import "prelude.bufo";
import "libc.bufo";
import "substr.bufo";
import "string.bufo";
import "bufo.bufo";
import "./lexer.bufo";
import "./token.bufo";
import "./nodes.bufo";
import "./context.bufo";
import "../util/lists.bufo";
import "../util/span.bufo";
import "../util/arena.bufo";
import "../middleend/checker.bufo";
import "../middleend/types.bufo";
import "../backend/irgen.bufo";
import "../backend/interp.bufo";
import "../backend/codegen_llvm.bufo";

@os(WINDOWS) import "winapi/functions.bufo";
@os(WINDOWS) import "winapi/structs.bufo";

@os(LINUX) import "posix/constants.bufo";
@os(LINUX) import "posix/functions.bufo";
@os(LINUX) import "posix/structs.bufo";

struct Parser {
    lexer: Lexer;
    importRoots: &String;
    importRootLength: usize;
    importRootCapacity: usize;
    syntaxError: bool;
}

func addImportRoot(this: &Parser, filePath: SubStr) {
    trace("Parser.addImportRoot");
    let root: String = getPathParent(&filePath);
    if (this.importRootLength >= this.importRootCapacity) {
        let newCap: usize = this.importRootCapacity * 2;
        if (newCap == 0) newCap = 1;
        this.importRoots = realloc(this.importRoots, newCap * sizeof String);
        assert(this.importRoots != null, "Could not resize import roots");
        this.importRootCapacity = newCap;
    }
    this.importRoots[this.importRootLength] = root;
    this.importRootLength = this.importRootLength + 1;
}

func getImportRootAtIndex(this: &Parser, index: usize) -> String {
    trace("Parser.getImportRootAtIndex");
    return copy(&this.importRoots[index]);
}

func inheritImportRoots(this: &Parser, parent: &Parser) {
    for (let i: usize = 0; i < parent.importRootLength; i = i + 1) {
        let root: String = getImportRootAtIndex(parent, i);
        addImportRoot(this, asSubStr(&root));
        drop(&root);
    }
}

func expectSoftIdentifier(this: &Parser) -> Token {
    trace("Parser.expectSoftIdentifier");
    let tkn: Token = next(&this.lexer);
    if (tkn.kind != TOKEN_KEYWORD && tkn.kind != TOKEN_IDENT) {
        let loc: String = getLocation(&tkn);
        let name: String = toString(&tkn.content);
        fprintf(stderr, "%s: %s: Expected Identifier, found `%s` instead.\n", loc.buffer, ERR_STR, name.buffer);
        drop(&name);
        drop(&loc);
        exit(1);
    }
    // These keywords serve a purpose in parsePrimaryExpr, there's no point in creating variables
    // with those names, because you could never use them.
    // FIXME: This check is very expensive, and we do this for every parameter and variable declaration
    // TODO:  Short-circuiting for logical binary expressions
    if (equals(&tkn.content, &KEYWORD_NULL)
        || equals(&tkn.content, &KEYWORD_TRUE)
        || equals(&tkn.content, &KEYWORD_FALSE)
        || equals(&tkn.content, &KEYWORD_BLANK)
        || equals(&tkn.content, &KEYWORD_SIZEOF)) {
        let loc: String = getLocation(&tkn);
        let name: String = toString(&tkn.content);
        fprintf(stderr, "%s: %s: Expected Identifier, found `%s` instead.\n", loc.buffer, ERR_STR, name.buffer);
        drop(&name);
        drop(&loc);
        exit(1);
    }
    return tkn;
}

func expect(this: &Parser, tknKind: usize) -> Token {
    trace("Parser.expect");
    let tkn: Token = next(&this.lexer);
    if (tkn.kind != tknKind) {
        let loc: String = getLocation(&tkn);
        let exp: &char = tokenKindToString(tknKind);
        let name: String = toString(&tkn.content);
        fprintf(stderr, "%s: %s: Expected %s, found `%s` instead.\n", loc.buffer, ERR_STR, exp, name.buffer);
        drop(&name);
        drop(&loc);
        exit(1);
    }
    return tkn;
}

func eat(this: &Parser, tknKind: usize) -> bool {
    if (at(this, tknKind)) {
        next(&this.lexer);
        return true;
    }
    return false;
}
func at(this: &Parser, tknKind: usize) -> bool {
    if (peek(&this.lexer).kind == tknKind) {
        return true;
    }
    return false;
}

func parsedEOF(this: &Parser) -> bool {
    return peek(&this.lexer).kind == TOKEN_EOF;
}

func parseProject(this: &Parser, root: SubStr) -> ParsedFile {
    trace("Parser.parseProject");
    assert(this.lexer.fileID == 0, "Expected Parser.parseProject to be the root");
    let rootFile: &ParsedFile = newParsedFile(root, this.lexer.content);
    assert(getID(rootFile) == 0, "Expected Parser.parseProject result to be the root");
    parseFile(this, root, rootFile);
    if (this.syntaxError) {
        // All errors are reported at this point
        exit(1);
    }
    return *rootFile;
}

func parseFile(this: &Parser, root: SubStr, file: &ParsedFile) {
    trace("Parser.parseFile");
    file.mod = newParsedModule(blank, blank, blank, blank);
    addImportRoot(this, root);
    while (!parsedEOF(this)) {
        let attributes: ParsedAttributeList = blank;
        let skip = parseAttributes(this, &attributes, false);
        if (skip) {
            debug("Parsed TopLevelItem, but skipping it because of @os()");
            toggleIgnoringNodes();
            let item: &ParsedTopLevelItem = parseTopLevelItem(this, attributes, skip);
            toggleIgnoringNodes();
        } else {
            let item: &ParsedTopLevelItem = parseTopLevelItem(this, attributes, skip);
            push(&file.mod.tlis, getID(item));
        }
    }
}

func parseAttributes(this: &Parser, attrs: &ParsedAttributeList, inModule: bool) -> bool {
    trace("Parser.parseAttributes");
    let skip: bool = false;
    while (eat(this, TOKEN_AT)) {
        let name = expectSoftIdentifier(this);
        if (equals(&name.content, &_ATTR_EXTERN)) {
            if (!inModule && *flags.warnExtra) {
                let loc = toString(&name.span);
                fprintf(stderr, "%s: %s: `@extern()` used outside of a module.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            expect(this, TOKEN_PAREN_OPEN);
            let v = expect(this, TOKEN_STRING_LITERAL);
            let end = expect(this, TOKEN_PAREN_CLOSE);
            push(attrs, ParsedAttribute {
                span: newSpanBetween(&name.span, &end.span),
                kind: ATTR_EXTERN,
                name: v,
            });
        } else if (equals(&name.content, &_ATTR_OS)) {
            expect(this, TOKEN_PAREN_OPEN);
            let os = expect(this, TOKEN_IDENT);
            expect(this, TOKEN_PAREN_CLOSE);
            if (!equals(&os.content, &OS_WINDOWS) && !equals(&os.content, &OS_LINUX)) {
                fprintf(stderr, "%s\n", toString(&os.content).buffer);
                todo_with_msg("Unknown os");
            }
            skip = !equals(&os.content, &asSubStr(flags.target));
        } else if (equals(&name.content, &_ATTR_NORETURN)) {
            push(attrs, ParsedAttribute {
                span: name.span,
                kind: ATTR_NORETURN,
            });
        } else {
            let loc = toString(&name.span);
            let n = toString(&name.content);
            fprintf(stderr, "%s: %s: Use of unknown attribute `%s`.\n", loc.buffer, ERR_STR, n.buffer);
            drop(&n);
            drop(&loc);
            this.syntaxError = true;
        }
    }
    return skip;
}

func parseTopLevelItem(this: &Parser, attributes: ParsedAttributeList, skip: bool) -> &ParsedTopLevelItem {
    return parseTopLevelItem(this, TLIParent { isFile: true, id: this.lexer.fileID as u32 }, attributes, skip);
}

func parseTopLevelItem(this: &Parser, parent: TLIParent, attributes: ParsedAttributeList, skip: bool) -> &ParsedTopLevelItem {
    trace("Parser.parseTopLevelItem");
    let tkn: Token = peek(&this.lexer);
    if (equals(&tkn.content, &KEYWORD_IMPORT)) {
        return parseImport(this, skip);
    } else if (equals(&tkn.content, &KEYWORD_CONFIG)) {
        return asTLI(parseConfig(this, parent, attributes));
    } else if (equals(&tkn.content, &KEYWORD_MODULE)) {
        // REVIEW: Do we want to support modules outside of TLIs?
        return asTLI(parseModule(this, parent, attributes));
    } else if (equals(&tkn.content, &KEYWORD_LET)) {
        next(&this.lexer);
        return asTLI(parseVarDeclStmt(this, tkn, true));
    } else if (equals(&tkn.content, &KEYWORD_COMPTIME)) {
        next(&this.lexer);
        return asTLI(parseVarDeclStmt(this, tkn, true));
    } else if (equals(&tkn.content, &KEYWORD_STRUCT)) {
        // REVIEW: Do we want to support structs outside of TLIs?
        return asTLI(parseStructDecl(this, parent));
    } else if (equals(&tkn.content, &KEYWORD_UNION)) {
        // REVIEW: Do we want to support unions outside of TLIs?
        return asTLI(parseUnionDecl(this, parent));
    } else if (equals(&tkn.content, &KEYWORD_FUNC)) {
        // REVIEW: Do we want to support functions outside of TLIs?
        let isExtern: bool = false;
        for (let i: usize = 0; i < attributes.length; i = i + 1) {
            if (at(&attributes, i).kind == ATTR_EXTERN) {
                isExtern = true;
                break;
            }
        }
        let decl = parseFuncDecl(this, parent, isExtern);
        decl.attrs = attributes;
        return asTLI(decl);
    } else {
        let loc: String = toString(&tkn.span);
        let name: String = toString(&tkn.content);
        fprintf(stderr, "%s: %s: Expected Top Level Keyword, found `%s` instead.\n", loc.buffer, ERR_STR, name.buffer);
        fprintf(stderr, "%s: %s: A non-exhaustive list of TLK: `import`, `let`, `comptime`, `struct`, `union`, `func`.\n", loc.buffer, NOTE_STR);
        drop(&name);
        drop(&loc);
        exit(1);
    }
}

func parseModule(this: &Parser, _parent: TLIParent, modAttr: ParsedAttributeList) -> &ParsedModule {
    trace("Parser.parseModule");
    let modTkn: Token = expect(this, TOKEN_KEYWORD);
    assert(equals(&modTkn.content, &KEYWORD_MODULE));
    let name = expectSoftIdentifier(this);
    let tlis: UsizeList = blank;
    expect(this, TOKEN_CURLY_OPEN);
    let mod = newParsedModule(_parent, blank, name, blank);
    let parent = TLIParent { isFile: false, id: getID(mod) as u32 };
    let anyExtern = false;
    while (!at(this, TOKEN_CURLY_CLOSE)) {
        let attributes: ParsedAttributeList = blank;
        let skip = parseAttributes(this, &attributes, true);
        for (let i: usize = 0; !anyExtern && i < attributes.length; i = i + 1) {
            if (at(&attributes, i).kind == ATTR_EXTERN) {
                anyExtern = true;
                break;
            }
        }
        if (skip) {
            debug("Parsed TopLevelItem, but skipping it because of @os()");
            toggleIgnoringNodes();
            let item: &ParsedTopLevelItem = parseTopLevelItem(this, parent, attributes, skip);
            toggleIgnoringNodes();
        } else {
            let item: &ParsedTopLevelItem = parseTopLevelItem(this, parent, attributes, skip);
            push(&tlis, getID(item));
        }
    }
    let end = expect(this, TOKEN_CURLY_CLOSE);
    let span = newSpanBetween(&modTkn.span, &end.span);
    mod.span = span;
    mod.tlis = tlis;
    if (anyExtern) {
        // Check if all DLLs can be loaded
        let modConfigs = UsizeList {};
        let anyLibrary = false;
        for (let i: usize = 0; i < tlis.length; i = i + 1) {
            let t = at(&topLevelItems, *at(&tlis, i));
            if (t.kind == TLI_CONFIG) {
                push(&modConfigs, *at(&tlis, i));
                let cfg = at(&configs, t.nodeID);
                let paths: TokenList = blank;
                push(&paths, newToken(mod.parent.id as usize, &newSubStrOfStrLit("."), 0, TOKEN_DOT));
                for (let j: usize = 0; j < cfg.configs.length; j = j + 1) {
                    let _cfg = at(&cfg.configs, j);
                    if (_cfg.kind == CONFIG_LIBPATH) {
                        push(&paths, _cfg.value);
                    }
                }
                for (let k: usize = 0; k < paths.length; k = k + 1) {
                    let _path = toString(&at(&paths, k).content);
                    let path = toAbsolutePath(&_path);
                    @os(WINDOWS) pushChar(&path, '\\');
                    @os(LINUX) pushChar(&path, '/');
                    for (let j: usize = 0; j < cfg.configs.length; j = j + 1) {
                        let _cfg = at(&cfg.configs, j);
                        if (_cfg.kind == CONFIG_LIBNAME) {
                            // TODO: On Linux shared libraries often start with `lib`, e.g. libraylib.so
                            anyLibrary = true;
                            let libPath = copy(&path);
                            pushSubStr(&libPath, &_cfg.value.content);
                            @os(WINDOWS) pushStr(&libPath, ".dll");
                            @os(LINUX) pushStr(&libPath, ".so");
                            if (*flags.verbose) printf("[INFO] Trying to load %s: ", libPath.buffer);
                            let file: Any = fopen(libPath.buffer, "r");
                            if (file == null) {
                                if (*flags.verbose) {
                                    @os(WINDOWS) printf("No such file or directory\n");
                                    @os(LINUX) printf("%s\n", strerror(*errno()));
                                }
                                drop(&libPath);
                                continue;
                            }
                            fclose(file);
                            @os(WINDOWS) let handle = LoadLibraryA(libPath.buffer);
                            @os(LINUX) let handle: Handle = dlopen(libPath.buffer, RTLD_LAZY);
                            if (isNull(handle)) {
                                if (*flags.verbose) {
                                    @os(WINDOWS) printf("Could not load DLL\n");
                                    @os(LINUX) printf("%s\n", dlerror());
                                }
                                drop(&libPath);
                                continue;
                            }
                            if (*flags.verbose) printf("Success. Handle = %p\n", handle.ptr);
                            push(&mod.dlls, getID(newDLL(libPath, handle)));
                        }
                    }
                    drop(&_path);
                    drop(&path);
                }
            }
        }
        if (modConfigs.length == 0) {
            let loc = toString(&mod.span);
            fprintf(stderr, "%s: %s: Module contains @extern() functions, but no config was specified.\n", loc.buffer, ERR_STR);
            fprintf(stderr, "%s: %s: The config contains important information such as linker flags and library paths.\n", loc.buffer, NOTE_STR);
            fprintf(stderr, "%s: %s: The config can be declared using the top level keyword `config` within the module.\n", loc.buffer, NOTE_STR);
            drop(&loc);
            this.syntaxError = true;
        } else if (!anyLibrary) {
            let loc = toString(&mod.span);
            fprintf(stderr, "%s: %s: Module contains @extern() functions, but no library was provided in the config.\n", loc.buffer, ERR_STR);
            for (let i: usize = 0; i < modConfigs.length; i = i + 1) {
                let t = at(&topLevelItems, *at(&modConfigs, i));
                assert(t.kind == TLI_CONFIG);
                drop(&loc);
                loc = toString(&t.span);
                fprintf(stderr, "%s: %s: Module configuration specified here.\n", loc.buffer, NOTE_STR);
            }
            drop(&loc);
            this.syntaxError = true;
        }
    }
    return mod;
}

func parseConfig(this: &Parser, parent: TLIParent, attributes: ParsedAttributeList) -> &ParsedConfig {
    trace("Parser.parseConfig");
    let cfgTkn: Token = expect(this, TOKEN_KEYWORD);
    assert(equals(&cfgTkn.content, &KEYWORD_CONFIG));
    expect(this, TOKEN_CURLY_OPEN);
    let flags: ConfigList = blank;
    while (!at(this, TOKEN_CURLY_CLOSE)) {
        let _cfg = expect(this, TOKEN_IDENT);
        expect(this, TOKEN_COLON_SINGLE);
        let value = expect(this, TOKEN_STRING_LITERAL);
        let cfg = newConfig(_cfg, value);
        if (cfg.kind == CONFIG_INVALID) {
            let loc = toString(&_cfg.span);
            let name = toString(&_cfg.content);
            fprintf(stderr, "%s: %s: Unknown config option `%s`.\n", loc.buffer, ERR_STR, name.buffer);
            fprintf(stderr, "%s: %s: A non-exhaustive list of config options: `library`, `libpath`, `linker`.\n", loc.buffer, NOTE_STR);
            drop(&name);
            drop(&loc);
            this.syntaxError = true;
        } else if (value.content.len == 0) {
            let loc = toString(&value.span);
            let name = toString(&_cfg.content);
            fprintf(stderr, "%s: %s: Value for config option `%s` can't be empty.\n", loc.buffer, ERR_STR, name.buffer);
            drop(&name);
            drop(&loc);
            this.syntaxError = true;
        } else {
            push(&flags, cfg);
        }
        if (!eat(this, TOKEN_COMMA)) break;
    }
    let end = expect(this, TOKEN_CURLY_CLOSE);
    return newParsedConfig(newSpanBetween(&cfgTkn.span, &end.span), flags);
}

func parseImport(this: &Parser, skip: bool) -> &ParsedTopLevelItem {
    trace("Parser.parseImport");
    let impTkn: Token = expect(this, TOKEN_KEYWORD);
    assert(equals(&impTkn.content, &KEYWORD_IMPORT));
    let tkn: Token = expect(this, TOKEN_STRING_LITERAL);
    let file: String = toString(&tkn.content);
    let src: String = blank;
    for (let i: usize = 0; i < this.importRootLength; i = i + 1) {
        let path: String = getImportRootAtIndex(this, i);
        pushString(&path, &file);
        path = toAbsolutePath(&path);
        if (canReadFileToString(path.buffer, &src)) {
            debug("Found file");
            debug(path.buffer);
            if (skip) {
                debug("Parsed import, but skipping it because of @os()");
                drop(&src); // No need to leak anything here :^)
                drop(&path);
                expect(this, TOKEN_SEMI_COLON);
                return null;
            }
            let fileID: usize = 0;
            let importedFile: &ParsedFile = null;
            if (getFileByFilePath(asSubStr(&path), &fileID)) {
                importedFile = at(&files, fileID);
            } else {
                importedFile = newParsedFile(asSubStr(&path), asSubStr(&src));
                fileID = getID(importedFile);
                // Note: We leak the source code of the imported file here :^)
                let parser: Parser = newParserFromSource(fileID, asSubStr(&src));
                inheritImportRoots(&parser, this);
                parseFile(&parser, asSubStr(&path), importedFile);
            }
            let end: Token = expect(this, TOKEN_SEMI_COLON);
            let span: Span = newSpanBetween(&impTkn.span, &end.span);
            let item: &ParsedTopLevelItem = newParsedTopLevelItem(span, TLI_IMPORT, fileID);
            return item;
        }
        drop(&path);
    }
    let loc: String = getLocation(&tkn);
    fprintf(stderr, "%s: %s: Could not import file %s.\n", loc.buffer, ERR_STR, file.buffer);
    exit(1);
}

func parseUnionDecl(this: &Parser, parent: TLIParent) -> &ParsedUnionDecl {
    trace("Parser.parseUnionDecl");
    let kw: Token = expect(this, TOKEN_KEYWORD);
    let nameTkn: Token = expectSoftIdentifier(this);
    expect(this, TOKEN_CURLY_OPEN);
    let decl: &ParsedUnionDecl = newParsedUnionDecl(parent, defaultSpan(), nameTkn);
    let unionParent = TLIParent { id: getID(decl) as u32 };
    while (!parsedEOF(this) && !at(this, TOKEN_CURLY_CLOSE)) {
        let variant = parseUnionVariant(this, unionParent);
        push(&decl.variants, variant);
        if (!at(this, TOKEN_CURLY_CLOSE)) {
            expect(this, TOKEN_COMMA);
        }
    }
    let end: Token = expect(this, TOKEN_CURLY_CLOSE);
    decl.span = newSpanBetween(&kw.span, &end.span);
    return decl;
}

func parseUnionVariant(this: &Parser, parent: TLIParent) -> &ParsedUnionVariant {
    trace("Parser.parseUnionVariant");
    let name = expectSoftIdentifier(this);
    if (eat(this, TOKEN_CURLY_OPEN)) {
        let variant = newParsedUnionVariant(UNION_VARIANT_STRUCT, parent, name.span, name);
        while (!parsedEOF(this) && !at(this, TOKEN_CURLY_CLOSE)) {
            let fieldName = expectSoftIdentifier(this);
            expect(this, TOKEN_COLON_SINGLE);
            let typ = parseTypeNode(this);
            addNamedField(variant, fieldName, typ);
            if (!at(this, TOKEN_CURLY_CLOSE)) {
                expect(this, TOKEN_COMMA);
            }
        }
        let end: Token = expect(this, TOKEN_CURLY_CLOSE);
        variant.span = newSpanBetween(&name.span, &end.span);
        return variant;
    } else if (eat(this, TOKEN_PAREN_OPEN)) {
        let variant = newParsedUnionVariant(UNION_VARIANT_TUPLE, parent, name.span, name);
        while (!parsedEOF(this) && !at(this, TOKEN_PAREN_CLOSE)) {
            let typ = parseTypeNode(this);
            addField(variant, typ);
            if (!at(this, TOKEN_PAREN_CLOSE)) {
                expect(this, TOKEN_COMMA);
            }
        }
        let end: Token = expect(this, TOKEN_PAREN_CLOSE);
        variant.span = newSpanBetween(&name.span, &end.span);
        return variant;
    } else {
        return newParsedUnionVariant(UNION_VARIANT_EMPTY, parent, name.span, name);
    }
}

func parseStructDecl(this: &Parser, parent: TLIParent) -> &ParsedStructDecl {
    trace("Parser.parseStructDecl");
    let kw: Token = expect(this, TOKEN_KEYWORD);
    let nameTkn: Token = expectSoftIdentifier(this);
    expect(this, TOKEN_CURLY_OPEN);
    let decl: &ParsedStructDecl = newParsedStructDecl(parent, defaultSpan(), nameTkn);
    let structContext: StructContext = blank;
    while (!parsedEOF(this) && !at(this, TOKEN_CURLY_CLOSE)) {
        let tkn = expectSoftIdentifier(this);
        expect(this, TOKEN_COLON_SINGLE);
        let typ: &ParsedTypeNode = parseTypeNode(this);
        addField(&structContext, tkn, typ);
        expect(this, TOKEN_SEMI_COLON);
    }
    let end: Token = expect(this, TOKEN_CURLY_CLOSE);
    let span: Span = newSpanBetween(&kw.span, &end.span);
    (*decl).span = span;
    (*decl).context = structContext;
    return decl;
}

func parseFuncDecl(this: &Parser, parent: TLIParent, isExtern: bool) -> &ParsedFuncDecl {
    trace("Parser.parseFuncDecl");
    let tkn: Token = expect(this, TOKEN_KEYWORD);
    if (!isExtern) assert(equals(&tkn.content, &KEYWORD_FUNC));
    let name: Token = expectSoftIdentifier(this);
    let params: ParamContext = parseParameters(this);
    let retType: &ParsedTypeNode = parseReturnType(this);
    if (isExtern) {
        let end: Token = expect(this, TOKEN_SEMI_COLON);
        let span: Span = newSpanBetween(&tkn.span, &end.span);
        return newParsedFuncDecl(parent, span, name, params, retType, null);
    } else {
        let body: &ParsedBlock = parseBlock(this);
        let span: Span = newSpanBetween(&tkn.span, &body.span);
        return newParsedFuncDecl(parent, span, name, params, retType, body);
    }
}

func parseReturnType(this: &Parser) -> &ParsedTypeNode {
    trace("Parser.parseReturnType");
    if (eat(this, TOKEN_ARROW_THIN)) {
        return parseTypeNode(this);
    } else {
        return newBuiltinTypeDecl(peek(&this.lexer).span, PARSED_TYPE_NONE);
    }
}

func parseParameters(this: &Parser) -> ParamContext {
    trace("Parser.parseParameters");
    expect(this, TOKEN_PAREN_OPEN);
    let context: ParamContext = blank;
    while (!parsedEOF(this) && !at(this, TOKEN_PAREN_CLOSE)) {
        if (eat(this, TOKEN_DOTDOTDOT)) {
            context.isVarArg = true;
            break;
        }
        let name: Token = expectSoftIdentifier(this);
        expect(this, TOKEN_COLON_SINGLE);
        let typ: &ParsedTypeNode = parseTypeNode(this);
        addParameter(&context, name, typ);
        if (!eat(this, TOKEN_COMMA)) {
            break;
        }
    }
    expect(this, TOKEN_PAREN_CLOSE);
    return context;
}

func parseBlock(this: &Parser) -> &ParsedBlock {
    trace("Parser.parseBlock");
    let block: &ParsedBlock = newParsedBlock();
    let start: Token = expect(this, TOKEN_CURLY_OPEN);
    while (!parsedEOF(this) && !at(this, TOKEN_CURLY_CLOSE)) {
        let attributes: ParsedAttributeList = blank;
        let skip = parseAttributes(this, &attributes, false);
        if (skip) {
            debug("Parsed Stmt, but skipping it because of @os()");
            toggleIgnoringNodes();
            let stmt: &ParsedStmt = parseStmt(this);
            toggleIgnoringNodes();
        } else {
            let stmt: &ParsedStmt = parseStmt(this);
            addStmt(block, stmt);
        }
    }
    let end: Token = expect(this, TOKEN_CURLY_CLOSE);
    (*block).span = newSpanBetween(&start.span, &end.span);
    return block;
}

func parseStmt(this: &Parser) -> &ParsedStmt {
    trace("Parser.parseStmt");
    let tkn: Token = peek(&this.lexer);
    if (tkn.kind == TOKEN_KEYWORD) {
        if (equals(&tkn.content, &KEYWORD_LET)
            || equals(&tkn.content, &KEYWORD_COMPTIME)) {
            next(&this.lexer);
            return parseVarDeclStmt(this, tkn, false);
        } else if (equals(&tkn.content, &KEYWORD_IF)) {
            next(&this.lexer);
            return parseIfStmt(this, tkn);
        } else if (equals(&tkn.content, &KEYWORD_RETURN)) {
            next(&this.lexer);
            return parseReturnStmt(this, tkn);
        } else if (equals(&tkn.content, &KEYWORD_WHILE)) {
            next(&this.lexer);
            return parseWhileStmt(this, tkn);
        } else if (equals(&tkn.content, &KEYWORD_FOR)) {
            next(&this.lexer);
            return parseForStmt(this, tkn);
        } else if (equals(&tkn.content, &KEYWORD_WHILE)) {
            next(&this.lexer);
            return parseWhileStmt(this, tkn);
        } else if (equals(&tkn.content, &KEYWORD_BREAK)) {
            next(&this.lexer);
            let end: Token = expect(this, TOKEN_SEMI_COLON);
            let span: Span = newSpanBetween(&tkn.span, &end.span);
            return newParsedStmt(span, StmtData::Break);
        } else if (equals(&tkn.content, &KEYWORD_CONTINUE)) {
            next(&this.lexer);
            let end: Token = expect(this, TOKEN_SEMI_COLON);
            let span: Span = newSpanBetween(&tkn.span, &end.span);
            return newParsedStmt(span, StmtData::Continue);
        } else if (equals(&tkn.content, &KEYWORD_MATCH)) {
            next(&this.lexer);
            return parseMatchStmt(this, tkn);
        }
    } else if (tkn.kind == TOKEN_CURLY_OPEN) {
        let block: &ParsedBlock = parseBlock(this);
        return newParsedStmt(block.span, StmtData::Block(block));
    }
    let value: &ParsedExpr = parseExpr(this);
    let end: Token = expect(this, TOKEN_SEMI_COLON);
    let span: Span = newSpanBetween(&value.span, &end.span);
    return newParsedStmt(span, StmtData::Expr(value));
}

func parseMatchStmt(this: &Parser, kw: Token) -> &ParsedStmt {
    trace("Parser.parseMatchStmt");
    assert(kw.kind == TOKEN_KEYWORD);
    expect(this, TOKEN_PAREN_OPEN);
    let expr = parseExpr(this);
    expect(this, TOKEN_PAREN_CLOSE);
    expect(this, TOKEN_CURLY_OPEN);
    let patterns: ParsedPatternList = blank;
    let stmts: ParsedStmtList = blank;
    while (!at(this, TOKEN_CURLY_CLOSE)) {
        let pt = parsePattern(this);
        expect(this, TOKEN_ARROW_THICK);
        let block = parseBlock(this);
        let stmt = into_stmt(block);
        if (!at(this, TOKEN_CURLY_CLOSE)) {
            eat(this, TOKEN_COMMA);
        }
        push(&patterns, pt);
        push(&stmts, stmt);
    }
    let end = expect(this, TOKEN_CURLY_CLOSE);
    let span = newSpanBetween(&kw.span, &end.span);
    if (patterns.length == 0) {
        todo_with_msg("parser: 0 arms in match");
    }
    return newParsedStmt(span, StmtData::Match(expr, patterns, stmts));
}

func parsePattern(this: &Parser) -> &ParsedPattern {
    trace("Parser.parsePattern");
    // REVIEW: next or peek?
    let tkn = next(&this.lexer);
    if (tkn.kind == TOKEN_IDENT) {
        if (eat(this, TOKEN_COLON_DOUBLE)) {
            let subpat = parsePattern(this);
            match (&subpat.data) {
                &Pattern::Struct(_, _) => { }
                &Pattern::Ident(_) => { }
                _ => {
                    todo_with_msg("parser: Path Pattern has non-struct non-ident as RHS");
                }
            }
            return newParsedPattern(tkn.span, Pattern::Path(tkn, subpat));
        } else if (eat(this, TOKEN_CURLY_OPEN)) {
            let subPatterns: ParsedPatternList = blank;
            while (!at(this, TOKEN_CURLY_CLOSE)) {
                let subpat = parsePattern(this);
                if (!at(this, TOKEN_CURLY_CLOSE)) {
                    if (tag(&subpat.data) == comptime tag(&Pattern::Rest)) {
                        let loc = toString(&next(&this.lexer).span);
                        fprintf(stderr, "%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n", loc.buffer, ERR_STR);
                        drop(&loc);
                        this.syntaxError = true;
                    } else {
                        expect(this, TOKEN_COMMA);
                    }
                }
                push(&subPatterns, subpat);
            }
            let end = expect(this, TOKEN_CURLY_CLOSE);
            let span = newSpanBetween(&tkn.span, &end.span);
            return newParsedPattern(span, Pattern::Struct(tkn, subPatterns));
        } else if (eat(this, TOKEN_PAREN_OPEN)) {
            let subPatterns: ParsedPatternList = blank;
            while (!at(this, TOKEN_PAREN_CLOSE)) {
                let subpat = parsePattern(this);
                if (!at(this, TOKEN_PAREN_CLOSE)) {
                    if (tag(&subpat.data) == comptime tag(&Pattern::Rest)) {
                        let loc = toString(&next(&this.lexer).span);
                        fprintf(stderr, "%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n", loc.buffer, ERR_STR);
                        drop(&loc);
                        this.syntaxError = true;
                    } else {
                        expect(this, TOKEN_COMMA);
                    }
                }
                push(&subPatterns, subpat);
            }
            let end = expect(this, TOKEN_PAREN_CLOSE);
            let span = newSpanBetween(&tkn.span, &end.span);
            return newParsedPattern(span, Pattern::Struct(tkn, subPatterns));
        } else {
            return newParsedPattern(tkn.span, Pattern::Ident(tkn));
        }
    } else if (tkn.kind == TOKEN_DOTDOT) {
        return newParsedPattern(tkn.span, Pattern::Rest);
    } else if (tkn.kind == TOKEN_KEYWORD) {
        if (equals(&tkn.content, &KEYWORD_TRUE)) {
            return newParsedPattern(tkn.span, Pattern::Boolean(true));
        } else if (equals(&tkn.content, &KEYWORD_FALSE)) {
            return newParsedPattern(tkn.span, Pattern::Boolean(false));
        } else if (equals(&tkn.content, &KEYWORD_NULL)) {
            return newParsedPattern(tkn.span, Pattern::Null);
        }
    } else if (tkn.kind == TOKEN_WILDCARD) {
        return newParsedPattern(tkn.span, Pattern::Wildcard);
    } else if (tkn.kind == TOKEN_AMPERSAND_SINGLE) {
        let underlying = parsePattern(this);
        let span = newSpanBetween(&tkn.span, &underlying.span);
        return newParsedPattern(span, Pattern::Reference(underlying));
    } else if (tkn.kind == TOKEN_INT_LITERAL) {
        return newParsedPattern(tkn.span, Pattern::Number(tkn));
    }
    let loc: String = getLocation(&tkn);
    let name: String = toString(&tkn.content);
    fprintf(stderr, "%s: %s: Expected Pattern, found `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    drop(&name);
    drop(&loc);
    exit(1);
}

func parseForStmt(this: &Parser, kw: Token) -> &ParsedStmt {
    trace("Parser.parseForStmt");
    assert(kw.kind == TOKEN_KEYWORD);
    if (!eat(this, TOKEN_PAREN_OPEN)) {
        todo_with_msg("for in loop");
    } else {
        // FIXME: parseStmt() expects the ;
        let block: &ParsedBlock = newParsedBlock();
        let init: &ParsedStmt = parseStmt(this);
        let cond: &ParsedExpr = parseExpr(this);
        expect(this, TOKEN_SEMI_COLON);
        let step: &ParsedExpr = parseExpr(this);
        expect(this, TOKEN_PAREN_CLOSE);
        let body: &ParsedStmt = parseStmt(this);
        let span: Span = newSpanBetween(&kw.span, &body.span);
        return newParsedStmt(span, StmtData::CFor {
            init: init,
            cond: cond,
            step: step,
            body: body
        });
    }
}

func parseWhileStmt(this: &Parser, kw: Token) -> &ParsedStmt {
    trace("Parser.parseWhileStmt");
    assert(kw.kind == TOKEN_KEYWORD);
    expect(this, TOKEN_PAREN_OPEN);
    let cond: &ParsedExpr = parseExpr(this);
    expect(this, TOKEN_PAREN_CLOSE);
    let body = parseStmt(this);
    let span: Span = newSpanBetween(&kw.span, &body.span);
    return newParsedStmt(span, StmtData::While(cond, body));
}

func parseReturnStmt(this: &Parser, kw: Token) -> &ParsedStmt {
    trace("Parser.parseReturnStmt");
    assert(kw.kind == TOKEN_KEYWORD);
    let value: &ParsedExpr = null;
    if (!at(this, TOKEN_SEMI_COLON))
        value = parseExpr(this);
    let end: Token = expect(this, TOKEN_SEMI_COLON);
    let span: Span = newSpanBetween(&kw.span, &end.span);
    if (value != null) {
        return newParsedStmt(span, StmtData::ReturnExpr(value));
    } else {
        return newParsedStmt(span, StmtData::ReturnEmpty);
    }
}

func parseIfStmt(this: &Parser, kw: Token) -> &ParsedStmt {
    trace("Parser.parseIfStmt");
    assert(kw.kind == TOKEN_KEYWORD);
    expect(this, TOKEN_PAREN_OPEN);
    let cond: &ParsedExpr = parseExpr(this);
    expect(this, TOKEN_PAREN_CLOSE);
    let ifBody: &ParsedStmt = parseStmt(this);
    let elseBody: &ParsedStmt = null;
    let end: Span = ifBody.span;
    let maybeElse: Token = peek(&this.lexer);
    if (maybeElse.kind == TOKEN_KEYWORD) {
        if (equals(&maybeElse.content, &KEYWORD_ELSE)) {
            expect(this, TOKEN_KEYWORD);
            elseBody = parseStmt(this);
            end = elseBody.span;
        }
    }
    let span: Span = newSpanBetween(&kw.span, &end);
    if (elseBody != null) {
        return newParsedStmt(span, StmtData::IfElse(cond, ifBody, elseBody));
    } else {
        return newParsedStmt(span, StmtData::If(cond, ifBody));
    }
}

func parseVarDeclStmt(this: &Parser, kw: Token, isGlobal: bool) -> &ParsedStmt {
    trace("Parser.parseVarDeclStmt");
    let nameTkn: Token = expectSoftIdentifier(this);
    let isComptime: bool = equals(&kw.content, &KEYWORD_COMPTIME);
    let type: &ParsedTypeNode = null;
    if (eat(this, TOKEN_COLON_SINGLE)) {
        type = parseTypeNode(this);
    }
    expect(this, TOKEN_EQUAL_SINGLE);
    let expr = parseExpr(this);
    let end: Token = expect(this, TOKEN_SEMI_COLON);
    let span: Span = newSpanBetween(&kw.span, &end.span);
    return newParsedStmt(span, StmtData::VarDecl(VarDecl {
        name: nameTkn,
        type: type,
        expr: expr,
        isComptime: isComptime,
        isGlobal: isGlobal,
        origin: this.lexer.fileID,
    }));
}

func parseTypeNode(this: &Parser) -> &ParsedTypeNode {
    trace("Parser.parseTypeNode");
    let loc: Token = peek(&this.lexer);
    if (at(this, TOKEN_KEYWORD)) {
        let kw = peek(&this.lexer);
        if (!equals(&kw.content, &KEYWORD_FUNC)) {
            expectSoftIdentifier(this);
        }
        next(&this.lexer);
        expect(this, TOKEN_PAREN_OPEN);
        let params: ParsedTypeNodeList = blank;
        while (!at(this, TOKEN_PAREN_CLOSE)) {
            let pt = parseTypeNode(this);
            if (!at(this, TOKEN_PAREN_CLOSE)) {
                expect(this, TOKEN_COMMA);
            }
            push(&params, pt);
        }
        expect(this, TOKEN_PAREN_CLOSE);
        let retType = parseReturnType(this);
        let span = newSpanBetween(&kw.span, &retType.span);
        let funcNode = newParsedTypeNode(span, PARSED_TYPE_FUNC);
        funcNode.underlyingID = retType;
        funcNode.fnParams = params;
        return funcNode;
    } else if (eat(this, TOKEN_AMPERSAND_DOUBLE)) {
        let kw: Token = peek(&this.lexer);
        let typ: &ParsedTypeNode = parseTypeNode(this);
        let span: Span = newSpanBetween(&loc.span, &typ.span);
        let ptr1: &ParsedTypeNode = newParsedTypeNode(span, PARSED_TYPE_REF);
        (*ptr1).underlyingID = typ;
        let ptr: &ParsedTypeNode = newParsedTypeNode(span, PARSED_TYPE_REF);
        (*ptr).underlyingID = ptr1;
        return ptr;
    } else if (eat(this, TOKEN_AMPERSAND_SINGLE)) {
        let kw: Token = peek(&this.lexer);
        let typ: &ParsedTypeNode = parseTypeNode(this);
        let span: Span = newSpanBetween(&loc.span, &typ.span);
        let ptr: &ParsedTypeNode = newParsedTypeNode(span, PARSED_TYPE_REF);
        (*ptr).underlyingID = typ;
        return ptr;
    } else if (eat(this, TOKEN_SQUARE_OPEN)) {
        let typ: &ParsedTypeNode = parseTypeNode(this);
        expect(this, TOKEN_SEMI_COLON);
        let size: Token = expect(this, TOKEN_INT_LITERAL);
        let _size: String = toString(&size.content);
        let end: Token = expect(this, TOKEN_SQUARE_CLOSE);
        let span: Span = newSpanBetween(&loc.span, &end.span);
        let arr: &ParsedTypeNode = newParsedTypeNode(span, PARSED_TYPE_ARRAY);
        (*arr).underlyingID = typ;
        (*arr).arraySize = toU64(&_size) as usize;
        drop(&_size);
        return arr;
    } else {
        let nameTkn: Token = expectSoftIdentifier(this);
        if (at(this, TOKEN_COLON_DOUBLE)) {
            let node = newParsedTypeNode(nameTkn.span, PARSED_TYPE_MODULE);
            let orig = node;
            node.nameTkn = nameTkn;
            while (eat(this, TOKEN_COLON_DOUBLE)) {
                let typeTkn = expectSoftIdentifier(this);
                let span = newSpanBetween(&node.span, &typeTkn.span);
                let newNode = newParsedTypeNode(span, PARSED_TYPE_MODULE);
                newNode.nameTkn = typeTkn;
                node.underlyingID = newNode;
                node = newNode;
            }
            return orig;
        } else {
            let maybeBuiltin: usize = getBuiltinTypeKind(nameTkn);
            if (maybeBuiltin == 0) {
                // Not a builtin, must resolve later
                let typ: &ParsedTypeNode = newParsedTypeNode(nameTkn.span, PARSED_TYPE_IDENT);
                (*typ).nameTkn = nameTkn;
                return typ;
            } else {
                return newBuiltinTypeDecl(nameTkn.span, maybeBuiltin);
            }
        }
    }
}

func parseExpr(this: &Parser) -> &ParsedExpr {
    trace("Parser.parseExpr");
    return __parseExpr(this, 0, Assoc::Left);
}
func __parseExpr(this: &Parser, precedence: usize, associativity: Assoc) -> &ParsedExpr {
    trace("Parser.__parseExpr");
    let expr: &ParsedExpr = parsePrimaryExpr(this);
    while (matchesBinaryExpr(this)) {
        let tkn: Token = peek(&this.lexer);
        let newPrec: usize = getBinaryPrecedence(this, &tkn);
        if (newPrec < precedence)
            break;
        if (newPrec == precedence && tag(&associativity) == comptime tag(&Assoc::Left))
            break;
        let newAssoc = getBinaryAssociativity(this, &tkn);
        expr = parseSecondaryExpr(this, expr, newPrec, newAssoc);
    }
    return expr;
}
func parsePrimaryExpr(this: &Parser) -> &ParsedExpr {
    trace("Parser.parsePrimaryExpr");
    if (matchesUnaryExpr(this))
        return parseUnaryExpr(this);
    let tknKind: usize = peek(&this.lexer).kind;
    if (tknKind == TOKEN_INT_LITERAL) {
        let number = expect(this, TOKEN_INT_LITERAL);
        return newParsedExpr(number.span, ExprData::IntLit(number));
    } else if (tknKind == TOKEN_STRING_LITERAL) {
        let str = expect(this, TOKEN_STRING_LITERAL);
        return newParsedExpr(str.span, ExprData::StrLit(str));
    } else if (tknKind == TOKEN_CHAR_LITERAL) {
        let ch = expect(this, TOKEN_CHAR_LITERAL);
        return newParsedExpr(ch.span, ExprData::CharLit(ch));
    } else if (tknKind == TOKEN_PAREN_OPEN) {
        expect(this, TOKEN_PAREN_OPEN);
        let expr: &ParsedExpr = parseExpr(this);
        expect(this, TOKEN_PAREN_CLOSE);
        return expr;
    } else if (tknKind == TOKEN_SQUARE_OPEN) {
        let start: Token = expect(this, TOKEN_SQUARE_OPEN);
        let arrayContext: ArrayContext = blank;
        while (!parsedEOF(this) && !at(this, TOKEN_SQUARE_CLOSE)) {
            let expr: &ParsedExpr = parseExpr(this);
            addElement(&arrayContext, expr);
            if (eat(this, TOKEN_SEMI_COLON)) {
                if (arrayContext.elemLength != 1) todo_with_msg("array lit with given size too many elements");
                let size: Token = expect(this, TOKEN_INT_LITERAL);
                let _size: String = toString(&size.content);
                arrayContext.size = toU64(&_size) as usize;
                drop(&_size);
                break;
            }
            if (!eat(this, TOKEN_COMMA))
                break;
        }
        let end: Token = expect(this, TOKEN_SQUARE_CLOSE);
        let span: Span = newSpanBetween(&start.span, &end.span);
        return newParsedExpr(span, ExprData::ArrayLit(arrayContext));
    } else if (tknKind == TOKEN_KEYWORD || tknKind == TOKEN_IDENT) {
        let ident: Token = expect(this, tknKind);
        // Note: If you ever add a keyword here, you must adjust expectSoftIdentifier(this) accordingly
        if (equals(&ident.content, &KEYWORD_NULL)) {
            return newParsedExpr(ident.span, ExprData::Null);
        } else if (equals(&ident.content, &KEYWORD_TRUE)) {
            return newParsedExpr(ident.span, ExprData::True);
        } else if (equals(&ident.content, &KEYWORD_FALSE)) {
            return newParsedExpr(ident.span, ExprData::False);
        } else if (equals(&ident.content, &KEYWORD_BLANK)) {
            return newParsedExpr(ident.span, ExprData::Blank);
        } else if (equals(&ident.content, &KEYWORD_SIZEOF)) {
            let typ: &ParsedTypeNode = parseTypeNode(this);
            let span: Span = newSpanBetween(&ident.span, &typ.span);
            return newParsedExpr(span, ExprData::Sizeof(typ));
        } else if (at(this, TOKEN_CURLY_OPEN)) {
            expect(this, TOKEN_CURLY_OPEN);
            let context: StructInitContext = blank;
            while (!parsedEOF(this) && !at(this, TOKEN_CURLY_CLOSE)) {
                let name: Token = expectSoftIdentifier(this);
                expect(this, TOKEN_COLON_SINGLE);
                let expr: &ParsedExpr = parseExpr(this);
                addField(&context, name, expr);
                if (!eat(this, TOKEN_COMMA))
                    break;
            }
            let end: Token = expect(this, TOKEN_CURLY_CLOSE);
            let span: Span = newSpanBetween(&ident.span, &end.span);
            return newParsedExpr(span, ExprData::StructInit(StructExpr {
                name: ident,
                context: context
            }));
        } else {
            return newParsedExpr(ident.span, ExprData::Ident(IdentExpr {
                name: ident
            }));
        }
    }
    let t: Token = peek(&this.lexer);
    let loc: String = getLocation(&t);
    let name: String = toString(&t.content);
    fprintf(stderr, "%s: %s: Expected Expression, found `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    drop(&name);
    drop(&loc);
    exit(1);
}
func parseSecondaryExpr(this: &Parser, lhs: &ParsedExpr, precedence: usize, associativity: Assoc) -> &ParsedExpr {
    trace("Parser.parseSecondaryExpr");
    assert(matchesBinaryExpr(this));
    let opTkn: Token = next(&this.lexer);
    if (equals(&opTkn.content, &KEYWORD_AS)) {
        let typ: &ParsedTypeNode = parseTypeNode(this);
        let span: Span = newSpanBetween(&lhs.span, &typ.span);
        return newParsedExpr(span, ExprData::As(lhs, typ));
    }
    let rhs: &ParsedExpr = null;
    // FIXME: There's no reason why those things should be secondary expressions
    //        `foo{}` is a primary expression, but `foo()` and `foo[]` arent?
    // TODO:  Remove BIN_INDEXED_ACCESS and BIN_CALL (todo.py: There's a related FIXME one line above this)
    if (opTkn.kind == TOKEN_SQUARE_OPEN) {
        rhs = __parseExpr(this, 0, associativity);
        expect(this, TOKEN_SQUARE_CLOSE);
    } else if (opTkn.kind == TOKEN_PAREN_OPEN) {
        let args: ParsedExprList = blank;
        while (!parsedEOF(this) && !at(this, TOKEN_PAREN_CLOSE)) {
            push(&args, parseExpr(this));
            if (!eat(this, TOKEN_COMMA))
                break;
        }
        let end: Token = expect(this, TOKEN_PAREN_CLOSE);
        let span: Span = newSpanBetween(&lhs.span, &end.span);
        return newParsedExpr(span, ExprData::Call(CallExpr {
            span: span,
            base: lhs,
            args: args
        }));
    } else {
        rhs = __parseExpr(this, precedence, associativity);
    }
    if (opTkn.kind == TOKEN_DOT) {
        match (&rhs.data) {
            &ExprData::Ident(_) => { },
            _ => {
                fprintf(stderr, "%s: %s: The right side of `.` must be an identifier.\n", toString(&lhs.span).buffer, ERR_STR);
                this.syntaxError = true;
            }
        }
    } else if (opTkn.kind == TOKEN_COLON_DOUBLE) {
        match (&lhs.data) {
            &ExprData::Binary(BinaryExpr::Path(_, _)) => { },
            &ExprData::Ident(_) => { },
            _ => {
                fprintf(stderr, "%s: %s: The left side of `::` must be an identifier or other module specifier.\n", toString(&lhs.span).buffer, ERR_STR);
                this.syntaxError = true;
            }
        }
    }
    let span: Span = newSpanBetween(&lhs.span, &rhs.span);
    return newParsedExpr(span, ExprData::Binary(fromTkn(opTkn.kind, lhs, rhs)));
}
func parseUnaryExpr(this: &Parser) -> &ParsedExpr {
    trace("Parser.parseUnaryExpr");
    let tkn: Token = peek(&this.lexer);
    if (tkn.kind == TOKEN_KEYWORD) {
        next(&this.lexer);
        assert(equals(&tkn.content, &KEYWORD_COMPTIME), "Expected `comptime`");
        let precedence: usize = getUnaryPrecedence(this, tkn.kind);
        let expr: &ParsedExpr = __parseExpr(this, precedence, Assoc::Left);
        let span: Span = newSpanBetween(&tkn.span, &expr.span);
        return newParsedExpr(span, ExprData::Unary(UnaryExpr::Comptime(expr)));
    } else if (tkn.kind == TOKEN_AMPERSAND_DOUBLE) {
        next(&this.lexer);
        let precedence: usize = getUnaryPrecedence(this, TOKEN_AMPERSAND_SINGLE);
        let expr: &ParsedExpr = __parseExpr(this, precedence, Assoc::Left);
        let span: Span = newSpanBetween(&tkn.span, &expr.span);
        let inner = newParsedExpr(span, ExprData::Unary(UnaryExpr::Ref(expr)));
        return newParsedExpr(span, ExprData::Unary(UnaryExpr::Ref(inner)));
    } else if (tkn.kind == TOKEN_ASTERISK_SINGLE
        || tkn.kind == TOKEN_AMPERSAND_SINGLE
        || tkn.kind == TOKEN_MINUS_SINGLE
        || tkn.kind == TOKEN_BANG) {
        next(&this.lexer);
        let precedence: usize = getUnaryPrecedence(this, tkn.kind);
        let expr: &ParsedExpr = __parseExpr(this, precedence, Assoc::Left);
        let span: Span = newSpanBetween(&tkn.span, &expr.span);
        return newParsedExpr(span, ExprData::Unary(fromTkn(tkn.kind, expr)));
    } else {
        unreachable("Exhaustive handling of unary operations in parseUnaryExpr");
    }
}
func matchesBinaryExpr(this: &Parser) -> bool {
    trace("Parser.matchesBinaryExpr");
    let tknKind: usize = peek(&this.lexer).kind;
    if (tknKind == TOKEN_KEYWORD)
        return equals(&peek(&this.lexer).content, &KEYWORD_AS);
    return tknKind == TOKEN_EQUAL_DOUBLE
        || tknKind == TOKEN_EQUAL_SINGLE
        || tknKind == TOKEN_NOT_EQUAL
        || tknKind == TOKEN_MINUS_SINGLE
        || tknKind == TOKEN_PLUS_SINGLE
        || tknKind == TOKEN_ASTERISK_SINGLE
        || tknKind == TOKEN_SLASH_SINGLE
        || tknKind == TOKEN_LESS_THAN_EQUAL
        || tknKind == TOKEN_LESS_THAN
        || tknKind == TOKEN_GREATER_THAN_EQUAL
        || tknKind == TOKEN_GREATER_THAN
        || tknKind == TOKEN_AMPERSAND_SINGLE
        || tknKind == TOKEN_AMPERSAND_DOUBLE
        || tknKind == TOKEN_PIPE_DOUBLE
        || tknKind == TOKEN_PIPE_SINGLE
        || tknKind == TOKEN_CARET
        // FIXME: :: should be an identifier, not a binary expression
        || tknKind == TOKEN_COLON_DOUBLE
        || tknKind == TOKEN_DOT
        || tknKind == TOKEN_PAREN_OPEN
        || tknKind == TOKEN_SQUARE_OPEN
        || tknKind == TOKEN_PERCENT;
}
func matchesUnaryExpr(this: &Parser) -> bool {
    trace("Parser.matchesUnaryExpr");
    let tknKind: usize = peek(&this.lexer).kind;
    if (tknKind == TOKEN_KEYWORD)
        return equals(&peek(&this.lexer).content, &KEYWORD_COMPTIME);
    return tknKind == TOKEN_MINUS_SINGLE
        || tknKind == TOKEN_AMPERSAND_SINGLE
        // FIXME: Would be cooler if peek() could return split tokens too
        || tknKind == TOKEN_AMPERSAND_DOUBLE
        || tknKind == TOKEN_ASTERISK_SINGLE
        || tknKind == TOKEN_BANG;
}
func getBinaryPrecedence(this: &Parser, tkn: &Token) -> usize {
    trace("Parser.getBinaryPrecedence");
    let tknKind: usize = tkn.kind;
    if (tknKind == TOKEN_COLON_DOUBLE) return 18;
    else if (tknKind == TOKEN_DOT) return 17;
    else if (tknKind == TOKEN_PAREN_OPEN) return 16;
    else if (tknKind == TOKEN_SQUARE_OPEN) return 16;
    else if (tknKind == TOKEN_KEYWORD) {
        assert(equals(&tkn.content, &KEYWORD_AS), "unsupported keyword in getBinaryPrecedence");
        return 13;
    } else if (tknKind == TOKEN_SLASH_SINGLE) return 12;
    else if (tknKind == TOKEN_ASTERISK_SINGLE) return 12;
    else if (tknKind == TOKEN_PERCENT) return 12;
    else if (tknKind == TOKEN_PLUS_SINGLE) return 11;
    else if (tknKind == TOKEN_MINUS_SINGLE) return 11;
    else if (tknKind == TOKEN_LESS_THAN) return 9;
    else if (tknKind == TOKEN_LESS_THAN_EQUAL) return 9;
    else if (tknKind == TOKEN_GREATER_THAN) return 9;
    else if (tknKind == TOKEN_GREATER_THAN_EQUAL) return 9;
    else if (tknKind == TOKEN_EQUAL_DOUBLE) return 8;
    else if (tknKind == TOKEN_NOT_EQUAL) return 8;
    else if (tknKind == TOKEN_AMPERSAND_SINGLE) return 7;
    else if (tknKind == TOKEN_CARET) return 6;
    else if (tknKind == TOKEN_PIPE_SINGLE) return 5;
    else if (tknKind == TOKEN_AMPERSAND_DOUBLE) return 4;
    else if (tknKind == TOKEN_PIPE_DOUBLE) return 3;
    else if (tknKind == TOKEN_EQUAL_SINGLE) return 2;
    unreachable("Exhaustive handling of binary operators in Parser.getBinaryPrecedence");
}
func getBinaryAssociativity(this: &Parser, tkn: &Token) -> Assoc {
    trace("Parser.getBinaryAssociativity");
    let tknKind: usize = tkn.kind;
    if (tknKind == TOKEN_EQUAL_SINGLE) return Assoc::Right;
    return Assoc::Left;
}
func getUnaryPrecedence(this: &Parser, tknKind: usize) -> usize {
    // FIXME: We can't know if this is actually KEYWORD_COMPTIME
    if (tknKind == TOKEN_KEYWORD) return 14;
    else if (tknKind == TOKEN_MINUS_SINGLE) return 14;
    else if (tknKind == TOKEN_ASTERISK_SINGLE) return 14;
    else if (tknKind == TOKEN_AMPERSAND_SINGLE) return 14;
    else if (tknKind == TOKEN_BANG) return 14;
    unreachable("Exhaustive handling of unary operators in Parser.getUnaryPrecedence");
}

func newParserFromSource(fileID: usize, src: SubStr) -> Parser {
    return Parser {
        lexer: newLexer(fileID, src),
        importRoots: null,
        importRootLength: 0,
        importRootCapacity: 0,
        syntaxError: false,
    };
}
