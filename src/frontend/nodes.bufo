import "prelude.bufo";
import "libc.bufo";
import "substr.bufo";
import "string.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "./context.bufo";
import "./token.bufo";
import "./lexer.bufo";
import "../middleend/checker.bufo";
import "../middleend/types.bufo";

// Arbitrary number chosen as a magic constant for various things
// idea: We'll never have more than that many expressions or type nodes
//       if you ever have 10 billion expressions, please tell me how :^)
comptime NODE_ID_OFFSET: usize = 10000000000;

let ignoringNodes = false;
func toggleIgnoringNodes() {
    ignoringNodes = !ignoringNodes;
}

func mangleVariableName(
    moduleID: usize,
    name: &Token,
) -> String {
    if (moduleID == NODE_ID_OFFSET) {
        return toString(&name.content);
    } else {
        let mangledName: String = blank;
        pushNumber(&mangledName, moduleID);
        pushSubStr(&mangledName, &name.content);
        return mangledName;
    }
}

func mangleFunctionName(
    parentID: usize,
    name: &Token,
    params: &ParamContext,
    retTypeID: usize,
    isComptime: bool,
    attrs: &ParsedAttributeList,
) -> String {
    let mangledName: String = blank;
    for (let i: usize = 0; i < attrs.length; i = i + 1) {
        let a = at(attrs, i);
        if (a.kind == ATTR_EXTERN) return toString(&a.name.content);
    }
    // Function: Name-ParamsTypeID-rRetTypeID
    pushSubStr(&mangledName, &name.content);
    for (let i: usize = 0; i < params.paramLength; i = i + 1) {
        let name: Token = getNameAtIndex(params, i);
        let id: usize = getTypeAtIndex(params, i);
        let typeNode: &ParsedTypeNode = at(&typeNodes, id);
        assert(isSuccess(&typeNode.typeState), "Expected valid parameter type for mangling");
        let typ: &Type = at(&types, getType(&typeNode.typeState));
        let _typ: String = getMangledName(typ);
        pushString(&mangledName, &_typ);
        drop(&_typ);
    }
    pushChar(&mangledName, 'r');
    if (retTypeID != 0) {
        let retNode: &ParsedTypeNode = at(&typeNodes, retTypeID);
        assert(isSuccess(&retNode.typeState), "Expected valid return type for mangling");
        let typ: &Type = at(&types, getType(&retNode.typeState));
        let _typ: String = getMangledName(typ);
        pushString(&mangledName, &_typ);
        drop(&_typ);
    } else {
        pushChar(&mangledName, 'n');
    }
    return mangledName;
}

let modules: ParsedModuleArena = blank;
let topLevelItems: ParsedTopLevelItemArena = blank;
let structDecls: ParsedStructDeclArena = blank;
let funcDecls: ParsedFuncDeclArena = blank;
let blocks: ParsedBlockArena = blank;
let stmts: ParsedStmtArena = blank;
let typeNodes: ParsedTypeNodeArena = blank;
let exprs: ParsedExprArena = blank;
let compilerFlags: ParsedCompilerFlagArena = blank;

func getModuleByFilePath(path: SubStr, moduleID: &usize) -> bool {
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        if (equals(&mod.origin, &path)) {
            *moduleID = i;
            return true;
        }
    }
    return false;
}

comptime _ATTR_EXTERN: SubStr = BUILD_A_KEYWORD("extern");
comptime _ATTR_OS: SubStr = BUILD_A_KEYWORD("os");
comptime _ATTR_NORETURN: SubStr = BUILD_A_KEYWORD("noreturn");

comptime ATTR_INVALID: usize = 0;
comptime ATTR_EXTERN: usize = 1;
comptime ATTR_OS: usize = 2; // not used, handled in parser directly
comptime ATTR_NORETURN: usize = 3;
struct ParsedAttribute {
    kind: usize;
    span: Span;
    name: Token;
}

func equals(this: &ParsedAttribute, other: &ParsedAttribute) -> bool {
    unreachable("ParsedAttribute.equals is not implemented yet");
}

comptime COMPILER_FLAG_LIBRARY: SubStr = BUILD_A_KEYWORD("library");
comptime COMPILER_FLAG_LIBPATH: SubStr = BUILD_A_KEYWORD("libpath");
comptime COMPILER_FLAG_LINKER: SubStr = BUILD_A_KEYWORD("linker");
struct ParsedCompilerFlag {
    flag: Token;
    value: Token;
}
func equals(this: &ParsedCompilerFlag, other: &ParsedCompilerFlag) -> bool {
    if (!equals(&this.flag.content, &other.flag.content)) return false;
    return equals(&this.value.content, &other.value.content);
}

func newParsedCompilerFlag(flag: Token, value: Token) -> &ParsedCompilerFlag {
    let f: &SubStr = &flag.content;
    if (!equals(f, &COMPILER_FLAG_LIBRARY)
        && !equals(f, &COMPILER_FLAG_LIBPATH)
        && !equals(f, &COMPILER_FLAG_LINKER)) {
        todo_with_msg("unknown compiler_flag");
    }
    push(&compilerFlags, ParsedCompilerFlag {
        flag: flag,
        value: value,
    });
    return last(&compilerFlags);
}

struct ParsedModule {
    ignored: bool;
    origin: SubStr;
    tliList: &usize;
    tliLength: usize;
    tliCapacity: usize;
}

func getID(this: &ParsedModule) -> usize {
    trace("ParsedModule.getID");
    return indexOf(&modules, this);
}

func addTopLevelItem(this: &ParsedModule, tli: &ParsedTopLevelItem) {
    trace("ParsedModule.addTopLevelItem");
    if (this.tliLength >= this.tliCapacity) {
        let newCap: usize = this.tliCapacity * 2;
        if (newCap == 0) newCap = 1;
        this.tliList = realloc(this.tliList, newCap * sizeof usize);
        assert(this.tliList != null, "Could not resize tli list");
        this.tliCapacity = newCap;
    }
    this.tliList[this.tliLength] = getID(tli);
    this.tliLength = this.tliLength + 1;
}

func getTopLevelItemAtIndex(this: &ParsedModule, index: usize) -> usize {
    assert(index < this.tliLength, "Out of bounds access in getTopLevelItemAtIndex");
    return this.tliList[index];
}

func newParsedModule(origin: SubStr) -> &ParsedModule {
    trace("newParsedModule");
    push(&modules, ParsedModule {
        ignored: ignoringNodes,
        origin: origin,
    });
    return last(&modules);
}

comptime TLI_INVALID: usize = 0;
comptime TLI_IMPORT: usize = 1;
comptime TLI_VAR_DECL: usize = 2;
comptime TLI_STRUCT_DECL: usize = 3;
comptime TLI_FUNC_DECL: usize = 4;
struct ParsedTopLevelItem {
    ignored: bool;
    kind: usize;
    span: Span;
    nodeID: usize;
    attributes: ParsedAttributeList;
    typeState: TCState;
}

func getID(this: &ParsedTopLevelItem) -> usize {
    trace("ParsedTopLevelItem.getID");
    return indexOf(&topLevelItems, this);
}

func newParsedTopLevelItem(span: Span, kind: usize, nodeID: usize) -> &ParsedTopLevelItem {
    trace("newParsedTopLevelItem");
    push(&topLevelItems, ParsedTopLevelItem {
        ignored: ignoringNodes,
        kind: kind,
        span: span,
        nodeID: nodeID,
        typeState: blank,
    });
    return last(&topLevelItems);
}

struct ParsedStructDecl {
    ignored: bool;
    parentModule: usize;
    name: Token;
    span: Span;
    context: StructContext;
    typeState: TCState;
}
func getID(this: &ParsedStructDecl) -> usize {
    trace("ParsedStructDecl.getID");
    return indexOf(&structDecls, this);
}
func asTLI(this: &ParsedStructDecl) -> &ParsedTopLevelItem {
    trace("ParsedStructDecl.asTLI");
    return newParsedTopLevelItem(this.span, TLI_STRUCT_DECL, getID(this));
}

func getFieldIndex(this: &ParsedStructDecl, name: &SubStr) -> usize {
    return getFieldIndex(&this.context, name);
}
func getFieldOffset(this: &ParsedStructDecl, name: &SubStr) -> usize {
    let offset: usize = 0;
    let _idc: usize = 0;
    getFieldOffsetAndSize(this, getFieldIndex(this, name), &offset, &_idc);
    return offset;
}
func getFieldOffsetAndSize(this: &ParsedStructDecl, index: usize, offset: &usize, size: &usize) {
    trace("ParsedStructDecl.getFieldOffsetAndSize");
    let o: usize = 0;
    for (let i: usize = 0; i < this.context.fieldLength; i = i + 1) {
        let field: usize = getFieldTypeAtIndex(&this.context, i);
        let f1: &ParsedTypeNode = at(&typeNodes, field);
        let f: &Type = at(&types, getType(&f1.typeState));
        let s: usize = getSize(f);
        s = nextMultipleOf(s, getAlignment(f));
        if (i == index) {
            *offset = o;
            *size = s;
            return;
        }
        o = o + s;
    }
    unreachable("Expected to find field offset and size");
}

func newParsedStructDecl(parent: usize, span: Span, name: Token) -> &ParsedStructDecl {
    trace("newParsedStructDecl");
    push(&structDecls, ParsedStructDecl {
        ignored: ignoringNodes,
        parentModule: parent,
        name: name,
        span: span,
        context: blank,
        typeState: blank,
    });
    return last(&structDecls);
}

struct ParsedFuncDecl {
    ignored: bool;
    parentID: usize;
    name: Token;
    span: Span;
    params: ParamContext;
    retTypeID: usize;
    body: usize;
    attrs: ParsedAttributeList;
    isComptime: bool;
    typeState: TCState;
}

func getID(this: &ParsedFuncDecl) -> usize {
    trace("ParsedFuncDecl.getID");
    return indexOf(&funcDecls, this);
}

func isExtern(this: &ParsedFuncDecl) -> bool {
    trace("ParsedFuncDecl.isExtern");
    for (let i: usize = 0; i < this.attrs.length; i = i + 1) {
        if (at(&this.attrs, i).kind == ATTR_EXTERN) return true;
    }
    return false;
}

func getMangledName(this: &ParsedFuncDecl) -> String {
    trace("ParsedFuncDecl.getMangledName");
    if (this.ignored) return toString(&this.name.content);
    assert(isSuccess(&this.typeState), "Mangling can only be done after type checks");
    return mangleFunctionName(
        this.parentID,
        &this.name,
        &this.params,
        this.retTypeID,
        this.isComptime,
        &this.attrs,
    );
}

func asTLI(this: &ParsedFuncDecl) -> &ParsedTopLevelItem {
    trace("ParsedFuncDecl.asTLI");
    return newParsedTopLevelItem(this.span, TLI_FUNC_DECL, getID(this));
}

func newParsedFuncDecl(parentID: usize, span: Span, name: Token, params: ParamContext, retType: &ParsedTypeNode, body: usize) -> &ParsedFuncDecl {
    push(&funcDecls, ParsedFuncDecl {
        ignored: ignoringNodes,
        parentID: parentID,
        name: name,
        span: span,
        params: params,
        retTypeID: getID(retType),
        body: body,
        isComptime: false,
        typeState: blank,
    });
    return last(&funcDecls);
}

struct ParsedBlock {
    ignored: bool;
    span: Span;
    stmtList: &usize;
    stmtLength: usize;
    stmtCapacity: usize;
    typeState: TCState;
}

func getID(this: &ParsedBlock) -> usize {
    trace("ParsedBlock.getID");
    return indexOf(&blocks, this);
}
func addStmt(this: &ParsedBlock, stmt: &ParsedStmt) {
    trace("ParsedBlock.addStmt");
    if (this.stmtLength >= this.stmtCapacity) {
        let newCap: usize = this.stmtCapacity * 2;
        if (newCap == 0) newCap = 1;
        this.stmtList = realloc(this.stmtList, newCap * sizeof usize);
        assert(this.stmtList != null, "Could not resize stmt list");
        this.stmtCapacity = newCap;
    }
    this.stmtList[this.stmtLength] = getID(stmt);
    this.stmtLength = this.stmtLength + 1;
}

func getStmtAtIndex(this: &ParsedBlock, index: usize) -> usize {
    trace("ParsedBlock.getStmtAtIndex");
    assert(index < this.stmtLength, "Out of bounds access in ParsedBlock.getStmtAtIndex");
    return this.stmtList[index];
}

func newParsedBlock() -> &ParsedBlock {
    push(&blocks, ParsedBlock {
        ignored: ignoringNodes,
    });
    return last(&blocks);
}

comptime STMT_INVALID: usize = 0;
// if VarDecl is global, set block to moduleID, otherwise, set block to MAX
comptime STMT_VAR_DECL: usize = 1;
comptime STMT_RETURN_EMPTY: usize = 2;
comptime STMT_RETURN_EXPR: usize = 3;
comptime STMT_EXPR: usize = 4;
comptime STMT_BLOCK: usize = 5;
comptime STMT_IF: usize = 6;
comptime STMT_WHILE: usize = 7;
comptime STMT_BREAK: usize = 8;
comptime STMT_CONTINUE: usize = 9;
// FIXME: The amount of memory wasted here is crazy
struct ParsedStmt {
    ignored: bool;
    kind: usize;
    span: Span;
    varDeclContext: VarDeclContext;
    expr: usize;
    block: usize;
    step: usize;
    ifContext: IfContext;
    typeState: TCState;
}

func getID(this: &ParsedStmt) -> usize {
    trace("ParsedStmt.getID");
    return indexOf(&stmts, this);
}

func asTLI(this: &ParsedStmt) -> &ParsedTopLevelItem {
    trace("ParsedStmt.asTLI");
    if (this.kind == STMT_VAR_DECL) {
        return newParsedTopLevelItem(this.span, TLI_VAR_DECL, getID(this));
    } else {
        todo_with_msg("Can't convert stmt to tli");
    }
}

func getMangledName(this: &ParsedStmt) -> String {
    assert(this.kind == STMT_VAR_DECL, "Only variable declarations can get their names mangled");
    assert(this.block < NODE_ID_OFFSET, "Only global variable declarations can get their names mangled");
    return mangleVariableName(this.block, &this.varDeclContext.name);
}

func newParsedStmt(span: Span, kind: usize) -> &ParsedStmt {
    trace("newParsedStmt");
    push(&stmts, ParsedStmt {
        ignored: ignoringNodes,
        span: span,
        kind: kind,
    });
    return last(&stmts);
}

// REVIEW: These names might need changing once we make it to the Type Checker
comptime PARSED_TYPE_INVALID: usize = 0;
comptime PARSED_TYPE_UNKNOWN: usize = 1;
comptime PARSED_TYPE_NONE: usize = 2;
comptime PARSED_TYPE_ANY: usize = 3;
comptime PARSED_TYPE_BLANK: usize = 4;
comptime PARSED_TYPE_I8: usize = 5;
comptime PARSED_TYPE_I16: usize = 6;
comptime PARSED_TYPE_I32: usize = 7;
comptime PARSED_TYPE_I64: usize = 8;
comptime PARSED_TYPE_U8: usize = 9;
comptime PARSED_TYPE_U16: usize = 10;
comptime PARSED_TYPE_U32: usize = 11;
comptime PARSED_TYPE_U64: usize = 12;
comptime PARSED_TYPE_USIZE: usize = 13;
comptime PARSED_TYPE_BOOL: usize = 14;
comptime PARSED_TYPE_CHAR: usize = 15;
comptime PARSED_TYPE_IDENT: usize = 16;
comptime PARSED_TYPE_REF: usize = 17;
comptime PARSED_TYPE_ARRAY: usize = 18;
comptime PARSED_TYPE_F32: usize = 19;
comptime PARSED_TYPE_F64: usize = 20;
comptime PARSED_TYPE_BUILTIN: usize = 21;
func BUILD_A_TYPE(s: &char) -> SubStr {
    return SubStr {
        start: s,
        len: comptimeStrlen(s)
    };
}

comptime ANY: SubStr = BUILD_A_TYPE("Any");
comptime I8: SubStr = BUILD_A_TYPE("i8");
comptime I16: SubStr = BUILD_A_TYPE("i16");
comptime I32: SubStr = BUILD_A_TYPE("i32");
comptime I64: SubStr = BUILD_A_TYPE("i64");
comptime U8: SubStr = BUILD_A_TYPE("u8");
comptime U16: SubStr = BUILD_A_TYPE("u16");
comptime U32: SubStr = BUILD_A_TYPE("u32");
comptime U64: SubStr = BUILD_A_TYPE("u64");
comptime USIZE: SubStr = BUILD_A_TYPE("usize");
comptime F32: SubStr = BUILD_A_TYPE("f32");
comptime F64: SubStr = BUILD_A_TYPE("f64");
comptime BOOL: SubStr = BUILD_A_TYPE("bool");
comptime CHAR: SubStr = BUILD_A_TYPE("char");
func getBuiltinTypeKind(name: Token) -> usize {
    if (equals(&name.content, &ANY)) return PARSED_TYPE_ANY;
    else if (equals(&name.content, &I8)) return PARSED_TYPE_I8;
    else if (equals(&name.content, &I16)) return PARSED_TYPE_I16;
    else if (equals(&name.content, &I32)) return PARSED_TYPE_I32;
    else if (equals(&name.content, &I64)) return PARSED_TYPE_I64;
    else if (equals(&name.content, &U8)) return PARSED_TYPE_U8;
    else if (equals(&name.content, &U16)) return PARSED_TYPE_U16;
    else if (equals(&name.content, &U32)) return PARSED_TYPE_U32;
    else if (equals(&name.content, &U64)) return PARSED_TYPE_U64;
    else if (equals(&name.content, &USIZE)) return PARSED_TYPE_USIZE;
    else if (equals(&name.content, &F32)) return PARSED_TYPE_F32;
    else if (equals(&name.content, &F64)) return PARSED_TYPE_F64;
    else if (equals(&name.content, &BOOL)) return PARSED_TYPE_BOOL;
    else if (equals(&name.content, &CHAR)) return PARSED_TYPE_CHAR;
    return PARSED_TYPE_INVALID;
}
struct ParsedTypeNode {
    ignored: bool;
    span: Span;
    kind: usize;
    underlyingID: usize;
    arraySize: usize;
    nameTkn: Token;
    typeState: TCState;
}

func getID(this: &ParsedTypeNode) -> usize {
    trace("ParsedTypeNode.getID");
    return indexOf(&typeNodes, this);
}

func newParsedTypeNode(span: Span, kind: usize) -> &ParsedTypeNode {
    trace("newParsedTypeNode");
    push(&typeNodes, ParsedTypeNode {
        ignored: ignoringNodes,
        span: span,
        kind: kind,
    });
    return last(&typeNodes);
}

func newBuiltinTypeDecl(span: Span, kind: usize) -> &ParsedTypeNode {
    trace("newBuiltinTypeDecl");
    let t: &ParsedTypeNode = at(&typeNodes, kind);
    (*t).span = span;
    (*t).kind = PARSED_TYPE_BUILTIN;
    return t;
}

comptime ASSOC_LEFT: usize = 0;
comptime ASSOC_RIGHT: usize = 1;

comptime EXPR_INVALID: usize = 0;
comptime EXPR_EMPTY: usize = 1;
comptime EXPR_INT_LIT: usize = 2;
comptime EXPR_STRING_LIT: usize = 3;
comptime EXPR_CHAR_LIT: usize = 4;
comptime EXPR_ARRAY_LIT: usize = 5;
// name -> op is 1 if it's a global variable
// name -> LHS is ID of VarDecl, set by TypeChecker
//      -> if name is a parameter, set LHS to MAX+param#
comptime EXPR_NAME: usize = 6;
// unary -> op and LHS is set
comptime EXPR_UNARY: usize = 7;
comptime EXPR_BINARY: usize = 8;
// call -> origToken is fn name, arrayContext is args
// call -> LHS is ID of FuncDecl we call, set by TypeChecker
comptime EXPR_CALL: usize = 9;
// sizeof -> LHS is set
comptime EXPR_SIZEOF: usize = 10;
comptime EXPR_STRUCT_INIT: usize = 11;
// as -> LHS is expr, RHS is type ID
comptime EXPR_AS: usize = 12;
comptime EXPR_NULL: usize = 13;
comptime EXPR_BLANK: usize = 14;
comptime EXPR_TRUE: usize = 15;
comptime EXPR_FALSE: usize = 16;
struct ParsedExpr {
    ignored: bool;
    span: Span;
    kind: usize;
    origToken: Token;
    // REVIEW: We don't need to waste all that memory
    arrayContext: ArrayContext;
    structInitContext: StructInitContext;
    // FIXME: Do we need to waste that memory for all expressions, even if they're not binary ops?
    // REVIEW: We could store binOp in origToken and compute the op on the fly?
    op: usize;
    lhs: usize;
    rhs: usize;
    typeState: TCState;
}
func getID(this: &ParsedExpr) -> usize {
    trace("ParsedExpr.getID");
    return indexOf(&exprs, this);
}

func intoPointer(this: &ParsedExpr) -> usize {
    let unary: &ParsedExpr = newParsedExpr(this.span, EXPR_UNARY);
    (*unary).op = UNARY_REF;
    (*unary).lhs = getID(this);
    return getID(unary);
}

func isLValue(this: &ParsedExpr) -> bool {
    if (this.kind == EXPR_UNARY) {
        return this.op == UNARY_DEREF;
    } else if (this.kind == EXPR_BINARY) {
        if (this.op == BIN_DOT) {
            return at(&exprs, this.rhs).kind == EXPR_NAME;
        }
        if (this.op == BIN_INDEXED_ACCESS) return true;
        return false;
    } else {
        return this.kind == EXPR_NAME;
    }
}

func isBlank(this: &ParsedExpr) -> bool {
    return this.kind == EXPR_BLANK;
}
func isIdentifier(this: &ParsedExpr) -> bool {
    return this.kind == EXPR_NAME;
}
func isLiteral(this: &ParsedExpr) -> bool {
    return this.kind == EXPR_INT_LIT
        || this.kind == EXPR_STRING_LIT
        || this.kind == EXPR_CHAR_LIT
        || this.kind == EXPR_ARRAY_LIT
        || this.kind == EXPR_NULL
        || this.kind == EXPR_TRUE
        || this.kind == EXPR_FALSE;
}

func isUnary(this: &ParsedExpr) -> bool {
    return this.kind == EXPR_UNARY;
}

func isCall(this: &ParsedExpr) -> bool {
    return this.kind == EXPR_CALL;
}

func isAssignment(this: &ParsedExpr) -> bool {
    if (this.kind != EXPR_BINARY) return false;
    return this.op == BIN_ASSIGN;
}

func isArithmetic(this: &ParsedExpr) -> bool {
    if (this.kind != EXPR_BINARY) return false;
    return this.op == BIN_PLUS
        || this.op == BIN_SUB
        || this.op == BIN_MULT
        || this.op == BIN_DIV
        || this.op == BIN_MOD;
}

func isComparison(this: &ParsedExpr) -> bool {
    if (this.kind != EXPR_BINARY) return false;
    return this.op == BIN_CMP_GTE
        || this.op == BIN_CMP_GT
        || this.op == BIN_CMP_LTE
        || this.op == BIN_CMP_LT
        || this.op == BIN_CMP_EQ
        || this.op == BIN_CMP_NEQ;
}

func isLogical(this: &ParsedExpr) -> bool {
    if (this.kind != EXPR_BINARY) return false;
    return this.op == BIN_LAND
        || this.op == BIN_LOR;
}

func isBitwise(this: &ParsedExpr) -> bool {
    if (this.kind != EXPR_BINARY) return false;
    return this.op == BIN_BAND
        || this.op == BIN_BOR
        || this.op == BIN_BXOR;
}

comptime BIN_INVALID: usize = 0;
comptime BIN_PLUS: usize = 1;
comptime BIN_SUB: usize = 2;
comptime BIN_MULT: usize = 3;
comptime BIN_DIV: usize = 4;
comptime BIN_DOT: usize = 5;
comptime BIN_CMP_GTE: usize = 6;
comptime BIN_CMP_GT: usize = 7;
comptime BIN_CMP_LTE: usize = 8;
comptime BIN_CMP_LT: usize = 9;
comptime BIN_CMP_NEQ: usize = 10;
comptime BIN_CMP_EQ: usize = 11;
comptime BIN_ASSIGN: usize = 12;
comptime BIN_AS: usize = 13;
comptime BIN_INDEXED_ACCESS: usize = 14;
comptime BIN_MOD: usize = 15;
// FIXME: Those names are pretty easy to mix up
comptime BIN_LAND: usize = 16;
comptime BIN_LOR: usize = 17;
comptime BIN_BAND: usize = 18;
comptime BIN_BOR: usize = 19;
comptime BIN_BXOR: usize = 20;
func binOpFromKind(kind: usize) -> usize {
    trace("binOpFromKind");
    if (kind == TOKEN_PLUS_SINGLE) return BIN_PLUS;
    else if (kind == TOKEN_MINUS_SINGLE) return BIN_SUB;
    else if (kind == TOKEN_ASTERISK_SINGLE) return BIN_MULT;
    else if (kind == TOKEN_SLASH_SINGLE) return BIN_DIV;
    else if (kind == TOKEN_DOT) return BIN_DOT;
    else if (kind == TOKEN_GREATER_THAN_EQUAL) return BIN_CMP_GTE;
    else if (kind == TOKEN_GREATER_THAN) return BIN_CMP_GT;
    else if (kind == TOKEN_LESS_THAN_EQUAL) return BIN_CMP_LTE;
    else if (kind == TOKEN_LESS_THAN) return BIN_CMP_LT;
    else if (kind == TOKEN_NOT_EQUAL) return BIN_CMP_NEQ;
    else if (kind == TOKEN_EQUAL_DOUBLE) return BIN_CMP_EQ;
    else if (kind == TOKEN_EQUAL_SINGLE) return BIN_ASSIGN;
    // FIXME: We can't know if this is actually KEYWORD_AS
    else if (kind == TOKEN_KEYWORD) return BIN_AS;
    else if (kind == TOKEN_SQUARE_OPEN) return BIN_INDEXED_ACCESS;
    else if (kind == TOKEN_PERCENT) return BIN_MOD;
    else if (kind == TOKEN_PIPE_SINGLE) return BIN_BOR;
    else if (kind == TOKEN_PIPE_DOUBLE) return BIN_LOR;
    else if (kind == TOKEN_AMPERSAND_SINGLE) return BIN_BAND;
    else if (kind == TOKEN_AMPERSAND_DOUBLE) return BIN_LAND;
    else if (kind == TOKEN_CARET) return BIN_BXOR;
    else {
        printf("%llu\n", kind);
        todo_with_msg("binOpFromKind");
    }
}

func binOpAsStr(op: usize) -> &char {
    if (op == BIN_PLUS) return "+";
    else if (op == BIN_SUB) return "-";
    else if (op == BIN_MULT) return "*";
    else if (op == BIN_DIV) return "/";
    else if (op == BIN_DOT) return ".";
    else if (op == BIN_CMP_GTE) return ">=";
    else if (op == BIN_CMP_GT) return ">";
    else if (op == BIN_CMP_LTE) return "<=";
    else if (op == BIN_CMP_LT) return "<";
    else if (op == BIN_CMP_NEQ) return "!=";
    else if (op == BIN_CMP_EQ) return "==";
    else if (op == BIN_ASSIGN) return "=";
    else if (op == BIN_AS) return "as";
    else if (op == BIN_INDEXED_ACCESS) return "[]";
    else if (op == BIN_MOD) return "%";
    else if (op == BIN_LAND) return "&&";
    else if (op == BIN_LOR) return "||";
    else if (op == BIN_BAND) return "&";
    else if (op == BIN_BOR) return "|";
    else if (op == BIN_BXOR) return "^";
    unreachable("Exhaustive handling of binary ops in binOpAsStr");
}

comptime UNARY_INVALID: usize = 0;
comptime UNARY_COMPTIME: usize = 1;
comptime UNARY_DEREF: usize = 2;
comptime UNARY_REF: usize = 3;
comptime UNARY_MINUS: usize = 4;
comptime UNARY_NOT: usize = 5;
func unaryOpFromKind(kind: usize) -> usize {
    trace("unaryOpFromKind");
    // FIXME: We can't know if this is actually KEYWORD_COMPTIME
    if (kind == TOKEN_KEYWORD) return UNARY_COMPTIME;
    else if (kind == TOKEN_ASTERISK_SINGLE) return UNARY_DEREF;
    else if (kind == TOKEN_AMPERSAND_SINGLE) return UNARY_REF;
    else if (kind == TOKEN_MINUS_SINGLE) return UNARY_MINUS;
    else if (kind == TOKEN_BANG) return UNARY_NOT;
    todo_with_msg("unaryOpFromKind");
}

func newParsedExpr(span: Span, kind: usize) -> &ParsedExpr {
    trace("newParsedExpr");
    push(&exprs, ParsedExpr {
        ignored: ignoringNodes,
        kind: kind,
        span: span,
    });
    return last(&exprs);
}

