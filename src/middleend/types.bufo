import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "type_info.bufo";
import "../bufo.bufo";
import "../util/arena.bufo";
import "../util/lists.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "./checker.bufo";
import "../backend/LLVM/metadata.bufo";

func nextMultipleOf(a: usize, b: usize) -> usize {
    assert(b != 0, "nextMultipleOf: b is 0!");
    if (a % b == 0) return a;
    return a + (b - (a % b));
}

union PrimType {
    U8,
    U16,
    U32,
    U64,
    I8,
    I16,
    I32,
    I64,
    Usize,
    Any,
    Bool,
    None,
    Char,
    F32,
    F64,
}
comptime PRIM_TYPE_COUNT: usize = 15; // FIXME: When we add a new PrimType we need to update this

func index_of_type(table: &TypeInfoTable, type: &Type) -> usize {
    for (let i: usize = 0; i < table.length; i = i + 1) {
        let n = toString(type);
        let b = equals(&get_name(&table.elements[i]), &asSubStr(&n));
        drop(&n);
        if (b) return i;
    }
    return table.length;
}

// TODO: Remove this arena, instead associate types with Nodes?
let types: TypeArena = blank;
let debugTypes: LLVMMetadataArena = blank;

union Type {
    Error, // Used for error propagation, for example to still add a variable even though
           // its declaration failed - Just so we don't get "Use of undeclared variable" errors.
    Unknown,
    // TODO: Ideally this should be a Slice type, but not sure how to integrate the semantics yet
    Variadic(&Type),
    Prim(PrimType),
    Ptr(&Type),
    Array(&Type, usize),
    Func(TypeList, &Type, FuncAttr),
    Struct(&ParsedStructDecl),
    Union(&ParsedUnionDecl, usize),
    Module(&ParsedModule),
    Tuple(TypeList),
}

func getMangledName(this: &Type) -> String {
    match (this) {
        &Type::Prim(typ) => {
            // OPT: Make these Strings comptime
            match (typ) {
                PrimType::U8    => {  return newStringFromStrLit("u8"); }
                PrimType::U16   => {  return newStringFromStrLit("u16"); }
                PrimType::U32   => {  return newStringFromStrLit("u32"); }
                PrimType::U64   => {  return newStringFromStrLit("u64"); }
                PrimType::I8    => {  return newStringFromStrLit("i8"); }
                PrimType::I16   => {  return newStringFromStrLit("i16"); }
                PrimType::I32   => {  return newStringFromStrLit("i32"); }
                PrimType::I64   => {  return newStringFromStrLit("i64"); }
                PrimType::Usize => {  return newStringFromStrLit("usz"); }
                PrimType::Any   => {  return newStringFromStrLit("Any"); }
                PrimType::Bool  => {  return newStringFromStrLit("B"); }
                PrimType::None  => {  return newStringFromStrLit("N"); }
                PrimType::Char  => {  return newStringFromStrLit("c"); }
                PrimType::F32   => {  return newStringFromStrLit("f32"); }
                PrimType::F64   => {  return newStringFromStrLit("f64"); }
                _ => { unreachable("Exhaustive handling of primitive types in getMangledName"); }
            }
        }
        &Type::Ptr(typ) => {
            let s: String = newStringFromStrLit("P");
            let _s: String = getMangledName(typ);
            pushString(&s, &_s);
            drop(&_s);
            return s;
        }
        &Type::Struct(decl) => {
            let s: String = newStringFromStrLit("S");
            let hash: usize = hash(&decl.name.content, 4);
            if (hash < 10) pushNumber(&s, 0 as usize);
            if (hash < 100) pushNumber(&s, 0 as usize);
            if (hash < 1000) pushNumber(&s, 0 as usize);
            pushNumber(&s, hash);
            return s;
        }
        &Type::Union(decl, _) => {
            let s = newStringFromStrLit("U");
            let hash: usize = hash(&decl.name.content, 4);
            if (hash < 10) pushNumber(&s, 0 as usize);
            if (hash < 100) pushNumber(&s, 0 as usize);
            if (hash < 1000) pushNumber(&s, 0 as usize);
            pushNumber(&s, hash);
            return s;
        }
        &Type::Func(params, ret, _) => {
            let s: String = newStringFromStrLit("F");
            let r = getMangledName(ret);
            pushString(&s, &r);
            drop(&r);
            for (let i: usize = 0; i < params.length; i = i + 1) {
                if (i != params.length - 1) pushChar(&s, '.');
                let p = getMangledName(*at(&params, i));
                pushString(&s, &p);
                drop(&p);
            }
            return s;
        }
        &Type::Array(typ, size) => {
            let s: String = newStringFromStrLit("A");
            let r = getMangledName(typ);
            pushString(&s, &r);
            drop(&r);
            pushNumber(&s, size);
            return s;
        }
        &Type::Variadic(typ) => {
            let s: String = newStringFromStrLit("V");
            let r = getMangledName(typ);
            pushString(&s, &r);
            drop(&r);
            return s;
        }
        &Type::Tuple(elems) => {
            let s: String = newStringFromStrLit("T");
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                if (i != elems.length - 1) pushChar(&s, '.');
                let e = getMangledName(*at(&elems, i));
                pushString(&s, &e);
                drop(&e);
            }
            return s;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of types in Type.getMangledName");
}

func getID(this: &Type) -> usize {
    return indexOf(&types, this);
}

// TODO: Equality in a type system context is kinda stupid
//       What we want to know is if a type can be converted to another one
//       where f(A, B) may return true, but f(B, A) false.
func equals(this: &Type, other: &Type) -> bool {
    return _equals(this, other, true);
}
func _equals(this: &Type, other: &Type, allowData: bool) -> bool {
    // TODO: Tuple expressions
    if (allowData) {
        match (this) {
            &Type::Struct(decl) => {
                if (decl.isDataDefinition) return true;
            }
            _ => { }
        }
        match (other) {
            &Type::Struct(decl) => {
                if (decl.isDataDefinition) return true;
            }
            _ => { }
        }
    }
    match (this) {
        &Type::Error => { return true; }
        _ => { }
    }
    match (other) {
        &Type::Error => { return true; }
        _ => { }
    }
    match (this) {
        &Type::Ptr(typ) => {
            match (other) {
                &Type::Prim(PrimType::Any) => { return true; }
                &Type::Ptr(otyp) => { return equals(typ, otyp); }
                _ => { return false; }
            }
        }
        &Type::Prim(PrimType::Any) => {
            match (other) {
                &Type::Ptr(_) => { return true; }
                &Type::Prim(PrimType::Any) => { return true; }
                _ => { }
            }
        }
        &Type::Prim(t) => {
            match (other) {
                &Type::Prim(o) => { return tag(&t) == tag(&o); }
                _ => { }
            }
        }
        _ => { }
    }
    if (tag(this) != tag(other)) return false;
    match (this) {
        &Type::Variadic(typ1) => {
            match (other) {
                &Type::Variadic(typ2) => {
                    return equals(typ1, typ2);
                }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Array(typ1, size1) => {
            match (other) {
                &Type::Array(typ2, size2) => {
                    return size1 == size2 && equals(typ1, typ2);
                }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Func(params, ret, attr) => {
            match (other) {
                &Type::Func(oparams, oret, oattr) => {
                    if (attr.isVariadic != oattr.isVariadic) return false;
                    if (attr.isNoreturn != oattr.isNoreturn) return false;
                    if (params.length != oparams.length) return false;
                    if (!equals(ret, oret)) return false;
                    for (let i: usize = 0; i < params.length; i = i + 1) {
                        let p1 = *at(&params, i);
                        let p2 = *at(&oparams, i);
                        if (!equals(p1, p2)) return false;
                    }
                    return true;
                }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Tuple(elems) => {
            match (other) {
                &Type::Tuple(oelems) => {
                    if (elems.length != oelems.length) return false;
                    for (let i: usize = 0; i < elems.length; i = i + 1) {
                        let e1 = *at(&elems, i);
                        let e2 = *at(&oelems, i);
                        if (!equals(e1, e2)) return false;
                    }
                    return true;
                }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Struct(decl) => {
            match (other) {
                &Type::Struct(odecl) => { return decl == odecl; }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Union(decl, _) => {
            match (other) {
                &Type::Union(odecl, _) => { return decl == odecl; }
                _ => { return false; }
            }
        }
        _ => { }
    }
    match (this) {
        &Type::Module(decl) => {
            match (other) {
                &Type::Module(odecl) => { return decl == odecl; }
                _ => { return false; }
            }
        }
        _ => { }
    }
    C::fprintf(stderr, "%s\n", toString(this).buffer);
    C::fprintf(stderr, "%s\n", toString(other).buffer);
    unreachable("&Type.equals() should've caught all combinations by this point!");
}

func isUnknown(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Unknown);
}
func isFloat(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::F32) => { return true; }
        &Type::Prim(PrimType::F64) => { return true; }
        _ => { }
    }
    return false;
}
func isInteger(this: &Type) -> bool {
    return isSignedInteger(this) || isUnsignedInteger(this);
}
func isSignedInteger(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::I8)  => { return true; }
        &Type::Prim(PrimType::I16) => { return true; }
        &Type::Prim(PrimType::I32) => { return true; }
        &Type::Prim(PrimType::I64) => { return true; }
        _ => { }
    }
    return false;
}
func isUnsignedInteger(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::U8)  => { return true; }
        &Type::Prim(PrimType::U16) => { return true; }
        &Type::Prim(PrimType::U32) => { return true; }
        &Type::Prim(PrimType::U64) => { return true; }
        &Type::Prim(PrimType::Usize) => { return true; }
        _ => { }
    }
    return false;
}
func isVariadicType(this: &Type) -> bool {
    match (this) {
        &Type::Variadic(_) => { return true; }
        _ => { }
    }
    return false;
}
func isChar(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::Char) => { return true; }
        _ => { }
    }
    return false;
}
func isBoolean(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::Bool) => { return true; }
        _ => { }
    }
    return false;
}
func isNone(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::None) => { return true; }
        _ => { }
    }
    return false;
}
func isAny(this: &Type) -> bool {
    match (this) {
        &Type::Prim(PrimType::Any) => { return true; }
        _ => { }
    }
    return false;
}
func isData(this: &Type) -> bool {
    match (this) {
        &Type::Struct(decl) => {
            return decl.isDataDefinition;
        }
        _ => { }
    }
    return false;
}
func isPrimitive(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Prim);
}
func isFunction(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Func);
}
struct FuncAttr {
    isVariadic: bool;
    isNoreturn: bool;
}
func isVariadic(this: &Type) -> bool {
    match (this) {
        &Type::Func(_, _, attr) => { return attr.isVariadic; }
        _ => { }
    }
    return false;
}
func isNoreturn(this: &Type) -> bool {
    match (this) {
        &Type::Func(_, _, attr) => { return attr.isNoreturn; }
        _ => { }
    }
    return false;
}
func isPointer(this: &Type) -> bool {
    match (this) {
        &Type::Ptr(_) => { return true; }
        &Type::Prim(PrimType::Any) => { return true; }
        _ => { }
    }
    return false;
}
func isStructPointer(this: &Type) -> bool {
    if (!isPointer(this)) return false;
    return isStruct(getUnderlyingType(this, false));
}
func isTuplePointer(this: &Type) -> bool {
    if (!isPointer(this)) return false;
    return isTuple(getUnderlyingType(this, false));
}
func isPointerTo(this: &Type, typ: &Type) -> bool {
    match (this) {
        &Type::Ptr(to) => { return equals(to, typ); }
        _ => { }
    }
    return false;
}
func isModule(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Module);
}
func isStruct(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Struct);
}
func isUnion(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Union);
}
func isArray(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Array);
}
func isTuple(this: &Type) -> bool {
    return tag(this) == comptime tag(&Type::Tuple);
}
func isStructArray(this: &Type) -> bool {
    if (!isArray(this)) return false;
    return isStruct(getUnderlyingType(this, false));
}

func isComposite(this: &Type) -> bool {
    return isStruct(this) || isUnion(this);
}

func getUnderlyingType(this: &Type, deep: bool) -> &Type {
    let underlying = this;
    while (isVariadicType(this) || isPointer(this) || isArray(this)) {
        match (underlying) {
            &Type::Ptr(under) => { underlying = under; }
            &Type::Array(under, _) => { underlying = under; }
            &Type::Variadic(under) => { underlying = under; }
            _ => { break; }
        }
        if (!deep) break;
    }
    return underlying;
}
// OPT: Make toString() accept a buffer, so we don't allocate 20 bytes on the heap 1 million times
func toString(this: &Type) -> String {
    match (this) {
        &Type::Error => { return newStringFromStrLit("<propagated error>"); }
        &Type::Unknown => { return newStringFromStrLit("<unknown>"); }
        &Type::Prim(typ) => {
            // OPT: Make these Strings comptime
            match (typ) {
                PrimType::U8    => {  return newStringFromStrLit("u8"); }
                PrimType::U16   => {  return newStringFromStrLit("u16"); }
                PrimType::U32   => {  return newStringFromStrLit("u32"); }
                PrimType::U64   => {  return newStringFromStrLit("u64"); }
                PrimType::I8    => {  return newStringFromStrLit("i8"); }
                PrimType::I16   => {  return newStringFromStrLit("i16"); }
                PrimType::I32   => {  return newStringFromStrLit("i32"); }
                PrimType::I64   => {  return newStringFromStrLit("i64"); }
                PrimType::Usize => {  return newStringFromStrLit("usize"); }
                PrimType::Any   => {  return newStringFromStrLit("Any"); }
                PrimType::Bool  => {  return newStringFromStrLit("bool"); }
                PrimType::None  => {  return newStringFromStrLit("none"); }
                PrimType::Char  => {  return newStringFromStrLit("char"); }
                PrimType::F32   => {  return newStringFromStrLit("f32"); }
                PrimType::F64   => {  return newStringFromStrLit("f64"); }
                _ => { unreachable("Exhaustive handling of primitive types in toString"); }
            }
        }
        &Type::Ptr(sub) => {
            let s: String = newStringFromStrLit("&");
            let _s: String = toString(sub);
            pushString(&s, &_s);
            drop(&_s);
            return s;
        }
        &Type::Struct(decl) => { return getFullName(decl); }
        &Type::Union(decl, _) => { return getFullName(decl); }
        &Type::Module(decl) => { return getFullName(decl); }
        &Type::Func(params, rt, attr) => {
            let s: String = newStringFromStrLit("func (");
            for (let i: usize = 0; i < params.length; i = i + 1) {
                let p: String = toString(*at(&params, i));
                pushString(&s, &p);
                drop(&p);
                if (i != params.length - 1) {
                    pushChar(&s, ',');
                    pushChar(&s, ' ');
                }
            }
            if (attr.isVariadic) {
                if (params.length > 0) if (!isVariadicType(params.elements[params.length - 1])) {
                    pushStr(&s, "...");
                }
            }
            pushChar(&s, ')');
            if (!isNone(rt)) {
                pushStr(&s, " -> ");
                let r = toString(rt);
                pushString(&s, &r);
                drop(&r);
            }
            return s;
        }
        &Type::Array(sub, size) => {
            let s: String = newStringFromStrLit("[");
            let _s: String = toString(sub);
            pushString(&s, &_s);
            drop(&_s);
            pushChar(&s, ';');
            pushChar(&s, ' ');
            pushNumber(&s, size);
            pushChar(&s, ']');
            return s;
        }
        &Type::Variadic(typ) => {
            let s: String = newStringFromStrLit("...");
            let _s: String = toString(typ);
            pushString(&s, &_s);
            return s;
        }
        &Type::Tuple(elems) => {
            let s: String = newStringFromStrLit("(");
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                let e: String = toString(*at(&elems, i));
                pushString(&s, &e);
                drop(&e);
                if (i != elems.length - 1) {
                    pushChar(&s, ',');
                    pushChar(&s, ' ');
                }
            }
            pushChar(&s, ')');
            return s;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of types in Type.toString");
}
func getAlignmentInBits(this: &Type) -> usize {
    return getAlignmentInBytes(this) * 8;
}
func getAlignmentInBytes(this: &Type) -> usize {
    let res: usize = 0;
    match (this) {
        &Type::Ptr(_) => { res = 8; }
        &Type::Func(_,_,_) => { res = 8; }
        &Type::Prim(typ) => {
            match (typ) {
                // TODO: Or Pattern
                PrimType::None => { res = 1; }
                PrimType::I8 => { res = 1; }
                PrimType::U8 => { res = 1; }
                PrimType::Char => { res = 1; }
                PrimType::Bool => { res = 1; }
                PrimType::I16 => { res = 2; }
                PrimType::U16 => { res = 2; }
                PrimType::I32 => { res = 4; }
                PrimType::U32 => { res = 4; }
                PrimType::F32 => { res = 4; }
                PrimType::I64 => { res = 8; }
                PrimType::U64 => { res = 8; }
                PrimType::F64 => { res = 8; }
                PrimType::Usize => { res = 8; }
                PrimType::Any => { res = 8; }
                _ => { unreachable("Exhaustive handling of primitive types in Type.getAlignment"); }
            }
        }
        &Type::Array(sub, _) => { res = getAlignmentInBytes(sub); }
        &Type::Struct(decl) => {
            assert(isSuccess(&decl.typeState), "Can only get alignment of valid structs");
            let maxAlign: usize = 1;
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let td: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                assert(isSuccess(&td.typeState), "Expected valid field type");
                let tt: &Type = getType(&td.typeState);
                let _a: usize = getAlignmentInBytes(tt);
                if (_a > maxAlign) maxAlign = _a;
            }
            res = maxAlign;
        }
        &Type::Union(decl, _) => {
            assert(isSuccess(&decl.typeState), "Can only get alignment of valid unions");
            let maxAlign: usize = 1;
            if (decl.variants.length >= 256) maxAlign = 2;
            for (let i: usize = 0; i < decl.variants.length; i = i + 1) {
                let variant = *at(&decl.variants, i);
                for (let j: usize = 0; j < variant.fields.length; j = j + 1) {
                    let field = *at(&variant.fields, j);
                    assert(isSuccess(&field.typeState), "Expected valid field type");
                    let tt: &Type = getType(&field.typeState);
                    let _a: usize = getAlignmentInBytes(tt);
                    if (_a > maxAlign) maxAlign = _a;
                }
            }
            res = maxAlign;
        }
        &Type::Tuple(elems) => {
            let maxAlign: usize = 1;
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                let tt: &Type = elems.elements[i];
                let _a: usize = getAlignmentInBytes(tt);
                if (_a > maxAlign) maxAlign = _a;
            }
            res = maxAlign;
        }
        _ => {
            unreachable("Exhaustive handling of type kinds in Type.getAlignment");
        }
    }
    // Alignment is always a power of two
    assert(res != 0, "Alignment can't be 0 bytes");
    let n: usize = 1;
    while (n < res) n = n * 2;
    return n;
}
func getSizeInBits(this: &Type) -> usize {
    let s = getSizeInBytes(this) * 8;
    if (s == 0) return 1;
    return s;
}
func getSizeInBytes(this: &Type) -> usize {
    match (this) {
        &Type::Ptr(_) => { return 8; }
        &Type::Variadic(_) => { return 16; } // ptr + size
        &Type::Func(_,_,_) => { return 8; }
        &Type::Prim(typ) => {
            match (typ) {
                // TODO: Or Pattern
                PrimType::None => { return 0; }
                PrimType::I8 => { return 1; }
                PrimType::U8 => { return 1; }
                PrimType::Char => { return 1; }
                PrimType::Bool => { return 1; }
                PrimType::I16 => { return 2; }
                PrimType::U16 => { return 2; }
                PrimType::I32 => { return 4; }
                PrimType::U32 => { return 4; }
                PrimType::F32 => { return 4; }
                PrimType::I64 => { return 8; }
                PrimType::U64 => { return 8; }
                PrimType::F64 => { return 8; }
                PrimType::Usize => { return 8; }
                PrimType::Any => { return 8; }
                _ => { unreachable("Exhaustive handling of primitive types in Type.getSize"); }
            }
        }
        &Type::Module(_) => { return 0; }
        &Type::Array(sub, size) => { return getSizeInBytes(sub) * size; }
        &Type::Struct(decl) => {
            assert(isSuccess(&decl.typeState), "Can only get size of valid structs");
            let size: usize = 0;
            let maxAlign: usize = 1;
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let td: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                assert(isSuccess(&td.typeState), "Expected valid field type");
                let tt: &Type = getType(&td.typeState);
                size = size + getSizeInBytes(tt);
                let _a: usize = getAlignmentInBytes(tt);
                if (_a > maxAlign) maxAlign = _a;
                if (i != decl.context.fieldLength - 1) {
                    let next: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i + 1);
                    let nextType: &Type = getType(&next.typeState);
                    size = nextMultipleOf(size, getAlignmentInBytes(nextType));
                }
            }
            size = nextMultipleOf(size, maxAlign);
            return size;
        }
        &Type::Union(decl, _) => {
            assert(isSuccess(&decl.typeState), "Can only get size of valid unions");
            assert(decl.variants.length < 65536, "getSize expects the Union tag to fit into at most two bytes");
            let maxSize: usize = 0;
            let maxAlign: usize = 1;
            for (let i: usize = 0; i < decl.variants.length; i = i + 1) {
                let variant = *at(&decl.variants, i);
                let size: usize = 1; // union tag
                let align: usize = 1;
                if (decl.variants.length >= 256) {
                    size = 2;
                    align = 2;
                }
                if (variant.fields.length > 0) {
                    let next: &ParsedTypeNode = *at(&variant.fields, 0);
                    let nextType: &Type = getType(&next.typeState);
                    size = nextMultipleOf(size, getAlignmentInBytes(nextType));
                }
                for (let j: usize = 0; j < variant.fields.length; j = j + 1) {
                    let field = *at(&variant.fields, j);
                    assert(isSuccess(&field.typeState), "Expected valid field type");
                    let tt: &Type = getType(&field.typeState);
                    size = size + getSizeInBytes(tt);
                    let _a: usize = getAlignmentInBytes(tt);
                    if (_a > align) align = _a;
                    if (j != variant.fields.length - 1) {
                        let next: &ParsedTypeNode = *at(&variant.fields, j + 1);
                        let nextType: &Type = getType(&next.typeState);
                        size = nextMultipleOf(size, getAlignmentInBytes(nextType));
                    }
                }
                if (size > maxSize) maxSize = size;
                if (align > maxAlign) maxAlign = align;
            }
            maxSize = nextMultipleOf(maxSize, maxAlign);
            return maxSize;
        }
        &Type::Tuple(elems) => {
            let size: usize = 0;
            let maxAlign: usize = 1;
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                let tt: &Type = elems.elements[i];
                size = size + getSizeInBytes(tt);
                let _a: usize = getAlignmentInBytes(tt);
                if (_a > maxAlign) maxAlign = _a;
                if (i != elems.length - 1) {
                    let nextType: &Type = elems.elements[i + 1];
                    size = nextMultipleOf(size, getAlignmentInBytes(nextType));
                }
            }
            size = nextMultipleOf(size, maxAlign);
            return size;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of type kinds in Type.getSizeInBytes");
}
func getParam(fnType: &Type, id: usize) -> &Type {
    match (fnType) {
        &Type::Func(params, _, _) => { return *at(&params, id); }
        _ => { }
    }
    unreachable("getParam() called on non-function type");
}
func getReturnType(fnType: &Type) -> &Type {
    match (fnType) {
        &Type::Func(_, ret, _) => { return ret; }
        _ => { }
    }
    unreachable("getReturnType() called on non-function type");
}
func getTupleElement(tuple: &Type, index: usize) -> &Type {
    let &Type::Tuple(elems) = tuple else {
        unreachable("getTupleElement() called on non-tuple type");
    };
    return *at(&elems, index);
}
func getMaxFloatValue(this: &Type) -> f64 {
    match (this) {
        &Type::Prim(PrimType::F32) => {
            let VAL: i32 = 2139095039;
            return *(&VAL as &f32) as f64;
        }
        &Type::Prim(PrimType::F64) => {
            let VAL: i64 = 9218868437227405311;
            return *(&VAL as &f64);
        }
        _ => { }
    }
    unreachable("Type.getMaxFloatValue() called on non-Float");
}
func intoPointer(this: &Type) -> &Type {
    return wrap(Type::Ptr(this));
}
func intoArrayType(this: &Type, size: usize) -> &Type {
    return wrap(Type::Array(this, size));
}

func copy(this: &Type) -> &Type {
    return wrap(*this);
}

func wrap(t: Type) -> &Type {
    match (t) {
        Type::Prim(p) => {
            let id = tag(&p) as usize;
            assert(id < PRIM_TYPE_COUNT, "Type::Prim has invalid tag");
            *at(&types, id) = t;
            return at(&types, id);
        }
        _ => {
            push(&types, t);
            if (*flags.debug) push(&debugTypes, blank);
            return last(&types);
        }
    }
    unreachable();
}

