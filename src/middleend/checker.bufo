import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

comptime ERROR_INVALID: usize = 0;
comptime ERROR_LOOKUP_NOT_READY: usize = 1;
comptime ERROR_NO_SUCH_IDENTIFIER: usize = 2;
comptime ERROR_NO_SUCH_FUNCTION: usize = 3;
comptime ERROR_NO_SUCH_METHOD: usize = 4;
comptime ERROR_USE_BEFORE_DECLARATION: usize = 5;
comptime ERROR_FIELD_COUNT_MISMATCH: usize = 6;
comptime ERROR_INDEXED_TYPE_MISMATCH: usize = 7;
comptime ERROR_UNEXPECTED_LITERAL: usize = 8;
comptime ERROR_ARRAY_SIZE_MISMATCH: usize = 9;
comptime ERROR_TYPE_MISMATCH: usize = 10;
comptime ERROR_INVALID_POINTER_ARITHMETIC: usize = 11;
comptime ERROR_DUPLICATE_PARAMETER: usize = 12;
comptime ERROR_DUPLICATE_FIELD: usize = 13;
comptime ERROR_UNKNOWN_FIELD: usize = 14;
comptime ERROR_DUPLICATE_FUNCTION: usize = 15;
comptime ERROR_NO_CALL_CANDIDATE: usize = 16;
comptime ERROR_VARIABLE_REDECLARATION: usize = 17;
comptime ERROR_RECURSIVE_TYPE: usize = 18;
comptime ERROR_DUPLICATE_METHOD: usize = 19;
comptime ERROR_BLANK_FOR_NULL: usize = 20;
comptime ERROR_NON_PRIMITIVE_CAST: usize = 21;
comptime ERROR_INDEXED_ACCESS_ON_NON_ARRAY: usize = 22;
comptime ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT: usize = 23;
comptime ERROR_ANY_DEREF: usize = 24;
comptime ERROR_MEMBER_ACCESS_NON_STRUCT: usize = 25;
comptime ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS: usize = 26;
comptime ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS: usize = 27;

comptime TCSTATE_INVALID: usize = 0;
comptime TCSTATE_ERROR: usize = 1;
comptime TCSTATE_PLEASE_INFER: usize = 2;
comptime TCSTATE_TYPE: usize = 3;
struct TCState {
    kind: usize;
    typ: usize;
    name: Token;

    func equals(&this, other: &TCState) -> bool {
        todo_with_msg("TCState.equals");
    }

    func isInvalid(&this) -> bool {
        return this.kind == TCSTATE_INVALID;
    }
    func wantsInfer(&this) -> bool {
        return this.kind == TCSTATE_PLEASE_INFER;
    }
    func isCriticalError(&this) -> bool {
        if (!this.isError()) return false;
        let err: usize = this.getError();
        return err == ERROR_NO_SUCH_IDENTIFIER
            || err == ERROR_NO_SUCH_FUNCTION
            || err == ERROR_NO_SUCH_METHOD
            || err == ERROR_DUPLICATE_FUNCTION
            || err == ERROR_DUPLICATE_METHOD
            || err == ERROR_DUPLICATE_FIELD;
    }
    func isError(&this) -> bool {
        return this.kind == TCSTATE_ERROR;
    }

    func isSuccess(&this) -> bool {
        return this.kind == TCSTATE_TYPE;
    }

    func isType(&this) -> bool {
        return this.kind == TCSTATE_TYPE;
    }

    func getType(&this) -> usize {
        if (!this.isType()) {
            fprintf(stderr, "ERROR: TCState.getType() called on non-type TCState with kind=%llu\n", this.kind);
            assert(false);
        }
        return this.typ;
    }
    func getError(&this) -> usize {
        if (!this.isError()) {
            fprintf(stderr, "ERROR: TCState.getError() called on non-error TCState with kind=%llu\n", this.kind);
            assert(false);
        }
        return this.typ;
    }
}

func newTCStateSuccess() -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: 0,
        name: blank,
    };
}

func newTCStateType(typ: usize) -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: typ,
        name: blank,
    };
}

func newTCStateFailure(error: usize) -> TCState {
    return TCState {
        kind: TCSTATE_ERROR,
        typ: error,
        name: blank,
    };
}

func newTCStatePleaseInfer() -> TCState {
    return TCState {
        kind: TCSTATE_PLEASE_INFER,
        typ: 0,
        name: blank,
    };
}

struct TypeChecker {
    isComptimeContext: bool;
    currentModule: usize;
    currentFunction: &FunctionLookup;
    currentMethod: &MethodLookup;
    lookup: Lookup;
    typeError: bool;

    func reportTypeMismatch(&this, span: Span, expected: &Type, got: &Type) -> TCState {
        trace("TypeChecker.reportTypeMismatch");
        let loc: String = span.toString();
        let typ1: String = expected.toString();
        let typ2: String = got.toString();
        fprintf(stderr, "%s: %s: Type mismatch! Expected type %s, found type %s.\n",
            loc.chars(), ERR_STR, typ1.chars(), typ2.chars());
        typ1.drop();
        typ2.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_TYPE_MISMATCH);
    }

    func reportBinaryTypeMismatch(&this, op: usize, lhsSpan: Span, lhsType: &Type, rhsSpan: Span, rhsType: &Type) -> TCState {
        trace("TypeChecker.reportBinaryTypeMismatch");
        let loc: String = newSpanBetween(&lhsSpan, &rhsSpan).toString();
        let loc1: String = lhsSpan.toString();
        let loc2: String = rhsSpan.toString();
        let typ1: String = lhsType.toString();
        let typ2: String = rhsType.toString();
        fprintf(stderr, "%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n",
            loc.chars(), ERR_STR, typ1.chars(), binOpAsStr(op), typ2.chars());
        fprintf(stderr, "%s: %s: LHS has type %s.\n", loc1.chars(), NOTE_STR, typ1.chars());
        fprintf(stderr, "%s: %s: RHS has type %s.\n", loc2.chars(), NOTE_STR, typ2.chars());
        typ2.drop();
        typ1.drop();
        loc2.drop();
        loc1.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_TYPE_MISMATCH);
    }

    func reportInvalidPointerArithmetics(&this, op: usize, lhsSpan: Span, rhsSpan: Span) -> TCState {
        trace("TypeChecker.reportInvalidPointerArithmetics");
        let loc: String = newSpanBetween(&lhsSpan, &rhsSpan).toString();
        fprintf(stderr, "%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n",
            loc.chars(), ERR_STR, binOpAsStr(op));
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_INVALID_POINTER_ARITHMETIC);
    }

    func reportDuplicateField(&this, fieldToken: Token, declSpan: Span) -> TCState {
        trace("TypeChecker.reportDuplicateField");
        let duplLoc: String = fieldToken.span.toString();
        let origLoc: String = declSpan.toString();
        let name: String = fieldToken.content.toString();
        fprintf(stderr, "%s: %s: Field redeclaration.\n", duplLoc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.chars(), NOTE_STR, name.chars());
        name.drop();
        origLoc.drop();
        duplLoc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_DUPLICATE_FIELD);
    }

    func reportDuplicateParameter(&this, paramToken: Token, declSpan: Span) -> TCState {
        trace("TypeChecker.reportDuplicateParameter");
        let duplLoc: String = paramToken.span.toString();
        let origLoc: String = declSpan.toString();
        let name: String = paramToken.content.toString();
        fprintf(stderr, "%s: %s: Parameter redeclaration.\n", duplLoc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Parameter `%s` already declared here.\n", origLoc.chars(), NOTE_STR, name.chars());
        name.drop();
        origLoc.drop();
        duplLoc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_DUPLICATE_PARAMETER);
    }

    func reportUnknownField(&this, name: Token, decl: &StructLookup) -> TCState {
        trace("TypeChecker.reportUnknownField");
        let errLoc: String = name.span.toString();
        let declLoc: String = decl.name.span.toString();
        let strukt: String = decl.name.content.toString();
        let field: String = name.content.toString();
        fprintf(stderr, "%s: %s: Attempted to access unknown field `%s` of instance of struct %s.\n", errLoc.chars(), ERR_STR, field.chars(), strukt.chars());
        fprintf(stderr, "%s: %s: Struct %s is declared here.\n", declLoc.chars(), NOTE_STR, strukt.chars());
        field.drop();
        strukt.drop();
        declLoc.drop();
        errLoc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_UNKNOWN_FIELD);
    }

    func reportDuplicateFunction(&this, f1: &FunctionLookup, f2: &FunctionLookup) -> TCState {
        trace("TypeChecker.reportDuplicateFunction");
        let errLoc: String = f1.name.span.toString();
        let duplLoc: String = f2.name.span.toString();
        let name: String = f1.name.content.toString();
        fprintf(stderr, "%s: %s: Function redeclaration.\n", errLoc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: A function named `%s` with that signature is already declared here.\n", duplLoc.chars(), ERR_STR, name.chars());
        name.drop();
        duplLoc.drop();
        errLoc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_DUPLICATE_FUNCTION);
    }

    func reportDuplicateMethod(&this, m1: &MethodLookup, m2: &MethodLookup) -> TCState {
        trace("TypeChecker.reportDuplicateMethod");
        let errLoc: String = m1.name.span.toString();
        let duplLoc: String = m2.name.span.toString();
        let name: String = m1.name.content.toString();
        fprintf(stderr, "%s: %s: Method redeclaration.\n", errLoc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: A method named `%s` with that signature is already declared here.\n", duplLoc.chars(), ERR_STR, name.chars());
        name.drop();
        duplLoc.drop();
        errLoc.drop();
        return newTCStateFailure(ERROR_DUPLICATE_METHOD);
    }

    func reportNoFunctionCallCandidate(&this, callID: usize, functions: &FunctionLookupList) -> TCState {
        trace("TypeChecker.reportNoFunctionCallCandidate");
        let callExpr: &ParsedExpr = exprs.at(callID);
        assert(callExpr.kind == EXPR_CALL, "reportNoFunctionCallCandidate: Expected expr to be a call");
        let loc: String = callExpr.origToken.span.toString();
        let name: String = callExpr.origToken.content.toString();
        fprintf(stderr, "%s: %s: Could not find matching signature for call to function `%s`.\n", loc.chars(), ERR_STR, name.chars());
        assert(functions.length != 0, "reportNoFunctionCallCandidate: Expected at least one declaration");
        // REVIEW: It was suggested that we could hide this extra info behind a `--verbose` flag, which sounds interesting.
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f: &FunctionLookup = functions.at(i);
            let loc: String = f.name.span.toString();
            fprintf(stderr, "%s: %s: A function with that name is located here.\n", loc.chars(), NOTE_STR);
            loc.drop();
        }
        name.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_NO_CALL_CANDIDATE);
    }

    func reportNoMethodCallCandidate(&this, callID: usize, arguments: &TCStateList, methods: &MethodLookupList) -> TCState {
        trace("TypeChecker.reportNoMethodCallCandidate");
        let binExpr = exprs.at(callID);
        assert(binExpr.kind == EXPR_BINARY);
        let callExpr: &ParsedExpr = exprs.at(binExpr.rhs);
        assert(callExpr.kind == EXPR_CALL, "reportNoMethodCallCandidate: Expected expr to be a call");
        let loc: String = callExpr.origToken.span.toString();
        let name: String = callExpr.origToken.content.toString();
        fprintf(stderr, "%s: %s: Could not find matching signature for call to method `%s`.\n", loc.chars(), ERR_STR, name.chars());
        assert(methods.length != 0, "reportNoMethodCallCandidate: Expected at least one declaration");
        // REVIEW: It was suggested that we could hide this extra info behind a `--verbose` flag, which sounds interesting.
        for (let i: usize = 0; i < methods.length; i = i + 1) {
            let f: &MethodLookup = methods.at(i);
            let loc: String = f.name.span.toString();
            fprintf(stderr, "%s: %s: A method with that name is located here.\n", loc.chars(), NOTE_STR);
            loc.drop();
        }
        name.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_NO_CALL_CANDIDATE);
    }

    func reportVariableRedeclaration(&this, newDecl: Token, oldDecl: Token) -> TCState {
        trace("TypeChecker.reportVariableRedeclaration");
        let newLoc: String = newDecl.span.toString();
        let oldLoc: String = oldDecl.span.toString();
        let name: String = newDecl.content.toString();
        fprintf(stderr, "%s: %s: Variable redeclaration.\n", newLoc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Variable `%s` already declared here.\n", oldLoc.chars(), NOTE_STR, name.chars());
        name.drop();
        oldLoc.drop();
        newLoc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_VARIABLE_REDECLARATION);
    }

    func reportRecursiveType(&this, checked: &TypeLookup, cycle: &TypeLookupList) -> TCState {
        trace("TypeChecker.reportRecursiveType");
        let loc: String = checked.getLocation();
        let name: String = checked.getName();
        fprintf(stderr, "%s: %s: Recursive type %s.\n", loc.chars(), ERR_STR, name.chars());
        assert(cycle.length >= 1, "Cycle is empty");
        for (let i: usize = 1; i < cycle.length; i = i + 1) {
            loc = cycle.at(i).getLocation();
            name = cycle.at(i).getName();
            fprintf(stderr, "%s: %s: Chain of recursion also includes type %s.\n", loc.chars(), NOTE_STR, name.chars());
        }
        name.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_RECURSIVE_TYPE);
    }

    func reportNonPrimitiveCast(&this, span: Span, from: &Type, to: &Type) -> TCState {
        trace("TypeChecker.reportNonPrimitiveCast");
        let loc: String = span.toString();
        let typ1: String = from.toString();
        let typ2: String = to.toString();
        fprintf(stderr, "%s: %s: Non primitive cast from type %s to %s.\n",
            loc.chars(), ERR_STR, typ1.chars(), typ2.chars());
        typ1.drop();
        typ2.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_NON_PRIMITIVE_CAST);
    }

    func reportIndexedAccessOnNonArray(&this, span: Span, typ: &Type) -> TCState {
        trace("TypeChecker.reportIndexedAccessOnNonArray");
        let loc: String = span.toString();
        let name: String = typ.toString();
        fprintf(stderr, "%s: %s: Indexed Access is only supported for arrays.\n", loc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Expression has type %s.\n", loc.chars(), NOTE_STR, name.chars());
        name.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
    }

    func reportRuntimeValueInComptimeContext(&this, ident: Token, var: &VariableLookup) -> TCState {
        trace("TypeChecker.reportRuntimeValueInComptimeContext");
        let loc = ident.span.toString();
        let otherLoc = var.name.span.toString();
        let name = ident.content.toString();
        fprintf(stderr, "%s: %s: Variables declared with `let` can't be used in a comptime context.\n", loc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Variable `%s` is declared here.\n", otherLoc.chars(), NOTE_STR, name.chars());
        name.drop();
        otherLoc.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT);
    }

    func reportAnyDereference(&this, expr: &ParsedExpr) -> TCState {
        trace("TypeChecker.reportAnyDereference");
        let loc = expr.span.toString();
        fprintf(stderr, "%s: %s: Can't dereference expression of type Any.\n", loc.chars(), ERR_STR);
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_ANY_DEREF);
    }

    func reportMemberAccessOnNonStruct(&this, expr: &ParsedExpr, instance: &Type) -> TCState {
        trace("TypeChecker.reportMemberAccessOnNonStruct");
        let loc = expr.span.toString();
        let t = instance.toString();
        fprintf(stderr, "%s: %s: The Dot-Operator is not defined for values of type %s.\n", loc.chars(), ERR_STR, t.chars());
        t.drop();
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_MEMBER_ACCESS_NON_STRUCT);
    }

    func reportMemberAccessTooManyOptions(&this, expr: &ParsedExpr, structs: &StructLookupList) -> TCState {
        trace("TypeChecker.reportMemberAccessTooManyOptions");
        assert(structs.length > 0);
        let loc = expr.span.toString();
        fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.chars(), ERR_STR);
        for (let i: usize = 0; i < structs.length; i = i + 1) {
            let s = structs.at(i);
            let l = s.name.span.toString();
            let n = s.name.content.toString();
            fprintf(stderr, "%s: %s: Context allows struct %s to be used.\n", l.chars(), NOTE_STR, n.chars());
            n.drop();
            l.drop();
        }
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS);
    }

    func reportFunctionCallTooManyOptions(&this, expr: &ParsedExpr, functions: &FunctionLookupList) -> TCState {
        trace("TypeChecker.reportFunctionCallTooManyOptions");
        assert(functions.length > 0);
        let loc = expr.span.toString();
        fprintf(stderr, "%s: %s: Could not infer which function to call.\n", loc.chars(), ERR_STR);
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f = functions.at(i);
            let l = f.name.span.toString();
            let n = f.name.content.toString();
            fprintf(stderr, "%s: %s: Context allows this function to be called.\n", l.chars(), NOTE_STR, n.chars());
            n.drop();
            l.drop();
        }
        loc.drop();
        this.typeError = true;
        return newTCStateFailure(ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS);
    }

    func emergencyPrint(&this, where: Span) {
        let t: Token = Token {
            span: where,
            content: newSubStrOfStrLit(""),
            kind: TOKEN_EOF
        };
        t.getLocation().print();
        printf("\n");
    }

    func typeCheckProject(&this, project: &ParsedModule) -> bool {
        trace("TypeChecker.typeCheckProject");
        if (!this.fillLookup()) return false;
        if (!this.typeCheckModules()) return false;
        if (this.findRecursiveTypes()) return false;
        return !this.typeError;
    }

    func dfs(&this, typeLookup: TypeLookup, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
        trace("TypeChecker.dfs");
        if (finished.contains(&typeLookup))
            return false;
        if (visited.contains(&typeLookup))
            return true;
        visited.push(typeLookup);
        let done: bool = false;
        if (typeLookup.isStruct()) {
            let strukt: &StructLookup = (&typeLookup).asStruct();
            for (let i: usize = 0; i < strukt.fields.length; i = i + 1) {
                let field: &VariableLookup = strukt.fields.at(i);
                assert(field.typeState.isSuccess(), "Expected valid field type in DFS");
                let fieldTypeID: usize = field.typeState.getType();
                let fieldType: &Type = types.at(fieldTypeID);
                if (fieldType.isStructArray()) {
                    let typeID: usize = fieldType.typeIndex;
                    let elemType: &Type = types.at(typeID);
                    assert(elemType.isStruct());
                    let structID: usize = elemType.typeIndex;
                    let decl: &ParsedStructDecl = structDecls.at(structID);
                    let mod: &ModuleLookup = this.lookup.modules.at(decl.parentModule);
                    let strukt: &StructLookup = mod.getStructByGlobalID(structID);
                    if (this.dfs(strukt.asTypeLookup(), visited, finished)) {
                        done = true;
                    }
                } else if (fieldType.isStruct()) {
                    let structID: usize = fieldType.typeIndex;
                    let decl: &ParsedStructDecl = structDecls.at(structID);
                    let mod: &ModuleLookup = this.lookup.modules.at(decl.parentModule);
                    let strukt: &StructLookup = mod.getStructByGlobalID(structID);
                    if (this.dfs(strukt.asTypeLookup(), visited, finished)) {
                        done = true;
                    }
                }
            }
        } else {
            todo_with_msg("dfs on non-struct");
        }
        finished.push(typeLookup);
        return done;
    }

    func findRecursiveTypes(&this) -> bool {
        trace("TypeChecker.findRecursiveTypes");
        let recursive: bool = false;
        for (let i: usize = 0; i < structDecls.length; i = i + 1) {
            let decl: &ParsedStructDecl = structDecls.at(i);
            let mod: &ModuleLookup = this.lookup.modules.at(decl.parentModule);
            let strukt: &StructLookup = mod.getStructByGlobalID(i);
            let visited: TypeLookupList = blank;
            let finished: TypeLookupList = blank;
            if (this.dfs(strukt.asTypeLookup(), &visited, &finished)) {
                this.reportRecursiveType(&strukt.asTypeLookup(), &visited);
                recursive = true;
            }
        }
        return recursive;
    }

    func fillLookup(&this) -> bool {
        trace("TypeChecker.fillLookup");
        for (let i: usize = 0; i < modules.length; i = i + 1) {
            let mod: &ParsedModule = modules.at(i);
            assert(mod.getID() == i);
            this.currentModule = i;
            let lookup: &ModuleLookup = this.lookup.insertModule(mod);
            for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
                let tliID: usize = mod.getTopLevelItemAtIndex(j);
                let tli: &ParsedTopLevelItem = topLevelItems.at(tliID);
                if (tli.ignored) continue;
                lookup.insertTLI(tli);
            }
        }
        return true;
    }

    func typeCheckModules(&this) -> bool {
        trace("TypeChecker.typeCheckModules");
        let done: bool = false;
        let success: bool = true;
        while (!done) {
            done = true;
            for (let i: usize = 0; i < modules.length; i = i + 1) {
                let mod: &ParsedModule = modules.at(i);
                assert(mod.getID() == i);
                this.currentModule = i;
                let currModule: &ModuleLookup = this.lookup.modules.at(i);
                assert(currModule.variables.length == 1, "still deez");
                for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
                    let tliID: usize = mod.getTopLevelItemAtIndex(j);
                    let tli: &ParsedTopLevelItem = topLevelItems.at(tliID);
                    let state: TCState = this.typeCheckTLI(tli);
                    (*tli).typeState = state;
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) {
                            done = false;
                            // break;
                        } else if (state.isCriticalError()) {
                            // We can't continue here
                            return false;
                        } else {
                            success = false;
                        }
                    }
                }
            }
        }
        return success;
    }

    func typeCheckTLI(&this, tli: &ParsedTopLevelItem) -> TCState {
        trace("TypeChecker.typeCheckTLI");
        if (tli.ignored) return blank;
        this.currentFunction = null;
        this.currentMethod = null;
        let currentModule: &ModuleLookup = this.lookup.modules.at(this.currentModule);
        assert(currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        if (tli.kind == TLI_IMPORT) {
            return newTCStateSuccess();
        } else if (tli.kind == TLI_FUNC_DECL) {
            return this.typeCheckFunction(tli.nodeID, &currentModule.variables);
        } else if (tli.kind == TLI_STRUCT_DECL) {
            return this.typeCheckStructDecl(tli.nodeID);
        } else if (tli.kind == TLI_VAR_DECL) {
            return this.typeCheckVarDecl(tli.nodeID, &currentModule.variables, true);
        } else {
            unreachable("Exhaustive handling of TLI in typeCheckTLI");
        }
    }

    func typeCheckStructDecl(&this, structID: usize) -> TCState {
        trace("TypeChecker.typeCheckStructDecl");
        let strukt: &ParsedStructDecl = structDecls.at(structID);
        if (strukt.ignored) return blank;
        let moduleLookup: &ModuleLookup = this.lookup.modules.at(this.currentModule);
        let structLookup: &StructLookup = moduleLookup.getStructByGlobalID(structID);
        let context: &StructContext = &strukt.context;
        let result: TCState = newTCStateSuccess();
        if (!structLookup.getReadyState(STRUCT_READY_TO_USE)) {
            if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE)) {
                let failure: TCState = blank;
                for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
                    let name: Token = context.getFieldNameAtIndex(i);
                    let typ: usize = context.getFieldTypeAtIndex(i);
                    let dupl: VariableLookup = blank;
                    if (structLookup.checkForDuplicateField(&name, &dupl)) {
                        failure = this.reportDuplicateField(name, dupl.name.span);
                        continue;
                    }
                    let state: TCState = this.typeCheckTypeNode(typ);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    structLookup.addField(NODE_ID_OFFSET + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                structLookup.setReadyState(STRUCT_FIELDS_COMPLETE);
            }
            if (!structLookup.getReadyState(STRUCT_SIGNATURE_COMPLETE)) {
                let lookup: bool = false;
                let error: usize = 0;
                for (let i: usize = 0; i < context.methodLength; i = i + 1) {
                    let methodID: usize = context.getMethodAtIndex(i);
                    let state: TCState = this.typeCheckMethod(structID, methodID, true);
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) lookup = true;
                        if (state.isCriticalError()) error = err;
                    }
                    // Don't need to do anything with the StructLookup here because typeCheckMethod
                    // already updates MethodLookup accordingly
                }
                if (error != ERROR_INVALID) return newTCStateFailure(error);
                if (lookup) return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                structLookup.setReadyState(STRUCT_SIGNATURE_COMPLETE);
            }
            if (!structLookup.getReadyState(STRUCT_METHODS_COMPLETE)) {
                let lookup: bool = false;
                for (let i: usize = 0; i < context.methodLength; i = i + 1) {
                    let methodID: usize = context.getMethodAtIndex(i);
                    let state: TCState = this.typeCheckMethod(structID, methodID, false);
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) lookup = true;
                        if (state.isCriticalError()) return state;
                    }
                }
                if (lookup) return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                structLookup.setReadyState(STRUCT_METHODS_COMPLETE);
            }
            structLookup.setReadyState(STRUCT_READY_TO_USE);
        }
        (*strukt).typeState = newTCStateSuccess();
        return result;
    }

    func typeCheckMethod(&this, structID: usize, methodID: usize, onlySignature: bool) -> TCState {
        trace("TypeChecker.typeCheckMethod");
        // REVIEW: We can improve performance by passing the StructLookup instead of the ID
        let method: &ParsedMethod = methods.at(methodID);
        if (method.ignored) return blank;
        let moduleLookup: &ModuleLookup = this.lookup.modules.at(this.currentModule);
        let structLookup: &StructLookup = moduleLookup.getStructByGlobalID(structID);
        let methodLookup: &MethodLookup = structLookup.getMethodByGlobalID(methodID);
        if (methodLookup.getReadyState(METHOD_BODY_COMPLETE)) {
            assert(methodLookup.getReadyState(METHOD_READY_TO_USE), "Method should be ready to use at this point");
            return method.typeState;
        }
        this.currentMethod = methodLookup;
        if (!methodLookup.getReadyState(METHOD_READY_TO_USE)) {
            if (!methodLookup.getReadyState(METHOD_PARAMS_COMPLETE)) {
                let failure: TCState = blank;
                methodLookup.params.clear();
                for (let i: usize = 0; i < method.params.paramLength; i = i + 1) {
                    let typ: usize = method.params.getTypeAtIndex(i);
                    let name: Token = method.params.getNameAtIndex(i);
                    let dupl: VariableLookup = blank;
                    if (methodLookup.checkForDuplicateParam(&name, &dupl)) {
                        failure = this.reportDuplicateParameter(name, dupl.name.span);
                        methodLookup.setReadyState(METHOD_PARAMS_COMPLETE);
                        continue;
                    }
                    let state: TCState = this.typeCheckTypeNode(typ);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    methodLookup.addParameter(NODE_ID_OFFSET + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                methodLookup.setReadyState(METHOD_PARAMS_COMPLETE);
            }
            if (!methodLookup.getReadyState(METHOD_RETTYPE_COMPLETE)) {
                let retState: TCState = this.typeCheckTypeNode(method.retTypeID);
                if (retState.isError()) return retState;
                methodLookup.setReturnType(retState);
                methodLookup.setReadyState(METHOD_RETTYPE_COMPLETE);
            }
            methodLookup.setReadyState(METHOD_READY_TO_USE);
        }
        if (onlySignature) {
            assert(methodLookup.getReadyState(METHOD_READY_TO_USE), "expected method to be ready for use after checking signature");
            return newTCStateSuccess();
        }
        (*method).typeState = newTCStateSuccess();
        if (!methodLookup.getReadyState(METHOD_DUPLICATE_CHECK)) {
            // FIXME: We need to use usize because the bootstrap doesn't support nested references :^)
            let _dupl: usize = 0;
            if (structLookup.containsDuplicateMethod(methodLookup, &_dupl)) {
                assert(_dupl != 0, "Duplicate MethodLookup is null");
                return this.reportDuplicateMethod(methodLookup, _dupl as &MethodLookup);
            }
            methodLookup.setReadyState(METHOD_DUPLICATE_CHECK);
        }
        if (!methodLookup.getReadyState(METHOD_BODY_COMPLETE)) {
            let scopes: ScopeLookupList = blank;
            let scope: ScopeLookup = blank;
            for (let i: usize = 0; i < methodLookup.params.length; i = i + 1) {
                scope.addVariable(*(methodLookup.params.at(i)));
            }
            scopes.push(scope);
            let blockState: TCState = this.typeCheckBlock(method.body, &scopes);
            scopes.pop();
            if (blockState.isError()) return blockState;
            methodLookup.setReadyState(METHOD_BODY_COMPLETE);
        }
        return method.typeState;
    }

    func typeCheckFunction(&this, funcID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckFunction");
        let function: &ParsedFuncDecl = funcDecls.at(funcID);
        if (function.ignored) return blank;
        let moduleLookup: &ModuleLookup = this.lookup.modules.at(this.currentModule);
        let funcLookup: &FunctionLookup = moduleLookup.getFunctionByGlobalID(funcID);
        if (funcLookup.getReadyState(FUNC_BODY_COMPLETE)) {
            assert(funcLookup.getReadyState(FUNC_READY_TO_USE), "Function should be ready to use at this point");
            return function.typeState;
        }
        this.currentFunction = funcLookup;
        if (!funcLookup.getReadyState(FUNC_READY_TO_USE)) {
            if (!funcLookup.getReadyState(FUNC_PARAMS_COMPLETE)) {
                let failure: TCState = blank;
                funcLookup.params.clear();
                for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
                    let typ: usize = function.params.getTypeAtIndex(i);
                    let name: Token = function.params.getNameAtIndex(i);
                    let dupl: VariableLookup = blank;
                    if (funcLookup.checkForDuplicateParam(&name, &dupl)) {
                        failure = this.reportDuplicateParameter(name, dupl.name.span);
                        funcLookup.setReadyState(FUNC_PARAMS_COMPLETE);
                        continue;
                    }
                    let state: TCState = this.typeCheckTypeNode(typ);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    funcLookup.addParameter(NODE_ID_OFFSET + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                funcLookup.setReadyState(FUNC_PARAMS_COMPLETE);
            }
            if (!funcLookup.getReadyState(FUNC_RETTYPE_COMPLETE)) {
                let retState: TCState = this.typeCheckTypeNode(function.retTypeID);
                if (retState.isError()) return retState;
                funcLookup.setReturnType(retState);
                funcLookup.setReadyState(FUNC_RETTYPE_COMPLETE);
            }
            funcLookup.setReadyState(FUNC_READY_TO_USE);
        }
        (*function).typeState = newTCStateSuccess();
        if (!funcLookup.getReadyState(FUNC_DUPLICATE_CHECK)) {
            // FIXME: We need to use usize because the bootstrap doesn't support nested references :^)
            let _dupl: usize = 0;
            if (moduleLookup.containsDuplicateFunction(funcLookup, &_dupl)) {
                assert(_dupl != 0, "Duplicate FunctionLookup is null");
                return this.reportDuplicateFunction(funcLookup, _dupl as &FunctionLookup);
            }
            funcLookup.setReadyState(FUNC_DUPLICATE_CHECK);
        }
        if (!funcLookup.getReadyState(FUNC_BODY_COMPLETE)) {
            let scope: ScopeLookup = blank;
            for (let i: usize = 0; i < funcLookup.params.length; i = i + 1) {
                scope.addVariable(*(funcLookup.params.at(i)));
            }
            if (!function.isExtern()) {
                scopes.push(scope);
                let blockState: TCState = this.typeCheckBlock(function.body, scopes);
                scopes.pop();
                if (blockState.isError()) {
                    return blockState;
                }
            }
            funcLookup.setReadyState(FUNC_BODY_COMPLETE);
        }
        return function.typeState;
    }

    func typeCheckBlock(&this, blockID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckBlock");
        let block: &ParsedBlock = blocks.at(blockID);
        if (block.ignored) return blank;
        if (block.typeState.isSuccess()) {
            return block.typeState;
        }
        scopes.push(ScopeLookup {
            variables: blank,
        });
        let curr: usize = scopes.length;
        // REVIEW: Do we want to make blocks expressions?
        let blockState: TCState = newTCStateSuccess();
        for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
            let stmtState: TCState = this.typeCheckStmt(block.getStmtAtIndex(i), scopes);
            if (stmtState.isError()) {
                let err: usize = stmtState.getError();
                if (err == ERROR_LOOKUP_NOT_READY) {
                    blockState = stmtState;
                    break;
                } else {
                    blockState = stmtState;
                }
            }
        }
        let after: usize = scopes.length;
        scopes.pop();
        assert(after == curr, "Stack imbalance");
        if (blockState.isError()) return blockState;
        (*block).typeState = newTCStateSuccess();
        return block.typeState;
    }

    func typeCheckStmt(&this, stmtID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckStmt");
        let stmt: &ParsedStmt = stmts.at(stmtID);
        if (stmt.ignored) return blank;
        if (stmt.kind == STMT_BLOCK) {
            let blockState: TCState = this.typeCheckBlock(stmt.block, scopes);
            if (blockState.isError()) return blockState;
            (*stmt).typeState = blockState;
            return blockState;
        } else if (stmt.kind == STMT_VAR_DECL) {
            return this.typeCheckVarDecl(stmtID, scopes, false);
        } else if (stmt.kind == STMT_EXPR) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            let exprState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            if (exprState.isError()) return exprState;
            if (exprState.wantsInfer()) todo_with_msg("stmt expr infer");
            let expr: &ParsedExpr = exprs.at(stmt.expr);
            if (!exprState.isType()) {
                printf("%llu\n", exprState.kind);
                todo_with_msg("what is it then");
            }
            let exprType: &Type = types.at(exprState.getType());
            if (!exprType.isNone() && !expr.isAssignment()) {
                let loc: String = expr.span.toString();
                fprintf(stderr, "%s: %s: Unused expression value.\n", loc.chars(), WARN_STR);
                loc.drop();
            }
            (*stmt).typeState = exprState;
            return newTCStateSuccess();
        } else if (stmt.kind == STMT_IF) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            let condState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            let thenState: TCState = this.typeCheckStmt(stmt.ifContext.thenBody, scopes);
            let elseState: TCState = newTCStateSuccess();
            if (stmt.ifContext.hasElse) {
                elseState = this.typeCheckStmt(stmt.ifContext.elseBody, scopes);
            }
            if (condState.isError()) return condState;
            if (thenState.isError()) return thenState;
            if (elseState.isError()) return elseState;
            let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            if (condState.wantsInfer()) {
                condState = this.inferTypeOntoExpr(stmt.expr, boolType.getID());
                assert(condState.isType(), "Could not infer type onto if-condition");
            }
            let condType: &Type = types.at(condState.getType());
            if (!condType.isBoolean()) {
                return this.reportTypeMismatch(exprs.at(stmt.expr).span, boolType, condType);
            }
            let state: TCState = newTCStateSuccess();
            (*stmt).typeState = state;
            return state;
        } else if (stmt.kind == STMT_RETURN_EXPR) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            let exprState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            if (exprState.isError()) return exprState;
            if (this.currentFunction != null) {
                assert(this.currentFunction.getReadyState(FUNC_READY_TO_USE), "Function is not ready");
                let _retType: &Type = types.at(this.currentFunction.returnType.getType());
                if (_retType.isNone()) todo_with_msg("unexpected ret expr where empty function");
                let retState: &TCState = &this.currentFunction.returnType;
                assert(retState.isSuccess(), "ready to use function has invalid return type");
                assert(retState.isType(), "ready to use function has non-type as return type");
                if (exprState.wantsInfer()) {
                    exprState = this.inferTypeOntoExpr(stmt.expr, retState.getType());
                    if (exprState.isError()) return exprState;
                    assert(exprState.isType(), "Failed to infer type of return expression");
                }
                let exprType: &Type = types.at(exprState.getType());
                let retType: &Type = types.at(retState.getType());
                if (!exprType.equals(retType)) {
                    return this.reportTypeMismatch(stmt.span, retType, exprType);
                }
                (*stmt).typeState = *retState;
                return newTCStateSuccess();
            } else if (this.currentMethod != null) {
                assert(this.currentMethod.getReadyState(METHOD_READY_TO_USE), "Method is not ready");
                let _retType: &Type = types.at(this.currentMethod.returnType.getType());
                if (_retType.isNone()) todo_with_msg("unexpected ret expr where empty method");
                let retState: &TCState = &this.currentMethod.returnType;
                assert(retState.isSuccess(), "ready to use method has invalid return type");
                assert(retState.isType(), "ready to use method has non-type as return type");
                if (exprState.wantsInfer()) {
                    exprState = this.inferTypeOntoExpr(stmt.expr, retState.getType());
                    if (exprState.isError()) return exprState;
                    assert(exprState.isType(), "Failed to infer type of return expression");
                }
                let exprType: &Type = types.at(exprState.getType());
                let retType: &Type = types.at(retState.getType());
                if (!exprType.equals(retType)) {
                    return this.reportTypeMismatch(stmt.span, retType, exprType);
                }
                (*stmt).typeState = *retState;
                return newTCStateSuccess();
            } else {
                unreachable("Expected to be either in a method or function, got none of both");
            }
        } else if (stmt.kind == STMT_RETURN_EMPTY) {
            if (this.currentFunction != null) {
                assert(this.currentFunction.getReadyState(FUNC_READY_TO_USE), "Function is not ready");
                let retType: &Type = types.at(this.currentFunction.returnType.getType());
                if (!retType.isNone()) {
                    printf("%s\n", stmt.span.toString().chars());
                    printf("%llu %llu\n", retType.kind, retType.typeIndex);
                    todo_with_msg("function returns something, but we wrote return;");
                }
                (*stmt).typeState = newTCStateSuccess();
                return newTCStateSuccess();
            } else if (this.currentMethod != null) {
                assert(this.currentMethod.getReadyState(METHOD_READY_TO_USE), "Method is not ready");
                let retType: &Type = types.at(this.currentMethod.returnType.getType());
                if (!retType.isNone()) todo_with_msg("method returns something, but we wrote return;");
                (*stmt).typeState = newTCStateSuccess();
                return newTCStateSuccess();
            } else {
                unreachable("Expected to be either in a method or function, got none of both");
            }
        } else if (stmt.kind == STMT_WHILE) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            let condState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            let bodyState: TCState = this.typeCheckStmt(stmt.block, scopes);
            let stepState: TCState = this.typeCheckExpr(stmt.step, scopes);
            if (condState.isError()) return condState;
            if (bodyState.isError()) return bodyState;
            if (stepState.isError()) return stepState;
            let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            if (condState.wantsInfer()) {
                condState = this.inferTypeOntoExpr(stmt.expr, boolType.getID());
                assert(condState.isType(), "Could not infer type onto while-condition");
            }
            let condType: &Type = types.at(condState.getType());
            if (!condType.isBoolean()) {
                return this.reportTypeMismatch(exprs.at(stmt.expr).span, boolType, condType);
            }
            (*stmt).typeState = newTCStateSuccess();
            return newTCStateSuccess();
        } else if (stmt.kind == STMT_BREAK || stmt.kind == STMT_CONTINUE) {
            (*stmt).typeState = newTCStateSuccess();
            return newTCStateSuccess();
        } else {
            this.emergencyPrint(stmt.span);
            unreachable("Exhaustive handling of stmts in typeCheckStmt");
        }
    }

    func typeCheckVarDecl(&this, varDeclID: usize, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
        trace("TypeChecker.typeCheckVarDecl");
        let varDecl: &ParsedStmt = stmts.at(varDeclID);
        if (varDecl.ignored) return blank;
        assert(varDecl.kind == STMT_VAR_DECL, "Stmt expected to be a VarDecl");
        let context: VarDeclContext = varDecl.varDeclContext;
        let last: &ScopeLookup = scopes.last();
        let typeState: TCState = blank;
        let exprState: TCState = blank;
        if (varDecl.typeState.isSuccess()) {
            typeState = varDecl.typeState;
            exprState = varDecl.typeState;
        } else {
            let loc: Token = blank;
            // REVIEW: Warn about shadowing?
            if (!globalScope && last.isKnownVariable(context.name.content, &loc)) {
                return this.reportVariableRedeclaration(context.name, loc);
            }
            if (context.typeID != TYPE_INVALID) {
                typeState = this.typeCheckTypeNode(context.typeID);
                if (typeState.isError()) return typeState;
                if (!typeState.isType()) todo_with_msg("let type is not a type");
            }
            this.isComptimeContext = context.isComptime;
            exprState = this.typeCheckExpr(context.exprID, scopes);
            this.isComptimeContext = false;
            if (context.typeID == TYPE_INVALID) {
                // let var = expr;
                assert(typeState.isInvalid(), "`let var = expr;` got valid type state??");
                if (exprState.isError()) return exprState;
                if (exprState.wantsInfer()) {
                    todo_with_msg("`let var = expr;` wants inferred expr");
                }
                if (!exprState.isType()) todo_with_msg("let expr is not a type");
                typeState = exprState;
            } else {
                // let var: type = expr;
                if (exprState.wantsInfer()) {
                    exprState = this.inferTypeOntoExpr(context.exprID, typeState.getType());
                }
                if (exprState.isType()) {
                    let typeType: &Type = types.at(typeState.getType());
                    let exprType: &Type = types.at(exprState.getType());
                    if (!typeType.equals(exprType)) {
                        let exprNode: &ParsedExpr = exprs.at(context.exprID);
                        exprState = this.reportTypeMismatch(exprNode.span, typeType, exprType);
                    }
                }
            }
        }
        if (globalScope) {
            let index: usize = 0;
            assert(last.getVarIndexByName(context.name.content, &index), "Could not find variable in global scope");
            let var: &VariableLookup = last.getVariableAtIndex(index);
            (*var).typeState = typeState;
        } else {
            last.addVariable(VariableLookup {
                globalID: varDecl.getID(),
                name: context.name,
                typeState: typeState,
                isComptime: context.isComptime,
            });
        }
        if (exprState.isError()) return exprState;
        (*varDecl).typeState = typeState;
        return typeState;
    }

    func typeCheckExpr(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExpr");
        let expr: &ParsedExpr = exprs.at(exprID);
        if (expr.ignored) return blank;
        if (expr.typeState.isSuccess()) return expr.typeState;
        let state: TCState = blank;
        if (expr.kind == EXPR_EMPTY) {
            state = newTCStateSuccess();
        } else if (expr.kind == EXPR_INT_LIT) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_STRING_LIT) {
            let ct: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
            let st: &Type = newType(TYPE_KIND_POINTER, ct.getID());
            state = newTCStateType(st.getID());
        } else if (expr.kind == EXPR_CHAR_LIT) {
            let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
            state = newTCStateType(t.getID());
        } else if (expr.kind == EXPR_ARRAY_LIT) {
            let context: &ArrayContext = &expr.arrayContext;
            assert(context.elemLength != 0, "Zero sized Array Literal spotted");
            let elemIndex: usize = context.getElementAtIndex(0);
            let elemState: TCState = this.typeCheckExpr(elemIndex, scopes);
            if (elemState.isError()) return elemState;
            if (elemState.wantsInfer()) return elemState;
            let elemTypeID: usize = elemState.getType();
            if (context.size == 0) {
                let elemType: &Type = types.at(elemTypeID);
                let lastErrState: TCState = blank;
                for (let i: usize = 1; i < context.elemLength; i = i + 1) {
                    let nextIndex: usize = context.getElementAtIndex(i);
                    let nextState: TCState = this.typeCheckExpr(nextIndex, scopes);
                    if (nextState.isError()) {
                        lastErrState = nextState;
                        continue;
                    }
                    let nextType: &Type = types.at(nextState.getType());
                    if (!nextType.equals(elemType)) {
                        let loc = exprs.at(elemIndex).span.toString();
                        let t = elemType.toString();
                        lastErrState = this.reportTypeMismatch(exprs.at(nextIndex).span, elemType, nextType);
                        fprintf(stderr, "%s: %s: Array elements inferred to be type %s here.\n", loc.chars(), NOTE_STR, t.chars());
                        t.drop();
                        loc.drop();
                    }
                }
                if (!lastErrState.isInvalid()) return lastErrState;
                let t: &Type = newType(TYPE_KIND_ARRAY, elemTypeID);
                (*t).arraySize = context.elemLength;
                state = newTCStateType(t.getID());
            } else {
                let t: &Type = newType(TYPE_KIND_ARRAY, elemTypeID);
                (*t).arraySize = context.size;
                state = newTCStateType(t.getID());
            }
        } else if (expr.kind == EXPR_NAME) {
            state = this.typeCheckIdentifier(exprID, scopes);
        } else if (expr.kind == EXPR_UNARY) {
            state = this.typeCheckUnary(exprID, scopes);
        } else if (expr.kind == EXPR_BINARY) {
            state = this.typeCheckExprBinary(exprID, scopes);
        } else if (expr.kind == EXPR_CALL) {
            state = this.typeCheckExprCall(exprID, scopes);
        } else if (expr.kind == EXPR_SIZEOF) {
            state = this.typeCheckExprSizeof(exprID, scopes);
        } else if (expr.kind == EXPR_STRUCT_INIT) {
            state = this.typeCheckExprStructInit(exprID, scopes);
        } else if (expr.kind == EXPR_AS) {
            state = this.typeCheckExprAs(exprID, scopes);
        } else if (expr.kind == EXPR_NULL) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_BLANK) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
            let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            state = newTCStateType(t.getID());
        } else {
            unreachable("Exhaustive handling of expressions in typeCheckExpr");
        }
        if (state.isError()) return state;
        (*expr).typeState = state;
        return state;
    }

    func typeCheckExprSizeof(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprSizeof");
        let expr: &ParsedExpr = exprs.at(exprID);
        if (expr.typeState.isSuccess()) return expr.typeState;
        assert(expr.kind == EXPR_SIZEOF);
        let typeState: TCState = this.typeCheckTypeNode(expr.lhs);
        if (typeState.isError()) return typeState;
        let ut: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        return newTCStateType(ut.getID());
    }

    func typeCheckExprAs(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprAs");
        let expr: &ParsedExpr = exprs.at(exprID);
        assert(expr.kind == EXPR_AS);
        let exprState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let typeState: TCState = this.typeCheckTypeNode(expr.rhs);
        if (exprState.isError()) return exprState;
        if (typeState.isError()) return typeState;
        assert(typeState.isType(), "typeCheckExprAs Type is not a Type");
        let typeType: &Type = types.at(typeState.getType());
        if (exprState.wantsInfer()) exprState = this.inferTypeOntoExpr(expr.lhs, typeType.getID());
        if (exprState.isError()) return exprState;
        assert(exprState.isType(), "Expected <expr> in `<expr> as <type>` to have a valid type after infer");
        let exprType: &Type = types.at(exprState.getType());
        if (typeType.isPointer() && exprType.isPointer()) {
            // PTR as PTR is allowed
        } else if (exprType.isPointer() && typeType.isInteger()) {
            if (typeType.getSize() != exprType.getSize()) {
                let loc = expr.span.toString();
                let from = exprType.toString();
                let to = typeType.toString();
                fprintf(stderr, "%s: %s: Casting pointer of type %s to integer of type %s.\n",
                    loc.chars(), WARN_STR, from.chars(), to.chars());
                to.drop();
                from.drop();
                loc.drop();
            }
        } else if (exprType.isInteger() && typeType.isPointer()) {
            if (typeType.getSize() != exprType.getSize()) {
                let loc = expr.span.toString();
                let from = exprType.toString();
                let to = typeType.toString();
                fprintf(stderr, "%s: %s: Casting integer of type %s to pointer of type %s.\n",
                    loc.chars(), WARN_STR, from.chars(), to.chars());
                to.drop();
                from.drop();
                loc.drop();
            }
        } else if (!typeType.isPrimitive()) {
            return this.reportNonPrimitiveCast(expr.span, exprType, typeType);
        } else if (!exprType.isPrimitive()) {
            return this.reportNonPrimitiveCast(expr.span, exprType, typeType);
        }
        if (typeType.getSize() < exprType.getSize()) {
            let loc: String = expr.span.toString();
            let tName: String = typeType.toString();
            let oName: String = exprType.toString();
            fprintf(stderr, "%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n",
                loc.chars(), WARN_STR, tName.chars(), oName.chars());
            oName.drop();
            tName.drop();
            loc.drop();
        }
        return typeState;
    }

    func typeCheckUnary(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckUnary");
        let expr: &ParsedExpr = exprs.at(exprID);
        assert(expr.kind == EXPR_UNARY);
        let exprState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        if (exprState.isError()) return exprState;
        if (exprState.wantsInfer()) return exprState; // Can't be done in here
        if (expr.op == UNARY_COMPTIME) {
            return exprState;
        } else if (expr.op == UNARY_DEREF) {
            let exprType: &Type = types.at(exprState.getType());
            if (exprType.isPrimitive()) {
                if (exprType.typeIndex == TYPE_ANY) {
                    return this.reportAnyDereference(expr);
                }
            }
            if (!exprType.isPointer()) {
                todo_with_msg("deref non-pointer");
            }
            let underlying: &Type = exprType.getUnderlyingType(false);
            return newTCStateType(underlying.getID());
        } else if (expr.op == UNARY_REF) {
            let exprType: &Type = types.at(exprState.getType());
            let t: &Type = newType(TYPE_KIND_POINTER, exprType.getID());
            return newTCStateType(t.getID());
        } else if (expr.op == UNARY_NOT) {
            let exprType: &Type = types.at(exprState.getType());
            if (!exprType.isBoolean()) {
                let loc: String = expr.span.toString();
                let t: String = exprType.toString();
                fprintf(stderr, "%s: %s: Logical Not is not defined for type %s.\n", loc.chars(), ERR_STR, t.chars());
                t.drop();
                loc.drop();
                this.typeError = true;
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        } else if (expr.op == UNARY_MINUS) {
            let exprType: &Type = types.at(exprState.getType());
            if (!exprType.isSignedInteger() && !exprType.isFloat()) {
                let loc: String = expr.span.toString();
                let t: String = exprType.toString();
                fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.chars(), ERR_STR, t.chars());
                t.drop();
                loc.drop();
                this.typeError = true;
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        } else {
            unreachable("Exhaustive handling of ops in typeCheckUnary");
        }
    }

    func typeCheckExprCall(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprCall");
        // REVIEW: Would be cool if the call base could be any expression, not just an identifier
        let expr: &ParsedExpr = exprs.at(exprID);
        assert(expr.kind == EXPR_CALL);
        let name: Token = expr.origToken;
        let functions: FunctionLookupList = this.lookup.resolveFunctionByName(this.currentModule, &name);
        if (functions.length == 0) {
            let loc: String = name.getLocation();
            let n: String = name.content.toString();
            fprintf(stderr, "%s: %s: Call to unknown function `%s`.\n", loc.chars(), ERR_STR, n.chars());
            let alternatives: FunctionLookupList = this.lookup.searchAllModulesForFunctionName(&name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &FunctionLookup = &*alternatives.at(i);
                let loc: String = t.name.getLocation();
                fprintf(stderr, "%s: %s: A function with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                loc.drop();
            }
            n.drop();
            loc.drop();
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
        }
        let callContext: &ArrayContext = &expr.arrayContext;
        let arguments: TCStateList = blank;
        for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
            let argID: usize = callContext.getElementAtIndex(i);
            let arg: TCState = this.typeCheckExpr(argID, scopes);
            if (arg.isError()) return arg;
            arguments.push(arg);
        }
        assert(arguments.length == callContext.elemLength);
        let candidates: FunctionLookupList = blank;
        let mark: TCState = this.markFunctionCallCandidates(callContext, &functions, &candidates, &arguments);
        if (mark.isError()) return mark;
        // functions contains all functions with the same amount of arguments and
        // candidates where infer-semantics could validate the function
        // e.g. foo(i: i32) + foo(i: u64) for foo(5)
        let globalID: usize = 0;
        let sweep: TCState = this.selectFunctionCallCandidate(exprID, callContext, &functions, &candidates, &arguments, &globalID);
        if (sweep.isError()) return sweep;
        if (sweep.wantsInfer()) return sweep;
        assert(sweep.isType());
        (*expr).lhs = globalID;
        return sweep;
    }

    func markFunctionCallCandidates(
        &this,
        callContext: &ArrayContext,
        functions: &FunctionLookupList,
        candidates: &FunctionLookupList,
        arguments: &TCStateList,
    ) -> TCState {
        trace("TypeChecker.markFunctionCallCandidates");
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f: &FunctionLookup = &*(functions.at(i));
            if (!f.getReadyState(FUNC_READY_TO_USE)) {
                return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
            }
            if (!f.isVarArg && f.params.length != arguments.length) {
                continue;
            }
            let paramCheck = this.typeCheckFunctionParameters(&f.params, callContext, arguments, true);
            if (paramCheck.isError()) {
                continue;
            }
            candidates.push(*f);
        }
        return newTCStateSuccess();
    }

    func selectFunctionCallCandidate(
        &this,
        exprID: usize,
        callContext: &ArrayContext,
        functions: &FunctionLookupList,
        candidates: &FunctionLookupList,
        arguments: &TCStateList,
        funcID: &usize,
    ) -> TCState {
        trace("TypeChecker.selectFunctionCallCandidate");
        if (candidates.length == 0) {
            return this.reportNoFunctionCallCandidate(exprID, functions);
        } else if (candidates.length > 1) {
            return newTCStatePleaseInfer();
        }
        assert(candidates.length == 1, "selectFunctionCallCandidate: Expected exactly one candidate");
        let f: &FunctionLookup = &*(candidates.at(0));
        assert(f.getReadyState(FUNC_READY_TO_USE), "Expected markFunctionCallCandidates to validate FUNC_READY_TO_USE");
        let paramCheck = this.typeCheckFunctionParameters(&f.params, callContext, arguments, false);
        if (paramCheck.isError()) return paramCheck;
        *funcID = f.globalID;
        let retType: TCState = f.returnType;
        assert(retType.isSuccess(), "selectFunctionCallCandidate: Expected valid function return type");
        return retType;
    }

    func typeCheckFunctionArguments(&this, params: &VariableLookupList, callContext: &ArrayContext, arguments: &TCStateList, checkOnly: bool) -> TCState {
        trace("TypeChecker.typeCheckFunctionArguments");
        if (params.length != callContext.elemLength) {
            todo_with_msg("typeCheckFunctionArguments: param count mismatch");
        }
        for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
            let param = params.at(i);
            let pTypeID = param.typeState.getType();
            let argID: usize = callContext.getElementAtIndex(i);
            let arg: TCState = this.tryInferTypeOntoExpr(argID, pTypeID, checkOnly);
            if (arg.isError()) {
                todo_with_msg("typeCheckFunctionArguments: arg param couldnt infer");
            }
            arguments.push(arg);
        }
        assert(arguments.length == callContext.elemLength);
        return newTCStateSuccess();
    }

    func typeCheckFunctionParameters(&this, params: &VariableLookupList, callContext: &ArrayContext, arguments: &TCStateList, checkOnly: bool) -> TCState {
        let succ = true;
        for (let j: usize = 0; j < params.length; j = j + 1) {
            let argState: TCState = *arguments.at(j);
            let param: &VariableLookup = params.at(j);
            let paramState: &TCState = &param.typeState;
            assert(paramState.isSuccess(), "Expected valid function parameter");
            let paramType: &Type = types.at(paramState.getType());
            if (argState.wantsInfer()) {
                argState = this.tryInferTypeOntoExpr(callContext.getElementAtIndex(j), paramType.getID(), checkOnly);
                if (argState.isError()) {
                    todo_with_msg("error when inferring type of param onto argument");
                }
                assert(argState.isType(), "Did not infer type of param onto argument properly");
            }
            let argType: &Type = types.at(argState.getType());
            if (!argType.equals(paramType)) {
                if (!checkOnly) {
                    let e = exprs.at(callContext.getElementAtIndex(j));
                    this.reportTypeMismatch(e.span, paramType, argType);
                }
                succ = false;
                break;
            }
        }
        if (!succ) return newTCStateFailure(ERROR_TYPE_MISMATCH);
        return newTCStateSuccess();
    }

    func markMethodCallCandidates(
        &this,
        callContext: &ArrayContext,
        methods: &MethodLookupList,
        candidates: &MethodLookupList,
        arguments: &TCStateList,
    ) -> TCState {
        trace("TypeChecker.markMethodCallCandidates");
        for (let i: usize = 0; i < methods.length; i = i + 1) {
            let m: &MethodLookup = &*(methods.at(i));
            if (!m.getReadyState(METHOD_READY_TO_USE)) {
                return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
            }
            if (m.isStatic) {
                // Not handled here
                continue;
            }
            if (m.params.length != arguments.length) {
                continue;
            }
            assert(m.params.length != 0, "not a static method");
            let thisParam: &VariableLookup = m.params.at(0);
            let thisParamState: TCState = thisParam.typeState;
            assert(thisParamState.isSuccess(), "Expected valid this parameter");
            let paramType: &Type = types.at(thisParamState.getType());
            let instType: &Type = types.at(arguments.at(0).getType());
            if (!instType.equals(paramType)) {
                if (paramType.isPointer() && !instType.isPointer()) {
                    let under: &Type = paramType.getUnderlyingType(false);
                    if (!instType.equals(under)) {
                        continue;
                    }
                } else {
                    todo_with_msg("how can this happen");
                }
            }
            let match = true;
            for (let j: usize = 1; j < m.params.length; j = j + 1) {
                let argState: TCState = *arguments.at(j);
                let param: &VariableLookup = m.params.at(j);
                let paramState: &TCState = &param.typeState;
                assert(paramState.isSuccess(), "Expected valid method parameter");
                let paramType: &Type = types.at(paramState.getType());
                if (argState.wantsInfer()) {
                    argState = this.tryInferTypeOntoExpr(callContext.getElementAtIndex(j - 1), paramType.getID(), true);
                    if (argState.isError()) {
                        todo_with_msg("error when inferring type of param onto argument");
                    }
                    assert(argState.isType(), "Did not infer type of param onto argument properly");
                }
                let argType: &Type = types.at(argState.getType());
                if (!argType.equals(paramType)) {
                    match = false;
                    break;
                }
            }
            if (!match) {
                continue;
            }
            candidates.push(*m);
        }
        return newTCStateSuccess();
    }

    func selectMethodCallCandidate(
        &this,
        exprID: usize,
        callContext: &ArrayContext,
        methods: &MethodLookupList,
        candidates: &MethodLookupList,
        arguments: &TCStateList,
        funcID: &usize,
        scopes: &ScopeLookupList,
    ) -> TCState {
        trace("TypeChecker.selectMethodCallCandidate");
        if (candidates.length == 0) {
            return this.reportNoMethodCallCandidate(exprID, arguments, methods);
        } else if (candidates.length > 1) {
            return newTCStatePleaseInfer();
        }
        assert(candidates.length == 1, "selectMethodCallCandidate: Expected exactly one candidate");
        let m: &MethodLookup = &*(candidates.at(0));
        assert(m.getReadyState(METHOD_READY_TO_USE), "Expected markMethodCallCandidates to validate METHOD_READY_TO_USE");
        let thisParam: &VariableLookup = m.params.at(0);
        let thisParamState: TCState = thisParam.typeState;
        assert(thisParamState.isSuccess(), "Expected valid this parameter");
        let paramType: &Type = types.at(thisParamState.getType());
        let instType: &Type = types.at(arguments.at(0).getType());
        if (!instType.equals(paramType)) {
            if (paramType.isPointer() && !instType.isPointer()) {
                let under: &Type = paramType.getUnderlyingType(false);
                assert(instType.equals(under), "method call instance type doesn't match");
                let expr = exprs.at(exprID);
                (*expr).lhs = exprs.at(expr.lhs).intoPointer();
                let patched: TCState = this.typeCheckExpr(expr.lhs, scopes);
                assert(patched.isSuccess(), "patched instance failed");
                assert(patched.isType(), "patched instance state is not a type");
                assert(types.at(patched.getType()).equals(paramType), "patched instance type does not match");
            } else {
                todo_with_msg("how can this happen");
            }
        }
        for (let j: usize = 1; j < m.params.length; j = j + 1) {
            let argState: &TCState = &*arguments.at(j);
            let param: &VariableLookup = m.params.at(j);
            let paramState: &TCState = &param.typeState;
            assert(paramState.isSuccess(), "Expected valid method parameter");
            let paramType: &Type = types.at(paramState.getType());
            if (argState.wantsInfer()) {
                *argState = this.inferTypeOntoExpr(callContext.getElementAtIndex(j - 1), paramType.getID());
                assert(!argState.isError(), "selectMethodCallCandidate: Expected infer to be success");
                assert(argState.isType(), "selectMethodCallCandidate: Expected infer to be success");
            }
            let argType: &Type = types.at(argState.getType());
            assert(argType.equals(paramType), "selectMethodCallCandidate: Expected argument to match parameter");
        }
        *funcID = m.globalID;
        let retType: TCState = m.returnType;
        assert(retType.isSuccess(), "selectMethodCallCandidate: Expected valid method return type");
        return retType;
    }

    func typeCheckExprStructInit(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        // REVIEW: This function will later also do union declarations
        trace("TypeChecker.typeCheckExprStructInit");
        let expr: &ParsedExpr = exprs.at(exprID);
        assert(expr.kind == EXPR_STRUCT_INIT);
        let name: Token = expr.origToken;
        let lookup: TypeLookup = blank;
        if (!this.lookup.resolveTypeByName(this.currentModule, &name, &lookup)) {
            let loc: String = name.getLocation();
            let _n: String = name.content.toString();
            fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.chars(), ERR_STR, _n.chars());
            let alternatives: TypeLookupList = this.lookup.searchAllModulesForTypeName(&name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &TypeLookup = &*alternatives.at(i);
                if (t.isStruct()) {
                    let s: &StructLookup = t.asStruct();
                    let loc: String = s.name.getLocation();
                    fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                    loc.drop();
                }
            }
            _n.drop();
            loc.drop();
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (lookup.isStruct()) {
            let context: &StructInitContext = &expr.structInitContext;
            let structLookup: &StructLookup = &*lookup.asStruct();
            if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE))
                return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
            let hits: usize = 0;
            assert(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
            for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
                let name: Token = context.getFieldNameAtIndex(i);
                let exprID: usize = context.getFieldExprAtIndex(i);
                let exprState: TCState = this.typeCheckExpr(exprID, scopes);
                if (exprState.isError()) return exprState;
                if (!structLookup.hasField(&name.content)) {
                    return this.reportUnknownField(name, structLookup);
                }
                let fieldIndex: usize = structLookup.getIndexByName(&name);
                let bit: usize = shiftLeft(1, fieldIndex);
                if ((hits & bit) != 0) {
                    todo_with_msg("duplicate field");
                } else {
                    hits = hits | bit;
                }
                let field: &VariableLookup = structLookup.fields.at(fieldIndex);
                let fieldState: &TCState = &field.typeState;
                assert(fieldState.isSuccess(), "Struct is ready to go, but field type is invalid?");
                assert(name.content.equals(&field.name.content), "Seems like my hack doesn't work");
                let fieldType: &Type = types.at(fieldState.getType());
                if (exprState.wantsInfer())
                    exprState = this.inferTypeOntoExpr(exprID, fieldType.getID());
                let exprType: &Type = types.at(exprState.getType());
                if (!fieldType.equals(exprType)) {
                    return this.reportTypeMismatch(exprs.at(exprID).span, fieldType, exprType);
                }
            }
            return newTCStateType(structLookup.typeID);
        } else {
            unreachable("typeCheckExprStructInit got non-struct");
        }
    }

    func typeCheckIdentifier(&this, exprID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckIdentifier");
        let expr: &ParsedExpr = exprs.at(exprID);
        assert(expr.kind == EXPR_NAME);
        let name: Token = expr.origToken;
        let var: VariableLookup = blank;
        if (!this.lookup.resolveVariableByName(this.currentModule, &name, scopes, &var)) {
            let loc: String = name.getLocation();
            let _name: String = name.content.toString();
            fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.chars(), ERR_STR, _name.chars());
            let alternatives: VariableLookupList = this.lookup.searchAllModulesForIdentifier(&name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &VariableLookup = &*alternatives.at(i);
                let loc: String = t.name.getLocation();
                fprintf(stderr, "%s: %s: A variable with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                loc.drop();
            }
            _name.drop();
            loc.drop();
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (this.isComptimeContext && !var.isComptime) {
            this.reportRuntimeValueInComptimeContext(name, &var);
        }
        let state: TCState = var.typeState;
        if (state.isInvalid()) {
            return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
        }
        if (state.isError()) return state;
        assert(expr.op == 0);
        let _loc: Token = blank;
        if (scopes.at(0).isKnownVariable(name.content, &_loc)) {
            (*expr).op = 1;
        }
        (*expr).lhs = var.globalID;
        (*expr).typeState = state;
        return state;
    }

    func typeCheckExprBinary(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprBinary");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        if (expr.op == BIN_DOT) {
            return this.typeCheckExprMemberAccess(binID, scopes);
        } else if (expr.op == BIN_ASSIGN) {
            return this.typeCheckExprAssign(binID, scopes);
        } else if (expr.op == BIN_INDEXED_ACCESS) {
            return this.typeCheckExprIndexedAccess(binID, scopes);
        } else if (expr.isArithmetic()) {
            return this.typeCheckExprArithmetic(binID, scopes);
        } else if (expr.isComparison()) {
            return this.typeCheckExprComparison(binID, scopes);
        } else if (expr.isLogical()) {
            return this.typeCheckExprLogical(binID, scopes);
        } else if (expr.isBitwise()) {
            return this.typeCheckExprBitwise(binID, scopes);
        } else {
            this.emergencyPrint(expr.span);
            unreachable("Exhaustive handling of ops in typeCheckExprBinary");
        }
    }

    func typeCheckExprIndexedAccess(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprIndexedAccess");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_INDEXED_ACCESS);
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        if (!lhsState.isType()) todo_with_msg("indexed access, original LHS is not a type");
        let lhsTypeID: usize = lhsState.getType();
        let lhsType: &Type = types.at(lhsTypeID);
        if (!lhsType.isArray() && !lhsType.isPointer()) {
            return this.reportIndexedAccessOnNonArray(expr.span, lhsType);
        }
        if (rhsState.wantsInfer()) {
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            rhsState = this.inferTypeOntoExpr(expr.rhs, usizeType.getID());
        }
        if (!rhsState.isType()) todo_with_msg("indexed access, could not infer type to RHS");
        let rhsTypeID: usize = rhsState.getType();
        let rhsType: &Type = types.at(rhsTypeID);
        // FIXME: Put those into a single check
        if (!rhsType.isPrimitive() || rhsTypeID != TYPE_USIZE) {
            let loc: String = expr.span.toString();
            let typ: String = rhsType.toString();
            fprintf(stderr, "%s: %s: Expected index of array access to be type usize, got %s.\n", loc.chars(), ERR_STR, typ.chars());
            typ.drop();
            loc.drop();
            this.typeError = true;
            return newTCStateFailure(ERROR_INDEXED_TYPE_MISMATCH);
        }
        let underlyingID: usize = lhsType.typeIndex;
        let underlyingType: &Type = types.at(underlyingID);
        assert(underlyingType.getID() == underlyingID);
        return newTCStateType(underlyingID);
    }

    func typeCheckExprLogical(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprLogical");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.isLogical());
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &lhsState, expr.rhs, &rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in logical");
        }
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &Type = types.at(lhsState.getType());
        let rhsType: &Type = types.at(rhsState.getType());
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        let result = newTCStateType(boolType.getID());
        if (!lhsType.isBoolean()) {
            result = this.reportTypeMismatch(exprs.at(expr.lhs).span, boolType, lhsType);
        }
        if (!rhsType.isBoolean()) {
            result = this.reportTypeMismatch(exprs.at(expr.rhs).span, boolType, rhsType);
        }
        return result;
    }

    func typeCheckExprBitwise(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprBitwise");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.isBitwise());
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &lhsState, expr.rhs, &rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in bitwise");
        }
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &Type = types.at(lhsState.getType());
        let rhsType: &Type = types.at(rhsState.getType());
        if (!lhsType.equals(rhsType) || !lhsType.isInteger() || !rhsType.isInteger()) {
            return this.reportBinaryTypeMismatch(
                expr.op,
                exprs.at(expr.lhs).span, lhsType,
                exprs.at(expr.rhs).span, rhsType,
            );
        }
        return lhsState;
    }

    func typeCheckExprAssign(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprAssign");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_ASSIGN);
        let lhsExpr: &ParsedExpr = exprs.at(expr.lhs);
        if (!lhsExpr.isLValue()) {
            this.emergencyPrint(lhsExpr.span);
            todo_with_msg("invalid l-value");
        }
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &lhsState, expr.rhs, &rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in assignment");
        }
        if (!lhsState.isType()) todo_with_msg("assignment, could not infer type to LHS");
        if (!rhsState.isType()) todo_with_msg("assignment, could not infer type to RHS");
        let lhsType: &Type = types.at(lhsState.getType());
        let rhsType: &Type = types.at(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            return this.reportTypeMismatch(exprs.at(expr.rhs).span, lhsType, rhsType);
        }
        return rhsState;
    }

    func typeCheckExprMemberAccess(&this, dotID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprMemberAccess");
        let expr: &ParsedExpr = exprs.at(dotID);
        assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert(expr.op == BIN_DOT);
        let instance: TCState = this.typeCheckExpr(expr.lhs, scopes);
        if (instance.isError()) return instance;
        if (instance.wantsInfer()) return instance;
        let instanceTypeID: usize = instance.getType();
        let instanceType: &Type = types.at(instanceTypeID);
        if (!instanceType.isStruct() && !instanceType.isStructPointer()) {
            return this.reportMemberAccessOnNonStruct(expr, instanceType);
        }
        let underlying: &Type = instanceType;
        if (!underlying.isStruct()) underlying = instanceType.getUnderlyingType(true);
        let lookup: TypeLookup = this.lookup.getTypeLookupForType(underlying);
        if (underlying.isStruct()) {
            assert(lookup.isStruct());
            let structLookup: &StructLookup = &*lookup.asStruct();
            let rhs: &ParsedExpr = exprs.at(expr.rhs);
            if (rhs.kind == EXPR_NAME) {
                if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE))
                    return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                let fieldName: Token = rhs.origToken;
                let field: VariableLookup = blank;
                if (!structLookup.resolveFieldByName(&fieldName, &field)) {
                    return this.reportUnknownField(fieldName, structLookup);
                }
                let fieldState: TCState = field.typeState;
                assert(fieldState.isSuccess(), "Expected valid field type");
                return fieldState;
            } else if (rhs.kind == EXPR_CALL) {
                if (!structLookup.getReadyState(STRUCT_SIGNATURE_COMPLETE))
                    return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                let methodName: Token = rhs.origToken;
                let methods: MethodLookupList = structLookup.resolveMethodByName(&methodName);
                if (methods.length == 0) {
                    let loc: String = methodName.getLocation();
                    let structName: String = structLookup.name.toString();
                    let structLoc: String = structLookup.name.getLocation();
                    let n: String = methodName.content.toString();
                    fprintf(stderr,
                        "%s: %s: Struct `%s` has no method named `%s`.\n%s: %s: Struct declared here.\n",
                        loc.chars(), ERR_STR, structName.chars(), n.chars(), structLoc.chars(), NOTE_STR,
                    );
                    n.drop();
                    structLoc.drop();
                    structName.drop();
                    loc.drop();
                    this.typeError = true;
                    return newTCStateFailure(ERROR_NO_SUCH_METHOD);
                }
                let callContext: &ArrayContext = &rhs.arrayContext;
                let arguments: TCStateList = blank;
                arguments.push(instance);
                for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
                    let argID: usize = callContext.getElementAtIndex(i);
                    let arg: TCState = this.typeCheckExpr(argID, scopes);
                    if (arg.isError()) return arg;
                    arguments.push(arg);
                }
                assert(arguments.length == callContext.elemLength + 1);
                let candidates: MethodLookupList = blank;
                let mark: TCState = this.markMethodCallCandidates(callContext, &methods, &candidates, &arguments);
                if (mark.isError()) return mark;
                // methods contains all methods with the same amount of arguments and
                // candidates where infer-semantics could validate the function
                // e.g. foo(i: i32) + foo(i: u64) for foo(5)
                let globalID: usize = 0;
                let sweep: TCState = this.selectMethodCallCandidate(dotID, callContext, &methods, &candidates, &arguments, &globalID, scopes);
                if (sweep.isError()) return sweep;
                if (sweep.wantsInfer()) return sweep;
                assert(sweep.isType());
                (*rhs).lhs = globalID;
                return sweep;
            } else {
                unreachable("Got non-field non-call RHS in the dot operation.");
            }
        } else {
            unreachable("MemberAccess expected Struct as LHS");
        }
    }

    func checkIfInferIsNeeded(&this, lhsID: usize, lhsState: &TCState, rhsID: usize, rhsState: &TCState) -> TCState {
        trace("TypeChecker.checkIfInferIsNeeded");
        let lhsExpr: &ParsedExpr = exprs.at(lhsID);
        let rhsExpr: &ParsedExpr = exprs.at(rhsID);
        if (lhsState.isType() && rhsState.isType()) {
            return newTCStateSuccess();
        } else if (lhsState.isType() && !rhsState.isType()) {
            let lhsType: usize = lhsState.getType();
            *rhsState = this.inferTypeOntoExpr(rhsID, lhsType);
            return *rhsState;
        } else if (!lhsState.isType() && rhsState.isType()) {
            let rhsType: usize = rhsState.getType();
            *lhsState = this.inferTypeOntoExpr(lhsID, rhsType);
            return *lhsState;
        } else {
            return newTCStatePleaseInfer();
        }
    }

    func inferTypeOntoExpr(&this, exprID: usize, typeID: usize) -> TCState {
        trace("TypeChecker.inferTypeOntoExpr");
        return this.tryInferTypeOntoExpr(exprID, typeID, false);
    }

    func tryInferTypeOntoExpr(&this, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
        trace("TypeChecker.tryInferTypeOntoExpr");
        let expr: &ParsedExpr = exprs.at(exprID);
        if (expr.typeState.isSuccess()) {
            let exprType: &Type = types.at(expr.typeState.getType());
            let wantType: &Type = types.at(typeID);
            if (!exprType.equals(wantType)) todo_with_msg("infer failed");
            return newTCStateType(typeID);
        }
        let typ: &Type = types.at(typeID);
        let tid: TCState = blank;
        if (expr.kind == EXPR_INT_LIT) {
            if (typ.isChar()) {
                if (!checkOnly) {
                    let l: String = expr.origToken.getLocation();
                    fprintf(stderr, "%s: %s: Using integer literal to initialize value of type char.\n",
                        l.chars(), WARN_STR);
                    l.drop();
                }
                tid = newTCStateType(typ.getID());
            } else if (typ.isInteger() || typ.isFloat()) {
                tid = newTCStateType(typ.getID());
            } else if (typ.isPointer()) {
                // REVIEW: This is... More than debatable?
                // Context requires a pointer, we have an integer literal.. Now this literal is type usize
                // Question: Is there ever a situation where we actually want this literal to be type ptr?
                let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                tid = newTCStateType(usizeType.getID());
            } else if (typ.isBoolean()) {
                if (!checkOnly) {
                    let s: String = expr.origToken.content.toString();
                    let l: String = expr.origToken.getLocation();
                    fprintf(stderr, "%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n",
                        l.chars(), ERR_STR, s.chars());
                    l.drop();
                    s.drop();
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
            } else if (typ.isArray()) {
                if (!checkOnly) {
                    let s: String = expr.origToken.content.toString();
                    let l: String = expr.origToken.getLocation();
                    fprintf(stderr, "%s: %s: Unexpected Literal! Expected array, found `%s`.\n",
                        l.chars(), ERR_STR, s.chars());
                    l.drop();
                    s.drop();
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
            } else {
                todo_with_msg("can't infer non-int non-float type onto int literal");
            }
        } else if (expr.kind == EXPR_CHAR_LIT) {
            if (typ.kind != TYPE_KIND_PRIMITIVE && typ.typeIndex != TYPE_CHAR)
                todo_with_msg("can't infer non-char type onto char literal");
            tid = newTCStateType(typ.getID());
        } else if (expr.kind == EXPR_ARRAY_LIT) {
            if (!typ.isArray()) {
                if (!checkOnly) {
                    let loc = expr.span.toString();
                    let t = typ.toString();
                    fprintf(stderr, "%s: %s: Expected expression of type %s, found array literal.\n", loc.chars(), ERR_STR, t.chars());
                    t.drop();
                    loc.drop();
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            assert(expr.arrayContext.elemLength > 0, "Got empty array literal");
            if (expr.arrayContext.size == 0) {
                if (typ.arraySize != expr.arrayContext.elemLength) {
                    if (!checkOnly) {
                        let loc: String = expr.span.toString();
                        fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                            loc.chars(), ERR_STR, typ.arraySize, expr.arrayContext.elemLength);
                        loc.drop();
                        this.typeError = true;
                    }
                    return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
                }
                let lastErrState: TCState = blank;
                for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
                    tid = this.tryInferTypeOntoExpr(expr.arrayContext.getElementAtIndex(i), typ.typeIndex, checkOnly);
                    if (tid.isError()) {
                        lastErrState = tid;
                    }
                }
                if (!lastErrState.isInvalid()) return lastErrState;
            } else {
                if (typ.arraySize != expr.arrayContext.size) {
                    if (!checkOnly) {
                        let loc: String = expr.span.toString();
                        fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                            loc.chars(), ERR_STR, typ.arraySize, expr.arrayContext.size);
                        loc.drop();
                        this.typeError = true;
                    }
                    return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
                }
                tid = this.tryInferTypeOntoExpr(expr.arrayContext.getElementAtIndex(0), typ.typeIndex, checkOnly);
                if (tid.isError()) return tid;
            }
            tid = newTCStateType(typeID);
        } else if (expr.kind == EXPR_BLANK) {
            if (typ.isPointer()) {
                let loc: String = expr.span.toString();
                let name: String = typ.toString();
                fprintf(stderr, "%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n",
                    loc.chars(), ERR_STR, name.chars());
                name.drop();
                loc.drop();
                this.typeError = true;
                return newTCStateFailure(ERROR_BLANK_FOR_NULL);
            } else if (typ.isPrimitive()) {
                let loc: String = expr.span.toString();
                let name: String = typ.toString();
                fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n",
                    loc.chars(), WARN_STR, name.chars());
                name.drop();
                loc.drop();
            }
            tid = newTCStateType(typ.getID());
        } else if (expr.kind == EXPR_BINARY) {
            if (expr.isArithmetic() || expr.isBitwise()) {
                tid = this.tryInferTypeOntoExpr(expr.lhs, typeID, checkOnly);
                if (tid.isError()) return tid;
                tid = this.tryInferTypeOntoExpr(expr.rhs, typeID, checkOnly);
                if (tid.isError()) return tid;
                tid = newTCStateType(typeID);
            } else if (expr.isComparison()) {
                // Assuming that neither side has a type (otherwise typeCheckExprComparison would've handled the infer step)
                // So all that's left is whack things like `1 == 1`, for which we blindly try to infer usize onto both sides
                let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                tid = this.tryInferTypeOntoExpr(expr.lhs, usizeType.getID(), checkOnly);
                if (tid.isError()) return tid;
                tid = this.tryInferTypeOntoExpr(expr.rhs, usizeType.getID(), checkOnly);
                if (tid.isError()) return tid;
                tid = newTCStateType(typeID);
            } else if (expr.op == BIN_DOT) {
                tid = this.tryInferTypeOntoMemberAccess(exprID, typeID, checkOnly);
                if (tid.isError()) return tid;
            } else {
                todo_with_msg("inferTypeOntoExpr for non-arith non-comp binary");
            }
        } else if (expr.kind == EXPR_UNARY) {
            if (expr.op == UNARY_DEREF) {
                let newType: &Type = newType(TYPE_KIND_POINTER, typeID);
                tid = this.tryInferTypeOntoExpr(expr.lhs, newType.getID(), checkOnly);
                if (tid.isError()) return tid;
                tid = newTCStateType(typeID);
            } else if (expr.op == UNARY_REF) {
                if (!typ.isPointer()) todo_with_msg("can't infer non-pointer type onto reference");
                let underlying: &Type = typ.getUnderlyingType(false);
                tid = this.tryInferTypeOntoExpr(expr.lhs, underlying.getID(), checkOnly);
                if (tid.isError()) return tid;
                tid = newTCStateType(typeID);
            } else if (expr.op == UNARY_MINUS) {
                // -expr
                // typeof(expr) == typeof(-expr)
                if (!typ.isSignedInteger() && !typ.isFloat()) {
                    if (!checkOnly) {
                        let loc: String = expr.span.toString();
                        let t: String = typ.toString();
                        fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.chars(), ERR_STR, t.chars());
                        t.drop();
                        loc.drop();
                        this.typeError = true;
                    }
                    return newTCStateFailure(ERROR_TYPE_MISMATCH);
                }
                tid = this.tryInferTypeOntoExpr(expr.lhs, typeID, checkOnly);
                if (tid.isError()) return tid;
                assert(tid.isType(), "infer non-error expected to be a type");
                let subType: &Type = types.at(tid.getType());
                assert(subType.equals(typ), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
                tid = newTCStateType(typeID);
            } else if (expr.op == UNARY_NOT) {
                let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
                tid = this.tryInferTypeOntoExpr(expr.lhs, boolType.getID(), checkOnly);
                if (tid.isError()) return tid;
                todo_with_msg("unary not infer");
            } else {
                unreachable("Exhaustive handling of unary ops in inferTypeOntoExpr");
            }
        } else if (expr.kind == EXPR_NULL) {
            if (!typ.isPointer()) todo_with_msg("tried to infer non-ptr to null");
            tid = newTCStateType(typeID);
        } else if (expr.kind == EXPR_CALL) {
            tid = this.tryInferTypeOntoCall(exprID, typeID, checkOnly);
            if (tid.isError()) return tid;
        } else {
            this.emergencyPrint(expr.span);
            todo_with_msg("unhandled case in inferTypeOntoExpr");
        }
        if (!checkOnly) {
            (*expr).typeState = tid;
        }
        return tid;
    }

    func tryInferTypeOntoCall(&this, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
        trace("TypeChecker.tryInferTypeOntoCall");
        let expr = exprs.at(exprID);
        let typ = types.at(typeID);
        assert(expr.kind == EXPR_CALL);
        let functions: FunctionLookupList = blank;
        if (!this.lookup.resolveAllFunctionsWithReturnType(this.currentModule, &expr.origToken, typ, &functions)) {
            functions.clear();
            return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
        }
        let actual: FunctionLookupList = blank;
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f = functions.at(i);
            assert(f.getReadyState(FUNC_PARAMS_COMPLETE));
            let callContext: &ArrayContext = &expr.arrayContext;
            let arguments: TCStateList = blank;
            let state = this.typeCheckFunctionArguments(&f.params, callContext, &arguments, true);
            if (state.isError()) {
                todo_with_msg("argument fail");
            }
            state = this.typeCheckFunctionParameters(&f.params, callContext, &arguments, checkOnly);
            if (state.isError()) {
                todo_with_msg("parameter fail");
            }
            actual.push(*f);
        }
        if (actual.length == 1) {
            let f = actual.at(0);
            if (checkOnly) return newTCStateSuccess();
            (*expr).lhs = f.globalID;
            return f.returnType;
        } else if (actual.length == 0) {
            if (!checkOnly) {
                let functions: FunctionLookupList = this.lookup.resolveFunctionByName(this.currentModule, &expr.origToken);
                return this.reportNoFunctionCallCandidate(expr.getID(), &functions);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        } else {
            if (!checkOnly) {
                return this.reportFunctionCallTooManyOptions(expr, &actual);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
    }

    func tryInferTypeOntoMemberAccess(&this, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
        trace("TypeChecker.tryInferTypeOntoMemberAccess");
        let expr = exprs.at(exprID);
        let typ = types.at(typeID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_DOT);
        let lhs = exprs.at(expr.lhs);
        let rhs = exprs.at(expr.rhs);
        if (rhs.kind == EXPR_NAME) {
            let name = rhs.origToken;
            let structs = this.lookup.resolveAllStructsWithField(this.currentModule, &name, typ);
            if (structs.length == 0) {
                todo_with_msg("tryInferTypeOntoMemberAccess: 0 struct with field");
            } else if (structs.length == 1) {
                let strukt = structs.at(0);
                let state = this.tryInferTypeOntoExpr(expr.lhs, strukt.typeID, checkOnly);
                if (state.isError()) return state;
                if (checkOnly) return newTCStateSuccess();
                return newTCStateType(typeID);
            } else {
                if (!checkOnly) {
                    return this.reportMemberAccessTooManyOptions(expr, &structs);
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
        } else if (rhs.kind == EXPR_CALL) {
            todo_with_msg("infer member call");
        } else {
            unreachable("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess");
        }
    }

    func typeCheckExprArithmetic(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprArithmetic");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert(expr.isArithmetic(), "Expr expected to be arithmetic");
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let lhsPointer: bool = false;
        let rhsPointer: bool = false;
        if (lhsState.isType()) if (types.at(lhsState.getType()).isPointer()) lhsPointer = true;
        if (rhsState.isType()) if (types.at(rhsState.getType()).isPointer()) rhsPointer = true;
        if (lhsPointer || rhsPointer) {
            if (expr.op != BIN_PLUS && expr.op != BIN_SUB) {
                return this.reportInvalidPointerArithmetics(
                    expr.op,
                    exprs.at(expr.lhs).span,
                    exprs.at(expr.rhs).span,
                );
            }
        }
        let maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &lhsState, expr.rhs, &rhsState);
        if (maybeInfer.isError()) return maybeInfer;
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &Type = types.at(lhsState.getType());
        let rhsType: &Type = types.at(rhsState.getType());
        let resultState: TCState = blank;
        if (lhsType.equals(rhsType)) {
            if (lhsType.isChar() && expr.op != BIN_PLUS && expr.op != BIN_SUB) {
                return this.reportBinaryTypeMismatch(
                    expr.op,
                    exprs.at(expr.lhs).span, lhsType,
                    exprs.at(expr.rhs).span, rhsType,
                );
            }
            if (lhsType.isStruct() || lhsType.isArray()) {
                return this.reportBinaryTypeMismatch(
                    expr.op,
                    exprs.at(expr.lhs).span, lhsType,
                    exprs.at(expr.rhs).span, rhsType,
                );
            } else if (lhsType.isPointer()) {
                let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                resultState = newTCStateType(t.getID());
            } else {
                assert(lhsType.getID() == rhsType.getID(), "Arithmetic LHS and RHS are different types");
                resultState = newTCStateType(lhsType.getID());
            }
        } else if (lhsType.isPointer() && rhsType.isInteger()) {
            if (rhsType.typeIndex == TYPE_USIZE) {
                resultState = lhsState;
            } else {
                let rhs = exprs.at(expr.rhs).span;
                let err = this.reportBinaryTypeMismatch(
                    expr.op,
                    exprs.at(expr.lhs).span, lhsType,
                    rhs, rhsType,
                );
                let loc = rhs.toString();
                fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.chars(), NOTE_STR);
                loc.drop();
                return err;
            }
        } else if (lhsType.isInteger() && rhsType.isPointer()) {
            if (lhsType.typeIndex == TYPE_USIZE) {
                resultState = rhsState;
            } else {
                let lhs = exprs.at(expr.lhs).span;
                let err = this.reportBinaryTypeMismatch(
                    expr.op,
                    lhs, lhsType,
                    exprs.at(expr.rhs).span, rhsType,
                );
                let loc = lhs.toString();
                fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.chars(), NOTE_STR);
                loc.drop();
                return err;
            }
        } else {
            return this.reportBinaryTypeMismatch(
                expr.op,
                exprs.at(expr.lhs).span, lhsType,
                exprs.at(expr.rhs).span, rhsType,
            );
        }
        return resultState;
    }

    func typeCheckExprComparison(&this, binID: usize, scopes: &ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprComparison");
        let expr: &ParsedExpr = exprs.at(binID);
        assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert(expr.isComparison(), "Expr expected to be comparison");
        let lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        let rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &lhsState, expr.rhs, &rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in comp");
        }
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &Type = types.at(lhsState.getType());
        let rhsType: &Type = types.at(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            return this.reportBinaryTypeMismatch(
                expr.op,
                exprs.at(expr.lhs).span, lhsType,
                exprs.at(expr.rhs).span, rhsType,
            );
        }
        if (lhsType.isStruct() || rhsType.isStruct()
            || lhsType.isArray() || rhsType.isArray()) {
            todo_with_msg("report error, can't compare structs or arrays using == or similar.");
        }
        let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        return newTCStateType(t.getID());
    }


    func typeCheckTypeNode(&this, typeID: usize) -> TCState {
        trace("TypeChecker.typeCheckTypeNode");
        let typ: &ParsedTypeNode = typeNodes.at(typeID);
        if (typ.ignored) return blank;
        if (typ.typeState.isSuccess()) return typ.typeState;
        let tid: usize = 0;
        if (typ.kind == PARSED_TYPE_REF) {
            let under: TCState = this.typeCheckTypeNode(typ.underlyingID);
            if (under.isError()) return under;
            let underlyingType: usize = under.getType();
            let t: &Type = newType(TYPE_KIND_POINTER, underlyingType);
            tid = t.getID();
        } else if (typ.kind == PARSED_TYPE_ARRAY) {
            if (typ.arraySize == 0) todo_with_msg("0 elements in mah array");
            let under: TCState = this.typeCheckTypeNode(typ.underlyingID);
            if (under.isError()) return under;
            let underlyingType: usize = under.getType();
            let t: &Type = newType(TYPE_KIND_ARRAY, underlyingType);
            (*t).arraySize = typ.arraySize;
            tid = t.getID();
        } else if (typ.kind == PARSED_TYPE_IDENT) {
            let name: Token = typ.nameTkn;
            let typeLookup: TypeLookup = blank;
            if (!this.lookup.resolveTypeByName(this.currentModule, &name, &typeLookup)) {
                let loc: String = name.getLocation();
                let _n: String = name.content.toString();
                fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.chars(), ERR_STR, _n.chars());
                let alternatives: TypeLookupList = this.lookup.searchAllModulesForTypeName(&name);
                for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                    let t: &TypeLookup = &*alternatives.at(i);
                    if (t.isStruct()) {
                        let s: &StructLookup = t.asStruct();
                        let loc: String = s.name.getLocation();
                        fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                        loc.drop();
                    }
                }
                _n.drop();
                loc.drop();
                this.typeError = true;
                return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
            }
            if (typeLookup.isStruct()) {
                let structLookup: &StructLookup = &*typeLookup.asStruct();
                let _tid: usize = structLookup.typeID;
                assert(_tid != 0, "Ready to use Struct Lookup has Type ID 0");
                let t: &Type = types.at(_tid);
                assert(t.isStruct(), "Struct Lookup links to non-Struct type");
                tid = t.getID();
            } else {
                todo_with_msg("check ident");
            }
        } else if (typ.kind == PARSED_TYPE_BUILTIN) {
            let id: usize = typ.getID();
            let typeID: usize = 0;
            if (id == PARSED_TYPE_INVALID) typeID = TYPE_INVALID;
            else if (id == PARSED_TYPE_UNKNOWN) typeID = TYPE_UNKNOWN;
            else if (id == PARSED_TYPE_NONE) typeID = TYPE_NONE;
            else if (id == PARSED_TYPE_ANY) typeID = TYPE_ANY;
            else if (id == PARSED_TYPE_I8) typeID = TYPE_I8;
            else if (id == PARSED_TYPE_I16) typeID = TYPE_I16;
            else if (id == PARSED_TYPE_I32) typeID = TYPE_I32;
            else if (id == PARSED_TYPE_I64) typeID = TYPE_I64;
            else if (id == PARSED_TYPE_U8) typeID = TYPE_U8;
            else if (id == PARSED_TYPE_U16) typeID = TYPE_U16;
            else if (id == PARSED_TYPE_U32) typeID = TYPE_U32;
            else if (id == PARSED_TYPE_U64) typeID = TYPE_U64;
            else if (id == PARSED_TYPE_USIZE) typeID = TYPE_USIZE;
            else if (id == PARSED_TYPE_BOOL) typeID = TYPE_BOOL;
            else if (id == PARSED_TYPE_CHAR) typeID = TYPE_CHAR;
            else if (id == PARSED_TYPE_F32) typeID = TYPE_F32;
            else if (id == PARSED_TYPE_F64) typeID = TYPE_F64;
            else {
                this.emergencyPrint(typ.span);
                todo_with_msg("handle other parsed -> checked type conversion");
            }
            let t: &Type = newType(TYPE_KIND_PRIMITIVE, typeID);
            tid = t.getID();
        } else {
            todo_with_msg("unknown type kind");
        }
        let state: TCState = newTCStateType(tid);
        (*typ).typeState = state;
        return state;
    }
}

func newTypeChecker() -> TypeChecker {
    return TypeChecker {
        isComptimeContext: false,
        currentModule: 0,
        currentFunction: null,
        currentMethod: null,
        lookup: blank,
        typeError: false,
    };
}
