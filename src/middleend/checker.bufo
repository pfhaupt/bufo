import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/lexer.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

@os(WINDOWS) import "winapi/structs.bufo";
@os(WINDOWS) import "winapi/functions.bufo";

@os(LINUX) import "posix/structs.bufo";
@os(LINUX) import "posix/functions.bufo";

comptime ERROR_INVALID                           : usize = 0;
comptime ERROR_NO_SUCH_MODULE                    : usize = 1;
comptime ERROR_NO_SUCH_IDENTIFIER                : usize = 2;
comptime ERROR_NO_SUCH_FUNCTION                  : usize = 3;
comptime ERROR_NO_SUCH_METHOD                    : usize = 4;
comptime ERROR_NO_SUCH_TYPE                      : usize = 5;
comptime ERROR_USE_BEFORE_DECLARATION            : usize = 6;
comptime ERROR_FIELD_COUNT_MISMATCH              : usize = 7;
comptime ERROR_INDEXED_TYPE_MISMATCH             : usize = 8;
comptime ERROR_UNEXPECTED_LITERAL                : usize = 9;
comptime ERROR_ARRAY_SIZE_MISMATCH               : usize = 10;
comptime ERROR_TYPE_MISMATCH                     : usize = 11;
comptime ERROR_INVALID_POINTER_ARITHMETIC        : usize = 12;
comptime ERROR_DUPLICATE_PARAMETER               : usize = 13;
comptime ERROR_DUPLICATE_FIELD                   : usize = 14;
comptime ERROR_UNKNOWN_FIELD                     : usize = 15;
comptime ERROR_DUPLICATE_FUNCTION                : usize = 16;
comptime ERROR_NO_CALL_CANDIDATE                 : usize = 17;
comptime ERROR_VARIABLE_REDECLARATION            : usize = 18;
comptime ERROR_RECURSIVE_TYPE                    : usize = 19;
comptime ERROR_DUPLICATE_METHOD                  : usize = 20;
comptime ERROR_BLANK_FOR_NULL                    : usize = 21;
comptime ERROR_NON_PRIMITIVE_CAST                : usize = 22;
comptime ERROR_INDEXED_ACCESS_ON_NON_ARRAY       : usize = 23;
comptime ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT : usize = 24;
comptime ERROR_ANY_DEREF                         : usize = 25;
comptime ERROR_MEMBER_ACCESS_NON_STRUCT          : usize = 26;
comptime ERROR_MEMBER_ACCESS_NO_OPTIONS          : usize = 27;
comptime ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS    : usize = 28;
comptime ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS    : usize = 29;
comptime ERROR_CALL_TO_NON_FUNCTION              : usize = 30;
comptime ERROR_UNKNOWN_SUBMODULE                 : usize = 31;
comptime ERROR_MODULE_ACCESS_NON_MODULE          : usize = 32;
comptime ERROR_DEREF_NON_POINTER                 : usize = 33;
comptime ERROR_DUPLICATE_UNION_VARIANT           : usize = 34;
comptime ERROR_DUPLICATE_UNION_NAME              : usize = 35;
comptime ERROR_NON_EXHAUSTIVE_MATCH              : usize = 36;
comptime ERROR_IMPOSSIBLE_PATTERN                : usize = 37;
comptime ERROR_NULL_NON_PTR                      : usize = 38;
comptime ERROR_FILE_MISSING                      : usize = 39;
comptime ERROR_ASSEMBLY_IN_COMPTIME_CONTEXT      : usize = 40;
comptime ERROR_NAKED_STATEMENT                   : usize = 41;
comptime ERROR_INVALID_VARIANT_INIT              : usize = 42;
comptime ERROR_NO_SUCH_VARIANT                   : usize = 43;
comptime ERROR_INFER_FAILED                      : usize = 44;
comptime ERROR_MISSING_TRAMPOLINE                : usize = 45;

union TCState {
    Invalid,
    Success,
    Error(usize),
    Type(&Type),
    PleaseInfer,
    Pattern(PatState),
}

func equals(this: &TCState, other: &TCState) -> bool {
    todo_with_msg("TCState.equals");
}

func isInvalid(this: &TCState) -> bool {
    return tag(this) == comptime tag(&TCState::Invalid);
}
func wantsInfer(this: &TCState) -> bool {
    return tag(this) == comptime tag(&TCState::PleaseInfer);
}
func isCriticalError(this: &TCState) -> bool {
    if (!isError(this)) return false;
    let err: usize = getError(this);
    return err == ERROR_NO_SUCH_IDENTIFIER
        || err == ERROR_NO_SUCH_FUNCTION
        || err == ERROR_NO_SUCH_METHOD
        || err == ERROR_DUPLICATE_FUNCTION
        || err == ERROR_DUPLICATE_METHOD
        || err == ERROR_DUPLICATE_FIELD;
}
func isError(this: &TCState) -> bool {
    return tag(this) == comptime tag(&TCState::Error);
}

func isSuccess(this: &TCState) -> bool {
    return (tag(this) == comptime tag(&TCState::Success)) || isType(this) || isPattern(this);
}

func isType(this: &TCState) -> bool {
    return tag(this) == comptime tag(&TCState::Type);
}

func isPattern(this: &TCState) -> bool {
    return tag(this) == comptime tag(&TCState::Pattern);
}

func getType(this: &TCState) -> &Type {
    let &TCState::Type(type) = this else {
        C::fprintf(stderr, "ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n", tag(this));
        unreachable();
    };
    return type;
}
func getError(this: &TCState) -> usize {
    let &TCState::Error(error) = this else {
        C::fprintf(stderr, "ERROR: getType(&TCState) called on non-error TCState with kind=%llu\n", tag(this));
        unreachable();
    };
    return error;
}
func getPatState(this: &TCState) -> PatState {
    let &TCState::Pattern(pat) = this else {
        C::fprintf(stderr, "ERROR: getType(&TCState) called on non-pattern TCState with kind=%llu\n", tag(this));
        unreachable();
    };
    return pat;
}

struct PatState {
    complete: bool;
}

struct TypeChecker {
    comptimeDepth: usize;
    currentModule: &ModuleLookup;
    currentFunction: &FunctionLookup;
    anonFuncDepth: usize;
    lookup: Lookup;
    typeError: bool;
}
func enterAnonFunc(this: &TypeChecker) { this.anonFuncDepth = this.anonFuncDepth + 1; }
func leaveAnonFunc(this: &TypeChecker) { this.anonFuncDepth = this.anonFuncDepth - 1; }
func enterComptime(this: &TypeChecker) { this.comptimeDepth = this.comptimeDepth + 1; }
func leaveComptime(this: &TypeChecker) { this.comptimeDepth = this.comptimeDepth - 1; }

func pl(count: usize, s1: &char, s2: &char) -> &char {
    if (count == 1) return s1;
    return s2;
}
func reportUnknownIdentifier(this: &TypeChecker, name: &Token) -> TCState {
    let loc: String = getLocation(name);
    let _name: String = toString(&name.content);
    C::fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    let alternatives: VariableLookupList = searchAllFilesForIdentifier(&this.lookup, name, this.anonFuncDepth > 0);
    if (*flags.verbose) {
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &VariableLookup = at(&alternatives, i);
            drop(&loc);
            loc = getLocation(&t.name);
            C::fprintf(stderr, "%s: %s: A variable with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
        }
    } else if (alternatives.length > 0) {
        reportVerboseNote(this, loc, alternatives.length, "global variable with that name", "global variables with that name");
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_NO_SUCH_IDENTIFIER);
}
func reportVerboseNote(this: &TypeChecker, loc: String, count: usize, s1: &char, s2: &char) {
    let is = pl(count, "is", "are");
    let ol = pl(count, s1, s2);
    let it = pl(count, "it", "them");
    C::fprintf(stderr, "%s: %s: There %s %llu %s. Re-run with the --verbose flag to see %s.\n",
            loc.buffer, NOTE_STR, is, count, ol, it);
}

func reportTypeMismatch(this: &TypeChecker, span: Span, expected: &Type, got: &Type) -> TCState {
    let loc: String = toString(&span);
    let typ1: String = toString(expected);
    let typ2: String = toString(got);
    C::fprintf(stderr, "%s: %s: Type mismatch! Expected type %s, found type %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_TYPE_MISMATCH);
}

func reportBinaryTypeMismatch(this: &TypeChecker, op: &char, lhsSpan: Span, lhsType: &Type, rhsSpan: Span, rhsType: &Type) -> TCState {
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    let loc1: String = toString(&lhsSpan);
    let loc2: String = toString(&rhsSpan);
    let typ1: String = toString(lhsType);
    let typ2: String = toString(rhsType);
    C::fprintf(stderr, "%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n",
        loc.buffer, ERR_STR, typ1.buffer, op, typ2.buffer);
    C::fprintf(stderr, "%s: %s: LHS has type %s.\n", loc1.buffer, NOTE_STR, typ1.buffer);
    C::fprintf(stderr, "%s: %s: RHS has type %s.\n", loc2.buffer, NOTE_STR, typ2.buffer);
    drop(&typ2);
    drop(&typ1);
    drop(&loc2);
    drop(&loc1);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_TYPE_MISMATCH);
}

func reportInvalidPointerArithmetics(this: &TypeChecker, op: &char, lhsSpan: Span, rhsSpan: Span) -> TCState {
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    C::fprintf(stderr, "%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n",
        loc.buffer, ERR_STR, op);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_INVALID_POINTER_ARITHMETIC);
}

func reportDuplicateField(this: &TypeChecker, fieldToken: Token, declSpan: Span) -> TCState {
    let duplLoc: String = toString(&fieldToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&fieldToken.content);
    C::fprintf(stderr, "%s: %s: Field redeclaration.\n", duplLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return TCState::Error(ERROR_DUPLICATE_FIELD);
}

func reportDuplicateParameter(this: &TypeChecker, paramToken: Token, declSpan: Span) -> TCState {
    let duplLoc: String = toString(&paramToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&paramToken.content);
    C::fprintf(stderr, "%s: %s: Parameter redeclaration.\n", duplLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Parameter `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return TCState::Error(ERROR_DUPLICATE_PARAMETER);
}

func reportUnknownField(this: &TypeChecker, name: Token, decl: &StructLookup, isUnion: bool) -> TCState {
    let errLoc: String = toString(&name.span);
    let declLoc: String = toString(&decl.name.span);
    let strukt: String = toString(&decl.name.content);
    let field: String = toString(&name.content);
    let s1 = "struct";
    let s2 = "Struct";
    if (isUnion) {
        s1 = "union variant";
        s2 = "Union variant";
    }
    C::fprintf(stderr, "%s: %s: Attempted to access unknown field `%s` of instance of %s %s.\n", errLoc.buffer, ERR_STR, field.buffer, s1, strukt.buffer);
    C::fprintf(stderr, "%s: %s: %s %s is declared here.\n", declLoc.buffer, NOTE_STR, s2, strukt.buffer);
    drop(&field);
    drop(&strukt);
    drop(&declLoc);
    drop(&errLoc);
    this.typeError = true;
    return TCState::Error(ERROR_UNKNOWN_FIELD);
}
func reportUnknownType(this: &TypeChecker, mod: &ModuleLookup, name: Token, alternatives: TypeLookupList) -> TCState {
    let loc: String = getLocation(&name);
    let _n: String = toString(&name.content);
    if (mod != null) {
        let modNode = at(&modules, mod.globalID);
        let _n1 = toString(&modNode.name.content);
        let loc1 = toString(&modNode.span);
        C::fprintf(stderr, "%s: %s: Module `%s` does not contain any types named `%s`.\n", loc.buffer, ERR_STR, _n1.buffer, _n.buffer);
        C::fprintf(stderr, "%s: %s: Module declared here.\n", loc1.buffer, NOTE_STR);
        drop(&loc1);
        drop(&_n1);
    } else {
        C::fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
        if (*flags.verbose) {
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &TypeLookup = at(&alternatives, i);
                if (isStruct(t)) {
                    let s: &StructLookup = asStruct(t);
                    drop(&loc);
                    loc = getLocation(&s.name);
                    C::fprintf(stderr, "%s: %s: A struct with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
                }
            }
        } else if (alternatives.length > 0) {
            reportVerboseNote(this, loc, alternatives.length, "struct with that name", "structs with that name");
        }
    }
    drop(&_n);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_NO_SUCH_TYPE);
}

func reportDuplicateFunction(this: &TypeChecker, f1: &FunctionLookup, f2: &FunctionLookup) -> TCState {
    let errLoc: String = toString(&f1.name.span);
    let duplLoc: String = toString(&f2.name.span);
    let name: String = toString(&f1.name.content);
    let typ = toString(getType(&f1.fnType));
    C::fprintf(stderr, "%s: %s: Function redeclaration.\n", errLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: A function named `%s` with the signature %s is already declared here.\n", duplLoc.buffer, ERR_STR, name.buffer, typ.buffer);
    drop(&typ);
    drop(&name);
    drop(&duplLoc);
    drop(&errLoc);
    this.typeError = true;
    return TCState::Error(ERROR_DUPLICATE_FUNCTION);
}

func reportNoFunctionCallCandidate(this: &TypeChecker, ident: Token, fnType: &Type, functions: &FunctionLookupList) -> TCState {
    let loc: String = toString(&ident.span);
    let name: String = toString(&ident.content);
    let typ = toString(fnType);
    C::fprintf(stderr, "%s: %s: No function overload fits the provided context for call to function `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    C::fprintf(stderr, "%s: %s: Context requires an overload of the form %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    assert(functions.length != 0, "reportNoFunctionCallCandidate: Expected at least one declaration");
    if (*flags.verbose) {
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f: &FunctionLookup = at(functions, i);
            drop(&typ);
            drop(&loc);
            loc = toString(&f.name.span);
            typ = toString(getType(&f.fnType));
            C::fprintf(stderr, "%s: %s: Overload %s declared here.\n", loc.buffer, NOTE_STR, typ.buffer);
        }
    } else {
        reportVerboseNote(this, loc, functions.length, "possible overload", "possible overloads");
    }
    drop(&typ);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_NO_CALL_CANDIDATE);
}

func reportVariableRedeclaration(this: &TypeChecker, newDecl: Token, oldDecl: Token) -> TCState {
    let newLoc: String = toString(&newDecl.span);
    let oldLoc: String = toString(&oldDecl.span);
    let name: String = toString(&newDecl.content);
    C::fprintf(stderr, "%s: %s: Variable redeclaration.\n", newLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Variable `%s` already declared here.\n", oldLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&oldLoc);
    drop(&newLoc);
    this.typeError = true;
    return TCState::Error(ERROR_VARIABLE_REDECLARATION);
}

func reportRecursiveType(this: &TypeChecker, checked: &TypeLookup, cycle: &TypeLookupList) -> TCState {
    let loc: String = getLocation(checked);
    let name: String = getName(checked);
    C::fprintf(stderr, "%s: %s: Recursive type %s.\n", loc.buffer, ERR_STR, name.buffer);
    assert(cycle.length >= 1, "Cycle is empty");
    for (let i: usize = 1; i < cycle.length; i = i + 1) {
        loc = getLocation(at(cycle, i));
        name = getName(at(cycle, i));
        C::fprintf(stderr, "%s: %s: Chain of recursion also includes type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    }
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_RECURSIVE_TYPE);
}

func reportNonPrimitiveCast(this: &TypeChecker, span: Span, from: &Type, to: &Type) -> TCState {
    let loc: String = toString(&span);
    let typ1: String = toString(from);
    let typ2: String = toString(to);
    C::fprintf(stderr, "%s: %s: Non primitive cast from type %s to %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_NON_PRIMITIVE_CAST);
}

func reportIndexedAccessOnNonArray(this: &TypeChecker, span: Span, typ: &Type) -> TCState {
    let loc: String = toString(&span);
    let name: String = toString(typ);
    C::fprintf(stderr, "%s: %s: Indexed Access is only supported for arrays, pointers and variadic types.\n", loc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Expression has type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
}

func reportRuntimeValueInComptimeContext(this: &TypeChecker, ident: Token, var: &VariableLookup) -> TCState {
    let loc = toString(&ident.span);
    let otherLoc = toString(&var.name.span);
    let name = toString(&ident.content);
    C::fprintf(stderr, "%s: %s: Variables declared with `let` can't be used in a comptime context.\n", loc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Variable `%s` is declared here.\n", otherLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&otherLoc);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT);
}

func reportAnyDereference(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    let loc = toString(&expr.span);
    C::fprintf(stderr, "%s: %s: Can't dereference expression of type Any.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_ANY_DEREF);
}

func reportMemberAccessOnNonStructNonTuple(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    let loc = toString(&expr.span);
    let t = toString(instance);
    C::fprintf(stderr, "%s: %s: The Dot-Operator is not defined for values of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_NON_STRUCT);
}
func reportNonIdentAccessOnStruct(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    let loc = toString(&expr.span);
    let t = toString(instance);
    C::fprintf(stderr, "%s: %s: The Dot-Operator expected an identifier for a value of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_NON_STRUCT);
}
func reportNonNumberAccessOnTuple(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    let loc = toString(&expr.span);
    let t = toString(instance);
    C::fprintf(stderr, "%s: %s: The Dot-Operator expected a number for a value of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_NON_STRUCT);
}
func reportTupleIndexOutOfBounds(this: &TypeChecker, expr: &ParsedExpr, tuple: &Type, index: usize) -> TCState {
    let loc = toString(&expr.span);
    let t = toString(tuple);
    C::fprintf(stderr, "%s: %s: Index %llu is not valid for value of type %s.\n", loc.buffer, ERR_STR, index, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_NON_STRUCT);
}

func reportCouldNotInferType(this: &TypeChecker, span: Span) -> TCState {
    let loc = toString(&span);
    C::fprintf(stderr, "%s: %s: Could not infer type of expression.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_INFER_FAILED);
}

func reportMemberAccessNoOptions(this: &TypeChecker, span: Span) -> TCState {
    let loc = toString(&span);
    C::fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_NO_OPTIONS);
}

func reportMemberAccessTooManyOptions(this: &TypeChecker, span: Span, structs: &StructLookupList) -> TCState {
    assert(structs.length > 0);
    let loc = toString(&span);
    C::fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    for (let i: usize = 0; i < structs.length; i = i + 1) {
        let s = at(structs, i);
        let l = toString(&s.name.span);
        let n = toString(&s.name.content);
        C::fprintf(stderr, "%s: %s: Context allows struct %s to be used.\n", l.buffer, NOTE_STR, n.buffer);
        drop(&n);
        drop(&l);
    }
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS);
}

func reportFunctionCallTooManyOptions(this: &TypeChecker, expr: &CallExpr) -> TCState {
    let loc = toString(&expr.span);
    C::fprintf(stderr, "%s: %s: Could not infer which function to call.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS);
}

func reportCallToNonFunction(this: &TypeChecker, span: Span, base: &Type) -> TCState {
    let loc = toString(&span);
    let typ = toString(base);
    C::fprintf(stderr, "%s: %s: Can't call expression of type %s.\n", loc.buffer, ERR_STR, typ.buffer);
    C::fprintf(stderr, "%s: %s: Currently, all variables (including global variables) shadow functions.\n", loc.buffer, NOTE_STR);
    C::fprintf(stderr, "%s: %s: This is a known limitation and will be fixed soon.\n", loc.buffer, NOTE_STR);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_CALL_TO_NON_FUNCTION);
}

func reportArgumentCountMismatch(this: &TypeChecker, span: Span, base: &Type, args: usize) -> TCState {
    return reportArgumentCountMismatch(this, span, base, args, false);
}
func reportArgumentCountMismatch(this: &TypeChecker, span: Span, base: &Type, args: usize, atLeast: bool) -> TCState {
    let c: usize = 0;
    match (base) {
        &Type::Func(params, _, _) => { c = params.length; }
        _ => { unreachable(); }
    }
    let loc = toString(&span);
    let typ = toString(base);
    let s = "arguments";
    if (c == 1) s = "argument";
    let w = "were";
    if (args == 1) w = "was";
    let min = "";
    if (atLeast) min = "at least ";
    C::fprintf(stderr, "%s: %s: Call expects %s%llu %s, but %llu %s provided.\n", loc.buffer, ERR_STR, min, c, s, args, w);
    C::fprintf(stderr, "%s: %s: Call expression has type %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_CALL_TO_NON_FUNCTION);
}

func reportUnknownSubmodule(this: &TypeChecker, mod: &ModuleLookup, name: Token) -> TCState {
    let loc = toString(&name.span);
    let _mod = at(&modules, mod.globalID);
    let orig = toString(&_mod.span);
    let _origName = toString(&_mod.name.content);
    let _name = toString(&name.content);
    C::fprintf(stderr, "%s: %s: Module `%s` does not contain any submodules named `%s`.\n", loc.buffer, ERR_STR, _origName.buffer, _name.buffer);
    C::fprintf(stderr, "%s: %s: Module declared here.\n", orig.buffer, NOTE_STR);
    drop(&_name);
    drop(&_origName);
    drop(&orig);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_UNKNOWN_SUBMODULE);
}
func reportUnknownModule(this: &TypeChecker, name: Token) -> TCState {
    let loc = toString(&name.span);
    let _name = toString(&name.content);
    C::fprintf(stderr, "%s: %s: Use of undeclared module `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_NO_SUCH_MODULE);
}
func reportModuleAccessOfNonModule(this: &TypeChecker, span: Span, name: Token, typ: TypeLookup) -> TCState {
    let loc = toString(&span);
    let _name = toString(&name.content);
    C::fprintf(stderr, "%s: %s: `%s` is not a module, so the `::` operator cannot be applied.\n", loc.buffer, ERR_STR, _name.buffer);
    if (typ.kind != TYPE_LOOKUP_INVALID) {
        let _loc = getLocation(&typ);
        C::fprintf(stderr, "%s: %s: Struct declared here.\n", _loc.buffer, NOTE_STR);
        drop(&_loc);
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_MODULE_ACCESS_NON_MODULE);
}
func reportDuplicateVariant(this: &TypeChecker, orig: &ParsedUnionVariant, dupl: &UnionVariantLookup) -> TCState {
    let duplLoc: String = toString(&orig.span);
    let origLoc: String = toString(&dupl.global.span);
    let name: String = toString(&orig.name.content);
    C::fprintf(stderr, "%s: %s: Union Variant redeclaration.\n", duplLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Variant `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return TCState::Error(ERROR_DUPLICATE_UNION_VARIANT);
}
func reportDuplicateNameInUnion(this: &TypeChecker, variant: &ParsedUnionVariant, first: &Token, dupl: &Token) -> TCState {
    let duplLoc: String = toString(&first.span);
    let origLoc: String = toString(&dupl.span);
    let name: String = toString(&first.content);
    C::fprintf(stderr, "%s: %s: Union Variant already contains a field with that name.\n", duplLoc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return TCState::Error(ERROR_DUPLICATE_UNION_NAME);
}
func reportImpossiblePattern(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let loc = toString(&pat.span);
    let patS = toString(pat);
    let typ = toString(type);
    C::fprintf(stderr, "%s: %s: A value of type %s will never match the pattern `%s`.\n", loc.buffer, ERR_STR, typ.buffer, patS.buffer);
    drop(&patS);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_IMPOSSIBLE_PATTERN);
}
func reportNotEnoughPatterns(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let err = reportImpossiblePattern(this, pat, type);
    let loc = toString(&pat.span);
    C::fprintf(stderr, "%s: %s: Not enough patterns were provided to match the type.\n", loc.buffer, NOTE_STR);
    C::fprintf(stderr, "%s: %s: If you only care about certain fields, you can use `_` or `..` to ignore the rest.\n", loc.buffer, NOTE_STR);
    drop(&loc);
    return err;
}
func reportInvalidVariantInitializer(this: &TypeChecker, decl: &ParsedUnionDecl, variant: &ParsedUnionVariant, span: Span, gotVar: ParsedUnionVariantData) -> TCState {
    let loc1 = toString(&span);
    let loc2 = toString(&decl.name.span);
    let loc3 = toString(&variant.span);
    let name1 = toString(&variant.name.content);
    let name2 = toString(&decl.name.content);
    let f = func (data: ParsedUnionVariantData) -> &char {
        match (data) {
            ParsedUnionVariantData::Empty => { return "an Empty"; }
            ParsedUnionVariantData::Struct { _, _ } => { return "a Struct"; }
            ParsedUnionVariantData::Tuple { _ } => { return "a Tuple"; }
            _ => { }
        }
        unreachable();
    };
    let exp = f(variant.data);
    let got = f(gotVar);
    C::fprintf(stderr, "%s: %s: Invalid initialization of variant `%s` of type %s.\n", loc1.buffer, ERR_STR, name1.buffer, name2.buffer);
    C::fprintf(stderr, "%s: %s: `%s` is %s variant, but an initializer for %s variant was provided.\n", loc3.buffer, NOTE_STR, name1.buffer, exp, got);
    C::fprintf(stderr, "%s: %s: Type declared here.\n", loc2.buffer, NOTE_STR);
    drop(&loc1);
    drop(&loc2);
    drop(&loc3);
    drop(&name1);
    drop(&name2);
    this.typeError = true;
    return TCState::Error(ERROR_INVALID_VARIANT_INIT);
}
func reportInvalidVariant(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let loc = toString(&pat.span);
    let patS = toString(pat);
    let typ = toString(type);
    C::fprintf(stderr, "%s: %s: A value of type %s will never match the pattern `%s`.\n", loc.buffer, ERR_STR, typ.buffer, patS.buffer);
    C::fprintf(stderr, "%s: %s: Type %s has no such variant.\n", loc.buffer, NOTE_STR, typ.buffer);
    drop(&patS);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_IMPOSSIBLE_PATTERN);
}
func reportInvalidVariant(this: &TypeChecker, pat: &ParsedPattern, type: &Type, expVar: ParsedUnionVariantData, gotVar: ParsedUnionVariantData) -> TCState {
    let loc = toString(&pat.span);
    let patS = toString(pat);
    let typ = toString(type);
    let f = func (data: ParsedUnionVariantData) -> &char {
        match (data) {
            ParsedUnionVariantData::Empty => { return "an Empty"; }
            ParsedUnionVariantData::Struct { _, _ } => { return "a Struct"; }
            ParsedUnionVariantData::Tuple { _ } => { return "a Tuple"; }
            _ => { }
        }
        unreachable();
    };
    let exp = f(expVar);
    let got = f(gotVar);
    C::fprintf(stderr, "%s: %s: A value of type %s will never match the pattern `%s`.\n", loc.buffer, ERR_STR, typ.buffer, patS.buffer);
    C::fprintf(stderr, "%s: %s: %s pattern can't be used to match against %s variant.\n", loc.buffer, NOTE_STR, got, exp);
    drop(&patS);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_IMPOSSIBLE_PATTERN);
}
func reportNoSuchVariant(this: &TypeChecker, lookup: &UnionLookup, tkn: Token) -> TCState {
    let loc1 = toString(&tkn.span);
    let name1 = toString(&tkn.content);
    let loc2 = toString(&lookup.name.span);
    let name2 = toString(&lookup.name.content);
    C::fprintf(stderr, "%s: %s: Type %s has no variant named `%s`.\n", loc1.buffer, ERR_STR, name2.buffer, name1.buffer);
    C::fprintf(stderr, "%s: %s: Type declared here.\n", loc2.buffer, NOTE_STR);
    drop(&loc1);
    drop(&loc2);
    drop(&name1);
    drop(&name2);
    this.typeError = true;
    return TCState::Error(ERROR_NO_SUCH_VARIANT);
}
func reportTooManyPatterns(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let err = reportImpossiblePattern(this, pat, type);
    let loc = toString(&pat.span);
    C::fprintf(stderr, "%s: %s: Too many patterns were provided to match the type.\n", loc.buffer, NOTE_STR);
    drop(&loc);
    return err;
}
func reportStatementInNakedFunction(this: &TypeChecker, stmt: &ParsedStmt) -> TCState {
    let loc = toString(&stmt.span);
    C::fprintf(stderr, "%s: %s: Only `asm` statements are allowed in functions marked `@naked`.\n", loc.buffer, ERR_STR);
    drop(&loc);
    return TCState::Error(ERROR_NAKED_STATEMENT);
}
func reportAssemblyWrongReturnType(this: &TypeChecker, stmt: &ParsedStmt, got: &Type, wanted: &Type) -> TCState {
    let loc = toString(&stmt.span);
    let name1 = toString(got);
    let name2 = toString(wanted);
    C::fprintf(stderr, "%s: %s: The function passed as the first argument to `asm` must return an %s.\n", loc.buffer, ERR_STR, name2.buffer);
    C::fprintf(stderr, "%s: %s: The function currently returns a value of type `%s`.\n", loc.buffer, NOTE_STR, name1.buffer);
    drop(&name2);
    drop(&name1);
    drop(&loc);
    return TCState::Error(ERROR_TYPE_MISMATCH);
}
func reportAssemblyNotAFunction(this: &TypeChecker, stmt: &ParsedStmt, got: &Type, wanted: &Type) -> TCState {
    let loc = toString(&stmt.span);
    let name1 = toString(got);
    let name2 = toString(wanted);
    C::fprintf(stderr, "%s: %s: Expected first argument of `asm` to be a function, but found expression of type `%s`.\n", loc.buffer, ERR_STR, name1.buffer);
    C::fprintf(stderr, "%s: %s: Inline assembly uses compile-time evaluation and requires the function to return an %s.\n", loc.buffer, NOTE_STR, name2.buffer);
    drop(&name2);
    drop(&name1);
    drop(&loc);
    return TCState::Error(ERROR_TYPE_MISMATCH);
}
func reportAssemblyArgCountMismatch(this: &TypeChecker, stmt: &ParsedStmt, argCount: usize, paramCount: usize) -> TCState {
    let args = pl(argCount, "argument", "arguments");
    let params = pl(paramCount, "parameter", "parameters");
    let loc = toString(&stmt.span);
    C::fprintf(stderr, "%s: %s: The function passed to `asm` expected %llu %s, but got %llu %s.\n", loc.buffer, ERR_STR, paramCount, params, argCount, args);
    drop(&loc);
    return TCState::Error(ERROR_TYPE_MISMATCH);
}

func reportMissingTrampoline(this: &TypeChecker, span: Span) -> TCState {
    let loc = toString(&span);
    C::fprintf(stderr, "%s: %s: Pattern in variable declaration is not exhaustive.\n", loc.buffer, ERR_STR);
    C::fprintf(stderr, "%s: %s: Provide a trampoline to handle the case where the pattern does not match.\n", loc.buffer, NOTE_STR);
    C::fprintf(stderr, "%s: %s: A trampoline is an `else`-block after the declaration, for example `let a = 10 else { /* trampoline */ };`\n", loc.buffer, NOTE_STR);
    drop(&loc);
    return TCState::Error(ERROR_MISSING_TRAMPOLINE);
}

func reportUnnecessaryTrampoline(this: &TypeChecker, span: Span) {
    let loc = toString(&span);
    C::fprintf(stderr, "%s: %s: Pattern in variable declaration is exhaustive, the trampoline is unreachable.\n", loc.buffer, WARN_STR);
    drop(&loc);
}

func emergencyPrint(this: &TypeChecker, where: Span) {
    let t: Token = Token {
        span: where,
        content: newSubStrOfStrLit(""),
        kind: TOKEN_EOF
    };
    C::printf("%s\n", getLocation(&t).buffer);
}

func typeCheckProject(this: &TypeChecker, project: &ParsedFile) -> bool {
    if (!fillLookup(this)) return false;
    if (!typeCheckFiles(this)) return false;
    if (findRecursiveTypes(this)) return false;
    return !this.typeError;
}

func dfs(this: &TypeChecker, type: &Type, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    match (type) {
        &Type::Array(under, _) => { return dfs(this, under, visited, finished); }
        &Type::Struct(decl) => {
            return dfs(this, asTypeLookup(getStructByGlobalID(&this.lookup, getID(decl))), visited, finished);
        }
        &Type::Union(decl, _) => {
            return dfs(this, asTypeLookup(getUnionByGlobalDecl(&this.lookup, decl)), visited, finished);
        }
        _ => { }
    }
    return false;
}

func dfs(this: &TypeChecker, typeLookup: TypeLookup, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    if (contains(finished, &typeLookup))
        return false;
    if (contains(visited, &typeLookup))
        return true;
    push(visited, typeLookup);
    let done: bool = false;
    if (isStruct(&typeLookup)) {
        let strukt: &StructLookup = asStruct(&typeLookup);
        for (let i: usize = 0; i < strukt.fields.length; i = i + 1) {
            let field: &VariableLookup = at(&strukt.fields, i);
            assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
            let fieldType: &Type = getType(&field.typeState);
            if (dfs(this, fieldType, visited, finished)) {
                done = true;
            }
        }
    } else if (isUnion(&typeLookup)) {
        let onion: &UnionLookup = asUnion(&typeLookup);
        for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
            let _variant = at(&onion.variants, i);
            let variant = _variant.global;
            let (true, fields) = get_fields(variant) else {
                continue;
            };
            for (let j: usize = 0; j < fields.length; j = j + 1) {
                let field = fields.elements[j];
                assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
                let fieldType = getType(&field.typeState);
                if (dfs(this, fieldType, visited, finished)) {
                    done = true;
                }
            }
        }
    } else {
        unreachable("Exhaustive handling of TypeLookup kinds in dfs");
    }
    push(finished, typeLookup);
    return done;
}

func findRecursiveTypes(this: &TypeChecker) -> bool {
    let recursive: bool = false;
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl: &ParsedStructDecl = at(&structDecls, i);
        if (decl.ignored) continue;
        let strukt: &StructLookup = getStructByGlobalID(&this.lookup, i);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(strukt), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(strukt), &visited);
            recursive = true;
        }
    }
    for (let i: usize = 0; i < unionDecls.length; i = i + 1) {
        let decl: &ParsedUnionDecl = at(&unionDecls, i);
        if (decl.ignored) continue;
        let onion: &UnionLookup = getUnionByGlobalDecl(&this.lookup, decl);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(onion), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(onion), &visited);
            recursive = true;
        }
    }
    return recursive;
}

func fillLookup(this: &TypeChecker) -> bool {
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = insertFile(&this.lookup, file);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.ignored) continue;
            if (!insertTLI(this.currentModule, tli)) success = false;
        }
    }
    return success;
}

func typeCheckFiles(this: &TypeChecker) -> bool {
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_STRUCT_DECL) {
                let state = typeCheckStructDecl(this, tli.nodeID);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_UNION_DECL) {
                let state = typeCheckUnionDecl(this, asUnion(tli));
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
             let tliID: usize = *at(&file.mod.tlis, j);
             let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
             if (tli.kind == TLI_MOD_DECL) {
                 let state = typeCheckModule(this, tli.nodeID, &this.currentModule.variables);
                 if (!isSuccess(&state)) success = false;
             }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_VAR_DECL) {
                let state = typeCheckVarDecl(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, false);
                let _dupl: &FunctionLookup = null;
                let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
                if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                    assert(_dupl != null, "Duplicate FunctionLookup is null");
                    reportDuplicateFunction(this, funcLookup, _dupl);
                    success = false;
                }
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    return success;
}

// FIXME: This function is a mess
func typeCheckModule(this: &TypeChecker, modID: usize, scopes: &ScopeLookupList) -> TCState {
    let mod = at(&modules, modID);
    let prev = this.currentModule;
    this.currentModule = getModuleByGlobalID(&this.lookup, modID);
    let result = TCState::Success;
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_STRUCT_DECL) {
            let state = typeCheckStructDecl(this, tli.nodeID);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_UNION_DECL) {
            let state = typeCheckUnionDecl(this, asUnion(tli));
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_MOD_DECL) {
            let state = typeCheckModule(this, tli.nodeID, scopes);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_VAR_DECL) {
            let state = typeCheckVarDecl(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, false);
            let _dupl: &FunctionLookup = null;
            let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
            if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                assert(_dupl != null, "Duplicate FunctionLookup is null");
                result = reportDuplicateFunction(this, funcLookup, _dupl);
            }
            if (!isSuccess(&state)) result = state;
        }
    }
    this.currentModule = prev;
    return result;
}

func typeCheckUnionDecl(this: &TypeChecker, onion: &ParsedUnionDecl) -> TCState {
    if (onion.ignored) return TCState::Success;
    let unionLookup = getUnionByGlobalDecl(&this.lookup, onion);
    assert(isUnion(unionLookup.type), "typeCheckUnionDecl: Union Lookup doesn't contain Union Type");
    let result = TCState::Type(unionLookup.type);
    for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
        let variant = *at(&onion.variants, i);
        /*
        union Foo {
            A,
            B
        }
        typeof(Foo::A) == Foo
        typeof(Foo::B) == Foo
         */
        let state: TCState = TCState::Type(wrap(Type::Union(onion, 0)));
        let dupl: &UnionVariantLookup = null;
        if (checkForDuplicateVariant(unionLookup, variant, &dupl)) {
            result = reportDuplicateVariant(this, variant, dupl);
        }
        match (&variant.data) {
            &ParsedUnionVariantData::Empty => { }
            &ParsedUnionVariantData::Tuple { fields } => {
                for (let j: usize = 0; j < fields.length; j = j + 1) {
                    let fieldState = typeCheckTypeNode(this, fields.elements[j]);
                    if (!isSuccess(&fieldState)) {
                        result = fieldState;
                    }
                }
            }
            &ParsedUnionVariantData::Struct { fields, names } => {
                assert(fields.length == names.length, "typeCheckUnionDecl: fields.length != names.length");
                for (let j: usize = 0; j < fields.length; j = j + 1) {
                    let field = fields.elements[j];
                    let name = &names.elements[j];
                    let duplName: &Token = null;
                    if (checkForDuplicateName(variant, name, &duplName)) {
                        result = reportDuplicateNameInUnion(this, variant, name, duplName);
                        break;
                    }
                    let fieldState = typeCheckTypeNode(this, field);
                    if (!isSuccess(&fieldState)) {
                        result = fieldState;
                    }
                }
            }
            _ => { unreachable(); }
        }
        addVariant(unionLookup, variant, state);
    }
    if (isSuccess(&result)) {
        onion.typeState = result;
    }
    return result;
}

// FIXME: getStructByGlobalID -> getStructByGlobalDecl
func typeCheckStructDecl(this: &TypeChecker, structID: usize) -> TCState {
    let strukt: &ParsedStructDecl = at(&structDecls, structID);
    if (strukt.ignored) return TCState::Success;
    let structLookup: &StructLookup = getStructByGlobalID(&this.lookup, structID);
    assert(isStruct(structLookup.type), "typeCheckStructDecl: Struct Lookup doesn't contain Struct Type");
    let context: &StructContext = &strukt.context;
    let result = TCState::Success;
    let failure = TCState::Invalid;
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let typ = getFieldTypeAtIndex(context, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateField(structLookup, &name, &dupl)) {
            failure = reportDuplicateField(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        addField(structLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    strukt.typeState = TCState::Type(structLookup.type);
    return result;
}

func typeCheckFunction(this: &TypeChecker, funcID: usize, scopes: &ScopeLookupList, signatureOnly: bool) -> TCState {
    return typeCheckFunction(this, at(&funcDecls, funcID), scopes, signatureOnly);
}
func typeCheckFunction(this: &TypeChecker, function: &ParsedFuncDecl, scopes: &ScopeLookupList, signatureOnly: bool) -> TCState {
    if (function.ignored) return TCState::Success;
    let funcLookup = getFunctionByGlobalID(&this.lookup, getID(function));
    this.currentFunction = funcLookup;
    let failure = TCState::Invalid;
    clear(&funcLookup.params);
    let params: TypeList = blank;
    for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
        let typ = getTypeAtIndex(&function.params, i);
        let name: Token = getNameAtIndex(&function.params, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateParam(funcLookup, &name, &dupl)) {
            failure = reportDuplicateParameter(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        push(&params, getType(&state));
        addParameter(funcLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    let retState: TCState = typeCheckTypeNode(this, function.retType);
    if (isError(&retState)) return retState;
    let fnType = wrap(Type::Func(params, getType(&retState), FuncAttr {
        isVariadic: function.params.isVarArg,
        isNoreturn: hasAttribute(function, ParsedAttribute::Noreturn)
    }));
    let state = TCState::Type(fnType);
    funcLookup.fnType = state;
    function.typeState = state;
    if (isExtern(function)) {
        if (!function.parent.isFile) {
            let mod = getParentModule(function);
            let _name = getMangledName(function);
            if (mod.dlls.length == 0) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    C::fprintf(stderr, "%s: %s: No dynamic library was found for external function %s. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNotFound();
            }
            let addrFound = false;
            for (let i: usize = 0; i < mod.dlls.length; i = i + 1) {
                let dll = at(&dlls, *at(&mod.dlls, i));
                @os(WINDOWS) let handle = WinAPI::GetProcAddress(dll.handle, _name.buffer);
                @os(LINUX) let handle = dlsym(dll.handle, _name.buffer);
                if (!isNull(handle)) {
                    function.dllHandle = newDLL(dll.path, handle);
                    addrFound = true;
                    break;
                }
            }
            if (!addrFound && function.dllHandle != dllNotFound()) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    C::fprintf(stderr, "%s: %s: Could not find external function %s in any DLL. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNoSuchFunction();
            }
            drop(&_name);
        } else {
        }
        return function.typeState;
    }
    if (signatureOnly) {
        return TCState::Success;
    }
    let scope: ScopeLookup = blank;
    for (let i: usize = 0; i < funcLookup.params.length; i = i + 1) {
        addVariable(&scope, *(at(&funcLookup.params, i)));
    }
    push(scopes, scope);
    let blockState: TCState = typeCheckBlock(this, function.body, scopes, hasAttribute(function, ParsedAttribute::Naked));
    pop(scopes);
    if (isError(&blockState)) {
        return blockState;
    }
    return function.typeState;
}

func typeCheckBlock(this: &TypeChecker, block: &ParsedBlock, scopes: &ScopeLookupList, nakedFunc: bool) -> TCState {
    if (block.ignored) return TCState::Success;
    if (isSuccess(&block.typeState)) {
        return block.typeState;
    }
    push(scopes, ScopeLookup {
        variables: blank,
    });
    let curr: usize = scopes.length;
    // REVIEW: Do we want to make blocks expressions?
    let blockState: TCState = TCState::Success;
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmt = getStmtAtIndex(block, i);
        if (nakedFunc) {
            match (&stmt.data) {
                &StmtData::Asm(_, _) => {},
                &StmtData::Block(_block) => {
                    blockState = typeCheckBlock(this, _block, scopes, nakedFunc);
                    continue;
                }
                _ => {
                    blockState = reportStatementInNakedFunction(this, stmt);
                    continue;
                }
            }
        }
        let stmtState: TCState = typeCheckStmt(this, stmt, scopes);
        if (isError(&stmtState)) {
            blockState = stmtState;
        }
    }
    let after: usize = scopes.length;
    pop(scopes);
    assert(after == curr, "Stack imbalance");
    if (isError(&blockState)) return blockState;
    (*block).typeState = TCState::Success;
    return block.typeState;
}

func typeCheckStmt(this: &TypeChecker, stmt: &ParsedStmt, scopes: &ScopeLookupList) -> TCState {
    if (stmt.ignored) return TCState::Success;
    if (isSuccess(&stmt.typeState)) return stmt.typeState;
    let state = TCState::Success;
    match (&stmt.data) {
        &StmtData::VarDecl(_) => { return typeCheckVarDecl(this, stmt, scopes, false); }
        &StmtData::ReturnEmpty => {
            assert(this.currentFunction != null);
            let retState: &TCState = &this.currentFunction.fnType;
            let _rt = getType(retState);
            let retType = getReturnType(_rt);
            if (!isNone(retType)) {
                C::printf("%s\n", toString(&stmt.span).buffer);
                C::printf("%s\n", toString(retType).buffer);
                todo_with_msg("function returns something, but we wrote return;");
            }
        }
        &StmtData::ReturnExpr(expr) => {
            let exprState: TCState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            assert(this.currentFunction != null);
            let retState: &TCState = &this.currentFunction.fnType;
            assert(isSuccess(retState), "ready to use function has invalid return type");
            assert(isType(retState), "ready to use function has non-type as return type");
            let _rt = getType(retState);
            let retType = getReturnType(_rt);
            if (isNone(retType)) todo_with_msg("unexpected ret expr where empty function");
            if (wantsInfer(&exprState)) {
                exprState = inferTypeOntoExpr(this, expr, retType, scopes);
                if (isError(&exprState)) return exprState;
                assert(isType(&exprState), "Failed to infer type of return expression");
            }
            let exprType: &Type = getType(&exprState);
            if (!equals(exprType, retType)) {
                return reportTypeMismatch(this, stmt.span, retType, exprType);
            }
            state = *retState;
        }
        &StmtData::Expr(expr) => {
            let exprState: TCState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) {
                let noneType: &Type = wrap(Type::Prim(PrimType::None));
                exprState = inferTypeOntoExpr(this, expr, noneType, scopes);
            }
            if (!isType(&exprState)) {
                C::printf("%s\n", toString(&stmt.span).buffer);
                C::printf("%llu\n", tag(&exprState));
                todo_with_msg("what is it then");
            }
            let exprType: &Type = getType(&exprState);
            if (!isNone(exprType) && !isAssignment(expr) && *flags.warnUnused) {
                let loc: String = toString(&expr.span);
                C::fprintf(stderr, "%s: %s: Unused expression value.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            state = exprState;
        }
        &StmtData::Block(block) => { state = typeCheckBlock(this, block, scopes, false /*Don't care*/); }
        &StmtData::If(cond, then) => {
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let thenState: TCState = typeCheckStmt(this, then, scopes);
            if (isError(&condState)) return condState;
            if (isError(&thenState)) return thenState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto if-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::IfElse(cond, then, elze) => {
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let thenState: TCState = typeCheckStmt(this, then, scopes);
            let elseState: TCState = typeCheckStmt(this, elze, scopes);
            if (isError(&condState)) return condState;
            if (isError(&thenState)) return thenState;
            if (isError(&elseState)) return elseState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto if-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::While(cond, body) => {
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let bodyState: TCState = typeCheckStmt(this, body, scopes);
            if (isError(&condState)) return condState;
            if (isError(&bodyState)) return bodyState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto while-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::IfLet(pat, expr, block) => {
            // REVIEW: Check if pattern is exhaustive?
            push(scopes, blank);
            state = handleLetPatExpr(this, stmt.span, pat, expr, scopes, false);
            if (isError(&state)) return state;
            let blockState = typeCheckBlock(this, block, scopes, false);
            if (isError(&blockState)) return blockState;
            pop(scopes);
        }
        &StmtData::IfLetElse(pat, expr, block, elze) => {
            // REVIEW: Check if pattern is exhaustive?
            push(scopes, blank);
            state = handleLetPatExpr(this, stmt.span, pat, expr, scopes, false);
            if (isError(&state)) return state;
            let blockState = typeCheckBlock(this, block, scopes, false);
            if (isError(&blockState)) return blockState;
            pop(scopes);
            let elseState = typeCheckBlock(this, elze, scopes, false);
            if (isError(&elseState)) return elseState;
        }
        &StmtData::WhileLet(pat, expr, block) => {
            // REVIEW: Check if pattern is exhaustive?
            push(scopes, blank);
            state = handleLetPatExpr(this, stmt.span, pat, expr, scopes, false);
            if (isError(&state)) return state;
            let blockState = typeCheckBlock(this, block, scopes, false);
            if (isError(&blockState)) return blockState;
            pop(scopes);
        }
        &StmtData::CFor { init, cond, step, body } => {
            push(scopes, blank);
            let initState: TCState = typeCheckStmt(this, init, scopes);
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let stepState: TCState = typeCheckExpr(this, step, scopes);
            let bodyState: TCState = typeCheckStmt(this, body, scopes);
            pop(scopes);
            if (isError(&initState)) return initState;
            if (isError(&condState)) return condState;
            if (isError(&stepState)) return stepState;
            if (isError(&bodyState)) return bodyState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto for-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::Break => { }
        &StmtData::Continue => { }
        &StmtData::Match(_,_,_) => { return typeCheckMatchStmt(this, stmt, scopes); }
        &StmtData::Asm(fn, args) => {
            if (*flags.disableInlineAssembly) {
                let loc = toString(&stmt.span);
                C::fprintf(stderr, "%s: %s: Cannot use inline assembly.\n", loc.buffer, ERR_STR);
                C::fprintf(stderr, "%s: %s: Flag `--no-inline-assembly` was provided.\n", loc.buffer, NOTE_STR);
            }
            let exprState = typeCheckExpr(this, fn, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) return exprState; // Can't be done in here
            let exprType = getType(&exprState);
            comptime ASM_CONTEXT = BUILD_A_KEYWORD("ASMContext");
            comptime ASM_FILE = BUILD_A_KEYWORD("asm.bufo");
            let context = findStructByNameInFile(&this.lookup, &ASM_FILE, &ASM_CONTEXT);
            assert(context != null, "typeCheckStmt: Could not find struct context for ASMContext");
            match (exprType) {
                &Type::Func(params, ret, _) => {
                    if (!equals(ret, context.type)) {
                        return reportAssemblyWrongReturnType(this, stmt, ret, context.type);
                    }
                    if (args.length != params.length) {
                        return reportAssemblyArgCountMismatch(this, stmt, args.length, params.length);
                    }
                    for (let i: usize = 0; i < params.length; i = i + 1) {
                        let arg = *at(&args, i);
                        let par = *at(&params, i);
                        let argState = typeCheckExpr(this, arg, scopes);
                        if (isError(&argState)) return argState;
                        if (wantsInfer(&argState)) {
                            todo_with_msg("infer type onto asm arg");
                        }
                        assert(isType(&argState), "Expected asm-arg to be valid by now");
                    }
                }
                type => {
                    return reportAssemblyNotAFunction(this, stmt, type, context.type);
                }
            }
        }
        unknown => {
            C::fprintf(stderr, "%s typeCheckStmt: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
    if (isError(&state)) return state;
    stmt.typeState = state;
    return state;
}

func typeCheckMatchStmt(this: &TypeChecker, match: &ParsedStmt, scopes: &ScopeLookupList) -> TCState {
    let expr: &ParsedExpr = null;
    let patterns: &ParsedPatternList = null;
    let stmts: &ParsedStmtList = null;
    match (&match.data) {
        &StmtData::Match(_expr, _patterns, _stmts) => {
            expr = _expr;
            patterns = &_patterns;
            stmts = &_stmts;
        }
        _ => { unreachable(); }
    }
    let exprState = typeCheckExpr(this, expr, scopes);
    if (isError(&exprState)) return exprState;
    if (wantsInfer(&exprState)) todo_with_msg("match expr wants infer");
    let type = getType(&exprState);
    assert(patterns.length == stmts.length);
    let result = TCState::Success;
    let complete = false;
    // TODO: typeCheckMatchStmt: Check for exhaustive pattern matching
    // TODO: How do we know if we exhausted all union patterns?
    // TODO: How do we know if we exhausted any pattern?
    for (let i: usize = 0; i < patterns.length; i = i + 1) {
        let scope: ScopeLookup = blank;
        let pat = *at(patterns, i);
        let patState = checkAndBindPattern(this, type, pat, scopes, &scope);
        if (isError(&patState)) {
            result = patState;
            continue;
        }
        assert(isPattern(&patState));
        let _patState = getPatState(&patState);
        push(scopes, scope);
        let stmt = *at(stmts, i);
        let stmtState = typeCheckStmt(this, stmt, scopes);
        pop(scopes);
        complete = _patState.complete;
        if (complete && i != patterns.length - 1) {
            let next = *at(patterns, i + 1);
            let loc = toString(&next.span);
            C::fprintf(stderr, "%s: %s: Unreachable pattern.\n", loc.buffer, WARN_STR);
            drop(&loc);
            patterns.length = i + 1;
            stmts.length = i + 1;
        }
    }
    if (isError(&result)) return result;
    if (!complete) {
        let loc = toString(&match.span);
        C::fprintf(stderr, "%s: %s: Patterns of a match statement must be exhaustive.\n", loc.buffer, ERR_STR);
        let wildcard = tokenKindToString(TOKEN_WILDCARD);
        C::fprintf(stderr, "%s: %s: You can use the wildcard pattern %s to catch all other cases.\n", loc.buffer, NOTE_STR, wildcard);
        drop(&loc);
        return TCState::Error(ERROR_NON_EXHAUSTIVE_MATCH);
    }
    // match.typeState doesn't work because Parser treats match as start of statement
    (match.typeState = TCState::Pattern(PatState { complete: true }));
    return result;
}

func checkAndBindPattern(this: &TypeChecker, type: &Type, pat: &ParsedPattern, scopes: &ScopeLookupList, scope: &ScopeLookup) -> TCState {
    return checkAndBindPattern(this, type, pat, scopes, scope, false);
}
func checkAndBindPattern(this: &TypeChecker, type: &Type, pat: &ParsedPattern, scopes: &ScopeLookupList, scope: &ScopeLookup, globalScope: bool) -> TCState {
    let check_ident = func (this: &TypeChecker, type: &Type, pat: &ParsedPattern, ident: Token, scopes: &ScopeLookupList, scope: &ScopeLookup, globalScope: bool) -> TCState {
        let loc: Token = blank;
        if (globalScope) {
            let index: usize = 0;
            assert(getVarIndexByName(scope, ident.content, &index), "Could not find variable in global scope");
            let var: &VariableLookup = getVariableAtIndex(scope, index);
            var.typeState = TCState::Type(type);
        } else if (isKnownVariable(scope, ident.content, &loc)) {
            return reportVariableRedeclaration(this, ident, loc);
        } else {
            if (*flags.warnSimple) {
                for (let i: usize = 0; i < scopes.length - 1; i = i + 1) {
                    let s = at(scopes, i);
                    let _loc: Token = blank;
                    if (isKnownVariable(s, ident.content, &_loc)) {
                        let loc1 = toString(&ident.span);
                        let loc2 = toString(&_loc.span);
                        let name1 = toString(&ident.content);
                        C::fprintf(stderr, "%s: %s: Shadowing variable `%s` from an outer scope.\n", loc1.buffer, WARN_STR, name1.buffer);
                        C::fprintf(stderr, "%s: %s: Variable with the same name already declared here.\n", loc2.buffer, NOTE_STR);
                        drop(&name1);
                        drop(&loc2);
                        drop(&loc1);
                    }
                }
            }
            addVariable(scope, VariableLookup {
                globalID: getID(pat),
                name: ident,
                typeState: TCState::Type(type),
                isComptime: this.comptimeDepth > 0,
            });
        }
        return TCState::Pattern(PatState { complete: true, });
    };
    match (&pat.data) {
        &Pattern::PatWithType(subpat, typeNode) => {
            let typeState = typeCheckTypeNode(this, typeNode);
            if (isError(&typeState)) return typeState;
            let typ = getType(&typeState);
            let err = TCState::Invalid;
            if (!equals(typ, type)) {
                err = reportTypeMismatch(this, pat.span, typ, type);
            }
            let res = checkAndBindPattern(this, typ, subpat, scopes, scope, globalScope);
            if (isError(&err)) return err;
            return res;
        }
        &Pattern::Ident(ident) => {
            return check_ident(this, type, pat, ident, scopes, scope, globalScope);
        }
        &Pattern::Reference(sub) => {
            // REVIEW: Make &pat check for null?
            match (type) {
                &Type::Ptr(under) => { return checkAndBindPattern(this, under, sub, scopes, scope); }
                _ => { return reportImpossiblePattern(this, pat, type); }
            }
        }
        &Pattern::Boolean(_) => {
            if (!isBoolean(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return TCState::Pattern(PatState { complete: false });
        }
        &Pattern::Null => {
            if (!isPointer(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return TCState::Pattern(PatState { complete: false });
        }
        &Pattern::Path(name, subPat) => {
            let ident: Token = blank;
            match (&subPat.data) {
                &Pattern::Ident(_ident) => { ident = _ident; }
                &Pattern::Struct(_ident, _) => { ident = _ident; }
                _ => { unreachable("Path Pattern expected Ident or Struct as RHS"); }
            }
            match (type) {
                &Type::Union(decl, _) => {
                    if (!equals(&name.content, &decl.name.content)) {
                        return reportImpossiblePattern(this, pat, type);
                    }
                    let variant: &ParsedUnionVariant = null;
                    if (!resolveVariantByName(decl, &ident, &variant)) {
                        return reportInvalidVariant(this, pat, type);
                    }
                    match (&subPat.data) {
                        &Pattern::Ident(ident) => {
                            let ParsedUnionVariantData::Empty = variant.data else {
                                return reportInvalidVariant(this, pat, type, variant.data, ParsedUnionVariantData::Empty);
                            };
                        }
                        &Pattern::Struct(ident, subPatterns) => {
                            // The parser turns tuple patterns into struct patterns, so we must do this weird check here
                            if let ParsedUnionVariantData::Empty = variant.data {
                                return reportInvalidVariant(this, pat, type, ParsedUnionVariantData::Empty, variant.data);
                            }
                            // FIXME: Code duplication with Pattern::Struct a few lines below
                            let (true, fields) = get_fields(variant) else {
                                unreachable("Pattern::Struct got no variant fields");
                            };
                            if (subPatterns.length > fields.length) {
                                if (subPatterns.length == fields.length + 1) {
                                    let last = *at(&subPatterns, subPatterns.length - 1);
                                    if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                        return reportTooManyPatterns(this, pat, type);
                                    }
                                } else {
                                    return reportTooManyPatterns(this, pat, type);
                                }
                            }
                            if (subPatterns.length < fields.length) {
                                if (subPatterns.length > 0) {
                                    let last = *at(&subPatterns, subPatterns.length - 1);
                                    if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                        return reportNotEnoughPatterns(this, pat, type);
                                    }
                                } else {
                                    return reportNotEnoughPatterns(this, pat, type);
                                }
                            }
                            let complete = true;
                            for (let i: usize = 0; i < fields.length; i = i + 1) {
                                let subSubPat = *at(&subPatterns, i);
                                let field = fields.elements[i];
                                assert(isSuccess(&field.typeState), "checkAndBindPattern: Invalid field type");
                                let fieldType = getType(&field.typeState);
                                let subComplete = checkAndBindPattern(this, fieldType, subSubPat, scopes, scope);
                                if (isError(&subComplete)) return subComplete;
                                if (!getPatState(&subComplete).complete) {
                                    complete = false;
                                }
                                if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
                            }
                        }
                        _ => { unreachable("Expected Ident Pattern or Struct Pattern as RHS of Path Pattern"); }
                    }
                    return TCState::Pattern(PatState { complete: false });
                }
                type => {
                    let moduleLookup: &ModuleLookup = null;
                    if (resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
                        return checkAndBindPattern(this, type, subPat, scopes, scope);
                    } else {
                        return reportImpossiblePattern(this, pat, type);
                    }
                }
            }
        }
        &Pattern::Struct(name, subPatterns) => {
            match (type) {
                &Type::Struct(decl) => {
                    let lookup = getStructByGlobalID(&this.lookup, getID(decl));
                    if (!equals(&name.content, &lookup.name.content)) {
                        return reportImpossiblePattern(this, pat, type);
                    }
                    if (subPatterns.length > lookup.fields.length) {
                        if (subPatterns.length == lookup.fields.length + 1) {
                            let last = *at(&subPatterns, subPatterns.length - 1);
                            if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                return reportTooManyPatterns(this, pat, type);
                            }
                        } else {
                            return reportTooManyPatterns(this, pat, type);
                        }
                    }
                    if (subPatterns.length < lookup.fields.length) {
                        if (subPatterns.length > 0) {
                            let last = *at(&subPatterns, subPatterns.length - 1);
                            if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                return reportNotEnoughPatterns(this, pat, type);
                            }
                        } else {
                            return reportNotEnoughPatterns(this, pat, type);
                        }
                    }
                    let complete = true;
                    for (let i: usize = 0; i < lookup.fields.length; i = i + 1) {
                        // FIXME: Struct Pattern should bind by name, not index
                        let subpat = *at(&subPatterns, i);
                        let field = at(&lookup.fields, i);
                        assert(isSuccess(&field.typeState), "checkAndBindPattern: Invalid field type");
                        let fieldType = getType(&field.typeState);
                        let subComplete = checkAndBindPattern(this, fieldType, subpat, scopes, scope);
                        if (isError(&subComplete)) return subComplete;
                        if (!getPatState(&subComplete).complete) {
                            complete = false;
                        }
                        if (tag(&subpat.data) == comptime tag(&Pattern::Rest)) break;
                    }
                    return TCState::Pattern(PatState { complete: complete });
                }
                _ => { return reportImpossiblePattern(this, pat, type); }
            }
        }
        &Pattern::Number(_) => {
            if (!isInteger(type) && !isFloat(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return TCState::Pattern(PatState { complete: false });
        }
        &Pattern::Wildcard => { return TCState::Pattern(PatState { complete: true }); }
        &Pattern::Rest     => { return TCState::Pattern(PatState { complete: true }); }
        &Pattern::Tuple(patElems) => {
            let &Type::Tuple(typElems) = type else {
                return reportImpossiblePattern(this, pat, type);
            };
            if (patElems.length < typElems.length) {
                assert(patElems.length > 0, "Pattern::Tuple is empty?");
                let last = *at(&patElems, patElems.length - 1);
                if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                    return reportNotEnoughPatterns(this, pat, type);
                }
            } else if (patElems.length > typElems.length) {
                return reportTooManyPatterns(this, pat, type);
            }
            let complete = true;
            for (let i: usize = 0; i < typElems.length; i = i + 1) {
                let subpat = patElems.elements[i];
                let elemType = typElems.elements[i];
                let subComplete = checkAndBindPattern(this, elemType, subpat, scopes, scope);
                if (isError(&subComplete)) return subComplete;
                if (!getPatState(&subComplete).complete) {
                    complete = false;
                }
                if (tag(&subpat.data) == comptime tag(&Pattern::Rest)) break;
            }
            return TCState::Pattern(PatState { complete: complete });
        }
        _ => { }
    }
    unreachable("Exhaustive handling of patterns in checkAndBindPattern");
}

func typeCheckVarDecl(this: &TypeChecker, varDeclID: usize, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    return typeCheckVarDecl(this, at(&stmts, varDeclID), scopes, globalScope);
}
func handleLetPatExpr(this: &TypeChecker, span: Span, pat: &ParsedPattern, expr: &ParsedExpr, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    let declState = TCState::Success;
    let exprState = typeCheckExpr(this, expr, scopes);
    if (isError(&exprState)) {
        declState = exprState;
        exprState = TCState::Type(wrap(Type::Error));
    }
    if (wantsInfer(&exprState)) {
        // the case where `let <pat> = <expr>;` failed to get a type for `<expr>`
        exprState = inferPatternOntoExpr(this, expr, pat, scopes);
        if (isError(&exprState)) {
            declState = exprState;
            exprState = TCState::Type(wrap(Type::Error));
        }
        if (wantsInfer(&exprState)) {
            // We tried our best, but even looking at `<pat>` didnt help us resolve a type
            return reportCouldNotInferType(this, span);
        }
        assert(isType(&exprState), "typeCheckVarDecl: infer failed");
    }
    let exprType = getType(&exprState);
    let last: &ScopeLookup = last(scopes);
    let state = checkAndBindPattern(this, exprType, pat, scopes, last, globalScope);
    if (isError(&declState)) return declState;
    return state;
}
func typeCheckVarDecl(this: &TypeChecker, varDecl: &ParsedStmt, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    if (varDecl.ignored) return TCState::Success;
    match (&varDecl.data) {
        &StmtData::VarDecl(VarDecl { pat, expr, trampoline, isComptime, .. }) => {
            if (isComptime) enterComptime(this);
            // NOTE: hack1 and hack2 are... hacks. They ensure that we can't use any variables
            //       defined in the pattern (e.g. Foo::A(n)) in the trampoline in case the match
            //       failed.
            let last: &ScopeLookup = last(scopes);
            let hack1 = last.variables.length;
            let state = handleLetPatExpr(this, varDecl.span, pat, expr, scopes, globalScope);
            let hack2 = last.variables.length;
            if (isComptime) leaveComptime(this);
            if (isError(&state)) return state;
            let _patState = getPatState(&state);
            if (trampoline != null) {
                last.variables.length = hack1;
                state = typeCheckBlock(this, trampoline, scopes, false);
                last.variables.length = hack2;
                if (_patState.complete) {
                    reportUnnecessaryTrampoline(this, trampoline.span);
                }
            } else if (!_patState.complete) {
                return reportMissingTrampoline(this, varDecl.span);
            }
            varDecl.typeState = state;
            return state;
        }
        _ => { }
    }
    unreachable("typeCheckVarDecl: Expected VarDecl");
}

func typeCheckExpr(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    return typeCheckExpr(this, at(&exprs, exprID), scopes);
}
func typeCheckExpr(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    if (expr.ignored) return TCState::Success;
    if (isSuccess(&expr.typeState)) return expr.typeState;
    let state = TCState::Invalid;
    match (&expr.data) {
        &ExprData::IntLit(_) => { state = TCState::PleaseInfer; }
        &ExprData::StrLit(_) => {
            let ct = wrap(Type::Prim(PrimType::Char));
            let st = wrap(Type::Ptr(ct));
            state = TCState::Type(st);
        }
        &ExprData::CharLit(_) => {
            let ct = wrap(Type::Prim(PrimType::Char));
            state = TCState::Type(ct);
        }
        &ExprData::ArrayLit(context) => {
            if (context.elemLength == 0) return TCState::PleaseInfer;
            let elemIndex: usize = getElementAtIndex(&context, 0);
            let elemState: TCState = typeCheckExpr(this, elemIndex, scopes);
            if (isError(&elemState)) return elemState;
            if (wantsInfer(&elemState)) return elemState;
            let elemType: &Type = getType(&elemState);
            if (context.size == 0) {
                let lastErrState = TCState::Invalid;
                for (let i: usize = 1; i < context.elemLength; i = i + 1) {
                    let nextIndex: usize = getElementAtIndex(&context, i);
                    let nextState: TCState = typeCheckExpr(this, nextIndex, scopes);
                    if (isError(&nextState)) {
                        lastErrState = nextState;
                        continue;
                    }
                    let nextType: &Type = getType(&nextState);
                    if (!equals(nextType, elemType)) {
                        let loc = toString(&at(&exprs, elemIndex).span);
                        let t = toString(elemType);
                        lastErrState = reportTypeMismatch(this, at(&exprs, nextIndex).span, elemType, nextType);
                        C::fprintf(stderr, "%s: %s: Array elements inferred to be type %s here.\n", loc.buffer, NOTE_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                    }
                }
                if (!isInvalid(&lastErrState)) return lastErrState;
                let t: &Type = wrap(Type::Array(elemType, context.elemLength));
                state = TCState::Type(t);
            } else {
                let t: &Type = wrap(Type::Array(elemType, context.size));
                state = TCState::Type(t);
            }
        }
        &ExprData::Ident(ident) => { state = typeCheckIdentifier(this, &ident, scopes); }
        &ExprData::Unary(unary) => { state = typeCheckExprUnary(this, &unary, scopes); }
        &ExprData::Binary(binary) => { state = typeCheckExprBinary(this, &binary, scopes); }
        &ExprData::Call(call) => {
            state = typeCheckExprCall(this, &call, scopes);
            if (call.isUnion) {
                expr.data = ExprData::UnionInit(UnionExpr::Tuple(call));
            }
        }
        &ExprData::Sizeof(type) => {
            let typeState: TCState = typeCheckTypeNode(this, type);
            if (isError(&typeState)) return typeState;
            state = TCState::Type(wrap(Type::Prim(PrimType::Usize)));
        }
        &ExprData::StructInit(init) => { state = typeCheckExprStructInit(this, &init, scopes); }
        &ExprData::As(curr, type) => { state = typeCheckExprAs(this, expr, curr, type, scopes); }
        &ExprData::Null => { state = TCState::PleaseInfer; }
        &ExprData::Blank => { state = TCState::PleaseInfer; }
        &ExprData::True => { state = TCState::Type(wrap(Type::Prim(PrimType::Bool))); }
        &ExprData::False => { state = TCState::Type(wrap(Type::Prim(PrimType::Bool))); }
        &ExprData::Func(decl) => {
            let added = insertTLI(this.currentModule, asTLI(decl));
            assert(added, "Func Expr was already contained in lookup!");
            assert(scopes.length > 0, "Expected to at least find global scope in func expr");
            let _scopes: ScopeLookupList = blank;
            push(&_scopes, *at(scopes, 0));
            enterAnonFunc(this);
            let fn = this.currentFunction;
            state = typeCheckFunction(this, decl, &_scopes, false);
            this.currentFunction = fn;
            leaveAnonFunc(this);
            drop(&_scopes);
        }
        &ExprData::TypeInfo(type) => {
            let typeState: TCState = typeCheckTypeNode(this, type);
            if (isError(&typeState)) return typeState;
            comptime NAME = BUILD_A_KEYWORD("TypeInfo");
            comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
            let context = findUnionByNameInFile(&this.lookup, &FILE, &NAME);
            assert(context != null, "typeCheckExpr: Could not find union context for TypeInfo");
            state = TCState::Type(context.type);
        }
        &ExprData::AsData(subExpr) => {
            let typeState: TCState = typeCheckExpr(this, subExpr, scopes);
            if (isError(&typeState)) return typeState;
            if (wantsInfer(&typeState)) todo_with_msg("as_data infer");
            comptime NAME = BUILD_A_KEYWORD("Data");
            comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
            let context = findStructByNameInFile(&this.lookup, &FILE, &NAME);
            assert(context != null, "typeCheckExpr: Could not find struct context for Data");
            state = TCState::Type(context.type);
        }
        &ExprData::Tuple(elems) => {
            let tElems: TypeList = blank;
            let infer: TCState = TCState::Invalid;
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                let e = typeCheckExpr(this, elems.elements[i], scopes);
                if (isError(&e)) return e;
                if (wantsInfer(&e)) {
                    infer = e;
                    continue;
                }
                push(&tElems, getType(&e));
            }
            if (wantsInfer(&infer)) return infer;
            state = TCState::Type(wrap(Type::Tuple(tElems)));
        }
        unknown => {
            C::fprintf(stderr, "%s typeCheckExpr: Unhandled Expression with tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
    if (isError(&state)) return state;
    expr.typeState = state;
    return state;
}

func typeCheckExprAs(this: &TypeChecker, expr: &ParsedExpr, curr: &ParsedExpr, type: &ParsedTypeNode, scopes: &ScopeLookupList) -> TCState {
    let exprState: TCState = typeCheckExpr(this, curr, scopes);
    let typeState: TCState = typeCheckTypeNode(this, type);
    if (isError(&exprState)) return exprState;
    if (isError(&typeState)) return typeState;
    assert(isType(&typeState), "typeCheckExprAs Type is not a Type");
    let typeType: &Type = getType(&typeState);
    if (wantsInfer(&exprState)) exprState = inferTypeOntoExpr(this, curr, typeType, scopes);
    if (isError(&exprState)) return exprState;
    assert(isType(&exprState), "Expected <expr> in `<expr> as <type>` to have a valid type after infer");
    let exprType: &Type = getType(&exprState);
    if (isData(exprType) && isData(typeType)) {
        todo_with_msg("Data as Data???");
    } else if (isData(exprType)) {
        // Data as <Something> is allowed
    } else if (isData(typeType)) {
        // <Something> as Data is allowed
        expr.data = ExprData::AsData(curr);
    } else if (isPointer(exprType) && isPointer(typeType)) {
        // PTR as PTR is allowed
    } else if (isFunction(exprType) && isFunction(typeType)) {
        // Function as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&curr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            C::fprintf(stderr, "%s: %s: Casting from type %s to type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isFunction(exprType) && isAny(typeType)) {
        // Function as Any is allowed
        if (*flags.warnExtra) {
            let loc = toString(&curr.span);
            let from = toString(typeType);
            C::fprintf(stderr, "%s: %s: Casting from type %s to Any.\n",
                loc.buffer, WARN_STR, from.buffer);
            drop(&from);
            drop(&loc);
        }
    } else if (isAny(exprType) && isFunction(typeType)) {
        // Any as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&curr.span);
            let to = toString(typeType);
            C::fprintf(stderr, "%s: %s: Casting from Any to type %s.\n",
                loc.buffer, WARN_STR, to.buffer);
            drop(&to);
            drop(&loc);
        }
    } else if (isPointer(exprType) && isInteger(typeType)) {
        // FIXME: The condition above is too generous, see following code snippet
        /*
         * func foo(a: u32) {}
         * func bar() {
         *   let a: u32 = 10;
         *   foo(&a);
         * }
         */
        if (getSizeInBytes(typeType) != getSizeInBytes(exprType)) {
            let loc = toString(&curr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            C::fprintf(stderr, "%s: %s: Casting pointer of type %s to integer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isInteger(exprType) && isPointer(typeType)) {
        if (getSizeInBytes(typeType) != getSizeInBytes(exprType)) {
            let loc = toString(&curr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            C::fprintf(stderr, "%s: %s: Casting integer of type %s to pointer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (!isPrimitive(typeType)) {
        return reportNonPrimitiveCast(this, curr.span, exprType, typeType);
    } else if (!isPrimitive(exprType)) {
        return reportNonPrimitiveCast(this, curr.span, exprType, typeType);
    }
    if (getSizeInBytes(typeType) < getSizeInBytes(exprType) && *flags.warnExtra) {
        let loc: String = toString(&curr.span);
        let tName: String = toString(typeType);
        let oName: String = toString(exprType);
        C::fprintf(stderr, "%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n",
            loc.buffer, WARN_STR, tName.buffer, oName.buffer);
        drop(&oName);
        drop(&tName);
        drop(&loc);
    }
    return typeState;
}

func typeCheckExprUnary(this: &TypeChecker, unary: &UnaryExpr, scopes: &ScopeLookupList) -> TCState {
    match (unary) {
        &UnaryExpr::Comptime(expr) => {
            enterComptime(this);
            let exprState = typeCheckExpr(this, expr, scopes);
            leaveComptime(this);
            return exprState;
        }
        &UnaryExpr::Deref(expr) => {
            let exprState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) return exprState; // Can't be done in here
            let exprType = getType(&exprState);
            match (exprType) {
                &Type::Prim(PrimType::Any) => { return reportAnyDereference(this, expr); }
                &Type::Ptr(under) => { return TCState::Type(under); }
                _ => {
                    let loc: String = toString(&expr.span);
                    let t: String = toString(exprType);
                    C::fprintf(stderr, "%s: %s: Attempted to dereference expression of type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    return TCState::Error(ERROR_DEREF_NON_POINTER);
                }
            }
        }
        &UnaryExpr::Ref(expr) => {
            let exprState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) return exprState; // Can't be done in here
            let exprType = getType(&exprState);
            return TCState::Type(wrap(Type::Ptr(exprType)));
        }
        &UnaryExpr::Negate(expr) => {
            let exprState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) return exprState; // Can't be done in here
            let exprType = getType(&exprState);
            if (!isSignedInteger(exprType) && !isFloat(exprType)) {
                let loc: String = toString(&expr.span);
                let t: String = toString(exprType);
                C::fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
                this.typeError = true;
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        }
        &UnaryExpr::Not(expr) => {
            let exprState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) return exprState; // Can't be done in here
            let exprType = getType(&exprState);
            if (!isBoolean(exprType)) {
                let loc: String = toString(&expr.span);
                let t: String = toString(exprType);
                C::fprintf(stderr, "%s: %s: Logical Not is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
                this.typeError = true;
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of ops in typeCheckUnary");
}

func typeCheckExprCall(this: &TypeChecker, call: &CallExpr, scopes: &ScopeLookupList) -> TCState {
    // First sweep
    let args = &call.args;
    for (let i: usize = 0; i < args.length; i = i + 1) {
        let arg: TCState = typeCheckExpr(this, *at(args, i), scopes);
        if (isError(&arg)) return arg;
    }
    let callBase = typeCheckExpr(this, call.base, scopes);
    if (isError(&callBase)) return callBase;
    if (wantsInfer(&callBase)) {
        let params: TypeList = blank;
        for (let i: usize = 0; i < args.length; i = i + 1) {
            let typ = wrap(Type::Unknown);
            let state = &(*at(args, i)).typeState;
            if (isType(state)) typ = getType(state);
            push(&params, typ);
        }
        let fnType = wrap(Type::Func(params, wrap(Type::Unknown), blank));
        let baseState = tryInferTypeOntoExpr(this, call.base, fnType, scopes, false);
        if (isError(&baseState)) return baseState;
        if (wantsInfer(&baseState)) return baseState;
        callBase = baseState;
    }
    let baseType = getType(&callBase);
    match (baseType) {
        &Type::Union(decl, vID) => {
            let variant = *at(&decl.variants, vID);
            let &ParsedUnionVariantData::Tuple { fields } = &variant.data else {
                return reportInvalidVariantInitializer(this, decl, variant, call.span, ParsedUnionVariantData::Tuple);
            };
            if (args.length != fields.length) todo_with_msg("report error: Tuple variant count mismatch");
            let unionType = copy(baseType);
            for (let i: usize = 0; i < fields.length; i = i + 1) {
                let arg = *at(args, i);
                let argState = typeCheckExpr(this, arg, scopes);
                if (isError(&argState)) return argState;
                let paramType = getTypeAtIndex(variant, i);
                if (wantsInfer(&argState)) {
                    argState = inferTypeOntoExpr(this, arg, paramType, scopes);
                    if (isError(&argState)) return argState;
                }
                let argType = getType(&argState);
                if (!equals(argType, paramType)) {
                    reportTypeMismatch(this, arg.span, paramType, argType);
                }
            }
            call.isUnion = true;
            return TCState::Type(unionType);
        }
        &Type::Func(params, ret, attr) => {
            let check_params = func (this: &TypeChecker, args: &ParsedExprList, params: &TypeList, scopes: &ScopeLookupList, variadic: bool) -> TCState {
                for (let i: usize = 0; i < params.length; i = i + 1) {
                    let arg = at(args, i);
                    let paramType = *at(params, i);
                    let argState: TCState = typeCheckExpr(this, *arg, scopes);
                    if (isError(&argState)) return argState;
                    if (wantsInfer(&argState)) {
                        argState = inferTypeOntoExpr(this, *arg, paramType, scopes);
                        if (isError(&argState)) return argState;
                    }
                    let argType = getType(&argState);
                    if (isVariadicType(argType) && variadic) {
                        // no need to wrap again
                        assert(params.length == 1, "check_params: Assumption wrong");
                    } else if (!isData(argType) && isData(paramType)) {
                        *arg = newParsedExpr((*arg).span, ExprData::AsData(*arg));
                        let newState = typeCheckExpr(this, *arg, scopes);
                        if (isError(&newState)) return newState;
                        assert(isType(&newState), "idk if this is always the case");
                    } else if (!equals(argType, paramType)) {
                        reportTypeMismatch(this, (*arg).span, paramType, argType);
                    }
                }
                return TCState::Success;
            };
            if (attr.isVariadic) {
                assert(params.length > 0, "Variadic function with 0 parameters");
                let last = params.elements[params.length - 1];
                let state = TCState::Invalid;
                if (isVariadicType(last)) {
                    // bufo internal variadic
                    // FIXME: Find a way to not manipulate params.length here
                    params.length = params.length - 1; // Variadic type itself
                    if (args.length < params.length) {
                        // FIXME: We say "at least N" arguments, but it should be N-1 (ignore the variadic)
                        state = reportArgumentCountMismatch(this, call.span, baseType, args.length, true);
                        params.length = params.length + 1; // Variadic type itself
                        return state;
                    }
                    let varType = getUnderlyingType(last, false);
                    state = check_params(this, args, &params, scopes, false);
                    if (!isSuccess(&state)) {
                        params.length = params.length + 1; // Variadic type itself
                        return state;
                    }
                    // func f(p1, p2, ...p3)
                    // call f(a1, a2, a3, a4, a5)
                    // Type check a3...a5 with type p3
                    let varLen = args.length - params.length;
                    let varArgs = ParsedExprList { };
                    let varParams: TypeList = blank;
                    for (let i: usize = 0; i < varLen; i = i + 1) {
                        push(&varArgs, *at(args, params.length + i));
                        push(&varParams, varType);
                    }
                    state = check_params(this, &varArgs, &varParams, scopes, true);
                    if (!isSuccess(&state)) {
                        params.length = params.length + 1; // Variadic type itself
                        return state;
                    }
                    // -- Here we have successfully verified all types of the variadics
                    // Original:
                    //   [] = VarArgs
                    //   call f(a1, a2, [a3, a4, a5])
                    // Transform into:
                    //   call f(a1, a2, { &[a3, a4, a5], 3 })
                    args.length = params.length; // Strip off VarArgs
                    if (varArgs.length == 1) {
                        // We have exactly one variadic argument, which could be variadic itself
                        let entry = varArgs.elements[0];
                        assert(isType(&entry.typeState), "Single VarArg is not valid");
                        let t = getType(&entry.typeState);
                        if (isVariadicType(t)) {
                            if (equals(getUnderlyingType(t, false), varType)) {
                                // func f(ints: ...i32);
                                // func g(args: ...i32) {
                                //   f(args); // <-- No need to wrap [args] again
                                // }
                                push(args, entry);
                            } else {
                                let varArg = newParsedExpr(call.span, ExprData::Variadic(varArgs));
                                varArg.typeState = TCState::Type(last);
                                push(args, varArg);
                            }
                        } else {
                            let varArg = newParsedExpr(call.span, ExprData::Variadic(varArgs));
                            varArg.typeState = TCState::Type(last);
                            push(args, varArg);
                        }
                    } else {
                        let varArg = newParsedExpr(call.span, ExprData::Variadic(varArgs));
                        varArg.typeState = TCState::Type(last);
                        push(args, varArg);
                    }
                    params.length = params.length + 1; // Variadic type itself
                } else {
                    state = check_params(this, args, &params, scopes, false);
                    if (!isSuccess(&state)) return state;
                }
            } else {
                if (args.length != params.length) {
                    return reportArgumentCountMismatch(this, call.span, baseType, args.length);
                }
                let state = check_params(this, args, &params, scopes, false);
                if (!isSuccess(&state)) return state;
            }
            call.retType = ret;
            return TCState::Type(ret);
        }
        _ => { return reportCallToNonFunction(this, call.span, baseType); }
    }
    unreachable();
}

func typeCheckExprStructInit(this: &TypeChecker, expr: &StructExpr, scopes: &ScopeLookupList) -> TCState {
    let lookup: TypeLookup = blank;
    if (!resolveTypeByName(this.currentModule, &expr.name.content, &lookup)) {
        let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &expr.name.content);
        return reportUnknownType(this, null, expr.name, alternatives);
    }
    if (isStruct(&lookup)) {
        return typeCheckStructInitialization(this, expr, lookup, scopes);
    } else {
        unreachable("typeCheckExprStructInit got non-struct");
    }
}

func typeCheckIdentifier(this: &TypeChecker, ident: &IdentExpr, scopes: &ScopeLookupList) -> TCState {
    let var: VariableLookup = blank;
    let name = &ident.name;
    if (resolveVariableByName(this.currentModule, name, scopes, &var)) {
        if (this.comptimeDepth > 0 && !var.isComptime) {
            return reportRuntimeValueInComptimeContext(this, *name, &var);
        }
        let state: TCState = var.typeState;
        assert(!isInvalid(&state), "Variable not ready");
        if (isError(&state)) return state;
        let _loc: Token = blank;
        if (isKnownVariable(at(scopes, 0), name.content, &_loc)) {
            ident.isGlobal = true;
        }
        if (isType(&state)) {
            ident.type = getType(&state);
        }
        ident.origID = var.globalID;
        return state;
    }
    let functions = resolveFunctionByName(this.currentModule, name);
    if (functions.length > 1) {
        drop(&functions);
        return TCState::PleaseInfer;
    }
    if (functions.length == 1) {
        let f = at(&functions, 0);
        ident.type = getType(&f.fnType);
        ident.origID = f.globalID;
        return f.fnType;
    }
    let unionLookup: &UnionLookup = null;
    if (resolveUnionByName(this.currentModule, name, &unionLookup)) {
        assert(unionLookup != null, "resolveUnionByName returned true but lookup is null");
        let decl = unionLookup.global;
        assert(isSuccess(&decl.typeState), "Expected valid union type at this point");
        let t = getType(&decl.typeState);
        assert(isUnion(t), "Expected union declaration to have union type");
        // Must copy here because each `::` sets the variant of this type
        ident.type = t;
        return TCState::Type(copy(t));
    }
    let moduleLookup: &ModuleLookup = null;
    if (resolveModuleByName(this.currentModule, name, &moduleLookup)) {
        let typ = wrap(Type::Module(at(&modules, moduleLookup.globalID)));
        ident.type = typ;
        return TCState::Type(typ);
    }
    return reportUnknownIdentifier(this, name);
}

func typeCheckExprBinary(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    match (expr) {
        &BinaryExpr::Path(..) => { return typeCheckExprPathAccess(this, expr, scopes); }
        &BinaryExpr::Dot(..) => { return typeCheckExprMemberAccess(this, expr, scopes); }
        &BinaryExpr::Assign(..) => { return typeCheckExprAssign(this, expr, scopes); }
        &BinaryExpr::Plus(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Sub(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Mult(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Div(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Mod(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::CmpEq(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpNeq(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpGt(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpGte(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpLt(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpLte(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::LogAnd(..) => { return typeCheckExprLogical(this, expr, scopes); }
        &BinaryExpr::LogOr(..) => { return typeCheckExprLogical(this, expr, scopes); }
        &BinaryExpr::BitAnd(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::BitOr(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::BitXor(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::Indexed(..) => { return typeCheckExprIndexedAccess(this, expr, scopes); }
        unknown => {
            C::fprintf(stderr, "%s typeCheckExprBinary: Unhandled tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
    unreachable("Exhaustive handling of binary expressions in typeCheckExprBinary");
}

func typeCheckExprIndexedAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    if (wantsInfer(&lhsState)) {
        let loc = toString(&lhs.span);
        C::fprintf(stderr, "%s: %s: Could not infer type of subexpression for indexed access.\n", loc.buffer, ERR_STR);
        drop(&loc);
        return TCState::Error(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
    }
    assert(isType(&lhsState), "IndexedAccess: Not error, not infer, what is it?");
    if (wantsInfer(&rhsState)) {
        let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
        rhsState = inferTypeOntoExpr(this, rhs, usizeType, scopes);
    }
    if (isError(&rhsState)) return rhsState;
    assert(isType(&rhsState), "IndexedAccess: Index is not valid after infer?");
    let lhsType: &Type = getType(&lhsState);
    // FIXME: LHS may be of type Any here :^)
    if (!isArray(lhsType) && !isPointer(lhsType) && !isVariadicType(lhsType)) {
        return reportIndexedAccessOnNonArray(this, lhs.span, lhsType);
    }
    let rhsType: &Type = getType(&rhsState);
    match (rhsType) {
        &Type::Prim(PrimType::Usize) => {
            let underlyingType: &Type = getUnderlyingType(lhsType, false);
            return TCState::Type(underlyingType);
        }
        _ => { }
    }
    let loc: String = toString(&rhs.span);
    let typ: String = toString(rhsType);
    C::fprintf(stderr, "%s: %s: Expected index of array access to be type usize, got %s.\n", loc.buffer, ERR_STR, typ.buffer);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return TCState::Error(ERROR_INDEXED_TYPE_MISMATCH);
}

func typeCheckExprLogical(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
    let result = TCState::Type(boolType);
    if (!isBoolean(lhsType)) { result = reportTypeMismatch(this, lhs.span, boolType, lhsType); }
    if (!isBoolean(rhsType)) { result = reportTypeMismatch(this, rhs.span, boolType, rhsType); }
    return result;
}

func typeCheckExprBitwise(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType) || !isInteger(lhsType) || !isInteger(rhsType)) {
        return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
    }
    return lhsState;
}

func typeCheckExprAssign(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    // FIXME(2026-01-27): Would be cool if we had a way to disallow bogus assignments like array.length = xyz;
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    if (!isLValue(lhs)) {
        emergencyPrint(this, lhs.span);
        todo_with_msg("invalid l-value");
    }
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (!isType(&lhsState)) return lhsState;
    if (!isType(&rhsState)) return rhsState;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportTypeMismatch(this, rhs.span, lhsType, rhsType);
    }
    return rhsState;
}
func typeCheckStructInitialization(this: &TypeChecker, expr: &StructExpr, lookup: TypeLookup, scopes: &ScopeLookupList) -> TCState {
    return typeCheckStructInitialization(this, expr, lookup, scopes, false);
}

func typeCheckStructInitialization(this: &TypeChecker, expr: &StructExpr, lookup: TypeLookup, scopes: &ScopeLookupList, isUnion: bool) -> TCState {
    let context: &StructInitContext = &expr.context;
    let structLookup: &StructLookup = asStruct(&lookup);
    let hits: usize = 0;
    assert(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
    let result = TCState::Type(structLookup.type);
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let fieldExpr: &ParsedExpr = getFieldExprAtIndex(context, i);
        let exprState: TCState = typeCheckExpr(this, fieldExpr, scopes);
        if (isError(&exprState)) result = exprState;
        if (!hasField(structLookup, &name.content)) {
            result = reportUnknownField(this, name, structLookup, isUnion);
            continue;
        }
        let fieldIndex: usize = getIndexByName(structLookup, &name);
        let bit: usize = shiftLeft(1, fieldIndex);
        if ((hits & bit) != 0) {
            let field = getFieldNameAtIndex(context, fieldIndex);
            result = reportDuplicateField(this, name, field.span);
            continue;
        } else {
            hits = hits | bit;
        }
        let field: &VariableLookup = at(&structLookup.fields, fieldIndex);
        let fieldState: &TCState = &field.typeState;
        assert(isSuccess(fieldState), "Struct is ready to go, but field type is invalid?");
        assert(equals(&name.content, &field.name.content), "Seems like my hack doesn't work");
        let fieldType: &Type = getType(fieldState);
        if (wantsInfer(&exprState))
            exprState = inferTypeOntoExpr(this, fieldExpr, fieldType, scopes);
        if (isError(&exprState)) {
            result = exprState;
            continue;
        }
        let exprType: &Type = getType(&exprState);
        if (!equals(fieldType, exprType)) {
            result = reportTypeMismatch(this, fieldExpr.span, fieldType, exprType);
        }
    }
    return result;
}
func typeCheckExprPathAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: TCState = typeCheckExpr(this, lhs, scopes);
    if (isError(&instance)) return instance;
    let instanceType = getType(&instance);
    match (instanceType) {
        &Type::Module(decl) => {
            let modLookup = getModuleByGlobalID(&this.lookup, getID(decl));
            match (&rhs.data) {
                &ExprData::Ident(ident) => {
                    let submodule: &ModuleLookup = null;
                    let config = MLConfig {
                        checkSelf: false,
                        checkImport: false, // REVIEW: Should we pass true here instead?
                        checkModule: true,
                        checkParent: false,
                    };
                    if (resolveModuleByName(modLookup, &ident.name, &submodule, config)) {
                        let typ = wrap(Type::Module(at(&modules, submodule.globalID)));
                        rhs.typeState = TCState::Type(typ);
                        return rhs.typeState;
                    }
                    let var: &VariableLookup = null;
                    let fun: FunctionLookupList = blank;
                    let typ: TypeLookup = blank;
                    let res = resolveIdentifierByName(modLookup, &ident.name, &var, &typ, &fun);
                    if (res == IDENT_TYPE) {
                        if (isStruct(&typ)) {
                            return reportModuleAccessOfNonModule(this, lhs.span, ident.name, typ);
                        } else {
                            let t = asUnion(&typ).type;
                            rhs.typeState = TCState::Type(t);
                            return rhs.typeState;
                        }
                    } else if (res == IDENT_NONE) {
                        return reportUnknownSubmodule(this, modLookup, ident.name);
                    } else if (res == IDENT_FUNC) {
                        assert(fun.length != 0, "IDENT_FUNC but fun is empty");
                        if (fun.length == 1) {
                            let f = at(&fun, 0);
                            assert(isSuccess(&f.fnType), "Did not properly type check function of module");
                            let s = f.fnType;
                            rhs.typeState = s;
                            ident.type = getType(&s);
                            ident.origID = f.globalID;
                            return s;
                        } else {
                            drop(&fun);
                            return TCState::PleaseInfer;
                        }
                    } else if (res == IDENT_VAR) {
                        assert(var != null, "IDENT_VAR but var is null");
                        todo_with_msg("module.var");
                    } else {
                        unreachable("Exhaustive handling of outcomes of resolveIdentifierByName");
                    }
                }
                &ExprData::StructInit(init) => {
                    let lookup: TypeLookup = blank;
                    if (!resolveTypeByName(modLookup, &init.name.content, &lookup)) {
                        return reportUnknownType(this, modLookup, init.name, blank);
                    }
                    if (isStruct(&lookup)) {
                        rhs.typeState = typeCheckStructInitialization(this, &init, lookup, scopes);
                    } else {
                        unreachable("typeCheckExprModuleAccess got non-struct");
                    }
                    return rhs.typeState;
                }
                _ => { unreachable("Expected StructInit or Ident as RHS of module"); }
            }
        }
        &Type::Union(_, _) => { return typeCheckExprUnionInit(this, expr, instanceType, scopes); }
        typ => {
            let name: Token = blank;
            match (lhs.data) {
                ExprData::Ident(ident) => { name = ident.name; }
                _ => { unreachable("Expected identifier as LHS of Path access"); }
            }
            return reportModuleAccessOfNonModule(this, lhs.span, name, blank);
        }
    }
    unreachable();
}
func typeCheckExprUnionInit(this: &TypeChecker, expr: &BinaryExpr, unionType: &Type, scopes: &ScopeLookupList) -> TCState {
    let decl: &ParsedUnionDecl = null;
    match (unionType) {
        &Type::Union(_decl, _) => { decl = _decl; }
        _ => { unreachable(); }
    }
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    assert(isSuccess(&lhs.typeState), "UnionInit: Expected valid LHS type");
    let lhsType = getType(&lhs.typeState);
    assert(isUnion(lhsType), "UnionInit: Expected LHS to be union");
    assert(equals(lhsType, unionType), "UnionInit: Passed type is not the same union");
    let lookup: &UnionLookup = getUnionByGlobalDecl(&this.lookup, decl);
    let result = TCState::Type(unionType);
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            let variant: &UnionVariantLookup = null;
            if (!resolveVariantByName(lookup, &ident.name, &variant)) {
                return reportNoSuchVariant(this, lookup, ident.name);
            }
            unionType = wrap(Type::Union(decl, variant.tag));
            result = TCState::Type(unionType);
            rhs.data = ExprData::UnionInit(UnionExpr::Empty);
        }
        &ExprData::StructInit(init) => {
            let variant: &UnionVariantLookup = null;
            if (!resolveVariantByName(lookup, &init.name, &variant)) {
                return reportNoSuchVariant(this, lookup, init.name);
            }
            let ParsedUnionVariantData::Struct { _fields, _names } = variant.global.data else {
                return reportInvalidVariantInitializer(this, decl, variant.global, rhs.span, ParsedUnionVariantData::Struct);
            };
            unionType = wrap(Type::Union(decl, variant.tag));
            result = TCState::Type(unionType);
            let structLookup = intoStructLookup(variant);
            // FIXME: typeCheckStructInitialization is exactly what we need here, but it would be cool
            //        if it wasn't called like that
            let check = typeCheckStructInitialization(this, &init, asTypeLookup(&structLookup), scopes, true);
            if (isError(&check)) return check;
            rhs.data = ExprData::UnionInit(UnionExpr::Struct(init));
        }
        _ => { unreachable("Expected StructInit or Ident as RHS"); }
    }
    rhs.typeState = result;
    return result;
}
func typeCheckExprMemberAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: TCState = typeCheckExpr(this, lhs, scopes);
    if (isError(&instance)) return instance;
    if (wantsInfer(&instance)) return instance;
    let instanceType = getType(&instance);
    // TODO: There's no reason why things like the following example shouldn't work for member access.
    // [Marker for todo.py: The above TODO is important]
    // [Marker for todo.py: The above TODO is important]
    /*
    struct Foo {
        a: i32;
    }
    func main() {
        let f = Foo { a: 1 };
        let r1 = &f;
        let r2 = &r1;
        r2.a = 13; // The Dot-Operator is not defined for values of type &&Foo.
        assert(f.a == 13);
    }
    */
    if (isVariadicType(instanceType)
        || isArray(instanceType)
        || isArrayPointer(instanceType)) {
        let fieldName: Token = blank;
        match (&rhs.data) {
            &ExprData::Ident(IdentExpr { ident, .. }) => { fieldName = ident; }
            _ => { unreachable("Expected RHS to be an identifier"); }
        }
        if (equals(&fieldName.content, &comptime newSubStrOfStrLit("length"))) {
            let usizeType = wrap(Type::Prim(PrimType::Usize));
            return TCState::Type(usizeType);
        }
        let l: String = toString(&rhs.span);
        let s = "array";
        if (isVariadicType(instanceType)) s = "variadic";
        C::fprintf(stderr, "%s: %s: Attempted to access unknown field `%.*s` of %s type.\n",
            l.buffer, ERR_STR, fieldName.content.len, fieldName.content.start, s);
        drop(&l);
        return TCState::Error(ERROR_UNKNOWN_FIELD);
    }
    if (!isStruct(instanceType)
        && !isStructPointer(instanceType)
        && !isTuple(instanceType)
        && !isTuplePointer(instanceType)) {
        return reportMemberAccessOnNonStructNonTuple(this, lhs, instanceType);
    }
    let underlying: &Type = instanceType;
    if (!isStruct(underlying)) underlying = getUnderlyingType(instanceType, true);
    if (isStruct(underlying)) {
        let lookup: TypeLookup = getTypeLookupForType(&this.lookup, underlying);
        assert(isStruct(&lookup));
        let structLookup: &StructLookup = asStruct(&lookup);
        let fieldName: Token = blank;
        match (&rhs.data) {
            &ExprData::Ident(IdentExpr { ident, .. }) => { fieldName = ident; }
            &ExprData::IntLit(_) => {
                return reportNonIdentAccessOnStruct(this, lhs, instanceType);
            }
            _ => { unreachable("Expected RHS to be an identifier or number"); }
        }
        let field: VariableLookup = blank;
        if (!resolveFieldByName(structLookup, &fieldName, &field)) {
            return reportUnknownField(this, fieldName, structLookup, false);
        }
        let fieldState: TCState = field.typeState;
        assert(isSuccess(&fieldState), "Expected valid field type");
        return fieldState;
    } else if (isTuple(underlying)) {
        let tkn: Token = blank;
        match (&rhs.data) {
            &ExprData::Ident(_) => {
                return reportNonNumberAccessOnTuple(this, lhs, instanceType);
            }
            &ExprData::IntLit(_tkn) => {
                tkn = _tkn;
            }
            _ => { unreachable("Expected RHS to be an identifier or number"); }
        }
        let index = toU64(&tkn.content) as usize;
        let &Type::Tuple(elems) = underlying else {
            unreachable("underlying is tuple");
        };
        if (index >= elems.length) {
            return reportTupleIndexOutOfBounds(this, lhs, instanceType, index);
        }
        return TCState::Type(elems.elements[index]);
    } else {
        unreachable("MemberAccess expected Struct or Tuple as LHS");
    }
}

func checkIfInferIsNeeded(this: &TypeChecker, lhsID: usize, lhsState: &TCState, rhsID: usize, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    let lhsExpr: &ParsedExpr = at(&exprs, lhsID);
    let rhsExpr: &ParsedExpr = at(&exprs, rhsID);
    return checkIfInferIsNeeded(this, lhsExpr, lhsState, rhsExpr, rhsState, scopes);
}
func checkIfInferIsNeeded(this: &TypeChecker, lhsExpr: &ParsedExpr, lhsState: &TCState, rhsExpr: &ParsedExpr, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    if (isType(lhsState) && isType(rhsState)) {
        return TCState::Success;
    } else if (isType(lhsState) && !isType(rhsState)) {
        *rhsState = inferTypeOntoExpr(this, rhsExpr, getType(lhsState), scopes);
        return *rhsState;
    } else if (!isType(lhsState) && isType(rhsState)) {
        *lhsState = inferTypeOntoExpr(this, lhsExpr, getType(rhsState), scopes);
        return *lhsState;
    } else {
        return TCState::PleaseInfer;
    }
}

func inferPatternOntoExpr(this: &TypeChecker, expr: &ParsedExpr, pat: &ParsedPattern, scopes: &ScopeLookupList) -> TCState {
    match (pat.data) {
        Pattern::Wildcard => { todo_with_msg("inferPatternOntoExpr: Wildcard onto expr? Is this possible?"); },
        Pattern::Number(_) => { todo_with_msg("inferPatternOntoExpr: Wildcard onto expr? Is this possible?"); },
        Pattern::Rest => { todo_with_msg("inferPatternOntoExpr: Wildcard onto expr? Is this possible?"); },
        Pattern::Boolean(_) => { todo_with_msg("inferPatternOntoExpr: Wildcard onto expr? Is this possible?"); },
        Pattern::Null => { todo_with_msg("inferPatternOntoExpr: Wildcard onto expr? Is this possible?"); },
        Pattern::PatWithType(subpat, typeNode) => {
            let typeState = typeCheckTypeNode(this, typeNode);
            if (isError(&typeState)) return typeState;
            let type = getType(&typeState);
            return inferTypeOntoExpr(this, expr, type, scopes);
        }
        // FIXME: See related FIXME in tryInferTypeOntoExpr, we may be able to restore old semantics
        //        It's just:tm: more complicated now because we have recursive patterns instead of
        //        simple identifiers.
        Pattern::Ident(name) => { return TCState::PleaseInfer; },
        Pattern::Reference(subpat) => { }
        Pattern::Struct(name, subpats) => { }
        Pattern::Path(_, subpat) => { }
        _ => { }
    }
    emergencyPrint(this, pat.span);
    emergencyPrint(this, expr.span);
    unreachable("inferPatternOntoExpr: Exhaustive handling of patterns");
}

func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, exprID, typeID, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, expr, type, scopes, false);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, checkOnly);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), at(&types, typeID), scopes, checkOnly);
}

func tryInferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    if (isSuccess(&expr.typeState)) {
        let exprType: &Type = getType(&expr.typeState);
        if (!equals(exprType, type)) todo_with_msg("infer failed");
        return TCState::Type(type);
    }
    let tid = TCState::Invalid;
    match (&expr.data) {
        &ExprData::IntLit(value) => {
            if (isChar(type)) {
                if (!checkOnly) {
                    let l: String = getLocation(&value);
                    C::fprintf(stderr, "%s: %s: Using integer literal to initialize value of type char.\n",
                        l.buffer, WARN_STR);
                    drop(&l);
                }
                tid = TCState::Type(type);
            } else if (isInteger(type) || isFloat(type)) {
                tid = TCState::Type(type);
            } else if (isPointer(type)) {
                // REVIEW: This is... More than debatable?
                // Context requires a pointer, we have an integer literal.. Now this literal is type usize
                // Question: Is there ever a situation where we actually want this literal to be type ptr?
                tid = TCState::Type(wrap(Type::Prim(PrimType::Usize)));
            } else if (isBoolean(type)) {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    C::fprintf(stderr, "%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n",
                        l.buffer, ERR_STR, s.buffer);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return TCState::Error(ERROR_UNEXPECTED_LITERAL);
            } else if (isArray(type)) {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    C::fprintf(stderr, "%s: %s: Unexpected Literal! Expected array, found `%s`.\n",
                        l.buffer, ERR_STR, s.buffer);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return TCState::Error(ERROR_UNEXPECTED_LITERAL);
            } else {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    let t = toString(type);
                    C::fprintf(stderr, "%s: %s: Unexpected Literal! Expected value of type %s, found `%s`.\n",
                        l.buffer, ERR_STR, t.buffer, s.buffer);
                    drop(&t);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return TCState::Error(ERROR_UNEXPECTED_LITERAL);
            }
        }
        // &ExprData::StrLit(Token)
        // &ExprData::CharLit(Token)
        &ExprData::ArrayLit(context) => {
            match (type) {
                &Type::Array(under, size) => {
                    if (context.size == 0) {
                        if (size != context.elemLength) {
                            if (!checkOnly) {
                                let loc: String = toString(&expr.span);
                                C::fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                                    loc.buffer, ERR_STR, size, context.elemLength);
                                drop(&loc);
                                this.typeError = true;
                            }
                            return TCState::Error(ERROR_ARRAY_SIZE_MISMATCH);
                        }
                        let lastErrState = TCState::Invalid;
                        for (let i: usize = 0; i < context.elemLength; i = i + 1) {
                            tid = tryInferTypeOntoExpr(this, getElementAtIndex(&context, i), under, scopes, checkOnly);
                            if (isError(&tid)) lastErrState = tid;
                        }
                        if (!isInvalid(&lastErrState)) return lastErrState;
                    } else {
                        if (size != context.size) {
                            if (!checkOnly) {
                                let loc: String = toString(&expr.span);
                                C::fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                                    loc.buffer, ERR_STR, size, context.size);
                                drop(&loc);
                                this.typeError = true;
                            }
                            return TCState::Error(ERROR_ARRAY_SIZE_MISMATCH);
                        }
                        tid = tryInferTypeOntoExpr(this, getElementAtIndex(&context, 0), under, scopes, checkOnly);
                        if (isError(&tid)) return tid;
                    }
                    tid = TCState::Type(type);
                }
                _ => {
                    if (!checkOnly) {
                        let loc = toString(&expr.span);
                        let t = toString(type);
                        C::fprintf(stderr, "%s: %s: Expected expression of type %s, found array literal.\n", loc.buffer, ERR_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                    }
                    return TCState::Error(ERROR_TYPE_MISMATCH);
                }
            }
        }
        &ExprData::Ident(ident) => { tid = tryInferTypeOntoIdent(this, &ident, type, scopes, checkOnly); }
        &ExprData::Unary(unary) => { tid = tryInferTypeOntoUnary(this, expr.span, &unary, type, scopes, checkOnly); }
        &ExprData::Binary(binary) => { tid = tryInferTypeOntoBinary(this, &binary, type, scopes, checkOnly); }
        &ExprData::Call(call) => { tid = tryInferTypeOntoCall(this, &call, type, scopes, checkOnly); }
        // &ExprData::Sizeof(&ParsedTypeNode)
        // &ExprData::StructInit(StructExpr)
        // &ExprData::UnionInit(UnionExpr)
        // &ExprData::As(&ParsedExpr, &ParsedTypeNode)
        &ExprData::Null => {
            if (!isPointer(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                C::fprintf(stderr, "%s: %s: Can't use `null` to initialize value of type %s.\n",loc.buffer, ERR_STR, name.buffer);
                drop(&name);
                drop(&loc);
                this.typeError = true;
                return TCState::Error(ERROR_NULL_NON_PTR);
            }
            tid = TCState::Type(type);
        }
        &ExprData::Blank => {
            if (isPointer(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                C::fprintf(stderr, "%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n",
                    loc.buffer, ERR_STR, name.buffer);
                drop(&name);
                drop(&loc);
                this.typeError = true;
                return TCState::Error(ERROR_BLANK_FOR_NULL);
            } else if (isPrimitive(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                C::fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n",
                    loc.buffer, WARN_STR, name.buffer);
                drop(&name);
                drop(&loc);
            } else if (isUnion(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                C::fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s.\n",
                    loc.buffer, WARN_STR, name.buffer);
                drop(&name);
                drop(&loc);
            }
            tid = TCState::Type(type);
        }
        &ExprData::True => {
            if (!isBoolean(type)) {
                if (!checkOnly) {
                    let loc = toString(&expr.span);
                    let t = toString(type);
                    C::fprintf(stderr, "%s: %s: Expected expression of type %s, found `true`.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            tid = TCState::Type(type);
        }
        &ExprData::False => {
            if (!isBoolean(type)) {
                if (!checkOnly) {
                    let loc = toString(&expr.span);
                    let t = toString(type);
                    C::fprintf(stderr, "%s: %s: Expected expression of type %s, found `false`.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            tid = TCState::Type(type);
        }
        &ExprData::Tuple(exprElems) => {
            let &Type::Tuple(typeElems) = type else {
                if (!checkOnly) {
                    let loc = toString(&expr.span);
                    let t = toString(type);
                    C::fprintf(stderr, "%s: %s: Expected expression of type %s, found tuple.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            };
            if (typeElems.length != exprElems.length) {
                if (!checkOnly) {
                    let loc = toString(&expr.span);
                    C::fprintf(stderr, "%s: %s: Expected tuple with %llu elements, found %llu.\n", loc.buffer, ERR_STR, typeElems.length, exprElems.length);
                    drop(&loc);
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            for (let i: usize = 0; i < typeElems.length; i = i + 1) {
                let _expr = exprElems.elements[i];
                let _type = typeElems.elements[i];
                let state = tryInferTypeOntoExpr(this, _expr, _type, scopes, checkOnly);
                if (isError(&state)) return state;
            }
            tid = TCState::Type(type);
        }
        unknown => {
            let loc = toString(&expr.span);
            C::fprintf(stderr, "%s %s: tryInferTypeOntoExpr: Unknown tag %hhu!\n", FATAL_STR, loc.buffer, tag(unknown));
            C::exit(2);
        }
    }
    if (!checkOnly) {
        (*expr).typeState = tid;
    }
    return tid;
}

func tryInferTypeOntoUnary(this: &TypeChecker, span: Span, unary: &UnaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let tid = TCState::Invalid;
    match (unary) {
        &UnaryExpr::Deref(subExpr) => {
            let newType: &Type = wrap(Type::Ptr(type));
            tid = tryInferTypeOntoExpr(this, subExpr, newType, scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = TCState::Type(type);
        }
        &UnaryExpr::Ref(subExpr) => {
            match (type) {
                &Type::Ptr(under) => {
                    tid = tryInferTypeOntoExpr(this, subExpr, under, scopes, checkOnly);
                    if (isError(&tid)) return tid;
                    tid = TCState::Type(type);
                }
                _ => {
                    if (!checkOnly) {
                        let loc: String = toString(&span);
                        let t: String = toString(type);
                        C::fprintf(stderr, "%s: %s: Expected expression of type %s, found reference.\n", loc.buffer, ERR_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                        this.typeError = true;
                    }
                    return TCState::Error(ERROR_TYPE_MISMATCH);
                }
            }
        }
        &UnaryExpr::Negate(subExpr) => {
            if (!isSignedInteger(type) && !isFloat(type)) {
                if (!checkOnly) {
                    let loc: String = toString(&span);
                    let t: String = toString(type);
                    C::fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    this.typeError = true;
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, subExpr, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
            assert(isType(&tid), "infer non-error expected to be a type");
            let subType: &Type = getType(&tid);
            assert(equals(subType, type), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
            tid = TCState::Type(type);
        }
        &UnaryExpr::Not(subExpr) => {
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            tid = tryInferTypeOntoExpr(this, subExpr, boolType, scopes, checkOnly);
            if (isError(&tid)) return tid;
            todo_with_msg("unary not infer");
        }
        _ => { unreachable("Exhaustive handling of ops in tryInferTypeOntoUnary"); }
    }
    return tid;
}

func tryInferTypeOntoBinary(this: &TypeChecker, binary: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(binary, &lhs, &rhs);
    let tid = TCState::Invalid;
    if (isArithmetic(binary) || isBitwise(binary)) {
        tid = tryInferTypeOntoExpr(this, lhs, type, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = tryInferTypeOntoExpr(this, rhs, type, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = TCState::Type(type);
    } else if (isComparison(binary)) {
        // Assuming that neither side has a type (otherwise typeCheckExprComparison would've handled the infer step)
        // So all that's left is whack things like `1 == 1`, for which we blindly try to infer usize onto both sides
        let usizeType = wrap(Type::Prim(PrimType::Usize));
        tid = tryInferTypeOntoExpr(this, lhs, usizeType, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = tryInferTypeOntoExpr(this, rhs, usizeType, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = TCState::Type(type);
    } else if (tag(binary) == comptime tag(&BinaryExpr::Dot)) {
        tid = tryInferTypeOntoMemberAccess(this, binary, type, scopes, checkOnly);
    } else if (tag(binary) == comptime tag(&BinaryExpr::Path)) {
        tid = tryInferTypeOntoPathAccess(this, binary, type, scopes, checkOnly);
    } else {
        todo_with_msg("inferTypeOntoExpr for non-arith non-comp binary");
    }
    return tid;
}

func tryInferTypeOntoIdent(this: &TypeChecker, ident: &IdentExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let var: VariableLookup = blank;
    let tid = TCState::Invalid;
    if (resolveVariableByName(this.currentModule, &ident.name, scopes, &var)) {
        unreachable("tryInferTypeOntoIdent: New let-statements prevent variables from ever being unresolved");
        assert(wantsInfer(&var.typeState), "Ident has no type, but variable doesn't want infer");
        tid = TCState::Type(type);
        var.typeState = tid;
        // FIXME: This is waiting for corruption to happen, var.globalID now points into the pattern list
        let stmt = at(&stmts, var.globalID);
        match (stmt.data) {
            StmtData::VarDecl(decl) => {
                // FIXME: Maybe try making this work for `let <pat> = <expr>;` aswell?
                //        Problem is that we don't keep track of individual sub-expressions
                //        aka in (a, b) = (5, 12) both a and b point towards (5, 12) instead
                //        of 5 and 12 individually
                tid = tryInferTypeOntoExpr(this, decl.expr, type, scopes, checkOnly);
            }
            _ => { unreachable("VariableLookup points to non-VarDecl"); }
        }
        if (isError(&tid)) {
            let loc = toString(&ident.name.span);
            let name = toString(&ident.name.content);
            let typeName = toString(type);
            C::fprintf(stderr, "%s: %s: Variable `%s` inferred to be of type %s here.\n", loc.buffer, NOTE_STR, name.buffer, typeName.buffer);
            drop(&typeName);
            drop(&name);
            drop(&loc);
        }
        stmt.typeState = tid;
    } else if (isFunction(type)) {
        let config = MLConfig {
            checkSelf: true,
            checkImport: true,
            checkModule: false,
            checkParent: true,
            allowData: false,
        };
        let functions = resolveAllFunctionsWithSignature(this.currentModule, &ident.name, type, config);
        if (functions.length == 0) {
            config.allowData = true;
            functions = resolveAllFunctionsWithSignature(this.currentModule, &ident.name, type, config);
            if (functions.length == 0) {
                if (checkOnly) {
                    tid = TCState::Error(ERROR_NO_SUCH_FUNCTION);
                } else {
                    let all = resolveFunctionByName(this.currentModule, &ident.name);
                    tid = reportNoFunctionCallCandidate(this, ident.name, type, &all);
                    drop(&all);
                }
            } else if (functions.length == 1) {
                let f = at(&functions, 0);
                if (!checkOnly) {
                    ident.origID = f.globalID;
                }
                tid = f.fnType;
            } else {
                tid = TCState::PleaseInfer;
            }
        } else if (functions.length == 1) {
            let f = at(&functions, 0);
            if (!checkOnly) {
                ident.origID = f.globalID;
            }
            tid = f.fnType;
        } else {
            tid = TCState::PleaseInfer;
        }
        drop(&functions);
    } else {
        return reportUnknownIdentifier(this, &ident.name);
    }
    if (isType(&tid)) {
        ident.type = getType(&tid);
    }
    return tid;
}

func tryInferTypeOntoCall(this: &TypeChecker, expr: &CallExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let params: TypeList = blank;
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let state = &(*at(&expr.args, i)).typeState;
        let typ = wrap(Type::Unknown);
        if (isType(state)) typ = getType(state);
        push(&params, typ);
    }
    let fnType = wrap(Type::Func(params, type, blank));
    let baseState = tryInferTypeOntoExpr(this, expr.base, fnType, scopes, checkOnly);
    if (isError(&baseState)) return baseState;
    if (wantsInfer(&baseState)) {
        return reportFunctionCallTooManyOptions(this, expr);
    }
    assert(isType(&baseState), "tryInferOntoCall: Base is not a type");
    let baseFunc = getType(&baseState);
    assert(isFunction(baseFunc), "tryInferTypeOntoCall: Base is not a function");
    let state: TCState = TCState::Success;
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let p = getParam(baseFunc, i);
        let s1 = tryInferTypeOntoExpr(this, *at(&expr.args, i), p, scopes, checkOnly);
        if (isError(&s1)) {
            state = s1;
        }
    }
    if (!isSuccess(&state)) {
        todo_with_msg("infer arg failed");
    }
    if (checkOnly) return TCState::Success;
    expr.retType = type;
    return TCState::Type(type);
}

func tryInferTypeOntoMemberAccess(this: &TypeChecker, expr: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            let name = ident.name;
            let structs = resolveAllStructsWithField(this.currentModule, &name, type);
            if (structs.length == 0) {
                return reportMemberAccessNoOptions(this, lhs.span);
            } else if (structs.length == 1) {
                let struct = at(&structs, 0);
                let state = tryInferTypeOntoExpr(this, lhs, struct.type, scopes, checkOnly);
                if (isError(&state)) return state;
                if (checkOnly) return TCState::Success;
                return TCState::Type(type);
            } else {
                if (!checkOnly) {
                    return reportMemberAccessTooManyOptions(this, lhs.span, &structs);
                }
                return TCState::Error(ERROR_TYPE_MISMATCH);
            }
        }
        _ => { }
    }
    unreachable("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess"); 
}

func tryInferTypeOntoPathAccess(this: &TypeChecker, expr: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState = lhs.typeState;
    if (!isSuccess(&lhsState)) return lhsState;
    if (!isType(&lhsState)) return lhsState;
    let lhsType = getType(&lhsState);
    let lookup: &ModuleLookup = null;
    match (lhsType) {
        &Type::Module(decl) => { lookup = getModuleByGlobalID(this.currentModule, getID(decl)); }
        _ => { unreachable("LHS of BIN_MODULE is not of type module!"); }
    }
    let tid = TCState::Invalid;
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            assert(isFunction(type), "Can only try to infer functions onto module identifiers for now");
            let functions = resolveAllFunctionsWithSignature(lookup, &ident.name, type);
            if (functions.length == 0) {
                if (checkOnly) {
                    tid = TCState::Error(ERROR_NO_SUCH_FUNCTION);
                } else {
                    let all = resolveFunctionByName(lookup, &ident.name);
                    tid = reportNoFunctionCallCandidate(this, ident.name, type, &all);
                    drop(&all);
                }
            } else if (functions.length == 1) {
                let f = at(&functions, 0);
                if (!checkOnly) {
                    ident.origID = f.globalID;
                }
                tid = f.fnType;
            } else {
                tid = TCState::PleaseInfer;
            }
            rhs.typeState = tid;
            if (isType(&tid)) {
                ident.type = getType(&tid);
            }
            drop(&functions);
        }
        _ => { unreachable("Exhaustive handling of possibilities in tryInferTypeOntoModuleAccess"); }
    }
    return tid;
}

func typeCheckExprArithmetic(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    assert(isArithmetic(expr), "Expr expected to be arithmetic");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let lhsPointer: bool = false;
    let rhsPointer: bool = false;
    if (isType(&lhsState)) if (isPointer(getType(&lhsState))) lhsPointer = true;
    if (isType(&rhsState)) if (isPointer(getType(&rhsState))) rhsPointer = true;
    if (lhsPointer || rhsPointer) {
        match (expr) {
            &BinaryExpr::Plus(..) => { },
            &BinaryExpr::Sub(..) => { },
            other => { return reportInvalidPointerArithmetics(this, binOpAsStr(other), lhs.span, rhs.span); }
        }
    }
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let resultState = TCState::Invalid;
    if (equals(lhsType, rhsType)) {
        comptime p = tag(&BinaryExpr::Plus);
        comptime s = tag(&BinaryExpr::Sub);
        if (isChar(lhsType) && tag(expr) != p && tag(expr) != s) {
            return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
        }
        if (isStruct(lhsType) || isArray(lhsType)) {
            return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
        } else if (isPointer(lhsType)) {
            resultState = TCState::Type(wrap(Type::Prim(PrimType::Usize)));
        } else {
            resultState = TCState::Type(lhsType);
        }
    } else if (isPointer(lhsType) && isInteger(rhsType)) {
        match (rhsType) {
            &Type::Prim(PrimType::Usize) => { resultState = lhsState; }
            _ => {
                let err = reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
                let loc = toString(&rhs.span);
                C::fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
                drop(&loc);
                return err;
            }
        }
    } else if (isInteger(lhsType) && isPointer(rhsType)) {
        match (lhsType) {
            &Type::Prim(PrimType::Usize) => { resultState = rhsState; }
            _ => {
                let err = reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
                let loc = toString(&lhs.span);
                C::fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
                drop(&loc);
                return err;
            }
        }
    } else {
        return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
    }
    return resultState;
}

func typeCheckExprComparison(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    assert(isComparison(expr), "Expr expected to be comparison");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportBinaryTypeMismatch(this, 
            binOpAsStr(expr),
            lhs.span, lhsType,
            rhs.span, rhsType,
        );
    }
    if (isStruct(lhsType) || isStruct(rhsType)
        || isArray(lhsType) || isArray(rhsType)) {
        todo_with_msg("report error, can't compare structs or arrays using == or similar.");
    }
    return TCState::Type(wrap(Type::Prim(PrimType::Bool)));
}

func typeCheckTypeNode(this: &TypeChecker, typeNode: &ParsedTypeNode) -> TCState {
    if (typeNode.ignored) return TCState::Success;
    if (isSuccess(&typeNode.typeState)) return typeNode.typeState;
    let tid: &Type = null;
    if (typeNode.kind == PARSED_TYPE_FUNC) {
        let retState: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&retState)) return retState;
        let params: TypeList = blank;
        let error = TCState::Invalid;
        let is_variadic = false;
        for (let i: usize = 0; i < typeNode.fnParams.length; i = i + 1) {
            let state = typeCheckTypeNode(this, *at(&typeNode.fnParams, i));
            if (isError(&state)) {
                error = state;
            } else {
                let typ = getType(&state);
                if (isVariadic(typ)) is_variadic = true;
                push(&params, typ);
            }
        }
        if (isError(&error)) return error;
        tid = wrap(Type::Func(params, getType(&retState), FuncAttr {
            isVariadic: is_variadic
        }));
    } else if (typeNode.kind == PARSED_TYPE_REF) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = wrap(Type::Ptr(getType(&under)));
    } else if (typeNode.kind == PARSED_TYPE_ARRAY) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = wrap(Type::Array(getType(&under), typeNode.arraySize));
    } else if (typeNode.kind == PARSED_TYPE_IDENT) {
        let name: Token = typeNode.nameTkn;
        let typeLookup: TypeLookup = blank;
        if (!resolveTypeByName(this.currentModule, &name.content, &typeLookup)) {
            let loc: String = getLocation(&name);
            let _n: String = toString(&name.content);
            C::fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
            let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &name.content);
            return reportUnknownType(this, null, name, alternatives);
        }
        if (isStruct(&typeLookup)) {
            let structLookup: &StructLookup = asStruct(&typeLookup);
            tid = structLookup.type;
            assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
        } else if (isUnion(&typeLookup)) {
            let unionLookup: &UnionLookup = asUnion(&typeLookup);
            tid = unionLookup.type;
            assert(isUnion(tid), "Union Lookup links to non-Union typeNode");
        } else {
            unreachable("Exhaustive handling of TypeLookup kinds in typeCheckTypeNode");
        }
    } else if (typeNode.kind == PARSED_TYPE_MODULE) {
        let _orig = typeNode;
        let moduleLookup: &ModuleLookup = null;
        let name = typeNode.nameTkn;
        if (!resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
            return reportUnknownModule(this, name);
        }
        while (true) {
            let sub = typeNode.underlyingID;
            if (sub.underlyingID == null) {
                let lookup: TypeLookup = blank;
                if (!resolveTypeByName(moduleLookup, &sub.nameTkn.content, &lookup)) {
                    return reportUnknownType(this, moduleLookup, sub.nameTkn, blank);
                }
                if (isStruct(&lookup)) {
                    let structLookup: &StructLookup = asStruct(&lookup);
                    tid = structLookup.type;
                    assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
                    break;
                } else if (isUnion(&lookup)) {
                    let unionLookup: &UnionLookup = asUnion(&lookup);
                    tid = unionLookup.type;
                    assert(isUnion(tid), "Union Lookup links to non-Union typeNode");
                    break;
                } else {
                    todo_with_msg("module::<typeNode> with typeNode != struct && != union");
                }
            } else {
                name = sub.nameTkn;
                let newModule: &ModuleLookup = null;
                if (!resolveModuleByName(moduleLookup, &name, &newModule)) {
                    return reportUnknownSubmodule(this, moduleLookup, name);
                }
                let modType = wrap(Type::Module(at(&modules, newModule.globalID)));
                typeNode.typeState = TCState::Type(modType);
                typeNode = sub;
                moduleLookup = newModule;
            }
        }
        typeNode = _orig;
    } else if (typeNode.kind == PARSED_TYPE_VARIADIC) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = wrap(Type::Variadic(getType(&under)));
    } else if (typeNode.kind == PARSED_TYPE_TUPLE) {
        let elems: TypeList = blank;
        let error = TCState::Invalid;
        for (let i: usize = 0; i < typeNode.fnParams.length; i = i + 1) {
            let state = typeCheckTypeNode(this, *at(&typeNode.fnParams, i));
            if (isError(&state)) {
                error = state;
            } else {
                push(&elems, getType(&state));
            }
        }
        if (isError(&error)) return error;
        tid = wrap(Type::Tuple(elems));
    } else if (typeNode.kind == PARSED_TYPE_BUILTIN) {
        let id: usize = getID(typeNode);
        let prim: PrimType = PrimType::None;
        if (id == PARSED_TYPE_NONE) prim = PrimType::None;
        else if (id == PARSED_TYPE_ANY) prim = PrimType::Any;
        else if (id == PARSED_TYPE_I8) prim =PrimType::I8;
        else if (id == PARSED_TYPE_I16) prim =PrimType::I16;
        else if (id == PARSED_TYPE_I32) prim =PrimType::I32;
        else if (id == PARSED_TYPE_I64) prim =PrimType::I64;
        else if (id == PARSED_TYPE_U8) prim =PrimType::U8;
        else if (id == PARSED_TYPE_U16) prim =PrimType::U16;
        else if (id == PARSED_TYPE_U32) prim =PrimType::U32;
        else if (id == PARSED_TYPE_U64) prim =PrimType::U64;
        else if (id == PARSED_TYPE_USIZE) prim =PrimType::Usize;
        else if (id == PARSED_TYPE_BOOL) prim =PrimType::Bool;
        else if (id == PARSED_TYPE_CHAR) prim =PrimType::Char;
        else if (id == PARSED_TYPE_F32) prim =PrimType::F32;
        else if (id == PARSED_TYPE_F64) prim =PrimType::F64;
        else {
            unreachable("Exhaustive handling of parsed types in typeCheckTypeNode");
        }
        tid = wrap(Type::Prim(prim));
    } else {
        todo_with_msg("unknown typeNode kind");
    }
    let state: TCState = TCState::Type(tid);
    typeNode.typeState = state;
    return state;
}

func newTypeChecker() -> TypeChecker {
    return TypeChecker {
        comptimeDepth: 0,
        currentModule: null,
        currentFunction: null,
        lookup: blank,
        typeError: false,
    };
}
