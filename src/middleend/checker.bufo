import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

@os(WINDOWS) import "winapi/structs.bufo";
@os(WINDOWS) import "winapi/functions.bufo";

comptime ERROR_INVALID                          : usize = 0;
comptime ERROR_NO_SUCH_MODULE                   : usize = 1;
comptime ERROR_NO_SUCH_IDENTIFIER               : usize = 2;
comptime ERROR_NO_SUCH_FUNCTION                 : usize = 3;
comptime ERROR_NO_SUCH_METHOD                   : usize = 4;
comptime ERROR_NO_SUCH_TYPE                     : usize = 5;
comptime ERROR_USE_BEFORE_DECLARATION           : usize = 6;
comptime ERROR_FIELD_COUNT_MISMATCH             : usize = 7;
comptime ERROR_INDEXED_TYPE_MISMATCH            : usize = 8;
comptime ERROR_UNEXPECTED_LITERAL               : usize = 9;
comptime ERROR_ARRAY_SIZE_MISMATCH              : usize = 10;
comptime ERROR_TYPE_MISMATCH                    : usize = 11;
comptime ERROR_INVALID_POINTER_ARITHMETIC       : usize = 12;
comptime ERROR_DUPLICATE_PARAMETER              : usize = 13;
comptime ERROR_DUPLICATE_FIELD                  : usize = 14;
comptime ERROR_UNKNOWN_FIELD                    : usize = 15;
comptime ERROR_DUPLICATE_FUNCTION               : usize = 16;
comptime ERROR_NO_CALL_CANDIDATE                : usize = 17;
comptime ERROR_VARIABLE_REDECLARATION           : usize = 18;
comptime ERROR_RECURSIVE_TYPE                   : usize = 19;
comptime ERROR_DUPLICATE_METHOD                 : usize = 20;
comptime ERROR_BLANK_FOR_NULL                   : usize = 21;
comptime ERROR_NON_PRIMITIVE_CAST               : usize = 22;
comptime ERROR_INDEXED_ACCESS_ON_NON_ARRAY      : usize = 23;
comptime ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT: usize = 24;
comptime ERROR_ANY_DEREF                        : usize = 25;
comptime ERROR_MEMBER_ACCESS_NON_STRUCT         : usize = 26;
comptime ERROR_MEMBER_ACCESS_NO_OPTIONS         : usize = 27;
comptime ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS   : usize = 28;
comptime ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS   : usize = 29;
comptime ERROR_CALL_TO_NON_FUNCTION             : usize = 30;
comptime ERROR_UNKNOWN_SUBMODULE                : usize = 31;
comptime ERROR_MODULE_ACCESS_NON_MODULE         : usize = 32;
comptime ERROR_DEREF_NON_POINTER                : usize = 33;
comptime ERROR_DUPLICATE_UNION_VARIANT           : usize = 34;
comptime ERROR_DUPLICATE_UNION_NAME              : usize = 35;

comptime TCSTATE_INVALID: usize = 0;
comptime TCSTATE_ERROR: usize = 1;
comptime TCSTATE_PLEASE_INFER: usize = 2;
comptime TCSTATE_TYPE: usize = 3;
struct TCState {
    kind: usize;
    error: usize;
    typ: &Type;
    name: Token;
}

func equals(this: &TCState, other: &TCState) -> bool {
    todo_with_msg("TCState.equals");
}

func isInvalid(this: &TCState) -> bool {
    return this.kind == TCSTATE_INVALID;
}
func wantsInfer(this: &TCState) -> bool {
    return this.kind == TCSTATE_PLEASE_INFER;
}
func isCriticalError(this: &TCState) -> bool {
    if (!isError(this)) return false;
    let err: usize = getError(this);
    return err == ERROR_NO_SUCH_IDENTIFIER
        || err == ERROR_NO_SUCH_FUNCTION
        || err == ERROR_NO_SUCH_METHOD
        || err == ERROR_DUPLICATE_FUNCTION
        || err == ERROR_DUPLICATE_METHOD
        || err == ERROR_DUPLICATE_FIELD;
}
func isError(this: &TCState) -> bool {
    return this.kind == TCSTATE_ERROR;
}

func isSuccess(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE;
}

func isType(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE;
}

func getType(this: &TCState) -> &Type {
    if (!isType(this)) {
        fprintf(stderr, "ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.typ;
}
func getError(this: &TCState) -> usize {
    if (!isError(this)) {
        fprintf(stderr, "ERROR: getError(&TCState) called on non-error TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.error;
}

func newTCStateSuccess() -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
    };
}

func newTCStateType(typ: &Type) -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: typ,
    };
}

func newTCStateFailure(error: usize) -> TCState {
    return TCState {
        kind: TCSTATE_ERROR,
        error: error,
    };
}

func newTCStatePleaseInfer() -> TCState {
    return TCState {
        kind: TCSTATE_PLEASE_INFER,
    };
}

struct TypeChecker {
    isComptimeContext: bool;
    currentModule: &ModuleLookup;
    currentFunction: &FunctionLookup;
    lookup: Lookup;
    typeError: bool;
}

func reportTypeMismatch(this: &TypeChecker, span: Span, expected: &Type, got: &Type) -> TCState {
    trace("TypeChecker.reportTypeMismatch");
    let loc: String = toString(&span);
    let typ1: String = toString(expected);
    let typ2: String = toString(got);
    fprintf(stderr, "%s: %s: Type mismatch! Expected type %s, found type %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportBinaryTypeMismatch(this: &TypeChecker, op: usize, lhsSpan: Span, lhsType: &Type, rhsSpan: Span, rhsType: &Type) -> TCState {
    trace("TypeChecker.reportBinaryTypeMismatch");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    let loc1: String = toString(&lhsSpan);
    let loc2: String = toString(&rhsSpan);
    let typ1: String = toString(lhsType);
    let typ2: String = toString(rhsType);
    fprintf(stderr, "%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n",
        loc.buffer, ERR_STR, typ1.buffer, binOpAsStr(op), typ2.buffer);
    fprintf(stderr, "%s: %s: LHS has type %s.\n", loc1.buffer, NOTE_STR, typ1.buffer);
    fprintf(stderr, "%s: %s: RHS has type %s.\n", loc2.buffer, NOTE_STR, typ2.buffer);
    drop(&typ2);
    drop(&typ1);
    drop(&loc2);
    drop(&loc1);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportInvalidPointerArithmetics(this: &TypeChecker, op: usize, lhsSpan: Span, rhsSpan: Span) -> TCState {
    trace("TypeChecker.reportInvalidPointerArithmetics");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    fprintf(stderr, "%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n",
        loc.buffer, ERR_STR, binOpAsStr(op));
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INVALID_POINTER_ARITHMETIC);
}

func reportDuplicateField(this: &TypeChecker, fieldToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateField");
    let duplLoc: String = toString(&fieldToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&fieldToken.content);
    fprintf(stderr, "%s: %s: Field redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FIELD);
}

func reportDuplicateParameter(this: &TypeChecker, paramToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateParameter");
    let duplLoc: String = toString(&paramToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&paramToken.content);
    fprintf(stderr, "%s: %s: Parameter redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Parameter `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_PARAMETER);
}

func reportUnknownField(this: &TypeChecker, name: Token, decl: &StructLookup) -> TCState {
    trace("TypeChecker.reportUnknownField");
    let errLoc: String = toString(&name.span);
    let declLoc: String = toString(&decl.name.span);
    let strukt: String = toString(&decl.name.content);
    let field: String = toString(&name.content);
    fprintf(stderr, "%s: %s: Attempted to access unknown field `%s` of instance of struct %s.\n", errLoc.buffer, ERR_STR, field.buffer, strukt.buffer);
    fprintf(stderr, "%s: %s: Struct %s is declared here.\n", declLoc.buffer, NOTE_STR, strukt.buffer);
    drop(&field);
    drop(&strukt);
    drop(&declLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_UNKNOWN_FIELD);
}
func reportUnknownType(this: &TypeChecker, mod: &ModuleLookup, name: Token, alternatives: TypeLookupList) -> TCState {
    let loc: String = getLocation(&name);
    let _n: String = toString(&name.content);
    if (mod != null) {
        let mod = at(&modules, mod.globalID);
        let _n1 = toString(&mod.name.content);
        let loc1 = toString(&mod.span);
        fprintf(stderr, "%s: %s: Module `%s` does not contain any types named `%s`.\n", loc.buffer, ERR_STR, _n1.buffer, _n.buffer);
        fprintf(stderr, "%s: %s: Module declared here.\n", loc1.buffer, NOTE_STR);
        drop(&loc1);
        drop(&_n1);
    } else {
        fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &TypeLookup = at(&alternatives, i);
            if (isStruct(t)) {
                let s: &StructLookup = asStruct(t);
                let loc: String = getLocation(&s.name);
                fprintf(stderr, "%s: %s: A struct with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
                drop(&loc);
            }
        }
    }
    drop(&_n);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_TYPE);
}

func reportDuplicateFunction(this: &TypeChecker, f1: &FunctionLookup, f2: &FunctionLookup) -> TCState {
    trace("TypeChecker.reportDuplicateFunction");
    let errLoc: String = toString(&f1.name.span);
    let duplLoc: String = toString(&f2.name.span);
    let name: String = toString(&f1.name.content);
    let typ = toString(getType(&f1.fnType));
    fprintf(stderr, "%s: %s: Function redeclaration.\n", errLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: A function named `%s` with the signature %s is already declared here.\n", duplLoc.buffer, ERR_STR, name.buffer, typ.buffer);
    drop(&typ);
    drop(&name);
    drop(&duplLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FUNCTION);
}

func reportNoFunctionCallCandidate(this: &TypeChecker, callExpr: &ParsedExpr, fnType: &Type, functions: &FunctionLookupList) -> TCState {
    trace("TypeChecker.reportNoFunctionCallCandidate");
    assert(callExpr.kind == EXPR_NAME, "reportNoFunctionCallCandidate: Expected expr to be a call");
    let loc: String = toString(&callExpr.origToken.span);
    let name: String = toString(&callExpr.origToken.content);
    let typ = toString(fnType);
    fprintf(stderr, "%s: %s: No function overload fits the provided context for call to function `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    fprintf(stderr, "%s: %s: Context requires an overload of the form %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    assert(functions.length != 0, "reportNoFunctionCallCandidate: Expected at least one declaration");
    if (*flags.verbose) {
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f: &FunctionLookup = at(functions, i);
            let loc: String = toString(&f.name.span);
            let typ = toString(getType(&f.fnType));
            fprintf(stderr, "%s: %s: Overload %s declared here.\n", loc.buffer, NOTE_STR, typ.buffer);
            drop(&typ);
            drop(&loc);
        }
    } else {
        let is = "are";
        let ol = "overloads";
        let it = "them";
        if (functions.length == 1) {
            is = "is";
            ol = "overload";
            it = "it";
        }
        fprintf(stderr, "%s: %s: There %s %llu possible %s. Re-run with the --verbose flag to see %s.\n",
                loc.buffer, NOTE_STR, is, functions.length, ol, it);
    }
    drop(&typ);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_CALL_CANDIDATE);
}

func reportVariableRedeclaration(this: &TypeChecker, newDecl: Token, oldDecl: Token) -> TCState {
    trace("TypeChecker.reportVariableRedeclaration");
    let newLoc: String = toString(&newDecl.span);
    let oldLoc: String = toString(&oldDecl.span);
    let name: String = toString(&newDecl.content);
    fprintf(stderr, "%s: %s: Variable redeclaration.\n", newLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` already declared here.\n", oldLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&oldLoc);
    drop(&newLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_VARIABLE_REDECLARATION);
}

func reportRecursiveType(this: &TypeChecker, checked: &TypeLookup, cycle: &TypeLookupList) -> TCState {
    trace("TypeChecker.reportRecursiveType");
    let loc: String = getLocation(checked);
    let name: String = getName(checked);
    fprintf(stderr, "%s: %s: Recursive type %s.\n", loc.buffer, ERR_STR, name.buffer);
    assert(cycle.length >= 1, "Cycle is empty");
    for (let i: usize = 1; i < cycle.length; i = i + 1) {
        loc = getLocation(at(cycle, i));
        name = getName(at(cycle, i));
        fprintf(stderr, "%s: %s: Chain of recursion also includes type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    }
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RECURSIVE_TYPE);
}

func reportNonPrimitiveCast(this: &TypeChecker, span: Span, from: &Type, to: &Type) -> TCState {
    trace("TypeChecker.reportNonPrimitiveCast");
    let loc: String = toString(&span);
    let typ1: String = toString(from);
    let typ2: String = toString(to);
    fprintf(stderr, "%s: %s: Non primitive cast from type %s to %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NON_PRIMITIVE_CAST);
}

func reportIndexedAccessOnNonArray(this: &TypeChecker, span: Span, typ: &Type) -> TCState {
    trace("TypeChecker.reportIndexedAccessOnNonArray");
    let loc: String = toString(&span);
    let name: String = toString(typ);
    fprintf(stderr, "%s: %s: Indexed Access is only supported for arrays.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Expression has type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
}

func reportRuntimeValueInComptimeContext(this: &TypeChecker, ident: Token, var: &VariableLookup) -> TCState {
    trace("TypeChecker.reportRuntimeValueInComptimeContext");
    let loc = toString(&ident.span);
    let otherLoc = toString(&var.name.span);
    let name = toString(&ident.content);
    fprintf(stderr, "%s: %s: Variables declared with `let` can't be used in a comptime context.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` is declared here.\n", otherLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&otherLoc);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT);
}

func reportAnyDereference(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    trace("TypeChecker.reportAnyDereference");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Can't dereference expression of type Any.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_ANY_DEREF);
}

func reportMemberAccessOnNonStruct(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    trace("TypeChecker.reportMemberAccessOnNonStruct");
    let loc = toString(&expr.span);
    let t = toString(instance);
    fprintf(stderr, "%s: %s: The Dot-Operator is not defined for values of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_NON_STRUCT);
}

func reportMemberAccessNoOptions(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    trace("TypeChecker.reportMemberAccessNoOptions");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_NO_OPTIONS);
}

func reportMemberAccessTooManyOptions(this: &TypeChecker, expr: &ParsedExpr, structs: &StructLookupList) -> TCState {
    trace("TypeChecker.reportMemberAccessTooManyOptions");
    assert(structs.length > 0);
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    for (let i: usize = 0; i < structs.length; i = i + 1) {
        let s = at(structs, i);
        let l = toString(&s.name.span);
        let n = toString(&s.name.content);
        fprintf(stderr, "%s: %s: Context allows struct %s to be used.\n", l.buffer, NOTE_STR, n.buffer);
        drop(&n);
        drop(&l);
    }
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS);
}

func reportFunctionCallTooManyOptions(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    trace("TypeChecker.reportFunctionCallTooManyOptions");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which function to call.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS);
}

func reportCallToNonFunction(this: &TypeChecker, span: Span, base: &Type) -> TCState {
    trace("TypeChecker.reportCallToNonFunction");
    let loc = toString(&span);
    let typ = toString(base);
    fprintf(stderr, "%s: %s: Can't call expression of type %s.\n", loc.buffer, ERR_STR, typ.buffer);
    fprintf(stderr, "%s: %s: Currently, all variables (including global variables) shadow functions.\n", loc.buffer, NOTE_STR);
    fprintf(stderr, "%s: %s: This is a known limitation and will be fixed soon.\n", loc.buffer, NOTE_STR);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_CALL_TO_NON_FUNCTION);
}

func reportArgumentCountMismatch(this: &TypeChecker, span: Span, base: &Type, args: usize) -> TCState {
    trace("TypeChecker.reportArgumentCountMismatch");
    let loc = toString(&span);
    let typ = toString(base);
    let s = "arguments";
    let c = base.fnParams.length;
    if (c == 1) s = "argument";
    let w = "were";
    if (args == 1) w = "was";
    fprintf(stderr, "%s: %s: Call expects %llu %s, but %llu %s provided.\n", loc.buffer, ERR_STR, c, s, args, w);
    fprintf(stderr, "%s: %s: Call expression has type %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_CALL_TO_NON_FUNCTION);
}

func reportUnknownSubmodule(this: &TypeChecker, mod: &ModuleLookup, name: Token) -> TCState {
    trace("TypeChecker.reportUnknownSubmodule");
    let loc = toString(&name.span);
    let _mod = at(&modules, mod.globalID);
    let orig = toString(&_mod.span);
    let _origName = toString(&_mod.name.content);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: Module `%s` does not contain any submodules named `%s`.\n", loc.buffer, ERR_STR, _origName.buffer, _name.buffer);
    fprintf(stderr, "%s: %s: Module declared here.\n", orig.buffer, NOTE_STR);
    drop(&_name);
    drop(&_origName);
    drop(&orig);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_UNKNOWN_SUBMODULE);
}
func reportUnknownModule(this: &TypeChecker, name: Token) -> TCState {
    let loc = toString(&name.span);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: Use of undeclared module `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_MODULE);
}
func reportModuleAccessOfNonModule(this: &TypeChecker, span: Span, name: Token, typ: TypeLookup) -> TCState {
    let loc = toString(&span);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: `%s` is not a module, so the `::` operator cannot be applied.\n", loc.buffer, ERR_STR, _name.buffer);
    if (typ.kind != TYPE_LOOKUP_INVALID) {
        let _loc = getLocation(&typ);
        fprintf(stderr, "%s: %s: Struct declared here.\n", _loc.buffer, NOTE_STR);
        drop(&_loc);
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MODULE_ACCESS_NON_MODULE);
}
func reportDuplicateVariant(this: &TypeChecker, orig: &ParsedUnionVariant, dupl: &UnionVariantLookup) -> TCState {
    trace("TypeChecker.reportDuplicateVariant");
    let duplLoc: String = toString(&orig.span);
    let origLoc: String = toString(&dupl.global.span);
    let name: String = toString(&orig.name.content);
    fprintf(stderr, "%s: %s: Union Variant redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variant `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_UNION_VARIANT);
}
func reportDuplicateNameInUnion(this: &TypeChecker, variant: &ParsedUnionVariant, first: &Token, dupl: &Token) -> TCState {
    trace("TypeChecker.reportDuplicateNameInUnion");
    let duplLoc: String = toString(&first.span);
    let origLoc: String = toString(&dupl.span);
    let name: String = toString(&first.content);
    fprintf(stderr, "%s: %s: Union Variant already contains a field with that name.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_UNION_NAME);
}

func emergencyPrint(this: &TypeChecker, where: Span) {
    let t: Token = Token {
        span: where,
        content: newSubStrOfStrLit(""),
        kind: TOKEN_EOF
    };
    printf("%s\n", getLocation(&t).buffer);
}

func typeCheckProject(this: &TypeChecker, project: &ParsedFile) -> bool {
    trace("TypeChecker.typeCheckProject");
    if (!fillLookup(this)) return false;
    if (!typeCheckFiles(this)) return false;
    if (findRecursiveTypes(this)) return false;
    return !this.typeError;
}

func dfs(this: &TypeChecker, type: &Type, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    if (isArray(type)) {
        return dfs(this, getUnderlyingType(type, false), visited, finished);
    } else if (isStruct(type)) {
        let structID: usize = type.typeIndex;
        let strukt: &StructLookup = getStructByGlobalID(&this.lookup, structID);
        return dfs(this, asTypeLookup(strukt), visited, finished);
    } else if (isUnion(type)) {
        let unionID: usize = type.typeIndex;
        let onion: &UnionLookup = getUnionByGlobalDecl(&this.lookup, at(&unionDecls, unionID));
        return dfs(this, asTypeLookup(onion), visited, finished);
    } else {
        return false;
    }
}

func dfs(this: &TypeChecker, typeLookup: TypeLookup, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    trace("TypeChecker.dfs");
    if (contains(finished, &typeLookup))
        return false;
    if (contains(visited, &typeLookup))
        return true;
    push(visited, typeLookup);
    let done: bool = false;
    if (isStruct(&typeLookup)) {
        let strukt: &StructLookup = asStruct(&typeLookup);
        for (let i: usize = 0; i < strukt.fields.length; i = i + 1) {
            let field: &VariableLookup = at(&strukt.fields, i);
            assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
            let fieldType: &Type = getType(&field.typeState);
            if (dfs(this, fieldType, visited, finished)) {
                done = true;
            }
        }
    } else if (isUnion(&typeLookup)) {
        let onion: &UnionLookup = asUnion(&typeLookup);
        for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
            let _variant = at(&onion.variants, i);
            let variant = _variant.global;
            for (let j: usize = 0; j < variant.fields.length; j = j + 1) {
                let field = *at(&variant.fields, j);
                assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
                let fieldType = getType(&field.typeState);
                if (dfs(this, fieldType, visited, finished)) {
                    done = true;
                }
            }
        }
    } else {
        unreachable("Exhaustive handling of TypeLookup kinds in dfs");
    }
    push(finished, typeLookup);
    return done;
}

func findRecursiveTypes(this: &TypeChecker) -> bool {
    trace("TypeChecker.findRecursiveTypes");
    let recursive: bool = false;
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl: &ParsedStructDecl = at(&structDecls, i);
        if (decl.ignored) continue;
        let strukt: &StructLookup = getStructByGlobalID(&this.lookup, i);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(strukt), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(strukt), &visited);
            recursive = true;
        }
    }
    for (let i: usize = 0; i < unionDecls.length; i = i + 1) {
        let decl: &ParsedUnionDecl = at(&unionDecls, i);
        if (decl.ignored) continue;
        let onion: &UnionLookup = getUnionByGlobalDecl(&this.lookup, decl);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(onion), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(onion), &visited);
            recursive = true;
        }
    }
    return recursive;
}

func fillLookup(this: &TypeChecker) -> bool {
    trace("TypeChecker.fillLookup");
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = insertFile(&this.lookup, file);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.ignored) continue;
            if (!insertTLI(this.currentModule, tli)) success = false;
        }
    }
    return success;
}

func typeCheckFiles(this: &TypeChecker) -> bool {
    trace("TypeChecker.typeCheckFiles");
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_STRUCT_DECL) {
                let state = typeCheckStructDecl(this, tli.nodeID);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_UNION_DECL) {
                let state = typeCheckUnionDecl(this, asUnion(tli));
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule != null);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
             let tliID: usize = *at(&file.mod.tlis, j);
             let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
             if (tli.kind == TLI_MOD_DECL) {
                 let state = typeCheckModule(this, tli.nodeID, &this.currentModule.variables);
                 if (!isSuccess(&state)) success = false;
             }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_VAR_DECL) {
                let state = typeCheckVarDecl(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, false);
                let _dupl: &FunctionLookup = null;
                let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
                if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                    assert(_dupl != null, "Duplicate FunctionLookup is null");
                    reportDuplicateFunction(this, funcLookup, _dupl);
                    success = false;
                }
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    return success;
}

// FIXME: This function is a mess
func typeCheckModule(this: &TypeChecker, modID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckModule");
    let mod = at(&modules, modID);
    let prev = this.currentModule;
    this.currentModule = getModuleByGlobalID(&this.lookup, modID);
    let result = newTCStateSuccess();
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_STRUCT_DECL) {
            let state = typeCheckStructDecl(this, tli.nodeID);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_UNION_DECL) {
            let state = typeCheckUnionDecl(this, asUnion(tli));
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_MOD_DECL) {
            let state = typeCheckModule(this, tli.nodeID, scopes);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_VAR_DECL) {
            let state = typeCheckVarDecl(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, false);
            let _dupl: &FunctionLookup = null;
            let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
            if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                assert(_dupl != null, "Duplicate FunctionLookup is null");
                result = reportDuplicateFunction(this, funcLookup, _dupl);
            }
            if (!isSuccess(&state)) result = state;
        }
    }
    this.currentModule = prev;
    return result;
}

func typeCheckUnionDecl(this: &TypeChecker, onion: &ParsedUnionDecl) -> TCState {
    trace("TypeChecker.typeCheckUnionDecl");
    if (onion.ignored) return blank;
    let unionLookup = getUnionByGlobalDecl(&this.lookup, onion);
    let result = newTCStateSuccess();
    for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
        let variant = *at(&onion.variants, i);
        /*
        union Foo {
            A,
            B
        }
        typeof(Foo::A) == Foo
        typeof(Foo::B) == Foo
         */
        let state: TCState = newTCStateType(newType(TYPE_KIND_UNION, getID(onion)));
        let dupl: &UnionVariantLookup = null;
        if (checkForDuplicateVariant(unionLookup, variant, &dupl)) {
            result = reportDuplicateVariant(this, variant, dupl);
        }
        if (variant.kind == UNION_VARIANT_EMPTY) {
            assert(variant.fields.length == 0, "Empty Union Variant has fields");
            assert(variant.names.length == 0, "Empty Union Variant has fields");
        }
        assert(variant.names.length == variant.fields.length, "Union Variant name and field length mismatch");
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let field = *at(&variant.fields, i);
            let name = at(&variant.names, i);
            let dupl: &Token = null;
            if (checkForDuplicateName(variant, name, &dupl)) {
                result = reportDuplicateNameInUnion(this, variant, name, dupl);
                break;
            }
            let fieldState = typeCheckTypeNode(this, field);
            if (!isSuccess(&fieldState)) {
                result = fieldState;
            }
        }
        addVariant(unionLookup, variant, state);
    }
    if (isSuccess(&result)) {
        onion.typeState = result;
    }
    return result;
}

// FIXME: getStructByGlobalID -> getStructByGlobalDecl
func typeCheckStructDecl(this: &TypeChecker, structID: usize) -> TCState {
    trace("TypeChecker.typeCheckStructDecl");
    let strukt: &ParsedStructDecl = at(&structDecls, structID);
    if (strukt.ignored) return blank;
    let structLookup: &StructLookup = getStructByGlobalID(&this.lookup, structID);
    let context: &StructContext = &strukt.context;
    let result: TCState = newTCStateSuccess();
    let failure: TCState = blank;
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let typ = getFieldTypeAtIndex(context, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateField(structLookup, &name, &dupl)) {
            failure = reportDuplicateField(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        addField(structLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    (*strukt).typeState = newTCStateSuccess();
    return result;
}

func typeCheckFunction(this: &TypeChecker, funcID: usize, scopes: &ScopeLookupList, signatureOnly: bool) -> TCState {
    trace("TypeChecker.typeCheckFunction");
    let function: &ParsedFuncDecl = at(&funcDecls, funcID);
    if (function.ignored) return blank;
    let funcLookup = getFunctionByGlobalID(&this.lookup, funcID);
    this.currentFunction = funcLookup;
    let failure: TCState = blank;
    clear(&funcLookup.params);
    let params: TCStateList = blank;
    for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
        let typ = getTypeAtIndex(&function.params, i);
        let name: Token = getNameAtIndex(&function.params, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateParam(funcLookup, &name, &dupl)) {
            failure = reportDuplicateParameter(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        push(&params, state);
        addParameter(funcLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    let retState: TCState = typeCheckTypeNode(this, function.retType);
    if (isError(&retState)) return retState;
    let fnType = newType(TYPE_KIND_FUNCTION, getType(&retState));
    fnType.fnParams = params;
    if (function.params.isVarArg) fnType.arraySize = fnType.arraySize | FUNC_TYPE_VARIADIC;
    if (hasAttribute(function, ATTR_NORETURN)) fnType.arraySize = fnType.arraySize | FUNC_TYPE_NORETURN;
    let state = newTCStateType(fnType);
    funcLookup.fnType = state;
    function.typeState = state;
    @os(WINDOWS) if (isExtern(function)) {
        if (!function.parent.isFile) {
            let mod = getParentModule(function);
            let _name = getMangledName(function);
            if (mod.dlls.length == 0) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    fprintf(stderr, "%s: %s: No dynamic library was found for external function %s. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNotFound();
            }
            let addrFound = false;
            for (let i: usize = 0; i < mod.dlls.length; i = i + 1) {
                let dll = at(&dlls, *at(&mod.dlls, i));
                let handle = GetProcAddress(dll.handle, _name.buffer);
                if (!isNull(handle)) {
                    function.dllHandle = newDLL(dll.path, handle);
                    addrFound = true;
                    break;
                }
            }
            if (!addrFound && function.dllHandle != dllNotFound()) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    fprintf(stderr, "%s: %s: Could not find external function %s in any DLL. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNoSuchFunction();
            }
            drop(&_name);
        } else {
        }
        return function.typeState;
    }
    @os(LINUX) if (isExtern(function)) {
        todo_with_msg("type check extern func on Linux");
    }
    if (signatureOnly) {
        return newTCStateSuccess();
    }
    let scope: ScopeLookup = blank;
    for (let i: usize = 0; i < funcLookup.params.length; i = i + 1) {
        addVariable(&scope, *(at(&funcLookup.params, i)));
    }
    push(scopes, scope);
    let blockState: TCState = typeCheckBlock(this, function.body, scopes);
    pop(scopes);
    if (isError(&blockState)) {
        return blockState;
    }
    return function.typeState;
}

func typeCheckBlock(this: &TypeChecker, block: &ParsedBlock, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckBlock");
    if (block.ignored) return blank;
    if (isSuccess(&block.typeState)) {
        return block.typeState;
    }
    push(scopes, ScopeLookup {
        variables: blank,
    });
    let curr: usize = scopes.length;
    // REVIEW: Do we want to make blocks expressions?
    let blockState: TCState = newTCStateSuccess();
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmtState: TCState = typeCheckStmt(this, getStmtAtIndex(block, i), scopes);
        if (isError(&stmtState)) {
            blockState = stmtState;
        }
    }
    let after: usize = scopes.length;
    pop(scopes);
    assert(after == curr, "Stack imbalance");
    if (isError(&blockState)) return blockState;
    (*block).typeState = newTCStateSuccess();
    return block.typeState;
}

func typeCheckStmt(this: &TypeChecker, stmt: &ParsedStmt, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckStmt");
    if (stmt.ignored) return blank;
    if (stmt.kind == STMT_BLOCK) {
        let blockState: TCState = typeCheckBlock(this, stmt.block, scopes);
        if (isError(&blockState)) {
            return blockState;
        }
        stmt.typeState = blockState;
        return blockState;
    } else if (stmt.kind == STMT_VAR_DECL) {
        return typeCheckVarDecl(this, stmt, scopes, false);
    } else if (stmt.kind == STMT_EXPR) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let exprState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        if (isError(&exprState)) {
            return exprState;
        }
        if (wantsInfer(&exprState)) {
            let noneType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_NONE);
            exprState = inferTypeOntoExpr(this, stmt.expr, noneType, scopes);
        }
        if (!isType(&exprState)) {
            printf("%llu\n", exprState.kind);
            todo_with_msg("what is it then");
        }
        let exprType: &Type = getType(&exprState);
        if (!isNone(exprType) && !isAssignment(stmt.expr) && *flags.warnUnused) {
            let loc: String = toString(&stmt.expr.span);
            fprintf(stderr, "%s: %s: Unused expression value.\n", loc.buffer, WARN_STR);
            drop(&loc);
        }
        (*stmt).typeState = exprState;
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_IF) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let condState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        let thenState: TCState = typeCheckStmt(this, stmt.ifContext.thenBody, scopes);
        let elseState: TCState = newTCStateSuccess();
        if (stmt.ifContext.hasElse) {
            elseState = typeCheckStmt(this, stmt.ifContext.elseBody, scopes);
        }
        if (isError(&condState)) return condState;
        if (isError(&thenState)) return thenState;
        if (isError(&elseState)) return elseState;
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        if (wantsInfer(&condState)) {
            condState = inferTypeOntoExpr(this, stmt.expr, boolType, scopes);
            assert(isType(&condState), "Could not infer type onto if-condition");
        }
        let condType: &Type = getType(&condState);
        if (!isBoolean(condType)) {
            return reportTypeMismatch(this, stmt.expr.span, boolType, condType);
        }
        let state: TCState = newTCStateSuccess();
        (*stmt).typeState = state;
        return state;
    } else if (stmt.kind == STMT_RETURN_EXPR) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let exprState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        if (isError(&exprState)) return exprState;
        assert(this.currentFunction != null);
        let retState: &TCState = &this.currentFunction.fnType;
        assert(isSuccess(retState), "ready to use function has invalid return type");
        assert(isType(retState), "ready to use function has non-type as return type");
        let _rt = getType(retState);
        let retType = at(&types, _rt.typeIndex);
        if (isNone(retType)) todo_with_msg("unexpected ret expr where empty function");
        if (wantsInfer(&exprState)) {
            exprState = inferTypeOntoExpr(this, stmt.expr, retType, scopes);
            if (isError(&exprState)) return exprState;
            assert(isType(&exprState), "Failed to infer type of return expression");
        }
        let exprType: &Type = getType(&exprState);
        if (!equals(exprType, retType)) {
            return reportTypeMismatch(this, stmt.span, retType, exprType);
        }
        (*stmt).typeState = *retState;
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_RETURN_EMPTY) {
        assert(this.currentFunction != null);
        let retState: &TCState = &this.currentFunction.fnType;
        let _rt = getType(retState);
        let retType = at(&types, _rt.typeIndex);
        if (!isNone(retType)) {
            printf("%s\n", toString(&stmt.span).buffer);
            printf("%llu %llu\n", retType.kind, retType.typeIndex);
            todo_with_msg("function returns something, but we wrote return;");
        }
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_WHILE) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let condState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        let bodyState: TCState = typeCheckBlock(this, stmt.block, scopes);
        let stepState: TCState = typeCheckExpr(this, stmt.step, scopes);
        if (isError(&condState)) return condState;
        if (isError(&bodyState)) return bodyState;
        if (isError(&stepState)) return stepState;
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        if (wantsInfer(&condState)) {
            condState = inferTypeOntoExpr(this, stmt.expr, boolType, scopes);
            assert(isType(&condState), "Could not infer type onto while-condition");
        }
        let condType: &Type = getType(&condState);
        if (!isBoolean(condType)) {
            return reportTypeMismatch(this, stmt.expr.span, boolType, condType);
        }
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_BREAK || stmt.kind == STMT_CONTINUE) {
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else {
        unreachable("Exhaustive handling of stmts in typeCheckStmt");
    }
}

func typeCheckVarDecl(this: &TypeChecker, varDeclID: usize, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    return typeCheckVarDecl(this, at(&stmts, varDeclID), scopes, globalScope);
}
func typeCheckVarDecl(this: &TypeChecker, varDecl: &ParsedStmt, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    trace("TypeChecker.typeCheckVarDecl");
    if (varDecl.ignored) return blank;
    assert(varDecl.kind == STMT_VAR_DECL, "Stmt expected to be a VarDecl");
    let context: VarDeclContext = varDecl.varDeclContext;
    let last: &ScopeLookup = last(scopes);
    let typeState: TCState = blank;
    let exprState: TCState = blank;
    if (isSuccess(&varDecl.typeState)) {
        typeState = varDecl.typeState;
        exprState = varDecl.typeState;
    } else {
        let loc: Token = blank;
        if (*flags.warnSimple) {
            for (let i: usize = 0; i < scopes.length - 1; i = i + 1) {
                let s = at(scopes, i);
                let _loc: Token = blank;
                if (isKnownVariable(s, context.name.content, &_loc)) {
                    let loc1 = toString(&context.name.span);
                    let loc2 = toString(&_loc.span);
                    let name = toString(&context.name.content);
                    fprintf(stderr, "%s: %s: Shadowing variable `%s` from an outer scope.\n", loc1.buffer, WARN_STR, name.buffer);
                    fprintf(stderr, "%s: %s: Variable with the same name already declared here.\n", loc2.buffer, NOTE_STR);
                    drop(&name);
                    drop(&loc2);
                    drop(&loc1);
                }
            }
        }
        if (!globalScope && isKnownVariable(last, context.name.content, &loc)) {
            return reportVariableRedeclaration(this, context.name, loc);
        }
        if (context.type != null) {
            typeState = typeCheckTypeNode(this, context.type);
            if (isError(&typeState)) return typeState;
            if (!isType(&typeState)) todo_with_msg("let type is not a type");
        }
        this.isComptimeContext = context.isComptime;
        exprState = typeCheckExpr(this, context.expr, scopes);
        this.isComptimeContext = false;
        if (context.type == null) {
            // let var = expr;
            assert(isInvalid(&typeState), "`let var = expr;` got valid type state??");
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) {
            } else if (!isType(&exprState)) {
                todo_with_msg("let expr is not a type");
            }
            typeState = exprState;
        } else {
            // let var: type = expr;
            if (wantsInfer(&exprState)) {
                exprState = inferTypeOntoExpr(this, context.expr, getType(&typeState), scopes);
            }
            if (isType(&exprState)) {
                let typeType: &Type = getType(&typeState);
                let exprType: &Type = getType(&exprState);
                if (!equals(typeType, exprType)) {
                    exprState = reportTypeMismatch(this, context.expr.span, typeType, exprType);
                }
            }
        }
    }
    if (globalScope) {
        let index: usize = 0;
        assert(getVarIndexByName(last, context.name.content, &index), "Could not find variable in global scope");
        let var: &VariableLookup = getVariableAtIndex(last, index);
        (*var).typeState = typeState;
    } else {
        addVariable(last, VariableLookup {
            globalID: getID(varDecl),
            name: context.name,
            typeState: typeState,
            isComptime: context.isComptime,
        });
    }
    if (isError(&exprState)) return exprState;
    (*varDecl).typeState = typeState;
    return typeState;
}

func typeCheckExpr(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    return typeCheckExpr(this, at(&exprs, exprID), scopes);
}
func typeCheckExpr(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExpr");
    if (expr.ignored) return blank;
    if (isSuccess(&expr.typeState)) return expr.typeState;
    let state: TCState = blank;
    if (expr.kind == EXPR_EMPTY) {
        state = newTCStateSuccess();
    } else if (expr.kind == EXPR_INT_LIT) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_STRING_LIT) {
        let ct: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
        let st: &Type = newType(TYPE_KIND_POINTER, getID(ct));
        state = newTCStateType(st);
    } else if (expr.kind == EXPR_CHAR_LIT) {
        state = newTCStateType(newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR));
    } else if (expr.kind == EXPR_ARRAY_LIT) {
        let context: &ArrayContext = &expr.arrayContext;
        if (context.elemLength == 0) return newTCStatePleaseInfer();
        let elemIndex: usize = getElementAtIndex(context, 0);
        let elemState: TCState = typeCheckExpr(this, elemIndex, scopes);
        if (isError(&elemState)) return elemState;
        if (wantsInfer(&elemState)) return elemState;
        let elemType: &Type = getType(&elemState);
        if (context.size == 0) {
            let lastErrState: TCState = blank;
            for (let i: usize = 1; i < context.elemLength; i = i + 1) {
                let nextIndex: usize = getElementAtIndex(context, i);
                let nextState: TCState = typeCheckExpr(this, nextIndex, scopes);
                if (isError(&nextState)) {
                    lastErrState = nextState;
                    continue;
                }
                let nextType: &Type = getType(&nextState);
                if (!equals(nextType, elemType)) {
                    let loc = toString(&at(&exprs, elemIndex).span);
                    let t = toString(elemType);
                    lastErrState = reportTypeMismatch(this, at(&exprs, nextIndex).span, elemType, nextType);
                    fprintf(stderr, "%s: %s: Array elements inferred to be type %s here.\n", loc.buffer, NOTE_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                }
            }
            if (!isInvalid(&lastErrState)) return lastErrState;
            let t: &Type = newType(TYPE_KIND_ARRAY, getID(elemType));
            (*t).arraySize = context.elemLength;
            state = newTCStateType(t);
        } else {
            let t: &Type = newType(TYPE_KIND_ARRAY, getID(elemType));
            (*t).arraySize = context.size;
            state = newTCStateType(t);
        }
    } else if (expr.kind == EXPR_NAME) {
        state = typeCheckIdentifier(this, expr, scopes);
    } else if (expr.kind == EXPR_UNARY) {
        state = typeCheckUnary(this, expr, scopes);
    } else if (expr.kind == EXPR_BINARY) {
        state = typeCheckExprBinary(this, expr, scopes);
    } else if (expr.kind == EXPR_CALL) {
        state = typeCheckExprCall(this, expr, scopes);
    } else if (expr.kind == EXPR_SIZEOF) {
        state = typeCheckExprSizeof(this, expr, scopes);
    } else if (expr.kind == EXPR_STRUCT_INIT) {
        state = typeCheckExprStructInit(this, expr, scopes);
    } else if (expr.kind == EXPR_AS) {
        state = typeCheckExprAs(this, expr, scopes);
    } else if (expr.kind == EXPR_NULL) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_BLANK) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
        state = newTCStateType(newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL));
    } else {
        unreachable("Exhaustive handling of expressions in typeCheckExpr");
    }
    if (isError(&state)) return state;
    (*expr).typeState = state;
    return state;
}

func typeCheckExprSizeof(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprSizeof");
    if (isSuccess(&expr.typeState)) return expr.typeState;
    assert(expr.kind == EXPR_SIZEOF);
    let typeState: TCState = typeCheckTypeNode(this, at(&typeNodes, expr.lhs));
    if (isError(&typeState)) return typeState;
    return newTCStateType(newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE));
}

func typeCheckExprAs(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAs");
    assert(expr.kind == EXPR_AS);
    let exprState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let typeState: TCState = typeCheckTypeNode(this, at(&typeNodes, expr.rhs));
    if (isError(&exprState)) return exprState;
    if (isError(&typeState)) return typeState;
    assert(isType(&typeState), "typeCheckExprAs Type is not a Type");
    let typeType: &Type = getType(&typeState);
    if (wantsInfer(&exprState)) exprState = inferTypeOntoExpr(this, expr.lhs, getID(typeType), scopes);
    if (isError(&exprState)) return exprState;
    assert(isType(&exprState), "Expected <expr> in `<expr> as <type>` to have a valid type after infer");
    let exprType: &Type = getType(&exprState);
    if (isPointer(exprType) && isPointer(typeType)) {
        // PTR as PTR is allowed
    } else if (isFunction(exprType) && isFunction(typeType)) {
        // Function as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from type %s to type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isFunction(exprType) && isAny(typeType)) {
        // Function as Any is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let from = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from type %s to Any.\n",
                loc.buffer, WARN_STR, from.buffer);
            drop(&from);
            drop(&loc);
        }
    } else if (isAny(exprType) && isFunction(typeType)) {
        // Any as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from Any to type %s.\n",
                loc.buffer, WARN_STR, to.buffer);
            drop(&to);
            drop(&loc);
        }
    } else if (isPointer(exprType) && isInteger(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting pointer of type %s to integer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isInteger(exprType) && isPointer(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting integer of type %s to pointer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (!isPrimitive(typeType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    } else if (!isPrimitive(exprType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    }
    if (getSize(typeType) < getSize(exprType) && *flags.warnExtra) {
        let loc: String = toString(&expr.span);
        let tName: String = toString(typeType);
        let oName: String = toString(exprType);
        fprintf(stderr, "%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n",
            loc.buffer, WARN_STR, tName.buffer, oName.buffer);
        drop(&oName);
        drop(&tName);
        drop(&loc);
    }
    return typeState;
}

func typeCheckUnary(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckUnary");
    assert(expr.kind == EXPR_UNARY);
    let exprState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&exprState)) return exprState;
    if (wantsInfer(&exprState)) return exprState; // Can't be done in here
    if (expr.op == UNARY_COMPTIME) {
        return exprState;
    } else if (expr.op == UNARY_DEREF) {
        let exprType: &Type = getType(&exprState);
        if (isPrimitive(exprType)) {
            if (exprType.typeIndex == TYPE_ANY) {
                return reportAnyDereference(this, expr);
            }
        }
        if (!isPointer(exprType)) {
            let loc: String = toString(&expr.span);
            let t: String = toString(exprType);
            fprintf(stderr, "%s: %s: Attempted to dereference expression of type %s.\n", loc.buffer, ERR_STR, t.buffer);
            drop(&t);
            drop(&loc);
            return newTCStateFailure(ERROR_DEREF_NON_POINTER);
        }
        return newTCStateType(getUnderlyingType(exprType, false));
    } else if (expr.op == UNARY_REF) {
        let exprType: &Type = getType(&exprState);
        return newTCStateType(newType(TYPE_KIND_POINTER, getID(exprType)));
    } else if (expr.op == UNARY_NOT) {
        let exprType: &Type = getType(&exprState);
        if (!isBoolean(exprType)) {
            let loc: String = toString(&expr.span);
            let t: String = toString(exprType);
            fprintf(stderr, "%s: %s: Logical Not is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
            drop(&t);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        return exprState;
    } else if (expr.op == UNARY_MINUS) {
        let exprType: &Type = getType(&exprState);
        if (!isSignedInteger(exprType) && !isFloat(exprType)) {
            let loc: String = toString(&expr.span);
            let t: String = toString(exprType);
            fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
            drop(&t);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        return exprState;
    } else {
        unreachable("Exhaustive handling of ops in typeCheckUnary");
    }
}

func typeCheckExprCall(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprCall");
    assert(expr.kind == EXPR_CALL);
    // First sweep
    let callContext = &expr.arrayContext;
    for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
        let argID: usize = getElementAtIndex(callContext, i);
        let arg: TCState = typeCheckExpr(this, argID, scopes);
        if (isError(&arg)) return arg;
    }
    let callBase = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&callBase)) return callBase;
    if (wantsInfer(&callBase)) {
        let fnType = newType(TYPE_KIND_FUNCTION, TYPE_UNKNOWN);
        for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
            let argID: usize = getElementAtIndex(callContext, i);
            push(&fnType.fnParams, at(&exprs, argID).typeState);
        }
        let baseState = tryInferTypeOntoExpr(this, expr.lhs, getID(fnType), scopes, false);
        if (isError(&baseState)) return baseState;
        if (wantsInfer(&baseState)) return baseState;
        callBase = baseState;
    }
    let baseType = getType(&callBase);
    if (!isFunction(baseType)) {
        return reportCallToNonFunction(this, expr.span, baseType);
    }
    if (!isVariadic(baseType) && callContext.elemLength != baseType.fnParams.length) {
        return reportArgumentCountMismatch(this, expr.span, baseType, callContext.elemLength);
    }
    for (let i: usize = 0; i < baseType.fnParams.length; i = i + 1) {
        let argID: usize = getElementAtIndex(callContext, i);
        let arg: TCState = typeCheckExpr(this, argID, scopes);
        if (isError(&arg)) return arg;
        if (wantsInfer(&arg)) {
            let p = getParam(baseType, i);
            arg = inferTypeOntoExpr(this, argID, getType(p), scopes);
            if (isError(&arg)) return arg;
        }
        let argType = getType(&arg);
        let paramType = getType(getParam(baseType, i));
        if (!equals(argType, paramType)) {
            let e = at(&exprs, argID);
            reportTypeMismatch(this, e.span, paramType, argType);
        }
    }
    return newTCStateType(at(&types, baseType.typeIndex));
}

func typeCheckExprStructInit(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprStructInit");
    assert(expr.kind == EXPR_STRUCT_INIT);
    let name: Token = expr.origToken;
    let lookup: TypeLookup = blank;
    if (!resolveTypeByName(this.currentModule, &name, &lookup)) {
        let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &name);
        return reportUnknownType(this, null, name, alternatives);
    }
    if (isStruct(&lookup)) {
        return typeCheckStructInitialization(this, expr, lookup, scopes);
    } else {
        unreachable("typeCheckExprStructInit got non-struct");
    }
}

func typeCheckIdentifier(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckIdentifier");
    assert(expr.kind == EXPR_NAME);
    let name: Token = expr.origToken;
    let var: VariableLookup = blank;
    if (resolveVariableByName(this.currentModule, &name, scopes, &var)) {
        if (this.isComptimeContext && !var.isComptime) {
            reportRuntimeValueInComptimeContext(this, name, &var);
        }
        let state: TCState = var.typeState;
        assert(!isInvalid(&state), "Variable not ready");
        if (isError(&state)) return state;
        assert(expr.op == 0);
        let _loc: Token = blank;
        if (isKnownVariable(at(scopes, 0), name.content, &_loc)) {
            (*expr).op = 1;
        }
        (*expr).lhs = var.globalID;
        (*expr).typeState = state;
        return state;
    }
    let functions = resolveFunctionByName(this.currentModule, &name);
    if (functions.length > 1) {
        drop(&functions);
        return newTCStatePleaseInfer();
    }
    if (functions.length == 1) {
        let f = at(&functions, 0);
        (*expr).lhs = f.globalID;
        (*expr).typeState = f.fnType;
        return f.fnType;
    }
    let moduleLookup: &ModuleLookup = null;
    if (resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
        let typ = newType(TYPE_KIND_MODULE, moduleLookup.globalID);
        let state = newTCStateType(typ);
        expr.typeState = state;
        return state;
    }
    let loc: String = getLocation(&name);
    let _name: String = toString(&name.content);
    fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    let alternatives: VariableLookupList = searchAllFilesForIdentifier(&this.lookup, &name);
    for (let i: usize = 0; i < alternatives.length; i = i + 1) {
        let t: &VariableLookup = at(&alternatives, i);
        let loc: String = getLocation(&t.name);
        fprintf(stderr, "%s: %s: A variable with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
        drop(&loc);
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
}

func typeCheckExprBinary(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBinary");
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    if (expr.op == BIN_MODULE) {
        return typeCheckExprModuleAccess(this, expr, scopes);
    } else if (expr.op == BIN_DOT) {
        return typeCheckExprMemberAccess(this, expr, scopes);
    } else if (expr.op == BIN_ASSIGN) {
        return typeCheckExprAssign(this, expr, scopes);
    } else if (expr.op == BIN_INDEXED_ACCESS) {
        return typeCheckExprIndexedAccess(this, expr, scopes);
    } else if (isArithmetic(expr)) {
        return typeCheckExprArithmetic(this, expr, scopes);
    } else if (isComparison(expr)) {
        return typeCheckExprComparison(this, expr, scopes);
    } else if (isLogical(expr)) {
        return typeCheckExprLogical(this, expr, scopes);
    } else if (isBitwise(expr)) {
        return typeCheckExprBitwise(this, expr, scopes);
    } else {
        unreachable("Exhaustive handling of ops in typeCheckExprBinary");
    }
}

func typeCheckExprIndexedAccess(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprIndexedAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_INDEXED_ACCESS);
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    if (wantsInfer(&lhsState)) {
        let lhs = at(&exprs, expr.lhs);
        let loc = toString(&lhs.span);
        fprintf(stderr, "%s: %s: Could not infer type of subexpression for indexed access.\n", loc.buffer, ERR_STR);
        drop(&loc);
        return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
    }
    assert(isType(&lhsState), "IndexedAccess: Not error, not infer, what is it?");
    let lhsType: &Type = getType(&lhsState);
    if (!isArray(lhsType) && !isPointer(lhsType)) {
        return reportIndexedAccessOnNonArray(this, expr.span, lhsType);
    }
    if (wantsInfer(&rhsState)) {
        let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        rhsState = inferTypeOntoExpr(this, expr.rhs, getID(usizeType), scopes);
    }
    if (isError(&rhsState)) return rhsState;
    assert(isType(&rhsState), "IndexedAccess: Index is not valid after infer?");
    let rhsType: &Type = getType(&rhsState);
    if (!isPrimitive(rhsType) || rhsType.typeIndex != TYPE_USIZE) {
        let loc: String = toString(&expr.span);
        let typ: String = toString(rhsType);
        fprintf(stderr, "%s: %s: Expected index of array access to be type usize, got %s.\n", loc.buffer, ERR_STR, typ.buffer);
        drop(&typ);
        drop(&loc);
        this.typeError = true;
        return newTCStateFailure(ERROR_INDEXED_TYPE_MISMATCH);
    }
    let underlyingID: usize = lhsType.typeIndex;
    let underlyingType: &Type = at(&types, underlyingID);
    assert(getID(underlyingType) == underlyingID);
    return newTCStateType(underlyingType);
}

func typeCheckExprLogical(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprLogical");
    assert(expr.kind == EXPR_BINARY);
    assert(isLogical(expr));
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in logical");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
    let result = newTCStateType(boolType);
    if (!isBoolean(lhsType)) {
        result = reportTypeMismatch(this, at(&exprs, expr.lhs).span, boolType, lhsType);
    }
    if (!isBoolean(rhsType)) {
        result = reportTypeMismatch(this, at(&exprs, expr.rhs).span, boolType, rhsType);
    }
    return result;
}

func typeCheckExprBitwise(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBitwise");
    assert(expr.kind == EXPR_BINARY);
    assert(isBitwise(expr));
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in bitwise");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType) || !isInteger(lhsType) || !isInteger(rhsType)) {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    return lhsState;
}

func typeCheckExprAssign(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAssign");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_ASSIGN);
    let lhsExpr: &ParsedExpr = at(&exprs, expr.lhs);
    if (!isLValue(lhsExpr)) {
        emergencyPrint(this, lhsExpr.span);
        todo_with_msg("invalid l-value");
    }
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (!isType(&lhsState)) return lhsState;
    if (!isType(&rhsState)) return rhsState;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportTypeMismatch(this, at(&exprs, expr.rhs).span, lhsType, rhsType);
    }
    return rhsState;
}

func typeCheckStructInitialization(this: &TypeChecker, expr: &ParsedExpr, lookup: TypeLookup, scopes: &ScopeLookupList) -> TCState {
    let context: &StructInitContext = &expr.structInitContext;
    let structLookup: &StructLookup = asStruct(&lookup);
    let hits: usize = 0;
    assert(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
    let result = newTCStateType(structLookup.type);
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let fieldExpr: &ParsedExpr = getFieldExprAtIndex(context, i);
        let exprState: TCState = typeCheckExpr(this, fieldExpr, scopes);
        if (isError(&exprState)) result = exprState;
        if (!hasField(structLookup, &name.content)) {
            result = reportUnknownField(this, name, structLookup);
            continue;
        }
        let fieldIndex: usize = getIndexByName(structLookup, &name);
        let bit: usize = shiftLeft(1, fieldIndex);
        if ((hits & bit) != 0) {
            let field = getFieldNameAtIndex(context, fieldIndex);
            result = reportDuplicateField(this, name, field.span);
            continue;
        } else {
            hits = hits | bit;
        }
        let field: &VariableLookup = at(&structLookup.fields, fieldIndex);
        let fieldState: &TCState = &field.typeState;
        assert(isSuccess(fieldState), "Struct is ready to go, but field type is invalid?");
        assert(equals(&name.content, &field.name.content), "Seems like my hack doesn't work");
        let fieldType: &Type = getType(fieldState);
        if (wantsInfer(&exprState))
            exprState = inferTypeOntoExpr(this, fieldExpr, fieldType, scopes);
        if (isError(&exprState)) {
            result = exprState;
            continue;
        }
        let exprType: &Type = getType(&exprState);
        if (!equals(fieldType, exprType)) {
            result = reportTypeMismatch(this, fieldExpr.span, fieldType, exprType);
        }
    }
    return result;
}
func typeCheckExprModuleAccess(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprModuleAccess");
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(expr.op == BIN_MODULE);
    let modExpr = at(&exprs, expr.lhs);
    let rhs = at(&exprs, expr.rhs);
    let instance: TCState = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&instance)) return instance;
    let instanceType = getType(&instance);
    if (!isModule(instanceType)) {
        return reportModuleAccessOfNonModule(this, expr.span, modExpr.origToken, blank);
    }
    let modLookup = getModuleByGlobalID(&this.lookup, instanceType.typeIndex);
    if (rhs.kind == EXPR_NAME) {
        let submodule: &ModuleLookup = null;
        if (resolveModuleByName(modLookup, &rhs.origToken, &submodule, false, true, true)) {
            let typ = newType(TYPE_KIND_MODULE, submodule.globalID);
            rhs.typeState = newTCStateType(typ);
            return rhs.typeState;
        }
        let var: &VariableLookup = null;
        let fun: FunctionLookupList = blank;
        let typ: TypeLookup = blank;
        let res = resolveIdentifierByName(modLookup, &rhs.origToken, &var, &typ, &fun);
        if (res == IDENT_TYPE) {
            return reportModuleAccessOfNonModule(this, expr.span, rhs.origToken, typ);
        } else if (res == IDENT_NONE) {
            return reportUnknownSubmodule(this, modLookup, rhs.origToken);
        } else if (res == IDENT_FUNC) {
            assert(fun.length != 0, "IDENT_FUNC but fun is empty");
            if (fun.length == 1) {
                let f = at(&fun, 0);
                assert(isSuccess(&f.fnType), "Did not properly type check function of module");
                let s = f.fnType;
                rhs.typeState = s;
                rhs.lhs = f.globalID;
                return s;
            } else {
                drop(&fun);
                return newTCStatePleaseInfer();
            }
        } else if (res == IDENT_VAR) {
            assert(var != null, "IDENT_VAR but var is null");
            todo_with_msg("module.var");
        } else {
            unreachable("Exhaustive handling of outcomes of resolveIdentifierByName");
        }
    } else if (rhs.kind == EXPR_STRUCT_INIT) {
        let name: Token = rhs.origToken;
        let lookup: TypeLookup = blank;
        if (!resolveTypeByName(modLookup, &name, &lookup)) {
            return reportUnknownType(this, modLookup, name, blank);
        }
        if (isStruct(&lookup)) {
            rhs.typeState = typeCheckStructInitialization(this, rhs, lookup, scopes);
        } else {
            unreachable("typeCheckExprModuleAccess got non-struct");
        }
        return rhs.typeState;
    } else {
        todo_with_msg("report error maybe?");
    }
}
func typeCheckExprMemberAccess(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprMemberAccess");
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(expr.op == BIN_DOT);
    let instance: TCState = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&instance)) return instance;
    if (wantsInfer(&instance)) return instance;
    let instanceType = getType(&instance);
    // TODO: There's no reason why things like the following example shouldn't work for member access.
    // [Marker for todo.py: The above TODO is important]
    // [Marker for todo.py: The above TODO is important]
    /*
    struct Foo {
        a: i32;
    }
    func main() {
        let f = Foo { a: 1 };
        let r1 = &f;
        let r2 = &r1;
        r2.a = 13; // The Dot-Operator is not defined for values of type &&Foo.
        assert(f.a == 13);
    }
    */
    if (!isStruct(instanceType) && !isStructPointer(instanceType)) {
        return reportMemberAccessOnNonStruct(this, expr, instanceType);
    }
    let underlying: &Type = instanceType;
    if (!isStruct(underlying)) underlying = getUnderlyingType(instanceType, true);
    let lookup: TypeLookup = getTypeLookupForType(&this.lookup, underlying);
    if (isStruct(underlying)) {
        assert(isStruct(&lookup));
        let structLookup: &StructLookup = asStruct(&lookup);
        let rhs: &ParsedExpr = at(&exprs, expr.rhs);
        assert(rhs.kind == EXPR_NAME);
        let fieldName: Token = rhs.origToken;
        let field: VariableLookup = blank;
        if (!resolveFieldByName(structLookup, &fieldName, &field)) {
            return reportUnknownField(this, fieldName, structLookup);
        }
        let fieldState: TCState = field.typeState;
        assert(isSuccess(&fieldState), "Expected valid field type");
        return fieldState;
    } else {
        unreachable("MemberAccess expected Struct as LHS");
    }
}

func checkIfInferIsNeeded(this: &TypeChecker, lhsID: usize, lhsState: &TCState, rhsID: usize, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    let lhsExpr: &ParsedExpr = at(&exprs, lhsID);
    let rhsExpr: &ParsedExpr = at(&exprs, rhsID);
    return checkIfInferIsNeeded(this, lhsExpr, lhsState, rhsExpr, rhsState, scopes);
}
func checkIfInferIsNeeded(this: &TypeChecker, lhsExpr: &ParsedExpr, lhsState: &TCState, rhsExpr: &ParsedExpr, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.checkIfInferIsNeeded");
    if (isType(lhsState) && isType(rhsState)) {
        return newTCStateSuccess();
    } else if (isType(lhsState) && !isType(rhsState)) {
        *rhsState = inferTypeOntoExpr(this, rhsExpr, getType(lhsState), scopes);
        return *rhsState;
    } else if (!isType(lhsState) && isType(rhsState)) {
        *lhsState = inferTypeOntoExpr(this, lhsExpr, getType(rhsState), scopes);
        return *lhsState;
    } else {
        return newTCStatePleaseInfer();
    }
}

func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.inferTypeOntoExpr");
    return tryInferTypeOntoExpr(this, exprID, typeID, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, expr, type, scopes, false);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, checkOnly);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), at(&types, typeID), scopes, checkOnly);
}

func tryInferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoExpr");
    if (isSuccess(&expr.typeState)) {
        let exprType: &Type = getType(&expr.typeState);
        if (!equals(exprType, type)) todo_with_msg("infer failed");
        return newTCStateType(type);
    }
    let tid: TCState = blank;
    if (expr.kind == EXPR_NAME) {
        let var: VariableLookup = blank;
        if (resolveVariableByName(this.currentModule, &expr.origToken, scopes, &var)) {
            assert(wantsInfer(&var.typeState), "Ident has no type, but variable doesn't want infer");
            tid = newTCStateType(type);
            var.typeState = tid;
            let stmt = at(&stmts, var.globalID);
            assert(stmt.kind == STMT_VAR_DECL, "VariableLookup points to non-VarDecl");
            tid = tryInferTypeOntoExpr(this, stmt.varDeclContext.expr, type, scopes, checkOnly);
            if (isError(&tid)) {
                let loc = toString(&expr.span);
                let name = toString(&expr.origToken.content);
                let type = toString(type);
                fprintf(stderr, "%s: %s: Variable `%s` inferred to be of type %s here.\n", loc.buffer, NOTE_STR, name.buffer, type.buffer);
                drop(&type);
                drop(&name);
                drop(&loc);
            }
            stmt.typeState = tid;
        } else if (isFunction(type)) {
            let functions = resolveAllFunctionsWithSignature(this.currentModule, &expr.origToken, type);
            if (functions.length == 0) {
                if (checkOnly) {
                    tid = newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
                } else {
                    let all = resolveFunctionByName(this.currentModule, &expr.origToken);
                    tid = reportNoFunctionCallCandidate(this, expr, type, &all);
                    drop(&all);
                }
            } else if (functions.length == 1) {
                let f = at(&functions, 0);
                assert(f.params.length == type.fnParams.length);
                if (!checkOnly) {
                    expr.lhs = f.globalID;
                }
                tid = f.fnType;
            } else {
                tid = newTCStatePleaseInfer();
            }
            drop(&functions);
        } else {
            todo_with_msg("infer onto name, but not a function or variable");
        }
    } else if (expr.kind == EXPR_INT_LIT) {
        if (isChar(type)) {
            if (!checkOnly) {
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Using integer literal to initialize value of type char.\n",
                    l.buffer, WARN_STR);
                drop(&l);
            }
            tid = newTCStateType(type);
        } else if (isInteger(type) || isFloat(type)) {
            tid = newTCStateType(type);
        } else if (isPointer(type)) {
            // REVIEW: This is... More than debatable?
            // Context requires a pointer, we have an integer literal.. Now this literal is type usize
            // Question: Is there ever a situation where we actually want this literal to be type ptr?
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            tid = newTCStateType(usizeType);
        } else if (isBoolean(type)) {
            if (!checkOnly) {
                let s: String = toString(&expr.origToken.content);
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n",
                    l.buffer, ERR_STR, s.buffer);
                drop(&l);
                drop(&s);
                this.typeError = true;
            }
            return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
        } else if (isArray(type)) {
            if (!checkOnly) {
                let s: String = toString(&expr.origToken.content);
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Unexpected Literal! Expected array, found `%s`.\n",
                    l.buffer, ERR_STR, s.buffer);
                drop(&l);
                drop(&s);
                this.typeError = true;
            }
            return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
        } else {
            if (!checkOnly) {
                let s: String = toString(&expr.origToken.content);
                let l: String = getLocation(&expr.origToken);
                let t = toString(type);
                fprintf(stderr, "%s: %s: Unexpected Literal! Expected value of type %s, found `%s`.\n",
                    l.buffer, ERR_STR, t.buffer, s.buffer);
                drop(&t);
                drop(&l);
                drop(&s);
                this.typeError = true;
            }
            return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
        }
    } else if (expr.kind == EXPR_CHAR_LIT) {
        unreachable("EXPR_CHAR_LIT always has type char and should never be the target of tryInferTypeOntoExpr");
    } else if (expr.kind == EXPR_ARRAY_LIT) {
        if (!isArray(type)) {
            if (!checkOnly) {
                let loc = toString(&expr.span);
                let t = toString(type);
                fprintf(stderr, "%s: %s: Expected expression of type %s, found array literal.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        if (expr.arrayContext.size == 0) {
            if (type.arraySize != expr.arrayContext.elemLength) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                        loc.buffer, ERR_STR, type.arraySize, expr.arrayContext.elemLength);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
            }
            let lastErrState: TCState = blank;
            for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
                tid = tryInferTypeOntoExpr(this, getElementAtIndex(&expr.arrayContext, i), type.typeIndex, scopes, checkOnly);
                if (isError(&tid)) {
                    lastErrState = tid;
                }
            }
            if (!isInvalid(&lastErrState)) return lastErrState;
        } else {
            if (type.arraySize != expr.arrayContext.size) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                        loc.buffer, ERR_STR, type.arraySize, expr.arrayContext.size);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, getElementAtIndex(&expr.arrayContext, 0), type.typeIndex, scopes, checkOnly);
            if (isError(&tid)) return tid;
        }
        tid = newTCStateType(type);
    } else if (expr.kind == EXPR_BLANK) {
        if (isPointer(type)) {
            let loc: String = toString(&expr.span);
            let name: String = toString(type);
            fprintf(stderr, "%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n",
                loc.buffer, ERR_STR, name.buffer);
            drop(&name);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_BLANK_FOR_NULL);
        } else if (isPrimitive(type)) {
            let loc: String = toString(&expr.span);
            let name: String = toString(type);
            fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n",
                loc.buffer, WARN_STR, name.buffer);
            drop(&name);
            drop(&loc);
        }
        tid = newTCStateType(type);
    } else if (expr.kind == EXPR_BINARY) {
        if (isArithmetic(expr) || isBitwise(expr)) {
            tid = tryInferTypeOntoExpr(this, expr.lhs, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = tryInferTypeOntoExpr(this, expr.rhs, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(type);
        } else if (isComparison(expr)) {
            // Assuming that neither side has a type (otherwise typeCheckExprComparison would've handled the infer step)
            // So all that's left is whack things like `1 == 1`, for which we blindly try to infer usize onto both sides
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(usizeType), scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = tryInferTypeOntoExpr(this, expr.rhs, getID(usizeType), scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(type);
        } else if (expr.op == BIN_DOT) {
            tid = tryInferTypeOntoMemberAccess(this, expr, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
        } else if (expr.op == BIN_MODULE) {
            tid = tryInferTypeOntoModuleAccess(this, expr, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
        } else {
            todo_with_msg("inferTypeOntoExpr for non-arith non-comp binary");
        }
    } else if (expr.kind == EXPR_UNARY) {
        if (expr.op == UNARY_DEREF) {
            let newType: &Type = newType(TYPE_KIND_POINTER, type);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(newType), scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(type);
        } else if (expr.op == UNARY_REF) {
            if (!isPointer(type)) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    let t: String = toString(type);
                    fprintf(stderr, "%s: %s: Expected expression of type %s, found reference.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            let underlying: &Type = getUnderlyingType(type, false);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(underlying), scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(type);
        } else if (expr.op == UNARY_MINUS) {
            // -expr
            // typeof(expr) == typeof(-expr)
            if (!isSignedInteger(type) && !isFloat(type)) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    let t: String = toString(type);
                    fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, expr.lhs, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
            assert(isType(&tid), "infer non-error expected to be a type");
            let subType: &Type = getType(&tid);
            assert(equals(subType, type), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
            tid = newTCStateType(type);
        } else if (expr.op == UNARY_NOT) {
            let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(boolType), scopes, checkOnly);
            if (isError(&tid)) return tid;
            todo_with_msg("unary not infer");
        } else {
            unreachable("Exhaustive handling of unary ops in inferTypeOntoExpr");
        }
    } else if (expr.kind == EXPR_NULL) {
        if (!isPointer(type)) todo_with_msg("tried to infer non-ptr to null");
        tid = newTCStateType(type);
    } else if (expr.kind == EXPR_CALL) {
        tid = tryInferTypeOntoCall(this, expr, type, scopes, checkOnly);
        if (isError(&tid)) return tid;
    } else {
        emergencyPrint(this, expr.span);
        todo_with_msg("unhandled case in inferTypeOntoExpr");
    }
    if (!checkOnly) {
        (*expr).typeState = tid;
    }
    return tid;
}

func tryInferTypeOntoCall(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoCall");
    assert(expr.kind == EXPR_CALL);
    let typeID = getID(type);
    let fnType = newType(TYPE_KIND_FUNCTION, typeID);
    let callContext = &expr.arrayContext;
    for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
        let argID: usize = getElementAtIndex(callContext, i);
        push(&fnType.fnParams, at(&exprs, argID).typeState);
    }
    let baseState = tryInferTypeOntoExpr(this, expr.lhs, getID(fnType), scopes, checkOnly);
    if (isError(&baseState)) return baseState;
    if (wantsInfer(&baseState)) {
        return reportFunctionCallTooManyOptions(this, expr);
    }
    assert(isType(&baseState), "tryInferOntoCall: Base is not a type");
    let baseFunc = getType(&baseState);
    assert(isFunction(baseFunc), "tryInferTypeOntoCall: Base is not a function");
    assert(baseFunc.typeIndex == typeID, "tryInferTypeOntoCall: Base return type doesn't match expected");
    assert(baseFunc.fnParams.length == callContext.elemLength, "tryInferTypeOntoCall: Base expects different count of arguments");
    let state: TCState = newTCStateSuccess();
    for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
        let p = getParam(baseFunc, i);
        let s1 = tryInferTypeOntoExpr(this, getElementAtIndex(callContext, i), getType(p), scopes, checkOnly);
        if (isError(&s1)) {
            state = s1;
        }
    }
    if (!isSuccess(&state)) {
        todo_with_msg("infer arg failed");
    }
    if (checkOnly) return newTCStateSuccess();
    return newTCStateType(type);
}

func tryInferTypeOntoMemberAccess(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoMemberAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_DOT);
    let lhs = at(&exprs, expr.lhs);
    let rhs = at(&exprs, expr.rhs);
    if (rhs.kind == EXPR_NAME) {
        let name = rhs.origToken;
        let structs = resolveAllStructsWithField(this.currentModule, &name, type);
        if (structs.length == 0) {
            return reportMemberAccessNoOptions(this, expr);
        } else if (structs.length == 1) {
            let strukt = at(&structs, 0);
            let state = tryInferTypeOntoExpr(this, expr.lhs, strukt.type, scopes, checkOnly);
            if (isError(&state)) return state;
            if (checkOnly) return newTCStateSuccess();
            return newTCStateType(type);
        } else {
            if (!checkOnly) {
                return reportMemberAccessTooManyOptions(this, expr, &structs);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
    } else if (rhs.kind == EXPR_CALL) {
        todo_with_msg("infer member call");
    } else {
        unreachable("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess");
    }
}

func tryInferTypeOntoModuleAccess(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoModuleAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_MODULE);
    let lhs = at(&exprs, expr.lhs);
    let lhsState = lhs.typeState;
    if (!isSuccess(&lhsState)) return lhsState;
    if (!isType(&lhsState)) return lhsState;
    let lhsType = getType(&lhsState);
    assert(isModule(lhsType), "LHS of BIN_MODULE is not of type module!");
    let lookup = getModuleByGlobalID(this.currentModule, lhsType.typeIndex);
    let rhs = at(&exprs, expr.rhs);
    let tid: TCState = blank;
    if (rhs.kind == EXPR_NAME) {
        assert(isFunction(type), "Can only try to infer functions onto module identifiers for now");
        let functions = resolveAllFunctionsWithSignature(lookup, &rhs.origToken, type);
        if (functions.length == 0) {
            if (checkOnly) {
                tid = newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
            } else {
                let all = resolveFunctionByName(lookup, &rhs.origToken);
                tid = reportNoFunctionCallCandidate(this, at(&exprs, expr.rhs), type, &all);
                drop(&all);
            }
        } else if (functions.length == 1) {
            let f = at(&functions, 0);
            assert(f.params.length == type.fnParams.length);
            if (!checkOnly) {
                rhs.lhs = f.globalID;
            }
            tid = f.fnType;
        } else {
            tid = newTCStatePleaseInfer();
        }
        rhs.typeState = tid;
        drop(&functions);
    } else {
        unreachable("Exhaustive handling of possibilities in tryInferTypeOntoModuleAccess");
    }
    expr.typeState = tid;
    return tid;
}

func typeCheckExprArithmetic(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprArithmetic");
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(isArithmetic(expr), "Expr expected to be arithmetic");
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let lhsPointer: bool = false;
    let rhsPointer: bool = false;
    if (isType(&lhsState)) if (isPointer(getType(&lhsState))) lhsPointer = true;
    if (isType(&rhsState)) if (isPointer(getType(&rhsState))) rhsPointer = true;
    if (lhsPointer || rhsPointer) {
        if (expr.op != BIN_PLUS && expr.op != BIN_SUB) {
            return reportInvalidPointerArithmetics(this, 
                expr.op,
                at(&exprs, expr.lhs).span,
                at(&exprs, expr.rhs).span,
            );
        }
    }
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let resultState: TCState = blank;
    if (equals(lhsType, rhsType)) {
        if (isChar(lhsType) && expr.op != BIN_PLUS && expr.op != BIN_SUB) {
            return reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
        }
        if (isStruct(lhsType) || isArray(lhsType)) {
            return reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
        } else if (isPointer(lhsType)) {
            let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            resultState = newTCStateType(t);
        } else {
            assert(getID(lhsType) == getID(rhsType), "Arithmetic LHS and RHS are different types");
            resultState = newTCStateType(lhsType);
        }
    } else if (isPointer(lhsType) && isInteger(rhsType)) {
        if (rhsType.typeIndex == TYPE_USIZE) {
            resultState = lhsState;
        } else {
            let rhs = at(&exprs, expr.rhs).span;
            let err = reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                rhs, rhsType,
            );
            let loc = toString(&rhs);
            fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
            drop(&loc);
            return err;
        }
    } else if (isInteger(lhsType) && isPointer(rhsType)) {
        if (lhsType.typeIndex == TYPE_USIZE) {
            resultState = rhsState;
        } else {
            let lhs = at(&exprs, expr.lhs).span;
            let err = reportBinaryTypeMismatch(this, 
                expr.op,
                lhs, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
            let loc = toString(&lhs);
            fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
            drop(&loc);
            return err;
        }
    } else {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    return resultState;
}

func typeCheckExprComparison(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprComparison");
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(isComparison(expr), "Expr expected to be comparison");
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in comp");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    if (isStruct(lhsType) || isStruct(rhsType)
        || isArray(lhsType) || isArray(rhsType)) {
        todo_with_msg("report error, can't compare structs or arrays using == or similar.");
    }
    return newTCStateType(newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL));
}

func typeCheckTypeNode(this: &TypeChecker, typeNode: &ParsedTypeNode) -> TCState {
    trace("TypeChecker.typeCheckTypeNode");
    if (typeNode.ignored) return blank;
    if (isSuccess(&typeNode.typeState)) return typeNode.typeState;
    let tid: &Type = null;
    if (typeNode.kind == PARSED_TYPE_FUNC) {
        let retState: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&retState)) return retState;
        let params: TCStateList = blank;
        let fnType = newType(TYPE_KIND_FUNCTION, getID(getType(&retState)));
        let error: TCState = blank;
        for (let i: usize = 0; i < typeNode.fnParams.length; i = i + 1) {
            let state = typeCheckTypeNode(this, *at(&typeNode.fnParams, i));
            if (isError(&state)) {
                error = state;
            }
            push(&params, state);
        }
        if (isError(&error)) return error;
        fnType.fnParams = params;
        tid = fnType;
    } else if (typeNode.kind == PARSED_TYPE_REF) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = newType(TYPE_KIND_POINTER, getID(getType(&under)));
    } else if (typeNode.kind == PARSED_TYPE_ARRAY) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        let t: &Type = newType(TYPE_KIND_ARRAY, getID(getType(&under)));
        (*t).arraySize = typeNode.arraySize;
        tid = t;
    } else if (typeNode.kind == PARSED_TYPE_IDENT) {
        let name: Token = typeNode.nameTkn;
        let typeLookup: TypeLookup = blank;
        if (!resolveTypeByName(this.currentModule, &name, &typeLookup)) {
            let loc: String = getLocation(&name);
            let _n: String = toString(&name.content);
            fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
            let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &TypeLookup = at(&alternatives, i);
                if (isStruct(t)) {
                    let s: &StructLookup = asStruct(t);
                    let loc: String = getLocation(&s.name);
                    fprintf(stderr, "%s: %s: A struct with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
                    drop(&loc);
                }
            }
            drop(&_n);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (isStruct(&typeLookup)) {
            let structLookup: &StructLookup = asStruct(&typeLookup);
            tid = structLookup.type;
            assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
        } else if (isUnion(&typeLookup)) {
            let unionLookup: &UnionLookup = asUnion(&typeLookup);
            tid = unionLookup.type;
            assert(isUnion(tid), "Union Lookup links to non-Union typeNode");
        } else {
            unreachable("Exhaustive handling of TypeLookup kinds in typeCheckTypeNode");
        }
    } else if (typeNode.kind == PARSED_TYPE_MODULE) {
        let _orig = typeNode;
        let moduleLookup: &ModuleLookup = null;
        let name = typeNode.nameTkn;
        if (!resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
            return reportUnknownModule(this, name);
        }
        while (true) {
            let sub = typeNode.underlyingID;
            if (sub.underlyingID == null) {
                let lookup: TypeLookup = blank;
                if (!resolveTypeByName(moduleLookup, &sub.nameTkn, &lookup)) {
                    return reportUnknownType(this, moduleLookup, sub.nameTkn, blank);
                }
                if (isStruct(&lookup)) {
                    let structLookup: &StructLookup = asStruct(&lookup);
                    tid = structLookup.type;
                    assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
                    break;
                } else {
                    todo_with_msg("module::<typeNode> with typeNode != struct");
                }
            } else {
                name = sub.nameTkn;
                let newModule: &ModuleLookup = null;
                if (!resolveModuleByName(moduleLookup, &name, &newModule)) {
                    return reportUnknownSubmodule(this, moduleLookup, name);
                }
                let modType = newType(TYPE_KIND_MODULE, newModule.globalID);
                typeNode.typeState = newTCStateType(modType);
                typeNode = sub;
                moduleLookup = newModule;
            }
        }
        typeNode = _orig;
    } else if (typeNode.kind == PARSED_TYPE_BUILTIN) {
        let id: usize = getID(typeNode);
        let typeID: usize = 0;
        if (id == PARSED_TYPE_INVALID) typeID = TYPE_INVALID;
        else if (id == PARSED_TYPE_UNKNOWN) typeID = TYPE_UNKNOWN;
        else if (id == PARSED_TYPE_NONE) typeID = TYPE_NONE;
        else if (id == PARSED_TYPE_ANY) typeID = TYPE_ANY;
        else if (id == PARSED_TYPE_I8) typeID = TYPE_I8;
        else if (id == PARSED_TYPE_I16) typeID = TYPE_I16;
        else if (id == PARSED_TYPE_I32) typeID = TYPE_I32;
        else if (id == PARSED_TYPE_I64) typeID = TYPE_I64;
        else if (id == PARSED_TYPE_U8) typeID = TYPE_U8;
        else if (id == PARSED_TYPE_U16) typeID = TYPE_U16;
        else if (id == PARSED_TYPE_U32) typeID = TYPE_U32;
        else if (id == PARSED_TYPE_U64) typeID = TYPE_U64;
        else if (id == PARSED_TYPE_USIZE) typeID = TYPE_USIZE;
        else if (id == PARSED_TYPE_BOOL) typeID = TYPE_BOOL;
        else if (id == PARSED_TYPE_CHAR) typeID = TYPE_CHAR;
        else if (id == PARSED_TYPE_F32) typeID = TYPE_F32;
        else if (id == PARSED_TYPE_F64) typeID = TYPE_F64;
        else {
            unreachable("Exhaustive handling of parsed types in typeCheckTypeNode");
        }
        tid = newType(TYPE_KIND_PRIMITIVE, typeID);
    } else {
        todo_with_msg("unknown typeNode kind");
    }
    let state: TCState = newTCStateType(tid);
    typeNode.typeState = state;
    return state;
}

func newTypeChecker() -> TypeChecker {
    return TypeChecker {
        isComptimeContext: false,
        currentModule: null,
        currentFunction: null,
        lookup: blank,
        typeError: false,
    };
}
