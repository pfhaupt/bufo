import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

comptime ERROR_INVALID: usize = 0;
comptime ERROR_NO_SUCH_IDENTIFIER: usize = 1;
comptime ERROR_NO_SUCH_FUNCTION: usize = 2;
comptime ERROR_NO_SUCH_METHOD: usize = 3;
comptime ERROR_USE_BEFORE_DECLARATION: usize = 4;
comptime ERROR_FIELD_COUNT_MISMATCH: usize = 5;
comptime ERROR_INDEXED_TYPE_MISMATCH: usize = 6;
comptime ERROR_UNEXPECTED_LITERAL: usize = 7;
comptime ERROR_ARRAY_SIZE_MISMATCH: usize = 8;
comptime ERROR_TYPE_MISMATCH: usize = 9;
comptime ERROR_INVALID_POINTER_ARITHMETIC: usize = 10;
comptime ERROR_DUPLICATE_PARAMETER: usize = 11;
comptime ERROR_DUPLICATE_FIELD: usize = 12;
comptime ERROR_UNKNOWN_FIELD: usize = 13;
comptime ERROR_DUPLICATE_FUNCTION: usize = 14;
comptime ERROR_NO_CALL_CANDIDATE: usize = 15;
comptime ERROR_VARIABLE_REDECLARATION: usize = 16;
comptime ERROR_RECURSIVE_TYPE: usize = 17;
comptime ERROR_DUPLICATE_METHOD: usize = 18;
comptime ERROR_BLANK_FOR_NULL: usize = 19;
comptime ERROR_NON_PRIMITIVE_CAST: usize = 20;
comptime ERROR_INDEXED_ACCESS_ON_NON_ARRAY: usize = 21;
comptime ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT: usize = 22;
comptime ERROR_ANY_DEREF: usize = 23;
comptime ERROR_MEMBER_ACCESS_NON_STRUCT: usize = 24;
comptime ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS: usize = 25;
comptime ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS: usize = 26;

comptime TCSTATE_INVALID: usize = 0;
comptime TCSTATE_ERROR: usize = 1;
comptime TCSTATE_PLEASE_INFER: usize = 2;
comptime TCSTATE_TYPE: usize = 3;
struct TCState {
    kind: usize;
    typ: usize;
    name: Token;
}

func equals(this: &TCState, other: &TCState) -> bool {
    todo_with_msg("TCState.equals");
}

func isInvalid(this: &TCState) -> bool {
    return this.kind == TCSTATE_INVALID;
}
func wantsInfer(this: &TCState) -> bool {
    return this.kind == TCSTATE_PLEASE_INFER;
}
func isCriticalError(this: &TCState) -> bool {
    if (!isError(this)) return false;
    let err: usize = getError(this);
    return err == ERROR_NO_SUCH_IDENTIFIER
        || err == ERROR_NO_SUCH_FUNCTION
        || err == ERROR_NO_SUCH_METHOD
        || err == ERROR_DUPLICATE_FUNCTION
        || err == ERROR_DUPLICATE_METHOD
        || err == ERROR_DUPLICATE_FIELD;
}
func isError(this: &TCState) -> bool {
    return this.kind == TCSTATE_ERROR;
}

func isSuccess(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE;
}

func isType(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE;
}

func getType(this: &TCState) -> usize {
    if (!isType(this)) {
        fprintf(stderr, "ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.typ;
}
func getError(this: &TCState) -> usize {
    if (!isError(this)) {
        fprintf(stderr, "ERROR: getError(&TCState) called on non-error TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.typ;
}

func newTCStateSuccess() -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: 0,
        name: blank,
    };
}

func newTCStateType(typ: usize) -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: typ,
        name: blank,
    };
}

func newTCStateFailure(error: usize) -> TCState {
    return TCState {
        kind: TCSTATE_ERROR,
        typ: error,
        name: blank,
    };
}

func newTCStatePleaseInfer() -> TCState {
    return TCState {
        kind: TCSTATE_PLEASE_INFER,
        typ: 0,
        name: blank,
    };
}

struct TypeChecker {
    isComptimeContext: bool;
    currentModule: usize;
    currentFunction: &FunctionLookup;
    lookup: Lookup;
    typeError: bool;
}

func reportTypeMismatch(this: &TypeChecker, span: Span, expected: &Type, got: &Type) -> TCState {
    trace("TypeChecker.reportTypeMismatch");
    let loc: String = toString(&span);
    let typ1: String = toString(expected);
    let typ2: String = toString(got);
    fprintf(stderr, "%s: %s: Type mismatch! Expected type %s, found type %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportBinaryTypeMismatch(this: &TypeChecker, op: usize, lhsSpan: Span, lhsType: &Type, rhsSpan: Span, rhsType: &Type) -> TCState {
    trace("TypeChecker.reportBinaryTypeMismatch");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    let loc1: String = toString(&lhsSpan);
    let loc2: String = toString(&rhsSpan);
    let typ1: String = toString(lhsType);
    let typ2: String = toString(rhsType);
    fprintf(stderr, "%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n",
        loc.buffer, ERR_STR, typ1.buffer, binOpAsStr(op), typ2.buffer);
    fprintf(stderr, "%s: %s: LHS has type %s.\n", loc1.buffer, NOTE_STR, typ1.buffer);
    fprintf(stderr, "%s: %s: RHS has type %s.\n", loc2.buffer, NOTE_STR, typ2.buffer);
    drop(&typ2);
    drop(&typ1);
    drop(&loc2);
    drop(&loc1);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportInvalidPointerArithmetics(this: &TypeChecker, op: usize, lhsSpan: Span, rhsSpan: Span) -> TCState {
    trace("TypeChecker.reportInvalidPointerArithmetics");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    fprintf(stderr, "%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n",
        loc.buffer, ERR_STR, binOpAsStr(op));
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INVALID_POINTER_ARITHMETIC);
}

func reportDuplicateField(this: &TypeChecker, fieldToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateField");
    let duplLoc: String = toString(&fieldToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&fieldToken.content);
    fprintf(stderr, "%s: %s: Field redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FIELD);
}

func reportDuplicateParameter(this: &TypeChecker, paramToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateParameter");
    let duplLoc: String = toString(&paramToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&paramToken.content);
    fprintf(stderr, "%s: %s: Parameter redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Parameter `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_PARAMETER);
}

func reportUnknownField(this: &TypeChecker, name: Token, decl: &StructLookup) -> TCState {
    trace("TypeChecker.reportUnknownField");
    let errLoc: String = toString(&name.span);
    let declLoc: String = toString(&decl.name.span);
    let strukt: String = toString(&decl.name.content);
    let field: String = toString(&name.content);
    fprintf(stderr, "%s: %s: Attempted to access unknown field `%s` of instance of struct %s.\n", errLoc.buffer, ERR_STR, field.buffer, strukt.buffer);
    fprintf(stderr, "%s: %s: Struct %s is declared here.\n", declLoc.buffer, NOTE_STR, strukt.buffer);
    drop(&field);
    drop(&strukt);
    drop(&declLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_UNKNOWN_FIELD);
}

func reportDuplicateFunction(this: &TypeChecker, f1: &FunctionLookup, f2: &FunctionLookup) -> TCState {
    trace("TypeChecker.reportDuplicateFunction");
    let errLoc: String = toString(&f1.name.span);
    let duplLoc: String = toString(&f2.name.span);
    let name: String = toString(&f1.name.content);
    fprintf(stderr, "%s: %s: Function redeclaration.\n", errLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: A function named `%s` with that signature is already declared here.\n", duplLoc.buffer, ERR_STR, name.buffer);
    drop(&name);
    drop(&duplLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FUNCTION);
}

func reportNoFunctionCallCandidate(this: &TypeChecker, callID: usize, functions: &FunctionLookupList) -> TCState {
    trace("TypeChecker.reportNoFunctionCallCandidate");
    let callExpr: &ParsedExpr = at(&exprs, callID);
    assert(callExpr.kind == EXPR_CALL, "reportNoFunctionCallCandidate: Expected expr to be a call");
    let loc: String = toString(&callExpr.origToken.span);
    let name: String = toString(&callExpr.origToken.content);
    fprintf(stderr, "%s: %s: Could not find matching signature for call to function `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    assert(functions.length != 0, "reportNoFunctionCallCandidate: Expected at least one declaration");
    // REVIEW: It was suggested that we could hide this extra info behind a `--verbose` flag, which sounds interesting.
    for (let i: usize = 0; i < functions.length; i = i + 1) {
        let f: &FunctionLookup = at(functions, i);
        let loc: String = toString(&f.name.span);
        fprintf(stderr, "%s: %s: A function with that name is located here.\n", loc.buffer, NOTE_STR);
        drop(&loc);
    }
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_CALL_CANDIDATE);
}

func reportVariableRedeclaration(this: &TypeChecker, newDecl: Token, oldDecl: Token) -> TCState {
    trace("TypeChecker.reportVariableRedeclaration");
    let newLoc: String = toString(&newDecl.span);
    let oldLoc: String = toString(&oldDecl.span);
    let name: String = toString(&newDecl.content);
    fprintf(stderr, "%s: %s: Variable redeclaration.\n", newLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` already declared here.\n", oldLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&oldLoc);
    drop(&newLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_VARIABLE_REDECLARATION);
}

func reportRecursiveType(this: &TypeChecker, checked: &TypeLookup, cycle: &TypeLookupList) -> TCState {
    trace("TypeChecker.reportRecursiveType");
    let loc: String = getLocation(checked);
    let name: String = getName(checked);
    fprintf(stderr, "%s: %s: Recursive type %s.\n", loc.buffer, ERR_STR, name.buffer);
    assert(cycle.length >= 1, "Cycle is empty");
    for (let i: usize = 1; i < cycle.length; i = i + 1) {
        loc = getLocation(at(cycle, i));
        name = getName(at(cycle, i));
        fprintf(stderr, "%s: %s: Chain of recursion also includes type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    }
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RECURSIVE_TYPE);
}

func reportNonPrimitiveCast(this: &TypeChecker, span: Span, from: &Type, to: &Type) -> TCState {
    trace("TypeChecker.reportNonPrimitiveCast");
    let loc: String = toString(&span);
    let typ1: String = toString(from);
    let typ2: String = toString(to);
    fprintf(stderr, "%s: %s: Non primitive cast from type %s to %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NON_PRIMITIVE_CAST);
}

func reportIndexedAccessOnNonArray(this: &TypeChecker, span: Span, typ: &Type) -> TCState {
    trace("TypeChecker.reportIndexedAccessOnNonArray");
    let loc: String = toString(&span);
    let name: String = toString(typ);
    fprintf(stderr, "%s: %s: Indexed Access is only supported for arrays.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Expression has type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
}

func reportRuntimeValueInComptimeContext(this: &TypeChecker, ident: Token, var: &VariableLookup) -> TCState {
    trace("TypeChecker.reportRuntimeValueInComptimeContext");
    let loc = toString(&ident.span);
    let otherLoc = toString(&var.name.span);
    let name = toString(&ident.content);
    fprintf(stderr, "%s: %s: Variables declared with `let` can't be used in a comptime context.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` is declared here.\n", otherLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&otherLoc);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT);
}

func reportAnyDereference(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    trace("TypeChecker.reportAnyDereference");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Can't dereference expression of type Any.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_ANY_DEREF);
}

func reportMemberAccessOnNonStruct(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    trace("TypeChecker.reportMemberAccessOnNonStruct");
    let loc = toString(&expr.span);
    let t = toString(instance);
    fprintf(stderr, "%s: %s: The Dot-Operator is not defined for values of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_NON_STRUCT);
}

func reportMemberAccessTooManyOptions(this: &TypeChecker, expr: &ParsedExpr, structs: &StructLookupList) -> TCState {
    trace("TypeChecker.reportMemberAccessTooManyOptions");
    assert(structs.length > 0);
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    for (let i: usize = 0; i < structs.length; i = i + 1) {
        let s = at(structs, i);
        let l = toString(&s.name.span);
        let n = toString(&s.name.content);
        fprintf(stderr, "%s: %s: Context allows struct %s to be used.\n", l.buffer, NOTE_STR, n.buffer);
        drop(&n);
        drop(&l);
    }
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS);
}

func reportFunctionCallTooManyOptions(this: &TypeChecker, expr: &ParsedExpr, functions: &FunctionLookupList) -> TCState {
    trace("TypeChecker.reportFunctionCallTooManyOptions");
    assert(functions.length > 0);
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which function to call.\n", loc.buffer, ERR_STR);
    for (let i: usize = 0; i < functions.length; i = i + 1) {
        let f = at(functions, i);
        let l = toString(&f.name.span);
        let n = toString(&f.name.content);
        fprintf(stderr, "%s: %s: Context allows this function to be called.\n", l.buffer, NOTE_STR, n.buffer);
        drop(&n);
        drop(&l);
    }
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS);
}

func emergencyPrint(this: &TypeChecker, where: Span) {
    let t: Token = Token {
        span: where,
        content: newSubStrOfStrLit(""),
        kind: TOKEN_EOF
    };
    printf("%s\n", getLocation(&t).buffer);
}

func typeCheckProject(this: &TypeChecker, project: &ParsedModule) -> bool {
    trace("TypeChecker.typeCheckProject");
    if (!fillLookup(this)) return false;
    if (!typeCheckModules(this)) return false;
    if (findRecursiveTypes(this)) return false;
    return !this.typeError;
}

func dfs(this: &TypeChecker, typeLookup: TypeLookup, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    trace("TypeChecker.dfs");
    if (contains(finished, &typeLookup))
        return false;
    if (contains(visited, &typeLookup))
        return true;
    push(visited, typeLookup);
    let done: bool = false;
    if (isStruct(&typeLookup)) {
        let strukt: &StructLookup = asStruct(&typeLookup);
        for (let i: usize = 0; i < strukt.fields.length; i = i + 1) {
            let field: &VariableLookup = at(&strukt.fields, i);
            assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
            let fieldTypeID: usize = getType(&field.typeState);
            let fieldType: &Type = at(&types, fieldTypeID);
            if (isStructArray(fieldType)) {
                let typeID: usize = fieldType.typeIndex;
                let elemType: &Type = at(&types, typeID);
                assert(isStruct(elemType));
                let structID: usize = elemType.typeIndex;
                let decl: &ParsedStructDecl = at(&structDecls, structID);
                let mod: &ModuleLookup = at(&this.lookup.modules, decl.parentModule);
                let strukt: &StructLookup = getStructByGlobalID(mod, structID);
                if (dfs(this, asTypeLookup(strukt), visited, finished)) {
                    done = true;
                }
            } else if (isStruct(fieldType)) {
                let structID: usize = fieldType.typeIndex;
                let decl: &ParsedStructDecl = at(&structDecls, structID);
                let mod: &ModuleLookup = at(&this.lookup.modules, decl.parentModule);
                let strukt: &StructLookup = getStructByGlobalID(mod, structID);
                if (dfs(this, asTypeLookup(strukt), visited, finished)) {
                    done = true;
                }
            }
        }
    } else {
        todo_with_msg("dfs on non-struct");
    }
    push(finished, typeLookup);
    return done;
}

func findRecursiveTypes(this: &TypeChecker) -> bool {
    trace("TypeChecker.findRecursiveTypes");
    let recursive: bool = false;
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl: &ParsedStructDecl = at(&structDecls, i);
        let mod: &ModuleLookup = at(&this.lookup.modules, decl.parentModule);
        let strukt: &StructLookup = getStructByGlobalID(mod, i);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(strukt), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(strukt), &visited);
            recursive = true;
        }
    }
    return recursive;
}

func fillLookup(this: &TypeChecker) -> bool {
    trace("TypeChecker.fillLookup");
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        assert(getID(mod) == i);
        this.currentModule = i;
        let lookup: &ModuleLookup = insertModule(&this.lookup, mod);
        for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
            let tliID: usize = getTopLevelItemAtIndex(mod, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.ignored) continue;
            insertTLI(lookup, tli);
        }
    }
    return true;
}

func typeCheckModules(this: &TypeChecker) -> bool {
    trace("TypeChecker.typeCheckModules");
    let success = true;
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        assert(getID(mod) == i);
        this.currentModule = i;
        for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
            let tliID: usize = getTopLevelItemAtIndex(mod, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_STRUCT_DECL) {
                let state = typeCheckStructDecl(this, tli.nodeID);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        assert(getID(mod) == i);
        this.currentModule = i;
        let currentModule: &ModuleLookup = at(&this.lookup.modules, this.currentModule);
        assert(currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
            let tliID: usize = getTopLevelItemAtIndex(mod, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        assert(getID(mod) == i);
        this.currentModule = i;
        let currentModule: &ModuleLookup = at(&this.lookup.modules, this.currentModule);
        assert(currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
            let tliID: usize = getTopLevelItemAtIndex(mod, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_VAR_DECL) {
                let state = typeCheckVarDecl(this, tli.nodeID, &currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < modules.length; i = i + 1) {
        let mod: &ParsedModule = at(&modules, i);
        assert(getID(mod) == i);
        this.currentModule = i;
        let currentModule: &ModuleLookup = at(&this.lookup.modules, this.currentModule);
        assert(currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
            let tliID: usize = getTopLevelItemAtIndex(mod, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &currentModule.variables, false);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    return true;
}

func typeCheckStructDecl(this: &TypeChecker, structID: usize) -> TCState {
    trace("TypeChecker.typeCheckStructDecl");
    let strukt: &ParsedStructDecl = at(&structDecls, structID);
    if (strukt.ignored) return blank;
    let moduleLookup: &ModuleLookup = at(&this.lookup.modules, this.currentModule);
    let structLookup: &StructLookup = getStructByGlobalID(moduleLookup, structID);
    let context: &StructContext = &strukt.context;
    let result: TCState = newTCStateSuccess();
    if (!getReadyState(structLookup, STRUCT_READY_TO_USE)) {
        if (!getReadyState(structLookup, STRUCT_FIELDS_COMPLETE)) {
            let failure: TCState = blank;
            for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
                let name: Token = getFieldNameAtIndex(context, i);
                let typ: usize = getFieldTypeAtIndex(context, i);
                let dupl: VariableLookup = blank;
                if (checkForDuplicateField(structLookup, &name, &dupl)) {
                    failure = reportDuplicateField(this, name, dupl.name.span);
                    continue;
                }
                let state: TCState = typeCheckTypeNode(this, typ);
                if (isError(&state)) {
                    failure = state;
                    continue;
                }
                addField(structLookup, NODE_ID_OFFSET + i, name, state);
            }
            if (!isInvalid(&failure)) return failure;
            setReadyState(structLookup, STRUCT_FIELDS_COMPLETE);
        }
        setReadyState(structLookup, STRUCT_READY_TO_USE);
    }
    (*strukt).typeState = newTCStateSuccess();
    return result;
}

func typeCheckFunction(this: &TypeChecker, funcID: usize, scopes: &ScopeLookupList, signatureOnly: bool) -> TCState {
    trace("TypeChecker.typeCheckFunction");
    let function: &ParsedFuncDecl = at(&funcDecls, funcID);
    if (function.ignored) return blank;
    let moduleLookup: &ModuleLookup = at(&this.lookup.modules, this.currentModule);
    let funcLookup: &FunctionLookup = getFunctionByGlobalID(moduleLookup, funcID);
    if (getReadyState(funcLookup, FUNC_BODY_COMPLETE)) {
        assert(getReadyState(funcLookup, FUNC_READY_TO_USE), "Function should be ready to use at this point");
        return function.typeState;
    }
    this.currentFunction = funcLookup;
    if (!getReadyState(funcLookup, FUNC_READY_TO_USE)) {
        if (!getReadyState(funcLookup, FUNC_PARAMS_COMPLETE)) {
            let failure: TCState = blank;
            clear(&funcLookup.params);
            for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
                let typ: usize = getTypeAtIndex(&function.params, i);
                let name: Token = getNameAtIndex(&function.params, i);
                let dupl: VariableLookup = blank;
                if (checkForDuplicateParam(funcLookup, &name, &dupl)) {
                    failure = reportDuplicateParameter(this, name, dupl.name.span);
                    setReadyState(funcLookup, FUNC_PARAMS_COMPLETE);
                    continue;
                }
                let state: TCState = typeCheckTypeNode(this, typ);
                if (isError(&state)) {
                    failure = state;
                    continue;
                }
                addParameter(funcLookup, NODE_ID_OFFSET + i, name, state);
            }
            if (!isInvalid(&failure)) return failure;
            setReadyState(funcLookup, FUNC_PARAMS_COMPLETE);
        }
        if (!getReadyState(funcLookup, FUNC_RETTYPE_COMPLETE)) {
            let retState: TCState = typeCheckTypeNode(this, function.retTypeID);
            if (isError(&retState)) return retState;
            setReturnType(funcLookup, retState);
            setReadyState(funcLookup, FUNC_RETTYPE_COMPLETE);
        }
        setReadyState(funcLookup, FUNC_READY_TO_USE);
    }
    if (signatureOnly) {
        return newTCStateSuccess();
    }
    (*function).typeState = newTCStateSuccess();
    if (!getReadyState(funcLookup, FUNC_DUPLICATE_CHECK)) {
        // FIXME: We need to use usize because the bootstrap doesn't support nested references :^)
        let _dupl: usize = 0;
        if (containsDuplicateFunction(moduleLookup, funcLookup, &_dupl)) {
            assert(_dupl != 0, "Duplicate FunctionLookup is null");
            return reportDuplicateFunction(this, funcLookup, _dupl as &FunctionLookup);
        }
        setReadyState(funcLookup, FUNC_DUPLICATE_CHECK);
    }
    if (!getReadyState(funcLookup, FUNC_BODY_COMPLETE)) {
        let scope: ScopeLookup = blank;
        for (let i: usize = 0; i < funcLookup.params.length; i = i + 1) {
            addVariable(&scope, *(at(&funcLookup.params, i)));
        }
        if (!isExtern(function)) {
            push(scopes, scope);
            let blockState: TCState = typeCheckBlock(this, function.body, scopes);
            pop(scopes);
            if (isError(&blockState)) {
                return blockState;
            }
        }
        setReadyState(funcLookup, FUNC_BODY_COMPLETE);
    }
    return function.typeState;
}

func typeCheckBlock(this: &TypeChecker, blockID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckBlock");
    let block: &ParsedBlock = at(&blocks, blockID);
    if (block.ignored) return blank;
    if (isSuccess(&block.typeState)) {
        return block.typeState;
    }
    push(scopes, ScopeLookup {
        variables: blank,
    });
    let curr: usize = scopes.length;
    // REVIEW: Do we want to make blocks expressions?
    let blockState: TCState = newTCStateSuccess();
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmtState: TCState = typeCheckStmt(this, getStmtAtIndex(block, i), scopes);
        if (isError(&stmtState)) {
            let err: usize = getError(&stmtState);
            blockState = stmtState;
        }
    }
    let after: usize = scopes.length;
    pop(scopes);
    assert(after == curr, "Stack imbalance");
    if (isError(&blockState)) return blockState;
    (*block).typeState = newTCStateSuccess();
    return block.typeState;
}

func typeCheckStmt(this: &TypeChecker, stmtID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckStmt");
    let stmt: &ParsedStmt = at(&stmts, stmtID);
    if (stmt.ignored) return blank;
    if (stmt.kind == STMT_BLOCK) {
        let blockState: TCState = typeCheckBlock(this, stmt.block, scopes);
        if (isError(&blockState)) return blockState;
        (*stmt).typeState = blockState;
        return blockState;
    } else if (stmt.kind == STMT_VAR_DECL) {
        return typeCheckVarDecl(this, stmtID, scopes, false);
    } else if (stmt.kind == STMT_EXPR) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let exprState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        if (isError(&exprState)) return exprState;
        if (wantsInfer(&exprState)) todo_with_msg("stmt expr infer");
        let expr: &ParsedExpr = at(&exprs, stmt.expr);
        if (!isType(&exprState)) {
            printf("%llu\n", exprState.kind);
            todo_with_msg("what is it then");
        }
        let exprType: &Type = at(&types, getType(&exprState));
        if (!isNone(exprType) && !isAssignment(expr) && *flags.verbose) {
            let loc: String = toString(&expr.span);
            fprintf(stderr, "%s: %s: Unused expression value.\n", loc.buffer, WARN_STR);
            drop(&loc);
        }
        (*stmt).typeState = exprState;
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_IF) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let condState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        let thenState: TCState = typeCheckStmt(this, stmt.ifContext.thenBody, scopes);
        let elseState: TCState = newTCStateSuccess();
        if (stmt.ifContext.hasElse) {
            elseState = typeCheckStmt(this, stmt.ifContext.elseBody, scopes);
        }
        if (isError(&condState)) return condState;
        if (isError(&thenState)) return thenState;
        if (isError(&elseState)) return elseState;
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        if (wantsInfer(&condState)) {
            condState = inferTypeOntoExpr(this, stmt.expr, getID(boolType));
            assert(isType(&condState), "Could not infer type onto if-condition");
        }
        let condType: &Type = at(&types, getType(&condState));
        if (!isBoolean(condType)) {
            return reportTypeMismatch(this, at(&exprs, stmt.expr).span, boolType, condType);
        }
        let state: TCState = newTCStateSuccess();
        (*stmt).typeState = state;
        return state;
    } else if (stmt.kind == STMT_RETURN_EXPR) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let exprState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        if (isError(&exprState)) return exprState;
        assert(this.currentFunction != null);
        assert(getReadyState(this.currentFunction, FUNC_READY_TO_USE), "Function is not ready");
        let _retType: &Type = at(&types, getType(&this.currentFunction.returnType));
        if (isNone(_retType)) todo_with_msg("unexpected ret expr where empty function");
        let retState: &TCState = &this.currentFunction.returnType;
        assert(isSuccess(retState), "ready to use function has invalid return type");
        assert(isType(retState), "ready to use function has non-type as return type");
        if (wantsInfer(&exprState)) {
            exprState = inferTypeOntoExpr(this, stmt.expr, getType(retState));
            if (isError(&exprState)) return exprState;
            assert(isType(&exprState), "Failed to infer type of return expression");
        }
        let exprType: &Type = at(&types, getType(&exprState));
        let retType: &Type = at(&types, getType(retState));
        if (!equals(exprType, retType)) {
            return reportTypeMismatch(this, stmt.span, retType, exprType);
        }
        (*stmt).typeState = *retState;
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_RETURN_EMPTY) {
        assert(this.currentFunction != null);
        assert(getReadyState(this.currentFunction, FUNC_READY_TO_USE), "Function is not ready");
        let retType: &Type = at(&types, getType(&this.currentFunction.returnType));
        if (!isNone(retType)) {
            printf("%s\n", toString(&stmt.span).buffer);
            printf("%llu %llu\n", retType.kind, retType.typeIndex);
            todo_with_msg("function returns something, but we wrote return;");
        }
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_WHILE) {
        if (isSuccess(&stmt.typeState))
            return stmt.typeState;
        let condState: TCState = typeCheckExpr(this, stmt.expr, scopes);
        let bodyState: TCState = typeCheckStmt(this, stmt.block, scopes);
        let stepState: TCState = typeCheckExpr(this, stmt.step, scopes);
        if (isError(&condState)) return condState;
        if (isError(&bodyState)) return bodyState;
        if (isError(&stepState)) return stepState;
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        if (wantsInfer(&condState)) {
            condState = inferTypeOntoExpr(this, stmt.expr, getID(boolType));
            assert(isType(&condState), "Could not infer type onto while-condition");
        }
        let condType: &Type = at(&types, getType(&condState));
        if (!isBoolean(condType)) {
            return reportTypeMismatch(this, at(&exprs, stmt.expr).span, boolType, condType);
        }
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else if (stmt.kind == STMT_BREAK || stmt.kind == STMT_CONTINUE) {
        (*stmt).typeState = newTCStateSuccess();
        return newTCStateSuccess();
    } else {
        unreachable("Exhaustive handling of stmts in typeCheckStmt");
    }
}

func typeCheckVarDecl(this: &TypeChecker, varDeclID: usize, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    trace("TypeChecker.typeCheckVarDecl");
    let varDecl: &ParsedStmt = at(&stmts, varDeclID);
    if (varDecl.ignored) return blank;
    assert(varDecl.kind == STMT_VAR_DECL, "Stmt expected to be a VarDecl");
    let context: VarDeclContext = varDecl.varDeclContext;
    let last: &ScopeLookup = last(scopes);
    let typeState: TCState = blank;
    let exprState: TCState = blank;
    if (isSuccess(&varDecl.typeState)) {
        typeState = varDecl.typeState;
        exprState = varDecl.typeState;
    } else {
        let loc: Token = blank;
        // REVIEW: Warn about shadowing?
        if (!globalScope && isKnownVariable(last, context.name.content, &loc)) {
            return reportVariableRedeclaration(this, context.name, loc);
        }
        if (context.typeID != TYPE_INVALID) {
            typeState = typeCheckTypeNode(this, context.typeID);
            if (isError(&typeState)) return typeState;
            if (!isType(&typeState)) todo_with_msg("let type is not a type");
        }
        this.isComptimeContext = context.isComptime;
        exprState = typeCheckExpr(this, context.exprID, scopes);
        this.isComptimeContext = false;
        if (context.typeID == TYPE_INVALID) {
            // let var = expr;
            assert(isInvalid(&typeState), "`let var = expr;` got valid type state??");
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) {
                todo_with_msg("`let var = expr;` wants inferred expr");
            }
            if (!isType(&exprState)) todo_with_msg("let expr is not a type");
            typeState = exprState;
        } else {
            // let var: type = expr;
            if (wantsInfer(&exprState)) {
                exprState = inferTypeOntoExpr(this, context.exprID, getType(&typeState));
            }
            if (isType(&exprState)) {
                let typeType: &Type = at(&types, getType(&typeState));
                let exprType: &Type = at(&types, getType(&exprState));
                if (!equals(typeType, exprType)) {
                    let exprNode: &ParsedExpr = at(&exprs, context.exprID);
                    exprState = reportTypeMismatch(this, exprNode.span, typeType, exprType);
                }
            }
        }
    }
    if (globalScope) {
        let index: usize = 0;
        assert(getVarIndexByName(last, context.name.content, &index), "Could not find variable in global scope");
        let var: &VariableLookup = getVariableAtIndex(last, index);
        (*var).typeState = typeState;
    } else {
        addVariable(last, VariableLookup {
            globalID: getID(varDecl),
            name: context.name,
            typeState: typeState,
            isComptime: context.isComptime,
        });
    }
    if (isError(&exprState)) return exprState;
    (*varDecl).typeState = typeState;
    return typeState;
}

func typeCheckExpr(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExpr");
    let expr: &ParsedExpr = at(&exprs, exprID);
    if (expr.ignored) return blank;
    if (isSuccess(&expr.typeState)) return expr.typeState;
    let state: TCState = blank;
    if (expr.kind == EXPR_EMPTY) {
        state = newTCStateSuccess();
    } else if (expr.kind == EXPR_INT_LIT) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_STRING_LIT) {
        let ct: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
        let st: &Type = newType(TYPE_KIND_POINTER, getID(ct));
        state = newTCStateType(getID(st));
    } else if (expr.kind == EXPR_CHAR_LIT) {
        let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
        state = newTCStateType(getID(t));
    } else if (expr.kind == EXPR_ARRAY_LIT) {
        let context: &ArrayContext = &expr.arrayContext;
        assert(context.elemLength != 0, "Zero sized Array Literal spotted");
        let elemIndex: usize = getElementAtIndex(context, 0);
        let elemState: TCState = typeCheckExpr(this, elemIndex, scopes);
        if (isError(&elemState)) return elemState;
        if (wantsInfer(&elemState)) return elemState;
        let elemTypeID: usize = getType(&elemState);
        if (context.size == 0) {
            let elemType: &Type = at(&types, elemTypeID);
            let lastErrState: TCState = blank;
            for (let i: usize = 1; i < context.elemLength; i = i + 1) {
                let nextIndex: usize = getElementAtIndex(context, i);
                let nextState: TCState = typeCheckExpr(this, nextIndex, scopes);
                if (isError(&nextState)) {
                    lastErrState = nextState;
                    continue;
                }
                let nextType: &Type = at(&types, getType(&nextState));
                if (!equals(nextType, elemType)) {
                    let loc = toString(&at(&exprs, elemIndex).span);
                    let t = toString(elemType);
                    lastErrState = reportTypeMismatch(this, at(&exprs, nextIndex).span, elemType, nextType);
                    fprintf(stderr, "%s: %s: Array elements inferred to be type %s here.\n", loc.buffer, NOTE_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                }
            }
            if (!isInvalid(&lastErrState)) return lastErrState;
            let t: &Type = newType(TYPE_KIND_ARRAY, elemTypeID);
            (*t).arraySize = context.elemLength;
            state = newTCStateType(getID(t));
        } else {
            let t: &Type = newType(TYPE_KIND_ARRAY, elemTypeID);
            (*t).arraySize = context.size;
            state = newTCStateType(getID(t));
        }
    } else if (expr.kind == EXPR_NAME) {
        state = typeCheckIdentifier(this, exprID, scopes);
    } else if (expr.kind == EXPR_UNARY) {
        state = typeCheckUnary(this, exprID, scopes);
    } else if (expr.kind == EXPR_BINARY) {
        state = typeCheckExprBinary(this, exprID, scopes);
    } else if (expr.kind == EXPR_CALL) {
        state = typeCheckExprCall(this, exprID, scopes);
    } else if (expr.kind == EXPR_SIZEOF) {
        state = typeCheckExprSizeof(this, exprID, scopes);
    } else if (expr.kind == EXPR_STRUCT_INIT) {
        state = typeCheckExprStructInit(this, exprID, scopes);
    } else if (expr.kind == EXPR_AS) {
        state = typeCheckExprAs(this, exprID, scopes);
    } else if (expr.kind == EXPR_NULL) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_BLANK) {
        state = newTCStatePleaseInfer();
    } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
        let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        state = newTCStateType(getID(t));
    } else {
        unreachable("Exhaustive handling of expressions in typeCheckExpr");
    }
    if (isError(&state)) return state;
    (*expr).typeState = state;
    return state;
}

func typeCheckExprSizeof(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprSizeof");
    let expr: &ParsedExpr = at(&exprs, exprID);
    if (isSuccess(&expr.typeState)) return expr.typeState;
    assert(expr.kind == EXPR_SIZEOF);
    let typeState: TCState = typeCheckTypeNode(this, expr.lhs);
    if (isError(&typeState)) return typeState;
    let ut: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
    return newTCStateType(getID(ut));
}

func typeCheckExprAs(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAs");
    let expr: &ParsedExpr = at(&exprs, exprID);
    assert(expr.kind == EXPR_AS);
    let exprState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let typeState: TCState = typeCheckTypeNode(this, expr.rhs);
    if (isError(&exprState)) return exprState;
    if (isError(&typeState)) return typeState;
    assert(isType(&typeState), "typeCheckExprAs Type is not a Type");
    let typeType: &Type = at(&types, getType(&typeState));
    if (wantsInfer(&exprState)) exprState = inferTypeOntoExpr(this, expr.lhs, getID(typeType));
    if (isError(&exprState)) return exprState;
    assert(isType(&exprState), "Expected <expr> in `<expr> as <type>` to have a valid type after infer");
    let exprType: &Type = at(&types, getType(&exprState));
    if (isPointer(typeType) && isPointer(exprType)) {
        // PTR as PTR is allowed
    } else if (isPointer(exprType) && isInteger(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting pointer of type %s to integer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isInteger(exprType) && isPointer(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting integer of type %s to pointer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (!isPrimitive(typeType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    } else if (!isPrimitive(exprType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    }
    if (getSize(typeType) < getSize(exprType) && *flags.verbose) {
        let loc: String = toString(&expr.span);
        let tName: String = toString(typeType);
        let oName: String = toString(exprType);
        fprintf(stderr, "%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n",
            loc.buffer, WARN_STR, tName.buffer, oName.buffer);
        drop(&oName);
        drop(&tName);
        drop(&loc);
    }
    return typeState;
}

func typeCheckUnary(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckUnary");
    let expr: &ParsedExpr = at(&exprs, exprID);
    assert(expr.kind == EXPR_UNARY);
    let exprState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&exprState)) return exprState;
    if (wantsInfer(&exprState)) return exprState; // Can't be done in here
    if (expr.op == UNARY_COMPTIME) {
        return exprState;
    } else if (expr.op == UNARY_DEREF) {
        let exprType: &Type = at(&types, getType(&exprState));
        if (isPrimitive(exprType)) {
            if (exprType.typeIndex == TYPE_ANY) {
                return reportAnyDereference(this, expr);
            }
        }
        if (!isPointer(exprType)) {
            todo_with_msg("deref non-pointer");
        }
        let underlying: &Type = getUnderlyingType(exprType, false);
        return newTCStateType(getID(underlying));
    } else if (expr.op == UNARY_REF) {
        let exprType: &Type = at(&types, getType(&exprState));
        let t: &Type = newType(TYPE_KIND_POINTER, getID(exprType));
        return newTCStateType(getID(t));
    } else if (expr.op == UNARY_NOT) {
        let exprType: &Type = at(&types, getType(&exprState));
        if (!isBoolean(exprType)) {
            let loc: String = toString(&expr.span);
            let t: String = toString(exprType);
            fprintf(stderr, "%s: %s: Logical Not is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
            drop(&t);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        return exprState;
    } else if (expr.op == UNARY_MINUS) {
        let exprType: &Type = at(&types, getType(&exprState));
        if (!isSignedInteger(exprType) && !isFloat(exprType)) {
            let loc: String = toString(&expr.span);
            let t: String = toString(exprType);
            fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
            drop(&t);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        return exprState;
    } else {
        unreachable("Exhaustive handling of ops in typeCheckUnary");
    }
}

func typeCheckExprCall(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprCall");
    // REVIEW: Would be cool if the call base could be any expression, not just an identifier
    let expr: &ParsedExpr = at(&exprs, exprID);
    assert(expr.kind == EXPR_CALL);
    let name: Token = expr.origToken;
    let functions: FunctionLookupList = resolveFunctionByName(&this.lookup, this.currentModule, &name);
    if (functions.length == 0) {
        let loc: String = getLocation(&name);
        let n: String = toString(&name.content);
        fprintf(stderr, "%s: %s: Call to unknown function `%s`.\n", loc.buffer, ERR_STR, n.buffer);
        let alternatives: FunctionLookupList = searchAllModulesForFunctionName(&this.lookup, &name);
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &FunctionLookup = at(&alternatives, i);
            let loc: String = getLocation(&t.name);
            fprintf(stderr, "%s: %s: A function with that name is located here. Import the module to use it.\n", loc.buffer, NOTE_STR);
            drop(&loc);
        }
        drop(&n);
        drop(&loc);
        this.typeError = true;
        return newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
    }
    let callContext: &ArrayContext = &expr.arrayContext;
    let arguments: TCStateList = blank;
    for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
        let argID: usize = getElementAtIndex(callContext, i);
        let arg: TCState = typeCheckExpr(this, argID, scopes);
        if (isError(&arg)) return arg;
        push(&arguments, arg);
    }
    assert(arguments.length == callContext.elemLength);
    let candidates: FunctionLookupList = blank;
    let mark: TCState = markFunctionCallCandidates(this, callContext, &functions, &candidates, &arguments);
    if (isError(&mark)) return mark;
    // functions contains all functions with the same amount of arguments and
    // candidates where infer-semantics could validate the function
    // e.g. foo(i: i32) + foo(i: u64) for foo(5)
    let globalID: usize = 0;
    let sweep: TCState = selectFunctionCallCandidate(this, exprID, callContext, &functions, &candidates, &arguments, &globalID);
    if (isError(&sweep)) return sweep;
    if (wantsInfer(&sweep)) return sweep;
    assert(isType(&sweep));
    (*expr).lhs = globalID;
    return sweep;
}

func markFunctionCallCandidates(
    this: &TypeChecker,
    callContext: &ArrayContext,
    functions: &FunctionLookupList,
    candidates: &FunctionLookupList,
    arguments: &TCStateList,
) -> TCState {
    trace("TypeChecker.markFunctionCallCandidates");
    for (let i: usize = 0; i < functions.length; i = i + 1) {
        let f: &FunctionLookup = at(functions, i);
        assert(getReadyState(f, FUNC_READY_TO_USE), "Function mark not ready");
        if (!f.isVarArg && f.params.length != arguments.length) {
            continue;
        }
        let paramCheck = typeCheckFunctionParameters(this, &f.params, callContext, arguments, true);
        if (isError(&paramCheck)) {
            continue;
        }
        push(candidates, *f);
    }
    return newTCStateSuccess();
}

func selectFunctionCallCandidate(
    this: &TypeChecker,
    exprID: usize,
    callContext: &ArrayContext,
    functions: &FunctionLookupList,
    candidates: &FunctionLookupList,
    arguments: &TCStateList,
    funcID: &usize,
) -> TCState {
    trace("TypeChecker.selectFunctionCallCandidate");
    if (candidates.length == 0) {
        return reportNoFunctionCallCandidate(this, exprID, functions);
    } else if (candidates.length > 1) {
        return newTCStatePleaseInfer();
    }
    assert(candidates.length == 1, "selectFunctionCallCandidate: Expected exactly one candidate");
    let f: &FunctionLookup = at(candidates, 0);
    assert(getReadyState(f, FUNC_READY_TO_USE), "Expected markFunctionCallCandidates to validate FUNC_READY_TO_USE");
    let paramCheck = typeCheckFunctionParameters(this, &f.params, callContext, arguments, false);
    if (isError(&paramCheck)) return paramCheck;
    *funcID = f.globalID;
    let retType: TCState = f.returnType;
    assert(isSuccess(&retType), "selectFunctionCallCandidate: Expected valid function return type");
    return retType;
}

func typeCheckFunctionArguments(this: &TypeChecker, params: &VariableLookupList, callContext: &ArrayContext, arguments: &TCStateList, checkOnly: bool) -> TCState {
    trace("TypeChecker.typeCheckFunctionArguments");
    if (params.length != callContext.elemLength) {
        todo_with_msg("typeCheckFunctionArguments: param count mismatch");
    }
    for (let i: usize = 0; i < callContext.elemLength; i = i + 1) {
        let param = at(params, i);
        let pTypeID = getType(&param.typeState);
        let argID: usize = getElementAtIndex(callContext, i);
        let arg: TCState = tryInferTypeOntoExpr(this, argID, pTypeID, checkOnly);
        if (isError(&arg)) {
            todo_with_msg("typeCheckFunctionArguments: arg param couldnt infer");
        }
        push(arguments, arg);
    }
    assert(arguments.length == callContext.elemLength);
    return newTCStateSuccess();
}

func typeCheckFunctionParameters(this: &TypeChecker, params: &VariableLookupList, callContext: &ArrayContext, arguments: &TCStateList, checkOnly: bool) -> TCState {
    let succ = true;
    for (let j: usize = 0; j < params.length; j = j + 1) {
        let argState: TCState = *at(arguments, j);
        let param: &VariableLookup = at(params, j);
        let paramState: &TCState = &param.typeState;
        assert(isSuccess(paramState), "Expected valid function parameter");
        let paramType: &Type = at(&types, getType(paramState));
        if (wantsInfer(&argState)) {
            argState = tryInferTypeOntoExpr(this, getElementAtIndex(callContext, j), getID(paramType), checkOnly);
            if (isError(&argState)) {
                todo_with_msg("error when inferring type of param onto argument");
            }
            assert(isType(&argState), "Did not infer type of param onto argument properly");
        }
        let argType: &Type = at(&types, getType(&argState));
        if (!equals(argType, paramType)) {
            if (!checkOnly) {
                let e = at(&exprs, getElementAtIndex(callContext, j));
                reportTypeMismatch(this, e.span, paramType, argType);
            }
            succ = false;
            break;
        }
    }
    if (!succ) return newTCStateFailure(ERROR_TYPE_MISMATCH);
    return newTCStateSuccess();
}

func typeCheckExprStructInit(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    // REVIEW: This function will later also do union declarations
    trace("TypeChecker.typeCheckExprStructInit");
    let expr: &ParsedExpr = at(&exprs, exprID);
    assert(expr.kind == EXPR_STRUCT_INIT);
    let name: Token = expr.origToken;
    let lookup: TypeLookup = blank;
    if (!resolveTypeByName(&this.lookup, this.currentModule, &name, &lookup)) {
        let loc: String = getLocation(&name);
        let _n: String = toString(&name.content);
        fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
        let alternatives: TypeLookupList = searchAllModulesForTypeName(&this.lookup, &name);
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &TypeLookup = at(&alternatives, i);
            if (isStruct(t)) {
                let s: &StructLookup = asStruct(t);
                let loc: String = getLocation(&s.name);
                fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.buffer, NOTE_STR);
                drop(&loc);
            }
        }
        drop(&_n);
        drop(&loc);
        this.typeError = true;
        return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
    }
    if (isStruct(&lookup)) {
        let context: &StructInitContext = &expr.structInitContext;
        let structLookup: &StructLookup = asStruct(&lookup);
        assert(getReadyState(structLookup, STRUCT_FIELDS_COMPLETE), "Struct fields not ready pt2");
        let hits: usize = 0;
        assert(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
        for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
            let name: Token = getFieldNameAtIndex(context, i);
            let exprID: usize = getFieldExprAtIndex(context, i);
            let exprState: TCState = typeCheckExpr(this, exprID, scopes);
            if (isError(&exprState)) return exprState;
            if (!hasField(structLookup, &name.content)) {
                return reportUnknownField(this, name, structLookup);
            }
            let fieldIndex: usize = getIndexByName(structLookup, &name);
            let bit: usize = shiftLeft(1, fieldIndex);
            if ((hits & bit) != 0) {
                todo_with_msg("duplicate field");
            } else {
                hits = hits | bit;
            }
            let field: &VariableLookup = at(&structLookup.fields, fieldIndex);
            let fieldState: &TCState = &field.typeState;
            assert(isSuccess(fieldState), "Struct is ready to go, but field type is invalid?");
            assert(equals(&name.content, &field.name.content), "Seems like my hack doesn't work");
            let fieldType: &Type = at(&types, getType(fieldState));
            if (wantsInfer(&exprState))
                exprState = inferTypeOntoExpr(this, exprID, getID(fieldType));
            let exprType: &Type = at(&types, getType(&exprState));
            if (!equals(fieldType, exprType)) {
                return reportTypeMismatch(this, at(&exprs, exprID).span, fieldType, exprType);
            }
        }
        return newTCStateType(structLookup.typeID);
    } else {
        unreachable("typeCheckExprStructInit got non-struct");
    }
}

func typeCheckIdentifier(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckIdentifier");
    let expr: &ParsedExpr = at(&exprs, exprID);
    assert(expr.kind == EXPR_NAME);
    let name: Token = expr.origToken;
    let var: VariableLookup = blank;
    if (!resolveVariableByName(&this.lookup, this.currentModule, &name, scopes, &var)) {
        let loc: String = getLocation(&name);
        let _name: String = toString(&name.content);
        fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
        let alternatives: VariableLookupList = searchAllModulesForIdentifier(&this.lookup, &name);
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &VariableLookup = at(&alternatives, i);
            let loc: String = getLocation(&t.name);
            fprintf(stderr, "%s: %s: A variable with that name is located here. Import the module to use it.\n", loc.buffer, NOTE_STR);
            drop(&loc);
        }
        drop(&_name);
        drop(&loc);
        this.typeError = true;
        return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
    }
    if (this.isComptimeContext && !var.isComptime) {
        reportRuntimeValueInComptimeContext(this, name, &var);
    }
    let state: TCState = var.typeState;
    assert(!isInvalid(&state), "Variable not ready");
    if (isError(&state)) return state;
    assert(expr.op == 0);
    let _loc: Token = blank;
    if (isKnownVariable(at(scopes, 0), name.content, &_loc)) {
        (*expr).op = 1;
    }
    (*expr).lhs = var.globalID;
    (*expr).typeState = state;
    return state;
}

func typeCheckExprBinary(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBinary");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    if (expr.op == BIN_DOT) {
        return typeCheckExprMemberAccess(this, binID, scopes);
    } else if (expr.op == BIN_ASSIGN) {
        return typeCheckExprAssign(this, binID, scopes);
    } else if (expr.op == BIN_INDEXED_ACCESS) {
        return typeCheckExprIndexedAccess(this, binID, scopes);
    } else if (isArithmetic(expr)) {
        return typeCheckExprArithmetic(this, binID, scopes);
    } else if (isComparison(expr)) {
        return typeCheckExprComparison(this, binID, scopes);
    } else if (isLogical(expr)) {
        return typeCheckExprLogical(this, binID, scopes);
    } else if (isBitwise(expr)) {
        return typeCheckExprBitwise(this, binID, scopes);
    } else {
        unreachable("Exhaustive handling of ops in typeCheckExprBinary");
    }
}

func typeCheckExprIndexedAccess(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprIndexedAccess");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_INDEXED_ACCESS);
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    if (!isType(&lhsState)) todo_with_msg("indexed access, original LHS is not a type");
    let lhsTypeID: usize = getType(&lhsState);
    let lhsType: &Type = at(&types, lhsTypeID);
    if (!isArray(lhsType) && !isPointer(lhsType)) {
        return reportIndexedAccessOnNonArray(this, expr.span, lhsType);
    }
    if (wantsInfer(&rhsState)) {
        let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        rhsState = inferTypeOntoExpr(this, expr.rhs, getID(usizeType));
    }
    if (!isType(&rhsState)) todo_with_msg("indexed access, could not infer type to RHS");
    let rhsTypeID: usize = getType(&rhsState);
    let rhsType: &Type = at(&types, rhsTypeID);
    // FIXME: Put those into a single check
    if (!isPrimitive(rhsType) || rhsTypeID != TYPE_USIZE) {
        let loc: String = toString(&expr.span);
        let typ: String = toString(rhsType);
        fprintf(stderr, "%s: %s: Expected index of array access to be type usize, got %s.\n", loc.buffer, ERR_STR, typ.buffer);
        drop(&typ);
        drop(&loc);
        this.typeError = true;
        return newTCStateFailure(ERROR_INDEXED_TYPE_MISMATCH);
    }
    let underlyingID: usize = lhsType.typeIndex;
    let underlyingType: &Type = at(&types, underlyingID);
    assert(getID(underlyingType) == underlyingID);
    return newTCStateType(underlyingID);
}

func typeCheckExprLogical(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprLogical");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY);
    assert(isLogical(expr));
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in logical");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = at(&types, getType(&lhsState));
    let rhsType: &Type = at(&types, getType(&rhsState));
    let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
    let result = newTCStateType(getID(boolType));
    if (!isBoolean(lhsType)) {
        result = reportTypeMismatch(this, at(&exprs, expr.lhs).span, boolType, lhsType);
    }
    if (!isBoolean(rhsType)) {
        result = reportTypeMismatch(this, at(&exprs, expr.rhs).span, boolType, rhsType);
    }
    return result;
}

func typeCheckExprBitwise(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBitwise");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY);
    assert(isBitwise(expr));
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in bitwise");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = at(&types, getType(&lhsState));
    let rhsType: &Type = at(&types, getType(&rhsState));
    if (!equals(lhsType, rhsType) || !isInteger(lhsType) || !isInteger(rhsType)) {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    return lhsState;
}

func typeCheckExprAssign(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAssign");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_ASSIGN);
    let lhsExpr: &ParsedExpr = at(&exprs, expr.lhs);
    if (!isLValue(lhsExpr)) {
        emergencyPrint(this, lhsExpr.span);
        todo_with_msg("invalid l-value");
    }
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in assignment");
    }
    if (!isType(&lhsState)) todo_with_msg("assignment, could not infer type to LHS");
    if (!isType(&rhsState)) todo_with_msg("assignment, could not infer type to RHS");
    let lhsType: &Type = at(&types, getType(&lhsState));
    let rhsType: &Type = at(&types, getType(&rhsState));
    if (!equals(lhsType, rhsType)) {
        return reportTypeMismatch(this, at(&exprs, expr.rhs).span, lhsType, rhsType);
    }
    return rhsState;
}

func typeCheckExprMemberAccess(this: &TypeChecker, dotID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprMemberAccess");
    let expr: &ParsedExpr = at(&exprs, dotID);
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(expr.op == BIN_DOT);
    let instance: TCState = typeCheckExpr(this, expr.lhs, scopes);
    if (isError(&instance)) return instance;
    if (wantsInfer(&instance)) return instance;
    let instanceTypeID: usize = getType(&instance);
    let instanceType: &Type = at(&types, instanceTypeID);
    if (!isStruct(instanceType) && !isStructPointer(instanceType)) {
        return reportMemberAccessOnNonStruct(this, expr, instanceType);
    }
    let underlying: &Type = instanceType;
    if (!isStruct(underlying)) underlying = getUnderlyingType(instanceType, true);
    let lookup: TypeLookup = getTypeLookupForType(&this.lookup, underlying);
    if (isStruct(underlying)) {
        assert(isStruct(&lookup));
        let structLookup: &StructLookup = asStruct(&lookup);
        let rhs: &ParsedExpr = at(&exprs, expr.rhs);
        assert(rhs.kind == EXPR_NAME);
        assert(getReadyState(structLookup, STRUCT_FIELDS_COMPLETE), "Struct fields not complete");
        let fieldName: Token = rhs.origToken;
        let field: VariableLookup = blank;
        if (!resolveFieldByName(structLookup, &fieldName, &field)) {
            return reportUnknownField(this, fieldName, structLookup);
        }
        let fieldState: TCState = field.typeState;
        assert(isSuccess(&fieldState), "Expected valid field type");
        return fieldState;
    } else {
        unreachable("MemberAccess expected Struct as LHS");
    }
}

func checkIfInferIsNeeded(this: &TypeChecker, lhsID: usize, lhsState: &TCState, rhsID: usize, rhsState: &TCState) -> TCState {
    trace("TypeChecker.checkIfInferIsNeeded");
    let lhsExpr: &ParsedExpr = at(&exprs, lhsID);
    let rhsExpr: &ParsedExpr = at(&exprs, rhsID);
    if (isType(lhsState) && isType(rhsState)) {
        return newTCStateSuccess();
    } else if (isType(lhsState) && !isType(rhsState)) {
        let lhsType: usize = getType(lhsState);
        *rhsState = inferTypeOntoExpr(this, rhsID, lhsType);
        return *rhsState;
    } else if (!isType(lhsState) && isType(rhsState)) {
        let rhsType: usize = getType(rhsState);
        *lhsState = inferTypeOntoExpr(this, lhsID, rhsType);
        return *lhsState;
    } else {
        return newTCStatePleaseInfer();
    }
}

func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize) -> TCState {
    trace("TypeChecker.inferTypeOntoExpr");
    return tryInferTypeOntoExpr(this, exprID, typeID, false);
}

func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoExpr");
    let expr: &ParsedExpr = at(&exprs, exprID);
    if (isSuccess(&expr.typeState)) {
        let exprType: &Type = at(&types, getType(&expr.typeState));
        let wantType: &Type = at(&types, typeID);
        if (!equals(exprType, wantType)) todo_with_msg("infer failed");
        return newTCStateType(typeID);
    }
    let typ: &Type = at(&types, typeID);
    let tid: TCState = blank;
    if (expr.kind == EXPR_INT_LIT) {
        if (isChar(typ)) {
            if (!checkOnly) {
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Using integer literal to initialize value of type char.\n",
                    l.buffer, WARN_STR);
                drop(&l);
            }
            tid = newTCStateType(getID(typ));
        } else if (isInteger(typ) || isFloat(typ)) {
            tid = newTCStateType(getID(typ));
        } else if (isPointer(typ)) {
            // REVIEW: This is... More than debatable?
            // Context requires a pointer, we have an integer literal.. Now this literal is type usize
            // Question: Is there ever a situation where we actually want this literal to be type ptr?
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            tid = newTCStateType(getID(usizeType));
        } else if (isBoolean(typ)) {
            if (!checkOnly) {
                let s: String = toString(&expr.origToken.content);
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n",
                    l.buffer, ERR_STR, s.buffer);
                drop(&l);
                drop(&s);
                this.typeError = true;
            }
            return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
        } else if (isArray(typ)) {
            if (!checkOnly) {
                let s: String = toString(&expr.origToken.content);
                let l: String = getLocation(&expr.origToken);
                fprintf(stderr, "%s: %s: Unexpected Literal! Expected array, found `%s`.\n",
                    l.buffer, ERR_STR, s.buffer);
                drop(&l);
                drop(&s);
                this.typeError = true;
            }
            return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
        } else {
            todo_with_msg("can't infer non-int non-float type onto int literal");
        }
    } else if (expr.kind == EXPR_CHAR_LIT) {
        if (typ.kind != TYPE_KIND_PRIMITIVE && typ.typeIndex != TYPE_CHAR)
            todo_with_msg("can't infer non-char type onto char literal");
        tid = newTCStateType(getID(typ));
    } else if (expr.kind == EXPR_ARRAY_LIT) {
        if (!isArray(typ)) {
            if (!checkOnly) {
                let loc = toString(&expr.span);
                let t = toString(typ);
                fprintf(stderr, "%s: %s: Expected expression of type %s, found array literal.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
        assert(expr.arrayContext.elemLength > 0, "Got empty array literal");
        if (expr.arrayContext.size == 0) {
            if (typ.arraySize != expr.arrayContext.elemLength) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                        loc.buffer, ERR_STR, typ.arraySize, expr.arrayContext.elemLength);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
            }
            let lastErrState: TCState = blank;
            for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
                tid = tryInferTypeOntoExpr(this, getElementAtIndex(&expr.arrayContext, i), typ.typeIndex, checkOnly);
                if (isError(&tid)) {
                    lastErrState = tid;
                }
            }
            if (!isInvalid(&lastErrState)) return lastErrState;
        } else {
            if (typ.arraySize != expr.arrayContext.size) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                        loc.buffer, ERR_STR, typ.arraySize, expr.arrayContext.size);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, getElementAtIndex(&expr.arrayContext, 0), typ.typeIndex, checkOnly);
            if (isError(&tid)) return tid;
        }
        tid = newTCStateType(typeID);
    } else if (expr.kind == EXPR_BLANK) {
        if (isPointer(typ)) {
            let loc: String = toString(&expr.span);
            let name: String = toString(typ);
            fprintf(stderr, "%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n",
                loc.buffer, ERR_STR, name.buffer);
            drop(&name);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_BLANK_FOR_NULL);
        } else if (isPrimitive(typ)) {
            let loc: String = toString(&expr.span);
            let name: String = toString(typ);
            fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n",
                loc.buffer, WARN_STR, name.buffer);
            drop(&name);
            drop(&loc);
        }
        tid = newTCStateType(getID(typ));
    } else if (expr.kind == EXPR_BINARY) {
        if (isArithmetic(expr) || isBitwise(expr)) {
            tid = tryInferTypeOntoExpr(this, expr.lhs, typeID, checkOnly);
            if (isError(&tid)) return tid;
            tid = tryInferTypeOntoExpr(this, expr.rhs, typeID, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(typeID);
        } else if (isComparison(expr)) {
            // Assuming that neither side has a type (otherwise typeCheckExprComparison would've handled the infer step)
            // So all that's left is whack things like `1 == 1`, for which we blindly try to infer usize onto both sides
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(usizeType), checkOnly);
            if (isError(&tid)) return tid;
            tid = tryInferTypeOntoExpr(this, expr.rhs, getID(usizeType), checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(typeID);
        } else if (expr.op == BIN_DOT) {
            tid = tryInferTypeOntoMemberAccess(this, exprID, typeID, checkOnly);
            if (isError(&tid)) return tid;
        } else {
            todo_with_msg("inferTypeOntoExpr for non-arith non-comp binary");
        }
    } else if (expr.kind == EXPR_UNARY) {
        if (expr.op == UNARY_DEREF) {
            let newType: &Type = newType(TYPE_KIND_POINTER, typeID);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(newType), checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(typeID);
        } else if (expr.op == UNARY_REF) {
            if (!isPointer(typ)) todo_with_msg("can't infer non-pointer type onto reference");
            let underlying: &Type = getUnderlyingType(typ, false);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(underlying), checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(typeID);
        } else if (expr.op == UNARY_MINUS) {
            // -expr
            // typeof(expr) == typeof(-expr)
            if (!isSignedInteger(typ) && !isFloat(typ)) {
                if (!checkOnly) {
                    let loc: String = toString(&expr.span);
                    let t: String = toString(typ);
                    fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, expr.lhs, typeID, checkOnly);
            if (isError(&tid)) return tid;
            assert(isType(&tid), "infer non-error expected to be a type");
            let subType: &Type = at(&types, getType(&tid));
            assert(equals(subType, typ), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
            tid = newTCStateType(typeID);
        } else if (expr.op == UNARY_NOT) {
            let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            tid = tryInferTypeOntoExpr(this, expr.lhs, getID(boolType), checkOnly);
            if (isError(&tid)) return tid;
            todo_with_msg("unary not infer");
        } else {
            unreachable("Exhaustive handling of unary ops in inferTypeOntoExpr");
        }
    } else if (expr.kind == EXPR_NULL) {
        if (!isPointer(typ)) todo_with_msg("tried to infer non-ptr to null");
        tid = newTCStateType(typeID);
    } else if (expr.kind == EXPR_CALL) {
        tid = tryInferTypeOntoCall(this, exprID, typeID, checkOnly);
        if (isError(&tid)) return tid;
    } else {
        emergencyPrint(this, expr.span);
        todo_with_msg("unhandled case in inferTypeOntoExpr");
    }
    if (!checkOnly) {
        (*expr).typeState = tid;
    }
    return tid;
}

func tryInferTypeOntoCall(this: &TypeChecker, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoCall");
    let expr = at(&exprs, exprID);
    let typ = at(&types, typeID);
    assert(expr.kind == EXPR_CALL);
    let functions: FunctionLookupList = blank;
    assert(resolveAllFunctionsWithReturnType(&this.lookup, this.currentModule, &expr.origToken, typ, &functions), "Could not resolve functions");
    let callContext: &ArrayContext = &expr.arrayContext;
    let actual: FunctionLookupList = blank;
    for (let i: usize = 0; i < functions.length; i = i + 1) {
        let f = at(&functions, i);
        assert(getReadyState(f, FUNC_PARAMS_COMPLETE));
        let arguments: TCStateList = blank;
        let state = typeCheckFunctionArguments(this, &f.params, callContext, &arguments, true);
        if (isError(&state)) {
            todo_with_msg("argument fail");
        }
        state = typeCheckFunctionParameters(this, &f.params, callContext, &arguments, checkOnly);
        if (isError(&state)) {
            todo_with_msg("parameter fail");
        }
        push(&actual, *f);
    }
    if (actual.length == 1) {
        let f = at(&actual, 0);
        if (!checkOnly) {
            let arguments: TCStateList = blank;
            let state = typeCheckFunctionArguments(this, &f.params, callContext, &arguments, false);
            assert(isSuccess(&state));
            (*expr).lhs = f.globalID;
        }
        return f.returnType;
    } else if (actual.length == 0) {
        if (!checkOnly) {
            let functions: FunctionLookupList = resolveFunctionByName(&this.lookup, this.currentModule, &expr.origToken);
            return reportNoFunctionCallCandidate(this, getID(expr), &functions);
        }
        return newTCStateFailure(ERROR_TYPE_MISMATCH);
    } else {
        if (!checkOnly) {
            return reportFunctionCallTooManyOptions(this, expr, &actual);
        }
        return newTCStateFailure(ERROR_TYPE_MISMATCH);
    }
}

func tryInferTypeOntoMemberAccess(this: &TypeChecker, exprID: usize, typeID: usize, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoMemberAccess");
    let expr = at(&exprs, exprID);
    let typ = at(&types, typeID);
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_DOT);
    let lhs = at(&exprs, expr.lhs);
    let rhs = at(&exprs, expr.rhs);
    if (rhs.kind == EXPR_NAME) {
        let name = rhs.origToken;
        let structs = resolveAllStructsWithField(&this.lookup, this.currentModule, &name, typ);
        if (structs.length == 0) {
            todo_with_msg("tryInferTypeOntoMemberAccess: 0 struct with field");
        } else if (structs.length == 1) {
            let strukt = at(&structs, 0);
            let state = tryInferTypeOntoExpr(this, expr.lhs, strukt.typeID, checkOnly);
            if (isError(&state)) return state;
            if (checkOnly) return newTCStateSuccess();
            return newTCStateType(typeID);
        } else {
            if (!checkOnly) {
                return reportMemberAccessTooManyOptions(this, expr, &structs);
            }
            return newTCStateFailure(ERROR_TYPE_MISMATCH);
        }
    } else if (rhs.kind == EXPR_CALL) {
        todo_with_msg("infer member call");
    } else {
        unreachable("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess");
    }
}

func typeCheckExprArithmetic(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprArithmetic");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(isArithmetic(expr), "Expr expected to be arithmetic");
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let lhsPointer: bool = false;
    let rhsPointer: bool = false;
    if (isType(&lhsState)) if (isPointer(at(&types, getType(&lhsState)))) lhsPointer = true;
    if (isType(&rhsState)) if (isPointer(at(&types, getType(&rhsState)))) rhsPointer = true;
    if (lhsPointer || rhsPointer) {
        if (expr.op != BIN_PLUS && expr.op != BIN_SUB) {
            return reportInvalidPointerArithmetics(this, 
                expr.op,
                at(&exprs, expr.lhs).span,
                at(&exprs, expr.rhs).span,
            );
        }
    }
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = at(&types, getType(&lhsState));
    let rhsType: &Type = at(&types, getType(&rhsState));
    let resultState: TCState = blank;
    if (equals(lhsType, rhsType)) {
        if (isChar(lhsType) && expr.op != BIN_PLUS && expr.op != BIN_SUB) {
            return reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
        }
        if (isStruct(lhsType) || isArray(lhsType)) {
            return reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
        } else if (isPointer(lhsType)) {
            let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            resultState = newTCStateType(getID(t));
        } else {
            assert(getID(lhsType) == getID(rhsType), "Arithmetic LHS and RHS are different types");
            resultState = newTCStateType(getID(lhsType));
        }
    } else if (isPointer(lhsType) && isInteger(rhsType)) {
        if (rhsType.typeIndex == TYPE_USIZE) {
            resultState = lhsState;
        } else {
            let rhs = at(&exprs, expr.rhs).span;
            let err = reportBinaryTypeMismatch(this, 
                expr.op,
                at(&exprs, expr.lhs).span, lhsType,
                rhs, rhsType,
            );
            let loc = toString(&rhs);
            fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
            drop(&loc);
            return err;
        }
    } else if (isInteger(lhsType) && isPointer(rhsType)) {
        if (lhsType.typeIndex == TYPE_USIZE) {
            resultState = rhsState;
        } else {
            let lhs = at(&exprs, expr.lhs).span;
            let err = reportBinaryTypeMismatch(this, 
                expr.op,
                lhs, lhsType,
                at(&exprs, expr.rhs).span, rhsType,
            );
            let loc = toString(&lhs);
            fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
            drop(&loc);
            return err;
        }
    } else {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    return resultState;
}

func typeCheckExprComparison(this: &TypeChecker, binID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprComparison");
    let expr: &ParsedExpr = at(&exprs, binID);
    assert(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
    assert(isComparison(expr), "Expr expected to be comparison");
    let lhsState: TCState = typeCheckExpr(this, expr.lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, expr.rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, expr.lhs, &lhsState, expr.rhs, &rhsState);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in comp");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = at(&types, getType(&lhsState));
    let rhsType: &Type = at(&types, getType(&rhsState));
    if (!equals(lhsType, rhsType)) {
        return reportBinaryTypeMismatch(this, 
            expr.op,
            at(&exprs, expr.lhs).span, lhsType,
            at(&exprs, expr.rhs).span, rhsType,
        );
    }
    if (isStruct(lhsType) || isStruct(rhsType)
        || isArray(lhsType) || isArray(rhsType)) {
        todo_with_msg("report error, can't compare structs or arrays using == or similar.");
    }
    let t: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
    return newTCStateType(getID(t));
}


func typeCheckTypeNode(this: &TypeChecker, typeID: usize) -> TCState {
    trace("TypeChecker.typeCheckTypeNode");
    let typ: &ParsedTypeNode = at(&typeNodes, typeID);
    if (typ.ignored) return blank;
    if (isSuccess(&typ.typeState)) return typ.typeState;
    let tid: usize = 0;
    if (typ.kind == PARSED_TYPE_REF) {
        let under: TCState = typeCheckTypeNode(this, typ.underlyingID);
        if (isError(&under)) return under;
        let underlyingType: usize = getType(&under);
        let t: &Type = newType(TYPE_KIND_POINTER, underlyingType);
        tid = getID(t);
    } else if (typ.kind == PARSED_TYPE_ARRAY) {
        if (typ.arraySize == 0) todo_with_msg("0 elements in mah array");
        let under: TCState = typeCheckTypeNode(this, typ.underlyingID);
        if (isError(&under)) return under;
        let underlyingType: usize = getType(&under);
        let t: &Type = newType(TYPE_KIND_ARRAY, underlyingType);
        (*t).arraySize = typ.arraySize;
        tid = getID(t);
    } else if (typ.kind == PARSED_TYPE_IDENT) {
        let name: Token = typ.nameTkn;
        let typeLookup: TypeLookup = blank;
        if (!resolveTypeByName(&this.lookup, this.currentModule, &name, &typeLookup)) {
            let loc: String = getLocation(&name);
            let _n: String = toString(&name.content);
            fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
            let alternatives: TypeLookupList = searchAllModulesForTypeName(&this.lookup, &name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &TypeLookup = at(&alternatives, i);
                if (isStruct(t)) {
                    let s: &StructLookup = asStruct(t);
                    let loc: String = getLocation(&s.name);
                    fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.buffer, NOTE_STR);
                    drop(&loc);
                }
            }
            drop(&_n);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (isStruct(&typeLookup)) {
            let structLookup: &StructLookup = asStruct(&typeLookup);
            let _tid: usize = structLookup.typeID;
            assert(_tid != 0, "Ready to use Struct Lookup has Type ID 0");
            let t: &Type = at(&types, _tid);
            assert(isStruct(t), "Struct Lookup links to non-Struct type");
            tid = getID(t);
        } else {
            todo_with_msg("check ident");
        }
    } else if (typ.kind == PARSED_TYPE_BUILTIN) {
        let id: usize = getID(typ);
        let typeID: usize = 0;
        if (id == PARSED_TYPE_INVALID) typeID = TYPE_INVALID;
        else if (id == PARSED_TYPE_UNKNOWN) typeID = TYPE_UNKNOWN;
        else if (id == PARSED_TYPE_NONE) typeID = TYPE_NONE;
        else if (id == PARSED_TYPE_ANY) typeID = TYPE_ANY;
        else if (id == PARSED_TYPE_I8) typeID = TYPE_I8;
        else if (id == PARSED_TYPE_I16) typeID = TYPE_I16;
        else if (id == PARSED_TYPE_I32) typeID = TYPE_I32;
        else if (id == PARSED_TYPE_I64) typeID = TYPE_I64;
        else if (id == PARSED_TYPE_U8) typeID = TYPE_U8;
        else if (id == PARSED_TYPE_U16) typeID = TYPE_U16;
        else if (id == PARSED_TYPE_U32) typeID = TYPE_U32;
        else if (id == PARSED_TYPE_U64) typeID = TYPE_U64;
        else if (id == PARSED_TYPE_USIZE) typeID = TYPE_USIZE;
        else if (id == PARSED_TYPE_BOOL) typeID = TYPE_BOOL;
        else if (id == PARSED_TYPE_CHAR) typeID = TYPE_CHAR;
        else if (id == PARSED_TYPE_F32) typeID = TYPE_F32;
        else if (id == PARSED_TYPE_F64) typeID = TYPE_F64;
        else {
            emergencyPrint(this, typ.span);
            todo_with_msg("handle other parsed -> checked type conversion");
        }
        let t: &Type = newType(TYPE_KIND_PRIMITIVE, typeID);
        tid = getID(t);
    } else {
        todo_with_msg("unknown type kind");
    }
    let state: TCState = newTCStateType(tid);
    (*typ).typeState = state;
    return state;
}

func newTypeChecker() -> TypeChecker {
    return TypeChecker {
        isComptimeContext: false,
        currentModule: 0,
        currentFunction: null,
        lookup: blank,
        typeError: false,
    };
}
