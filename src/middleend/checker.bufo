import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

@os(WINDOWS) import "winapi/structs.bufo";
@os(WINDOWS) import "winapi/functions.bufo";

@os(LINUX) import "posix/structs.bufo";
@os(LINUX) import "posix/functions.bufo";

comptime ERROR_INVALID                           : usize = 0;
comptime ERROR_NO_SUCH_MODULE                    : usize = 1;
comptime ERROR_NO_SUCH_IDENTIFIER                : usize = 2;
comptime ERROR_NO_SUCH_FUNCTION                  : usize = 3;
comptime ERROR_NO_SUCH_METHOD                    : usize = 4;
comptime ERROR_NO_SUCH_TYPE                      : usize = 5;
comptime ERROR_USE_BEFORE_DECLARATION            : usize = 6;
comptime ERROR_FIELD_COUNT_MISMATCH              : usize = 7;
comptime ERROR_INDEXED_TYPE_MISMATCH             : usize = 8;
comptime ERROR_UNEXPECTED_LITERAL                : usize = 9;
comptime ERROR_ARRAY_SIZE_MISMATCH               : usize = 10;
comptime ERROR_TYPE_MISMATCH                     : usize = 11;
comptime ERROR_INVALID_POINTER_ARITHMETIC        : usize = 12;
comptime ERROR_DUPLICATE_PARAMETER               : usize = 13;
comptime ERROR_DUPLICATE_FIELD                   : usize = 14;
comptime ERROR_UNKNOWN_FIELD                     : usize = 15;
comptime ERROR_DUPLICATE_FUNCTION                : usize = 16;
comptime ERROR_NO_CALL_CANDIDATE                 : usize = 17;
comptime ERROR_VARIABLE_REDECLARATION            : usize = 18;
comptime ERROR_RECURSIVE_TYPE                    : usize = 19;
comptime ERROR_DUPLICATE_METHOD                  : usize = 20;
comptime ERROR_BLANK_FOR_NULL                    : usize = 21;
comptime ERROR_NON_PRIMITIVE_CAST                : usize = 22;
comptime ERROR_INDEXED_ACCESS_ON_NON_ARRAY       : usize = 23;
comptime ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT : usize = 24;
comptime ERROR_ANY_DEREF                         : usize = 25;
comptime ERROR_MEMBER_ACCESS_NON_STRUCT          : usize = 26;
comptime ERROR_MEMBER_ACCESS_NO_OPTIONS          : usize = 27;
comptime ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS    : usize = 28;
comptime ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS    : usize = 29;
comptime ERROR_CALL_TO_NON_FUNCTION              : usize = 30;
comptime ERROR_UNKNOWN_SUBMODULE                 : usize = 31;
comptime ERROR_MODULE_ACCESS_NON_MODULE          : usize = 32;
comptime ERROR_DEREF_NON_POINTER                 : usize = 33;
comptime ERROR_DUPLICATE_UNION_VARIANT           : usize = 34;
comptime ERROR_DUPLICATE_UNION_NAME              : usize = 35;
comptime ERROR_NON_EXHAUSTIVE_MATCH              : usize = 36;
comptime ERROR_IMPOSSIBLE_PATTERN                : usize = 37;
comptime ERROR_NULL_NON_PTR                      : usize = 38;

comptime TCSTATE_INVALID: usize = 0;
comptime TCSTATE_ERROR: usize = 1;
comptime TCSTATE_PLEASE_INFER: usize = 2;
comptime TCSTATE_TYPE: usize = 3;
comptime TCSTATE_PATTERN: usize = 4;
struct TCState {
    kind: usize;
    error: usize;
    typ: &Type;
    name: Token;
    pattern: PatState;
}

func equals(this: &TCState, other: &TCState) -> bool {
    todo_with_msg("TCState.equals");
}

func isInvalid(this: &TCState) -> bool {
    return this.kind == TCSTATE_INVALID;
}
func wantsInfer(this: &TCState) -> bool {
    return this.kind == TCSTATE_PLEASE_INFER;
}
func isCriticalError(this: &TCState) -> bool {
    if (!isError(this)) return false;
    let err: usize = getError(this);
    return err == ERROR_NO_SUCH_IDENTIFIER
        || err == ERROR_NO_SUCH_FUNCTION
        || err == ERROR_NO_SUCH_METHOD
        || err == ERROR_DUPLICATE_FUNCTION
        || err == ERROR_DUPLICATE_METHOD
        || err == ERROR_DUPLICATE_FIELD;
}
func isError(this: &TCState) -> bool {
    return this.kind == TCSTATE_ERROR;
}

func isSuccess(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE || this.kind == TCSTATE_PATTERN;
}

func isType(this: &TCState) -> bool {
    return this.kind == TCSTATE_TYPE;
}

func isPattern(this: &TCState) -> bool {
    return this.kind == TCSTATE_PATTERN;
}

func getType(this: &TCState) -> &Type {
    if (!isType(this)) {
        fprintf(stderr, "ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.typ;
}
func getError(this: &TCState) -> usize {
    if (!isError(this)) {
        fprintf(stderr, "ERROR: getError(&TCState) called on non-error TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.error;
}
func getPatState(this: &TCState) -> PatState {
    if (!isPattern(this)) {
        fprintf(stderr, "ERROR: getPatState(&TCState) called on non-pattern TCState with kind=%llu\n", this.kind);
        assert(false);
    }
    return this.pattern;
}

func newTCStateSuccess() -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
    };
}

func newTCStateType(typ: &Type) -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: typ,
    };
}

func newTCStateFailure(error: usize) -> TCState {
    return TCState {
        kind: TCSTATE_ERROR,
        error: error,
    };
}

func newTCStatePleaseInfer() -> TCState {
    return TCState {
        kind: TCSTATE_PLEASE_INFER,
    };
}
func newTCStatePattern(state: PatState) -> TCState {
    return TCState {
        kind: TCSTATE_PATTERN,
        pattern: state
    };
}

struct PatState {
    complete: bool;
}

struct TypeChecker {
    isComptimeContext: bool;
    currentModule: &ModuleLookup;
    currentFunction: &FunctionLookup;
    lookup: Lookup;
    typeError: bool;
}

func reportTypeMismatch(this: &TypeChecker, span: Span, expected: &Type, got: &Type) -> TCState {
    trace("TypeChecker.reportTypeMismatch");
    let loc: String = toString(&span);
    let typ1: String = toString(expected);
    let typ2: String = toString(got);
    fprintf(stderr, "%s: %s: Type mismatch! Expected type %s, found type %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportBinaryTypeMismatch(this: &TypeChecker, op: &char, lhsSpan: Span, lhsType: &Type, rhsSpan: Span, rhsType: &Type) -> TCState {
    trace("TypeChecker.reportBinaryTypeMismatch");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    let loc1: String = toString(&lhsSpan);
    let loc2: String = toString(&rhsSpan);
    let typ1: String = toString(lhsType);
    let typ2: String = toString(rhsType);
    fprintf(stderr, "%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n",
        loc.buffer, ERR_STR, typ1.buffer, op, typ2.buffer);
    fprintf(stderr, "%s: %s: LHS has type %s.\n", loc1.buffer, NOTE_STR, typ1.buffer);
    fprintf(stderr, "%s: %s: RHS has type %s.\n", loc2.buffer, NOTE_STR, typ2.buffer);
    drop(&typ2);
    drop(&typ1);
    drop(&loc2);
    drop(&loc1);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_TYPE_MISMATCH);
}

func reportInvalidPointerArithmetics(this: &TypeChecker, op: &char, lhsSpan: Span, rhsSpan: Span) -> TCState {
    trace("TypeChecker.reportInvalidPointerArithmetics");
    let loc: String = toString(&newSpanBetween(&lhsSpan, &rhsSpan));
    fprintf(stderr, "%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n",
        loc.buffer, ERR_STR, op);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INVALID_POINTER_ARITHMETIC);
}

func reportDuplicateField(this: &TypeChecker, fieldToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateField");
    let duplLoc: String = toString(&fieldToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&fieldToken.content);
    fprintf(stderr, "%s: %s: Field redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FIELD);
}

func reportDuplicateParameter(this: &TypeChecker, paramToken: Token, declSpan: Span) -> TCState {
    trace("TypeChecker.reportDuplicateParameter");
    let duplLoc: String = toString(&paramToken.span);
    let origLoc: String = toString(&declSpan);
    let name: String = toString(&paramToken.content);
    fprintf(stderr, "%s: %s: Parameter redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Parameter `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_PARAMETER);
}

func reportUnknownField(this: &TypeChecker, name: Token, decl: &StructLookup, isUnion: bool) -> TCState {
    trace("TypeChecker.reportUnknownField");
    let errLoc: String = toString(&name.span);
    let declLoc: String = toString(&decl.name.span);
    let strukt: String = toString(&decl.name.content);
    let field: String = toString(&name.content);
    let s1 = "struct";
    let s2 = "Struct";
    if (isUnion) {
        s1 = "union variant";
        s2 = "Union variant";
    }
    fprintf(stderr, "%s: %s: Attempted to access unknown field `%s` of instance of %s %s.\n", errLoc.buffer, ERR_STR, field.buffer, s1, strukt.buffer);
    fprintf(stderr, "%s: %s: %s %s is declared here.\n", declLoc.buffer, NOTE_STR, s2, strukt.buffer);
    drop(&field);
    drop(&strukt);
    drop(&declLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_UNKNOWN_FIELD);
}
func reportUnknownType(this: &TypeChecker, mod: &ModuleLookup, name: Token, alternatives: TypeLookupList) -> TCState {
    let loc: String = getLocation(&name);
    let _n: String = toString(&name.content);
    if (mod != null) {
        let modNode = at(&modules, mod.globalID);
        let _n1 = toString(&modNode.name.content);
        let loc1 = toString(&modNode.span);
        fprintf(stderr, "%s: %s: Module `%s` does not contain any types named `%s`.\n", loc.buffer, ERR_STR, _n1.buffer, _n.buffer);
        fprintf(stderr, "%s: %s: Module declared here.\n", loc1.buffer, NOTE_STR);
        drop(&loc1);
        drop(&_n1);
    } else {
        fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
        for (let i: usize = 0; i < alternatives.length; i = i + 1) {
            let t: &TypeLookup = at(&alternatives, i);
            if (isStruct(t)) {
                let s: &StructLookup = asStruct(t);
                drop(&loc);
                loc = getLocation(&s.name);
                fprintf(stderr, "%s: %s: A struct with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
            }
        }
    }
    drop(&_n);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_TYPE);
}

func reportDuplicateFunction(this: &TypeChecker, f1: &FunctionLookup, f2: &FunctionLookup) -> TCState {
    trace("TypeChecker.reportDuplicateFunction");
    let errLoc: String = toString(&f1.name.span);
    let duplLoc: String = toString(&f2.name.span);
    let name: String = toString(&f1.name.content);
    let typ = toString(getType(&f1.fnType));
    fprintf(stderr, "%s: %s: Function redeclaration.\n", errLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: A function named `%s` with the signature %s is already declared here.\n", duplLoc.buffer, ERR_STR, name.buffer, typ.buffer);
    drop(&typ);
    drop(&name);
    drop(&duplLoc);
    drop(&errLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_FUNCTION);
}

func reportNoFunctionCallCandidate(this: &TypeChecker, ident: Token, fnType: &Type, functions: &FunctionLookupList) -> TCState {
    trace("TypeChecker.reportNoFunctionCallCandidate");
    let loc: String = toString(&ident.span);
    let name: String = toString(&ident.content);
    let typ = toString(fnType);
    fprintf(stderr, "%s: %s: No function overload fits the provided context for call to function `%s`.\n", loc.buffer, ERR_STR, name.buffer);
    fprintf(stderr, "%s: %s: Context requires an overload of the form %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    assert(functions.length != 0, "reportNoFunctionCallCandidate: Expected at least one declaration");
    if (*flags.verbose) {
        for (let i: usize = 0; i < functions.length; i = i + 1) {
            let f: &FunctionLookup = at(functions, i);
            drop(&typ);
            drop(&loc);
            loc = toString(&f.name.span);
            typ = toString(getType(&f.fnType));
            fprintf(stderr, "%s: %s: Overload %s declared here.\n", loc.buffer, NOTE_STR, typ.buffer);
        }
    } else {
        let is = "are";
        let ol = "overloads";
        let it = "them";
        if (functions.length == 1) {
            is = "is";
            ol = "overload";
            it = "it";
        }
        fprintf(stderr, "%s: %s: There %s %llu possible %s. Re-run with the --verbose flag to see %s.\n",
                loc.buffer, NOTE_STR, is, functions.length, ol, it);
    }
    drop(&typ);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_CALL_CANDIDATE);
}

func reportVariableRedeclaration(this: &TypeChecker, newDecl: Token, oldDecl: Token) -> TCState {
    trace("TypeChecker.reportVariableRedeclaration");
    let newLoc: String = toString(&newDecl.span);
    let oldLoc: String = toString(&oldDecl.span);
    let name: String = toString(&newDecl.content);
    fprintf(stderr, "%s: %s: Variable redeclaration.\n", newLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` already declared here.\n", oldLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&oldLoc);
    drop(&newLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_VARIABLE_REDECLARATION);
}

func reportRecursiveType(this: &TypeChecker, checked: &TypeLookup, cycle: &TypeLookupList) -> TCState {
    trace("TypeChecker.reportRecursiveType");
    let loc: String = getLocation(checked);
    let name: String = getName(checked);
    fprintf(stderr, "%s: %s: Recursive type %s.\n", loc.buffer, ERR_STR, name.buffer);
    assert(cycle.length >= 1, "Cycle is empty");
    for (let i: usize = 1; i < cycle.length; i = i + 1) {
        loc = getLocation(at(cycle, i));
        name = getName(at(cycle, i));
        fprintf(stderr, "%s: %s: Chain of recursion also includes type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    }
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RECURSIVE_TYPE);
}

func reportNonPrimitiveCast(this: &TypeChecker, span: Span, from: &Type, to: &Type) -> TCState {
    trace("TypeChecker.reportNonPrimitiveCast");
    let loc: String = toString(&span);
    let typ1: String = toString(from);
    let typ2: String = toString(to);
    fprintf(stderr, "%s: %s: Non primitive cast from type %s to %s.\n",
        loc.buffer, ERR_STR, typ1.buffer, typ2.buffer);
    drop(&typ1);
    drop(&typ2);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NON_PRIMITIVE_CAST);
}

func reportIndexedAccessOnNonArray(this: &TypeChecker, span: Span, typ: &Type) -> TCState {
    trace("TypeChecker.reportIndexedAccessOnNonArray");
    let loc: String = toString(&span);
    let name: String = toString(typ);
    fprintf(stderr, "%s: %s: Indexed Access is only supported for arrays.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Expression has type %s.\n", loc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
}

func reportRuntimeValueInComptimeContext(this: &TypeChecker, ident: Token, var: &VariableLookup) -> TCState {
    trace("TypeChecker.reportRuntimeValueInComptimeContext");
    let loc = toString(&ident.span);
    let otherLoc = toString(&var.name.span);
    let name = toString(&ident.content);
    fprintf(stderr, "%s: %s: Variables declared with `let` can't be used in a comptime context.\n", loc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variable `%s` is declared here.\n", otherLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&otherLoc);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT);
}

func reportAnyDereference(this: &TypeChecker, expr: &ParsedExpr) -> TCState {
    trace("TypeChecker.reportAnyDereference");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Can't dereference expression of type Any.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_ANY_DEREF);
}

func reportMemberAccessOnNonStruct(this: &TypeChecker, expr: &ParsedExpr, instance: &Type) -> TCState {
    trace("TypeChecker.reportMemberAccessOnNonStruct");
    let loc = toString(&expr.span);
    let t = toString(instance);
    fprintf(stderr, "%s: %s: The Dot-Operator is not defined for values of type %s.\n", loc.buffer, ERR_STR, t.buffer);
    drop(&t);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_NON_STRUCT);
}

func reportMemberAccessNoOptions(this: &TypeChecker, span: Span) -> TCState {
    trace("TypeChecker.reportMemberAccessNoOptions");
    let loc = toString(&span);
    fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_NO_OPTIONS);
}

func reportMemberAccessTooManyOptions(this: &TypeChecker, span: Span, structs: &StructLookupList) -> TCState {
    trace("TypeChecker.reportMemberAccessTooManyOptions");
    assert(structs.length > 0);
    let loc = toString(&span);
    fprintf(stderr, "%s: %s: Could not infer which type to use for expression.\n", loc.buffer, ERR_STR);
    for (let i: usize = 0; i < structs.length; i = i + 1) {
        let s = at(structs, i);
        let l = toString(&s.name.span);
        let n = toString(&s.name.content);
        fprintf(stderr, "%s: %s: Context allows struct %s to be used.\n", l.buffer, NOTE_STR, n.buffer);
        drop(&n);
        drop(&l);
    }
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS);
}

func reportFunctionCallTooManyOptions(this: &TypeChecker, expr: &CallExpr) -> TCState {
    trace("TypeChecker.reportFunctionCallTooManyOptions");
    let loc = toString(&expr.span);
    fprintf(stderr, "%s: %s: Could not infer which function to call.\n", loc.buffer, ERR_STR);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS);
}

func reportCallToNonFunction(this: &TypeChecker, span: Span, base: &Type) -> TCState {
    trace("TypeChecker.reportCallToNonFunction");
    let loc = toString(&span);
    let typ = toString(base);
    fprintf(stderr, "%s: %s: Can't call expression of type %s.\n", loc.buffer, ERR_STR, typ.buffer);
    fprintf(stderr, "%s: %s: Currently, all variables (including global variables) shadow functions.\n", loc.buffer, NOTE_STR);
    fprintf(stderr, "%s: %s: This is a known limitation and will be fixed soon.\n", loc.buffer, NOTE_STR);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_CALL_TO_NON_FUNCTION);
}

func reportArgumentCountMismatch(this: &TypeChecker, span: Span, base: &Type, args: usize) -> TCState {
    trace("TypeChecker.reportArgumentCountMismatch");
    let c: usize = 0;
    match (base) {
        &Type::Func(params, _, _) => { c = params.length; }
        _ => { unreachable(); }
    }
    let loc = toString(&span);
    let typ = toString(base);
    let s = "arguments";
    if (c == 1) s = "argument";
    let w = "were";
    if (args == 1) w = "was";
    fprintf(stderr, "%s: %s: Call expects %llu %s, but %llu %s provided.\n", loc.buffer, ERR_STR, c, s, args, w);
    fprintf(stderr, "%s: %s: Call expression has type %s.\n", loc.buffer, NOTE_STR, typ.buffer);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_CALL_TO_NON_FUNCTION);
}

func reportUnknownSubmodule(this: &TypeChecker, mod: &ModuleLookup, name: Token) -> TCState {
    trace("TypeChecker.reportUnknownSubmodule");
    let loc = toString(&name.span);
    let _mod = at(&modules, mod.globalID);
    let orig = toString(&_mod.span);
    let _origName = toString(&_mod.name.content);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: Module `%s` does not contain any submodules named `%s`.\n", loc.buffer, ERR_STR, _origName.buffer, _name.buffer);
    fprintf(stderr, "%s: %s: Module declared here.\n", orig.buffer, NOTE_STR);
    drop(&_name);
    drop(&_origName);
    drop(&orig);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_UNKNOWN_SUBMODULE);
}
func reportUnknownModule(this: &TypeChecker, name: Token) -> TCState {
    let loc = toString(&name.span);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: Use of undeclared module `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_MODULE);
}
func reportModuleAccessOfNonModule(this: &TypeChecker, span: Span, name: Token, typ: TypeLookup) -> TCState {
    let loc = toString(&span);
    let _name = toString(&name.content);
    fprintf(stderr, "%s: %s: `%s` is not a module, so the `::` operator cannot be applied.\n", loc.buffer, ERR_STR, _name.buffer);
    if (typ.kind != TYPE_LOOKUP_INVALID) {
        let _loc = getLocation(&typ);
        fprintf(stderr, "%s: %s: Struct declared here.\n", _loc.buffer, NOTE_STR);
        drop(&_loc);
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_MODULE_ACCESS_NON_MODULE);
}
func reportDuplicateVariant(this: &TypeChecker, orig: &ParsedUnionVariant, dupl: &UnionVariantLookup) -> TCState {
    trace("TypeChecker.reportDuplicateVariant");
    let duplLoc: String = toString(&orig.span);
    let origLoc: String = toString(&dupl.global.span);
    let name: String = toString(&orig.name.content);
    fprintf(stderr, "%s: %s: Union Variant redeclaration.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Variant `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_UNION_VARIANT);
}
func reportDuplicateNameInUnion(this: &TypeChecker, variant: &ParsedUnionVariant, first: &Token, dupl: &Token) -> TCState {
    trace("TypeChecker.reportDuplicateNameInUnion");
    let duplLoc: String = toString(&first.span);
    let origLoc: String = toString(&dupl.span);
    let name: String = toString(&first.content);
    fprintf(stderr, "%s: %s: Union Variant already contains a field with that name.\n", duplLoc.buffer, ERR_STR);
    fprintf(stderr, "%s: %s: Field `%s` already declared here.\n", origLoc.buffer, NOTE_STR, name.buffer);
    drop(&name);
    drop(&origLoc);
    drop(&duplLoc);
    this.typeError = true;
    return newTCStateFailure(ERROR_DUPLICATE_UNION_NAME);
}
func reportImpossiblePattern(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    trace("TypeChecker.reportImpossiblePattern");
    let loc = toString(&pat.span);
    let patS = toString(pat);
    let typ = toString(type);
    fprintf(stderr, "%s: %s: A value of type %s will never match the pattern `%s`.\n", loc.buffer, ERR_STR, typ.buffer, patS.buffer);
    drop(&patS);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_IMPOSSIBLE_PATTERN);
}
func reportNotEnoughPatterns(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let err = reportImpossiblePattern(this, pat, type);
    let loc = toString(&pat.span);
    fprintf(stderr, "%s: %s: Not enough patterns were provided to match the type.\n", loc.buffer, NOTE_STR);
    fprintf(stderr, "%s: %s: If you only care about certain fields, you can use `_` or `..` to ignore the rest.\n", loc.buffer, NOTE_STR);
    drop(&loc);
    return err;
}
func reportTooManyPatterns(this: &TypeChecker, pat: &ParsedPattern, type: &Type) -> TCState {
    let err = reportImpossiblePattern(this, pat, type);
    let loc = toString(&pat.span);
    fprintf(stderr, "%s: %s: Too many patterns were provided to match the type.\n", loc.buffer, NOTE_STR);
    drop(&loc);
    return err;
}

func emergencyPrint(this: &TypeChecker, where: Span) {
    let t: Token = Token {
        span: where,
        content: newSubStrOfStrLit(""),
        kind: TOKEN_EOF
    };
    printf("%s\n", getLocation(&t).buffer);
}

func typeCheckProject(this: &TypeChecker, project: &ParsedFile) -> bool {
    trace("TypeChecker.typeCheckProject");
    if (!fillLookup(this)) return false;
    if (!typeCheckFiles(this)) return false;
    if (findRecursiveTypes(this)) return false;
    return !this.typeError;
}

func dfs(this: &TypeChecker, type: &Type, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    match (type) {
        &Type::Array(under, _) => { return dfs(this, under, visited, finished); }
        &Type::Struct(decl) => {
            return dfs(this, asTypeLookup(getStructByGlobalID(&this.lookup, getID(decl))), visited, finished);
        }
        &Type::Union(decl, _) => {
            return dfs(this, asTypeLookup(getUnionByGlobalDecl(&this.lookup, decl)), visited, finished);
        }
        _ => { }
    }
    return false;
}

func dfs(this: &TypeChecker, typeLookup: TypeLookup, visited: &TypeLookupList, finished: &TypeLookupList) -> bool {
    trace("TypeChecker.dfs");
    if (contains(finished, &typeLookup))
        return false;
    if (contains(visited, &typeLookup))
        return true;
    push(visited, typeLookup);
    let done: bool = false;
    if (isStruct(&typeLookup)) {
        let strukt: &StructLookup = asStruct(&typeLookup);
        for (let i: usize = 0; i < strukt.fields.length; i = i + 1) {
            let field: &VariableLookup = at(&strukt.fields, i);
            assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
            let fieldType: &Type = getType(&field.typeState);
            if (dfs(this, fieldType, visited, finished)) {
                done = true;
            }
        }
    } else if (isUnion(&typeLookup)) {
        let onion: &UnionLookup = asUnion(&typeLookup);
        for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
            let _variant = at(&onion.variants, i);
            let variant = _variant.global;
            for (let j: usize = 0; j < variant.fields.length; j = j + 1) {
                let field = *at(&variant.fields, j);
                assert(isSuccess(&field.typeState), "Expected valid field type in DFS");
                let fieldType = getType(&field.typeState);
                if (dfs(this, fieldType, visited, finished)) {
                    done = true;
                }
            }
        }
    } else {
        unreachable("Exhaustive handling of TypeLookup kinds in dfs");
    }
    push(finished, typeLookup);
    return done;
}

func findRecursiveTypes(this: &TypeChecker) -> bool {
    trace("TypeChecker.findRecursiveTypes");
    let recursive: bool = false;
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl: &ParsedStructDecl = at(&structDecls, i);
        if (decl.ignored) continue;
        let strukt: &StructLookup = getStructByGlobalID(&this.lookup, i);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(strukt), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(strukt), &visited);
            recursive = true;
        }
    }
    for (let i: usize = 0; i < unionDecls.length; i = i + 1) {
        let decl: &ParsedUnionDecl = at(&unionDecls, i);
        if (decl.ignored) continue;
        let onion: &UnionLookup = getUnionByGlobalDecl(&this.lookup, decl);
        let visited: TypeLookupList = blank;
        let finished: TypeLookupList = blank;
        if (dfs(this, asTypeLookup(onion), &visited, &finished)) {
            reportRecursiveType(this, &asTypeLookup(onion), &visited);
            recursive = true;
        }
    }
    return recursive;
}

func fillLookup(this: &TypeChecker) -> bool {
    trace("TypeChecker.fillLookup");
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = insertFile(&this.lookup, file);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.ignored) continue;
            if (!insertTLI(this.currentModule, tli)) success = false;
        }
    }
    return success;
}

func typeCheckFiles(this: &TypeChecker) -> bool {
    trace("TypeChecker.typeCheckFiles");
    let success = true;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_STRUCT_DECL) {
                let state = typeCheckStructDecl(this, tli.nodeID);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_UNION_DECL) {
                let state = typeCheckUnionDecl(this, asUnion(tli));
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule != null);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
             let tliID: usize = *at(&file.mod.tlis, j);
             let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
             if (tli.kind == TLI_MOD_DECL) {
                 let state = typeCheckModule(this, tli.nodeID, &this.currentModule.variables);
                 if (!isSuccess(&state)) success = false;
             }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_VAR_DECL) {
                let state = typeCheckVarDecl(this, tli.nodeID, &this.currentModule.variables, true);
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    if (!success) return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        assert(getID(file) == i);
        this.currentModule = at(&this.lookup.files, i);
        assert(this.currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tliID: usize = *at(&file.mod.tlis, j);
            let tli: &ParsedTopLevelItem = at(&topLevelItems, tliID);
            if (tli.kind == TLI_FUNC_DECL) {
                let state = typeCheckFunction(this, tli.nodeID, &this.currentModule.variables, false);
                let _dupl: &FunctionLookup = null;
                let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
                if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                    assert(_dupl != null, "Duplicate FunctionLookup is null");
                    reportDuplicateFunction(this, funcLookup, _dupl);
                    success = false;
                }
                if (!isSuccess(&state)) success = false;
            }
        }
    }
    return success;
}

// FIXME: This function is a mess
func typeCheckModule(this: &TypeChecker, modID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckModule");
    let mod = at(&modules, modID);
    let prev = this.currentModule;
    this.currentModule = getModuleByGlobalID(&this.lookup, modID);
    let result = newTCStateSuccess();
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_STRUCT_DECL) {
            let state = typeCheckStructDecl(this, tli.nodeID);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_UNION_DECL) {
            let state = typeCheckUnionDecl(this, asUnion(tli));
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_MOD_DECL) {
            let state = typeCheckModule(this, tli.nodeID, scopes);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_VAR_DECL) {
            let state = typeCheckVarDecl(this, tli.nodeID, scopes, true);
            if (!isSuccess(&state)) result = state;
        }
    }
    if (!isSuccess(&result)) {
        this.currentModule = prev;
        return result;
    }
    for (let i: usize = 0; i < mod.tlis.length; i = i + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&mod.tlis, i));
        if (tli.kind == TLI_FUNC_DECL) {
            let state = typeCheckFunction(this, tli.nodeID, scopes, false);
            let _dupl: &FunctionLookup = null;
            let funcLookup = getFunctionByGlobalID(this.currentModule, tli.nodeID);
            if (containsDuplicateFunction(this.currentModule, funcLookup, &_dupl)) {
                assert(_dupl != null, "Duplicate FunctionLookup is null");
                result = reportDuplicateFunction(this, funcLookup, _dupl);
            }
            if (!isSuccess(&state)) result = state;
        }
    }
    this.currentModule = prev;
    return result;
}

func typeCheckUnionDecl(this: &TypeChecker, onion: &ParsedUnionDecl) -> TCState {
    trace("TypeChecker.typeCheckUnionDecl");
    if (onion.ignored) return blank;
    let unionLookup = getUnionByGlobalDecl(&this.lookup, onion);
    let result = newTCStateType(wrap(Type::Union(onion, 0)));
    for (let i: usize = 0; i < onion.variants.length; i = i + 1) {
        let variant = *at(&onion.variants, i);
        /*
        union Foo {
            A,
            B
        }
        typeof(Foo::A) == Foo
        typeof(Foo::B) == Foo
         */
        let state: TCState = newTCStateType(wrap(Type::Union(onion, 0)));
        let dupl: &UnionVariantLookup = null;
        if (checkForDuplicateVariant(unionLookup, variant, &dupl)) {
            result = reportDuplicateVariant(this, variant, dupl);
        }
        if (variant.kind == UNION_VARIANT_EMPTY) {
            assert(variant.fields.length == 0, "Empty Union Variant has fields");
            assert(variant.names.length == 0, "Empty Union Variant has fields");
        }
        assert(variant.names.length == variant.fields.length, "Union Variant name and field length mismatch");
        for (let j: usize = 0; j < variant.fields.length; j = j + 1) {
            let field = *at(&variant.fields, j);
            let name = at(&variant.names, j);
            let duplName: &Token = null;
            if (checkForDuplicateName(variant, name, &duplName)) {
                result = reportDuplicateNameInUnion(this, variant, name, duplName);
                break;
            }
            let fieldState = typeCheckTypeNode(this, field);
            if (!isSuccess(&fieldState)) {
                result = fieldState;
            }
        }
        addVariant(unionLookup, variant, state);
    }
    if (isSuccess(&result)) {
        onion.typeState = result;
    }
    return result;
}

// FIXME: getStructByGlobalID -> getStructByGlobalDecl
func typeCheckStructDecl(this: &TypeChecker, structID: usize) -> TCState {
    trace("TypeChecker.typeCheckStructDecl");
    let strukt: &ParsedStructDecl = at(&structDecls, structID);
    if (strukt.ignored) return blank;
    let structLookup: &StructLookup = getStructByGlobalID(&this.lookup, structID);
    let context: &StructContext = &strukt.context;
    let result: TCState = newTCStateSuccess();
    let failure: TCState = blank;
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let typ = getFieldTypeAtIndex(context, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateField(structLookup, &name, &dupl)) {
            failure = reportDuplicateField(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        addField(structLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    (*strukt).typeState = newTCStateSuccess();
    return result;
}

func typeCheckFunction(this: &TypeChecker, funcID: usize, scopes: &ScopeLookupList, signatureOnly: bool) -> TCState {
    trace("TypeChecker.typeCheckFunction");
    let function: &ParsedFuncDecl = at(&funcDecls, funcID);
    if (function.ignored) return blank;
    let funcLookup = getFunctionByGlobalID(&this.lookup, funcID);
    this.currentFunction = funcLookup;
    let failure: TCState = blank;
    clear(&funcLookup.params);
    let params: TypeList = blank;
    for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
        let typ = getTypeAtIndex(&function.params, i);
        let name: Token = getNameAtIndex(&function.params, i);
        let dupl: VariableLookup = blank;
        if (checkForDuplicateParam(funcLookup, &name, &dupl)) {
            failure = reportDuplicateParameter(this, name, dupl.name.span);
            continue;
        }
        let state: TCState = typeCheckTypeNode(this, typ);
        if (isError(&state)) {
            failure = state;
            continue;
        }
        push(&params, getType(&state));
        addParameter(funcLookup, NODE_ID_OFFSET + i, name, state);
    }
    if (!isInvalid(&failure)) return failure;
    let retState: TCState = typeCheckTypeNode(this, function.retType);
    if (isError(&retState)) return retState;
    let fnType = wrap(Type::Func(params, getType(&retState), FuncAttr {
        isVariadic: function.params.isVarArg,
        isNoreturn: hasAttribute(function, ATTR_NORETURN)
    }));
    let state = newTCStateType(fnType);
    funcLookup.fnType = state;
    function.typeState = state;
    if (isExtern(function)) {
        if (!function.parent.isFile) {
            let mod = getParentModule(function);
            let _name = getMangledName(function);
            if (mod.dlls.length == 0) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    fprintf(stderr, "%s: %s: No dynamic library was found for external function %s. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNotFound();
            }
            let addrFound = false;
            for (let i: usize = 0; i < mod.dlls.length; i = i + 1) {
                let dll = at(&dlls, *at(&mod.dlls, i));
                @os(WINDOWS) let handle = GetProcAddress(dll.handle, _name.buffer);
                @os(LINUX) let handle = dlsym(dll.handle, _name.buffer);
                if (!isNull(handle)) {
                    function.dllHandle = newDLL(dll.path, handle);
                    addrFound = true;
                    break;
                }
            }
            if (!addrFound && function.dllHandle != dllNotFound()) {
                if (*flags.warnSimple) {
                    let loc = toString(&function.span);
                    fprintf(stderr, "%s: %s: Could not find external function %s in any DLL. You will not be able to call it at compile time.\n",
                        loc.buffer, WARN_STR, _name.buffer);
                    drop(&loc);
                }
                function.dllHandle = dllNoSuchFunction();
            }
            drop(&_name);
        } else {
        }
        return function.typeState;
    }
    if (signatureOnly) {
        return newTCStateSuccess();
    }
    let scope: ScopeLookup = blank;
    for (let i: usize = 0; i < funcLookup.params.length; i = i + 1) {
        addVariable(&scope, *(at(&funcLookup.params, i)));
    }
    push(scopes, scope);
    let blockState: TCState = typeCheckBlock(this, function.body, scopes);
    pop(scopes);
    if (isError(&blockState)) {
        return blockState;
    }
    return function.typeState;
}

func typeCheckBlock(this: &TypeChecker, block: &ParsedBlock, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckBlock");
    if (block.ignored) return blank;
    if (isSuccess(&block.typeState)) {
        return block.typeState;
    }
    push(scopes, ScopeLookup {
        variables: blank,
    });
    let curr: usize = scopes.length;
    // REVIEW: Do we want to make blocks expressions?
    let blockState: TCState = newTCStateSuccess();
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmtState: TCState = typeCheckStmt(this, getStmtAtIndex(block, i), scopes);
        if (isError(&stmtState)) {
            blockState = stmtState;
        }
    }
    let after: usize = scopes.length;
    pop(scopes);
    assert(after == curr, "Stack imbalance");
    if (isError(&blockState)) return blockState;
    (*block).typeState = newTCStateSuccess();
    return block.typeState;
}

func typeCheckStmt(this: &TypeChecker, stmt: &ParsedStmt, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckStmt");
    if (stmt.ignored) return blank;
    if (isSuccess(&stmt.typeState)) return stmt.typeState;
    let state = newTCStateSuccess();
    match (&stmt.data) {
        &StmtData::VarDecl(_) => { return typeCheckVarDecl(this, stmt, scopes, false); }
        &StmtData::ReturnEmpty => {
            trace("TypeChecker.typeCheckStmt: ReturnEmpty");
            assert(this.currentFunction != null);
            let retState: &TCState = &this.currentFunction.fnType;
            let _rt = getType(retState);
            let retType = getReturnType(_rt);
            if (!isNone(retType)) {
                printf("%s\n", toString(&stmt.span).buffer);
                printf("%s\n", toString(retType).buffer);
                todo_with_msg("function returns something, but we wrote return;");
            }
        }
        &StmtData::ReturnExpr(expr) => {
            trace("TypeChecker.typeCheckStmt: ReturnExpr");
            let exprState: TCState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            assert(this.currentFunction != null);
            let retState: &TCState = &this.currentFunction.fnType;
            assert(isSuccess(retState), "ready to use function has invalid return type");
            assert(isType(retState), "ready to use function has non-type as return type");
            let _rt = getType(retState);
            let retType = getReturnType(_rt);
            if (isNone(retType)) todo_with_msg("unexpected ret expr where empty function");
            if (wantsInfer(&exprState)) {
                exprState = inferTypeOntoExpr(this, expr, retType, scopes);
                if (isError(&exprState)) return exprState;
                assert(isType(&exprState), "Failed to infer type of return expression");
            }
            let exprType: &Type = getType(&exprState);
            if (!equals(exprType, retType)) {
                return reportTypeMismatch(this, stmt.span, retType, exprType);
            }
            state = *retState;
        }
        &StmtData::Expr(expr) => {
            trace("TypeChecker.typeCheckStmt: Expr");
            let exprState: TCState = typeCheckExpr(this, expr, scopes);
            if (isError(&exprState)) return exprState;
            if (wantsInfer(&exprState)) {
                let noneType: &Type = wrap(Type::Prim(PrimType::None));
                exprState = inferTypeOntoExpr(this, expr, noneType, scopes);
            }
            if (!isType(&exprState)) {
                printf("%s\n", toString(&stmt.span).buffer);
                printf("%llu\n", exprState.kind);
                todo_with_msg("what is it then");
            }
            let exprType: &Type = getType(&exprState);
            if (!isNone(exprType) && !isAssignment(expr) && *flags.warnUnused) {
                let loc: String = toString(&expr.span);
                fprintf(stderr, "%s: %s: Unused expression value.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            state = exprState;
        }
        &StmtData::Block(block) => { state = typeCheckBlock(this, block, scopes); }
        &StmtData::If(cond, then) => {
            trace("TypeChecker.typeCheckStmt: If");
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let thenState: TCState = typeCheckStmt(this, then, scopes);
            if (isError(&condState)) return condState;
            if (isError(&thenState)) return thenState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto if-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::IfElse(cond, then, elze) => {
            trace("TypeChecker.typeCheckStmt: IfElse");
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let thenState: TCState = typeCheckStmt(this, then, scopes);
            let elseState: TCState = typeCheckStmt(this, elze, scopes);
            if (isError(&condState)) return condState;
            if (isError(&thenState)) return thenState;
            if (isError(&elseState)) return elseState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto if-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::While(cond, body) => {
            trace("TypeChecker.typeCheckStmt: While");
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let bodyState: TCState = typeCheckStmt(this, body, scopes);
            if (isError(&condState)) return condState;
            if (isError(&bodyState)) return bodyState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto while-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::CFor { init, cond, step, body } => {
            trace("TypeChecker.typeCheckStmt: CFor");
            push(scopes, blank);
            let initState: TCState = typeCheckStmt(this, init, scopes);
            let condState: TCState = typeCheckExpr(this, cond, scopes);
            let stepState: TCState = typeCheckExpr(this, step, scopes);
            let bodyState: TCState = typeCheckStmt(this, body, scopes);
            pop(scopes);
            if (isError(&initState)) return initState;
            if (isError(&condState)) return condState;
            if (isError(&stepState)) return stepState;
            if (isError(&bodyState)) return bodyState;
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            if (wantsInfer(&condState)) {
                condState = inferTypeOntoExpr(this, cond, boolType, scopes);
                assert(isType(&condState), "Could not infer type onto for-condition");
            }
            let condType: &Type = getType(&condState);
            if (!isBoolean(condType)) {
                return reportTypeMismatch(this, cond.span, boolType, condType);
            }
        }
        &StmtData::Break => { }
        &StmtData::Continue => { }
        &StmtData::Match(_,_,_) => { return typeCheckMatchStmt(this, stmt, scopes); }
        unknown => {
            fprintf(stderr, "%s typeCheckStmt: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    if (isError(&state)) return state;
    stmt.typeState = state;
    return state;
}

func typeCheckMatchStmt(this: &TypeChecker, match: &ParsedStmt, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckMatchStmt");
    let expr: &ParsedExpr = null;
    let patterns: &ParsedPatternList = null;
    let stmts: &ParsedStmtList = null;
    match (&match.data) {
        &StmtData::Match(_expr, _patterns, _stmts) => {
            expr = _expr;
            patterns = &_patterns;
            stmts = &_stmts;
        }
        _ => { unreachable(); }
    }
    let exprState = typeCheckExpr(this, expr, scopes);
    if (isError(&exprState)) return exprState;
    if (wantsInfer(&exprState)) todo_with_msg("match expr wants infer");
    let type = getType(&exprState);
    assert(patterns.length == stmts.length);
    let result = newTCStateSuccess();
    let complete = false;
    // TODO: typeCheckMatchStmt: Check for exhaustive pattern matching
    // TODO: How do we know if we exhausted all union patterns?
    // TODO: How do we know if we exhausted any pattern?
    for (let i: usize = 0; i < patterns.length; i = i + 1) {
        let scope: ScopeLookup = blank;
        let pat = *at(patterns, i);
        let patState = checkAndBindPattern(this, type, pat, &scope);
        if (isError(&patState)) {
            result = patState;
            continue;
        }
        assert(isPattern(&patState));
        let _patState = getPatState(&patState);
        push(scopes, scope);
        let stmt = *at(stmts, i);
        let stmtState = typeCheckStmt(this, stmt, scopes);
        pop(scopes);
        complete = _patState.complete;
        if (complete && i != patterns.length - 1) {
            let next = *at(patterns, i + 1);
            let loc = toString(&next.span);
            fprintf(stderr, "%s: %s: Unreachable pattern.\n", loc.buffer, WARN_STR);
            drop(&loc);
            patterns.length = i + 1;
            stmts.length = i + 1;
        }
    }
    if (isError(&result)) return result;
    if (!complete) {
        let loc = toString(&match.span);
        fprintf(stderr, "%s: %s: Patterns of a match statement must be exhaustive.\n", loc.buffer, ERR_STR);
        let wildcard = tokenKindToString(TOKEN_WILDCARD);
        fprintf(stderr, "%s: %s: You can use the wildcard pattern %s to catch all other cases.\n", loc.buffer, NOTE_STR, wildcard);
        drop(&loc);
        return newTCStateFailure(ERROR_NON_EXHAUSTIVE_MATCH);
    }
    // match.typeState doesn't work because Parser treats match as start of statement
    (match.typeState = newTCStatePattern(PatState {
        complete: true
    }));
    return result;
}

func checkAndBindPattern(this: &TypeChecker, type: &Type, pat: &ParsedPattern, scope: &ScopeLookup) -> TCState {
    trace("TypeChecker.checkAndBindPattern");
    // TODO: This is a good spot to test match statements after the refactor :^)
    match (&pat.data) {
        &Pattern::Ident(ident) => {
            let loc: Token = blank;
            if (isKnownVariable(scope, ident.content, &loc)) {
                todo_with_msg("pat ident exists, check type");
            }
            addVariable(scope, VariableLookup {
                globalID: getID(pat),
                name: ident,
                typeState: newTCStateType(type),
                isComptime: false,
            });
            return newTCStatePattern(PatState {
                complete: true,
            });
        }
        &Pattern::Reference(sub) => {
            // REVIEW: Make &pat check for null?
            match (type) {
                &Type::Ptr(under) => { return checkAndBindPattern(this, under, sub, scope); }
                _ => { return reportImpossiblePattern(this, pat, type); }
            }
        }
        &Pattern::Boolean(_) => {
            if (!isBoolean(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return newTCStatePattern(PatState {
                complete: false
            });
        }
        &Pattern::Null => {
            if (!isPointer(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return newTCStatePattern(PatState {
                complete: false
            });
        }
        &Pattern::Path(name, subPat) => {
            let ident: Token = blank;
            match (&subPat.data) {
                &Pattern::Ident(_ident) => { ident = _ident; }
                &Pattern::Struct(_ident, _) => { ident = _ident; }
                _ => { unreachable("Path Pattern expected Ident or Struct as RHS"); }
            }
            match (type) {
                &Type::Union(decl, _) => {
                    if (!equals(&name.content, &decl.name.content)) {
                        return reportImpossiblePattern(this, pat, type);
                    }
                    let variant: &ParsedUnionVariant = null;
                    if (!resolveVariantByName(decl, &ident, &variant)) {
                        todo_with_msg("checkAndBindPattern: Path pattern Union doesn't have variant");
                    }
                    match (&subPat.data) {
                        &Pattern::Ident(ident) => {
                            if (variant.kind != UNION_VARIANT_EMPTY) {
                                todo_with_msg("checkAndBindPattern: Union Pattern ident not empty");
                            }
                        }
                        &Pattern::Struct(ident, subPatterns) => {
                            // FIXME: Code duplication with Pattern::Struct a few lines below
                            if (subPatterns.length > variant.fields.length) {
                                if (subPatterns.length == variant.fields.length + 1) {
                                    let last = *at(&subPatterns, subPatterns.length - 1);
                                    if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                        return reportTooManyPatterns(this, pat, type);
                                    }
                                } else {
                                    return reportTooManyPatterns(this, pat, type);
                                }
                            }
                            if (subPatterns.length < variant.fields.length) {
                                if (subPatterns.length > 0) {
                                    let last = *at(&subPatterns, subPatterns.length - 1);
                                    if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                        return reportNotEnoughPatterns(this, pat, type);
                                    }
                                } else {
                                    return reportNotEnoughPatterns(this, pat, type);
                                }
                            }
                            let complete = true;
                            for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
                                let subSubPat = *at(&subPatterns, i);
                                let field = *at(&variant.fields, i);
                                assert(isSuccess(&field.typeState), "checkAndBindPattern: Invalid field type");
                                let fieldType = getType(&field.typeState);
                                let subComplete = checkAndBindPattern(this, fieldType, subSubPat, scope);
                                if (isError(&subComplete)) return subComplete;
                                if (!getPatState(&subComplete).complete) {
                                    complete = false;
                                }
                                if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
                            }
                        }
                        _ => { unreachable("Expected Ident Pattern or Struct Pattern as RHS of Path Pattern"); }
                    }
                    return newTCStatePattern(PatState {
                        complete: false
                    });
                }
                type => {
                    let moduleLookup: &ModuleLookup = null;
                    if (resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
                        return checkAndBindPattern(this, type, subPat, scope);
                    } else {
                        return reportImpossiblePattern(this, pat, type);
                    }
                }
            }
        }
        &Pattern::Struct(name, subPatterns) => {
            match (type) {
                &Type::Struct(decl) => {
                    let lookup = getStructByGlobalID(&this.lookup, getID(decl));
                    if (!equals(&name.content, &lookup.name.content)) {
                        return reportImpossiblePattern(this, pat, type);
                    }
                    if (subPatterns.length > lookup.fields.length) {
                        if (subPatterns.length == lookup.fields.length + 1) {
                            let last = *at(&subPatterns, subPatterns.length - 1);
                            if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                return reportTooManyPatterns(this, pat, type);
                            }
                        } else {
                            return reportTooManyPatterns(this, pat, type);
                        }
                    }
                    if (subPatterns.length < lookup.fields.length) {
                        if (subPatterns.length > 0) {
                            let last = *at(&subPatterns, subPatterns.length - 1);
                            if (tag(&last.data) != comptime tag(&Pattern::Rest)) {
                                return reportNotEnoughPatterns(this, pat, type);
                            }
                        } else {
                            return reportNotEnoughPatterns(this, pat, type);
                        }
                    }
                    let complete = true;
                    for (let i: usize = 0; i < lookup.fields.length; i = i + 1) {
                        // FIXME: Struct Pattern should bind by name, not index
                        let subpat = *at(&subPatterns, i);
                        let field = at(&lookup.fields, i);
                        assert(isSuccess(&field.typeState), "checkAndBindPattern: Invalid field type");
                        let fieldType = getType(&field.typeState);
                        let subComplete = checkAndBindPattern(this, fieldType, subpat, scope);
                        if (isError(&subComplete)) return subComplete;
                        if (!getPatState(&subComplete).complete) {
                            complete = false;
                        }
                        if (tag(&subpat.data) == comptime tag(&Pattern::Rest)) break;
                    }
                    return newTCStatePattern(PatState {
                        complete: complete
                    });
                }
                _ => { return reportImpossiblePattern(this, pat, type); }
            }
        }
        &Pattern::Number(_) => {
            if (!isInteger(type) && !isFloat(type)) {
                return reportImpossiblePattern(this, pat, type);
            }
            return newTCStatePattern(PatState {
                complete: false
            });
        }
        &Pattern::Wildcard => { return newTCStatePattern(PatState { complete: true }); }
        &Pattern::Rest     => { return newTCStatePattern(PatState { complete: true }); }
        _ => { }
    }
    unreachable("Exhaustive handling of patterns in checkAndBindPattern");
}

func typeCheckVarDecl(this: &TypeChecker, varDeclID: usize, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    return typeCheckVarDecl(this, at(&stmts, varDeclID), scopes, globalScope);
}
func typeCheckVarDecl(this: &TypeChecker, varDecl: &ParsedStmt, scopes: &ScopeLookupList, globalScope: bool) -> TCState {
    trace("TypeChecker.typeCheckVarDecl");
    if (varDecl.ignored) return blank;
    // TODO: Split StmtData::VarDecl into a version that has a type, and one that doesn't
    match (&varDecl.data) {
        &StmtData::VarDecl(VarDecl { name, type, expr, isComptime, .. }) => {
            let last: &ScopeLookup = last(scopes);
            let typeState: TCState = blank;
            let exprState: TCState = blank;
            if (isSuccess(&varDecl.typeState)) {
                typeState = varDecl.typeState;
                exprState = varDecl.typeState;
            } else {
                let loc: Token = blank;
                if (*flags.warnSimple) {
                    for (let i: usize = 0; i < scopes.length - 1; i = i + 1) {
                        let s = at(scopes, i);
                        let _loc: Token = blank;
                        if (isKnownVariable(s, name.content, &_loc)) {
                            let loc1 = toString(&name.span);
                            let loc2 = toString(&_loc.span);
                            let name = toString(&name.content);
                            fprintf(stderr, "%s: %s: Shadowing variable `%s` from an outer scope.\n", loc1.buffer, WARN_STR, name.buffer);
                            fprintf(stderr, "%s: %s: Variable with the same name already declared here.\n", loc2.buffer, NOTE_STR);
                            drop(&name);
                            drop(&loc2);
                            drop(&loc1);
                        }
                    }
                }
                if (!globalScope && isKnownVariable(last, name.content, &loc)) {
                    return reportVariableRedeclaration(this, name, loc);
                }
                if (type != null) {
                    typeState = typeCheckTypeNode(this, type);
                    if (isError(&typeState)) return typeState;
                    if (!isType(&typeState)) todo_with_msg("let type is not a type");
                }
                this.isComptimeContext = isComptime;
                exprState = typeCheckExpr(this, expr, scopes);
                this.isComptimeContext = false;
                if (type == null) {
                    // let var = expr;
                    assert(isInvalid(&typeState), "`let var = expr;` got valid type state??");
                    if (isError(&exprState)) return exprState;
                    if (wantsInfer(&exprState)) {
                    } else if (!isType(&exprState)) {
                        todo_with_msg("let expr is not a type");
                    }
                    typeState = exprState;
                } else {
                    // let var: type = expr;
                    if (wantsInfer(&exprState)) {
                        exprState = inferTypeOntoExpr(this, expr, getType(&typeState), scopes);
                    }
                    if (isType(&exprState)) {
                        let typeType: &Type = getType(&typeState);
                        let exprType: &Type = getType(&exprState);
                        if (!equals(typeType, exprType)) {
                            exprState = reportTypeMismatch(this, expr.span, typeType, exprType);
                        }
                    }
                }
            }
            if (globalScope) {
                let index: usize = 0;
                assert(getVarIndexByName(last, name.content, &index), "Could not find variable in global scope");
                let var: &VariableLookup = getVariableAtIndex(last, index);
                var.typeState = typeState;
            } else {
                addVariable(last, VariableLookup {
                    globalID: getID(varDecl),
                    name: name,
                    typeState: typeState,
                    isComptime: isComptime,
                });
            }
            if (isError(&exprState)) return exprState;
            varDecl.typeState = typeState;
            return typeState;
        }
        _ => { }
    }
    unreachable("typeCheckVarDecl: Expected VarDecl");
}

func typeCheckExpr(this: &TypeChecker, exprID: usize, scopes: &ScopeLookupList) -> TCState {
    return typeCheckExpr(this, at(&exprs, exprID), scopes);
}
func typeCheckExpr(this: &TypeChecker, expr: &ParsedExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExpr");
    if (expr.ignored) return blank;
    if (isSuccess(&expr.typeState)) return expr.typeState;
    let state: TCState = blank;
    match (&expr.data) {
        &ExprData::IntLit(_) => { state = newTCStatePleaseInfer(); }
        &ExprData::StrLit(_) => {
            let ct = wrap(Type::Prim(PrimType::Char));
            let st = wrap(Type::Ptr(ct));
            state = newTCStateType(st);
        }
        &ExprData::CharLit(_) => {
            let ct = wrap(Type::Prim(PrimType::Char));
            state = newTCStateType(ct);
        }
        &ExprData::ArrayLit(context) => {
            if (context.elemLength == 0) return newTCStatePleaseInfer();
            let elemIndex: usize = getElementAtIndex(&context, 0);
            let elemState: TCState = typeCheckExpr(this, elemIndex, scopes);
            if (isError(&elemState)) return elemState;
            if (wantsInfer(&elemState)) return elemState;
            let elemType: &Type = getType(&elemState);
            if (context.size == 0) {
                let lastErrState: TCState = blank;
                for (let i: usize = 1; i < context.elemLength; i = i + 1) {
                    let nextIndex: usize = getElementAtIndex(&context, i);
                    let nextState: TCState = typeCheckExpr(this, nextIndex, scopes);
                    if (isError(&nextState)) {
                        lastErrState = nextState;
                        continue;
                    }
                    let nextType: &Type = getType(&nextState);
                    if (!equals(nextType, elemType)) {
                        let loc = toString(&at(&exprs, elemIndex).span);
                        let t = toString(elemType);
                        lastErrState = reportTypeMismatch(this, at(&exprs, nextIndex).span, elemType, nextType);
                        fprintf(stderr, "%s: %s: Array elements inferred to be type %s here.\n", loc.buffer, NOTE_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                    }
                }
                if (!isInvalid(&lastErrState)) return lastErrState;
                let t: &Type = wrap(Type::Array(elemType, context.elemLength));
                state = newTCStateType(t);
            } else {
                let t: &Type = wrap(Type::Array(elemType, context.size));
                state = newTCStateType(t);
            }
        }
        &ExprData::Ident(ident) => { state = typeCheckIdentifier(this, &ident, scopes); }
        &ExprData::Unary(unary) => { state = typeCheckExprUnary(this, &unary, scopes); }
        &ExprData::Binary(binary) => { state = typeCheckExprBinary(this, &binary, scopes); }
        &ExprData::Call(call) => {
            state = typeCheckExprCall(this, &call, scopes);
            if (call.isUnion) {
                expr.data = ExprData::UnionInit(UnionExpr::Tuple(call));
            }
        }
        &ExprData::Sizeof(type) => {
            let typeState: TCState = typeCheckTypeNode(this, type);
            if (isError(&typeState)) return typeState;
            state = newTCStateType(wrap(Type::Prim(PrimType::Usize)));
        }
        &ExprData::StructInit(init) => { state = typeCheckExprStructInit(this, &init, scopes); }
        &ExprData::As(expr, type) => { state = typeCheckExprAs(this, expr, type, scopes); }
        &ExprData::Null => { state = newTCStatePleaseInfer(); }
        &ExprData::Blank => { state = newTCStatePleaseInfer(); }
        &ExprData::True => { state = newTCStateType(wrap(Type::Prim(PrimType::Bool))); }
        &ExprData::False => { state = newTCStateType(wrap(Type::Prim(PrimType::Bool))); }
        unknown => {
            fprintf(stderr, "%s Unhandled Expression with tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    if (isError(&state)) return state;
    expr.typeState = state;
    return state;
}

func typeCheckExprAs(this: &TypeChecker, expr: &ParsedExpr, type: &ParsedTypeNode, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAs");
    let exprState: TCState = typeCheckExpr(this, expr, scopes);
    let typeState: TCState = typeCheckTypeNode(this, type);
    if (isError(&exprState)) return exprState;
    if (isError(&typeState)) return typeState;
    assert(isType(&typeState), "typeCheckExprAs Type is not a Type");
    let typeType: &Type = getType(&typeState);
    if (wantsInfer(&exprState)) exprState = inferTypeOntoExpr(this, expr, typeType, scopes);
    if (isError(&exprState)) return exprState;
    assert(isType(&exprState), "Expected <expr> in `<expr> as <type>` to have a valid type after infer");
    let exprType: &Type = getType(&exprState);
    if (isPointer(exprType) && isPointer(typeType)) {
        // PTR as PTR is allowed
    } else if (isFunction(exprType) && isFunction(typeType)) {
        // Function as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from type %s to type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isFunction(exprType) && isAny(typeType)) {
        // Function as Any is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let from = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from type %s to Any.\n",
                loc.buffer, WARN_STR, from.buffer);
            drop(&from);
            drop(&loc);
        }
    } else if (isAny(exprType) && isFunction(typeType)) {
        // Any as Function is allowed
        if (*flags.warnExtra) {
            let loc = toString(&expr.span);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting from Any to type %s.\n",
                loc.buffer, WARN_STR, to.buffer);
            drop(&to);
            drop(&loc);
        }
    } else if (isPointer(exprType) && isInteger(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting pointer of type %s to integer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (isInteger(exprType) && isPointer(typeType)) {
        if (getSize(typeType) != getSize(exprType)) {
            let loc = toString(&expr.span);
            let from = toString(exprType);
            let to = toString(typeType);
            fprintf(stderr, "%s: %s: Casting integer of type %s to pointer of type %s.\n",
                loc.buffer, WARN_STR, from.buffer, to.buffer);
            drop(&to);
            drop(&from);
            drop(&loc);
        }
    } else if (!isPrimitive(typeType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    } else if (!isPrimitive(exprType)) {
        return reportNonPrimitiveCast(this, expr.span, exprType, typeType);
    }
    if (getSize(typeType) < getSize(exprType) && *flags.warnExtra) {
        let loc: String = toString(&expr.span);
        let tName: String = toString(typeType);
        let oName: String = toString(exprType);
        fprintf(stderr, "%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n",
            loc.buffer, WARN_STR, tName.buffer, oName.buffer);
        drop(&oName);
        drop(&tName);
        drop(&loc);
    }
    return typeState;
}

func typeCheckExprUnary(this: &TypeChecker, unary: &UnaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprUnary");
    let lhs: &ParsedExpr = null;
    extractOperand(unary, &lhs);
    let exprState: TCState = typeCheckExpr(this, lhs, scopes);
    if (isError(&exprState)) return exprState;
    if (wantsInfer(&exprState)) return exprState; // Can't be done in here
    let exprType: &Type = getType(&exprState);
    match (unary) {
        &UnaryExpr::Comptime(_) => { return exprState; }
        &UnaryExpr::Deref(_) => {
            match (exprType) {
                &Type::Prim(PrimType::Any) => { return reportAnyDereference(this, lhs); }
                &Type::Ptr(under) => { return newTCStateType(under); }
                t => {
                    let loc: String = toString(&lhs.span);
                    let t: String = toString(exprType);
                    fprintf(stderr, "%s: %s: Attempted to dereference expression of type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    return newTCStateFailure(ERROR_DEREF_NON_POINTER);
                }
            }
        }
        &UnaryExpr::Ref(_) => {
            return newTCStateType(wrap(Type::Ptr(exprType)));
        }
        &UnaryExpr::Negate(_) => {
            if (!isSignedInteger(exprType) && !isFloat(exprType)) {
                let loc: String = toString(&lhs.span);
                let t: String = toString(exprType);
                fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
                this.typeError = true;
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        }
        &UnaryExpr::Not(_) => {
            if (!isBoolean(exprType)) {
                let loc: String = toString(&lhs.span);
                let t: String = toString(exprType);
                fprintf(stderr, "%s: %s: Logical Not is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                drop(&t);
                drop(&loc);
                this.typeError = true;
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            return exprState;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of ops in typeCheckUnary");
}

func typeCheckExprCall(this: &TypeChecker, call: &CallExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprCall");
    // First sweep
    let args = &call.args;
    for (let i: usize = 0; i < args.length; i = i + 1) {
        let arg: TCState = typeCheckExpr(this, *at(args, i), scopes);
        if (isError(&arg)) return arg;
    }
    let callBase = typeCheckExpr(this, call.base, scopes);
    if (isError(&callBase)) return callBase;
    if (wantsInfer(&callBase)) {
        let params: TypeList = blank;
        for (let i: usize = 0; i < args.length; i = i + 1) {
            let typ = wrap(Type::Unknown);
            let state = &(*at(args, i)).typeState;
            if (isType(state)) typ = getType(state);
            push(&params, typ);
        }
        let fnType = wrap(Type::Func(params, wrap(Type::Unknown), blank));
        let baseState = tryInferTypeOntoExpr(this, call.base, fnType, scopes, false);
        if (isError(&baseState)) return baseState;
        if (wantsInfer(&baseState)) return baseState;
        callBase = baseState;
    }
    let baseType = getType(&callBase);
    match (baseType) {
        &Type::Union(decl, vID) => {
            let variant = *at(&decl.variants, vID);
            if (variant.kind != UNION_VARIANT_TUPLE) todo_with_msg("report error: Union Variant is not a tuple");
            if (args.length != variant.fields.length) todo_with_msg("report error: Tuple variant count mismatch");
            let unionType = copy(baseType);
            for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
                let arg = *at(args, i);
                let argState = typeCheckExpr(this, arg, scopes);
                if (isError(&argState)) return argState;
                let paramType = getTypeAtIndex(variant, i);
                if (wantsInfer(&argState)) {
                    argState = inferTypeOntoExpr(this, arg, paramType, scopes);
                    if (isError(&argState)) return argState;
                }
                let argType = getType(&argState);
                if (!equals(argType, paramType)) {
                    reportTypeMismatch(this, arg.span, paramType, argType);
                }
            }
            call.isUnion = true;
            return newTCStateType(unionType);
        }
        &Type::Func(params, ret, attr) => {
            if (!attr.isVariadic && args.length != params.length) {
                return reportArgumentCountMismatch(this, call.span, baseType, args.length);
            }
            for (let i: usize = 0; i < params.length; i = i + 1) {
                let arg = *at(args, i);
                let paramType = *at(&params, i);
                let argState: TCState = typeCheckExpr(this, arg, scopes);
                if (isError(&argState)) return argState;
                if (wantsInfer(&argState)) {
                    argState = inferTypeOntoExpr(this, arg, paramType, scopes);
                    if (isError(&argState)) return argState;
                }
                let argType = getType(&argState);
                if (!equals(argType, paramType)) {
                    reportTypeMismatch(this, arg.span, paramType, argType);
                }
            }
            call.retType = ret;
            return newTCStateType(ret);
        }
        _ => { return reportCallToNonFunction(this, call.span, baseType); }
    }
    unreachable();
}

func typeCheckExprStructInit(this: &TypeChecker, expr: &StructExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprStructInit");
    let lookup: TypeLookup = blank;
    if (!resolveTypeByName(this.currentModule, &expr.name, &lookup)) {
        let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &expr.name);
        return reportUnknownType(this, null, expr.name, alternatives);
    }
    if (isStruct(&lookup)) {
        return typeCheckStructInitialization(this, expr, lookup, scopes);
    } else {
        unreachable("typeCheckExprStructInit got non-struct");
    }
}

func typeCheckIdentifier(this: &TypeChecker, ident: &IdentExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckIdentifier");
    let var: VariableLookup = blank;
    let name = &ident.name;
    if (resolveVariableByName(this.currentModule, name, scopes, &var)) {
        if (this.isComptimeContext && !var.isComptime) {
            reportRuntimeValueInComptimeContext(this, *name, &var);
        }
        let state: TCState = var.typeState;
        assert(!isInvalid(&state), "Variable not ready");
        if (isError(&state)) return state;
        let _loc: Token = blank;
        if (isKnownVariable(at(scopes, 0), name.content, &_loc)) {
            ident.isGlobal = true;
        }
        if (isType(&state)) {
            ident.type = getType(&state);
        }
        ident.origID = var.globalID;
        return state;
    }
    let functions = resolveFunctionByName(this.currentModule, name);
    if (functions.length > 1) {
        drop(&functions);
        return newTCStatePleaseInfer();
    }
    if (functions.length == 1) {
        let f = at(&functions, 0);
        ident.type = getType(&f.fnType);
        ident.origID = f.globalID;
        return f.fnType;
    }
    let unionLookup: &UnionLookup = null;
    if (resolveUnionByName(this.currentModule, name, &unionLookup)) {
        assert(unionLookup != null, "resolveUnionByName returned true but lookup is null");
        let decl = unionLookup.global;
        assert(isSuccess(&decl.typeState), "Expected valid union type at this point");
        let t = getType(&decl.typeState);
        assert(isUnion(t), "Expected union declaration to have union type");
        // Must copy here because each `::` sets the variant of this type
        ident.type = t;
        return newTCStateType(copy(t));
    }
    let moduleLookup: &ModuleLookup = null;
    if (resolveModuleByName(this.currentModule, name, &moduleLookup)) {
        let typ = wrap(Type::Module(at(&modules, moduleLookup.globalID)));
        ident.type = typ;
        return newTCStateType(typ);
    }
    let loc: String = getLocation(name);
    let _name: String = toString(&name.content);
    fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.buffer, ERR_STR, _name.buffer);
    let alternatives: VariableLookupList = searchAllFilesForIdentifier(&this.lookup, name);
    for (let i: usize = 0; i < alternatives.length; i = i + 1) {
        let t: &VariableLookup = at(&alternatives, i);
        drop(&loc);
        loc = getLocation(&t.name);
        fprintf(stderr, "%s: %s: A variable with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
    }
    drop(&_name);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
}

func typeCheckExprBinary(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBinary");
    match (expr) {
        &BinaryExpr::Path(..) => { return typeCheckExprPathAccess(this, expr, scopes); }
        &BinaryExpr::Dot(..) => { return typeCheckExprMemberAccess(this, expr, scopes); }
        &BinaryExpr::Assign(..) => { return typeCheckExprAssign(this, expr, scopes); }
        &BinaryExpr::Plus(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Sub(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Mult(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Div(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::Mod(..) => { return typeCheckExprArithmetic(this, expr, scopes); }
        &BinaryExpr::CmpEq(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpNeq(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpGt(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpGte(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpLt(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::CmpLte(..) => { return typeCheckExprComparison(this, expr, scopes); }
        &BinaryExpr::LogAnd(..) => { return typeCheckExprLogical(this, expr, scopes); }
        &BinaryExpr::LogOr(..) => { return typeCheckExprLogical(this, expr, scopes); }
        &BinaryExpr::BitAnd(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::BitOr(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::BitXor(..) => { return typeCheckExprBitwise(this, expr, scopes); }
        &BinaryExpr::Indexed(..) => { return typeCheckExprIndexedAccess(this, expr, scopes); }
        unknown => {
            fprintf(stderr, "%s typeCheckExprBinary: Unhandled tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    unreachable("Exhaustive handling of binary expressions in typeCheckExprBinary");
}

func typeCheckExprIndexedAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprIndexedAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    if (wantsInfer(&lhsState)) {
        let loc = toString(&lhs.span);
        fprintf(stderr, "%s: %s: Could not infer type of subexpression for indexed access.\n", loc.buffer, ERR_STR);
        drop(&loc);
        return newTCStateFailure(ERROR_INDEXED_ACCESS_ON_NON_ARRAY);
    }
    assert(isType(&lhsState), "IndexedAccess: Not error, not infer, what is it?");
    let lhsType: &Type = getType(&lhsState);
    if (!isArray(lhsType) && !isPointer(lhsType)) {
        return reportIndexedAccessOnNonArray(this, lhs.span, lhsType);
    }
    if (wantsInfer(&rhsState)) {
        let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
        rhsState = inferTypeOntoExpr(this, rhs, usizeType, scopes);
    }
    if (isError(&rhsState)) return rhsState;
    assert(isType(&rhsState), "IndexedAccess: Index is not valid after infer?");
    let rhsType: &Type = getType(&rhsState);
    match (rhsType) {
        &Type::Prim(PrimType::Usize) => {
            let underlyingType: &Type = getUnderlyingType(lhsType, false);
            return newTCStateType(underlyingType);
        }
        _ => { }
    }
    let loc: String = toString(&rhs.span);
    let typ: String = toString(rhsType);
    fprintf(stderr, "%s: %s: Expected index of array access to be type usize, got %s.\n", loc.buffer, ERR_STR, typ.buffer);
    drop(&typ);
    drop(&loc);
    this.typeError = true;
    return newTCStateFailure(ERROR_INDEXED_TYPE_MISMATCH);
}

func typeCheckExprLogical(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprLogical");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) { todo_with_msg("couldn't infer in logical"); }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
    let result = newTCStateType(boolType);
    if (!isBoolean(lhsType)) { result = reportTypeMismatch(this, lhs.span, boolType, lhsType); }
    if (!isBoolean(rhsType)) { result = reportTypeMismatch(this, rhs.span, boolType, rhsType); }
    return result;
}

func typeCheckExprBitwise(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprBitwise");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) { todo_with_msg("couldn't infer in bitwise"); }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType) || !isInteger(lhsType) || !isInteger(rhsType)) {
        return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
    }
    return lhsState;
}

func typeCheckExprAssign(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprAssign");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    if (!isLValue(lhs)) {
        emergencyPrint(this, lhs.span);
        todo_with_msg("invalid l-value");
    }
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (!isType(&lhsState)) return lhsState;
    if (!isType(&rhsState)) return rhsState;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportTypeMismatch(this, rhs.span, lhsType, rhsType);
    }
    return rhsState;
}
func typeCheckStructInitialization(this: &TypeChecker, expr: &StructExpr, lookup: TypeLookup, scopes: &ScopeLookupList) -> TCState {
    return typeCheckStructInitialization(this, expr, lookup, scopes, false);
}

func typeCheckStructInitialization(this: &TypeChecker, expr: &StructExpr, lookup: TypeLookup, scopes: &ScopeLookupList, isUnion: bool) -> TCState {
    let context: &StructInitContext = &expr.context;
    let structLookup: &StructLookup = asStruct(&lookup);
    let hits: usize = 0;
    assert(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
    let result = newTCStateType(structLookup.type);
    for (let i: usize = 0; i < context.fieldLength; i = i + 1) {
        let name: Token = getFieldNameAtIndex(context, i);
        let fieldExpr: &ParsedExpr = getFieldExprAtIndex(context, i);
        let exprState: TCState = typeCheckExpr(this, fieldExpr, scopes);
        if (isError(&exprState)) result = exprState;
        if (!hasField(structLookup, &name.content)) {
            result = reportUnknownField(this, name, structLookup, isUnion);
            continue;
        }
        let fieldIndex: usize = getIndexByName(structLookup, &name);
        let bit: usize = shiftLeft(1, fieldIndex);
        if ((hits & bit) != 0) {
            let field = getFieldNameAtIndex(context, fieldIndex);
            result = reportDuplicateField(this, name, field.span);
            continue;
        } else {
            hits = hits | bit;
        }
        let field: &VariableLookup = at(&structLookup.fields, fieldIndex);
        let fieldState: &TCState = &field.typeState;
        assert(isSuccess(fieldState), "Struct is ready to go, but field type is invalid?");
        assert(equals(&name.content, &field.name.content), "Seems like my hack doesn't work");
        let fieldType: &Type = getType(fieldState);
        if (wantsInfer(&exprState))
            exprState = inferTypeOntoExpr(this, fieldExpr, fieldType, scopes);
        if (isError(&exprState)) {
            result = exprState;
            continue;
        }
        let exprType: &Type = getType(&exprState);
        if (!equals(fieldType, exprType)) {
            result = reportTypeMismatch(this, fieldExpr.span, fieldType, exprType);
        }
    }
    return result;
}
func typeCheckExprPathAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprPathAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: TCState = typeCheckExpr(this, lhs, scopes);
    if (isError(&instance)) return instance;
    let instanceType = getType(&instance);
    match (instanceType) {
        &Type::Module(decl) => {
            let modLookup = getModuleByGlobalID(&this.lookup, getID(decl));
            match (&rhs.data) {
                &ExprData::Ident(ident) => {
                    let submodule: &ModuleLookup = null;
                    let konfig = MLConfig {
                        checkSelf: false,
                        checkImport: false, // REVIEW: Should we pass true here instead?
                        checkModule: true,
                        checkParent: false,
                    };
                    if (resolveModuleByName(modLookup, &ident.name, &submodule, konfig)) {
                        let typ = wrap(Type::Module(at(&modules, submodule.globalID)));
                        rhs.typeState = newTCStateType(typ);
                        return rhs.typeState;
                    }
                    let var: &VariableLookup = null;
                    let fun: FunctionLookupList = blank;
                    let typ: TypeLookup = blank;
                    let res = resolveIdentifierByName(modLookup, &ident.name, &var, &typ, &fun);
                    if (res == IDENT_TYPE) {
                        return reportModuleAccessOfNonModule(this, lhs.span, ident.name, typ);
                    } else if (res == IDENT_NONE) {
                        return reportUnknownSubmodule(this, modLookup, ident.name);
                    } else if (res == IDENT_FUNC) {
                        assert(fun.length != 0, "IDENT_FUNC but fun is empty");
                        if (fun.length == 1) {
                            let f = at(&fun, 0);
                            assert(isSuccess(&f.fnType), "Did not properly type check function of module");
                            let s = f.fnType;
                            rhs.typeState = s;
                            ident.type = getType(&s);
                            ident.origID = f.globalID;
                            return s;
                        } else {
                            drop(&fun);
                            return newTCStatePleaseInfer();
                        }
                    } else if (res == IDENT_VAR) {
                        assert(var != null, "IDENT_VAR but var is null");
                        todo_with_msg("module.var");
                    } else {
                        unreachable("Exhaustive handling of outcomes of resolveIdentifierByName");
                    }
                }
                &ExprData::StructInit(init) => {
                    let lookup: TypeLookup = blank;
                    if (!resolveTypeByName(modLookup, &init.name, &lookup)) {
                        return reportUnknownType(this, modLookup, init.name, blank);
                    }
                    if (isStruct(&lookup)) {
                        rhs.typeState = typeCheckStructInitialization(this, &init, lookup, scopes);
                    } else {
                        unreachable("typeCheckExprModuleAccess got non-struct");
                    }
                    return rhs.typeState;
                }
                _ => { unreachable("Expected StructInit or Ident as RHS of module"); }
            }
        }
        &Type::Union(_, _) => { return typeCheckExprUnionInit(this, expr, instanceType, scopes); }
        _ => {
            let name: Token = blank;
            match (lhs.data) {
                ExprData::Ident(ident) => { name = ident.name; }
                _ => { unreachable("Expected identifier as LHS of Path access"); }
            }
            return reportModuleAccessOfNonModule(this, lhs.span, name, blank);
        }
    }
    unreachable();
}
func typeCheckExprUnionInit(this: &TypeChecker, expr: &BinaryExpr, unionType: &Type, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprUnionInit");
    let decl: &ParsedUnionDecl = null;
    match (unionType) {
        &Type::Union(_decl, _) => { decl = _decl; }
        _ => { unreachable(); }
    }
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    assert(isSuccess(&lhs.typeState));
    let lookup: &UnionLookup = null;
    let succ = resolveUnionByName(this.currentModule, &decl.name, &lookup);
    assert(succ);
    let result = newTCStateType(unionType);
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            let variant: &UnionVariantLookup = null;
            if (!resolveVariantByName(lookup, &ident.name, &variant)) todo_with_msg("report error, no such variant");
            unionType = wrap(Type::Union(decl, variant.tag));
            result = newTCStateType(unionType);
            rhs.data = ExprData::UnionInit(UnionExpr::Empty);
        }
        &ExprData::StructInit(init) => {
            let variant: &UnionVariantLookup = null;
            if (!resolveVariantByName(lookup, &init.name, &variant)) todo_with_msg("report error, no such variant");
            unionType = wrap(Type::Union(decl, variant.tag));
            result = newTCStateType(unionType);
            let structLookup = intoStructLookup(variant);
            // FIXME: typeCheckStructInitialization is exactly what we need here, but it would be cool
            //        if it wasn't called like that
            let check = typeCheckStructInitialization(this, &init, asTypeLookup(&structLookup), scopes, true);
            if (isError(&check)) return check;
            rhs.data = ExprData::UnionInit(UnionExpr::Struct(init));
        }
        _ => { unreachable("Expected StructInit or Ident as RHS"); }
    }
    rhs.typeState = result;
    return result;
}
func typeCheckExprMemberAccess(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprMemberAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: TCState = typeCheckExpr(this, lhs, scopes);
    if (isError(&instance)) return instance;
    if (wantsInfer(&instance)) return instance;
    let instanceType = getType(&instance);
    // TODO: There's no reason why things like the following example shouldn't work for member access.
    // [Marker for todo.py: The above TODO is important]
    // [Marker for todo.py: The above TODO is important]
    /*
    struct Foo {
        a: i32;
    }
    func main() {
        let f = Foo { a: 1 };
        let r1 = &f;
        let r2 = &r1;
        r2.a = 13; // The Dot-Operator is not defined for values of type &&Foo.
        assert(f.a == 13);
    }
    */
    if (!isStruct(instanceType) && !isStructPointer(instanceType)) {
        return reportMemberAccessOnNonStruct(this, lhs, instanceType);
    }
    let underlying: &Type = instanceType;
    if (!isStruct(underlying)) underlying = getUnderlyingType(instanceType, true);
    let lookup: TypeLookup = getTypeLookupForType(&this.lookup, underlying);
    if (isStruct(underlying)) {
        assert(isStruct(&lookup));
        let structLookup: &StructLookup = asStruct(&lookup);
        let fieldName: Token = blank;
        match (&rhs.data) {
            &ExprData::Ident(IdentExpr { ident, .. }) => { fieldName = ident; }
            _ => { unreachable("Expected RHS to be an identifier"); }
        }
        let field: VariableLookup = blank;
        if (!resolveFieldByName(structLookup, &fieldName, &field)) {
            return reportUnknownField(this, fieldName, structLookup, false);
        }
        let fieldState: TCState = field.typeState;
        assert(isSuccess(&fieldState), "Expected valid field type");
        return fieldState;
    } else {
        unreachable("MemberAccess expected Struct as LHS");
    }
}

func checkIfInferIsNeeded(this: &TypeChecker, lhsID: usize, lhsState: &TCState, rhsID: usize, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    let lhsExpr: &ParsedExpr = at(&exprs, lhsID);
    let rhsExpr: &ParsedExpr = at(&exprs, rhsID);
    return checkIfInferIsNeeded(this, lhsExpr, lhsState, rhsExpr, rhsState, scopes);
}
func checkIfInferIsNeeded(this: &TypeChecker, lhsExpr: &ParsedExpr, lhsState: &TCState, rhsExpr: &ParsedExpr, rhsState: &TCState, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.checkIfInferIsNeeded");
    if (isType(lhsState) && isType(rhsState)) {
        return newTCStateSuccess();
    } else if (isType(lhsState) && !isType(rhsState)) {
        *rhsState = inferTypeOntoExpr(this, rhsExpr, getType(lhsState), scopes);
        return *rhsState;
    } else if (!isType(lhsState) && isType(rhsState)) {
        *lhsState = inferTypeOntoExpr(this, lhsExpr, getType(rhsState), scopes);
        return *lhsState;
    } else {
        return newTCStatePleaseInfer();
    }
}

func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.inferTypeOntoExpr");
    return tryInferTypeOntoExpr(this, exprID, typeID, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, false);
}
func inferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList) -> TCState {
    return tryInferTypeOntoExpr(this, expr, type, scopes, false);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), type, scopes, checkOnly);
}
func tryInferTypeOntoExpr(this: &TypeChecker, exprID: usize, typeID: usize, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    return tryInferTypeOntoExpr(this, at(&exprs, exprID), at(&types, typeID), scopes, checkOnly);
}

func tryInferTypeOntoExpr(this: &TypeChecker, expr: &ParsedExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoExpr");
    if (isSuccess(&expr.typeState)) {
        let exprType: &Type = getType(&expr.typeState);
        if (!equals(exprType, type)) todo_with_msg("infer failed");
        return newTCStateType(type);
    }
    let tid: TCState = blank;
    match (&expr.data) {
        &ExprData::IntLit(value) => {
            if (isChar(type)) {
                if (!checkOnly) {
                    let l: String = getLocation(&value);
                    fprintf(stderr, "%s: %s: Using integer literal to initialize value of type char.\n",
                        l.buffer, WARN_STR);
                    drop(&l);
                }
                tid = newTCStateType(type);
            } else if (isInteger(type) || isFloat(type)) {
                tid = newTCStateType(type);
            } else if (isPointer(type)) {
                // REVIEW: This is... More than debatable?
                // Context requires a pointer, we have an integer literal.. Now this literal is type usize
                // Question: Is there ever a situation where we actually want this literal to be type ptr?
                tid = newTCStateType(wrap(Type::Prim(PrimType::Usize)));
            } else if (isBoolean(type)) {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    fprintf(stderr, "%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n",
                        l.buffer, ERR_STR, s.buffer);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
            } else if (isArray(type)) {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    fprintf(stderr, "%s: %s: Unexpected Literal! Expected array, found `%s`.\n",
                        l.buffer, ERR_STR, s.buffer);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
            } else {
                if (!checkOnly) {
                    let s: String = toString(&value.content);
                    let l: String = getLocation(&value);
                    let t = toString(type);
                    fprintf(stderr, "%s: %s: Unexpected Literal! Expected value of type %s, found `%s`.\n",
                        l.buffer, ERR_STR, t.buffer, s.buffer);
                    drop(&t);
                    drop(&l);
                    drop(&s);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_UNEXPECTED_LITERAL);
            }
        }
        // &ExprData::StrLit(Token)
        // &ExprData::CharLit(Token)
        &ExprData::ArrayLit(context) => {
            match (type) {
                &Type::Array(under, size) => {
                    if (context.size == 0) {
                        if (size != context.elemLength) {
                            if (!checkOnly) {
                                let loc: String = toString(&expr.span);
                                fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                                    loc.buffer, ERR_STR, size, context.elemLength);
                                drop(&loc);
                                this.typeError = true;
                            }
                            return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
                        }
                        let lastErrState: TCState = blank;
                        for (let i: usize = 0; i < context.elemLength; i = i + 1) {
                            tid = tryInferTypeOntoExpr(this, getElementAtIndex(&context, i), under, scopes, checkOnly);
                            if (isError(&tid)) lastErrState = tid;
                        }
                        if (!isInvalid(&lastErrState)) return lastErrState;
                    } else {
                        if (size != context.size) {
                            if (!checkOnly) {
                                let loc: String = toString(&expr.span);
                                fprintf(stderr, "%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n",
                                    loc.buffer, ERR_STR, size, context.size);
                                drop(&loc);
                                this.typeError = true;
                            }
                            return newTCStateFailure(ERROR_ARRAY_SIZE_MISMATCH);
                        }
                        tid = tryInferTypeOntoExpr(this, getElementAtIndex(&context, 0), under, scopes, checkOnly);
                        if (isError(&tid)) return tid;
                    }
                    tid = newTCStateType(type);
                }
                _ => {
                    if (!checkOnly) {
                        let loc = toString(&expr.span);
                        let t = toString(type);
                        fprintf(stderr, "%s: %s: Expected expression of type %s, found array literal.\n", loc.buffer, ERR_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                    }
                    return newTCStateFailure(ERROR_TYPE_MISMATCH);
                }
            }
        }
        &ExprData::Ident(ident) => { tid = tryInferTypeOntoIdent(this, &ident, type, scopes, checkOnly); }
        &ExprData::Unary(unary) => { tid = tryInferTypeOntoUnary(this, expr.span, &unary, type, scopes, checkOnly); }
        &ExprData::Binary(binary) => { tid = tryInferTypeOntoBinary(this, &binary, type, scopes, checkOnly); }
        &ExprData::Call(call) => { tid = tryInferTypeOntoCall(this, &call, type, scopes, checkOnly); }
        // &ExprData::Sizeof(&ParsedTypeNode)
        // &ExprData::StructInit(StructExpr)
        // &ExprData::UnionInit(UnionExpr)
        // &ExprData::As(&ParsedExpr, &ParsedTypeNode)
        &ExprData::Null => {
            if (!isPointer(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                fprintf(stderr, "%s: %s: Can't use `null` to initialize value of type %s.\n",loc.buffer, ERR_STR, name.buffer);
                drop(&name);
                drop(&loc);
                this.typeError = true;
                return newTCStateFailure(ERROR_NULL_NON_PTR);
            }
            tid = newTCStateType(type);
        }
        &ExprData::Blank => {
            if (isPointer(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                fprintf(stderr, "%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n",
                    loc.buffer, ERR_STR, name.buffer);
                drop(&name);
                drop(&loc);
                this.typeError = true;
                return newTCStateFailure(ERROR_BLANK_FOR_NULL);
            } else if (isPrimitive(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n",
                    loc.buffer, WARN_STR, name.buffer);
                drop(&name);
                drop(&loc);
            } else if (isUnion(type)) {
                let loc: String = toString(&expr.span);
                let name: String = toString(type);
                fprintf(stderr, "%s: %s: Using `blank` to initialize value of type %s.\n",
                    loc.buffer, WARN_STR, name.buffer);
                drop(&name);
                drop(&loc);
            }
            tid = newTCStateType(type);
        }
        // &ExprData::True
        // &ExprData::False
        unknown => {
            fprintf(stderr, "%s tryInferTypeOntoExpr: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    /*
    // } else if (expr.kind == EXPR_CHAR_LIT) {
    //     unreachable("EXPR_CHAR_LIT always has type char and should never be the target of tryInferTypeOntoExpr");
    // } else if (expr.kind == EXPR_ARRAY_LIT) {
    // } else if (expr.kind == EXPR_BLANK) {
    // } else if (expr.kind == EXPR_UNARY) {
    // } else if (expr.kind == EXPR_CALL) {
    //     tid = tryInferTypeOntoCall(this, expr, type, scopes, checkOnly);
    //     if (isError(&tid)) return tid;
    // } else {
    //     emergencyPrint(this, expr.span);
    //     todo_with_msg("unhandled case in inferTypeOntoExpr");
    // }
    */
    if (!checkOnly) {
        (*expr).typeState = tid;
    }
    return tid;
}

func tryInferTypeOntoUnary(this: &TypeChecker, span: Span, unary: &UnaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let tid: TCState = blank;
    match (unary) {
        &UnaryExpr::Deref(subExpr) => {
            let newType: &Type = wrap(Type::Ptr(type));
            tid = tryInferTypeOntoExpr(this, subExpr, newType, scopes, checkOnly);
            if (isError(&tid)) return tid;
            tid = newTCStateType(type);
        }
        &UnaryExpr::Ref(subExpr) => {
            match (type) {
                &Type::Ptr(under) => {
                    tid = tryInferTypeOntoExpr(this, subExpr, under, scopes, checkOnly);
                    if (isError(&tid)) return tid;
                    tid = newTCStateType(type);
                }
                _ => {
                    if (!checkOnly) {
                        let loc: String = toString(&span);
                        let t: String = toString(type);
                        fprintf(stderr, "%s: %s: Expected expression of type %s, found reference.\n", loc.buffer, ERR_STR, t.buffer);
                        drop(&t);
                        drop(&loc);
                        this.typeError = true;
                    }
                    return newTCStateFailure(ERROR_TYPE_MISMATCH);
                }
            }
        }
        &UnaryExpr::Negate(subExpr) => {
            if (!isSignedInteger(type) && !isFloat(type)) {
                if (!checkOnly) {
                    let loc: String = toString(&span);
                    let t: String = toString(type);
                    fprintf(stderr, "%s: %s: Negation is not defined for type %s.\n", loc.buffer, ERR_STR, t.buffer);
                    drop(&t);
                    drop(&loc);
                    this.typeError = true;
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
            tid = tryInferTypeOntoExpr(this, subExpr, type, scopes, checkOnly);
            if (isError(&tid)) return tid;
            assert(isType(&tid), "infer non-error expected to be a type");
            let subType: &Type = getType(&tid);
            assert(equals(subType, type), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
            tid = newTCStateType(type);
        }
        &UnaryExpr::Not(subExpr) => {
            let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
            tid = tryInferTypeOntoExpr(this, subExpr, boolType, scopes, checkOnly);
            if (isError(&tid)) return tid;
            todo_with_msg("unary not infer");
        }
        _ => { unreachable("Exhaustive handling of ops in tryInferTypeOntoUnary"); }
    }
    return tid;
}

func tryInferTypeOntoBinary(this: &TypeChecker, binary: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(binary, &lhs, &rhs);
    let tid: TCState = blank;
    if (isArithmetic(binary) || isBitwise(binary)) {
        tid = tryInferTypeOntoExpr(this, lhs, type, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = tryInferTypeOntoExpr(this, rhs, type, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = newTCStateType(type);
    } else if (isComparison(binary)) {
        // Assuming that neither side has a type (otherwise typeCheckExprComparison would've handled the infer step)
        // So all that's left is whack things like `1 == 1`, for which we blindly try to infer usize onto both sides
        let usizeType = wrap(Type::Prim(PrimType::Usize));
        tid = tryInferTypeOntoExpr(this, lhs, usizeType, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = tryInferTypeOntoExpr(this, rhs, usizeType, scopes, checkOnly);
        if (isError(&tid)) return tid;
        tid = newTCStateType(type);
    } else if (tag(binary) == comptime tag(&BinaryExpr::Dot)) {
        tid = tryInferTypeOntoMemberAccess(this, binary, type, scopes, checkOnly);
    } else if (tag(binary) == comptime tag(&BinaryExpr::Path)) {
        tid = tryInferTypeOntoPathAccess(this, binary, type, scopes, checkOnly);
    } else {
        todo_with_msg("inferTypeOntoExpr for non-arith non-comp binary");
    }
    return tid;
}

func tryInferTypeOntoIdent(this: &TypeChecker, ident: &IdentExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    let var: VariableLookup = blank;
    let tid: TCState = blank;
    if (resolveVariableByName(this.currentModule, &ident.name, scopes, &var)) {
        assert(wantsInfer(&var.typeState), "Ident has no type, but variable doesn't want infer");
        tid = newTCStateType(type);
        var.typeState = tid;
        let stmt = at(&stmts, var.globalID);
        match (stmt.data) {
            StmtData::VarDecl(decl) => {
                tid = tryInferTypeOntoExpr(this, decl.expr, type, scopes, checkOnly);
            }
            _ => { unreachable("VariableLookup points to non-VarDecl"); }
        }
        if (isError(&tid)) {
            let loc = toString(&ident.name.span);
            let name = toString(&ident.name.content);
            let typeName = toString(type);
            fprintf(stderr, "%s: %s: Variable `%s` inferred to be of type %s here.\n", loc.buffer, NOTE_STR, name.buffer, typeName.buffer);
            drop(&typeName);
            drop(&name);
            drop(&loc);
        }
        stmt.typeState = tid;
    } else if (isFunction(type)) {
        let functions = resolveAllFunctionsWithSignature(this.currentModule, &ident.name, type);
        if (functions.length == 0) {
            if (checkOnly) {
                tid = newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
            } else {
                let all = resolveFunctionByName(this.currentModule, &ident.name);
                tid = reportNoFunctionCallCandidate(this, ident.name, type, &all);
                drop(&all);
            }
        } else if (functions.length == 1) {
            let f = at(&functions, 0);
            if (!checkOnly) {
                ident.origID = f.globalID;
            }
            tid = f.fnType;
        } else {
            tid = newTCStatePleaseInfer();
        }
        drop(&functions);
    } else {
        todo_with_msg("infer onto name, but not a function or variable");
    }
    if (isType(&tid)) {
        ident.type = getType(&tid);
    }
    return tid;
}

func tryInferTypeOntoCall(this: &TypeChecker, expr: &CallExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoCall");
    let params: TypeList = blank;
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let state = &(*at(&expr.args, i)).typeState;
        let typ = wrap(Type::Unknown);
        if (isType(state)) typ = getType(state);
        push(&params, typ);
    }
    let fnType = wrap(Type::Func(params, type, blank));
    let baseState = tryInferTypeOntoExpr(this, expr.base, fnType, scopes, checkOnly);
    if (isError(&baseState)) return baseState;
    if (wantsInfer(&baseState)) {
        return reportFunctionCallTooManyOptions(this, expr);
    }
    assert(isType(&baseState), "tryInferOntoCall: Base is not a type");
    let baseFunc = getType(&baseState);
    assert(isFunction(baseFunc), "tryInferTypeOntoCall: Base is not a function");
    let state: TCState = newTCStateSuccess();
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let p = getParam(baseFunc, i);
        let s1 = tryInferTypeOntoExpr(this, *at(&expr.args, i), p, scopes, checkOnly);
        if (isError(&s1)) {
            state = s1;
        }
    }
    if (!isSuccess(&state)) {
        todo_with_msg("infer arg failed");
    }
    if (checkOnly) return newTCStateSuccess();
    expr.retType = type;
    return newTCStateType(type);
}

func tryInferTypeOntoMemberAccess(this: &TypeChecker, expr: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoMemberAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            let name = ident.name;
            let structs = resolveAllStructsWithField(this.currentModule, &name, type);
            if (structs.length == 0) {
                return reportMemberAccessNoOptions(this, lhs.span);
            } else if (structs.length == 1) {
                let struct = at(&structs, 0);
                let state = tryInferTypeOntoExpr(this, lhs, struct.type, scopes, checkOnly);
                if (isError(&state)) return state;
                if (checkOnly) return newTCStateSuccess();
                return newTCStateType(type);
            } else {
                if (!checkOnly) {
                    return reportMemberAccessTooManyOptions(this, lhs.span, &structs);
                }
                return newTCStateFailure(ERROR_TYPE_MISMATCH);
            }
        }
        _ => { }
    }
    unreachable("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess"); 
}

func tryInferTypeOntoPathAccess(this: &TypeChecker, expr: &BinaryExpr, type: &Type, scopes: &ScopeLookupList, checkOnly: bool) -> TCState {
    trace("TypeChecker.tryInferTypeOntoPathAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState = lhs.typeState;
    if (!isSuccess(&lhsState)) return lhsState;
    if (!isType(&lhsState)) return lhsState;
    let lhsType = getType(&lhsState);
    let lookup: &ModuleLookup = null;
    match (lhsType) {
        &Type::Module(decl) => { lookup = getModuleByGlobalID(this.currentModule, getID(decl)); }
        _ => { unreachable("LHS of BIN_MODULE is not of type module!"); }
    }
    let tid: TCState = blank;
    match (&rhs.data) {
        &ExprData::Ident(ident) => {
            assert(isFunction(type), "Can only try to infer functions onto module identifiers for now");
            let functions = resolveAllFunctionsWithSignature(lookup, &ident.name, type);
            if (functions.length == 0) {
                if (checkOnly) {
                    tid = newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
                } else {
                    let all = resolveFunctionByName(lookup, &ident.name);
                    tid = reportNoFunctionCallCandidate(this, ident.name, type, &all);
                    drop(&all);
                }
            } else if (functions.length == 1) {
                let f = at(&functions, 0);
                if (!checkOnly) {
                    ident.origID = f.globalID;
                }
                tid = f.fnType;
            } else {
                tid = newTCStatePleaseInfer();
            }
            rhs.typeState = tid;
            if (isType(&tid)) {
                ident.type = getType(&tid);
            }
            drop(&functions);
        }
        _ => { unreachable("Exhaustive handling of possibilities in tryInferTypeOntoModuleAccess"); }
    }
    return tid;
}

func typeCheckExprArithmetic(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprArithmetic");
    assert(isArithmetic(expr), "Expr expected to be arithmetic");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let lhsPointer: bool = false;
    let rhsPointer: bool = false;
    if (isType(&lhsState)) if (isPointer(getType(&lhsState))) lhsPointer = true;
    if (isType(&rhsState)) if (isPointer(getType(&rhsState))) rhsPointer = true;
    if (lhsPointer || rhsPointer) {
        match (expr) {
            &BinaryExpr::Plus(..) => { },
            &BinaryExpr::Sub(..) => { },
            other => { return reportInvalidPointerArithmetics(this, binOpAsStr(other), lhs.span, rhs.span); }
        }
    }
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) return maybeInfer;
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    let resultState: TCState = blank;
    if (equals(lhsType, rhsType)) {
        comptime p = tag(&BinaryExpr::Plus);
        comptime s = tag(&BinaryExpr::Sub);
        if (isChar(lhsType) && tag(expr) != p && tag(expr) != s) {
            return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
        }
        if (isStruct(lhsType) || isArray(lhsType)) {
            return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
        } else if (isPointer(lhsType)) {
            resultState = newTCStateType(wrap(Type::Prim(PrimType::Usize)));
        } else {
            resultState = newTCStateType(lhsType);
        }
    } else if (isPointer(lhsType) && isInteger(rhsType)) {
        match (rhsType) {
            &Type::Prim(PrimType::Usize) => { resultState = lhsState; }
            _ => {
                let err = reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
                let loc = toString(&rhs.span);
                fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
                drop(&loc);
                return err;
            }
        }
    } else if (isInteger(lhsType) && isPointer(rhsType)) {
        match (lhsType) {
            &Type::Prim(PrimType::Usize) => { resultState = rhsState; }
            _ => {
                let err = reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
                let loc = toString(&lhs.span);
                fprintf(stderr, "%s: %s: Pointer offsets must be of type usize.\n", loc.buffer, NOTE_STR);
                drop(&loc);
                return err;
            }
        }
    } else {
        return reportBinaryTypeMismatch(this, binOpAsStr(expr), lhs.span, lhsType, rhs.span, rhsType);
    }
    return resultState;
}

func typeCheckExprComparison(this: &TypeChecker, expr: &BinaryExpr, scopes: &ScopeLookupList) -> TCState {
    trace("TypeChecker.typeCheckExprComparison");
    assert(isComparison(expr), "Expr expected to be comparison");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsState: TCState = typeCheckExpr(this, lhs, scopes);
    let rhsState: TCState = typeCheckExpr(this, rhs, scopes);
    if (isError(&lhsState)) return lhsState;
    if (isError(&rhsState)) return rhsState;
    let maybeInfer: TCState = checkIfInferIsNeeded(this, lhs, &lhsState, rhs, &rhsState, scopes);
    if (isError(&maybeInfer)) {
        todo_with_msg("couldn't infer in comp");
    }
    if (wantsInfer(&maybeInfer)) return maybeInfer;
    let lhsType: &Type = getType(&lhsState);
    let rhsType: &Type = getType(&rhsState);
    if (!equals(lhsType, rhsType)) {
        return reportBinaryTypeMismatch(this, 
            binOpAsStr(expr),
            lhs.span, lhsType,
            rhs.span, rhsType,
        );
    }
    if (isStruct(lhsType) || isStruct(rhsType)
        || isArray(lhsType) || isArray(rhsType)) {
        todo_with_msg("report error, can't compare structs or arrays using == or similar.");
    }
    return newTCStateType(wrap(Type::Prim(PrimType::Bool)));
}

func typeCheckTypeNode(this: &TypeChecker, typeNode: &ParsedTypeNode) -> TCState {
    trace("TypeChecker.typeCheckTypeNode");
    if (typeNode.ignored) return blank;
    if (isSuccess(&typeNode.typeState)) return typeNode.typeState;
    let tid: &Type = null;
    if (typeNode.kind == PARSED_TYPE_FUNC) {
        let retState: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&retState)) return retState;
        let params: TypeList = blank;
        let error: TCState = blank;
        for (let i: usize = 0; i < typeNode.fnParams.length; i = i + 1) {
            let state = typeCheckTypeNode(this, *at(&typeNode.fnParams, i));
            if (isError(&state)) {
                error = state;
            }
            push(&params, getType(&state));
        }
        if (isError(&error)) return error;
        tid = wrap(Type::Func(params, getType(&retState), blank));
    } else if (typeNode.kind == PARSED_TYPE_REF) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = wrap(Type::Ptr(getType(&under)));
    } else if (typeNode.kind == PARSED_TYPE_ARRAY) {
        let under: TCState = typeCheckTypeNode(this, typeNode.underlyingID);
        if (isError(&under)) return under;
        tid = wrap(Type::Array(getType(&under), typeNode.arraySize));
    } else if (typeNode.kind == PARSED_TYPE_IDENT) {
        let name: Token = typeNode.nameTkn;
        let typeLookup: TypeLookup = blank;
        if (!resolveTypeByName(this.currentModule, &name, &typeLookup)) {
            let loc: String = getLocation(&name);
            let _n: String = toString(&name.content);
            fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.buffer, ERR_STR, _n.buffer);
            let alternatives: TypeLookupList = searchAllFilesForTypeName(&this.lookup, &name);
            for (let i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &TypeLookup = at(&alternatives, i);
                if (isStruct(t)) {
                    let s: &StructLookup = asStruct(t);
                    drop(&loc);
                    loc = getLocation(&s.name);
                    fprintf(stderr, "%s: %s: A struct with that name is located here. Import the file to use it.\n", loc.buffer, NOTE_STR);
                }
            }
            drop(&_n);
            drop(&loc);
            this.typeError = true;
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (isStruct(&typeLookup)) {
            let structLookup: &StructLookup = asStruct(&typeLookup);
            tid = structLookup.type;
            assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
        } else if (isUnion(&typeLookup)) {
            let unionLookup: &UnionLookup = asUnion(&typeLookup);
            tid = unionLookup.type;
            assert(isUnion(tid), "Union Lookup links to non-Union typeNode");
        } else {
            unreachable("Exhaustive handling of TypeLookup kinds in typeCheckTypeNode");
        }
    } else if (typeNode.kind == PARSED_TYPE_MODULE) {
        let _orig = typeNode;
        let moduleLookup: &ModuleLookup = null;
        let name = typeNode.nameTkn;
        if (!resolveModuleByName(this.currentModule, &name, &moduleLookup)) {
            return reportUnknownModule(this, name);
        }
        while (true) {
            let sub = typeNode.underlyingID;
            if (sub.underlyingID == null) {
                let lookup: TypeLookup = blank;
                if (!resolveTypeByName(moduleLookup, &sub.nameTkn, &lookup)) {
                    return reportUnknownType(this, moduleLookup, sub.nameTkn, blank);
                }
                if (isStruct(&lookup)) {
                    let structLookup: &StructLookup = asStruct(&lookup);
                    tid = structLookup.type;
                    assert(isStruct(tid), "Struct Lookup links to non-Struct typeNode");
                    break;
                } else {
                    todo_with_msg("module::<typeNode> with typeNode != struct");
                }
            } else {
                name = sub.nameTkn;
                let newModule: &ModuleLookup = null;
                if (!resolveModuleByName(moduleLookup, &name, &newModule)) {
                    return reportUnknownSubmodule(this, moduleLookup, name);
                }
                let modType = wrap(Type::Module(at(&modules, newModule.globalID)));
                typeNode.typeState = newTCStateType(modType);
                typeNode = sub;
                moduleLookup = newModule;
            }
        }
        typeNode = _orig;
    } else if (typeNode.kind == PARSED_TYPE_BUILTIN) {
        let id: usize = getID(typeNode);
        let prim: PrimType = PrimType::None;
        if (id == PARSED_TYPE_NONE) prim = PrimType::None;
        else if (id == PARSED_TYPE_ANY) prim = PrimType::Any;
        else if (id == PARSED_TYPE_I8) prim =PrimType::I8;
        else if (id == PARSED_TYPE_I16) prim =PrimType::I16;
        else if (id == PARSED_TYPE_I32) prim =PrimType::I32;
        else if (id == PARSED_TYPE_I64) prim =PrimType::I64;
        else if (id == PARSED_TYPE_U8) prim =PrimType::U8;
        else if (id == PARSED_TYPE_U16) prim =PrimType::U16;
        else if (id == PARSED_TYPE_U32) prim =PrimType::U32;
        else if (id == PARSED_TYPE_U64) prim =PrimType::U64;
        else if (id == PARSED_TYPE_USIZE) prim =PrimType::Usize;
        else if (id == PARSED_TYPE_BOOL) prim =PrimType::Bool;
        else if (id == PARSED_TYPE_CHAR) prim =PrimType::Char;
        else if (id == PARSED_TYPE_F32) prim =PrimType::F32;
        else if (id == PARSED_TYPE_F64) prim =PrimType::F64;
        else {
            unreachable("Exhaustive handling of parsed types in typeCheckTypeNode");
        }
        tid = wrap(Type::Prim(prim));
    } else {
        todo_with_msg("unknown typeNode kind");
    }
    let state: TCState = newTCStateType(tid);
    typeNode.typeState = state;
    return state;
}

func newTypeChecker() -> TypeChecker {
    return TypeChecker {
        isComptimeContext: false,
        currentModule: null,
        currentFunction: null,
        lookup: blank,
        typeError: false,
    };
}
