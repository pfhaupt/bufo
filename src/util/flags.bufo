import "prelude.bufo";
import "libc.bufo";
import "string.bufo";

comptime FLAG_INVALID: usize = 0;
comptime FLAG_STRING: usize = 1;
comptime FLAG_BOOL: usize = 2;

comptime FLAG_MODE_DEFAULT: usize   = 0;
comptime FLAG_MODE_SINGLE: usize    = pow2(0);
comptime FLAG_MODE_MANDATORY: usize = pow2(1);

struct Flag {
    kind: usize;
    found: bool;
    mode: usize;
    short: &char;
    long: &char;
    descr: &char;
    asString: String;
    asBool: bool;
}
func isMandatory(flag: &Flag) -> bool {
    return (flag.mode & FLAG_MODE_MANDATORY) != 0;
}
func toString(this: &Flag) -> String {
    let s: String = blank;
    if (this.long != null) {
        pushStr(&s, "--");
        pushStr(&s, this.long);
        if (this.kind == FLAG_STRING) {
            pushStr(&s, " [arg]");
        }
    } else if (this.short != null) {
        pushChar(&s, '-');
        pushStr(&s, this.short);
        if (this.kind == FLAG_STRING) {
            pushStr(&s, " [arg]");
        }
    } else {
        assert(this.kind == FLAG_STRING);
        pushStr(&s, "<standalone>");
    }
    return s;
}

struct FlagParser {
    programName: String;
    helpFlag: &bool;
    flags: [Flag; 32];
    flagCount: usize;
    errors: StringList;
}
func addHelpFlag(this: &FlagParser) -> &bool {
    assert(this.helpFlag == null, "addHelpFlag() called twice");
    return this.helpFlag = addBoolFlag(this, "h", "help", "Print help and exit");
}
func addDefaultFlag(this: &FlagParser, kind: usize, short: &char, long: &char, descr: &char, mode: usize) -> &Flag {
    assert(this.flagCount < 32, "Could not add flag: Too many flags");
    let f = &this.flags[this.flagCount];
    assert(f.kind == FLAG_INVALID);
    this.flagCount = this.flagCount + 1;
    f.kind = kind;
    f.mode = mode;
    f.short = short;
    f.long = long;
    f.descr = descr;
    return f;
}
func addStringFlag(this: &FlagParser, descr: &char, mode: usize) -> &String {
    return addStringFlag(this, null, null, descr, mode);
}
func addStringFlag(this: &FlagParser, short: &char, long: &char, descr: &char) -> &String {
    return addStringFlag(this, short, long, descr, FLAG_MODE_DEFAULT);
}
func addStringFlag(this: &FlagParser, short: &char, long: &char, descr: &char, mode: usize) -> &String {
    let f = addDefaultFlag(this, FLAG_STRING, short, long, descr, mode);
    return &f.asString;
}
func addBoolFlag(this: &FlagParser, flag: &char, descr: &char) -> &bool {
    if (C::strncmp("--", flag, 2) == 0) {
        flag = flag + 2;
        return addBoolFlag(this, null, flag, descr);
    } else if (*flag == '-') {
        flag = flag + 1;
        return addBoolFlag(this, flag, null, descr);
    }
    C::printf("%s\n", flag);
    assert(false, "addBoolFlag(&FlagParser, &char, &char) must be called with a flag that has the form -s or --long");
    unreachable();
}
func addBoolFlag(this: &FlagParser, short: &char, long: &char, descr: &char) -> &bool {
    return addBoolFlag(this, short, long, descr, FLAG_MODE_DEFAULT);
}
func addBoolFlag(this: &FlagParser, short: &char, long: &char, descr: &char, mode: usize) -> &bool {
    let f = addDefaultFlag(this, FLAG_BOOL, short, long, descr, mode);
    return &f.asBool;
}
func shiftArgument(this: &FlagParser, argc: &i32, argv: &&&char) -> &char {
    assert(*argc > 0);
    let result = **argv;
    *argv = *argv + sizeof &&char;
    *argc = *argc - 1;
    return result;
}
func showErrors(stream: Any, this: &FlagParser) {
    assert(this.errors.length > 0, "showErrors() called but no error collected");
    for (let i: usize = 0; i < this.errors.length; i = i + 1) {
        let f = &this.errors.elements[i];
        C::fprintf(stream, "%.*s", f.length, f.buffer);
    }
}
func showUsage(stream: Any, this: &FlagParser) {
    C::fprintf(stream, "Usage: %s", this.programName.buffer);
    for (let i: usize = 0; i < this.flagCount; i = i + 1) {
        let f = &this.flags[i];
        if (isMandatory(f)) {
            C::fprintf(stream, " %s", toString(f).buffer);
        }
    }
    C::fprintf(stream, "\n");
}
func showHelp(stream: Any, this: &FlagParser) {
    C::fprintf(stream, "Help:\n");
    for (let i: usize = 0; i < this.flagCount; i = i + 1) {
        showHelp(stream, &this.flags[i]);
    }
}
func showHelp(stream: Any, this: &Flag) {
    let s: String = blank;
    if (this.short != null && this.long != null) {
        pushChar(&s, '-');
        pushStr(&s, this.short);
        pushStr(&s, " | ");
        let _s: String = toString(this);
        pushString(&s, &_s);
        drop(&_s);
    } else {
        s = toString(this);
    }
    C::fprintf(stream, "%20s: %s", s.buffer, this.descr);
    if (isMandatory(this)) {
        C::fprintf(stream, " [mandatory]");
    }
    C::fprintf(stream, "\n");
    drop(&s);
}
func helpOr(this: &FlagParser, or: bool) -> bool {
    if (this.helpFlag != null) {
        return *this.helpFlag || or;
    }
    return or;
}
func emitFlagError(this: &FlagParser, msg: &char, name: &char) -> &String {
    let len = C::strlen(msg) + C::strlen(name) + 1;
    let buf = C::calloc(len, sizeof char);
    assert(buf != null);
    C::snprintf(buf, len, msg, name);
    let err = emitFlagError(this, buf);
    C::free(buf);
    return err;
}
func emitFlagError(this: &FlagParser, msg: &char) -> &String {
    let err = newStringFromStrLit(ERR_STR);
    pushStr(&err, ": ");
    pushStr(&err, msg);
    pushChar(&err, '\n');
    push(&this.errors, err);
    return last(&this.errors);
}
func emitFlagDescription(this: &FlagParser, f: &Flag) -> String {
    let err = newStringFromStrLit(NOTE_STR);
    pushStr(&err, ": Description of flag: ");
    pushStr(&err, f.descr);
    pushStr(&err, "\n");
    return err;
}
func runOn(this: &FlagParser, argc: i32, argv: &&char) -> bool {
    let res = _runOn(this, argc, argv) && this.errors.length == 0;
    return helpOr(this, res);
}
func _runOn(this: &FlagParser, argc: i32, argv: &&char) -> bool {
    if (this.programName.buffer == null) {
        let name = shiftArgument(this, &argc, &argv);
        this.programName = newStringFromStrLit(name);
    }
    while (argc > 0) {
        let flag = shiftArgument(this, &argc, &argv);
        let long = false;
        let short = false;
        let standalone = false;
        if (C::strncmp("--", flag, 2) == 0) {
            flag = flag + 2;
            long = true;
        } else if (*flag == '-') {
            flag = flag + 1;
            short = true;
        } else {
            standalone = true;
        }
        let found = false;
        for (let i: usize = 0; i < this.flagCount; i = i + 1) {
            let f = &this.flags[i];
            if (long) {
                if (f.long == null) continue;
                if (C::strcmp(flag, f.long) == 0) {
                    if (f.found && ((f.mode & FLAG_MODE_SINGLE) != 0)) {
                        emitFlagError(this, "Value for flag --%s was already provided.", f.long);
                        return false;
                    }
                    if (f.kind == FLAG_BOOL) {
                        f.asBool = true;
                    } else if (f.kind == FLAG_STRING) {
                        if (argc == 0) {
                            emitFlagError(this, "Expected one more positional argument for flag --%s.", f.long);
                            return false;
                        }
                        let val = shiftArgument(this, &argc, &argv);
                        f.asString = newStringFromStrLit(val);
                    } else {
                        unreachable("Exhaustive handling of long flag kinds");
                    }
                    f.found = true;
                    found = true;
                    break;
                }
            } else if (short) {
                if (f.short == null) continue;
                if (C::strcmp(flag, f.short) == 0) {
                    if (f.found && ((f.mode & FLAG_MODE_SINGLE) != 0)) {
                        emitFlagError(this, "Value for flag -%s was already provided.", f.short);
                        return false;
                    }
                    if (f.kind == FLAG_BOOL) {
                        f.asBool = true;
                    } else if (f.kind == FLAG_STRING) {
                        if (argc == 0) {
                            emitFlagError(this, "Expected one more positional argument for flag -%s.", f.short);
                            return false;
                        }
                        let val = shiftArgument(this, &argc, &argv);
                        f.asString = newStringFromStrLit(val);
                    } else {
                        unreachable("Exhaustive handling of short flag kinds");
                    }
                    f.found = true;
                    found = true;
                    break;
                }
            } else if (standalone) {
                if (f.short != null) continue;
                if (f.long != null) continue;
                if (f.found && ((f.mode & FLAG_MODE_SINGLE) != 0)) {
                    let err = emitFlagError(this, "Value for standalone flag was already provided.");
                    let note = emitFlagDescription(this, f);
                    pushString(err, &note);
                    drop(&note);
                    return false;
                }
                if (f.kind == FLAG_BOOL) {
                    f.asBool = true;
                } else if (f.kind == FLAG_STRING) {
                    f.asString = newStringFromStrLit(flag);
                } else {
                    unreachable("Exhaustive handling of standalone flag kinds");
                }
                f.found = true;
                found = true;
                break;
            }
        }
        if (!found) {
            if (long) emitFlagError(this, "Unknown flag --%s.", flag);
            if (short) emitFlagError(this, "Unknown flag -%s.", flag);
            if (standalone) emitFlagError(this, "Unknown flag %s.", flag);
            continue;
        }
    }
    let allGotten = true;
    for (let i: usize = 0; i < this.flagCount; i = i + 1) {
        let f = &this.flags[i];
        if (!f.found && ((f.mode & FLAG_MODE_MANDATORY) != 0)) {
            let name = f.long;
            if (name == null) name = f.short;
            // emitFlagError pushes the error to FlagParser.errors, no need to do anything here
            if (name == null) {
                let err = emitFlagError(this, "Mandatory standalone flag not provided.");
                let note = emitFlagDescription(this, f);
                pushString(err, &note);
                drop(&note);
            } else {
                emitFlagError(this, "No value for flag `%s` was provided.", name);
            }
            allGotten = false;
        }
    }
    return allGotten;
}

