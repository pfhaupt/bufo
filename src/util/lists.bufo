import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../frontend/nodes.bufo";
import "../middleend/lookup.bufo";
import "../middleend/checker.bufo";
import "../backend/irgen.bufo";
import "../backend/codegen_llvm.bufo";
import "../backend/interp.bufo";
import "../backend/LLVM/basic_block.bufo";
import "../backend/LLVM/values.bufo";
import "../backend/LLVM/types.bufo";

struct ModuleLookupList {
    elements: &ModuleLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof ModuleLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in ModuleLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: ModuleLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof ModuleLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in ModuleLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof ModuleLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &ModuleLookup {
        let l: &ModuleLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &ModuleLookup {
        assert_with_msg(index < this.length, "Out of bounds access in ModuleLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in ModuleLookupList.at");
        return this.elements + index * sizeof ModuleLookup;
    }

    func contains(&this, element: &ModuleLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &ModuleLookup {
        assert_with_msg(this.length != 0, "Called last() on empty ModuleLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &ModuleLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct ImportLookupList {
    elements: &ImportLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof ImportLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in ImportLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: ImportLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof ImportLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in ImportLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof ImportLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &ImportLookup {
        let l: &ImportLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &ImportLookup {
        assert_with_msg(index < this.length, "Out of bounds access in ImportLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in ImportLookupList.at");
        return this.elements + index * sizeof ImportLookup;
    }

    func contains(&this, element: &ImportLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &ImportLookup {
        assert_with_msg(this.length != 0, "Called last() on empty ImportLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &ImportLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct FunctionLookupList {
    elements: &FunctionLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof FunctionLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in FunctionLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: FunctionLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof FunctionLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in FunctionLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof FunctionLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &FunctionLookup {
        let l: &FunctionLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &FunctionLookup {
        assert_with_msg(index < this.length, "Out of bounds access in FunctionLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in FunctionLookupList.at");
        return this.elements + index * sizeof FunctionLookup;
    }

    func contains(&this, element: &FunctionLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &FunctionLookup {
        assert_with_msg(this.length != 0, "Called last() on empty FunctionLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &FunctionLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct StructLookupList {
    elements: &StructLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof StructLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in StructLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: StructLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof StructLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in StructLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof StructLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &StructLookup {
        let l: &StructLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &StructLookup {
        assert_with_msg(index < this.length, "Out of bounds access in StructLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in StructLookupList.at");
        return this.elements + index * sizeof StructLookup;
    }

    func contains(&this, element: &StructLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &StructLookup {
        assert_with_msg(this.length != 0, "Called last() on empty StructLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &StructLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct TypeLookupList {
    elements: &TypeLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof TypeLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in TypeLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: TypeLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof TypeLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in TypeLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof TypeLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &TypeLookup {
        let l: &TypeLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &TypeLookup {
        assert_with_msg(index < this.length, "Out of bounds access in TypeLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in TypeLookupList.at");
        return this.elements + index * sizeof TypeLookup;
    }

    func contains(&this, element: &TypeLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &TypeLookup {
        assert_with_msg(this.length != 0, "Called last() on empty TypeLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &TypeLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct ScopeLookupList {
    elements: &ScopeLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof ScopeLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in ScopeLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: ScopeLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof ScopeLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in ScopeLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof ScopeLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &ScopeLookup {
        let l: &ScopeLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &ScopeLookup {
        assert_with_msg(index < this.length, "Out of bounds access in ScopeLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in ScopeLookupList.at");
        return this.elements + index * sizeof ScopeLookup;
    }

    func contains(&this, element: &ScopeLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &ScopeLookup {
        assert_with_msg(this.length != 0, "Called last() on empty ScopeLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &ScopeLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct VariableLookupList {
    elements: &VariableLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof VariableLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in VariableLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: VariableLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof VariableLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in VariableLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof VariableLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &VariableLookup {
        let l: &VariableLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &VariableLookup {
        assert_with_msg(index < this.length, "Out of bounds access in VariableLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in VariableLookupList.at");
        return this.elements + index * sizeof VariableLookup;
    }

    func contains(&this, element: &VariableLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &VariableLookup {
        assert_with_msg(this.length != 0, "Called last() on empty VariableLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &VariableLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct MethodLookupList {
    elements: &MethodLookup;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof MethodLookup);
        assert_with_msg(this.elements != null, "Could not allocate memory in MethodLookupList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: MethodLookup) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof MethodLookup);
            assert_with_msg(this.elements != null, "Could not allocate memory in MethodLookupList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof MethodLookup) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &MethodLookup {
        let l: &MethodLookup = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &MethodLookup {
        assert_with_msg(index < this.length, "Out of bounds access in MethodLookupList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in MethodLookupList.at");
        return this.elements + index * sizeof MethodLookup;
    }

    func contains(&this, element: &MethodLookup) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &MethodLookup {
        assert_with_msg(this.length != 0, "Called last() on empty MethodLookupList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &MethodLookupList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct TCStateList {
    elements: &TCState;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof TCState);
        assert_with_msg(this.elements != null, "Could not allocate memory in TCStateList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: TCState) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof TCState);
            assert_with_msg(this.elements != null, "Could not allocate memory in TCStateList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof TCState) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &TCState {
        let l: &TCState = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &TCState {
        assert_with_msg(index < this.length, "Out of bounds access in TCStateList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in TCStateList.at");
        return this.elements + index * sizeof TCState;
    }

    func contains(&this, element: &TCState) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &TCState {
        assert_with_msg(this.length != 0, "Called last() on empty TCStateList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &TCStateList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct RegIndexList {
    elements: &RegIndex;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof RegIndex);
        assert_with_msg(this.elements != null, "Could not allocate memory in RegIndexList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: RegIndex) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof RegIndex);
            assert_with_msg(this.elements != null, "Could not allocate memory in RegIndexList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof RegIndex) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &RegIndex {
        let l: &RegIndex = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &RegIndex {
        assert_with_msg(index < this.length, "Out of bounds access in RegIndexList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in RegIndexList.at");
        return this.elements + index * sizeof RegIndex;
    }

    func contains(&this, element: &RegIndex) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &RegIndex {
        assert_with_msg(this.length != 0, "Called last() on empty RegIndexList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &RegIndexList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRInstrList {
    elements: &IRInstr;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRInstr);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRInstrList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRInstr) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRInstr);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRInstrList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRInstr) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRInstr {
        let l: &IRInstr = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRInstr {
        assert_with_msg(index < this.length, "Out of bounds access in IRInstrList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRInstrList.at");
        return this.elements + index * sizeof IRInstr;
    }

    func contains(&this, element: &IRInstr) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRInstr {
        assert_with_msg(this.length != 0, "Called last() on empty IRInstrList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRInstrList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRScopeList {
    elements: &IRScope;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRScope);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRScopeList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRScope) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRScope);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRScopeList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRScope) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRScope {
        let l: &IRScope = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRScope {
        assert_with_msg(index < this.length, "Out of bounds access in IRScopeList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRScopeList.at");
        return this.elements + index * sizeof IRScope;
    }

    func contains(&this, element: &IRScope) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRScope {
        assert_with_msg(this.length != 0, "Called last() on empty IRScopeList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRScopeList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRRegList {
    elements: &IRReg;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRReg);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRRegList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRReg) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRReg);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRRegList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRReg) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRReg {
        let l: &IRReg = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRReg {
        assert_with_msg(index < this.length, "Out of bounds access in IRRegList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRRegList.at");
        return this.elements + index * sizeof IRReg;
    }

    func contains(&this, element: &IRReg) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRReg {
        assert_with_msg(this.length != 0, "Called last() on empty IRRegList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRRegList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRBlockList {
    elements: &IRBlock;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRBlock);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRBlockList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRBlock) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRBlock);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRBlockList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRBlock) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRBlock {
        let l: &IRBlock = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRBlock {
        assert_with_msg(index < this.length, "Out of bounds access in IRBlockList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRBlockList.at");
        return this.elements + index * sizeof IRBlock;
    }

    func contains(&this, element: &IRBlock) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRBlock {
        assert_with_msg(this.length != 0, "Called last() on empty IRBlockList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRBlockList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct LoopBlockList {
    elements: &LoopBlock;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof LoopBlock);
        assert_with_msg(this.elements != null, "Could not allocate memory in LoopBlockList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: LoopBlock) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof LoopBlock);
            assert_with_msg(this.elements != null, "Could not allocate memory in LoopBlockList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof LoopBlock) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &LoopBlock {
        let l: &LoopBlock = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &LoopBlock {
        assert_with_msg(index < this.length, "Out of bounds access in LoopBlockList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in LoopBlockList.at");
        return this.elements + index * sizeof LoopBlock;
    }

    func contains(&this, element: &LoopBlock) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &LoopBlock {
        assert_with_msg(this.length != 0, "Called last() on empty LoopBlockList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &LoopBlockList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRScopeEntryList {
    elements: &IRScopeEntry;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRScopeEntry);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRScopeEntryList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRScopeEntry) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRScopeEntry);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRScopeEntryList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRScopeEntry) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRScopeEntry {
        let l: &IRScopeEntry = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRScopeEntry {
        assert_with_msg(index < this.length, "Out of bounds access in IRScopeEntryList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRScopeEntryList.at");
        return this.elements + index * sizeof IRScopeEntry;
    }

    func contains(&this, element: &IRScopeEntry) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRScopeEntry {
        assert_with_msg(this.length != 0, "Called last() on empty IRScopeEntryList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRScopeEntryList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct IRFuncList {
    elements: &IRFunc;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof IRFunc);
        assert_with_msg(this.elements != null, "Could not allocate memory in IRFuncList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: IRFunc) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof IRFunc);
            assert_with_msg(this.elements != null, "Could not allocate memory in IRFuncList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof IRFunc) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &IRFunc {
        let l: &IRFunc = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &IRFunc {
        assert_with_msg(index < this.length, "Out of bounds access in IRFuncList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in IRFuncList.at");
        return this.elements + index * sizeof IRFunc;
    }

    func contains(&this, element: &IRFunc) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &IRFunc {
        assert_with_msg(this.length != 0, "Called last() on empty IRFuncList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &IRFuncList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct LLVMTypeList {
    elements: &LLVMType;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof LLVMType);
        assert_with_msg(this.elements != null, "Could not allocate memory in LLVMTypeList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: LLVMType) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof LLVMType);
            assert_with_msg(this.elements != null, "Could not allocate memory in LLVMTypeList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof LLVMType) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &LLVMType {
        let l: &LLVMType = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &LLVMType {
        assert_with_msg(index < this.length, "Out of bounds access in LLVMTypeList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in LLVMTypeList.at");
        return this.elements + index * sizeof LLVMType;
    }

    func contains(&this, element: &LLVMType) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &LLVMType {
        assert_with_msg(this.length != 0, "Called last() on empty LLVMTypeList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &LLVMTypeList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct RegValueList {
    elements: &RegValue;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof RegValue);
        assert_with_msg(this.elements != null, "Could not allocate memory in RegValueList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: RegValue) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof RegValue);
            assert_with_msg(this.elements != null, "Could not allocate memory in RegValueList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof RegValue) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &RegValue {
        let l: &RegValue = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &RegValue {
        assert_with_msg(index < this.length, "Out of bounds access in RegValueList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in RegValueList.at");
        return this.elements + index * sizeof RegValue;
    }

    func contains(&this, element: &RegValue) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &RegValue {
        assert_with_msg(this.length != 0, "Called last() on empty RegValueList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &RegValueList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct LLVMBasicBlockList {
    elements: &LLVMBasicBlock;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof LLVMBasicBlock);
        assert_with_msg(this.elements != null, "Could not allocate memory in LLVMBasicBlockList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: LLVMBasicBlock) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof LLVMBasicBlock);
            assert_with_msg(this.elements != null, "Could not allocate memory in LLVMBasicBlockList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof LLVMBasicBlock) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &LLVMBasicBlock {
        let l: &LLVMBasicBlock = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &LLVMBasicBlock {
        assert_with_msg(index < this.length, "Out of bounds access in LLVMBasicBlockList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in LLVMBasicBlockList.at");
        return this.elements + index * sizeof LLVMBasicBlock;
    }

    func contains(&this, element: &LLVMBasicBlock) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &LLVMBasicBlock {
        assert_with_msg(this.length != 0, "Called last() on empty LLVMBasicBlockList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &LLVMBasicBlockList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

struct LLVMValueList {
    elements: &LLVMValue;
    length: usize;
    capacity: usize;

    func initBlank(&this, newCap: usize) {
        if (this.elements != null) free(this.elements);
        this.elements = calloc(newCap, sizeof LLVMValue);
        assert_with_msg(this.elements != null, "Could not allocate memory in LLVMValueList.initBlank");
        this.capacity = newCap;
        this.length = newCap;
    }

    func push(&this, element: LLVMValue) {
        if (this.length >= this.capacity) {
            let newCap: usize = this.capacity * 2;
            if (newCap == 0) newCap = 1;
            this.elements = realloc(this.elements, newCap * sizeof LLVMValue);
            assert_with_msg(this.elements != null, "Could not allocate memory in LLVMValueList.push");
            this.capacity = newCap;
        }
        *(this.elements + this.length * sizeof LLVMValue) = element;
        this.length = this.length + 1;
    }

    func pop(&this) -> &LLVMValue {
        let l: &LLVMValue = this.last();
        this.length = this.length - 1;
        return l;
    }

    func at(&this, index: usize) -> &LLVMValue {
        assert_with_msg(index < this.length, "Out of bounds access in LLVMValueList.at");
        assert_with_msg(this.elements != null, "Element pointer is NULL in LLVMValueList.at");
        return this.elements + index * sizeof LLVMValue;
    }

    func contains(&this, element: &LLVMValue) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            if (this.at(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    func last(&this) -> &LLVMValue {
        assert_with_msg(this.length != 0, "Called last() on empty LLVMValueList");
        return this.at(this.length - 1);
    }

    func extend(&this, other: &LLVMValueList) {
        for (let i: usize = 0; i < other.length; i = i + 1) {
            this.push(*(other.at(i)));
        }
        other.free();
    }

    func free(&this) {
        free(this.elements);
        this.elements = null;
        this.length = 0;
        this.capacity = 0;
    }

    func clear(&this) {
        this.length = 0;
    }
}

