import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/hashmaps.bufo";
import "../util/arena.bufo";
import "../frontend/nodes.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./irgen.bufo";
import "./codegen_llvm.bufo";

@os(WINDOWS) import "winapi/structs.bufo";
@os(WINDOWS) import "winapi/functions.bufo";

struct InterpReg {
    offset: usize;
    size: usize;
}
func equals(this: &InterpReg, other: &InterpReg) -> bool {
    unreachable("InterpReg.equals is never called");
}

comptime REG_STACK_SIZE: usize = 16777216;
comptime STACK_SIZE: usize = 4194304;
struct IRInterp {
    irGen: &IRGen;
    regStackStart: &u8;
    globalRegisters: &RegValueList;
    globalRegBase: &u8;
    regStackBase: &u8;
    realStackStart: &u8;
    realStackPointer: &u8;
    realStackBase: &u8;
    argStack: &u8;
    argStackLength: usize;
    argStackCapacity: usize;
}
func dumpRegisterStack(this: &IRInterp, bytes: usize) {
    let cols: usize = 4;
    for (let i: usize = 0; i < bytes; i = i + 1) {
        if (i > 0 && i % (8 * cols) == 0) printf("\n");
        printf("%2hhX", *(this.regStackStart + i));
    }
    printf("\n");
}
func getGlobalPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    return this.globalRegBase - reg.offset - reg.size;
}
func getRegStackPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    let ptr: &u8 = this.regStackBase - reg.offset - reg.size;
    assert(ptr < this.regStackStart + REG_STACK_SIZE, "Stack Overflow in IRInterp.getRegStackPointer");
    assert(ptr >= this.regStackStart, "Stack Underflow in IRInterp.getRegStackPointer");
    return ptr;
}
func advanceRealStack(this: &IRInterp, span: Span, size: usize) -> &u8 {
    let _p: &u8 = this.realStackPointer;
    let new: &u8 = this.realStackPointer + size;
    if (new >= this.realStackStart + STACK_SIZE) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s: Stack Overflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        fprintf(stderr, "%s: %s: Last allocation tried to allocate %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        exit(2);
    }
    this.realStackPointer = new;
    return _p;
}
func pushArgument(this: &IRInterp, span: Span, start: &u8, size: usize) {
    trace("IRInterp.pushArgument");
    let new = this.argStackLength + size;
    if (new >= this.argStackCapacity) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s: Argument Stack Overflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        fprintf(stderr, "%s: %s: Last function call tried to push %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        exit(2);
    }
    memcpy(this.argStack + this.argStackLength, start, size);
    this.argStackLength = new;
}
func popArgument(this: &IRInterp, span: Span, start: &u8, size: usize) {
    trace("IRInterp.popArgument");
    let new = this.argStackLength - size;
    if (this.argStackLength < size) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s: Argument Stack Underflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        fprintf(stderr, "%s: %s: Last function call tried to pop %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        exit(2);
    }
    this.argStackLength = new;
    memcpy(start, this.argStack + this.argStackLength, size);
}

let instrFns = [
    evaluateNotImplemented,     // INSTR_INVALID
    evaluateAlloca,             // INSTR_ALLOCA
    evaluateGetParam,           // INSTR_GET_PARAM
    evaluateStore,              // INSTR_STORE
    evaluateNotImplemented,
    evaluateNotImplemented,
    evaluateFetchComptimeValue, // INSTR_FETCH_COMPTIME_VALUE
    evaluateLoadFunctionPtr,    // INSTR_LOAD_FUNCTION_PTR
    evaluateLoad,               // INSTR_LOAD
    evaluateMove,               // INSTR_MOVE
    evaluateInstrCall,          // INSTR_CALL
    evaluateReturnExpr,         // INSTR_RETURN_EXPR
    evaluateReturnVoid,         // INSTR_RETURN_VOID
    evaluateLoadString,         // INSTR_LOAD_STRING
    evaluateLoadBool,           // INSTR_LOAD_BOOL
    evaluateLoadI8,             // INSTR_LOAD_I8
    evaluateLoadU8,             // INSTR_LOAD_U8
    evaluateLoadI16,            // INSTR_LOAD_I16
    evaluateLoadU16,            // INSTR_LOAD_U16
    evaluateLoadI32,            // INSTR_LOAD_I32
    evaluateLoadU32,            // INSTR_LOAD_U32
    evaluateNotImplemented,
    evaluateLoadU64,            // INSTR_LOAD_U64
    evaluateLoadNull,           // INSTR_LOAD_NULL
    evaluateLoadF32,            // INSTR_LOAD_F32
    evaluateLoadF64,            // INSTR_LOAD_F64
    evaluateLoadBlank,          // INSTR_LOAD_BLANK
    evaluateCondBr,             // INSTR_COND_BR
    evaluateBr,                 // INSTR_BR
    evaluateIntAdd,             // INSTR_INT_ADD
    evaluateIntSub,             // INSTR_INT_SUB
    evaluateIntMul,             // INSTR_INT_MUL
    evaluateNotImplemented,     // INSTR_INT_DIV
    evaluateIntMod,             // INSTR_INT_MOD
    evaluateIntCmpEqAndNeq,     // INSTR_INT_CMP_EQ
    evaluateIntCmpEqAndNeq,     // INSTR_INT_CMP_NEQ
    evaluateIntCmpGtAndLte,     // INSTR_INT_CMP_GT
    evaluateIntCmpLtAndGte,     // INSTR_INT_CMP_GTE
    evaluateIntCmpLtAndGte,     // INSTR_INT_CMP_LT
    evaluateIntCmpGtAndLte,     // INSTR_INT_CMP_LTE
    evaluateFloatAdd,           // INSTR_FLOAT_ADD
    evaluateFloatSub,           // INSTR_FLOAT_SUB
    evaluateFloatMul,           // INSTR_FLOAT_MUL
    evaluateFloatDiv,           // INSTR_FLOAT_DIV
    evaluateFloatMod,           // INSTR_FLOAT_MOD
    evaluateFloatCmpEqAndNeq,   // INSTR_FLOAT_CMP_EQ
    evaluateFloatCmpEqAndNeq,   // INSTR_FLOAT_CMP_NEQ
    evaluateFloatCmpGtAndLte,   // INSTR_FLOAT_CMP_GT
    evaluateFloatCmpLtAndGte,   // INSTR_FLOAT_CMP_GTE
    evaluateFloatCmpLtAndGte,   // INSTR_FLOAT_CMP_LT
    evaluateFloatCmpGtAndLte,   // INSTR_FLOAT_CMP_LTE
    evaluateLogicalNot,         // INSTR_LOGICAL_NOT
    evaluateLogicalAnd,         // INSTR_LOGICAL_AND
    evaluateLogicalOr,          // INSTR_LOGICAL_OR
    evaluateNotImplemented,
    evaluateNotImplemented,
    evaluateNotImplemented,
    evaluateInsertValue,        // INSTR_INSERT_VALUE
    evaluateNotImplemented,
    evaluateNotImplemented,
    evaluateNotImplemented,
    evaluateIntToF32,           // INSTR_INT_TO_F32
    evaluateNotImplemented,
    evaluateF32ToInt,           // INSTR_F32_TO_INT
    evaluateF64ToInt,           // INSTR_F64_TO_INT
    evaluateF32ToF64,           // INSTR_F32_TO_F64
    evaluateF64ToF32,           // INSTR_F64_TO_F32
    evaluateCreateArray,        // INSTR_CREATE_ARRAY
    evaluateCreateStruct,       // INSTR_CREATE_STRUCT
    evaluatePtrToInt,           // INSTR_PTR_TO_INT
    evaluateIntToPtr,           // INSTR_INT_TO_PTR
    evaluateGetFieldPtr,        // INSTR_GET_FIELD_PTR
    evaluateNotImplemented,     // INSTR_GET_ELEMENT_PTR
    evaluateUnreachable,        // INSTR_UNREACHABLE
    evaluateUnterminated,       // INSTR_UNTERMINATED
];
func evaluateNotImplemented(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    printf("%s: ", toString(&instr.span).buffer);
    dump(instr);
    unreachable("Not implemented");
}
func evaluateAlloca(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateAlloca");
    // dst: dst,
    // src: RegIndex { i: size },
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "Alloca got non-pointer");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    *(getRegStackPointer(this, &reg) as &usize) = advanceRealStack(this, instr.span, instr.src.i) as usize;
    return reg;
}
func evaluateGetParam(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateGetParam");
    let size: usize = instr.op1.i;
    assert(size <= 8, "Interp: Expected small size for GetParam");
    let dst: InterpReg = InterpReg {
        offset: getRegister(irFunc, instr.dst).offset,
        size: size,
    };
    popArgument(this, instr.span, getRegStackPointer(this, &dst), size);
    return dst;
}
func evaluateStore(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateStore");
    // dst: ptr,
    // src: val,
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    assert(isPointer(dst.typ), "Store expected Ptr Dst");
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: getSize(dst.typ),
    };
    let srcReg: InterpReg = asInterp(src, "Store src");
    let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
    let dstLoc: &u8 = *(getRegStackPointer(this, &dstReg) as &usize) as &u8;
    memcpy(dstLoc, srcLoc, srcReg.size);
    return dstReg;
}
func evaluateFetchComptimeValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFetchComptimeValue");
    if (instr.op1.i == 1) {
        // Global fetch
        let fReg = getRegister(irFunc, instr.dst);
        let ptr = getGlobalPointer(this, &asInterp(at(this.globalRegisters, instr.src.i), "Interp FetchComptimeValue"));
        let size = getSize(fReg.typ);
        let reg = InterpReg {
            offset: fReg.offset,
            size: size,
        };
        memcpy(getRegStackPointer(this, &reg), ptr, size);
        return reg;
    } else {
        // Local fetch
        // noop in interpreter
        return asInterp(at(regs, instr.src.i), "Interp FetchComptimeValue");
    }
}
func evaluateLoadFunctionPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadFunctionPtr");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFunction(fReg.typ), "LoadFunctionPtr got non-function");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}
func evaluateLoad(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoad");
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    let srcReg: InterpReg =  asInterp(src, "Load src");
    assert(srcReg.size == 8, "Load expected Ptr Src");
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: getSize(dst.typ),
    };
    let srcLoc: &u8 = *(getRegStackPointer(this, &srcReg) as &usize) as &u8;
    let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
    memcpy(dstLoc, srcLoc, dstReg.size);
    return dstReg;
}
func evaluateMove(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateMove");
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    let srcReg: InterpReg =  asInterp(src, "Interp Move src");
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: getSize(dst.typ),
    };
    let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
    let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
    memcpy(dstLoc, srcLoc, dstReg.size);
    return dstReg;
}
func evaluateInstrCall(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateInstrCall");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let id = *(getRegStackPointer(this, &asInterp(at(regs, instr.src.i), "Call")) as &usize);
    let calledFunc: &IRFunc = at(&this.irGen.functions, id);
    let f = at(&funcDecls, calledFunc.originalID);
    if (isExtern(f)) {
        @os(WINDOWS) if (!isNull(f.dllHandle)) {
            let fun = compileFunctionCall(this, irFunc, calledFunc, instr, f.dllHandle.handle.ptr, regs);
            let retType = at(&types, at(&types, getType(&f.typeState)).typeIndex);
            let val = fun.run();
            let size: usize = getSize(dstReg.typ);
            let dst: InterpReg = InterpReg {
                offset: dstReg.offset,
                size: size,
            };
            if (getSize(retType) == 0) {
                // noop
            } else if (getSize(retType) <= 1) {
                *(getRegStackPointer(this, &dst) as &u8) = *((&val) as &u8);
            } else if (getSize(retType) <= 2) {
                *(getRegStackPointer(this, &dst) as &u16) = *((&val) as &u16);
            } else if (getSize(retType) <= 4) {
                if (isFloat(retType)) {
                    *(getRegStackPointer(this, &dst) as &f32) = *((&val) as &f32);
                } else {
                    *(getRegStackPointer(this, &dst) as &u32) = *((&val) as &u32);
                }
            } else if (getSize(retType) <= 8) {
                if (isFloat(retType)) {
                    *(getRegStackPointer(this, &dst) as &f64) = *((&val) as &f64);
                } else {
                    *(getRegStackPointer(this, &dst) as &u64) = *((&val) as &u64);
                }
            } else {
                // handled by IR generator
            }
            free(fun);
            return dst;
        } else {
            let loc = toString(&instr.span);
            fprintf(stderr, "%s: %s: Can not call external function `%s` at compile time.\n", loc.buffer, ERR_STR, calledFunc.name.buffer);
            if (f.dllHandle == dllNotFound()) {
                let m = getParentModule(f);
                let _loc = toString(&m.span);
                let cfg = getConfigs(m);
                if (cfg.length == 0) {
                    fprintf(stderr, "%s: %s: No configuration found!\n", _loc.buffer, NOTE_STR);
                } else {
                    fprintf(stderr, "%s: %s: Could not load any of the libraries specified in the module configuration.\n", loc.buffer, NOTE_STR);
                    fprintf(stderr, "%s: %s: Module declared here.\n", _loc.buffer, NOTE_STR);
                    for (let i: usize = 0; i < cfg.length; i = i + 1) {
                        let tli = at(&topLevelItems, *at(&cfg, i));
                        assert(tli.kind == TLI_CONFIG);
                        let _loc = toString(&tli.span);
                        fprintf(stderr, "%s: %s: Module configuration declared here.\n", _loc.buffer, NOTE_STR);
                        drop(&_loc);
                    }
                }
            } else if (f.dllHandle == dllNoSuchFunction()) {
                let m = getParentModule(f);
                let _loc = toString(&m.span);
                let cfg = getConfigs(m);
                if (cfg.length == 0) {
                    fprintf(stderr, "%s: %s: No configuration found!\n", _loc.buffer, NOTE_STR);
                } else {
                    let _fnLoc = toString(&f.span);
                    fprintf(stderr, "%s: %s: Could not find the function in any of the specified libraries.\n", loc.buffer, ERR_STR);
                    fprintf(stderr, "%s: %s: Function declared here.\n", _fnLoc.buffer, NOTE_STR);
                    fprintf(stderr, "%s: %s: Module declared here.\n", _loc.buffer, NOTE_STR);
                    for (let i: usize = 0; i < cfg.length; i = i + 1) {
                        let tli = at(&topLevelItems, *at(&cfg, i));
                        assert(tli.kind == TLI_CONFIG);
                        let _loc = toString(&tli.span);
                        fprintf(stderr, "%s: %s: Module configuration declared here.\n", _loc.buffer, NOTE_STR);
                        drop(&_loc);
                    }
                    drop(&_fnLoc);
                }
            } else if (f.dllHandle == null) {
                // REVIEW: What do we report here?
            } else {
                unreachable("actually null-ptr");
            }
            drop(&loc);
            exit(1);
        }
        @os(LINUX) todo_with_msg("comptime extern call");
    } else {
        let argSize: usize = this.argStackLength;
        let stackStart: &u8 = this.realStackStart;
        let regStackStart: &u8 = this.regStackStart;
        for (let _i: usize = 0; _i < instr.args.length; _i = _i + 1) {
            let i: usize = instr.args.length - _i - 1;
            let reg: &RegValue = at(regs, at(&instr.args, i).i);
            let arg: InterpReg = asInterp(reg, "call arg");
            pushArgument(this, instr.span, getRegStackPointer(this, &arg), arg.size);
        }
        let regs: RegValueList = blank;
        initBlank(&regs, calledFunc.registers.length);
        evaluateCall(this, instr.span, calledFunc, &regs);
        let size: usize = getSize(dstReg.typ);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: size,
        };
        popArgument(this, instr.span, getRegStackPointer(this, &dst), size);
        assert(argSize == this.argStackLength, "Imbalanced argument stack after calling IRInterp.evaluateCall");
        assert(stackStart == this.realStackStart, "Imbalanced real stack after calling IRInterp.evaluateCall");
        assert(regStackStart == this.regStackStart, "Imbalanced reg stack after calling IRInterp.evaluateCall");
        return dst;
    }
}
func evaluateReturnExpr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateReturnExpr");
    let expr: &RegValue = at(regs, instr.src.i);
    let rExpr: InterpReg =  asInterp(expr, "ReturnExpr");
    pushArgument(this, instr.span, getRegStackPointer(this, &rExpr), rExpr.size);
    return blank;
}

func evaluateReturnVoid(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateReturnVoid");
    return blank;
}

func evaluateLoadString(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadString");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "LoadString expected Ptr");
    assert(isChar(getUnderlyingType(fReg.typ, false)), "LoadString expected Ptr to Char");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}
func evaluateLoadBool(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadBool");
    let isTrue: u8 = instr.src.i as u8;
    assert(isTrue == 0 || isTrue == 1, "LoadBool expected 0 or 1");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u8) = isTrue;
    return reg;
}

func evaluateLoadI8(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI8");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI8 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i8) = instr.src.i as i8;
    return reg;
}
func evaluateLoadU8(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU8");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ) || isChar(fReg.typ), "LoadU8 got non-int non-char");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u8) = instr.src.i as u8;
    return reg;
}
func evaluateLoadI16(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI16");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI16 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 2,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i16) = instr.src.i as i16;
    return reg;
}

func evaluateLoadU16(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU16");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU16 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 2,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u16) = instr.src.i as u16;
    return reg;
}
func evaluateLoadI32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI32 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i32) = instr.src.i as i32;
    return reg;
}
func evaluateLoadU32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU32 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u32) = instr.src.i as u32;
    return reg;
}
func evaluateLoadU64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU64");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU64 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}

func evaluateLoadNull(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadNull");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "LoadNull got non-ptr");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = 0;
    return reg;
}
func evaluateLoadF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadF32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFloat(fReg.typ), "LoadF32 got non-float");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &f32) = *(&instr.src.i as &f32);
    return reg;
}

func evaluateLoadF64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadF64");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFloat(fReg.typ), "LoadF64 got non-float");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &f64) = *(&instr.src.i as &f64);
    return reg;
}

func evaluateLoadBlank(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadBlank");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateCondBr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCondBr");
    let cond: &RegValue = at(regs, instr.src.i);
    let rCond: InterpReg = asInterp(cond, "CondBr");
    assert(rCond.size == 1, "comptime CondBr expected single byte Cond");
    let condLoc: &u8 = getRegStackPointer(this, &rCond);
    let v: u8 = *condLoc;
    assert(v == 0 || v == 1, "condition is not 0 or 1");
    let id: usize = 0;
    if (v == 1) {
        id = instr.dst.i;
    } else {
        id = instr.op1.i;
    }
    return InterpReg { offset: id, size: 1 };
}
func evaluateBr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateBr");
    return InterpReg { offset: instr.dst.i, size: 1 };
}
func evaluateIntAdd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntAdd");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg = asInterp(lhs, "AddInt LHS");
    let rRhs: InterpReg = asInterp(rhs, "AddInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "AddInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) + *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) + *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) + *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) + *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) + *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) + *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) + *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) + *(rhsStart as &u64);
    } else {
        unreachable("int add with sus bitsize");
    }
    return dst;
}
func evaluateIntSub(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntSub");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "SubInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "SubInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "SubInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) - *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) - *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) - *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) - *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) - *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) - *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) - *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) - *(rhsStart as &u64);
    } else {
        unreachable("int add with sus bitsize");
    }
    return dst;
}

func evaluateIntMul(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntMul");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "MulInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "MulInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "MulInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) * *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) * *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) * *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) * *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) * *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) * *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) * *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) * *(rhsStart as &u64);
    } else {
        unreachable("int mul with sus bitsize");
    }
    return dst;
}
func evaluateIntMod(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntMod");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ModInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ModInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "ModInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) % *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) % *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) % *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) % *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) % *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) % *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) % *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) % *(rhsStart as &u64);
    } else {
        unreachable("int mod with sus bitsize");
    }
    return dst;
}
func evaluateIntCmpEqAndNeq(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpEqAndNeq");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpNeq/ICmpEq LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpNeq/ICmpEq RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpNeq/ICmpEq got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isInteger(t1) || isPointer(t1) || isChar(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) eq = *(lhsStart as &i8) == *(rhsStart as &i8);
            else eq = *(lhsStart as &u8) == *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) eq = *(lhsStart as &i16) == *(rhsStart as &i16);
            else eq = *(lhsStart as &u16) == *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) eq = *(lhsStart as &i32) == *(rhsStart as &i32);
            else eq = *(lhsStart as &u32) == *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) eq = *(lhsStart as &i64) == *(rhsStart as &i64);
            else eq = *(lhsStart as &u64) == *(rhsStart as &u64);
        } else {
            unreachable("int cmp with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpEq/ICmpNeq on non-int");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_INT_CMP_NEQ) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateIntCmpGtAndLte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpGtAndLte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpGt/ICmpLte LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpGt/ICmpLte RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpGt/ICmpLte got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let gt: bool = false;
    if (isInteger(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) gt = *(lhsStart as &i8) > *(rhsStart as &i8);
            else gt = *(lhsStart as &u8) > *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) gt = *(lhsStart as &i16) > *(rhsStart as &i16);
            else gt = *(lhsStart as &u16) > *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) gt = *(lhsStart as &i32) > *(rhsStart as &i32);
            else gt = *(lhsStart as &u32) > *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) gt = *(lhsStart as &i64) > *(rhsStart as &i64);
            else gt = *(lhsStart as &u64) > *(rhsStart as &u64);
        } else {
            unreachable("int cmpgt with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpGt/ICmpLte on non-int");
    }
    let r: u8 = 0;
    if (gt) r = 1;
    if (instr.kind == INSTR_INT_CMP_LTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateIntCmpLtAndGte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpLtAndGte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpLt/ICmpGte LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpLt/ICmpGte RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpLt/ICmpGte got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let gt: bool = false;
    if (isInteger(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) gt = *(lhsStart as &i8) < *(rhsStart as &i8);
            else gt = *(lhsStart as &u8) < *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) gt = *(lhsStart as &i16) < *(rhsStart as &i16);
            else gt = *(lhsStart as &u16) < *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) gt = *(lhsStart as &i32) < *(rhsStart as &i32);
            else gt = *(lhsStart as &u32) < *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) gt = *(lhsStart as &i64) < *(rhsStart as &i64);
            else gt = *(lhsStart as &u64) < *(rhsStart as &u64);
        } else {
            unreachable("int cmpgt with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpGt/ICmpLte on non-int");
    }
    let r: u8 = 0;
    if (gt) r = 1;
    if (instr.kind == INSTR_INT_CMP_GTE) r = 1 - r;
    *start = r;
    return dst;
}

func evaluateFloatAdd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatAdd");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatAdd LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatAdd RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatAdd expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) + *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) + *(rhsStart as &f64);
    } else {
        unreachable("float add with sus bitsize");
    }
    return dst;
}
func evaluateFloatSub(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatSub");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatSub LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatSub RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatSub expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) - *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) - *(rhsStart as &f64);
    } else {
        unreachable("float sub with sus bitsize");
    }
    return dst;
}
func evaluateFloatMul(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatMul");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatMul LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatMul RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatMul expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) * *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) * *(rhsStart as &f64);
    } else {
        unreachable("float mul with sus bitsize");
    }
    return dst;
}
func evaluateFloatDiv(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatDiv");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatDiv LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatDiv RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatDiv expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) / *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) / *(rhsStart as &f64);
    } else {
        unreachable("float div with sus bitsize");
    }
    return dst;
}
func evaluateFloatMod(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatMod");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatMod LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatMod RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatMod expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) % *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) % *(rhsStart as &f64);
    } else {
        unreachable("float mod with sus bitsize");
    }
    return dst;
}
func evaluateFloatCmpEqAndNeq(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpEqAndNeq");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpNeq/FCmpEq LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpNeq/FCmpEq RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpNeq/FCmpEq got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) == *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) == *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpEq/FCmpNeq on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_NEQ) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateFloatCmpGtAndLte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpGtAndLte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpLte/FCmpGt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpLte/FCmpGt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpLte/FCmpGt got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) > *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) > *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpGt/FCmpLte on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_LTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateFloatCmpLtAndGte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpLtAndGte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpGte/FCmpLt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpGte/FCmpLt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpGte/FCmpLt got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) < *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) < *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpLt/FCmpGte on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_GTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateLogicalNot(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalNot");
    let src: &RegValue = at(regs, instr.src.i);
    let rSrc: InterpReg = asInterp(src, "LNot SRC");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = getSize(t1);
    assert(s1 == 1, "Idk");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let srcStart: &u8 = getRegStackPointer(this, &rSrc);
    let val: u8 = *srcStart;
    assert(val == 0 || val == 1, "Logical Not got non-zero non-one");
    *dstStart = 1 - val;
    return dst;
}
func evaluateLogicalAnd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalAnd");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "LAnd LHS");
    let rRhs: InterpReg =  asInterp(rhs, "LAnd RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "LAnd got differently sized operands");
    assert(s1 == 1, "Idk");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    *dstStart = 0;
    if (*(lhsStart as &bool) && *(rhsStart as &bool)) {
        *dstStart = 1;
    }
    return dst;
}
func evaluateLogicalOr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalOr");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "LOr LHS");
    let rRhs: InterpReg =  asInterp(rhs, "LOr RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "LOr got differently sized operands");
    assert(s1 == 1, "Idk");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    *dstStart = 0;
    if (*(lhsStart as &bool) || *(rhsStart as &bool)) {
        *dstStart = 1;
    }
    return dst;
}
func evaluateInsertValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateInsertValue");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let t: &Type = dstReg.typ;
    if (isArray(t)) {
        let ut = getUnderlyingType(t, false);
        let valReg: InterpReg = asInterp(at(regs, instr.op1.i), "Interp InsertValue Array");
        let size = getSize(ut);
        let offset = instr.src.i * size;
        memcpy(dstStart + offset, getRegStackPointer(this, &valReg), size);
    } else if (isStruct(t)) {
        let s: &ParsedStructDecl = at(&structDecls, t.typeIndex);
        let offset: usize = 0;
        let fieldSize: usize = 0;
        getFieldOffsetAndSize(s, instr.src.i, &offset, &fieldSize);
        let valReg: InterpReg = asInterp(at(regs, instr.op1.i), "Interp InsertValue Struct");
        assert(valReg.size == fieldSize, "field size mismatch in Interp InsertValue");
        memcpy(dstStart + offset, getRegStackPointer(this, &valReg), fieldSize);
    } else {
        unreachable("Interp InsertValue expected Array or Struct");
    }
    return dst;
}
func evaluateF32ToF64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF32ToF64");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F32ToF64");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 8,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f32 = *(srcStart as &f32);
    *(dstStart as &f64) = v as f64;
    return dst;
}
func evaluateF64ToF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF64ToF32");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F64ToF32");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 4,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f64 = *(srcStart as &f64);
    *(dstStart as &f32) = v as f32;
    return dst;
}
func evaluateCreateArray(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCreateArray");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateCreateStruct(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCreateStruct");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateIntToF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntToF32");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp IntToF32");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 4,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let t: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t);
    let s: usize = getSize(t);
    let v: f32 = 0;
    if (s == 1) {
        if (signed) v = *(srcStart as &i8) as f32;
        else v = *(srcStart as &u8) as f32;
    } else if (s == 2) {
        if (signed) v = *(srcStart as &i16) as f32;
        else v = *(srcStart as &u16) as f32;
    } else if (s == 4) {
        if (signed) v = *(srcStart as &i32) as f32;
        else v = *(srcStart as &u32) as f32;
    } else if (s == 8) {
        if (signed) v = *(srcStart as &i64) as f32;
        else v = *(srcStart as &u64) as f32;
    } else {
        unreachable("Interp unexpected size in IntToF32");
    }
    *(dstStart as &f32) = v;
    return dst;
}
func evaluateF32ToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF32ToInt");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F32ToInt");
    let size: usize = getSize(dstReg.typ);
    let signed: bool = isSignedInteger(dstReg.typ);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: size,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f32 = *(srcStart as &f32);
    if (size == 1) {
        if (signed) *(dstStart as &i8) = v as i8;
        else *(dstStart as &u8) = v as u8;
    } else if (size == 2) {
        if (signed) *(dstStart as &i16) = v as i16;
        else *(dstStart as &u16) = v as u16;
    } else if (size == 4) {
        if (signed) *(dstStart as &i32) = v as i32;
        else *(dstStart as &u32) = v as u32;
    } else if (size == 8) {
        if (signed) *(dstStart as &i64) = v as i64;
        else *(dstStart as &u64) = v as u64;
    } else {
        unreachable("Interp F32ToInt: Exhaustive handling of destinations");
    }
    return dst;
}
func evaluateF64ToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF64ToInt");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F64ToInt");
    let size: usize = getSize(dstReg.typ);
    let signed: bool = isSignedInteger(dstReg.typ);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: size,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f64 = *(srcStart as &f64);
    if (size == 1) {
        if (signed) *(dstStart as &i8) = v as i8;
        else *(dstStart as &u8) = v as u8;
    } else if (size == 2) {
        if (signed) *(dstStart as &i16) = v as i16;
        else *(dstStart as &u16) = v as u16;
    } else if (size == 4) {
        if (signed) *(dstStart as &i32) = v as i32;
        else *(dstStart as &u32) = v as u32;
    } else if (size == 8) {
        if (signed) *(dstStart as &i64) = v as i64;
        else *(dstStart as &u64) = v as u64;
    } else {
        unreachable("Interp F64ToInt: Exhaustive handling of destinations");
    }
    return dst;
}
func evaluatePtrToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluatePtrToInt");
    // noop in interpreter
    return asInterp(at(regs, instr.src.i), "Interp PtrToInt");
}
func evaluateIntToPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntToPtr");
    // noop in interpreter
    return asInterp(at(regs, instr.src.i), "Interp IntToPtr");
}
func evaluateGetFieldPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateGetFieldPtr");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    let fAggr: InterpReg = asInterp(at(regs, instr.src.i), "IRInterp: GetFieldPtr");
    let t: &Type = getRegister(irFunc, instr.src).typ;
    assert(isStructPointer(t), "IRInterp: GetFieldPtr got non-struct pointer");
    let u: &Type = getUnderlyingType(t, false);
    assert(isStruct(u));
    let decl: &ParsedStructDecl = at(&structDecls, u.typeIndex);
    let offset: usize = 0;
    let size: usize = 0;
    getFieldOffsetAndSize(decl, instr.op1.i, &offset, &size);
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    let ptr: &u8 = getRegStackPointer(this, &fAggr);
    *(regStackLoc as &usize) = *(ptr as &usize) + offset;
    return reg;
}
func evaluateUnreachable(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateUnreachable");
    unreachable("IRInterp: Hit INSTR_UNREACHABLE");
}
func evaluateUnterminated(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateUnterminated");
    unreachable("IRInterp: Hit INSTR_UNTERMINATED");
}

func evaluateSingle(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateSingle");
    if (!forcedComptime) {
        assert(instr.isComptime, "Expected comptime instr in IRInterp.evaluateSingle");
    }
    assert(this.regStackBase < this.regStackStart + REG_STACK_SIZE, "Stack Cursor Overflow in IRInterp.evaluateSingle");
    if (PRINT_DEBUG) dump(instr);
    return instrFns[instr.kind](this, irFunc, instr, regs, forcedComptime);
}
func evaluateBlock(this: &IRInterp, blockID: &IRBlockID, irFunc: &IRFunc, regs: &RegValueList, forcedComptime: bool) -> bool {
    trace("IRInterp.evaluateBlock");
    let block: &IRBlock = getBlockByID(irFunc, *blockID);
    assert(block.instructions.length > 0, "Interp: Encountered empty block");
    for (let ip: usize = 0; ip < block.instructions.length; ip = ip + 1) {
        let instr: &IRInstr = at(&block.instructions, ip);
        let result = evaluateSingle(this, irFunc, instr, regs, forcedComptime);
        if (ip == block.instructions.length - 1) {
            assert(isTerminator(instr), "Interp: Unexpected non-terminator at the end of a block");
            let ret = result.size == 1;
            if (ret) {
                *blockID = IRBlockID { i: result.offset };
            }
            return ret;
        } else {
            assert(!isTerminator(instr), "Interp: Unexpected terminator in the middle of a block");
            *(at(regs, instr.dst.i)) = RegValue {
                isLLVM: false,
                regValue: result,
                llvmValue: blank,
            };
        }
    }
    return false;
}

comptime RAX: u8 = 0;
comptime RCX: u8 = 1;
comptime RDX: u8 = 2;
comptime RBX: u8 = 3;
comptime RSP: u8 = 4;
comptime RBP: u8 = 5;
comptime RSI: u8 = 6;
comptime RDI: u8 = 7;
comptime R8: u8 = 8;
comptime R9: u8 = 9;
comptime R10: u8 = 10;
comptime R11: u8 = 11;
comptime R12: u8 = 12;
comptime R13: u8 = 13;
comptime R14: u8 = 14;
comptime R15: u8 = 15;

comptime XMM0: u8 = 0;
comptime XMM1: u8 = 1;
comptime XMM2: u8 = 2;
comptime XMM3: u8 = 3;
comptime XMM4: u8 = 4;
comptime XMM5: u8 = 5;

comptime ADDR_INDIRECT: u8 = 0;
comptime ADDR_DISP8: u8 = 1;
comptime ADDR_DISP32: u8 = 2;
comptime ADDR_REG: u8 = 3;

comptime PROT_READ: i32 = 1;
comptime PROT_WRITE: i32 = 2;
comptime PROT_EXEC: i32 = 4;
comptime MAP_PRIVATE: i32 = 2;
comptime MAP_ANONYMOUS: i32 = 32;

comptime RTLD_LAZY: i32 = 1;

struct ByteBuffer {
    elements: &u8;
    length: usize;
    capacity: usize;
}

struct Function {
    run: func () -> u64;
    size: usize;
}

func free(fn: Function) {
    if (!VirtualFree(fn.run as Any, fn.size, 16384)) {
        printf("warning: Could not free function at %p\n", fn.run);
    }
}

func push(buf: &ByteBuffer, b1: char, b2: char, b3: char, b4: char, b5: char, b6: char, b7: char, b8: char) {
    push(buf, b1 as u8, b2 as u8, b3 as u8, b4 as u8, b5 as u8, b6 as u8, b7 as u8, b8 as u8);
}

func push(buf: &ByteBuffer, b1: char, b2: char, b3: char, b4: char) {
    push(buf, b1 as u8, b2 as u8);
    push(buf, b3 as u8, b4 as u8);
}
func push(buf: &ByteBuffer, b1: char, b2: char, b3: char) {
    push(buf, b1 as u8, b2 as u8);
    push(buf, b3 as u8);
}
func push(buf: &ByteBuffer, b1: char, b2: char) {
    push(buf, b1 as u8, b2 as u8);
}
func push(buf: &ByteBuffer, b1: char) {
    push(buf, b1 as u8);
}
func push(buf: &ByteBuffer, b1: u8, b2: u8) {
    push(buf, b1);
    push(buf, b2);
}
func push(buf: &ByteBuffer, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8) {
    push(buf, b1);
    push(buf, b2);
    push(buf, b3);
    push(buf, b4);
    push(buf, b5);
    push(buf, b6);
    push(buf, b7);
    push(buf, b8);
}
func push(buf: &ByteBuffer, element: u8) {
    if (buf.length >= buf.capacity) {
        let newCap: usize = buf.capacity * 2;
        if (newCap == 0) newCap = 32;
        buf.elements = realloc(buf.elements, newCap * sizeof u8);
        assert(buf.elements != null, "Could not allocate memory in ByteBuffer.push");
        buf.capacity = newCap;
    }
    buf.elements[buf.length] = element;
    buf.length = buf.length + 1;
}

func extend(buf: &ByteBuffer, other: &ByteBuffer) {
    for (let i: usize = 0; i < other.length; i = i + 1) {
        push(buf, other.elements[i]);
    }
    free(other.elements);
    *other = blank;
}

func pushImm(bytes: &ByteBuffer, imm: u32) {
    let _bytes = &imm as &u8;
    for (let i: usize = 0; i < 4; i = i + 1) {
        push(bytes, _bytes[i]);
    }
}

func pushImm(bytes: &ByteBuffer, imm: u64) {
    let _bytes = &imm as &u8;
    for (let i: usize = 0; i < 8; i = i + 1) {
        push(bytes, _bytes[i]);
    }
}

func modRM(bytes: &ByteBuffer, addr: u8, opext: u8, reg: u8) {
    let byte = shiftLeft(addr as usize, 6) as u8;
    byte = byte | shiftLeft(opext as usize, 3) as u8;
    byte = byte | (reg % 8);
    push(bytes, byte);
}

func modPrefix(bytes: &ByteBuffer, r: u8) {
    let rex: u8 = '\x48' as u8;
    if (r >= 8) rex = rex | 1;
    push(bytes, rex);
}

func mov(to: u8, from: u8) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    modPrefix(&bytes, from);
    push(&bytes, '\x89');
    modRM(&bytes, ADDR_REG, from, to);
    return bytes;
}

func mov(r: u8, imm: u32) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    let opcode = (('\xb8' as u8) + (r % 8)) as char;
    push(&bytes, opcode);
    pushImm(&bytes, imm);
    return bytes;
}

func mov(r: u8, imm: u64) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    modPrefix(&bytes, r);
    let opcode = (('\xb8' as u8) + (r % 8)) as char;
    push(&bytes, opcode);
    pushImm(&bytes, imm);
    return bytes;
}


func push(reg: u8) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    push(&bytes, '\xFF');
    modRM(&bytes, ADDR_REG, 6, reg);
    return bytes;
}

func pop(reg: u8) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    push(&bytes, '\x8F');
    modRM(&bytes, ADDR_REG, 0, reg);
    return bytes;
}

func mov(r: u8, offset: u32, imm: u64) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    extend(&bytes, &mov(RBX, imm));
    assert(offset < 256, "only single byte offset for now");
    push(&bytes, '\x48', '\x89', '\x5C', '\x24');
    push(&bytes, offset as char);
    return bytes;
}

func mov(r: u8, imm: f32) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    extend(&bytes, &mov(RAX, *(&imm as &u32)));
    push(&bytes, '\x66', '\x0F', '\x6E');
    modRM(&bytes, ADDR_REG, r, RAX);
    return bytes;
}

func mov(r: u8, imm: f64) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    extend(&bytes, &mov(RAX, *(&imm as &u64)));
    push(&bytes, '\x66', '\x48', '\x0F', '\x6E');
    modRM(&bytes, ADDR_REG, r, RAX);
    return bytes;
}

func add(r: u8, imm: u32) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    modPrefix(&bytes, r);
    push(&bytes, '\x81');
    modRM(&bytes, ADDR_REG, 0, r);
    pushImm(&bytes, imm);
    return bytes;
}

func sub(r: u8, imm: u32) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    modPrefix(&bytes, r);
    push(&bytes, '\x81');
    modRM(&bytes, ADDR_REG, 5, r);
    pushImm(&bytes, imm);
    return bytes;
}

func call(r: u8) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    push(&bytes, '\xFF');
    modRM(&bytes, ADDR_REG, 2, r);
    return bytes;
}

func push(val: u64) -> ByteBuffer {
    let bytes: ByteBuffer = blank;
    extend(&bytes, &mov(RAX, val));
    push(&bytes, '\xFF');
    modRM(&bytes, ADDR_REG, 6, RAX);
    return bytes;
}


@os(WINDOWS) func compileFunctionCall(this: &IRInterp, currFunc: &IRFunc, calledFunc: &IRFunc, instr: &IRInstr, fn: usize, regs: &RegValueList) -> Function {
    let f = at(&funcDecls, calledFunc.originalID);
    let fnType = at(&types, getType(&f.typeState));
    let retType = at(&types, fnType.typeIndex);
    let buf: ByteBuffer = blank;
    // push(&buf, '\xf1');
    extend(&buf, &push(RBP));
    extend(&buf, &mov(RBP, RSP));
    comptime ARG_LEN: usize = 4;
    let stack_offset: u32 = 32;
    comptime ARGS = [[RCX, XMM0], [RDX, XMM1], [R8, XMM2], [R9, XMM3]];
    for (let i: usize = 0; i < instr.args.length; i = i + 1) {
        let index = at(&instr.args, i);
        let reg: &RegValue = at(regs, index.i);
        let arg: InterpReg = asInterp(reg, "call arg");
        let origReg = getRegister(currFunc, *index);
        let argType = origReg.typ;
        if (isVariadic(fnType)) {
            if (isFloat(argType)) {
                if (getSize(argType) == 4) {
                    extend(&buf, &mov(ARGS[i][0], *(getRegStackPointer(this, &arg) as &u32)));
                    extend(&buf, &mov(ARGS[i][1], *(getRegStackPointer(this, &arg) as &f32)));
                } else {
                    extend(&buf, &mov(ARGS[i][0], *(getRegStackPointer(this, &arg) as &u64)));
                    extend(&buf, &mov(ARGS[i][1], *(getRegStackPointer(this, &arg) as &f64)));
                }
            } else if (getSize(argType) <= 8) {
                extend(&buf, &mov(ARGS[i][0], *(getRegStackPointer(this, &arg) as &u64)));
            } else {
                todo_with_msg("non-int non-float >8 byte reg");
            }
        } else if (i >= ARG_LEN) {
            // Technically this puts a lot of garbage on the stack, but do we care?
            // we update the stack pointer correctly, so the next argument overwrites the garbage
            // and if the called function doesn't manage the stack properly, is that our fault?
            if (getSize(argType) <= 8) {
                extend(&buf, &mov(RSP, stack_offset, *(getRegStackPointer(this, &arg) as &u64)));
            } else {
                todo_with_msg(">8byte stack");
            }
            stack_offset = stack_offset + getSize(argType) as u32;
        } else {
            if (isFloat(argType)) {
                if (getSize(argType) == 4) {
                    extend(&buf, &mov(ARGS[i][1], *(getRegStackPointer(this, &arg) as &f32)));
                } else {
                    extend(&buf, &mov(ARGS[i][1], *(getRegStackPointer(this, &arg) as &f64)));
                }
            } else if (getSize(argType) <= 8) {
                extend(&buf, &mov(ARGS[i][0], *(getRegStackPointer(this, &arg) as &u64)));
            } else {
                todo_with_msg("non-int non-float >8 byte reg");
            }
        }
    }
    if (instr.args.length < 4) extend(&buf, &sub(RSP, 32));
    extend(&buf, &mov(RAX, fn as u64));
    extend(&buf, &call(RAX));
    if (instr.args.length < 4) extend(&buf, &add(RSP, 32));
    extend(&buf, &pop(RBP));
    if (isFloat(retType)) {
        push(&buf, '\x66', '\x48', '\x0F', '\x7E');
        modRM(&buf, ADDR_REG, XMM0, RAX);
    } else if (isNone(retType)) {
        extend(&buf, &mov(RAX, 420691337 as u32));
    } else if (isInteger(retType) || isBoolean(retType) || isStruct(retType) || isPointer(retType)) {
        // noop, other side will hopefully put the thing in RAX for us
    } else {
        fprintf(stderr, "%s\n", toString(retType).buffer);
        todo_with_msg("non-float ret");
    }
    // if (ret == U64) {
    // } else if (ret == F64) {
    // } else if (ret == F32) {
    //     push(&buf, '\x66', '\x0F', '\x7E');
    //     modRM(&buf, ADDR_REG, XMM0, RAX);
    // } else {
    //     unreachable("yo momma so fat, she can't even return properly");
    // }
    push(&buf, '\xC3');
    let code = VirtualAlloc(null, buf.length, 4096, 64);
    assert(code != null, "Could not alloc some bytes sadge thx Windows");
    memcpy(code, buf.elements, buf.length);
    free(buf.elements);
    return Function { run: code as func () -> u64, size: buf.length };
}
func evaluateCall(this: &IRInterp, span: Span, irFunc: &IRFunc, regs: &RegValueList) {
    trace("IRInterp.evaluateCall");
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    pushRegisterStack(this, span, funcSize);
    let blockID: IRBlockID = IRBlockID { i: 0 };
    while (evaluateBlock(this, &blockID, irFunc, regs, true)) {
    }
    popRegisterStack(this, span, funcSize);
    return;
}
func pushRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.pushRegisterStack");
    let new: &u8 = this.regStackBase + size;
    if (new > this.regStackStart + REG_STACK_SIZE) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s Register Stack Overflow in the comptime interpreter.\n", loc.buffer, FATAL_STR);
        fprintf(stderr, "%s: %s Tried to reserve %llu byte(s).\n", loc.buffer, FATAL_STR, size);
        drop(&loc);
        exit(2);
    }
    this.regStackBase = new;
}
func popRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.popRegisterStack");
    let new: &u8 = this.regStackBase - size;
    if (new < this.regStackStart) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s Register Stack Underflow in the comptime interpreter.\n", loc.buffer, FATAL_STR);
        drop(&loc);
        exit(2);
    }
    this.regStackBase = new;
    assert(this.regStackBase >= this.globalRegBase, "Register Stack overwrote global stack");
}

func newIRInterpreter(irGen: &IRGen) -> IRInterp {
    let regStack: &u8 = malloc(REG_STACK_SIZE);
    assert(regStack != null, "Could not prepare IRInterp.regStack");
    let realStack: &u8 = malloc(STACK_SIZE);
    assert(realStack != null, "Could not prepare IRInterp.realStack");
    let argStack: &u8 = malloc(640000);
    assert(argStack != null, "Could not prepare IRInterp.argStack");
    return IRInterp {
        irGen: irGen,
        globalRegisters: null,
        regStackStart: regStack,
        globalRegBase: regStack,
        regStackBase: regStack,
        realStackStart: realStack,
        realStackPointer: realStack,
        realStackBase: realStack,
        argStack: argStack,
        argStackLength: 0,
        argStackCapacity: 640000,
    };
}
