import "prelude.bufo";
import "libc.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../frontend/nodes.bufo";
import "../middleend/types.bufo";
import "./irgen.bufo";
import "./codegen_llvm.bufo";

struct InterpReg {
    offset: usize;
    size: usize;
}
func equals(this: &InterpReg, other: &InterpReg) -> bool {
    todo_with_msg("InterpReg.equals");
}

comptime REG_STACK_SIZE: usize = 16777216;
comptime STACK_SIZE: usize = 4194304;
struct IRInterp {
    irGen: &IRGen;
    regStackStart: &u8;
    globalRegisters: &RegValueList;
    globalRegBase: &u8;
    regStackBase: &u8;
    realStackStart: &u8;
    realStackPointer: &u8;
    realStackBase: &u8;
    argStack: &u8;
    argStackLength: usize;
    argStackCapacity: usize;
}
func dumpRegisterStack(this: &IRInterp, bytes: usize) {
    let cols: usize = 4;
    for (let i: usize = 0; i < bytes; i = i + 1) {
        if (i > 0 && i % (8 * cols) == 0) printf("\n");
        printf("%2hhX", *(this.regStackStart + i));
    }
    printf("\n");
}
func getGlobalPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    return this.globalRegBase - reg.offset - reg.size;
}
func getRegStackPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    let ptr: &u8 = this.regStackBase - reg.offset - reg.size;
    assert(ptr < this.regStackStart + REG_STACK_SIZE, "Stack Overflow in IRInterp.getRegStackPointer");
    assert(ptr >= this.regStackStart, "Stack Underflow in IRInterp.getRegStackPointer");
    return ptr;
}
func advanceRealStack(this: &IRInterp, span: Span, size: usize) -> &u8 {
    let _p: &u8 = this.realStackPointer;
    let new: &u8 = this.realStackPointer + size;
    if (new >= this.realStackStart + STACK_SIZE) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s: Stack Overflow in the comptime interpreter.\n", loc.chars(), ERR_STR);
        fprintf(stderr, "%s: %s: Last allocation tried to allocate %llu byte(s).\n", loc.chars(), NOTE_STR, size);
        loc.drop();
        exit(2);
    }
    this.realStackPointer = new;
    return _p;
}
func pushArgument(this: &IRInterp, start: &u8, size: usize) {
    trace("IRInterp.pushArgument");
    if (this.argStackLength + size >= this.argStackCapacity) todo_with_msg("overflow in pushArgument");
    memcpy(this.argStack + this.argStackLength, start, size);
    this.argStackLength = this.argStackLength + size;
}
func popArgument(this: &IRInterp, start: &u8, size: usize) {
    trace("IRInterp.popArgument");
    if (this.argStackLength < size) todo_with_msg("underflow in popArgument");
    this.argStackLength = this.argStackLength - size;
    memcpy(start, this.argStack + this.argStackLength, size);
}
func evaluateSingle(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateSingle");
    if (!forcedComptime) {
        assert(instr.isComptime, "Expected comptime instr in IRInterp.evaluateSingle");
    }
    assert(this.regStackBase < this.regStackStart + REG_STACK_SIZE, "Stack Cursor Overflow in IRInterp.evaluateSingle");
    if (PRINT_DEBUG) instr.dump();
    if (instr.kind == INSTR_ALLOCA) {
        // dst: dst,
        // src: RegIndex { i: size },
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isPointer(), "Alloca got non-pointer");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        *(getRegStackPointer(this, &reg) as &usize) = advanceRealStack(this, instr.span, instr.src.i) as usize;
        return reg;
    } else if (instr.kind == INSTR_STORE) {
        // dst: ptr,
        // src: val,
        let dst: &IRReg = irFunc.getRegister(instr.dst);
        let src: &RegValue = regs.at(instr.src.i);
        assert(dst.typ.isPointer(), "Store expected Ptr Dst");
        let dstReg: InterpReg = InterpReg {
            offset: dst.offset,
            size: dst.typ.getSize(),
        };
        let srcReg: InterpReg = asInterp(src, "Store src");
        let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
        let dstLoc: &u8 = *(getRegStackPointer(this, &dstReg) as &usize) as &u8;
        memcpy(dstLoc, srcLoc, srcReg.size);
        return dstReg;
    } else if (instr.kind == INSTR_GET_PARAM) {
        // dst: dst,
        // src: RegIndex { i: index },
        // op1: RegIndex { i: size },
        // this.argStack -> top is argument
        // size of arg -> instr.src.i
        // param ptr -> reg[instr.dst]
        let size: usize = instr.op1.i;
        assert(size <= 8, "Interp: Expected small size for GetParam");
        let dst: InterpReg = InterpReg {
            offset: irFunc.getRegister(instr.dst).offset,
            size: size,
        };
        popArgument(this, getRegStackPointer(this, &dst), size);
        return dst;
    } else if (instr.kind == INSTR_LOAD) {
        // dst: reg,
        // src: ptr,
        let dst: &IRReg = irFunc.getRegister(instr.dst);
        let src: &RegValue = regs.at(instr.src.i);
        let srcReg: InterpReg =  asInterp(src, "Load src");
        assert(srcReg.size == 8, "Load expected Ptr Src");
        let dstReg: InterpReg = InterpReg {
            offset: dst.offset,
            size: dst.typ.getSize(),
        };
        let srcLoc: &u8 = *(getRegStackPointer(this, &srcReg) as &usize) as &u8;
        let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
        memcpy(dstLoc, srcLoc, dstReg.size);
        return dstReg;
    } else if (instr.kind == INSTR_MOVE) {
        // dst: reg,
        // src: ptr,
        let dst: &IRReg = irFunc.getRegister(instr.dst);
        let src: &RegValue = regs.at(instr.src.i);
        let srcReg: InterpReg =  asInterp(src, "Interp Move src");
        let dstReg: InterpReg = InterpReg {
            offset: dst.offset,
            size: dst.typ.getSize(),
        };
        let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
        let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
        memcpy(dstLoc, srcLoc, dstReg.size);
        return dstReg;
    } else if (instr.kind == INSTR_LOAD_I8) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadI8 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 1,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &i8) = instr.src.i as i8;
        return reg;
    } else if (instr.kind == INSTR_LOAD_U8) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger() || fReg.typ.isChar(), "LoadU8 got non-int non-char");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 1,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &u8) = instr.src.i as u8;
        return reg;
    } else if (instr.kind == INSTR_LOAD_I16) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadI16 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 2,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &i16) = instr.src.i as i16;
        return reg;
    } else if (instr.kind == INSTR_LOAD_U16) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadU16 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 2,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &u16) = instr.src.i as u16;
        return reg;
    } else if (instr.kind == INSTR_LOAD_I32) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadI32 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 4,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &i32) = instr.src.i as i32;
        return reg;
    } else if (instr.kind == INSTR_LOAD_U32) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadU32 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 4,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &u32) = instr.src.i as u32;
        return reg;
    } else if (instr.kind == INSTR_LOAD_I64) {
        todo_with_msg("INSTR_LOAD_I64");
    } else if (instr.kind == INSTR_LOAD_U64) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isInteger(), "LoadU64 got non-int");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &usize) = instr.src.i;
        return reg;
    } else if (instr.kind == INSTR_LOAD_F32) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isFloat(), "LoadF32 got non-float");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 4,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &f32) = *(&instr.src.i as &f32);
        return reg;
    } else if (instr.kind == INSTR_LOAD_F64) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isFloat(), "LoadF64 got non-float");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &f64) = *(&instr.src.i as &f64);
        return reg;
    } else if (instr.kind == INSTR_LOAD_BOOL) {
        let isTrue: u8 = instr.src.i as u8;
        assert(isTrue == 0 || isTrue == 1, "LoadBool expected 0 or 1");
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 1,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &u8) = isTrue;
        return reg;
    } else if (instr.kind == INSTR_LOAD_NULL) {
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isPointer(), "LoadNull got non-ptr");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &usize) = 0;
        return reg;
    } else if (instr.kind == INSTR_LOAD_BLANK) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: dstReg.typ.getSize(),
        };
        memset(getRegStackPointer(this, &dst), 0, dst.size);
        return dst;
    } else if (instr.kind == INSTR_CREATE_STRUCT) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: dstReg.typ.getSize(),
        };
        memset(getRegStackPointer(this, &dst), 0, dst.size);
        return dst;
    } else if (instr.kind == INSTR_LOAD_STRING) {
        // dst: dst,
        // src: RegIndex { i: str.start as usize },
        // op1: RegIndex { i: str.len },
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        assert(fReg.typ.isPointer(), "LoadString expected Ptr");
        assert(fReg.typ.getUnderlyingType(false).isChar(), "LoadString expected Ptr to Char");
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        *(regStackLoc as &usize) = instr.src.i;
        return reg;
    } else if (instr.kind == INSTR_CALL) {
        // dst: dst,
        // src: funcID,
        // op1: blank,
        // args: args,
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let calledFunc: &IRFunc = this.irGen.functions.at(instr.src.i);
        let argSize: usize = this.argStackLength;
        let stackStart: &u8 = this.realStackStart;
        let regStackStart: &u8 = this.regStackStart;
        for (let _i: usize = 0; _i < instr.args.length; _i = _i + 1) {
            let i: usize = instr.args.length - _i - 1;
            let reg: &RegValue = regs.at(instr.args.at(i).i);
            let arg: InterpReg = asInterp(reg, "call arg");
            pushArgument(this, getRegStackPointer(this, &arg), arg.size);
        }
        let regs: RegValueList = blank;
        regs.initBlank(calledFunc.registers.length);
        evaluateCall(this, instr.span, calledFunc, &regs);
        let size: usize = dstReg.typ.getSize();
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: size,
        };
        popArgument(this, getRegStackPointer(this, &dst), size);
        assert(argSize == this.argStackLength, "Imbalanced argument stack after calling IRInterp.evaluateCall");
        assert(stackStart == this.realStackStart, "Imbalanced real stack after calling IRInterp.evaluateCall");
        assert(regStackStart == this.regStackStart, "Imbalanced reg stack after calling IRInterp.evaluateCall");
        return dst;
    } else if (instr.kind == INSTR_INSERT_VALUE) {
        // dst: aggr,
        // src: RegIndex { i: index },
        // op1: val,
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: dstReg.typ.getSize(),
        };
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let t: &Type = dstReg.typ;
        if (t.isArray()) {
            todo_with_msg("InsertValue Array");
        } else if (t.isStruct()) {
            let s: &ParsedStructDecl = structDecls.at(t.typeIndex);
            let offset: usize = 0;
            let fieldSize: usize = 0;
            s.getFieldOffsetAndSize(instr.src.i, &offset, &fieldSize);
            let valReg: InterpReg = asInterp(regs.at(instr.op1.i), "Interp InsertValue Struct");
            assert(valReg.size == fieldSize, "field size mismatch in Interp InsertValue");
            memcpy(dstStart + offset, getRegStackPointer(this, &valReg), fieldSize);
            return dst;
        } else {
            unreachable("Interp InsertValue expected Array or Struct");
        }
    } else if (instr.kind == INSTR_INT_ADD) {
        // OPT: Specialized 8bit, 16bit, etc. variations
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "AddInt LHS");
        let rRhs: InterpReg =  asInterp(rhs, "AddInt RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let signed: bool = t1.isSignedInteger();
        let s1: usize = rLhs.size;
        let s2: usize = rRhs.size;
        assert(s1 == s2, "AddInt expected LHS and RHS to be the same size");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        if (s1 == 1) {
            if (signed) *(start as &i8) = *(lhsStart as &i8) + *(rhsStart as &i8);
            else *(start as &u8) = *(lhsStart as &u8) + *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) *(start as &i16) = *(lhsStart as &i16) + *(rhsStart as &i16);
            else *(start as &u16) = *(lhsStart as &u16) + *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) *(start as &i32) = *(lhsStart as &i32) + *(rhsStart as &i32);
            else *(start as &u32) = *(lhsStart as &u32) + *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) *(start as &i64) = *(lhsStart as &i64) + *(rhsStart as &i64);
            else *(start as &u64) = *(lhsStart as &u64) + *(rhsStart as &u64);
        } else {
            unreachable("int add with sus bitsize");
        }
        return dst;
    } else if (instr.kind == INSTR_INT_SUB) {
        // OPT: Specialized 8bit, 16bit, etc. variations
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "SubInt LHS");
        let rRhs: InterpReg =  asInterp(rhs, "SubInt RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let signed: bool = t1.isSignedInteger();
        let s1: usize = rLhs.size;
        let s2: usize = rRhs.size;
        assert(s1 == s2, "SubInt expected LHS and RHS to be the same size");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        if (s1 == 1) {
            if (signed) *(start as &i8) = *(lhsStart as &i8) - *(rhsStart as &i8);
            else *(start as &u8) = *(lhsStart as &u8) - *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) *(start as &i16) = *(lhsStart as &i16) - *(rhsStart as &i16);
            else *(start as &u16) = *(lhsStart as &u16) - *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) *(start as &i32) = *(lhsStart as &i32) - *(rhsStart as &i32);
            else *(start as &u32) = *(lhsStart as &u32) - *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) *(start as &i64) = *(lhsStart as &i64) - *(rhsStart as &i64);
            else *(start as &u64) = *(lhsStart as &u64) - *(rhsStart as &u64);
        } else {
            unreachable("int add with sus bitsize");
        }
        return dst;
    } else if (instr.kind == INSTR_INT_MUL) {
        // OPT: Specialized 8bit, 16bit, etc. variations
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "MulInt LHS");
        let rRhs: InterpReg =  asInterp(rhs, "MulInt RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let signed: bool = t1.isSignedInteger();
        let s1: usize = rLhs.size;
        let s2: usize = rRhs.size;
        assert(s1 == s2, "MulInt expected LHS and RHS to be the same size");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        if (s1 == 1) {
            if (signed) *(start as &i8) = *(lhsStart as &i8) * *(rhsStart as &i8);
            else *(start as &u8) = *(lhsStart as &u8) * *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) *(start as &i16) = *(lhsStart as &i16) * *(rhsStart as &i16);
            else *(start as &u16) = *(lhsStart as &u16) * *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) *(start as &i32) = *(lhsStart as &i32) * *(rhsStart as &i32);
            else *(start as &u32) = *(lhsStart as &u32) * *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) *(start as &i64) = *(lhsStart as &i64) * *(rhsStart as &i64);
            else *(start as &u64) = *(lhsStart as &u64) * *(rhsStart as &u64);
        } else {
            unreachable("int mul with sus bitsize");
        }
        return dst;
    } else if (instr.kind == INSTR_INT_MOD) {
        // OPT: Specialized 8bit, 16bit, etc. variations
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "ModInt LHS");
        let rRhs: InterpReg =  asInterp(rhs, "ModInt RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let signed: bool = t1.isSignedInteger();
        let s1: usize = rLhs.size;
        let s2: usize = rRhs.size;
        assert(s1 == s2, "ModInt expected LHS and RHS to be the same size");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        if (s1 == 1) {
            if (signed) *(start as &i8) = *(lhsStart as &i8) % *(rhsStart as &i8);
            else *(start as &u8) = *(lhsStart as &u8) % *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) *(start as &i16) = *(lhsStart as &i16) % *(rhsStart as &i16);
            else *(start as &u16) = *(lhsStart as &u16) % *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) *(start as &i32) = *(lhsStart as &i32) % *(rhsStart as &i32);
            else *(start as &u32) = *(lhsStart as &u32) % *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) *(start as &i64) = *(lhsStart as &i64) % *(rhsStart as &i64);
            else *(start as &u64) = *(lhsStart as &u64) % *(rhsStart as &u64);
        } else {
            unreachable("int mod with sus bitsize");
        }
        return dst;
    } else if (instr.kind == INSTR_FLOAT_DIV) {
        // OPT: Specialized 8bit, 16bit, etc. variations
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "FloatDiv LHS");
        let rRhs: InterpReg =  asInterp(rhs, "FloatDiv RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let s1: usize = rLhs.size;
        let s2: usize = rRhs.size;
        assert(s1 == s2, "FloatDiv expected LHS and RHS to be the same size");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        if (s1 == 4) {
            *(start as &f32) = *(lhsStart as &f32) / *(rhsStart as &f32);
        } else if (s1 == 8) {
            *(start as &f64) = *(lhsStart as &f64) / *(rhsStart as &f64);
        } else {
            unreachable("float div with sus bitsize");
        }
        return dst;
    } else if (instr.kind == INSTR_INT_CMP_EQ || instr.kind == INSTR_INT_CMP_NEQ) {
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "ICmpNeq/ICmpEq LHS");
        let rRhs: InterpReg =  asInterp(rhs, "ICmpNeq/ICmpEq RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let t2: &Type = irFunc.getRegister(instr.op1).typ;
        let s1: usize = t1.getSize();
        let s2: usize = t2.getSize();
        assert(s1 == s2, "ICmpNeq/ICmpEq got differently sized operands");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        let eq: bool = false;
        if (t1.isInteger() || t1.isPointer() || t1.isChar()) {
            let signed: bool = t1.isSignedInteger();
            if (s1 == 1) {
                if (signed) eq = *(lhsStart as &i8) == *(rhsStart as &i8);
                else eq = *(lhsStart as &u8) == *(rhsStart as &u8);
            } else if (s1 == 2) {
                if (signed) eq = *(lhsStart as &i16) == *(rhsStart as &i16);
                else eq = *(lhsStart as &u16) == *(rhsStart as &u16);
            } else if (s1 == 4) {
                if (signed) eq = *(lhsStart as &i32) == *(rhsStart as &i32);
                else eq = *(lhsStart as &u32) == *(rhsStart as &u32);
            } else if (s1 == 8) {
                if (signed) eq = *(lhsStart as &i64) == *(rhsStart as &i64);
                else eq = *(lhsStart as &u64) == *(rhsStart as &u64);
            } else {
                unreachable("int cmp with sus bitsize");
            }
        } else {
            unreachable("Interp ICmpEq/ICmpNeq on non-int");
        }
        let r: u8 = 0;
        if (eq) r = 1;
        if (instr.kind == INSTR_INT_CMP_NEQ) r = 1 - r;
        *start = r;
        return dst;
    } else if (instr.kind == INSTR_INT_CMP_GT || instr.kind == INSTR_INT_CMP_LTE) {
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "ICmpGt/ICmpLte LHS");
        let rRhs: InterpReg =  asInterp(rhs, "ICmpGt/ICmpLte RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let t2: &Type = irFunc.getRegister(instr.op1).typ;
        let s1: usize = t1.getSize();
        let s2: usize = t2.getSize();
        assert(s1 == s2, "ICmpGt/ICmpLte got differently sized operands");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        let gt: bool = false;
        if (t1.isInteger()) {
            let signed: bool = t1.isSignedInteger();
            if (s1 == 1) {
                if (signed) gt = *(lhsStart as &i8) > *(rhsStart as &i8);
                else gt = *(lhsStart as &u8) > *(rhsStart as &u8);
            } else if (s1 == 2) {
                if (signed) gt = *(lhsStart as &i16) > *(rhsStart as &i16);
                else gt = *(lhsStart as &u16) > *(rhsStart as &u16);
            } else if (s1 == 4) {
                if (signed) gt = *(lhsStart as &i32) > *(rhsStart as &i32);
                else gt = *(lhsStart as &u32) > *(rhsStart as &u32);
            } else if (s1 == 8) {
                if (signed) gt = *(lhsStart as &i64) > *(rhsStart as &i64);
                else gt = *(lhsStart as &u64) > *(rhsStart as &u64);
            } else {
                unreachable("int cmpgt with sus bitsize");
            }
        } else {
            unreachable("Interp ICmpGt/ICmpLte on non-int");
        }
        let r: u8 = 0;
        if (gt) r = 1;
        if (instr.kind == INSTR_INT_CMP_LTE) r = 1 - r;
        *start = r;
        return dst;
    } else if (instr.kind == INSTR_INT_CMP_LT || instr.kind == INSTR_INT_CMP_GTE) {
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "ICmpLt/ICmpGte LHS");
        let rRhs: InterpReg =  asInterp(rhs, "ICmpLt/ICmpGte RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let t2: &Type = irFunc.getRegister(instr.op1).typ;
        let s1: usize = t1.getSize();
        let s2: usize = t2.getSize();
        assert(s1 == s2, "ICmpLt/ICmpGte got differently sized operands");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        let gt: bool = false;
        if (t1.isInteger()) {
            let signed: bool = t1.isSignedInteger();
            if (s1 == 1) {
                if (signed) gt = *(lhsStart as &i8) < *(rhsStart as &i8);
                else gt = *(lhsStart as &u8) < *(rhsStart as &u8);
            } else if (s1 == 2) {
                if (signed) gt = *(lhsStart as &i16) < *(rhsStart as &i16);
                else gt = *(lhsStart as &u16) < *(rhsStart as &u16);
            } else if (s1 == 4) {
                if (signed) gt = *(lhsStart as &i32) < *(rhsStart as &i32);
                else gt = *(lhsStart as &u32) < *(rhsStart as &u32);
            } else if (s1 == 8) {
                if (signed) gt = *(lhsStart as &i64) < *(rhsStart as &i64);
                else gt = *(lhsStart as &u64) < *(rhsStart as &u64);
            } else {
                unreachable("int cmpgt with sus bitsize");
            }
        } else {
            unreachable("Interp ICmpGt/ICmpLte on non-int");
        }
        let r: u8 = 0;
        if (gt) r = 1;
        if (instr.kind == INSTR_INT_CMP_GTE) r = 1 - r;
        *start = r;
        return dst;
    } else if (instr.kind == INSTR_FLOAT_CMP_EQ || instr.kind == INSTR_FLOAT_CMP_NEQ) {
        let lhs: &RegValue = regs.at(instr.src.i);
        let rhs: &RegValue = regs.at(instr.op1.i);
        let rLhs: InterpReg =  asInterp(lhs, "FCmpNeq/FCmpEq LHS");
        let rRhs: InterpReg =  asInterp(rhs, "FCmpNeq/FCmpEq RHS");
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let t2: &Type = irFunc.getRegister(instr.op1).typ;
        let s1: usize = t1.getSize();
        let s2: usize = t2.getSize();
        assert(s1 == s2, "FCmpNeq/FCmpEq got differently sized operands");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 1,
        };
        let start: &u8 = getRegStackPointer(this, &dst);
        let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
        let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
        let eq: bool = false;
        if (t1.isFloat()) {
            if (s1 == 4) {
                eq = *(lhsStart as &f32) == *(rhsStart as &f32);
            } else if (s1 == 8) {
                eq = *(lhsStart as &f64) == *(rhsStart as &f64);
            } else {
                unreachable("float cmp with sus bitsize");
            }
        } else {
            unreachable("Interp FCmpEq/FCmpNeq on non-float");
        }
        let r: u8 = 0;
        if (eq) r = 1;
        if (instr.kind == INSTR_FLOAT_CMP_NEQ) r = 1 - r;
        *start = r;
        return dst;
    } else if (instr.kind == INSTR_LOGICAL_NOT) {
        // dst: dst,
        // src: src,
        let src: &RegValue = regs.at(instr.src.i);
        let rSrc: InterpReg = asInterp(src, "LNot SRC");
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let t1: &Type = irFunc.getRegister(instr.src).typ;
        let s1: usize = t1.getSize();
        assert(s1 == 1, "Idk");
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: s1,
        };
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let srcStart: &u8 = getRegStackPointer(this, &rSrc);
        let val: u8 = *srcStart;
        assert(val == 0 || val == 1, "Logical Not got non-zero non-one");
        *dstStart = 1 - val;
        return dst;
    } else if (instr.kind == INSTR_PTR_TO_INT) {
        // noop in interpreter
         return asInterp(regs.at(instr.src.i), "Interp PtrToInt");
    } else if (instr.kind == INSTR_INT_TO_PTR) {
        // noop in interpreter
         return asInterp(regs.at(instr.src.i), "Interp IntToPtr");
    } else if (instr.kind == INSTR_F32_TO_F64) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let src: InterpReg = asInterp(regs.at(instr.src.i), "Interp F32ToF64");
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 8,
        };
        let srcStart: &u8 = getRegStackPointer(this, &src);
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let v: f32 = *(srcStart as &f32);
        *(dstStart as &f64) = v as f64;
        return dst;
    } else if (instr.kind == INSTR_INT_TO_F32) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let src: InterpReg = asInterp(regs.at(instr.src.i), "Interp IntToF32");
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 4,
        };
        let srcStart: &u8 = getRegStackPointer(this, &src);
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let t: &Type = irFunc.getRegister(instr.src).typ;
        let signed: bool = t.isSignedInteger();
        let s: usize = t.getSize();
        let v: f32 = 0;
        if (s == 1) {
            if (signed) v = *(srcStart as &i8) as f32;
            else v = *(srcStart as &u8) as f32;
        } else if (s == 2) {
            if (signed) v = *(srcStart as &i16) as f32;
            else v = *(srcStart as &u16) as f32;
        } else if (s == 4) {
            if (signed) v = *(srcStart as &i32) as f32;
            else v = *(srcStart as &u32) as f32;
        } else if (s == 8) {
            if (signed) v = *(srcStart as &i64) as f32;
            else v = *(srcStart as &u64) as f32;
        } else {
            unreachable("Interp unexpected size in IntToF32");
        }
        *(dstStart as &f32) = v;
        return dst;
    } else if (instr.kind == INSTR_F64_TO_F32) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let src: InterpReg = asInterp(regs.at(instr.src.i), "Interp F64ToF32");
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: 4,
        };
        let srcStart: &u8 = getRegStackPointer(this, &src);
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let v: f64 = *(srcStart as &f64);
        *(dstStart as &f32) = v as f32;
        return dst;
    } else if (instr.kind == INSTR_F32_TO_INT) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let src: InterpReg = asInterp(regs.at(instr.src.i), "Interp F32ToInt");
        let size: usize = dstReg.typ.getSize();
        let signed: bool = dstReg.typ.isSignedInteger();
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: size,
        };
        let srcStart: &u8 = getRegStackPointer(this, &src);
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let v: f32 = *(srcStart as &f32);
        if (size == 1) {
            if (signed) *(dstStart as &i8) = v as i8;
            else *(dstStart as &u8) = v as u8;
        } else if (size == 2) {
            if (signed) *(dstStart as &i16) = v as i16;
            else *(dstStart as &u16) = v as u16;
        } else if (size == 4) {
            if (signed) *(dstStart as &i32) = v as i32;
            else *(dstStart as &u32) = v as u32;
        } else if (size == 8) {
            if (signed) *(dstStart as &i64) = v as i64;
            else *(dstStart as &u64) = v as u64;
        } else {
            unreachable("Interp F32ToInt: Exhaustive handling of destinations");
        }
        return dst;
    } else if (instr.kind == INSTR_F64_TO_INT) {
        let dstReg: &IRReg = irFunc.getRegister(instr.dst);
        let src: InterpReg = asInterp(regs.at(instr.src.i), "Interp F64ToInt");
        let size: usize = dstReg.typ.getSize();
        let signed: bool = dstReg.typ.isSignedInteger();
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: size,
        };
        let srcStart: &u8 = getRegStackPointer(this, &src);
        let dstStart: &u8 = getRegStackPointer(this, &dst);
        let v: f64 = *(srcStart as &f64);
        if (size == 1) {
            if (signed) *(dstStart as &i8) = v as i8;
            else *(dstStart as &u8) = v as u8;
        } else if (size == 2) {
            if (signed) *(dstStart as &i16) = v as i16;
            else *(dstStart as &u16) = v as u16;
        } else if (size == 4) {
            if (signed) *(dstStart as &i32) = v as i32;
            else *(dstStart as &u32) = v as u32;
        } else if (size == 8) {
            if (signed) *(dstStart as &i64) = v as i64;
            else *(dstStart as &u64) = v as u64;
        } else {
            unreachable("Interp F64ToInt: Exhaustive handling of destinations");
        }
        return dst;
    } else if (instr.kind == INSTR_FETCH_COMPTIME_VALUE) {
        // noop in interpreter
        if (instr.op1.i == 1) {
            // Global fetch
            let fReg = irFunc.getRegister(instr.dst);
            let ptr = getGlobalPointer(this, &asInterp(this.globalRegisters.at(instr.src.i), "Interp FetchComptimeValue"));
            let size = fReg.typ.getSize();
            let reg = InterpReg {
                offset: fReg.offset,
                size: size,
            };
            memcpy(getRegStackPointer(this, &reg), ptr, size);
            return reg;
        } else {
            // Local fetch
             return asInterp(regs.at(instr.src.i), "Interp FetchComptimeValue");
        }
    } else if (instr.kind == INSTR_GET_FIELD_PTR) {
        // dst: elem,
        // src: aggr,
        // op1: RegIndex { i: index },
        let fReg: &IRReg = irFunc.getRegister(instr.dst);
        let fAggr: InterpReg = asInterp(regs.at(instr.src.i), "IRInterp: GetFieldPtr");
        let t: &Type = irFunc.getRegister(instr.src).typ;
        assert(t.isStructPointer(), "IRInterp: GetFieldPtr got non-struct pointer");
        let u: &Type = t.getUnderlyingType(false);
        assert(u.isStruct());
        let decl: &ParsedStructDecl = structDecls.at(u.typeIndex);
        let offset: usize = 0;
        let size: usize = 0;
        decl.getFieldOffsetAndSize(instr.op1.i, &offset, &size);
        let reg: InterpReg = InterpReg {
            offset: fReg.offset,
            size: 8,
        };
        let regStackLoc: &u8 = getRegStackPointer(this, &reg);
        let ptr: &u8 = getRegStackPointer(this, &fAggr);
        *(regStackLoc as &usize) = *(ptr as &usize) + offset;
        return reg;
    } else {
        printf("INTERP %llu\n", instr.kind);
        todo_with_msg("unknown instr");
    }
}
func evaluateBlock(this: &IRInterp, blockID: &IRBlockID, irFunc: &IRFunc, regs: &RegValueList, forcedComptime: bool) -> bool {
    trace("IRInterp.evaluateBlock");
    let block: &IRBlock = irFunc.getBlockByID(*blockID);
    assert(block.instructions.length > 0, "Interp: Encountered empty block");
    for (let ip: usize = 0; ip < block.instructions.length; ip = ip + 1) {
        let instr: &IRInstr = block.instructions.at(ip);
        if (ip == block.instructions.length - 1) {
            if (PRINT_DEBUG) instr.dump();
            assert(instr.isTerminator(), "Interp: Unexpected non-terminator at the end of a block");
            if (instr.kind == INSTR_BR) {
                *blockID = IRBlockID { i: instr.dst.i };
                return true;
            } else if (instr.kind == INSTR_COND_BR) {
                let cond: &RegValue = &*regs.at(instr.src.i);
                let rCond: InterpReg =  asInterp(cond, "CondBr");
                assert(rCond.size == 1, "comptime CondBr expected single byte Cond");
                let condLoc: &u8 = getRegStackPointer(this, &rCond);
                let v: u8 = *condLoc;
                assert(v == 0 || v == 1, "condition is not 0 or 1");
                if (v == 1) {
                    *blockID = IRBlockID { i: instr.dst.i };
                } else {
                    *blockID = IRBlockID { i: instr.op1.i };
                }
                return true;
            } else if (instr.kind == INSTR_RETURN_EXPR) {
                let expr: &RegValue = &*regs.at(instr.src.i);
                let rExpr: InterpReg =  asInterp(expr, "ReturnExpr");
                pushArgument(this, getRegStackPointer(this, &rExpr), rExpr.size);
                return false;
            } else if (instr.kind == INSTR_RETURN_VOID) {
                return false;
            } else {
                unreachable("Interp: Exhaustive handling of Terminators");
            }
        } else {
            assert(!instr.isTerminator(), "Interp: Unexpected terminator in the middle of a block");
            *(regs.at(instr.dst.i)) = RegValue {
                isLLVM: false,
                regValue: evaluateSingle(this, irFunc, instr, regs, true),
                llvmValue: blank,
            };
        }
    }
    return false;
}
func evaluateCall(this: &IRInterp, span: Span, irFunc: &IRFunc, regs: &RegValueList) {
    trace("IRInterp.evaluateCall");
    let funcSize: usize = irFunc.getRegisterSizeInBytes();
    pushRegisterStack(this, span, funcSize);
    let blockID: IRBlockID = IRBlockID { i: 0 };
    while (evaluateBlock(this, &blockID, irFunc, regs, true)) {
    }
    popRegisterStack(this, span, funcSize);
    return;
}
func pushRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.pushRegisterStack");
    let new: &u8 = this.regStackBase + size;
    if (new > this.regStackStart + REG_STACK_SIZE) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s Register Stack Overflow in the comptime interpreter.\n", loc.chars(), FATAL_STR);
        fprintf(stderr, "%s: %s Tried to reserve %llu byte(s).\n", loc.chars(), FATAL_STR, size);
        loc.drop();
        exit(2);
    }
    this.regStackBase = new;
}
func popRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.popRegisterStack");
    let new: &u8 = this.regStackBase - size;
    if (new < this.regStackStart) {
        let loc = toString(&span);
        fprintf(stderr, "%s: %s Register Stack Underflow in the comptime interpreter.\n", loc.chars(), FATAL_STR);
        loc.drop();
        exit(2);
    }
    this.regStackBase = new;
    assert(this.regStackBase >= this.globalRegBase, "Register Stack overwrote global stack");
}

func newIRInterpreter(irGen: &IRGen) -> IRInterp {
    let regStack: &u8 = malloc(REG_STACK_SIZE);
    assert(regStack != null, "Could not prepare IRInterp.regStack");
    let realStack: &u8 = malloc(STACK_SIZE);
    assert(realStack != null, "Could not prepare IRInterp.realStack");
    let argStack: &u8 = malloc(640000);
    assert(argStack != null, "Could not prepare IRInterp.argStack");
    return IRInterp {
        irGen: irGen,
        globalRegisters: null,
        regStackStart: regStack,
        globalRegBase: regStack,
        regStackBase: regStack,
        realStackStart: realStack,
        realStackPointer: realStack,
        realStackBase: realStack,
        argStack: argStack,
        argStackLength: 0,
        argStackCapacity: 640000,
    };
}
