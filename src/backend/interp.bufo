import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "asm.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/hashmaps.bufo";
import "../util/arena.bufo";
import "../frontend/nodes.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./irgen.bufo";
import "./codegen_llvm.bufo";
import "./assembler.bufo";
import "./byte_buffer.bufo";

@os(WINDOWS) import "winapi/structs.bufo";
@os(WINDOWS) import "winapi/functions.bufo";

@os(LINUX) import "posix/functions.bufo";

struct CallStackInfo {
    span: Span;
    name: String;
}
struct CallStack {
    elements: &CallStackInfo;
    length: usize;
    capacity: usize;
}
func push(this: &CallStack, element: CallStackInfo) {
    if (this.length >= this.capacity) {
        let newCap: usize = this.capacity * 2;
        if (newCap == 0) newCap = 32;
        this.elements = C::realloc(this.elements, newCap * sizeof CallStackInfo);
        assert(this.elements != null, "Could not allocate memory in CallStack.push");
        this.capacity = newCap;
    }
    this.elements[this.length] = element;
    this.length = this.length + 1;
}
func at(this: &CallStack, index: usize) -> &CallStackInfo {
    assert(index < this.length, "Out of bounds access in CallStack.at");
    assert(this.elements != null, "Element pointer is NULL in CallStack.at");
    return &this.elements[index];
}
func pop(this: &CallStack) -> &CallStackInfo {
    let l: &CallStackInfo = last(this);
    this.length = this.length - 1;
    return l;
}
func last(this: &CallStack) -> &CallStackInfo {
    assert(this.length != 0, "Called last() on empty CallStack");
    return at(this, this.length - 1);
}

comptime REG_STACK_SIZE: usize = 16777216;
comptime STACK_SIZE: usize = 4194304;
struct IRInterp {
    irGen: &IRGen;
    regStackStart: &u8;
    globalRegisters: &RegValueList;
    globalRegBase: &u8;
    regStackBase: &u8;
    realStackStart: &u8;
    realStackPointer: &u8;
    realStackBase: &u8;
    argStack: &u8;
    argStackLength: usize;
    argStackCapacity: usize;
    callStack: CallStack;
}
func dumpRegisterStack(this: &IRInterp, bytes: usize) {
    let cols: usize = 4;
    for (let i: usize = 0; i < bytes; i = i + 1) {
        if (i > 0 && i % (8 * cols) == 0) C::printf("\n");
        C::printf("%2hhX", *(this.regStackStart + i));
    }
    C::printf("\n");
}
func getGlobalPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    return this.globalRegBase - reg.offset - reg.size;
}
func getRegStackPointer(this: &IRInterp, reg: &InterpReg) -> &u8 {
    let ptr: &u8 = this.regStackBase - reg.offset - reg.size;
    assert(ptr < this.regStackStart + REG_STACK_SIZE, "Stack Overflow in IRInterp.getRegStackPointer");
    assert(ptr >= this.regStackStart, "Stack Underflow in IRInterp.getRegStackPointer");
    return ptr;
}
func advanceRealStack(this: &IRInterp, span: Span, size: usize) -> &u8 {
    let _p: &u8 = this.realStackPointer;
    let new: &u8 = this.realStackPointer + size;
    if (new >= this.realStackStart + STACK_SIZE) {
        let loc = toString(&span);
        C::fprintf(stderr, "%s: %s: Stack Overflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        C::fprintf(stderr, "%s: %s: Last allocation tried to allocate %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        C::exit(2);
    }
    this.realStackPointer = new;
    return _p;
}
func pushArgument(this: &IRInterp, span: Span, start: &u8, size: usize) {
    trace("IRInterp.pushArgument");
    let new = this.argStackLength + size;
    if (new >= this.argStackCapacity) {
        let loc = toString(&span);
        C::fprintf(stderr, "%s: %s: Argument Stack Overflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        C::fprintf(stderr, "%s: %s: Last function call tried to push %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        C::exit(2);
    }
    C::memcpy(this.argStack + this.argStackLength, start, size);
    this.argStackLength = new;
}
func popArgument(this: &IRInterp, span: Span, start: &u8, size: usize) {
    trace("IRInterp.popArgument");
    let new = this.argStackLength - size;
    if (this.argStackLength < size) {
        let loc = toString(&span);
        C::fprintf(stderr, "%s: %s: Argument Stack Underflow in the comptime interpreter.\n", loc.buffer, ERR_STR);
        C::fprintf(stderr, "%s: %s: Last function call tried to pop %llu byte(s).\n", loc.buffer, NOTE_STR, size);
        drop(&loc);
        C::exit(2);
    }
    this.argStackLength = new;
    C::memcpy(start, this.argStack + this.argStackLength, size);
}

let instrFns = [
    evaluateNotImplemented,     // INSTR_INVALID
    evaluateAlloca,             // INSTR_ALLOCA
    evaluateGetParam,           // INSTR_GET_PARAM
    evaluateStore,              // INSTR_STORE
    evaluateNotImplemented,     // INSTR_FETCH_GLOBAL_PTR
    evaluateFetchGlobalValue,   // INSTR_FETCH_GLOBAL_VALUE
    evaluateFetchComptimeValue, // INSTR_FETCH_COMPTIME_VALUE
    evaluateLoadFunctionPtr,    // INSTR_LOAD_FUNCTION_PTR
    evaluateLoad,               // INSTR_LOAD
    evaluateMove,               // INSTR_MOVE
    evaluateInstrCall,          // INSTR_CALL
    evaluateReturnExpr,         // INSTR_RETURN_EXPR
    evaluateReturnVoid,         // INSTR_RETURN_VOID
    evaluateLoadString,         // INSTR_LOAD_STRING
    evaluateLoadBool,           // INSTR_LOAD_BOOL
    evaluateLoadI8,             // INSTR_LOAD_I8
    evaluateLoadU8,             // INSTR_LOAD_U8
    evaluateLoadI16,            // INSTR_LOAD_I16
    evaluateLoadU16,            // INSTR_LOAD_U16
    evaluateLoadI32,            // INSTR_LOAD_I32
    evaluateLoadU32,            // INSTR_LOAD_U32
    evaluateNotImplemented,     // INSTR_LOAD_I64
    evaluateLoadU64,            // INSTR_LOAD_U64
    evaluateLoadNull,           // INSTR_LOAD_NULL
    evaluateLoadF32,            // INSTR_LOAD_F32
    evaluateLoadF64,            // INSTR_LOAD_F64
    evaluateLoadBlank,          // INSTR_LOAD_BLANK
    evaluateCondBr,             // INSTR_COND_BR
    evaluateBr,                 // INSTR_BR
    evaluateIntAdd,             // INSTR_INT_ADD
    evaluateIntSub,             // INSTR_INT_SUB
    evaluateIntMul,             // INSTR_INT_MUL
    evaluateNotImplemented,     // INSTR_INT_DIV
    evaluateIntMod,             // INSTR_INT_MOD
    evaluateIntCmpEqAndNeq,     // INSTR_INT_CMP_EQ
    evaluateIntCmpEqAndNeq,     // INSTR_INT_CMP_NEQ
    evaluateIntCmpGtAndLte,     // INSTR_INT_CMP_GT
    evaluateIntCmpLtAndGte,     // INSTR_INT_CMP_GTE
    evaluateIntCmpLtAndGte,     // INSTR_INT_CMP_LT
    evaluateIntCmpGtAndLte,     // INSTR_INT_CMP_LTE
    evaluateFloatAdd,           // INSTR_FLOAT_ADD
    evaluateFloatSub,           // INSTR_FLOAT_SUB
    evaluateFloatMul,           // INSTR_FLOAT_MUL
    evaluateFloatDiv,           // INSTR_FLOAT_DIV
    evaluateFloatMod,           // INSTR_FLOAT_MOD
    evaluateFloatCmpEqAndNeq,   // INSTR_FLOAT_CMP_EQ
    evaluateFloatCmpEqAndNeq,   // INSTR_FLOAT_CMP_NEQ
    evaluateFloatCmpGtAndLte,   // INSTR_FLOAT_CMP_GT
    evaluateFloatCmpLtAndGte,   // INSTR_FLOAT_CMP_GTE
    evaluateFloatCmpLtAndGte,   // INSTR_FLOAT_CMP_LT
    evaluateFloatCmpGtAndLte,   // INSTR_FLOAT_CMP_LTE
    evaluateLogicalNot,         // INSTR_LOGICAL_NOT
    evaluateLogicalAnd,         // INSTR_LOGICAL_AND
    evaluateLogicalOr,          // INSTR_LOGICAL_OR
    evaluateBitwiseAnd,         // INSTR_BITWISE_AND
    evaluateBitwiseOr,          // INSTR_BITWISE_OR
    evaluateNotImplemented,     // INSTR_BITWISE_XOR
    evaluateInsertValue,        // INSTR_INSERT_VALUE
    evaluateIntSignExtend,      // INSTR_INT_SIGN_EXTEND
    evaluateIntZeroExtend,      // INSTR_INT_ZERO_EXTEND
    evaluateIntTruncate,        // INSTR_INT_TRUNCATE
    evaluateIntToF32,           // INSTR_INT_TO_F32
    evaluateNotImplemented,     // INSTR_INT_TO_F64
    evaluateF32ToInt,           // INSTR_F32_TO_INT
    evaluateF64ToInt,           // INSTR_F64_TO_INT
    evaluateF32ToF64,           // INSTR_F32_TO_F64
    evaluateF64ToF32,           // INSTR_F64_TO_F32
    evaluateCreateArray,        // INSTR_CREATE_ARRAY
    evaluateCreateStruct,       // INSTR_CREATE_STRUCT
    evaluateCreateUnion,        // INSTR_CREATE_UNION
    evaluatePtrToInt,           // INSTR_PTR_TO_INT
    evaluateIntToPtr,           // INSTR_INT_TO_PTR
    evaluateGetFieldPtr,        // INSTR_GET_FIELD_PTR
    evaluateGetElementPtr,      // INSTR_GET_ELEMENT_PTR
    evaluateUnreachable,        // INSTR_UNREACHABLE
    evaluateUnterminated,       // INSTR_UNTERMINATED
    evaluateMemcpy,             // INSTR_MEMCPY
    evaluateEmitAssembly,       // INSTR_EMIT_ASSEMBLY
    evaluateIntoIRValue,        // INSTR_INTO_IR_VALUE
];
func evaluateNotImplemented(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    dumpInstructions(irFunc);
    let loc = toString(&instr.span);
    C::printf("%s: ", loc.buffer);
    dump(instr);
    dumpCallStack(this, &loc);
    unreachable("Not implemented");
}
func evaluateAlloca(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateAlloca");
    // dst: dst,
    // src: RegIndex { i: size },
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "Alloca got non-pointer");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    *(getRegStackPointer(this, &reg) as &usize) = advanceRealStack(this, instr.span, instr.src.i) as usize;
    return reg;
}
func evaluateGetParam(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateGetParam");
    let size: usize = instr.op1.i;
    assert(size <= 8, "Interp: Expected small size for GetParam");
    let dst: InterpReg = InterpReg {
        offset: getRegister(irFunc, instr.dst).offset,
        size: size,
    };
    popArgument(this, instr.span, getRegStackPointer(this, &dst), size);
    return dst;
}
func evaluateStore(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateStore");
    // dst: ptr,
    // src: val,
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    assert(isPointer(dst.typ), "Store expected Ptr Dst");
    let size = getSize(dst.typ);
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: size,
    };
    let srcReg: InterpReg = asInterp(src, "Store src");
    let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
    let dstLoc: &u8 = *(getRegStackPointer(this, &dstReg) as &usize) as &u8;
    C::memcpy(dstLoc, srcLoc, srcReg.size);
    return dstReg;
}
func evaluateFetchGlobalValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFetchGlobalValue");
    let fReg = getRegister(irFunc, instr.dst);
    let ptr = getGlobalPointer(this, &asInterp(at(this.globalRegisters, instr.src.i), "Interp FetchGlobalValue"));
    let size = getSize(fReg.typ);
    let reg = InterpReg {
        offset: fReg.offset,
        size: size,
    };
    C::memcpy(getRegStackPointer(this, &reg), ptr, size);
    return reg;
}
func evaluateFetchComptimeValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFetchComptimeValue");
    if (instr.op1.i == 1) {
        // Global fetch
        let fReg = getRegister(irFunc, instr.dst);
        let ptr = getGlobalPointer(this, &asInterp(at(this.globalRegisters, instr.src.i), "Interp FetchComptimeValue"));
        let size = getSize(fReg.typ);
        let reg = InterpReg {
            offset: fReg.offset,
            size: size,
        };
        C::memcpy(getRegStackPointer(this, &reg), ptr, size);
        return reg;
    } else {
        // Local fetch
        // noop in interpreter
        return asInterp(at(regs, instr.src.i), "Interp FetchComptimeValue");
    }
}
func evaluateLoadFunctionPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadFunctionPtr");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFunction(fReg.typ), "LoadFunctionPtr got non-function");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}
func evaluateLoad(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoad");
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    let srcReg: InterpReg =  asInterp(src, "Load src");
    assert(srcReg.size == 8, "Load expected Ptr Src");
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: getSize(dst.typ),
    };
    let srcLoc: &u8 = *(getRegStackPointer(this, &srcReg) as &usize) as &u8;
    let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
    C::memcpy(dstLoc, srcLoc, dstReg.size);
    return dstReg;
}
func evaluateMove(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateMove");
    let dst: &IRReg = getRegister(irFunc, instr.dst);
    let src: &RegValue = at(regs, instr.src.i);
    let srcReg: InterpReg =  asInterp(src, "Interp Move src");
    let dstReg: InterpReg = InterpReg {
        offset: dst.offset,
        size: getSize(dst.typ),
    };
    let srcLoc: &u8 = getRegStackPointer(this, &srcReg);
    let dstLoc: &u8 = getRegStackPointer(this, &dstReg);
    C::memcpy(dstLoc, srcLoc, dstReg.size);
    return dstReg;
}
func evaluateInstrCall(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateInstrCall");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let id = *(getRegStackPointer(this, &asInterp(at(regs, instr.src.i), "Call")) as &usize);
    let calledFunc: &IRFunc = at(&this.irGen.functions, id);
    let f = at(&funcDecls, calledFunc.originalID);
    if (isExtern(f)) {
        if (!isNull(f.dllHandle)) {
            let fun = compileFunctionCall(this, irFunc, calledFunc, instr, f.dllHandle.handle.ptr, regs);
            let retType: &Type = null;
            match (getType(&f.typeState)) {
                &Type::Func(_, _ret, _) => { retType = _ret; }
                _ => { unreachable("IRGen.evaluateInstrCall: Expected function type"); }
            }
            let val = fun.run();
            let size: usize = getSize(dstReg.typ);
            let dst: InterpReg = InterpReg {
                offset: dstReg.offset,
                size: size,
            };
            if (getSize(retType) == 0) {
                // noop
            } else if (getSize(retType) <= 1) {
                *(getRegStackPointer(this, &dst) as &u8) = *((&val) as &u8);
            } else if (getSize(retType) <= 2) {
                *(getRegStackPointer(this, &dst) as &u16) = *((&val) as &u16);
            } else if (getSize(retType) <= 4) {
                if (isFloat(retType)) {
                    *(getRegStackPointer(this, &dst) as &f32) = *((&val) as &f32);
                } else {
                    *(getRegStackPointer(this, &dst) as &u32) = *((&val) as &u32);
                }
            } else if (getSize(retType) <= 8) {
                if (isFloat(retType)) {
                    *(getRegStackPointer(this, &dst) as &f64) = *((&val) as &f64);
                } else {
                    *(getRegStackPointer(this, &dst) as &u64) = *((&val) as &u64);
                }
            } else {
                // handled by IR generator
            }
            free(fun);
            return dst;
        } else {
            let loc = toString(&instr.span);
            C::fprintf(stderr, "%s: %s: Can not call external function `%s` at compile time.\n", loc.buffer, ERR_STR, calledFunc.name.buffer);
            if (f.dllHandle == dllNotFound()) {
                let m = getParentModule(f);
                let _loc = toString(&m.span);
                let cfg = getConfigs(m);
                if (cfg.length == 0) {
                    C::fprintf(stderr, "%s: %s: No configuration found!\n", _loc.buffer, NOTE_STR);
                } else {
                    C::fprintf(stderr, "%s: %s: Could not load any of the libraries specified in the module configuration.\n", loc.buffer, NOTE_STR);
                    C::fprintf(stderr, "%s: %s: Module declared here.\n", _loc.buffer, NOTE_STR);
                    for (let i: usize = 0; i < cfg.length; i = i + 1) {
                        let tli = at(&topLevelItems, *at(&cfg, i));
                        assert(tli.kind == TLI_CONFIG);
                        drop(&_loc);
                        _loc = toString(&tli.span);
                        C::fprintf(stderr, "%s: %s: Module configuration declared here.\n", _loc.buffer, NOTE_STR);
                    }
                }
                drop(&_loc);
            } else if (f.dllHandle == dllNoSuchFunction()) {
                let m = getParentModule(f);
                let _loc = toString(&m.span);
                let cfg = getConfigs(m);
                if (cfg.length == 0) {
                    C::fprintf(stderr, "%s: %s: No configuration found!\n", _loc.buffer, NOTE_STR);
                } else {
                    let _fnLoc = toString(&f.span);
                    C::fprintf(stderr, "%s: %s: Could not find the function in any of the specified libraries.\n", loc.buffer, ERR_STR);
                    C::fprintf(stderr, "%s: %s: Function declared here.\n", _fnLoc.buffer, NOTE_STR);
                    C::fprintf(stderr, "%s: %s: Module declared here.\n", _loc.buffer, NOTE_STR);
                    for (let i: usize = 0; i < cfg.length; i = i + 1) {
                        let tli = at(&topLevelItems, *at(&cfg, i));
                        assert(tli.kind == TLI_CONFIG);
                        drop(&_loc);
                        _loc = toString(&tli.span);
                        C::fprintf(stderr, "%s: %s: Module configuration declared here.\n", _loc.buffer, NOTE_STR);
                    }
                    drop(&_fnLoc);
                }
                drop(&_loc);
            } else if (f.dllHandle == null) {
                // REVIEW: What do we report here?
            } else {
                unreachable("actually null-ptr");
            }
            drop(&loc);
            C::exit(1);
        }
    } else {
        let argSize: usize = this.argStackLength;
        let stackStart: &u8 = this.realStackStart;
        let regStackStart: &u8 = this.regStackStart;
        for (let _i: usize = 0; _i < instr.args.length; _i = _i + 1) {
            let i: usize = instr.args.length - _i - 1;
            let reg: &RegValue = at(regs, at(&instr.args, i).i);
            let arg: InterpReg = asInterp(reg, "call arg");
            pushArgument(this, instr.span, getRegStackPointer(this, &arg), arg.size);
        }
        let callRegs: RegValueList = blank;
        initBlank(&callRegs, calledFunc.registers.length);
        evaluateCall(this, instr.span, calledFunc, &callRegs);
        let size: usize = getSize(dstReg.typ);
        let dst: InterpReg = InterpReg {
            offset: dstReg.offset,
            size: size,
        };
        popArgument(this, instr.span, getRegStackPointer(this, &dst), size);
        assert(argSize == this.argStackLength, "Imbalanced argument stack after calling IRInterp.evaluateCall");
        assert(stackStart == this.realStackStart, "Imbalanced real stack after calling IRInterp.evaluateCall");
        assert(regStackStart == this.regStackStart, "Imbalanced reg stack after calling IRInterp.evaluateCall");
        return dst;
    }
}
func evaluateReturnExpr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateReturnExpr");
    let expr: &RegValue = at(regs, instr.src.i);
    let rExpr: InterpReg =  asInterp(expr, "ReturnExpr");
    pushArgument(this, instr.span, getRegStackPointer(this, &rExpr), rExpr.size);
    return blank;
}

func evaluateReturnVoid(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateReturnVoid");
    return blank;
}

func evaluateLoadString(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadString");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "LoadString expected Ptr");
    assert(isChar(getUnderlyingType(fReg.typ, false)), "LoadString expected Ptr to Char");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}
func evaluateLoadBool(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadBool");
    let isTrue: u8 = instr.src.i as u8;
    assert(isTrue == 0 || isTrue == 1, "LoadBool expected 0 or 1");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u8) = isTrue;
    return reg;
}

func evaluateLoadI8(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI8");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI8 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i8) = instr.src.i as i8;
    return reg;
}
func evaluateLoadU8(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU8");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ) || isChar(fReg.typ), "LoadU8 got non-int non-char");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 1,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u8) = instr.src.i as u8;
    return reg;
}
func evaluateLoadI16(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI16");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI16 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 2,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i16) = instr.src.i as i16;
    return reg;
}

func evaluateLoadU16(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU16");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU16 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 2,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u16) = instr.src.i as u16;
    return reg;
}
func evaluateLoadI32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadI32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadI32 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &i32) = instr.src.i as i32;
    return reg;
}
func evaluateLoadU32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU32 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &u32) = instr.src.i as u32;
    return reg;
}
func evaluateLoadU64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadU64");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isInteger(fReg.typ), "LoadU64 got non-int");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = instr.src.i;
    return reg;
}

func evaluateLoadNull(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadNull");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isPointer(fReg.typ), "LoadNull got non-ptr");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &usize) = 0;
    return reg;
}
func evaluateLoadF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadF32");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFloat(fReg.typ), "LoadF32 got non-float");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 4,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &f32) = *(&instr.src.i as &f32);
    return reg;
}

func evaluateLoadF64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadF64");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    assert(isFloat(fReg.typ), "LoadF64 got non-float");
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    *(regStackLoc as &f64) = *(&instr.src.i as &f64);
    return reg;
}

func evaluateLoadBlank(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLoadBlank");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    C::memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateCondBr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCondBr");
    let cond: &RegValue = at(regs, instr.src.i);
    let rCond: InterpReg = asInterp(cond, "CondBr");
    assert(rCond.size == 1, "comptime CondBr expected single byte Cond");
    let condLoc: &u8 = getRegStackPointer(this, &rCond);
    let v: u8 = *condLoc;
    assert(v == 0 || v == 1, "condition is not 0 or 1");
    let id: usize = 0;
    if (v == 1) {
        id = instr.dst.i;
    } else {
        id = instr.op1.i;
    }
    return InterpReg { offset: id, size: 1 };
}
func evaluateBr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateBr");
    return InterpReg { offset: instr.dst.i, size: 1 };
}
func evaluateIntAdd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntAdd");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg = asInterp(lhs, "AddInt LHS");
    let rRhs: InterpReg = asInterp(rhs, "AddInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "AddInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) + *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) + *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) + *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) + *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) + *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) + *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) + *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) + *(rhsStart as &u64);
    } else {
        unreachable("int add with sus bitsize");
    }
    return dst;
}
func evaluateIntSub(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntSub");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "SubInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "SubInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "SubInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) - *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) - *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) - *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) - *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) - *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) - *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) - *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) - *(rhsStart as &u64);
    } else {
        unreachable("int add with sus bitsize");
    }
    return dst;
}

func evaluateIntMul(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntMul");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "MulInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "MulInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "MulInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) * *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) * *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) * *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) * *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) * *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) * *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) * *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) * *(rhsStart as &u64);
    } else {
        unreachable("int mul with sus bitsize");
    }
    return dst;
}
func evaluateIntMod(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntMod");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ModInt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ModInt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t1);
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "ModInt expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 1) {
        if (signed) *(start as &i8) = *(lhsStart as &i8) % *(rhsStart as &i8);
        else *(start as &u8) = *(lhsStart as &u8) % *(rhsStart as &u8);
    } else if (s1 == 2) {
        if (signed) *(start as &i16) = *(lhsStart as &i16) % *(rhsStart as &i16);
        else *(start as &u16) = *(lhsStart as &u16) % *(rhsStart as &u16);
    } else if (s1 == 4) {
        if (signed) *(start as &i32) = *(lhsStart as &i32) % *(rhsStart as &i32);
        else *(start as &u32) = *(lhsStart as &u32) % *(rhsStart as &u32);
    } else if (s1 == 8) {
        if (signed) *(start as &i64) = *(lhsStart as &i64) % *(rhsStart as &i64);
        else *(start as &u64) = *(lhsStart as &u64) % *(rhsStart as &u64);
    } else {
        unreachable("int mod with sus bitsize");
    }
    return dst;
}
func evaluateIntCmpEqAndNeq(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpEqAndNeq");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpNeq/ICmpEq LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpNeq/ICmpEq RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpNeq/ICmpEq got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isInteger(t1) || isPointer(t1) || isChar(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) eq = *(lhsStart as &i8) == *(rhsStart as &i8);
            else eq = *(lhsStart as &u8) == *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) eq = *(lhsStart as &i16) == *(rhsStart as &i16);
            else eq = *(lhsStart as &u16) == *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) eq = *(lhsStart as &i32) == *(rhsStart as &i32);
            else eq = *(lhsStart as &u32) == *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) eq = *(lhsStart as &i64) == *(rhsStart as &i64);
            else eq = *(lhsStart as &u64) == *(rhsStart as &u64);
        } else {
            unreachable("int cmp with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpEq/ICmpNeq on non-int");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_INT_CMP_NEQ) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateIntCmpGtAndLte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpGtAndLte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpGt/ICmpLte LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpGt/ICmpLte RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpGt/ICmpLte got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let gt: bool = false;
    if (isInteger(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) gt = *(lhsStart as &i8) > *(rhsStart as &i8);
            else gt = *(lhsStart as &u8) > *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) gt = *(lhsStart as &i16) > *(rhsStart as &i16);
            else gt = *(lhsStart as &u16) > *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) gt = *(lhsStart as &i32) > *(rhsStart as &i32);
            else gt = *(lhsStart as &u32) > *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) gt = *(lhsStart as &i64) > *(rhsStart as &i64);
            else gt = *(lhsStart as &u64) > *(rhsStart as &u64);
        } else {
            unreachable("int cmpgt with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpGt/ICmpLte on non-int");
    }
    let r: u8 = 0;
    if (gt) r = 1;
    if (instr.kind == INSTR_INT_CMP_LTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateIntCmpLtAndGte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntCmpLtAndGte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "ICmpLt/ICmpGte LHS");
    let rRhs: InterpReg =  asInterp(rhs, "ICmpLt/ICmpGte RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "ICmpLt/ICmpGte got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let gt: bool = false;
    if (isInteger(t1)) {
        let signed: bool = isSignedInteger(t1);
        if (s1 == 1) {
            if (signed) gt = *(lhsStart as &i8) < *(rhsStart as &i8);
            else gt = *(lhsStart as &u8) < *(rhsStart as &u8);
        } else if (s1 == 2) {
            if (signed) gt = *(lhsStart as &i16) < *(rhsStart as &i16);
            else gt = *(lhsStart as &u16) < *(rhsStart as &u16);
        } else if (s1 == 4) {
            if (signed) gt = *(lhsStart as &i32) < *(rhsStart as &i32);
            else gt = *(lhsStart as &u32) < *(rhsStart as &u32);
        } else if (s1 == 8) {
            if (signed) gt = *(lhsStart as &i64) < *(rhsStart as &i64);
            else gt = *(lhsStart as &u64) < *(rhsStart as &u64);
        } else {
            unreachable("int cmpgt with sus bitsize");
        }
    } else {
        unreachable("Interp ICmpGt/ICmpLte on non-int");
    }
    let r: u8 = 0;
    if (gt) r = 1;
    if (instr.kind == INSTR_INT_CMP_GTE) r = 1 - r;
    *start = r;
    return dst;
}

func evaluateFloatAdd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatAdd");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatAdd LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatAdd RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatAdd expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) + *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) + *(rhsStart as &f64);
    } else {
        unreachable("float add with sus bitsize");
    }
    return dst;
}
func evaluateFloatSub(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatSub");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatSub LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatSub RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatSub expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) - *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) - *(rhsStart as &f64);
    } else {
        unreachable("float sub with sus bitsize");
    }
    return dst;
}
func evaluateFloatMul(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatMul");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatMul LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatMul RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatMul expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) * *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) * *(rhsStart as &f64);
    } else {
        unreachable("float mul with sus bitsize");
    }
    return dst;
}
func evaluateFloatDiv(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatDiv");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatDiv LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatDiv RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatDiv expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) / *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) / *(rhsStart as &f64);
    } else {
        unreachable("float div with sus bitsize");
    }
    return dst;
}
func evaluateFloatMod(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatMod");
    // OPT: Specialized 8bit, 16bit, etc. variations
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FloatMod LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FloatMod RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = rLhs.size;
    let s2: usize = rRhs.size;
    assert(s1 == s2, "FloatMod expected LHS and RHS to be the same size");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    if (s1 == 4) {
        *(start as &f32) = *(lhsStart as &f32) % *(rhsStart as &f32);
    } else if (s1 == 8) {
        *(start as &f64) = *(lhsStart as &f64) % *(rhsStart as &f64);
    } else {
        unreachable("float mod with sus bitsize");
    }
    return dst;
}
func evaluateFloatCmpEqAndNeq(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpEqAndNeq");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpNeq/FCmpEq LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpNeq/FCmpEq RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpNeq/FCmpEq got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) == *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) == *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpEq/FCmpNeq on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_NEQ) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateFloatCmpGtAndLte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpGtAndLte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpLte/FCmpGt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpLte/FCmpGt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpLte/FCmpGt got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) > *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) > *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpGt/FCmpLte on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_LTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateFloatCmpLtAndGte(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateFloatCmpLtAndGte");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "FCmpGte/FCmpLt LHS");
    let rRhs: InterpReg =  asInterp(rhs, "FCmpGte/FCmpLt RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "FCmpGte/FCmpLt got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let start: &u8 = getRegStackPointer(this, &dst);
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let eq: bool = false;
    if (isFloat(t1)) {
        if (s1 == 4) {
            eq = *(lhsStart as &f32) < *(rhsStart as &f32);
        } else if (s1 == 8) {
            eq = *(lhsStart as &f64) < *(rhsStart as &f64);
        } else {
            unreachable("float cmp with sus bitsize");
        }
    } else {
        unreachable("Interp FCmpLt/FCmpGte on non-float");
    }
    let r: u8 = 0;
    if (eq) r = 1;
    if (instr.kind == INSTR_FLOAT_CMP_GTE) r = 1 - r;
    *start = r;
    return dst;
}
func evaluateLogicalNot(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalNot");
    let src: &RegValue = at(regs, instr.src.i);
    let rSrc: InterpReg = asInterp(src, "LNot SRC");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let s1: usize = getSize(t1);
    assert(s1 == 1, "Idk");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let srcStart: &u8 = getRegStackPointer(this, &rSrc);
    let val: u8 = *srcStart;
    assert(val == 0 || val == 1, "Logical Not got non-zero non-one");
    *dstStart = 1 - val;
    return dst;
}
func evaluateLogicalAnd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalAnd");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "LAnd LHS");
    let rRhs: InterpReg =  asInterp(rhs, "LAnd RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "LAnd got differently sized operands");
    assert(s1 == 1, "Idk");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let l = *lhsStart;
    let r = *rhsStart;
    *dstStart = 0;
    if (l == 1 && r == 1) {
        *dstStart = 1;
    }
    return dst;
}
func evaluateLogicalOr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateLogicalOr");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "LOr LHS");
    let rRhs: InterpReg =  asInterp(rhs, "LOr RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "LOr got differently sized operands");
    assert(s1 == 1, "Idk");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let l = *lhsStart;
    let r = *rhsStart;
    *dstStart = 0;
    if (l == 1 || r == 1) {
        *dstStart = 1;
    }
    return dst;
}
func evaluateBitwiseAnd(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateBitwiseAnd");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "BAnd LHS");
    let rRhs: InterpReg =  asInterp(rhs, "BAnd RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "BAnd got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    if (s1 == 1) {
        *(dstStart as &u8) = *(lhsStart as &u8) & *(rhsStart as &u8);
    } else if (s1 == 2) {
        *(dstStart as &u16) = *(lhsStart as &u16) & *(rhsStart as &u16);
    } else if (s1 == 4) {
        *(dstStart as &u32) = *(lhsStart as &u32) & *(rhsStart as &u32);
    } else if (s1 == 8) {
        *(dstStart as &u64) = *(lhsStart as &u64) & *(rhsStart as &u64);
    } else unreachable("Exhaustive handling of types in BAnd");
    return dst;
}
func evaluateBitwiseOr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateBitwiseOr");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "BOr LHS");
    let rRhs: InterpReg =  asInterp(rhs, "BOr RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "BOr got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    if (s1 == 1) {
        *(dstStart as &u8) = *(lhsStart as &u8) | *(rhsStart as &u8);
    } else if (s1 == 2) {
        *(dstStart as &u16) = *(lhsStart as &u16) | *(rhsStart as &u16);
    } else if (s1 == 4) {
        *(dstStart as &u32) = *(lhsStart as &u32) | *(rhsStart as &u32);
    } else if (s1 == 8) {
        *(dstStart as &u64) = *(lhsStart as &u64) | *(rhsStart as &u64);
    } else unreachable("Exhaustive handling of types in BOr");
    return dst;
}
func evaluateBitwiseXor(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateBitwiseXor");
    let lhs: &RegValue = at(regs, instr.src.i);
    let rhs: &RegValue = at(regs, instr.op1.i);
    let rLhs: InterpReg =  asInterp(lhs, "BXor LHS");
    let rRhs: InterpReg =  asInterp(rhs, "BXor RHS");
    let t1: &Type = getRegister(irFunc, instr.src).typ;
    let t2: &Type = getRegister(irFunc, instr.op1).typ;
    let s1: usize = getSize(t1);
    let s2: usize = getSize(t2);
    assert(s1 == s2, "BXor got differently sized operands");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s1,
    };
    let lhsStart: &u8 = getRegStackPointer(this, &rLhs);
    let rhsStart: &u8 = getRegStackPointer(this, &rRhs);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    if (s1 == 1) {
        *(dstStart as &u8) = *(lhsStart as &u8) ^ *(rhsStart as &u8);
    } else if (s1 == 2) {
        *(dstStart as &u16) = *(lhsStart as &u16) ^ *(rhsStart as &u16);
    } else if (s1 == 4) {
        *(dstStart as &u32) = *(lhsStart as &u32) ^ *(rhsStart as &u32);
    } else if (s1 == 8) {
        *(dstStart as &u64) = *(lhsStart as &u64) ^ *(rhsStart as &u64);
    } else unreachable("Exhaustive handling of types in BXOr");
    return dst;
}
func evaluateInsertValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateInsertValue");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let t: &Type = dstReg.typ;
    match (t) {
        &Type::Array(under, _size) => {
            let valReg: InterpReg = asInterp(at(regs, instr.op1.i), "Interp InsertValue Array");
            let size = getSize(under);
            let offset = instr.src.i * size;
            C::memcpy(dstStart + offset, getRegStackPointer(this, &valReg), size);
        }
        &Type::Struct(decl) => {
            let offset: usize = 0;
            let fieldSize: usize = 0;
            getFieldOffsetAndSize(decl, instr.src.i, &offset, &fieldSize);
            let valReg: InterpReg = asInterp(at(regs, instr.op1.i), "Interp InsertValue Struct");
            assert(valReg.size == fieldSize, "field size mismatch in Interp InsertValue");
            C::memcpy(dstStart + offset, getRegStackPointer(this, &valReg), fieldSize);
        }
        _ => { unreachable("Interp InsertValue expected Array or Struct"); }
    }
    return dst;
}
func evaluateIntSignExtend(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntSignExtend");
    let src: &RegValue = at(regs, instr.src.i);
    let rSrc: InterpReg = asInterp(src, "SExt src");
    let t: &Type = getRegister(irFunc, instr.src).typ;
    assert(isSignedInteger(t), "SExt expected Signed Integer");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: rSrc.size,
    };
    let srcStart: &u8 = getRegStackPointer(this, &rSrc);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    todo_with_msg("sext");
}
func evaluateIntZeroExtend(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntZeroExtend");
    let src: &RegValue = at(regs, instr.src.i);
    let rSrc: InterpReg = asInterp(src, "ZExt src");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let t1 = getRegister(irFunc, instr.src).typ;
    let t2 = getRegister(irFunc, instr.dst).typ;
    let s1 = getSize(t1);
    let s2 = getSize(t2);
    assert(s2 > s1, "Zero Extend expected dst to be greater than src");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s2,
    };
    let srcStart: &u8 = getRegStackPointer(this, &rSrc);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    C::memset(dstStart, 0, s2);
    if (s1 == 1) *dstStart = *srcStart;
    else if (s1 == 2) *(dstStart as &u16) = *(srcStart as &u16);
    else if (s1 == 4) *(dstStart as &u32) = *(srcStart as &u32);
    else unreachable("ZExt 8 byte to what?");
    return dst;
}
func evaluateIntTruncate(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntTruncate");
    let src: &RegValue = at(regs, instr.src.i);
    let rSrc: InterpReg = asInterp(src, "Trunc src");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let t1 = getRegister(irFunc, instr.src).typ;
    let t2 = getRegister(irFunc, instr.dst).typ;
    let s1 = getSize(t1);
    let s2 = getSize(t2);
    assert(s1 > s2, "Int Truncate expected src to be greater than dst");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: s2,
    };
    let srcStart: &u8 = getRegStackPointer(this, &rSrc);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    C::memset(dstStart, 0, s2);
    if (s1 == 8) *(dstStart as &u64) = *(srcStart as &u64);
    else if (s1 == 4) *(dstStart as &u32) = *(srcStart as &u32);
    else if (s1 == 2) *(dstStart as &u16) = *(srcStart as &u16);
    else unreachable("Truncate 1 byte to what?");
    return dst;
}
func evaluateF32ToF64(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF32ToF64");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F32ToF64");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 8,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f32 = *(srcStart as &f32);
    *(dstStart as &f64) = v as f64;
    return dst;
}
func evaluateF64ToF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF64ToF32");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F64ToF32");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 4,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f64 = *(srcStart as &f64);
    *(dstStart as &f32) = v as f32;
    return dst;
}
func evaluateCreateArray(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCreateArray");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    C::memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateCreateStruct(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCreateStruct");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    C::memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateCreateUnion(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateCreateUnion");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: getSize(dstReg.typ),
    };
    C::memset(getRegStackPointer(this, &dst), 0, dst.size);
    return dst;
}
func evaluateIntToF32(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntToF32");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp IntToF32");
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: 4,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let t: &Type = getRegister(irFunc, instr.src).typ;
    let signed: bool = isSignedInteger(t);
    let s: usize = getSize(t);
    let v: f32 = 0;
    if (s == 1) {
        if (signed) v = *(srcStart as &i8) as f32;
        else v = *(srcStart as &u8) as f32;
    } else if (s == 2) {
        if (signed) v = *(srcStart as &i16) as f32;
        else v = *(srcStart as &u16) as f32;
    } else if (s == 4) {
        if (signed) v = *(srcStart as &i32) as f32;
        else v = *(srcStart as &u32) as f32;
    } else if (s == 8) {
        if (signed) v = *(srcStart as &i64) as f32;
        else v = *(srcStart as &u64) as f32;
    } else {
        unreachable("Interp unexpected size in IntToF32");
    }
    *(dstStart as &f32) = v;
    return dst;
}
func evaluateF32ToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF32ToInt");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F32ToInt");
    let size: usize = getSize(dstReg.typ);
    let signed: bool = isSignedInteger(dstReg.typ);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: size,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f32 = *(srcStart as &f32);
    if (size == 1) {
        if (signed) *(dstStart as &i8) = v as i8;
        else *(dstStart as &u8) = v as u8;
    } else if (size == 2) {
        if (signed) *(dstStart as &i16) = v as i16;
        else *(dstStart as &u16) = v as u16;
    } else if (size == 4) {
        if (signed) *(dstStart as &i32) = v as i32;
        else *(dstStart as &u32) = v as u32;
    } else if (size == 8) {
        if (signed) *(dstStart as &i64) = v as i64;
        else *(dstStart as &u64) = v as u64;
    } else {
        unreachable("Interp F32ToInt: Exhaustive handling of destinations");
    }
    return dst;
}
func evaluateF64ToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateF64ToInt");
    let dstReg: &IRReg = getRegister(irFunc, instr.dst);
    let src: InterpReg = asInterp(at(regs, instr.src.i), "Interp F64ToInt");
    let size: usize = getSize(dstReg.typ);
    let signed: bool = isSignedInteger(dstReg.typ);
    let dst: InterpReg = InterpReg {
        offset: dstReg.offset,
        size: size,
    };
    let srcStart: &u8 = getRegStackPointer(this, &src);
    let dstStart: &u8 = getRegStackPointer(this, &dst);
    let v: f64 = *(srcStart as &f64);
    if (size == 1) {
        if (signed) *(dstStart as &i8) = v as i8;
        else *(dstStart as &u8) = v as u8;
    } else if (size == 2) {
        if (signed) *(dstStart as &i16) = v as i16;
        else *(dstStart as &u16) = v as u16;
    } else if (size == 4) {
        if (signed) *(dstStart as &i32) = v as i32;
        else *(dstStart as &u32) = v as u32;
    } else if (size == 8) {
        if (signed) *(dstStart as &i64) = v as i64;
        else *(dstStart as &u64) = v as u64;
    } else {
        unreachable("Interp F64ToInt: Exhaustive handling of destinations");
    }
    return dst;
}
func evaluatePtrToInt(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluatePtrToInt");
    // noop in interpreter
    return asInterp(at(regs, instr.src.i), "Interp PtrToInt");
}
func evaluateIntToPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntToPtr");
    // noop in interpreter
    return asInterp(at(regs, instr.src.i), "Interp IntToPtr");
}
func evaluateGetFieldPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateGetFieldPtr");
    let fReg: &IRReg = getRegister(irFunc, instr.dst);
    let fAggr: InterpReg = asInterp(at(regs, instr.src.i), "IRInterp: GetFieldPtr");
    let t: &Type = getRegister(irFunc, instr.src).typ;
    assert(isStructPointer(t), "IRInterp: GetFieldPtr got non-struct pointer");
    let u: &Type = getUnderlyingType(t, false);
    let decl: &ParsedStructDecl = null;
    match (u) {
        &Type::Struct(_decl) => { decl = _decl; }
        _ => { unreachable("Expected Struct in evaluateGetFieldPtr"); }
    }
    let offset: usize = 0;
    let size: usize = 0;
    getFieldOffsetAndSize(decl, instr.op1.i, &offset, &size);
    let reg: InterpReg = InterpReg {
        offset: fReg.offset,
        size: 8,
    };
    let regStackLoc: &u8 = getRegStackPointer(this, &reg);
    let ptr: &u8 = getRegStackPointer(this, &fAggr);
    *(regStackLoc as &usize) = *(ptr as &usize) + offset;
    return reg;
}
func evaluateGetElementPtr(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateGetElementPtr");
    let elemReg: &IRReg = getRegister(irFunc, instr.dst);
    let aggr: InterpReg = asInterp(at(regs, instr.src.i), "IRInterp: GetElementPtr");
    let ptr: &u8 = getRegStackPointer(this, &aggr);
    let dstReg: InterpReg = InterpReg {
        offset: elemReg.offset,
        size: 8,
    };
    let t: &Type = getRegister(irFunc, instr.src).typ;
    let offset = 0;
    for (let i: usize = 0; i < instr.args.length; i = i + 1) {
        let arg = at(&instr.args, i);
        let reg = at(regs, arg.i);
        let elems = *(getRegStackPointer(this, &asInterp(reg, "IRInterp: GetElementPtr index")) as &usize);
        match (t) {
            &Type::Ptr(underlying) => {
                offset = offset + elems * getSize(underlying);
                t = underlying;
            }
            &Type::Array(underlying, _) => {
                offset = offset + elems * getSize(underlying);
                t = underlying;
            }
            &Type::Ptr(&Type::Struct(decl)) => {
                todo_with_msg("IRInterp: evaluateGetElementPtr on Struct");
            }
            _ => {
                C::fprintf(stderr, "%s IRInterp: evaluateGetElementPtr source has unexpected type!\n", FATAL_STR);
                C::fprintf(stderr, "%s IRInterp: The type: %s\n", FATAL_STR, toString(t).buffer);
                C::exit(2);
            }
        }
    }
    let regStackLoc: &u8 = getRegStackPointer(this, &dstReg);
    *(regStackLoc as &usize) = *(ptr as &usize) + offset;
    return dstReg;
}
func evaluateUnreachable(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateUnreachable");
    unreachable("IRInterp: Hit INSTR_UNREACHABLE");
}
func evaluateUnterminated(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateUnterminated");
    unreachable("IRInterp: Hit INSTR_UNTERMINATED");
}
func evaluateMemcpy(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateMemcpy");
    let src  = at(regs, instr.src.i);
    let dst  = at(regs, instr.dst.i);
    let size = at(regs, instr.op1.i);
    let rSrc = asInterp(src, "Memcpy src");
    let rDst = asInterp(dst, "Memcpy dst");
    let rSize = asInterp(size, "Memcpy size");
    let srcLoc: &u8 = *(getRegStackPointer(this, &rSrc) as &usize) as &u8;
    let dstLoc: &u8 = *(getRegStackPointer(this, &rDst) as &usize) as &u8;
    let sizeStart: &u8 = getRegStackPointer(this, &rSize);
    let sizeValue = *(sizeStart as &usize);
    C::memcpy(dstLoc, srcLoc, sizeValue);
    return rDst;
}
func evaluateEmitAssembly(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateEmitAssembly");
    let loc = toString(&instr.span);
    C::fprintf(stderr, "%s: %s: Inline Assembly can't be used in a comptime context.\n", loc.buffer, ERR_STR);
    dumpCallStack(this, &loc);
    drop(&loc);
    C::exit(1);
}
func evaluateIntoIRValue(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateIntoIRValue");
    let src = at(regs, instr.src.i);
    let dstReg = getRegister(irFunc, instr.dst);
    let size = getSize(dstReg.typ);
    assert(size == sizeof RegValue, "IntoIRValue: size mismatch with llvm");
    assert(size == sizeof IRValue, "IntoIRValue: size mismatch with asm");
    let dst = InterpReg {
        offset: dstReg.offset,
        size: size,
    };
    *(getRegStackPointer(this, &dst) as &RegValue) = *src;
    return dst;
}

func evaluateSingle(this: &IRInterp, irFunc: &IRFunc, instr: &IRInstr, regs: &RegValueList, forcedComptime: bool) -> InterpReg {
    trace("IRInterp.evaluateSingle");
    if (!forcedComptime) {
        assert(instr.isComptime, "Expected comptime instr in IRInterp.evaluateSingle");
    }
    assert(this.regStackBase < this.regStackStart + REG_STACK_SIZE, "Stack Cursor Overflow in IRInterp.evaluateSingle");
    if (*flags.debug) dump(instr);
    return instrFns[instr.kind](this, irFunc, instr, regs, forcedComptime);
}
func evaluateBlock(this: &IRInterp, blockID: &IRBlockID, irFunc: &IRFunc, regs: &RegValueList, forcedComptime: bool) -> bool {
    trace("IRInterp.evaluateBlock");
    let block: &IRBlock = getBlockByID(irFunc, *blockID);
    assert(block.instructions.length > 0, "Interp: Encountered empty block");
    for (let ip: usize = 0; ip < block.instructions.length; ip = ip + 1) {
        let instr: &IRInstr = at(&block.instructions, ip);
        let result = evaluateSingle(this, irFunc, instr, regs, forcedComptime);
        if (ip == block.instructions.length - 1) {
            assert(isTerminator(instr), "Interp: Unexpected non-terminator at the end of a block");
            let ret = result.size == 1;
            if (ret) {
                *blockID = IRBlockID { i: result.offset };
            }
            return ret;
        } else {
            assert(!isTerminator(instr), "Interp: Unexpected terminator in the middle of a block");
            addInterpValue(at(regs, instr.dst.i), result);
        }
    }
    return false;
}

@os(WINDOWS) func compileFunctionCall(this: &IRInterp, currFunc: &IRFunc, calledFunc: &IRFunc, instr: &IRInstr, fn: usize, regs: &RegValueList) -> Function {
    let f = at(&funcDecls, calledFunc.originalID);
    let isVariadic = false;
    let retType: &Type = null;
    match (getType(&f.typeState)) {
        &Type::Func(_, _ret, attr) => {
            isVariadic = attr.isVariadic;
            retType = _ret;
        }
        _ => { unreachable("IRGen.evaluateInstrCall: Expected function type"); }
    }
    let buf: ByteBuffer = blank;
    // push(&buf, '\xf1');
    push(&buf, RBP);
    mov(&buf, RBP, RSP);
    comptime ARG_LEN: usize = 4;
    let stack_offset: u32 = 32;
    comptime GPR_ARGS = [RCX , RDX , R8  , R9  ];
    comptime FPR_ARGS = [XMM0, XMM1, XMM2, XMM3];
    for (let i: usize = 0; i < instr.args.length; i = i + 1) {
        let index = at(&instr.args, i);
        let reg: &RegValue = at(regs, index.i);
        let arg: InterpReg = asInterp(reg, "call arg");
        let origReg = getRegister(currFunc, *index);
        let argType = origReg.typ;
        if (isVariadic) {
            if (i >= ARG_LEN) {
                if (getSize(argType) <= 8) {
                    let v = *(getRegStackPointer(this, &arg) as &u64);
                    mov(&buf, RSP, stack_offset, ImmI64 { b: v });
                } else {
                    todo_with_msg(">8byte stack");
                }
                stack_offset = stack_offset + 8;
            } else {
                if (isFloat(argType)) {
                    if (getSize(argType) == 4) {
                        let v1 = *(getRegStackPointer(this, &arg) as &u32);
                        let v2 = *(getRegStackPointer(this, &arg) as &f32);
                        mov(&buf, GPR_ARGS[i], ImmI32 { b: v1 });
                        mov(&buf, FPR_ARGS[i], ImmF32 { b: v2 });
                    } else {
                        let v1 = *(getRegStackPointer(this, &arg) as &u64);
                        let v2 = *(getRegStackPointer(this, &arg) as &f64);
                        mov(&buf, GPR_ARGS[i], ImmI64 { b: v1 });
                        mov(&buf, FPR_ARGS[i], ImmF64 { b: v2 });
                    }
                } else if (getSize(argType) <= 8) {
                    let v = *(getRegStackPointer(this, &arg) as &u64);
                    mov(&buf, GPR_ARGS[i], ImmI64 { b: v });
                } else {
                    todo_with_msg("non-int non-float >8 byte reg");
                }
            }
        } else if (i >= ARG_LEN) {
            // Technically this puts a lot of garbage on the stack, but do we care?
            // we update the stack pointer correctly, so the next argument overwrites the garbage
            // and if the called function doesn't manage the stack properly, is that our fault?
            if (getSize(argType) <= 8) {
                let v = *(getRegStackPointer(this, &arg) as &u64);
                mov(&buf, RSP, stack_offset, ImmI64 { b: v });
            } else {
                todo_with_msg(">8byte stack");
            }
            stack_offset = stack_offset + getSize(argType) as u32;
        } else {
            if (isFloat(argType)) {
                if (getSize(argType) == 4) {
                    let v = *(getRegStackPointer(this, &arg) as &f32);
                    mov(&buf, FPR_ARGS[i], ImmF32 { b: v });
                } else {
                    let v = *(getRegStackPointer(this, &arg) as &f64);
                    mov(&buf, FPR_ARGS[i], ImmF64 { b: v });
                }
            } else if (getSize(argType) <= 8) {
                let v = *(getRegStackPointer(this, &arg) as &u64);
                mov(&buf, GPR_ARGS[i], ImmI64 { b: v });
            } else {
                todo_with_msg("non-int non-float >8 byte reg");
            }
        }
    }
    if (instr.args.length < 4) sub(&buf, RSP, ImmI32 { b: 32 });
    mov(&buf, RAX, ImmI64 { b: fn as u64 });
    call(&buf, RAX);
    if (instr.args.length < 4) add(&buf, RSP, ImmI32 { b: 32 });
    pop(&buf, RBP);
    if (isFloat(retType)) {
        push(&buf, '\x66', '\x48', '\x0F', '\x7E');
        modRM(&buf, ADDR_REG, XMM0.r, RAX);
    } else if (isNone(retType)) {
        mov(&buf, RAX, ImmI32 { b: 420691337 });
    } else if (isInteger(retType) || isBoolean(retType) || isStruct(retType) || isPointer(retType)) {
        // noop, other side will hopefully put the thing in RAX for us
    } else {
        C::fprintf(stderr, "%s\n", toString(retType).buffer);
        todo_with_msg("non-float ret");
    }
    push(&buf, '\xC3');
    let code = WinAPI::VirtualAlloc(null, buf.length, 4096, 64);
    assert(code != null, "Could not alloc some bytes sadge thx Windows");
    C::memcpy(code, buf.elements, buf.length);
    C::free(buf.elements);
    return Function { run: code as func () -> u64, size: buf.length };
}
@os(LINUX) func compileFunctionCall(this: &IRInterp, currFunc: &IRFunc, calledFunc: &IRFunc, instr: &IRInstr, fn: usize, regs: &RegValueList) -> Function {
    todo_with_msg("comptime extern call");
}
func evaluateCall(this: &IRInterp, span: Span, irFunc: &IRFunc, regs: &RegValueList) {
    trace("IRInterp.evaluateCall");
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    let fn = at(&funcDecls, irFunc.originalID);
    pushCallStack(this, span, toString(&fn.name.content));
    pushRegisterStack(this, span, funcSize);
    let blockID: IRBlockID = IRBlockID { i: 0 };
    while (evaluateBlock(this, &blockID, irFunc, regs, true)) {
    }
    popRegisterStack(this, span, funcSize);
    popCallStack(this);
    return;
}
func pushRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.pushRegisterStack");
    let new: &u8 = this.regStackBase + size;
    if (new > this.regStackStart + REG_STACK_SIZE) {
        let loc = toString(&span);
        C::fprintf(stderr, "%s: %s Register Stack Overflow in the comptime interpreter.\n", loc.buffer, FATAL_STR);
        C::fprintf(stderr, "%s: %s Tried to reserve %llu byte(s).\n", loc.buffer, FATAL_STR, size);
        drop(&loc);
        C::exit(2);
    }
    this.regStackBase = new;
}
func popRegisterStack(this: &IRInterp, span: Span, size: usize) {
    trace("IRInterp.popRegisterStack");
    let new: &u8 = this.regStackBase - size;
    if (new < this.regStackStart) {
        let loc = toString(&span);
        C::fprintf(stderr, "%s: %s Register Stack Underflow in the comptime interpreter.\n", loc.buffer, FATAL_STR);
        drop(&loc);
        C::exit(2);
    }
    this.regStackBase = new;
    assert(this.regStackBase >= this.globalRegBase, "Register Stack overwrote global stack");
}
func pushCallStack(this: &IRInterp, span: Span, name: String) {
    push(&this.callStack, CallStackInfo {
        span: span,
        name: name,
    });
}
func popCallStack(this: &IRInterp) {
    assert(this.callStack.length > 0, "IRInterp.popCallStack() called on empty stack!");
    pop(&this.callStack);
}
func dumpCallStack(this: &IRInterp, loc: &String) {
    C::fprintf(stderr, "%s: %s: The current call stack:\n", loc.buffer, NOTE_STR);
    for (let _i: usize = 0; _i < this.callStack.length; _i = _i + 1) {
        let i = this.callStack.length - _i - 1;
        let e = at(&this.callStack, i);
        let l = toString(&e.span);
        C::fprintf(stderr, "%s: %s: Entered function `%s` here.\n", l.buffer, NOTE_STR, e.name.buffer);
        drop(&l);
    }
}

func newIRInterpreter(irGen: &IRGen) -> IRInterp {
    let regStack: &u8 = C::malloc(REG_STACK_SIZE);
    assert(regStack != null, "Could not prepare IRInterp.regStack");
    let realStack: &u8 = C::malloc(STACK_SIZE);
    assert(realStack != null, "Could not prepare IRInterp.realStack");
    let argStack: &u8 = C::malloc(640000);
    assert(argStack != null, "Could not prepare IRInterp.argStack");
    return IRInterp {
        irGen: irGen,
        globalRegisters: null,
        regStackStart: regStack,
        globalRegBase: regStack,
        regStackBase: regStack,
        realStackStart: realStack,
        realStackPointer: realStack,
        realStackBase: realStack,
        argStack: argStack,
        argStackLength: 0,
        argStackCapacity: 640000,
    };
}
