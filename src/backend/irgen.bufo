import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "span.bufo";
import "../util/hashmaps.bufo";
import "../util/lists.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../middleend/types.bufo";
import "./LLVM/values.bufo";

struct RegIndex {
    i: usize;
    func equals(&this, other: &RegIndex) -> bool {
        return this.i == other.i;
    }
}

struct IRReg {
    isComptime: bool;
    offset: usize;
    typ: &Type;
    func equals(&this, other: &IRReg) -> bool {
        todo_with_msg("IRReg.equals");
        return false;
    }
}

comptime INSTR_INVALID: usize = 0;
comptime INSTR_ALLOCA: usize = 1;
comptime INSTR_GET_PARAM: usize = 2;
comptime INSTR_STORE: usize = 3;
comptime INSTR_FETCH_GLOBAL_PTR: usize = 4;
comptime INSTR_FETCH_GLOBAL_VALUE: usize = 5;
comptime INSTR_FETCH_COMPTIME_VALUE: usize = 6;
comptime INSTR_LOAD: usize = 8;
comptime INSTR_MOVE: usize = 9;
comptime INSTR_CALL: usize = 10;
comptime INSTR_RETURN_EXPR: usize = 11;
comptime INSTR_RETURN_VOID: usize = 12;
comptime INSTR_LOAD_STRING: usize = 13;
comptime INSTR_LOAD_BOOL: usize = 14;
comptime INSTR_LOAD_I8: usize = 15;
comptime INSTR_LOAD_U8: usize = 16;
comptime INSTR_LOAD_I16: usize = 17;
comptime INSTR_LOAD_U16: usize = 18;
comptime INSTR_LOAD_I32: usize = 19;
comptime INSTR_LOAD_U32: usize = 20;
comptime INSTR_LOAD_I64: usize = 21;
comptime INSTR_LOAD_U64: usize = 22;
comptime INSTR_LOAD_NULL: usize = 23;
comptime INSTR_LOAD_F32: usize = 24;
comptime INSTR_LOAD_F64: usize = 25;
comptime INSTR_LOAD_BLANK: usize = 26;
comptime INSTR_COND_BR: usize = 27;
comptime INSTR_BR: usize = 28;
comptime INSTR_INT_ADD: usize = 29;
comptime INSTR_INT_SUB: usize = 30;
comptime INSTR_INT_MUL: usize = 31;
comptime INSTR_INT_DIV: usize = 32;
comptime INSTR_INT_MOD: usize = 33;
comptime INSTR_INT_CMP_EQ: usize = 34;
comptime INSTR_INT_CMP_NEQ: usize = 35;
comptime INSTR_INT_CMP_GT: usize = 36;
comptime INSTR_INT_CMP_GTE: usize = 37;
comptime INSTR_INT_CMP_LT: usize = 38;
comptime INSTR_INT_CMP_LTE: usize = 39;
comptime INSTR_FLOAT_ADD: usize = 40;
comptime INSTR_FLOAT_SUB: usize = 41;
comptime INSTR_FLOAT_MUL: usize = 42;
comptime INSTR_FLOAT_DIV: usize = 43;
comptime INSTR_FLOAT_MOD: usize = 44;
comptime INSTR_FLOAT_CMP_EQ: usize = 45;
comptime INSTR_FLOAT_CMP_NEQ: usize = 46;
comptime INSTR_FLOAT_CMP_GT: usize = 47;
comptime INSTR_FLOAT_CMP_GTE: usize = 48;
comptime INSTR_FLOAT_CMP_LT: usize = 49;
comptime INSTR_FLOAT_CMP_LTE: usize = 50;
comptime INSTR_LOGICAL_NOT: usize = 51;
comptime INSTR_LOGICAL_AND: usize = 52;
comptime INSTR_LOGICAL_OR: usize = 53;
comptime INSTR_BITWISE_AND: usize = 54;
comptime INSTR_BITWISE_OR: usize = 55;
comptime INSTR_BITWISE_XOR: usize = 56;
comptime INSTR_INSERT_VALUE: usize = 57;
comptime INSTR_INT_SIGN_EXTEND: usize = 58;
comptime INSTR_INT_ZERO_EXTEND: usize = 59;
comptime INSTR_INT_TRUNCATE: usize = 60;
comptime INSTR_INT_TO_F32: usize = 61;
comptime INSTR_INT_TO_F64: usize = 62;
comptime INSTR_F32_TO_INT: usize = 63;
comptime INSTR_F64_TO_INT: usize = 64;
comptime INSTR_F32_TO_F64: usize = 65;
comptime INSTR_F64_TO_F32: usize = 66;
comptime INSTR_CREATE_ARRAY: usize = 67;
comptime INSTR_CREATE_STRUCT: usize = 68;
comptime INSTR_PTR_TO_INT: usize = 69;
comptime INSTR_INT_TO_PTR: usize = 70;
comptime INSTR_GET_FIELD_PTR: usize = 71;
comptime INSTR_GET_ELEMENT_PTR: usize = 72;
comptime INSTR_UNREACHABLE: usize = 73;
struct IRInstr {
    kind: usize;
    isComptime: bool;
    dst: RegIndex;
    src: RegIndex;
    op1: RegIndex;
    args: RegIndexList;
    func equals(&this, other: &IRInstr) -> bool {
        todo_with_msg("IRInstr.equals");
        return false;
    }
    func isTerminator(&this) -> bool {
        return this.kind == INSTR_RETURN_EXPR
            || this.kind == INSTR_RETURN_VOID
            || this.kind == INSTR_COND_BR
            || this.kind == INSTR_BR
            || this.kind == INSTR_UNREACHABLE;
    }
    func dump(&this) {
        if (this.isComptime) printf("\x1b[92m");
        if (this.kind == INSTR_ALLOCA) printf("r%llu = Alloca %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_GET_PARAM) printf("r%llu = GetParam %llu (%llu bytes)", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_STORE) printf("Store r%llu, r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_FETCH_GLOBAL_PTR) printf("r%llu = FetchGlobalPtr r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_FETCH_GLOBAL_VALUE) printf("r%llu = FetchGlobalValue r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_FETCH_COMPTIME_VALUE) printf("r%llu = FetchComptimeValue r%llu, global=%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_LOAD) printf("r%llu = Load r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_MOVE) printf("r%llu = Move r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_CALL) {
            printf("r%llu = Call %llu", this.dst.i, this.src.i);
            for (let i: usize = 0; i < this.args.length; i = i + 1) {
                printf(", r%llu", this.args.at(i).i);
            }
        } else if (this.kind == INSTR_RETURN_EXPR) printf("RetExpr r%llu", this.src.i);
        else if (this.kind == INSTR_RETURN_VOID) printf("RetVoid");
        else if (this.kind == INSTR_LOAD_STRING) printf("r%llu = LoadString %p, %llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_LOAD_BOOL) printf("r%llu = Load Bool %hhu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_I8) printf("r%llu = Load I8 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_U8) printf("r%llu = Load U8 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_I16) printf("r%llu = Load I16 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_U16) printf("r%llu = Load U16 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_I32) printf("r%llu = Load I32 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_U32) printf("r%llu = Load U32 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_I64) printf("r%llu = Load I64 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_U64) printf("r%llu = Load U64 %llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOAD_NULL) printf("r%llu = Load Null", this.dst.i);
        else if (this.kind == INSTR_LOAD_F32) printf("r%llu = Load F32 %f", this.dst.i, *(&this.src.i as &f32) as f64);
        else if (this.kind == INSTR_LOAD_F64) printf("r%llu = Load F64 %f", this.dst.i, *(&this.src.i as &f64));
        else if (this.kind == INSTR_LOAD_BLANK) printf("r%llu = Load Blank", this.dst.i);
        else if (this.kind == INSTR_COND_BR) printf("CondBr r%llu, true=%llu, false=%llu", this.src.i, this.dst.i, this.op1.i);
        else if (this.kind == INSTR_BR) printf("Br %llu", this.dst.i);
        else if (this.kind == INSTR_INT_ADD) printf("r%llu = AddInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_SUB) printf("r%llu = SubInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_MUL) printf("r%llu = MulInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_DIV) printf("r%llu = DivInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_MOD) printf("r%llu = ModInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_EQ) printf("r%llu = ICmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_NEQ) printf("r%llu = ICmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_GT) printf("r%llu = ICmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_GTE) printf("r%llu = ICmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_LT) printf("r%llu = ICmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_CMP_LTE) printf("r%llu = ICmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_ADD) printf("r%llu = AddFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_SUB) printf("r%llu = SubFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_MUL) printf("r%llu = MulFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_DIV) printf("r%llu = DivFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_MOD) printf("r%llu = ModFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_EQ) printf("r%llu = FCmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_NEQ) printf("r%llu = FCmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_GT) printf("r%llu = FCmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_GTE) printf("r%llu = FCmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_LT) printf("r%llu = FCmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_FLOAT_CMP_LTE) printf("r%llu = FCmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_LOGICAL_NOT) printf("r%llu = LNot r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_LOGICAL_AND) printf("r%llu = LAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_LOGICAL_OR) printf("r%llu = LOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_BITWISE_AND) printf("r%llu = BAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_BITWISE_OR) printf("r%llu = BOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_BITWISE_XOR) printf("r%llu = BXOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INSERT_VALUE) printf("r%llu = InsertValue r%llu, %llu, r%llu", this.dst.i, this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_SIGN_EXTEND) printf("r%llu = IntSExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_ZERO_EXTEND) printf("r%llu = IntZExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_TRUNCATE) printf("r%llu = IntTrunc r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_INT_TO_F32) printf("r%llu = IntToF32 r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_F32_TO_INT) printf("r%llu = F32ToInt r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_F64_TO_INT) printf("r%llu = F64ToInt r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_F32_TO_F64) printf("r%llu = FloatExt r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_F64_TO_F32) printf("r%llu = FloatTrunc r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_CREATE_ARRAY) printf("r%llu = CreateArray", this.dst.i);
        else if (this.kind == INSTR_CREATE_STRUCT) printf("r%llu = CreateStruct", this.dst.i);
        else if (this.kind == INSTR_PTR_TO_INT) printf("r%llu = PtrToInt r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_INT_TO_PTR) printf("r%llu = IntToPtr r%llu", this.dst.i, this.src.i);
        else if (this.kind == INSTR_GET_FIELD_PTR) printf("r%llu = GetFieldPtr r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
        else if (this.kind == INSTR_UNREACHABLE) printf("unreachable");
        else if (this.kind == INSTR_GET_ELEMENT_PTR) {
            printf("r%llu = GetElementPtr r%llu", this.dst.i, this.src.i);
            for (let i: usize = 0; i < this.args.length; i = i + 1) {
                printf(", r%llu", this.args.at(i).i);
            }
        } else {
            fprintf(stderr, "kind: %llu\n", this.kind);
            unreachable("Exhaustive handling in IRInstr.dump()");
        }
        if (this.isComptime) printf("\x1b[0m\n"); else printf("\n");
    }
}

struct LoopBlock {
    before: IRBlockID;
    after: IRBlockID;
    func equals(&this, other: &LoopBlock) -> bool {
        return this.before.i == other.before.i && this.after.i == other.after.i;
    }
}

struct IRBlockID {
    i: usize;
}
struct IRBlock {
    parent: String;
    id: IRBlockID;
    instructions: IRInstrList;
    func equals(&this, other: &IRBlock) -> bool {
        return this.parent.equals(&other.parent) && this.id.i == other.id.i;
    }

    func isTerminated(&this) -> bool {
        trace("IRBlock.isTerminated");
        if (this.instructions.length == 0) return false;
        return this.instructions.last().isTerminator();
    }

    func dump(&this) {
        printf("b%llu:\n", this.id);
        for (let i: usize = 0; i < this.instructions.length; i = i + 1) {
            printf("  %4d: ", i);
            this.instructions.at(i).dump();
        }
    }
    func pushInstruction(&this, instr: IRInstr) {
        trace("IRBlock.pushInstruction");
        this.instructions.push(instr);
    }
}

struct IRFunc {
    originalID: usize;
    name: String;
    comptimeLevel: usize;
    isMethod: bool;
    scopes: IRScopeList;
    registers: IRRegList;
    blocks: IRBlockList;
    loopBlocks: LoopBlockList;
    currentBlock: IRBlockID;
    llvmFunc: LLVMValue;
    retPtr: RegIndex;
    attrs: ParsedAttributeList;
    func hasAttribute(&this, attr: usize) -> bool {
        trace("IRFunc.hasAttribute");
        for (let i: usize = 0; i < this.attrs.length; i = i + 1) {
            if (this.attrs.at(i).kind == attr) return true;
        }
        return false;
    }
    func isExtern(&this) -> bool {
        if (this.isMethod) return false;
        return this.getFuncNode().isExtern();
    }
    func appendBlock(&this) -> IRBlockID {
        let id: IRBlockID = IRBlockID { i: this.blocks.length };
        this.blocks.push(IRBlock {
            parent: this.name,
            id: id,
            instructions: blank,
        });
        return id;
    }
    func setCurrentBlock(&this, id: IRBlockID) {
        assert(id.i < this.blocks.length, "setCurrentBlock called with invalid ID");
        this.currentBlock = id;
    }
    func getCurrentBlock(&this) -> IRBlockID {
        assert(this.blocks.length > 0, "getCurrentBlock called on empty IRFunc");
        assert(this.currentBlock.i < this.blocks.length, "getCurrentBlock points to invalid block");
        return this.currentBlock;
    }
    func getCurrentBlockAsRef(&this) -> &IRBlock {
        assert(this.blocks.length > 0, "getCurrentBlockAsRef called on empty IRFunc");
        assert(this.currentBlock.i < this.blocks.length, "getCurrentBlockAsRef points to invalid block");
        return this.blocks.at(this.currentBlock.i);
    }
    func getBlockByID(&this, id: IRBlockID) -> &IRBlock {
        assert(this.blocks.length > 0, "getBlockByID called on empty IRFunc");
        assert(id.i < this.blocks.length, "getBlockByID called with invalid ID");
        return this.blocks.at(id.i);
    }
    func pushLoopBlocks(&this, before: IRBlockID, after: IRBlockID) {
        this.loopBlocks.push(LoopBlock {
            before: before,
            after: after,
        });
    }
    func popLoopBlocks(&this) {
        this.loopBlocks.pop();
    }
    func getFuncNode(&this) -> &ParsedFuncDecl {
        assert(!this.isMethod, "IRFunc.getFuncNode called on Method");
        return funcDecls.at(this.originalID);
    }
    func getMethodNode(&this) -> &ParsedMethod {
        assert(this.isMethod, "IRFunc.getMethodNode called on Function");
        return methods.at(this.originalID);
    }
    func dumpInstructions(&this) {
        printf("%s:\n", this.name.chars());
        for (let i: usize = 0; i < this.blocks.length; i = i + 1) {
            this.blocks.at(i).dump();
        }
    }
    func equals(&this, other: &IRFunc) -> bool {
        todo_with_msg("IRFunc.equals");
        return false;
    }
    func enterScope(&this) -> usize {
        this.scopes.push(blank);
        return this.scopes.length;
    }
    func leaveScope(&this) -> usize {
        let s: usize = this.scopes.length;
        this.scopes.pop();
        return s;
    }
    func startComptime(&this) {
        this.comptimeLevel = this.comptimeLevel + 1;
    }
    func endComptime(&this) {
        assert(this.comptimeLevel > 0);
        this.comptimeLevel = this.comptimeLevel - 1;
    }
    func getRegisterSizeInBytes(&this) -> usize {
        let size: usize = 0;
        for (let i: usize = 0; i < this.registers.length; i = i + 1) {
            let reg: &IRReg = this.getRegister(RegIndex { i: i });
            size = size + reg.typ.getSize();
        }
        return size;
    }
    func allocateRegister(&this, typ: &Type) -> RegIndex {
        trace("IRFunc.allocateRegister");
        let size: usize = this.registers.length;
        let offset: usize = 0;
        if (size > 0) {
            let last: &IRReg = this.registers.last();
            offset = last.offset + last.typ.getSize();
        }
        this.registers.push(IRReg {
            isComptime: this.comptimeLevel > 0,
            offset: offset,
            typ: typ,
        });
        return RegIndex { i: size };
    }
    func getRegister(&this, index: RegIndex) -> &IRReg {
        assert(index.i < this.registers.length, "Out of bounds access in IRFunc.getRegister");
        return this.registers.at(index.i);
    }
    func getIdentifierByName(&this, name: SubStr) -> &IRScopeEntry {
        trace("IRFunc.getIdentifierByName");
        for (let _i: usize = 0; _i < this.scopes.length; _i = _i + 1) {
            let i: usize = this.scopes.length - _i - 1;
            let entry: &IRScopeEntry = this.scopes.at(i).getIdentifierByName(name);
            if (entry != null) {
                return entry;
            }
        }
        return null;
    }
    func pushInstruction(&this, instr: IRInstr) {
        trace("IRFunc.pushInstruction");
        if (this.blocks.length == 0) todo_with_msg("no block");
        if (this.currentBlock.i >= this.blocks.length) todo_with_msg("overflow");
        this.blocks.at(this.currentBlock.i).pushInstruction(instr);
    }
    func buildAlloca(&this, dst: RegIndex, size: usize) {
        let alloca: IRInstr = IRInstr {
            kind: INSTR_ALLOCA,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: size },
            op1: blank,
            args: blank,
        };
        let entry: &IRBlock = this.getBlockByID(IRBlockID { i: 0 });
        if (entry.isTerminated()) {
            assert(entry.instructions.length > 0);
            entry.pushInstruction(alloca);
            let l: usize = entry.instructions.length;
            let last: &IRInstr = entry.instructions.at(l - 1);
            let prev: &IRInstr = entry.instructions.at(l - 2);
            let i1: IRInstr = *last;
            *last = *prev;
            *prev = i1;
        } else {
            entry.pushInstruction(alloca);
        }
    }
    func buildFetchGlobalPointer(&this, dst: RegIndex, globalIndex: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_FETCH_GLOBAL_PTR,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: globalIndex,
            op1: blank,
            args: blank,
        });
    }
    func buildFetchGlobalRuntimeValue(&this, dst: RegIndex, globalIndex: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_FETCH_GLOBAL_VALUE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: globalIndex,
            op1: blank,
            args: blank,
        });
    }
    func buildFetchGlobalComptimeValue(&this, dst: RegIndex, globalIndex: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_FETCH_COMPTIME_VALUE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: globalIndex,
            op1: RegIndex { i: 1 },
            args: blank,
        });
    }
    func buildFetchLocalComptimeValue(&this, dst: RegIndex, globalIndex: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_FETCH_COMPTIME_VALUE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: globalIndex,
            op1: RegIndex { i: 0 },
            args: blank,
        });
    }
    func buildLoad(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildMove(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_MOVE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildGetParam(&this, dst: RegIndex, index: usize, size: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_GET_PARAM,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: index },
            op1: RegIndex { i: size },
            args: blank,
        });
    }
    func buildStore(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_STORE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildCall(&this, dst: RegIndex, funcID: RegIndex, args: RegIndexList) {
        this.pushInstruction(IRInstr {
            kind: INSTR_CALL,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: funcID,
            op1: blank,
            args: args,
        });
    }
    func buildReturnExpr(&this, val: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_RETURN_EXPR,
            isComptime: this.comptimeLevel > 0,
            dst: blank,
            src: val,
            op1: blank,
            args: blank,
        });
    }
    func buildReturnEmpty(&this) {
        this.pushInstruction(IRInstr {
            kind: INSTR_RETURN_VOID,
            isComptime: this.comptimeLevel > 0,
            dst: blank,
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildLoadString(&this, dst: RegIndex, str: SubStr) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_STRING,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: str.start as usize },
            op1: RegIndex { i: str.len },
            args: blank,
        });
    }
    func buildLoadBool(&this, dst: RegIndex, val: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_BOOL,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: val },
            op1: blank,
            args: blank,
        });
    }
    func buildLoadInteger(&this, dst: RegIndex, t: &Type, val: usize) {
        let kind: usize = INSTR_LOAD_I8;
        if (t.isChar()) {
            kind = INSTR_LOAD_U8;
        } else {
            assert(t.isInteger(), "IRFunc.buildLoadInteger got non-int type");
            let size: usize = t.getSize();
            if (size == 2) kind = INSTR_LOAD_I16;
            if (size == 4) kind = INSTR_LOAD_I32;
            if (size == 8) kind = INSTR_LOAD_I64;
            if (!t.isSignedInteger()) kind = kind + 1;
        }
        this.pushInstruction(IRInstr {
            kind: kind,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: val },
            op1: blank,
            args: blank,
        });
    }
    func buildLoadNull(&this, dst: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_NULL,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildLoadF32(&this, dst: RegIndex, val: f32) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_F32,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: *(&val as &usize) },
            op1: blank,
            args: blank,
        });
    }
    func buildLoadF64(&this, dst: RegIndex, val: f64) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_F64,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: *(&val as &usize) },
            op1: blank,
            args: blank,
        });
    }
    func buildLoadBlank(&this, dst: RegIndex, size: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOAD_BLANK,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: RegIndex { i: size },
            op1: blank,
            args: blank,
        });
    }
    func buildLogicalNot(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_LOGICAL_NOT,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank
        });
    }
    func buildBinaryOp(&this, kind: usize, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: kind,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: lhs,
            op1: rhs,
            args: blank,
        });
    }
    func buildInsertValue(&this, aggr: RegIndex, index: usize, val: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INSERT_VALUE,
            isComptime: this.comptimeLevel > 0,
            dst: aggr,
            src: RegIndex { i: index },
            op1: val,
            args: blank,
        });
    }
    func buildUnreachable(&this) {
        this.pushInstruction(IRInstr {
            kind: INSTR_UNREACHABLE,
            isComptime: this.comptimeLevel > 0,
            dst: blank,
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildBr(&this, block: IRBlockID) {
        assert(block.i < this.blocks.length, "buildBr called with invalid ID");
        this.pushInstruction(IRInstr {
            kind: INSTR_BR,
            isComptime: this.comptimeLevel > 0,
            dst: RegIndex { i: block.i },
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildCondBr(&this, cond: RegIndex, drue: IRBlockID, falze: IRBlockID) {
        assert(drue.i < this.blocks.length, "buildCondBr called with invalid ID");
        assert(falze.i < this.blocks.length, "buildCondBr called with invalid ID");
        this.pushInstruction(IRInstr {
            kind: INSTR_COND_BR,
            isComptime: this.comptimeLevel > 0,
            dst: RegIndex { i: drue.i },
            src: cond,
            op1: RegIndex { i: falze.i },
            args: blank,
        });
    }
    func buildBreak(&this) -> bool {
        if (this.loopBlocks.length == 0) return false;
        let block: &LoopBlock = this.loopBlocks.last();
        this.buildBr(block.after);
        return true;
    }
    func buildContinue(&this) -> bool {
        if (this.loopBlocks.length == 0) return false;
        let block: &LoopBlock = this.loopBlocks.last();
        this.buildBr(block.before);
        return true;
    }
    func buildIntSignExtend(&this, dst: RegIndex, src: RegIndex, bits: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_SIGN_EXTEND,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: RegIndex { i: bits },
            args: blank,
        });
    }
    func buildIntZeroExtend(&this, dst: RegIndex, src: RegIndex, bits: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_ZERO_EXTEND,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: RegIndex { i: bits },
            args: blank,
        });
    }
    func buildIntTruncate(&this, dst: RegIndex, src: RegIndex, bits: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_TRUNCATE,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: RegIndex { i: bits },
            args: blank,
        });
    }
    func buildF32ToF64(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_F32_TO_F64,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildF64ToF32(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_F64_TO_F32,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildIntToF32(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_TO_F32,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildIntToF64(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_TO_F64,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildF32ToInt(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_F32_TO_INT,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildF64ToInt(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_F64_TO_INT,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildCreateArray(&this, dst: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_CREATE_ARRAY,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildCreateStruct(&this, dst: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_CREATE_STRUCT,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: blank,
            op1: blank,
            args: blank,
        });
    }
    func buildPtrToInt(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_PTR_TO_INT,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildIntToPtr(&this, dst: RegIndex, src: RegIndex) {
        this.pushInstruction(IRInstr {
            kind: INSTR_INT_TO_PTR,
            isComptime: this.comptimeLevel > 0,
            dst: dst,
            src: src,
            op1: blank,
            args: blank,
        });
    }
    func buildGetFieldPtr(&this, elem: RegIndex, aggr: RegIndex, index: usize) {
        this.pushInstruction(IRInstr {
            kind: INSTR_GET_FIELD_PTR,
            isComptime: this.comptimeLevel > 0,
            dst: elem,
            src: aggr,
            op1: RegIndex { i: index },
            args: blank,
        });
    }
    func buildGetElementPtr(&this, elem: RegIndex, aggr: RegIndex, indices: RegIndexList) {
        this.pushInstruction(IRInstr {
            kind: INSTR_GET_ELEMENT_PTR,
            isComptime: this.comptimeLevel > 0,
            dst: elem,
            src: aggr,
            op1: blank,
            args: indices,
        });
    }
}

struct IRScopeEntry {
    name: SubStr;
    ptr: RegIndex;
    isComptime: bool;
    func equals(&this, other: &IRScopeEntry) -> bool {
        todo_with_msg("IRScopeEntry.equals");
        return false;
    }
}

struct IRScope {
    entries: IRScopeEntryList;
    func equals(&this, other: &IRScope) -> bool {
        todo_with_msg("IRScope.equals");
        return false;
    }
    func addEntry(&this, name: SubStr, ptr: RegIndex, isComptime: bool) {
        this.entries.push(IRScopeEntry {
            name: name,
            ptr: ptr,
            isComptime: isComptime,
        });
    }
    func getIdentifierByName(&this, name: SubStr) -> &IRScopeEntry {
        for (let i: usize = 0; i < this.entries.length; i = i + 1) {
            let entry: &IRScopeEntry = this.entries.at(i);
            if (name.equals(&entry.name)) {
                return entry;
            }
        }
        return null;
    }
}

struct IRGen {
    globalScope: IRFunc;
    functions: String_IRFuncHashMap;
    func getIdentifierByName(&this, function: &IRFunc, name: SubStr, isGlobal: &bool) -> &IRScopeEntry {
    trace("IRGen.getIdentifierByName");
        let entry: &IRScopeEntry = function.getIdentifierByName(name);
        if (entry != null) {
            *isGlobal = false;
            return entry;
        }
        entry = this.globalScope.getIdentifierByName(name);
        if (entry != null) {
            *isGlobal = true;
            return entry;
        }
        name.print();
        unreachable("Could not find identifier anywhere.");
        return null;
    }
    func getFunctionByName(&this, name: &String) -> usize {
        return this.functions.indexOf(name);
    }
    func fillLookup(&this, project: &ParsedModule) -> bool {
        trace("IRGen.fillLookup");
        for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
            let function: &ParsedFuncDecl = funcDecls.at(i);
            if (function.ignored) continue;
            let name: String = function.getMangledName();
            if (this.functions.containsKey(&name)) {
                todo_with_msg("lookup already contains function with name");
            }
            let irfunc: IRFunc = IRFunc {
                name: name,
                isMethod: false,
                originalID: function.getID(),
                comptimeLevel: 0,
                scopes: blank,
                registers: blank,
                blocks: blank,
                loopBlocks: blank,
                currentBlock: blank,
                llvmFunc: blank,
                retPtr: blank,
                attrs: function.attrs,
            };
            this.functions.add(name, irfunc);
        }
        for (let i: usize = 0; i < methods.length; i = i + 1) {
            let method: &ParsedMethod = methods.at(i);
            if (method.ignored) continue;
            let name: String = method.getMangledName();
            if (this.functions.containsKey(&name)) {
                todo_with_msg("lookup already contains method with name");
            }
            let irmeth: IRFunc = IRFunc {
                name: name,
                isMethod: true,
                originalID: method.getID(),
                comptimeLevel: 0,
                scopes: blank,
                registers: blank,
                blocks: blank,
                loopBlocks: blank,
                currentBlock: blank,
                llvmFunc: blank,
                retPtr: blank,
                attrs: method.attrs,
            };
            this.functions.add(name, irmeth);
        }
        return true;
    }
    func generateBytecode(&this, project: &ParsedModule) -> bool {
        trace("IRGen.generateBytecode");
        if (!this.fillLookup(project))
            return false;
        let scope: usize = this.globalScope.enterScope();
        assert(this.globalScope.scopes.length == 1, "Expected only one valid scope");
        let entry: IRBlockID = this.globalScope.appendBlock();
        this.globalScope.setCurrentBlock(entry);
        for (let i: usize = 0; i < modules.length; i = i + 1) {
            let mod: &ParsedModule = modules.at(i);
            for (let j: usize = 0; j < mod.tliLength; j = j + 1) {
                let tli: &ParsedTopLevelItem = topLevelItems.at(mod.getTopLevelItemAtIndex(j));
                if (tli.ignored) continue;
                if (tli.kind == TLI_VAR_DECL) {
                    this.generateBytecodeStmt(&this.globalScope, stmts.at(tli.nodeID));
                }
            }
        }
        for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
            let fn: &ParsedFuncDecl = funcDecls.at(i);
            this.generateFunction(fn);
        }
        for (let i: usize = 0; i < methods.length; i = i + 1) {
            let meth: &ParsedMethod = methods.at(i);
            this.generateMethod(meth);
        }
        return true;
    }

    func generateFunctionHeader(&this, function: &IRFunc, retType: &Type, params: &ParamContext) {
        trace("IRGen.generateFunctionHeader");
        let entry: IRBlockID = function.appendBlock();
        function.setCurrentBlock(entry);
        let offset: usize = 0;
        if (retType.getSize() > 8) {
            offset = 1;
            this.prepareParameter(function, 0, newSubStrOfStrLit("ret"), types.at(retType.intoPointer()), true);
        }
        for (let i: usize = 0; i < params.paramLength; i = i + 1) {
            let name: Token = params.getNameAtIndex(i);
            let typ: usize = params.getTypeAtIndex(i);
            let typDecl: &ParsedTypeNode = typeNodes.at(typ);
            let pType: &Type = types.at(typDecl.typeState.getType());
            this.prepareParameter(function, i + offset, name.content, pType, false);
        }
    }

    func generateFunctionBody(&this, function: &IRFunc, body: &ParsedBlock, retTypeNode: &ParsedTypeNode) {
        trace("IRGen.generateFunctionBody");
        this.generateBytecodeBlock(function, body);
        let curr: &IRBlock = function.getCurrentBlockAsRef();
        if (!curr.isTerminated()) {
            let t: &Type = types.at(retTypeNode.typeState.getType());
            if (t.isNone()) {
                function.buildReturnEmpty();
            } else {
                todo_with_msg("this is sus and an error lol");
                let b: RegIndex = function.allocateRegister(t);
                function.buildLoadBlank(b, t.getSize());
                function.buildReturnExpr(b);
            }
        }
        let after: usize = function.leaveScope();
        assert(after == 1, "Scope imbalance detected");
    }

    func generateFunction(&this, funcDecl: &ParsedFuncDecl) {
        trace("IRGen.generateFunction");
        if (funcDecl.ignored) return;
        assert(funcDecl.typeState.isSuccess(), "Expected valid FuncDecl type in IRGen");
        let name: String = funcDecl.getMangledName();
        let function: &IRFunc = this.functions.get(&name);
        assert(function != null, "Expected to find function in lookup");
        assert(function.name.equals(&name), "functions.get() retrieved wrong IRFunc");
        name.drop();
        if (funcDecl.isExtern()) {
            return;
        }
        let scope: usize = function.enterScope();
        assert(scope == 1, "Expected function to enter first scope");
        let retDecl: &ParsedTypeNode = typeNodes.at(funcDecl.retTypeID);
        this.generateFunctionHeader(function, types.at(retDecl.typeState.getType()), &funcDecl.params);
        this.generateFunctionBody(function, blocks.at(funcDecl.body), typeNodes.at(funcDecl.retTypeID));
    }

    func generateMethod(&this, methDecl: &ParsedMethod) {
        trace("IRGen.generateMethod");
        if (methDecl.ignored) return;
        assert(methDecl.typeState.isSuccess(), "Expected valid Method type in IRGen");
        let name: String = methDecl.getMangledName();
        let function: &IRFunc = this.functions.get(&name);
        assert(function != null, "Expected to find function in lookup");
        assert(function.name.equals(&name), "functions.get() retrieved wrong IRFunc");
        name.drop();
        let scope: usize = function.enterScope();
        assert(scope == 1, "Expected method to enter first scope");
        let retDecl: &ParsedTypeNode = typeNodes.at(methDecl.retTypeID);
        this.generateFunctionHeader(function, types.at(retDecl.typeState.getType()), &methDecl.params);
        this.generateFunctionBody(function, blocks.at(methDecl.body), typeNodes.at(methDecl.retTypeID));
    }

    func generateBytecodeBlock(&this, function: &IRFunc, block: &ParsedBlock) {
        trace("IRGen.generateBytecodeBlock");
        if (block.ignored) return;
        assert(block.typeState.isSuccess(), "Expected valid Block type in IRGen");
        let scope: usize = function.enterScope();
        let modID: usize = 0;
        if (function.isMethod) {
            let m: &ParsedMethod = function.getMethodNode();
            let s: &ParsedStructDecl = structDecls.at(m.parentID);
            modID = s.parentModule;
        } else {
            let f: &ParsedFuncDecl = function.getFuncNode();
            modID = f.parentID;
        }
        for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
            let stmt: &ParsedStmt = stmts.at(block.getStmtAtIndex(i));
            this.generateBytecodeStmt(function, stmt);
            let curr: &IRBlock = function.getCurrentBlockAsRef();
            if (curr.isTerminated()) {
                if (i != block.stmtLength - 1) {
                    let loc: String = stmts.at(block.getStmtAtIndex(i + 1)).span.toString();
                    fprintf(stderr, "%s: %s: Unreachable code.\n", loc.chars(), WARN_STR);
                    loc.drop();
                }
                break;
            }
        }
        let after: usize = function.leaveScope();
        assert(scope == after, "Scope imbalance detected");
    }

    func generateBytecodeStmt(&this, function: &IRFunc, stmt: &ParsedStmt) {
        trace("IRGen.generateBytecodeStmt");
        if (stmt.ignored) return;
        assert(stmt.typeState.isSuccess(), "Expected valid Stmt type in IRGen");
        if (stmt.kind == STMT_VAR_DECL) {
            let exprID: usize = stmt.varDeclContext.exprID;
            let expr: &ParsedExpr = exprs.at(exprID);
            if (stmt.varDeclContext.isComptime) {
                function.startComptime();
                let result: RegIndex = this.generateBytecodeExpr(function, expr, false);
                let scope: &IRScope = function.scopes.last();
                scope.addEntry(stmt.varDeclContext.name.content, result, true);
                function.endComptime();
            } else {
                let result: RegIndex = this.generateBytecodeExpr(function, expr, false);
                let typ: &Type = types.at(stmt.typeState.getType());
                let allocaType: &Type = types.at(typ.intoPointer());
                let ptr: RegIndex = function.allocateRegister(allocaType);
                function.buildAlloca(ptr, typ.getSize());
                function.buildStore(ptr, result);
                let scope: &IRScope = function.scopes.last();
                scope.addEntry(stmt.varDeclContext.name.content, ptr, false);
            }
        } else if (stmt.kind == STMT_IF) {
            let context: &IfContext = &stmt.ifContext;
            let cond: RegIndex = this.generateBytecodeExpr(function, exprs.at(stmt.expr), false);
            if (context.hasElse) {
                let then: IRBlockID = function.appendBlock();
                let elze: IRBlockID = function.appendBlock();
                function.buildCondBr(cond, then, elze);

                function.setCurrentBlock(then);
                this.generateBytecodeStmt(function, stmts.at(context.thenBody));
                then = function.getCurrentBlock();

                function.setCurrentBlock(elze);
                this.generateBytecodeStmt(function, stmts.at(context.elseBody));
                elze = function.getCurrentBlock();

                let thenBlock: &IRBlock = function.getBlockByID(then);
                let elzeBlock: &IRBlock = function.getBlockByID(elze);
                let thenTerm: bool = thenBlock.isTerminated();
                let elseTerm: bool = elzeBlock.isTerminated();
                if (thenTerm && elseTerm) {
                    // nothing to do here
                } else if (thenTerm && !elseTerm) {
                    let after: IRBlockID = function.appendBlock();
                    function.setCurrentBlock(elze);
                    function.buildBr(after);
                    function.setCurrentBlock(after);
                } else if (!thenTerm && elseTerm) {
                    let after: IRBlockID = function.appendBlock();
                    function.setCurrentBlock(then);
                    function.buildBr(after);
                    function.setCurrentBlock(after);
                } else {
                    let after: IRBlockID = function.appendBlock();
                    function.setCurrentBlock(then);
                    function.buildBr(after);
                    function.setCurrentBlock(elze);
                    function.buildBr(after);
                    function.setCurrentBlock(after);
                }
            } else {
                let then: IRBlockID = function.appendBlock();
                let cont: IRBlockID = function.appendBlock();
                function.buildCondBr(cond, then, cont);

                function.setCurrentBlock(then);
                this.generateBytecodeStmt(function, stmts.at(context.thenBody));
                let curr: &IRBlock = function.getCurrentBlockAsRef();
                if (!curr.isTerminated()) {
                    function.buildBr(cont);
                }
                function.setCurrentBlock(cont);
            }
        } else if (stmt.kind == STMT_WHILE) {
            let condBlock: IRBlockID = function.appendBlock();
            let bodyBlock: IRBlockID = function.appendBlock();
            let afterBlock: IRBlockID = function.appendBlock();
            let stepBlock: IRBlockID = function.appendBlock();
            function.pushLoopBlocks(stepBlock, afterBlock);
            function.buildBr(condBlock);

            function.setCurrentBlock(condBlock);
            let cond: RegIndex = this.generateBytecodeExpr(function, exprs.at(stmt.expr), false);
            function.buildCondBr(cond, bodyBlock, afterBlock);

            function.setCurrentBlock(bodyBlock);
            this.generateBytecodeStmt(function, stmts.at(stmt.block));
            let curr: &IRBlock = function.getCurrentBlockAsRef();
            if (!curr.isTerminated()) {
                function.buildBr(stepBlock);
            }

            function.setCurrentBlock(stepBlock);
            this.generateBytecodeExpr(function, exprs.at(stmt.step), false);
            function.buildBr(condBlock);

            function.setCurrentBlock(afterBlock);
            function.popLoopBlocks();
        } else if (stmt.kind == STMT_RETURN_EXPR) {
            let exprID: usize = stmt.expr;
            let expr: &ParsedExpr = exprs.at(exprID);
            let typ: &Type = types.at(expr.typeState.getType());
            let result: RegIndex = this.generateBytecodeExpr(function, expr, false);
            if (typ.getSize() > 8) {
                function.buildStore(function.retPtr, result);
                function.buildReturnExpr(function.retPtr);
            } else {
                if (typ.isStruct()) {
                    let v: RegIndex = this.getRegisterForSize(function, typ.getSize());
                    let t: &Type = function.getRegister(v).typ;
                    let r: RegIndex = function.allocateRegister(types.at(t.intoPointer()));
                    let s: usize = t.getSize();
                    assert(s <= 8);
                    function.buildAlloca(r, s);
                    function.buildStore(r, result);
                    function.buildLoad(v, r);
                    function.buildReturnExpr(v);
                } else {
                    function.buildReturnExpr(result);
                }
            }
        } else if (stmt.kind == STMT_RETURN_EMPTY) {
            function.buildReturnEmpty();
        } else if (stmt.kind == STMT_BLOCK) {
            this.generateBytecodeBlock(function, blocks.at(stmt.block));
        } else if (stmt.kind == STMT_EXPR) {
            this.generateBytecodeExpr(function, exprs.at(stmt.expr), false);
        } else if (stmt.kind == STMT_BREAK) {
            if (!function.buildBreak()) {
                todo_with_msg("break outside of loop");
            }
        } else if (stmt.kind == STMT_CONTINUE) {
            if (!function.buildContinue()) {
                todo_with_msg("continue outside of loop");
            }
        } else {
            todo_with_msg("unknown stmt");
        }
    }

    func generateBytecodeExpr(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExpr");
        if (expr.ignored) return blank;
        assert(expr.typeState.isSuccess(), "Expected valid Expr type in IRGen");
        if (expr.kind == EXPR_EMPTY) {
            return blank;
        } else if (expr.isIdentifier()) {
            return this.generateBytecodeExprIdentifier(function, expr, needsPtr);
        } else if (expr.isArithmetic()) {
            return this.generateBytecodeExprArithmetic(function, expr);
        } else if (expr.isComparison()) {
            return this.generateBytecodeExprComparison(function, expr);
        } else if (expr.isLogical()) {
            return this.generateBytecodeExprLogical(function, expr);
        } else if (expr.isBitwise()) {
            return this.generateBytecodeExprBitwise(function, expr);
        } else if (expr.isLiteral()) {
            return this.generateBytecodeExprLiteral(function, expr, needsPtr);
        } else if (expr.isAssignment()) {
            return this.generateBytecodeExprAssignment(function, expr);
        } else if (expr.kind == EXPR_BINARY) {
            if (expr.op == BIN_DOT) {
                return this.generateBytecodeExprMemberAccess(function, expr, needsPtr);
            } else if (expr.op == BIN_INDEXED_ACCESS) {
                return this.generateBytecodeExprIndexedAccess(function, expr, needsPtr);
            } else {
                unreachable("op should've been handled by now");
            }
        } else if (expr.isCall()) {
            return this.generateBytecodeExprCall(function, expr, needsPtr);
        } else if (expr.isUnary()) {
            return this.generateBytecodeExprUnary(function, expr, needsPtr);
        } else if (expr.isBlank()) {
            let t: &Type = types.at(expr.typeState.getType());
            let size: usize = t.getSize();
            if (size == 0) warning("blank of type of size 0");
            let reg: RegIndex = function.allocateRegister(t);
            function.buildLoadBlank(reg, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = function.allocateRegister(types.at(t.intoPointer()));
                function.buildAlloca(tempAlloc, size);
                function.buildStore(tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        } else if (expr.kind == EXPR_SIZEOF) {
            let t: &Type = types.at(expr.typeState.getType());
            let target: &Type = types.at(typeNodes.at(expr.lhs).typeState.getType());
            let reg: RegIndex = function.allocateRegister(t);
            let size: usize = target.getSize();
            function.buildLoadInteger(reg, t, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = function.allocateRegister(types.at(t.intoPointer()));
                function.buildAlloca(tempAlloc, size);
                function.buildStore(tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        } else if (expr.kind == EXPR_AS) {
            let result: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
            let current: &Type = types.at(exprs.at(expr.lhs).typeState.getType());
            let target: &Type = types.at(typeNodes.at(expr.rhs).typeState.getType());
            let exType: &Type = types.at(expr.typeState.getType());
            assert(target.equals(exType));
            let dst: RegIndex = function.allocateRegister(target);
            if (current.isInteger() && target.isPointer()) {
                function.buildIntToPtr(dst, result);
            } else if (current.isPointer() && target.isInteger()) {
                function.buildPtrToInt(dst, result);
            } else if (current.isPointer() && target.isPointer()) {
                function.buildMove(dst, result);
            } else if ((current.isChar() || current.isInteger()) && (target.isChar() || target.isInteger())) {
                if (current.getSize() < target.getSize()) {
                    if (current.isSignedInteger()) {
                        function.buildIntSignExtend(dst, result, target.getSize() * 8);
                    } else {
                        function.buildIntZeroExtend(dst, result, target.getSize() * 8);
                    }
                } else if (current.getSize() > target.getSize()) {
                    function.buildIntTruncate(dst, result, target.getSize() * 8);
                } else {
                    function.buildMove(dst, result);
                }
            } else if (current.isInteger() && target.isFloat()) {
                if (target.getSize() == 4) function.buildIntToF32(dst, result);
                else if (target.getSize() == 8) function.buildIntToF64(dst, result);
                else unreachable("int to float");
            } else if (current.isFloat() && target.isInteger()) {
                if (current.getSize() == 4) function.buildF32ToInt(dst, result);
                else if (current.getSize() == 8) function.buildF64ToInt(dst, result);
                else unreachable("int to float");
            } else if (current.isFloat() && target.isFloat()) {
                if (current.getSize() < target.getSize()) {
                    assert(current.getSize() == 4);
                    assert(target.getSize() == 8);
                    function.buildF32ToF64(dst, result);
                } else if (current.getSize() > target.getSize()) {
                    assert(current.getSize() == 8);
                    assert(target.getSize() == 4);
                    function.buildF64ToF32(dst, result);
                } else {
                    todo_with_msg("same float to same float");
                }
            } else {
                printf("ligma %llu %llu\n", current.kind, current.typeIndex);
                printf("ligma %llu %llu\n", target.kind, target.typeIndex);
                todo_with_msg("idk as idk");
            }
            return dst;
        } else if (expr.kind == EXPR_STRUCT_INIT) {
            let strukt: &Type = types.at(expr.typeState.getType());
            assert(strukt.isStruct(), "Expected Struct Type in EXPR_STRUCT_INIT");
            let structDecl: &ParsedStructDecl = structDecls.at(strukt.typeIndex);
            let reg: RegIndex = function.allocateRegister(strukt);
            function.buildCreateStruct(reg);
            for (let i: usize = 0; i < expr.structInitContext.fieldLength; i = i + 1) {
                let name: Token = expr.structInitContext.getFieldNameAtIndex(i);
                let expr: &ParsedExpr = exprs.at(expr.structInitContext.getFieldExprAtIndex(i));
                let index: usize = structDecl.getFieldIndex(&name.content);
                let result: RegIndex = this.generateBytecodeExpr(function, expr, false);
                function.buildInsertValue(reg, index, result);
            }
            if (needsPtr) {
                let structAlloc: RegIndex = function.allocateRegister(types.at(strukt.intoPointer()));
                function.buildAlloca(structAlloc, strukt.getSize());
                function.buildStore(structAlloc, reg);
                return structAlloc;
            }
            return reg;
        } else {
            function.name.print();
            expr.span.print();
            printf("\n%llu\n", expr.kind);
            todo_with_msg("unknown expr");
        }
        todo_with_msg("gen expr");
        return blank;
    }

    func generateBytecodeExprMemberAccess(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprMemberAccess");
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_DOT);
        assert(expr.typeState.isSuccess(), "Expected valid Member state in IRGen");
        let lhs: &ParsedExpr = exprs.at(expr.lhs);
        let rhs: &ParsedExpr = exprs.at(expr.rhs);
        let instance: &Type = types.at(lhs.typeState.getType());
        assert(instance.isStruct() || instance.isStructPointer(), "Expected (ptr to) struct in MemberAccess");
        if (rhs.kind == EXPR_NAME) {
            let result: RegIndex = this.generateBytecodeExpr(function, lhs, !instance.isStructPointer());
            let _t: &Type = function.getRegister(result).typ;
            assert(_t.isStruct() || _t.isStructPointer(), "Expected (ptr to) struct in Field Access");
            if (!_t.isStructPointer()) {
                let t1: &Type = types.at(_t.intoPointer());
                let alloca: RegIndex = function.allocateRegister(t1);
                function.buildAlloca(alloca, _t.getSize());
                function.buildStore(alloca, result);
                result = alloca;
                _t = t1;
            }
            assert(_t.isStructPointer(), "Expected ptr to struct in Field Access");
            let structType: &Type = _t.getUnderlyingType(false);
            // `result` contains a pointer to a struct instance at this point
            let decl: &ParsedStructDecl = structDecls.at(structType.typeIndex);
            let index: usize = decl.getFieldIndex(&rhs.origToken.content);
            let _f: &ParsedTypeNode = typeNodes.at(decl.context.getFieldTypeAtIndex(index));
            let fieldType: &Type = types.at(_f.typeState.getType());
            let fieldPtr: RegIndex = function.allocateRegister(types.at(fieldType.intoPointer()));
            function.buildGetFieldPtr(fieldPtr, result, index);
            if (needsPtr) {
                return fieldPtr;
            } else {
                let dst: RegIndex = function.allocateRegister(fieldType);
                function.buildLoad(dst, fieldPtr);
                return dst;
            }
        } else if (rhs.kind == EXPR_CALL) {
            let result: RegIndex = this.generateBytecodeExpr(function, lhs, false);
            let instance: RegIndex = this.prepareArgument(function, result, instance);
            let method: &ParsedMethod = methods.at(rhs.lhs);
            let name: String = method.getMangledName();
            let funcID: usize = this.getFunctionByName(&name);
            name.drop();
            let typ: &Type = types.at(expr.typeState.getType());
            let args: RegIndexList = blank;
            let retPtr: RegIndex = blank;
            if (typ.getSize() > 8) {
                retPtr = function.allocateRegister(types.at(typ.intoPointer()));
                function.buildAlloca(retPtr, typ.getSize());
                args.push(retPtr);
            }
            if (method.isStatic) {
                unreachable("Actually... How did we get here so far?");
                assert(rhs.arrayContext.elemLength == method.params.paramLength, "args != params");
            } else {
                assert(rhs.arrayContext.elemLength == method.params.paramLength - 1, "args != params - this");
                args.push(instance);
            }
            for (let i: usize = 0; i < rhs.arrayContext.elemLength; i = i + 1) {
                let arg: &ParsedExpr = exprs.at(rhs.arrayContext.getElementAtIndex(i));
                let argType: &Type = types.at(arg.typeState.getType());
                let result: RegIndex = this.generateBytecodeExpr(function, arg, false);
                args.push(this.prepareArgument(function, result, argType));
            }
            return this.prepareReturnValue(function, funcID, args, typ, retPtr, needsPtr);
        } else {
            unreachable("Expected name or call in generateBytecodeExprMemberAccess");
            return blank;
        }
        todo_with_msg("member");
        return blank;
    }

    func prepareReturnValue(&this, function: &IRFunc, funcID: usize, args: RegIndexList, retType: &Type, retPtr: RegIndex, needsPtr: bool) -> RegIndex {
        let retVal: RegIndex = blank;
        if (retType.getSize() > 8) {
            let reg: RegIndex = function.allocateRegister(retType);
            function.buildCall(retPtr, RegIndex { i: funcID }, args);
            if (needsPtr) {
                retVal = retPtr;
            } else {
                function.buildLoad(reg, retPtr);
                retVal = reg;
            }
        } else {
            if (retType.isStruct()) {
                let reg: RegIndex = this.getRegisterForSize(function, retType.getSize());
                function.buildCall(reg, RegIndex { i: funcID }, args);
                let v: RegIndex = function.allocateRegister(retType);
                let t: &Type = function.getRegister(v).typ;
                let r: RegIndex = function.allocateRegister(types.at(t.intoPointer()));
                let s: usize = t.getSize();
                assert(s <= 8);
                function.buildAlloca(r, s);
                function.buildStore(r, reg);
                if (needsPtr) {
                    retVal = r;
                } else {
                    function.buildLoad(v, r);
                }
                retVal = v;
            } else {
                let reg: RegIndex = function.allocateRegister(retType);
                function.buildCall(reg, RegIndex { i: funcID }, args);
                if (needsPtr) {
                    let tempAlloc: RegIndex = function.allocateRegister(types.at(retType.intoPointer()));
                    function.buildAlloca(tempAlloc, retType.getSize());
                    function.buildStore(tempAlloc, reg);
                    retVal = tempAlloc;
                } else {
                    retVal = reg;
                }
            }
        }
        let f = this.functions.at(funcID);
        assert(f != null);
        if (f.hasAttribute(ATTR_NORETURN)) {
            function.buildUnreachable();
        }
        return retVal;
    }

    func generateBytecodeExprIndexedAccess(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprIndexedAccess");
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_INDEXED_ACCESS);
        let arrExpr: &ParsedExpr = exprs.at(expr.lhs);
        let lhs: RegIndex = this.generateBytecodeExpr(function, arrExpr, true);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        assert(function.getRegister(lhs).typ.isPointer(), "Expected Ptr as LHS in IndexedAccess");
        assert(function.getRegister(rhs).typ.isInteger(), "Expected Int as RHS in IndexedAccess");
        let elemType: &Type = types.at(expr.typeState.getType());
        let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        {
            // if (index >= size) panic("Index out of bounds");
            let arrType: &Type = types.at(arrExpr.typeState.getType());
            let elemCount: usize = arrType.getSize() / elemType.getSize();
            let cond: RegIndex = function.allocateRegister(boolType);
            let size: RegIndex = function.allocateRegister(usizeType);
            let panic: IRBlockID = function.appendBlock();
            let normal: IRBlockID = function.appendBlock();
            function.buildLoadInteger(size, usizeType, elemCount);
            function.buildBinaryOp(INSTR_INT_CMP_GTE, cond, rhs, size);
            function.buildCondBr(cond, panic, normal);

            function.setCurrentBlock(panic);
            let err: RegIndex = function.allocateRegister(newType(TYPE_KIND_POINTER, TYPE_CHAR));
            // FIXME: Don't use mangled name?
            let s: String = function.name.copy();
            let _s: String = expr.span.toString();
            s.pushChar(':');
            s.pushString(&_s);
            s.pushStr(": RUNTIME ERROR: Index out of bounds: Array of size ");
            s.pushNumber(elemCount);
            s.pushStr(" has no index %d\n");
            _s.drop();
            function.buildLoadString(err, s.asSubStr());
            // FIXME: Using the module ID in mangling is awkward
            let indexoob: String = newStringFromStrLit("index_oobPci64rNf0");
            if (!this.functions.containsKey(&indexoob)) {
                fprintf(stderr, "%s Could not generate index check for array access!\n", FATAL_STR);
                fprintf(stderr, "%s: Reason: Could not find function `index_oob`!\n", NOTE_STR);
                fprintf(stderr, "%s: Please import `prelude.bufo` and try again.\n", NOTE_STR);
                exit(1);
            }
            let funcID: usize = this.getFunctionByName(&indexoob);
            let args: RegIndexList = blank;
            args.push(err);
            args.push(rhs);
            let reg: RegIndex = function.allocateRegister(newType(TYPE_KIND_PRIMITIVE, TYPE_NONE));
            function.buildCall(reg, RegIndex { i: funcID }, args);
            function.buildUnreachable();
            function.setCurrentBlock(normal);
        }
        let elemPtr: RegIndex = function.allocateRegister(types.at(elemType.intoPointer()));
        let indices: RegIndexList = blank;
        let index: RegIndex = function.allocateRegister(usizeType);
        function.buildLoadInteger(index, usizeType, 0);
        indices.push(index);
        indices.push(rhs);
        function.buildGetElementPtr(elemPtr, lhs, indices);
        if (needsPtr) {
            return elemPtr;
        } else {
            let dst: RegIndex = function.allocateRegister(elemType);
            function.buildLoad(dst, elemPtr);
            return dst;
        }
    }

    func generateBytecodeExprIdentifier(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprIdentifier");
        assert(expr.isIdentifier());
        let isGlobal: bool = false;
        let entry: &IRScopeEntry = this.getIdentifierByName(function, expr.origToken.content, &isGlobal);
        assert(entry != null, "Could not find identifier in generateBytecodeExprIdentifier");
        let varType: &Type = types.at(expr.typeState.getType());
        if (function.comptimeLevel > 0 && !entry.isComptime) {
            // REVIEW: This should've been handled before here?
            todo_with_msg("Crossing the boundary: comptime IR needs runtime value :^)");
        }
        if (needsPtr) {
            if (isGlobal) {
                let ptrType: &Type = types.at(varType.intoPointer());
                let global: RegIndex = function.allocateRegister(ptrType);
                if (entry.isComptime) {
                    let val: RegIndex = function.allocateRegister(varType);
                    function.buildAlloca(global, varType.getSize());
                    function.buildFetchGlobalComptimeValue(val, entry.ptr);
                    function.buildStore(global, val);
                } else {
                    function.buildFetchGlobalPointer(global, entry.ptr);
                }
                return global;
            } else {
                if (entry.isComptime) {
                    let ptrType: &Type = types.at(varType.intoPointer());
                    let global: RegIndex = function.allocateRegister(ptrType);
                    let val: RegIndex = function.allocateRegister(varType);
                    function.buildAlloca(global, varType.getSize());
                    function.buildFetchLocalComptimeValue(val, entry.ptr);
                    function.buildStore(global, val);
                    return global;
                } else {
                    return entry.ptr;
                }
            }
        } else {
            let val: RegIndex = function.allocateRegister(varType);
            if (isGlobal) {
                if (entry.isComptime) {
                    function.buildFetchGlobalComptimeValue(val, entry.ptr);
                } else {
                    function.buildFetchGlobalRuntimeValue(val, entry.ptr);
                }
            } else {
                if (entry.isComptime) {
                    function.buildFetchLocalComptimeValue(val, entry.ptr);
                } else {
                    function.buildLoad(val, entry.ptr);
                }
            }
            return val;
        }
    }

    func generateBytecodeExprArithmetic(&this, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
        trace("IRGen.generateBytecodeExprArithmetic");
        assert(expr.isArithmetic());
        let lhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        let lhsType: &Type = types.at(exprs.at(expr.lhs).typeState.getType());
        let rhsType: &Type = types.at(exprs.at(expr.rhs).typeState.getType());
        let res: &Type = types.at(expr.typeState.getType());
        let dst: RegIndex = function.allocateRegister(res);
        // OPT: Specialized 8bit, 16bit, etc. variations
        if (expr.op == BIN_PLUS) {
            if ((lhsType.isInteger() || lhsType.isChar()) && (rhsType.isInteger() || rhsType.isChar())) {
                function.buildBinaryOp(INSTR_INT_ADD, dst, lhs, rhs);
            } else if (lhsType.isPointer() && rhsType.isInteger()) {
                assert(res.isPointer(), "PTR + INT expected to be PTR");
                function.buildPtrToInt(lhs, lhs);
                function.buildBinaryOp(INSTR_INT_ADD, dst, lhs, rhs);
                function.buildIntToPtr(dst, dst);
            } else if (lhsType.isInteger() && rhsType.isPointer()) {
                assert(res.isPointer(), "INT + PTR expected to be PTR");
                function.buildPtrToInt(rhs, rhs);
                function.buildBinaryOp(INSTR_INT_ADD, dst, lhs, rhs);
                function.buildIntToPtr(dst, dst);
            } else if (lhsType.isFloat() && rhsType.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_ADD, dst, lhs, rhs);
            } else {
                todo_with_msg("non-int add");
            }
        } else if (expr.op == BIN_SUB) {
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            if ((lhsType.isInteger() || lhsType.isChar()) && (rhsType.isInteger() || rhsType.isChar())) {
                function.buildBinaryOp(INSTR_INT_SUB, dst, lhs, rhs);
            } else if (lhsType.isPointer() && rhsType.isInteger()) {
                assert(res.isPointer(), "PTR - INT expected to be PTR");
                let tmp1: RegIndex = function.allocateRegister(usizeType);
                let tmp2: RegIndex = function.allocateRegister(usizeType);
                function.buildPtrToInt(tmp1, lhs);
                function.buildBinaryOp(INSTR_INT_SUB, tmp2, tmp1, rhs);
                function.buildIntToPtr(dst, tmp2);
            } else if (lhsType.isInteger() && rhsType.isPointer()) {
                assert(res.isPointer(), "INT - PTR expected to be PTR");
                let tmp1: RegIndex = function.allocateRegister(usizeType);
                let tmp2: RegIndex = function.allocateRegister(usizeType);
                function.buildPtrToInt(tmp1, rhs);
                function.buildBinaryOp(INSTR_INT_SUB, tmp2, lhs, tmp1);
                function.buildIntToPtr(dst, tmp2);
            } else if (lhsType.isPointer() && rhsType.isPointer()) {
                assert(res.isInteger(), "PTR - PTR expected to be INT");
                let tmp1: RegIndex = function.allocateRegister(usizeType);
                let tmp2: RegIndex = function.allocateRegister(usizeType);
                function.buildPtrToInt(tmp1, lhs);
                function.buildPtrToInt(tmp2, rhs);
                function.buildBinaryOp(INSTR_INT_SUB, dst, tmp1, tmp2);
            } else if (lhsType.isFloat() && rhsType.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_SUB, dst, lhs, rhs);
            } else {
                todo_with_msg("non-int sub");
            }
        } else if (expr.op == BIN_MULT) {
            if (res.isInteger()) {
                function.buildBinaryOp(INSTR_INT_MUL, dst, lhs, rhs);
            } else if (res.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_MUL, dst, lhs, rhs);
            } else {
                todo_with_msg("non-int mul");
            }
        } else if (expr.op == BIN_DIV) {
            if (res.isInteger()) {
                function.buildBinaryOp(INSTR_INT_DIV, dst, lhs, rhs);
            } else if (res.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_DIV, dst, lhs, rhs);
            } else {
                todo_with_msg("non-int non-float div");
            }
        } else if (expr.op == BIN_MOD) {
            if (res.isInteger()) {
                function.buildBinaryOp(INSTR_INT_MOD, dst, lhs, rhs);
            } else if (res.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_MOD, dst, lhs, rhs);
            } else {
                todo_with_msg("non-int mod");
            }
        } else {
            unreachable("Exhaustive handling of ops in generateBytecodeExprArithmetic (I think)");
        }
        return dst;
    }

    func generateBytecodeExprComparison(&this, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
        trace("IRGen.generateBytecodeExprComparison");
        assert(expr.isComparison());
        let lhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        let res: &Type = types.at(expr.typeState.getType());
        assert(res.isBoolean(), "Comparison expected to evaluate to Bool");
        let dst: RegIndex = function.allocateRegister(res);
        // OPT: Specialized 8bit, 16bit, etc. variations
        let t: &Type = function.getRegister(lhs).typ;
        if (expr.op == BIN_CMP_EQ) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_EQ, dst, lhs, rhs);
            } else if (t.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_CMP_EQ, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_EQ");
            }
        } else if (expr.op == BIN_CMP_NEQ) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_NEQ, dst, lhs, rhs);
            } else if (t.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_CMP_NEQ, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_NEQ");
            }
        } else if (expr.op == BIN_CMP_GT) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_GT, dst, lhs, rhs);
            } else if (t.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_CMP_GT, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_GT");
            }
        } else if (expr.op == BIN_CMP_GTE) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_GTE, dst, lhs, rhs);
            } else if (t.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_CMP_GTE, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_GTE");
            }
        } else if (expr.op == BIN_CMP_LT) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_LT, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_LT");
            }
        } else if (expr.op == BIN_CMP_LTE) {
            if (t.isInteger() || t.isChar() || t.isPointer() || t.isBoolean()) {
                function.buildBinaryOp(INSTR_INT_CMP_LTE, dst, lhs, rhs);
            } else if (t.isFloat()) {
                function.buildBinaryOp(INSTR_FLOAT_CMP_LTE, dst, lhs, rhs);
            } else {
                todo_with_msg("IRGen CMP_LTE");
            }
        } else {
            unreachable("Exhaustive handling of ops in generateBytecodeExprComparison");
        }
        return dst;
    }

    func generateBytecodeExprLogical(&this, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
        trace("IRGen.generateBytecodeExprLogical");
        assert(expr.isLogical());
        let lhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        let t: &Type = types.at(expr.typeState.getType());
        let dst: RegIndex = function.allocateRegister(t);
        if (expr.op == BIN_LAND) {
            function.buildBinaryOp(INSTR_LOGICAL_AND, dst, lhs, rhs);
        } else if (expr.op == BIN_LOR) {
            function.buildBinaryOp(INSTR_LOGICAL_OR, dst, lhs, rhs);
        } else {
            unreachable("Exhaustive handling of ops in generateBytecodeExprLogical");
        }
        return dst;
    }

    func generateBytecodeExprBitwise(&this, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
        trace("IRGen.generateBytecodeExprBitwise");
        assert(expr.isBitwise());
        let lhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        let t: &Type = types.at(expr.typeState.getType());
        let dst: RegIndex = function.allocateRegister(t);
        if (expr.op == BIN_BAND) {
            function.buildBinaryOp(INSTR_BITWISE_AND, dst, lhs, rhs);
        } else if (expr.op == BIN_BOR) {
            function.buildBinaryOp(INSTR_BITWISE_OR, dst, lhs, rhs);
        } else if (expr.op == BIN_BXOR) {
            function.buildBinaryOp(INSTR_BITWISE_XOR, dst, lhs, rhs);
        } else {
            unreachable("Exhaustive handling of ops in generateBytecodeExprBitwise");
        }
        return dst;
    }

    func generateBytecodeExprLiteral(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprLiteral");
        assert(expr.isLiteral());
        let t: &Type = types.at(expr.typeState.getType());
        let reg: RegIndex = function.allocateRegister(t);
        if (expr.kind == EXPR_INT_LIT) {
            if (t.isInteger()) {
                let _value: u64 = expr.origToken.content.toU64();
                let value: usize = _value as usize;
                let size: usize = bitCount(value);
                let typsize: usize = t.getSize() * 8;
                if (size > typsize) {
                    fprintf(stderr, "%llu %llu\n", size, typsize);
                    todo_with_msg("int literal bigger than type can hold");
                }
                function.buildLoadInteger(reg, t, value);
            } else if (t.isFloat()) {
                let value: f64 = expr.origToken.content.toF64();
                assert(value >= 0, "Expected FloatLit value to be positive");
                let typmax: f64 = t.getMaxFloatValue();
                if (value >= typmax) {
                    todo_with_msg("float literal bigger than type can hold");
                }
                if (t.getSize() == 4) function.buildLoadF32(reg, value as f32);
                else if (t.getSize() == 8) function.buildLoadF64(reg, value);
                else unreachable("load float");
            } else {
                unreachable("EXPR_LIT expected to be int or float");
            }
        } else if (expr.kind == EXPR_STRING_LIT) {
            assert(t.isPointerTo(TYPE_CHAR), "StrLit expected to be &char");
            let name: SubStr = expr.origToken.content;
            function.buildLoadString(reg, name);
        } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
            assert(t.isBoolean(), "true and false expected to be bool");
            let v: usize = 0;
            if (expr.kind == EXPR_TRUE) v = 1;
            function.buildLoadBool(reg, v);
        } else if (expr.kind == EXPR_NULL) {
            assert(t.isPointer(), "null expected to be pointer");
            function.buildLoadNull(reg);
        } else if (expr.kind == EXPR_CHAR_LIT) {
            assert(t.isChar(), "CharLit expected to be char");
            function.buildLoadInteger(reg, t, expr.origToken.content.getChar(0) as usize);
        } else if (expr.kind == EXPR_ARRAY_LIT) {
            assert(t.isArray(), "ArrayLit expected to be array");
            if (t.getSize() > 4096) warning("Array Literal is big and slows down the IR");
            if (expr.arrayContext.size == 0) {
                function.buildCreateArray(reg);
                for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
                    let elem: &ParsedExpr = exprs.at(expr.arrayContext.getElementAtIndex(i));
                    let result: RegIndex = this.generateBytecodeExpr(function, elem, false);
                    function.buildInsertValue(reg, i, result);
                }
            } else {
                let elem: &ParsedExpr = exprs.at(expr.arrayContext.getElementAtIndex(0));
                let value: RegIndex = this.generateBytecodeExpr(function, elem, false);
                let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
                let elemType: &Type = types.at(elem.typeState.getType());
                let arrayPtr: RegIndex = function.allocateRegister(types.at(t.intoPointer()));
                let zero: RegIndex = function.allocateRegister(usizeType);
                let one: RegIndex = function.allocateRegister(usizeType);
                let index: RegIndex = function.allocateRegister(usizeType);
                let indexPtr: RegIndex = function.allocateRegister(types.at(usizeType.intoPointer()));
                let size: RegIndex = function.allocateRegister(usizeType);
                let cond: RegIndex = function.allocateRegister(boolType);
                let elemPtr: RegIndex = function.allocateRegister(elemType);

                let start: IRBlockID = function.appendBlock();
                let body: IRBlockID = function.appendBlock();
                let end: IRBlockID = function.appendBlock();

                function.buildAlloca(arrayPtr, t.getSize());
                function.buildAlloca(indexPtr, usizeType.getSize());
                function.buildLoadInteger(zero, usizeType, 0);
                function.buildLoadInteger(one, usizeType, 1);
                function.buildStore(indexPtr, zero);
                function.buildLoadInteger(size, usizeType, expr.arrayContext.size);
                function.buildBr(start);

                function.setCurrentBlock(start);
                function.buildLoad(index, indexPtr);
                function.buildBinaryOp(INSTR_INT_CMP_LT, cond, index, size);
                function.buildCondBr(cond, body, end);

                function.setCurrentBlock(body);
                let indices: RegIndexList = blank;
                indices.push(zero);
                indices.push(index);
                function.buildGetElementPtr(elemPtr, arrayPtr, indices);
                function.buildStore(elemPtr, value);

                function.buildLoad(index, indexPtr);
                function.buildBinaryOp(INSTR_INT_ADD, index, index, one);
                function.buildStore(indexPtr, index);
                function.buildBr(start);

                function.setCurrentBlock(end);
                if (needsPtr) {
                    return arrayPtr;
                } else {
                    function.buildLoad(reg, arrayPtr);
                    return reg;
                }
            }
        } else {
            todo_with_msg("gen Literal");
        }
        return reg;
    }

    func generateBytecodeExprAssignment(&this, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
        trace("IRGen.generateBytecodeExprAssignment");
        assert(expr.isAssignment());
        let lhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), true);
        let rhs: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.rhs), false);
        assert(function.getRegister(lhs).typ.isPointer(), "Assignment expected Ptr as LHS");
        function.buildStore(lhs, rhs);
        return rhs;
    }

    func generateBytecodeExprUnary(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprUnary");
        assert(expr.isUnary());
        if (expr.op == UNARY_COMPTIME) {
            function.startComptime();
            let subexpr: &ParsedExpr = exprs.at(expr.lhs);
            let result: RegIndex = this.generateBytecodeExpr(function, subexpr, false);
            let exprType = types.at(expr.typeState.getType());
            let r: RegIndex = function.allocateRegister(exprType);
            function.endComptime();
            function.buildFetchLocalComptimeValue(r, result);
            if (needsPtr) {
                let subType: &Type = types.at(exprType.intoPointer());
                let ptr: RegIndex = function.allocateRegister(subType);
                function.buildAlloca(ptr, exprType.getSize());
                function.buildStore(ptr, r);
                return ptr;
            } else {
                return r;
            }
        } else if (expr.op == UNARY_DEREF) {
            let subexpr: &ParsedExpr = exprs.at(expr.lhs);
            let result: RegIndex = this.generateBytecodeExpr(function, subexpr, false);
            let ptr: &IRReg = function.getRegister(result);
            assert(ptr.typ.isPointer(), "Expected Ptr SubExpr in Unary Deref");
            if (needsPtr) {
                return result;
            } else {
                let t: &Type = types.at(expr.typeState.getType());
                let val: RegIndex = function.allocateRegister(t);
                function.buildLoad(val, result);
                return val;
            }
        } else if (expr.op == UNARY_REF) {
            let subExpr: &ParsedExpr = exprs.at(expr.lhs);
            let result: RegIndex = this.generateBytecodeExpr(function, subExpr, true);
            let ptrReg: &IRReg = function.getRegister(result);
            if (needsPtr || !ptrReg.typ.isPointer()) {
                let subType: &Type = types.at(ptrReg.typ.intoPointer());
                let ptr: RegIndex = function.allocateRegister(subType);
                function.buildAlloca(ptr, ptrReg.typ.getSize());
                function.buildStore(ptr, result);
                return ptr;
            } else {
                return result;
            }
        } else if (expr.op == UNARY_NOT) {
            let result: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
            let r: RegIndex = function.allocateRegister(types.at(expr.typeState.getType()));
            function.buildLogicalNot(r, result);
            return r;
        } else if (expr.op == UNARY_MINUS) {
            let result: RegIndex = this.generateBytecodeExpr(function, exprs.at(expr.lhs), false);
            let t: &Type = types.at(expr.typeState.getType());
            if (t.isInteger()) {
                let zero: RegIndex = function.allocateRegister(t);
                function.buildLoadInteger(zero, t, 0);
                function.buildBinaryOp(INSTR_INT_SUB, result, zero, result);
            } else if (t.isFloat()) {
                let zero: RegIndex = function.allocateRegister(t);
                if (t.getSize() == 4) function.buildLoadF32(zero, 0);
                else if (t.getSize() == 8) function.buildLoadF64(zero, 0);
                else unreachable("negation float");
                function.buildBinaryOp(INSTR_FLOAT_SUB, result, zero, result);
            } else {
                todo_with_msg("neg non-int");
            }
            return result;
        } else {
            todo_with_msg("unknown unary");
        }
        todo_with_msg("gen Unary");
        return blank;
    }

    func prepareParameter(&this, function: &IRFunc, index: usize, name: SubStr, typ: &Type, retValue: bool) {
        trace("IRGen.prepareParameter");
        if (typ.isStruct()) {
            let size: usize = typ.getSize();
            let t: &Type = null;
            if (size <= 1) {
                t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
            } else if (size <= 2) {
                t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
            } else if (size <= 4) {
                t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
            } else if (size <= 8) {
                t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
            } else {
                t = newType(TYPE_KIND_POINTER, TYPE_U8);
            }
            let value: RegIndex = function.allocateRegister(t);
            function.buildGetParam(value, index, t.getSize());
            // value contains prepared struct
            let allocType: &Type = types.at(typ.intoPointer());
            let allocReg: RegIndex = function.allocateRegister(allocType);
            if (t.isPointer()) {
                let instance: RegIndex = function.allocateRegister(typ);
                function.buildLoad(instance, value);

                function.buildAlloca(allocReg, typ.getSize());
                function.buildStore(allocReg, instance);
                function.scopes.last().addEntry(name, allocReg, false);
            } else {
                function.buildAlloca(allocReg, typ.getSize());
                function.buildStore(allocReg, value);
                function.scopes.last().addEntry(name, allocReg, false);
            }
        } else if (typ.getSize() > 8) {
            todo_with_msg("prepare urmom");
        } else {
            let allocType: &Type = types.at(typ.intoPointer());
            let allocReg: RegIndex = function.allocateRegister(allocType);
            let value: RegIndex = function.allocateRegister(typ);
            function.buildGetParam(value, index, typ.getSize());

            if (retValue) {
                assert(index == 0);
                (*function).retPtr = value;
            } else {
                function.buildAlloca(allocReg, typ.getSize());
                function.buildStore(allocReg, value);
                function.scopes.last().addEntry(name, allocReg, false);
            }
        }
    }

    func getRegisterForSize(&this, function: &IRFunc, size: usize) -> RegIndex {
        trace("IRGen.getRegisterForSize");
        let v: RegIndex = blank;
        if (size <= 1) {
            v = function.allocateRegister(newType(TYPE_KIND_PRIMITIVE, TYPE_U8));
        } else if (size <= 2) {
            v = function.allocateRegister(newType(TYPE_KIND_PRIMITIVE, TYPE_U16));
        } else if (size <= 4) {
            v = function.allocateRegister(newType(TYPE_KIND_PRIMITIVE, TYPE_U32));
        } else if (size <= 8) {
            v = function.allocateRegister(newType(TYPE_KIND_PRIMITIVE, TYPE_U64));
        } else {
            unreachable("getRegisterForSize called with size > 8");
        }
        return v;
    }

    func prepareArgument(&this, function: &IRFunc, value: RegIndex, typ: &Type) -> RegIndex {
        trace("IRGen.prepareArgument");
        if (typ.isStruct()) {
            let size: usize = typ.getSize();
            let alloc: RegIndex = function.allocateRegister(types.at(typ.intoPointer()));
            function.buildAlloca(alloc, size);
            function.buildStore(alloc, value);
            if (size > 8) return alloc;
            let v: RegIndex = this.getRegisterForSize(function, size);
            function.buildLoad(v, alloc);
            return v;
        } else if (typ.getSize() > 8) {
            // Following the ABI, all parameters that don't fit in a register get passed by pointer
            let tempAlloc: RegIndex = function.allocateRegister(types.at(typ.intoPointer()));
            function.buildAlloca(tempAlloc, typ.getSize());
            function.buildStore(tempAlloc, value);
            return tempAlloc;
        } else {
            return value;
        }
    }

    func generateBytecodeExprCall(&this, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
        trace("IRGen.generateBytecodeExprCall");
        assert(expr.isCall());
        let typ: &Type = types.at(expr.typeState.getType());
        let args: RegIndexList = blank;
        let reg: RegIndex = function.allocateRegister(typ);
        let retPtr: RegIndex = blank;
        if (typ.getSize() > 8) {
            retPtr = function.allocateRegister(types.at(typ.intoPointer()));
            function.buildAlloca(retPtr, typ.getSize());
            args.push(retPtr);
        }
        for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
            let arg: &ParsedExpr = exprs.at(expr.arrayContext.getElementAtIndex(i));
            let argType: &Type = types.at(arg.typeState.getType());
            let result: RegIndex = this.generateBytecodeExpr(function, arg, false);
            args.push(this.prepareArgument(function, result, argType));
        }
        let name: String = funcDecls.at(expr.lhs).getMangledName();
        let funcID: usize = this.getFunctionByName(&name);
        name.drop();
        return this.prepareReturnValue(function, funcID, args, typ, retPtr, needsPtr);
    }
}

func newIRGenerator() -> IRGen {
    return IRGen {
        globalScope: IRFunc {
            name: newStringFromStrLit("__global__"),
            isMethod: false,
            originalID: funcDecls.length + 1,
            comptimeLevel: 0,
            scopes: blank,
            registers: blank,
            blocks: blank,
            loopBlocks: blank,
            currentBlock: blank,
            llvmFunc: blank,
            retPtr: blank,
            attrs: blank,
        },
        functions: blank,
    };
}
