import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/hashmaps.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../frontend/lexer.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./LLVM/values.bufo";

struct RegIndex {
    i: usize;
}
func equals(this: &RegIndex, other: &RegIndex) -> bool {
    return this.i == other.i;
}

struct IRReg {
    isComptime: bool;
    offset: usize;
    typ: &Type;
}
func equals(this: &IRReg, other: &IRReg) -> bool {
    unreachable("IRReg.equals is not implemented yet");
}

// NOTE: When you update this list, you must also update the function pointers in the interpreter
comptime INSTR_INVALID: usize = 0;
comptime INSTR_ALLOCA: usize = 1;
comptime INSTR_GET_PARAM: usize = 2;
comptime INSTR_STORE: usize = 3;
comptime INSTR_FETCH_GLOBAL_PTR: usize = 4;
comptime INSTR_FETCH_GLOBAL_VALUE: usize = 5;
comptime INSTR_FETCH_COMPTIME_VALUE: usize = 6;
comptime INSTR_LOAD_FUNCTION_PTR: usize = 7;
comptime INSTR_LOAD: usize = 8;
comptime INSTR_MOVE: usize = 9;
comptime INSTR_CALL: usize = 10;
comptime INSTR_RETURN_EXPR: usize = 11;
comptime INSTR_RETURN_VOID: usize = 12;
comptime INSTR_LOAD_STRING: usize = 13;
comptime INSTR_LOAD_BOOL: usize = 14;
comptime INSTR_LOAD_I8: usize = 15;
comptime INSTR_LOAD_U8: usize = 16;
comptime INSTR_LOAD_I16: usize = 17;
comptime INSTR_LOAD_U16: usize = 18;
comptime INSTR_LOAD_I32: usize = 19;
comptime INSTR_LOAD_U32: usize = 20;
comptime INSTR_LOAD_I64: usize = 21;
comptime INSTR_LOAD_U64: usize = 22;
comptime INSTR_LOAD_NULL: usize = 23;
comptime INSTR_LOAD_F32: usize = 24;
comptime INSTR_LOAD_F64: usize = 25;
comptime INSTR_LOAD_BLANK: usize = 26;
comptime INSTR_COND_BR: usize = 27;
comptime INSTR_BR: usize = 28;
comptime INSTR_INT_ADD: usize = 29;
comptime INSTR_INT_SUB: usize = 30;
comptime INSTR_INT_MUL: usize = 31;
comptime INSTR_INT_DIV: usize = 32;
comptime INSTR_INT_MOD: usize = 33;
comptime INSTR_INT_CMP_EQ: usize = 34;
comptime INSTR_INT_CMP_NEQ: usize = 35;
comptime INSTR_INT_CMP_GT: usize = 36;
comptime INSTR_INT_CMP_GTE: usize = 37;
comptime INSTR_INT_CMP_LT: usize = 38;
comptime INSTR_INT_CMP_LTE: usize = 39;
comptime INSTR_FLOAT_ADD: usize = 40;
comptime INSTR_FLOAT_SUB: usize = 41;
comptime INSTR_FLOAT_MUL: usize = 42;
comptime INSTR_FLOAT_DIV: usize = 43;
comptime INSTR_FLOAT_MOD: usize = 44;
comptime INSTR_FLOAT_CMP_EQ: usize = 45;
comptime INSTR_FLOAT_CMP_NEQ: usize = 46;
comptime INSTR_FLOAT_CMP_GT: usize = 47;
comptime INSTR_FLOAT_CMP_GTE: usize = 48;
comptime INSTR_FLOAT_CMP_LT: usize = 49;
comptime INSTR_FLOAT_CMP_LTE: usize = 50;
comptime INSTR_LOGICAL_NOT: usize = 51;
comptime INSTR_LOGICAL_AND: usize = 52;
comptime INSTR_LOGICAL_OR: usize = 53;
comptime INSTR_BITWISE_AND: usize = 54;
comptime INSTR_BITWISE_OR: usize = 55;
comptime INSTR_BITWISE_XOR: usize = 56;
comptime INSTR_INSERT_VALUE: usize = 57;
comptime INSTR_INT_SIGN_EXTEND: usize = 58;
comptime INSTR_INT_ZERO_EXTEND: usize = 59;
comptime INSTR_INT_TRUNCATE: usize = 60;
comptime INSTR_INT_TO_F32: usize = 61;
comptime INSTR_INT_TO_F64: usize = 62;
comptime INSTR_F32_TO_INT: usize = 63;
comptime INSTR_F64_TO_INT: usize = 64;
comptime INSTR_F32_TO_F64: usize = 65;
comptime INSTR_F64_TO_F32: usize = 66;
comptime INSTR_CREATE_ARRAY: usize = 67;
comptime INSTR_CREATE_STRUCT: usize = 68;
comptime INSTR_CREATE_UNION: usize = 69;
comptime INSTR_PTR_TO_INT: usize = 70;
comptime INSTR_INT_TO_PTR: usize = 71;
comptime INSTR_GET_FIELD_PTR: usize = 72;
comptime INSTR_GET_ELEMENT_PTR: usize = 73;
comptime INSTR_UNREACHABLE: usize = 74;
comptime INSTR_UNTERMINATED: usize = 75;
comptime INSTR_MEMCPY: usize = 76;
struct IRInstr {
    kind: usize;
    span: Span;
    isComptime: bool;
    dst: RegIndex;
    src: RegIndex;
    op1: RegIndex;
    args: RegIndexList;
}
func equals(this: &IRInstr, other: &IRInstr) -> bool {
    unreachable("IRInstr.equals is not implemented yet");
}
func isTerminator(this: &IRInstr) -> bool {
    return this.kind == INSTR_RETURN_EXPR
        || this.kind == INSTR_RETURN_VOID
        || this.kind == INSTR_COND_BR
        || this.kind == INSTR_BR
        || this.kind == INSTR_UNREACHABLE
        || this.kind == INSTR_UNTERMINATED;
}
func dump(this: &IRInstr) {
    if (!*flags.emitBIR && this.isComptime) printf("\x1b[92m");
    if (PRINT_DEBUG) {
        let s = toString(&this.span);
        printf("%s ", s.buffer);
        drop(&s);
    }
    if (this.kind == INSTR_ALLOCA) printf("r%llu = Alloca %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_PARAM) printf("r%llu = GetParam %llu (%llu bytes)", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_STORE) printf("Store r%llu, r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_PTR) printf("r%llu = FetchGlobalPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_VALUE) printf("r%llu = FetchGlobalValue r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_COMPTIME_VALUE) printf("r%llu = FetchComptimeValue r%llu, global=%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD) printf("r%llu = Load r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_FUNCTION_PTR) printf("r%llu = LoadFunctionPtr %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_MOVE) printf("r%llu = Move r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CALL) {
        printf("r%llu = Call r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            printf(", r%llu", at(&this.args, i).i);
        }
    } else if (this.kind == INSTR_RETURN_EXPR) printf("RetExpr r%llu", this.src.i);
    else if (this.kind == INSTR_RETURN_VOID) printf("RetVoid");
    else if (this.kind == INSTR_LOAD_STRING) printf("r%llu = LoadString %p, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD_BOOL) printf("r%llu = Load Bool %hhu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I8) printf("r%llu = Load I8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U8) printf("r%llu = Load U8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I16) printf("r%llu = Load I16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U16) printf("r%llu = Load U16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I32) printf("r%llu = Load I32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U32) printf("r%llu = Load U32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I64) printf("r%llu = Load I64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U64) printf("r%llu = Load U64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_NULL) printf("r%llu = Load Null", this.dst.i);
    else if (this.kind == INSTR_LOAD_F32) printf("r%llu = Load F32 %f", this.dst.i, *(&this.src.i as &f32) as f64);
    else if (this.kind == INSTR_LOAD_F64) printf("r%llu = Load F64 %f", this.dst.i, *(&this.src.i as &f64));
    else if (this.kind == INSTR_LOAD_BLANK) printf("r%llu = Load Blank", this.dst.i);
    else if (this.kind == INSTR_COND_BR) printf("CondBr r%llu, true=%llu, false=%llu", this.src.i, this.dst.i, this.op1.i);
    else if (this.kind == INSTR_BR) printf("Br %llu", this.dst.i);
    else if (this.kind == INSTR_INT_ADD) printf("r%llu = AddInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SUB) printf("r%llu = SubInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MUL) printf("r%llu = MulInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_DIV) printf("r%llu = DivInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MOD) printf("r%llu = ModInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_EQ) printf("r%llu = ICmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_NEQ) printf("r%llu = ICmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GT) printf("r%llu = ICmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GTE) printf("r%llu = ICmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LT) printf("r%llu = ICmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LTE) printf("r%llu = ICmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_ADD) printf("r%llu = AddFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_SUB) printf("r%llu = SubFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MUL) printf("r%llu = MulFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_DIV) printf("r%llu = DivFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MOD) printf("r%llu = ModFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_EQ) printf("r%llu = FCmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_NEQ) printf("r%llu = FCmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GT) printf("r%llu = FCmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GTE) printf("r%llu = FCmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LT) printf("r%llu = FCmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LTE) printf("r%llu = FCmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_NOT) printf("r%llu = LNot r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOGICAL_AND) printf("r%llu = LAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_OR) printf("r%llu = LOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_AND) printf("r%llu = BAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_OR) printf("r%llu = BOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_XOR) printf("r%llu = BXOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INSERT_VALUE) printf("r%llu = InsertValue r%llu, %llu, r%llu", this.dst.i, this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SIGN_EXTEND) printf("r%llu = IntSExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_ZERO_EXTEND) printf("r%llu = IntZExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TRUNCATE) printf("r%llu = IntTrunc r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TO_F32) printf("r%llu = IntToF32 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_INT) printf("r%llu = F32ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_INT) printf("r%llu = F64ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_F64) printf("r%llu = FloatExt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_F32) printf("r%llu = FloatTrunc r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CREATE_ARRAY) printf("r%llu = CreateArray", this.dst.i);
    else if (this.kind == INSTR_CREATE_STRUCT) printf("r%llu = CreateStruct", this.dst.i);
    else if (this.kind == INSTR_CREATE_UNION) printf("r%llu = CreateUnion", this.dst.i);
    else if (this.kind == INSTR_PTR_TO_INT) printf("r%llu = PtrToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_PTR) printf("r%llu = IntToPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_FIELD_PTR) printf("r%llu = GetFieldPtr r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_UNREACHABLE) printf("unreachable");
    else if (this.kind == INSTR_UNTERMINATED) printf("<unterminated block>");
    else if (this.kind == INSTR_MEMCPY) printf("Memcpy r%llu, r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_GET_ELEMENT_PTR) {
        printf("r%llu = GetElementPtr r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            printf(", r%llu", at(&this.args, i).i);
        }
    } else {
        fprintf(stderr, "kind: %llu\n", this.kind);
        unreachable("Exhaustive handling in IRInstr.dump()");
    }
    if (!*flags.emitBIR && this.isComptime) printf("\x1b[0m\n"); else printf("\n");
}

struct LoopBlock {
    before: IRBlockID;
    after: IRBlockID;
}
func equals(this: &LoopBlock, other: &LoopBlock) -> bool {
    return this.before.i == other.before.i && this.after.i == other.after.i;
}

struct IRBlockID {
    i: usize;
}
struct IRBlock {
    parent: String;
    id: IRBlockID;
    instructions: IRInstrList;
}
func equals(this: &IRBlock, other: &IRBlock) -> bool {
    return equals(&this.parent, &other.parent) && this.id.i == other.id.i;
}
func isTerminated(this: &IRBlock) -> bool {
    trace("IRBlock.isTerminated");
    if (this.instructions.length == 0) return false;
    return isTerminator(last(&this.instructions));
}
func dump(this: &IRBlock) {
    printf("b%llu:\n", this.id);
    for (let i: usize = 0; i < this.instructions.length; i = i + 1) {
        printf("  %4d: ", i);
        dump(at(&this.instructions, i));
    }
}
func pushInstruction(this: &IRBlock, instr: IRInstr) {
    trace("IRBlock.pushInstruction");
    push(&this.instructions, instr);
}

struct IRFunc {
    originalID: usize;
    name: String;
    span: Span;
    comptimeLevel: usize;
    scopes: IRScopeList;
    registers: IRRegList;
    blocks: IRBlockList;
    loopBlocks: LoopBlockList;
    currentBlock: IRBlockID;
    llvmFunc: LLVMValue;
    retPtr: RegIndex;
    attrs: ParsedAttributeList;
    returnBlockID: IRBlockID;
    returnAlloc: RegIndex;
}
func hasAttribute(this: &IRFunc, attr: usize) -> bool {
    trace("IRFunc.hasAttribute");
    for (let i: usize = 0; i < this.attrs.length; i = i + 1) {
        if (at(&this.attrs, i).kind == attr) return true;
    }
    return false;
}
func isExtern(this: &IRFunc) -> bool {
    return isExtern(getFuncNode(this));
}
func appendBlock(this: &IRFunc) -> IRBlockID {
    let id: IRBlockID = IRBlockID { i: this.blocks.length };
    push(&this.blocks, IRBlock {
        parent: this.name,
        id: id,
    });
    return id;
}
func setCurrentBlock(this: &IRFunc, id: IRBlockID) {
    assert(id.i < this.blocks.length, "setCurrentBlock called with invalid ID");
    this.currentBlock = id;
}
func getCurrentBlock(this: &IRFunc) -> IRBlockID {
    assert(this.blocks.length > 0, "getCurrentBlock called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlock points to invalid block");
    return this.currentBlock;
}
func getCurrentBlockAsRef(this: &IRFunc) -> &IRBlock {
    assert(this.blocks.length > 0, "getCurrentBlockAsRef called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlockAsRef points to invalid block");
    return at(&this.blocks, this.currentBlock.i);
}
func getBlockByID(this: &IRFunc, id: IRBlockID) -> &IRBlock {
    assert(this.blocks.length > 0, "getBlockByID called on empty IRFunc");
    assert(id.i < this.blocks.length, "getBlockByID called with invalid ID");
    return at(&this.blocks, id.i);
}
func pushLoopBlocks(this: &IRFunc, before: IRBlockID, after: IRBlockID) {
    push(&this.loopBlocks, LoopBlock {
        before: before,
        after: after,
    });
}
func popLoopBlocks(this: &IRFunc) {
    pop(&this.loopBlocks);
}
func getFuncNode(this: &IRFunc) -> &ParsedFuncDecl {
    return at(&funcDecls, this.originalID);
}
func dumpInstructions(this: &IRFunc) {
    printf("%s:\n", this.name.buffer);
    for (let i: usize = 0; i < this.blocks.length; i = i + 1) {
        dump(at(&this.blocks, i));
    }
}
func equals(this: &IRFunc, other: &IRFunc) -> bool {
    unreachable("IRFunc.equals is not implemented yet");
}
func enterScope(this: &IRFunc) -> usize {
    push(&this.scopes, blank);
    return this.scopes.length;
}
func leaveScope(this: &IRFunc) -> usize {
    let s: usize = this.scopes.length;
    pop(&this.scopes);
    return s;
}
func startComptime(this: &IRFunc) {
    this.comptimeLevel = this.comptimeLevel + 1;
}
func endComptime(this: &IRFunc) {
    assert(this.comptimeLevel > 0);
    this.comptimeLevel = this.comptimeLevel - 1;
}
func getRegisterSizeInBytes(this: &IRFunc) -> usize {
    let size: usize = 0;
    for (let i: usize = 0; i < this.registers.length; i = i + 1) {
        let reg: &IRReg = getRegister(this, RegIndex { i: i });
        size = size + getSize(reg.typ);
    }
    return size;
}
func allocateRegister(this: &IRFunc, typ: &Type) -> RegIndex {
    trace("IRFunc.allocateRegister");
    let size: usize = this.registers.length;
    let offset: usize = 0;
    if (size > 0) {
        let last: &IRReg = last(&this.registers);
        offset = last.offset + getSize(last.typ);
    }
    push(&this.registers, IRReg {
        isComptime: this.comptimeLevel > 0,
        offset: offset,
        typ: typ,
    });
    return RegIndex { i: size };
}
func getRegister(this: &IRFunc, index: RegIndex) -> &IRReg {
    assert(index.i < this.registers.length, "Out of bounds access in IRFunc.getRegister");
    return at(&this.registers, index.i);
}
func getIdentifierByName(this: &IRFunc, name: SubStr) -> &IRScopeEntry {
    trace("IRFunc.getIdentifierByName");
    for (let _i: usize = 0; _i < this.scopes.length; _i = _i + 1) {
        let i: usize = this.scopes.length - _i - 1;
        let entry: &IRScopeEntry = getIdentifierByName(at(&this.scopes, i), name);
        if (entry != null) {
            return entry;
        }
    }
    return null;
}
func pushInstruction(this: &IRFunc, instr: IRInstr) {
    trace("IRFunc.pushInstruction");
    assert(this.blocks.length > 0, "IRFunc.pushInstruction called on empty block list");
    assert(this.currentBlock.i < this.blocks.length, "IRFunc.pushInstruction: Current block was invalid");
    pushInstruction(at(&this.blocks, this.currentBlock.i), instr);
}
func buildAlloca(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    let alloca: IRInstr = IRInstr {
        kind: INSTR_ALLOCA,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    };
    let entry: &IRBlock = getBlockByID(this, IRBlockID { i: 0 });
    if (isTerminated(entry)) {
        assert(entry.instructions.length > 0);
        pushInstruction(entry, alloca);
        let l: usize = entry.instructions.length;
        let last: &IRInstr = at(&entry.instructions, l - 1);
        let prev: &IRInstr = at(&entry.instructions, l - 2);
        let i1: IRInstr = *last;
        *last = *prev;
        *prev = i1;
    } else {
        pushInstruction(entry, alloca);
    }
}
func buildFetchGlobalPointer(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalRuntimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 1 },
    });
}
func buildFetchLocalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 0 },
    });
}
func buildLoadFunctionPtr(this: &IRFunc, span: Span, dst: RegIndex, funcID: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_FUNCTION_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: funcID },
    });
}
func buildLoad(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildMove(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MOVE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetParam(this: &IRFunc, span: Span, dst: RegIndex, index: usize, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_PARAM,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: index },
        op1: RegIndex { i: size },
    });
}
func buildStore(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_STORE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCall(this: &IRFunc, span: Span, dst: RegIndex, funcID: RegIndex, args: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CALL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: funcID,
        args: args,
    });
}
func buildReturnExpr(this: &IRFunc, span: Span, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_EXPR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        src: val,
    });
}
func buildReturnEmpty(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_VOID,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildLoadString(this: &IRFunc, span: Span, dst: RegIndex, str: SubStr) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_STRING,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: str.start as usize },
        op1: RegIndex { i: str.len },
    });
}
func buildLoadBool(this: &IRFunc, span: Span, dst: RegIndex, val: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BOOL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadInteger(this: &IRFunc, span: Span, dst: RegIndex, t: &Type, val: usize) {
    let kind: usize = INSTR_LOAD_I8;
    if (isChar(t)) {
        kind = INSTR_LOAD_U8;
    } else {
        assert(isInteger(t), "IRFunc.buildLoadInteger got non-int type");
        let size: usize = getSize(t);
        if (size == 2) kind = INSTR_LOAD_I16;
        if (size == 4) kind = INSTR_LOAD_I32;
        if (size == 8) kind = INSTR_LOAD_I64;
        if (!isSignedInteger(t)) kind = kind + 1;
    }
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadNull(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_NULL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildLoadF32(this: &IRFunc, span: Span, dst: RegIndex, val: f32) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadF64(this: &IRFunc, span: Span, dst: RegIndex, val: f64) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadBlank(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BLANK,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    });
}
func buildLogicalNot(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOGICAL_NOT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildBinaryOp(this: &IRFunc, span: Span, kind: usize, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: lhs,
        op1: rhs,
    });
}
func buildInsertValue(this: &IRFunc, span: Span, aggr: RegIndex, index: usize, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INSERT_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: aggr,
        src: RegIndex { i: index },
        op1: val,
    });
}
func buildUnreachable(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNREACHABLE,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildUnterminated(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNTERMINATED,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildBr(this: &IRFunc, span: Span, block: IRBlockID) {
    assert(block.i < this.blocks.length, "buildBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: block.i },
    });
}
func buildCondBr(this: &IRFunc, span: Span, cond: RegIndex, drue: IRBlockID, falze: IRBlockID) {
    assert(drue.i < this.blocks.length, "buildCondBr called with invalid ID");
    assert(falze.i < this.blocks.length, "buildCondBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_COND_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: drue.i },
        src: cond,
        op1: RegIndex { i: falze.i },
    });
}
func buildBreak(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.after);
    return true;
}
func buildContinue(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.before);
    return true;
}
func buildIntSignExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_SIGN_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntZeroExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_ZERO_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntTruncate(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TRUNCATE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildF32ToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF32ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCreateArray(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_ARRAY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateStruct(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_STRUCT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateUnion(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_UNION,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildPtrToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_PTR_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToPtr(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetFieldPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, index: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_FIELD_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        op1: RegIndex { i: index },
    });
}
func buildGetElementPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, indices: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_ELEMENT_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        args: indices,
    });
}
func buildMemcpy(this: &IRFunc, span: Span, src: RegIndex, dst: RegIndex, size: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MEMCPY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: size,
    });
}

struct IRScopeEntry {
    name: SubStr;
    ptr: RegIndex;
    isComptime: bool;
}
func equals(this: &IRScopeEntry, other: &IRScopeEntry) -> bool {
    unreachable("IRScopeEntry.equals is not implemented yet");
}

struct IRScope {
    entries: IRScopeEntryList;
}
func equals(this: &IRScope, other: &IRScope) -> bool {
        unreachable("IRScope.equals is not implemented yet");
}
func addEntry(this: &IRScope, name: SubStr, ptr: RegIndex, isComptime: bool) {
    push(&this.entries, IRScopeEntry {
        name: name,
        ptr: ptr,
        isComptime: isComptime,
    });
}
func getIdentifierByName(this: &IRScope, name: SubStr) -> &IRScopeEntry {
    for (let i: usize = 0; i < this.entries.length; i = i + 1) {
        let entry: &IRScopeEntry = at(&this.entries, i);
        if (equals(&name, &entry.name)) {
            return entry;
        }
    }
    return null;
}

struct IRGen {
    globalScope: IRFunc;
    functions: String_IRFuncHashMap;
    error: bool;
}
func getIdentifierByName(this: &IRGen, function: &IRFunc, name: SubStr, isGlobal: &bool) -> &IRScopeEntry {
    trace("IRGen.getIdentifierByName");
    let entry: &IRScopeEntry = getIdentifierByName(function, name);
    if (entry != null) {
        *isGlobal = false;
        return entry;
    }
    entry = getIdentifierByName(&this.globalScope, name);
    if (entry != null) {
        *isGlobal = true;
        return entry;
    }
    return null;
}
func getFunctionByName(this: &IRGen, name: &String) -> usize {
    return indexOf(&this.functions, name);
}
func fillLookup(this: &IRGen, project: &ParsedFile) -> bool {
    trace("IRGen.fillLookup");
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let function: &ParsedFuncDecl = at(&funcDecls, i);
        if (function.ignored) continue;
        let name: String = getMangledName(function);
        if (containsKey(&this.functions, &name)) {
            let fn = get(&this.functions, &name);
            let loc = toString(&function.span);
            let loc1 = toString(&fn.span);
            fprintf(stderr, "%s: %s Hash collision - Function Lookup already contains function!\n", loc.buffer, FATAL_STR);
            fprintf(stderr, "%s: %s Function with mangled name %s already defined here!\n", loc1.buffer, FATAL_STR, name.buffer);
            drop(&loc1);
            drop(&loc);
            exit(2);
        }
        let irfunc: IRFunc = IRFunc {
            name: name,
            span: function.span,
            originalID: getID(function),
            comptimeLevel: 0,
            attrs: function.attrs,
        };
        add(&this.functions, name, irfunc);
    }
    return true;
}
func generateBytecode(this: &IRGen, project: &ParsedFile) -> bool {
    trace("IRGen.generateBytecode");
    if (!fillLookup(this, project))
        return false;
    let scope: usize = enterScope(&this.globalScope);
    assert(this.globalScope.scopes.length == 1, "Expected only one valid scope");
    let entry: IRBlockID = appendBlock(&this.globalScope);
    setCurrentBlock(&this.globalScope, entry);
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&file.mod.tlis, j));
            if (tli.ignored) continue;
            if (tli.kind == TLI_VAR_DECL) {
                generateBytecodeStmt(this, &this.globalScope, at(&stmts, tli.nodeID));
            }
        }
    }
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let fn: &ParsedFuncDecl = at(&funcDecls, i);
        generateFunction(this, fn);
    }
    if (*flags.emitBIR) {
        // TODO: Emit to file
        dumpInstructions(&this.globalScope);
        let fns = asList(&this.functions);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            dumpInstructions(at(&fns, i));
        }
        drop(&fns);
    }
    return !this.error;
}

func generateFunctionHeader(this: &IRGen, function: &IRFunc, retType: &Type, params: &ParamContext) {
    trace("IRGen.generateFunctionHeader");
    let entry: IRBlockID = appendBlock(function);
    setCurrentBlock(function, entry);
    let offset: usize = 0;
    if (getSize(retType) > 8) {
        offset = 1;
        prepareParameter(this, function, 0, blank, newSubStrOfStrLit("ret"), at(&types, intoPointer(retType)), true);
    }
    for (let i: usize = 0; i < params.paramLength; i = i + 1) {
        let name: Token = getNameAtIndex(params, i);
        let typDecl: &ParsedTypeNode = getTypeAtIndex(params, i);
        let pType: &Type = getType(&typDecl.typeState);
        prepareParameter(this, function, i + offset, name.span, name.content, pType, false);
    }
}

func generateFunctionBody(this: &IRGen, function: &IRFunc, body: &ParsedBlock, retTypeNode: &ParsedTypeNode) {
    trace("IRGen.generateFunctionBody");
    let retType: &Type = getType(&retTypeNode.typeState);
    if (function.returnBlockID.i == 0) {
        let curr = getCurrentBlock(function);
        function.returnBlockID = appendBlock(function);
        if (isNone(retType)) {
            setCurrentBlock(function, function.returnBlockID);
            buildReturnEmpty(function, retTypeNode.span);
            setCurrentBlock(function, curr);
        } else {
            function.returnAlloc = allocateRegister(function, at(&types, intoPointer(retType)));
            buildAlloca(function, retTypeNode.span, function.returnAlloc, getSize(retType));
            setCurrentBlock(function, function.returnBlockID);
            let result = allocateRegister(function, retType);
            buildLoad(function, retTypeNode.span, result, function.returnAlloc);
            if (getSize(retType) > 8) {
                buildStore(function, retTypeNode.span, function.retPtr, result);
                buildReturnExpr(function, retTypeNode.span, function.retPtr);
            } else {
                if (isStruct(retType)) {
                    let v: RegIndex = getRegisterForSize(this, function, getSize(retType));
                    let t: &Type = getRegister(function, v).typ;
                    let r: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
                    let s: usize = getSize(t);
                    assert(s <= 8);
                    buildAlloca(function, retTypeNode.span, r, s);
                    buildStore(function, retTypeNode.span, r, result);
                    buildLoad(function, retTypeNode.span, v, r);
                    buildReturnExpr(function, retTypeNode.span, v);
                } else {
                    buildReturnExpr(function, retTypeNode.span, result);
                }
            }
            setCurrentBlock(function, curr);
        }
    }
    generateBytecodeBlock(this, function, body);
    let curr: &IRBlock = getCurrentBlockAsRef(function);
    if (!isTerminated(curr)) {
        if (isNone(retType)) {
            buildReturnEmpty(function, body.span);
        } else {
            buildUnterminated(function, body.span);
        }
    }
    let after: usize = leaveScope(function);
    assert(after == 1, "Scope imbalance detected");
}

func generateFunction(this: &IRGen, funcDecl: &ParsedFuncDecl) {
    trace("IRGen.generateFunction");
    if (funcDecl.ignored) return;
    assert(isSuccess(&funcDecl.typeState), "Expected valid FuncDecl type in IRGen");
    let name: String = getMangledName(funcDecl);
    let function: &IRFunc = get(&this.functions, &name);
    assert(function != null, "Expected to find function in lookup");
    assert(equals(&function.name, &name), "functions.get() retrieved wrong IRFunc");
    drop(&name);
    if (isExtern(funcDecl)) {
        return;
    }
    let scope: usize = enterScope(function);
    assert(scope == 1, "Expected function to enter first scope");
    let retDecl: &ParsedTypeNode = funcDecl.retType;
    generateFunctionHeader(this, function, getType(&retDecl.typeState), &funcDecl.params);
    generateFunctionBody(this, function, funcDecl.body, funcDecl.retType);
}

func generateBytecodeBlock(this: &IRGen, function: &IRFunc, block: &ParsedBlock) {
    trace("IRGen.generateBytecodeBlock");
    if (block.ignored) return;
    assert(isSuccess(&block.typeState), "Expected valid Block type in IRGen");
    let scope: usize = enterScope(function);
    let f: &ParsedFuncDecl = getFuncNode(function);
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmt: &ParsedStmt = getStmtAtIndex(block, i);
        generateBytecodeStmt(this, function, stmt);
        let curr: &IRBlock = getCurrentBlockAsRef(function);
        if (isTerminated(curr)) {
            if (i != block.stmtLength - 1) {
                let loc: String = toString(&getStmtAtIndex(block, i + 1).span);
                fprintf(stderr, "%s: %s: Unreachable code.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            break;
        }
    }
    let after: usize = leaveScope(function);
    assert(scope == after, "Scope imbalance detected");
}

func generateBytecodeStmt(this: &IRGen, function: &IRFunc, stmt: &ParsedStmt) {
    trace("IRGen.generateBytecodeStmt");
    if (stmt.ignored) return;
    assert(isSuccess(&stmt.typeState), "Expected valid Stmt type in IRGen");
    if (stmt.kind == STMT_VAR_DECL) {
        let expr: &ParsedExpr = stmt.varDeclContext.expr;
        if (stmt.varDeclContext.isComptime) {
            startComptime(function);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let scope: &IRScope = last(&function.scopes);
            addEntry(scope, stmt.varDeclContext.name.content, result, true);
            endComptime(function);
        } else {
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let typ: &Type = getType(&stmt.typeState);
            let allocaType: &Type = at(&types, intoPointer(typ));
            let ptr: RegIndex = allocateRegister(function, allocaType);
            buildAlloca(function, stmt.span, ptr, getSize(typ));
            buildStore(function, stmt.span, ptr, result);
            let scope: &IRScope = last(&function.scopes);
            addEntry(scope, stmt.varDeclContext.name.content, ptr, false);
        }
    } else if (stmt.kind == STMT_IF) {
        let context: &IfContext = &stmt.ifContext;
        let cond: RegIndex = generateBytecodeExpr(this, function, stmt.expr, false);
        if (context.hasElse) {
            let then: IRBlockID = appendBlock(function);
            let elze: IRBlockID = appendBlock(function);
            buildCondBr(function, stmt.span, cond, then, elze);

            setCurrentBlock(function, then);
            generateBytecodeStmt(this, function, context.thenBody);
            then = getCurrentBlock(function);

            setCurrentBlock(function, elze);
            generateBytecodeStmt(this, function, context.elseBody);
            elze = getCurrentBlock(function);

            let thenBlock: &IRBlock = getBlockByID(function, then);
            let elzeBlock: &IRBlock = getBlockByID(function, elze);
            let thenTerm: bool = isTerminated(thenBlock);
            let elseTerm: bool = isTerminated(elzeBlock);
            if (thenTerm && elseTerm) {
                // nothing to do here
            } else if (thenTerm && !elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, elze);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else if (!thenTerm && elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, then);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, then);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, elze);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            }
        } else {
            let then: IRBlockID = appendBlock(function);
            let cont: IRBlockID = appendBlock(function);
            buildCondBr(function, stmt.span, cond, then, cont);

            setCurrentBlock(function, then);
            generateBytecodeStmt(this, function, context.thenBody);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, cont);
            }
            setCurrentBlock(function, cont);
        }
    } else if (stmt.kind == STMT_WHILE) {
        let condBlock: IRBlockID = appendBlock(function);
        let bodyBlock: IRBlockID = appendBlock(function);
        let afterBlock: IRBlockID = appendBlock(function);
        let stepBlock: IRBlockID = appendBlock(function);
        pushLoopBlocks(function, stepBlock, afterBlock);
        buildBr(function, stmt.span, condBlock);

        setCurrentBlock(function, condBlock);
        let cond: RegIndex = generateBytecodeExpr(this, function, stmt.expr, false);
        buildCondBr(function, stmt.span, cond, bodyBlock, afterBlock);

        setCurrentBlock(function, bodyBlock);
        generateBytecodeBlock(this, function, stmt.block);
        let curr: &IRBlock = getCurrentBlockAsRef(function);
        if (!isTerminated(curr)) {
            buildBr(function, stmt.span, stepBlock);
        }

        setCurrentBlock(function, stepBlock);
        generateBytecodeExpr(this, function, stmt.step, false);
        buildBr(function, stmt.span, condBlock);

        setCurrentBlock(function, afterBlock);
        popLoopBlocks(function);
    } else if (stmt.kind == STMT_RETURN_EXPR) {
        let expr: &ParsedExpr = stmt.expr;
        let typ: &Type = getType(&expr.typeState);
        let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
        buildStore(function, stmt.span, function.returnAlloc, result);
        buildBr(function, stmt.span, function.returnBlockID);
    } else if (stmt.kind == STMT_RETURN_EMPTY) {
        buildBr(function, stmt.span, function.returnBlockID);
    } else if (stmt.kind == STMT_BLOCK) {
        generateBytecodeBlock(this, function, stmt.block);
    } else if (stmt.kind == STMT_EXPR) {
        generateBytecodeExpr(this, function, stmt.expr, false);
    } else if (stmt.kind == STMT_BREAK) {
        if (!buildBreak(function, stmt.span)) {
            todo_with_msg("break outside of loop");
        }
    } else if (stmt.kind == STMT_CONTINUE) {
        if (!buildContinue(function, stmt.span)) {
            todo_with_msg("continue outside of loop");
        }
    } else if (stmt.kind == STMT_MATCH) {
        generateBytecodeMatchStmt(this, function, stmt);
    } else {
        unreachable("Exhaustive handling of statements in IRGen.generateBytecodeStmt");
    }
}

func generateBytecodeMatchStmt(this: &IRGen, function: &IRFunc, match: &ParsedStmt) {
    trace("IRGen.generateBytecodeMatchStmt");
    assert(match.kind == STMT_MATCH);
    assert(match.patterns.length == match.stmts.length);
    let state = match.typeState;
    assert(isPattern(&state));
    let patState = getPatState(&state);
    assert(patState.complete, "generateBytecodeMatchStmt: Non-exhaustive pattern");
    let expr = generateBytecodeExpr(this, function, match.expr, false);
    let end = appendBlock(function);
    for (let i: usize = 0; i < match.patterns.length; i = i + 1) {
        let pat = *at(&match.patterns, i);
        let stmt = *at(&match.stmts, i);
        let scope: usize = enterScope(function);
        let patReg = generateBytecodePattern(this, function, expr, pat, false /* don't care */);
        let matchBlock = appendBlock(function);
        let nextBlock = appendBlock(function);
        buildCondBr(function, match.span, patReg, matchBlock, nextBlock);
        setCurrentBlock(function, matchBlock);
        generateBytecodeStmt(this, function, stmt);
        if (!isTerminated(getCurrentBlockAsRef(function))) {
            buildBr(function, stmt.span, end);
        }
        setCurrentBlock(function, nextBlock);
        let after = leaveScope(function);
        assert(scope == after, "Scope imbalance in match");
    }
    // in the normal control flow, we should at some point always go into a matchBlock, which jumps
    // to the end. If we don't, there's an internal compiler bug, which is why we put an unreachable
    // here.
    let unreachable: String = newStringFromStrLit("unreachablePcrN");
    if (!containsKey(&this.functions, &unreachable)) {
        fprintf(stderr, "%s Could not generate match guard check!\n", FATAL_STR);
        fprintf(stderr, "%s: Reason: Could not find function `unreachable`!\n", NOTE_STR);
        fprintf(stderr, "%s: Please import `prelude.bufo` and try again.\n", NOTE_STR);
        exit(1);
    }
    let funcID: usize = getFunctionByName(this, &unreachable);
    let args: RegIndexList = blank;
    {
        let err: RegIndex = allocateRegister(function, newType(TYPE_KIND_POINTER, TYPE_CHAR));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&match.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": FATAL COMPILER ERROR: match-statement reached guard block!\n");
        pushString(&s, &_s);
        pushStr(&s, ": This should never happen, as all match-patterns eventually lead to the real block.\n");
        pushString(&s, &_s);
        pushStr(&s, ": Please submit a bug report.\n");
        drop(&_s);
        buildLoadString(function, match.span, err, asSubStr(&s));
        push(&args, err);
    }
    let reg: RegIndex = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_NONE));
    {
        let ft = newType(TYPE_KIND_FUNCTION, TYPE_NONE);
        ft.arraySize = ft.arraySize | FUNC_TYPE_VARIADIC;
        let dst = allocateRegister(function, ft);
        buildLoadFunctionPtr(function, match.span, dst, funcID);
        buildCall(function, match.span, reg, dst, args);
    }
    buildUnreachable(function, match.span);
    setCurrentBlock(function, end);
}

func generateBytecodePattern(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, inOrigMemory: bool) -> RegIndex {
    trace("IRGen.generateBytecodePattern");
    let type = getRegister(function, expr).typ;
    let success = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL));
    if (pat.kind == PATTERN_IDENT) {
        let name = &pat.ident;
        if (inOrigMemory) {
            addEntry(last(&function.scopes), name.content, expr, false);
        } else {
            let allocReg = allocateRegister(function, at(&types, intoPointer(type)));
            buildAlloca(function, pat.span, allocReg, getSize(type));
            buildStore(function, pat.span, allocReg, expr);
            addEntry(last(&function.scopes), name.content, allocReg, false);
        }
        buildLoadBool(function, pat.span, success, 1);
    } else if (pat.kind == PATTERN_REFERENCE) {
        assert(pat.subPatterns.length == 1);
        assert(isPointer(type), "Reference Pattern expected pointer type");
        let under = getUnderlyingType(type, false);
        if (isPointer(under)) {
            let reg = allocateRegister(function, under);
            buildLoad(function, pat.span, reg, expr);
            return generateBytecodePattern(this, function, reg, *at(&pat.subPatterns, 0), true);
        } else {
            return generateBytecodePattern(this, function, expr, *at(&pat.subPatterns, 0), true);
        }
    } else if (pat.kind == PATTERN_NULL) {
        assert(isPointer(type), "Null Pattern expected pointer type");
        let reg = allocateRegister(function, type);
        buildLoadNull(function, pat.span, reg);
        buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, reg);
    } else if (pat.kind == PATTERN_BOOLEAN) {
        if (inOrigMemory) {
            assert(isPointer(type), "Boolean Pattern inOrigMemory expected pointer");
            assert(isPointerTo(type, TYPE_BOOL), "Boolean Pattern inOrigMemory expected pointer to bool");
            let _expr = allocateRegister(function, getUnderlyingType(type, false));
            buildLoad(function, pat.span, _expr, expr);
            if (equals(&pat.ident.content, &comptime BUILD_A_KEYWORD("true"))) {
                buildMove(function, pat.span, success, _expr);
            } else {
                buildLogicalNot(function, pat.span, success, _expr);
            }
        } else {
            if (equals(&pat.ident.content, &comptime BUILD_A_KEYWORD("true"))) {
                buildMove(function, pat.span, success, expr);
            } else {
                buildLogicalNot(function, pat.span, success, expr);
            }
        }
    } else if (pat.kind == PATTERN_STRUCT) {
        buildLoadBool(function, pat.span, success, 1);
        generateBytecodePatternStruct(this, function, expr, pat, success, inOrigMemory);
    } else if (pat.kind == PATTERN_PATH) {
        assert(pat.subPatterns.length == 1);
        buildLoadBool(function, pat.span, success, 1);
        let ptr = isPointer(type);
        if (ptr) {
            type = getUnderlyingType(type, false);
        }
        if (isUnion(type)) {
            generateBytecodePatternUnion(this, function, expr, pat, success, ptr || inOrigMemory);
        } else if (isStruct(type)) {
            generateBytecodePatternStruct(this, function, expr, *at(&pat.subPatterns, 0), success, ptr || inOrigMemory);
        } else {
            unreachable("generateBytecodePattern(PATTERN_PATH): Exhaustive handling of variations");
        }
    } else if (pat.kind == PATTERN_NUMBER) {
        let number: RegIndex = blank;
        let real = type;
        if (inOrigMemory) {
            assert(isPointer(real), "generateBytecodePattern: Number inOrigMemory");
            real = getUnderlyingType(real, false);
            let _expr = allocateRegister(function, real);
            buildLoad(function, pat.span, _expr, expr);
            expr = _expr;
        }
        number = allocateRegister(function, real);
        loadLiteral(this, function, number, &pat.ident);
        if (isInteger(real)) {
            buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, number);
        } else if (isFloat(real)) {
            buildBinaryOp(function, pat.span, INSTR_FLOAT_CMP_EQ, success, expr, number);
        } else {
            unreachable("Exhaustive handling of number types in IRGen.generateBytecodePattern");
        }
    } else if (pat.kind == PATTERN_WILDCARD || pat.kind == PATTERN_REST) {
        buildLoadBool(function, pat.span, success, 1);
    } else {
        unreachable("Exhaustive handling of patterns in IRGen.generateBytecodePattern");
    }
    return success;
}

func generateBytecodePatternStruct(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool) {
    trace("IRGen.generateBytecodePatternStruct");
    let type = getRegister(function, expr).typ;
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        assert(isStructPointer(type), "In Memory Struct Pattern expected pointer to struct type");
        type = getUnderlyingType(type, false);
        let decl = at(&structDecls, type.typeIndex);
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(&pat.subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = at(&types, intoPointer(getType(&fieldNode.typeState)));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, subExpr, expr, i);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, true);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (subPat.kind == PATTERN_REST) break;
        }
    } else {
        assert(isStruct(type), "Struct Pattern expected struct type");
        let decl = at(&structDecls, type.typeIndex);
        let allocReg = allocateRegister(function, at(&types, intoPointer(type)));
        buildAlloca(function, pat.span, allocReg, getSize(type));
        buildStore(function, pat.span, allocReg, expr);
        expr = allocReg;
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(&pat.subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldPtr = allocateRegister(function, at(&types, intoPointer(fieldType)));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, fieldPtr, expr, i);
            buildLoad(function, pat.span, subExpr, fieldPtr);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, false);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (subPat.kind == PATTERN_REST) break;
        }
    }
}

func generateBytecodePatternUnion(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool) {
    trace("IRGen.generateBytecodePatternUnion");
    // FIXME: Handling of IR for unions is always so awkward
    let type = getRegister(function, expr).typ;
    let subPat = *at(&pat.subPatterns, 0);
    let u8Type = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
    let usizeType = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
    let sizeReg = allocateRegister(function, usizeType);
    let tag = allocateRegister(function, u8Type);
    let tagMatch = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL));
    let tagPtr = allocateRegister(function, at(&types, intoPointer(u8Type)));
    let tagVal = allocateRegister(function, u8Type);
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        assert(isPointer(type), "In Memory Union Pattern expected pointer type");
        type = getUnderlyingType(type, false);
        assert(isUnion(type), "Union Pattern expected union type");
        let decl = at(&unionDecls, type.typeIndex);
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, &subPat.ident, &variant);
        assert(found);
        let tmp = allocateRegister(function, at(&types, intoPointer(type)));
        buildMove(function, pat.span, tmp, expr);
        {
            // tag check
            buildLoadInteger(function, subPat.span, tag, u8Type, getVariantTag(decl, variant));
            buildMove(function, subPat.span, tagPtr, tmp);
            buildLoad(function, subPat.span, tagVal, tagPtr);
            buildBinaryOp(function, subPat.span, INSTR_INT_CMP_EQ, tagMatch, tag, tagVal);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tag
            buildLoadInteger(function, subPat.span, sizeReg, usizeType, 1);
            buildPtrToInt(function, subPat.span, tmp, tmp);
            buildBinaryOp(function, subPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, subPat.span, tmp, tmp);
        }
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPat.subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSize(fieldType);
            let subPtr = allocateRegister(function, at(&types, intoPointer(fieldType)));
            buildMove(function, subSubPat.span, subPtr, tmp);
            let sub = generateBytecodePattern(this, function, subPtr, subSubPat, true);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (subSubPat.kind == PATTERN_REST) break;
            if (i != subPat.subPatterns.length - 1) {
                buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    } else {
        assert(isUnion(type), "Union Pattern expected union type");
        let decl = at(&unionDecls, type.typeIndex);
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, &subPat.ident, &variant);
        assert(found);
        let allocReg = allocateRegister(function, at(&types, intoPointer(type)));
        buildAlloca(function, pat.span, allocReg, getSize(type));
        buildStore(function, pat.span, allocReg, expr);
        let tmp = allocateRegister(function, at(&types, intoPointer(type)));
        buildMove(function, pat.span, tmp, allocReg);
        {
            // tag check
            buildLoadInteger(function, subPat.span, tag, u8Type, getVariantTag(decl, variant));
            buildMove(function, subPat.span, tagPtr, allocReg);
            buildLoad(function, subPat.span, tagVal, tagPtr);
            buildBinaryOp(function, subPat.span, INSTR_INT_CMP_EQ, tagMatch, tag, tagVal);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tag
            buildLoadInteger(function, subPat.span, sizeReg, usizeType, 1);
            buildPtrToInt(function, subPat.span, tmp, tmp);
            buildBinaryOp(function, subPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, subPat.span, tmp, tmp);
        }
        expr = allocReg;
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPat.subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSize(fieldType);
            let subAlloc = allocateRegister(function, at(&types, intoPointer(fieldType)));
            let subExpr = allocateRegister(function, fieldType);
            buildAlloca(function, subSubPat.span, subAlloc, fieldSize);
            buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
            buildMemcpy(function, subSubPat.span, tmp, subAlloc, sizeReg);
            buildLoad(function, subSubPat.span, subExpr, subAlloc);
            let sub = generateBytecodePattern(this, function, subExpr, subSubPat, false);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (subSubPat.kind == PATTERN_REST) break;
            if (i != subPat.subPatterns.length - 1) {
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    }
}

func generateBytecodeExpr(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExpr");
    if (expr.ignored) return blank;
    assert(isSuccess(&expr.typeState), "Expected valid Expr type in IRGen");
    if (expr.kind == EXPR_EMPTY) {
        return blank;
    } else if (isIdentifier(expr)) {
        return generateBytecodeExprIdentifier(this, function, expr, needsPtr);
    } else if (isArithmetic(expr)) {
        return generateBytecodeExprArithmetic(this, function, expr);
    } else if (isComparison(expr)) {
        return generateBytecodeExprComparison(this, function, expr);
    } else if (isLogical(expr)) {
        return generateBytecodeExprLogical(this, function, expr);
    } else if (isBitwise(expr)) {
        return generateBytecodeExprBitwise(this, function, expr);
    } else if (isLiteral(expr)) {
        return generateBytecodeExprLiteral(this, function, expr, needsPtr);
    } else if (isAssignment(expr)) {
        return generateBytecodeExprAssignment(this, function, expr);
    } else if (expr.kind == EXPR_BINARY) {
        if (expr.op == BIN_MODULE) {
            return generateBytecodeExprModuleAccess(this, function, expr, needsPtr);
        } else if (expr.op == BIN_DOT) {
            return generateBytecodeExprMemberAccess(this, function, expr, needsPtr);
        } else if (expr.op == BIN_INDEXED_ACCESS) {
            return generateBytecodeExprIndexedAccess(this, function, expr, needsPtr);
        } else {
            unreachable("op should've been handled by now");
        }
    } else if (isCall(expr)) {
        return generateBytecodeExprCall(this, function, expr, needsPtr);
    } else if (isUnary(expr)) {
        return generateBytecodeExprUnary(this, function, expr, needsPtr);
    } else if (isBlank(expr)) {
        let t: &Type = getType(&expr.typeState);
        let size: usize = getSize(t);
        let reg: RegIndex = allocateRegister(function, t);
        buildLoadBlank(function, expr.span, reg, size);
        if (needsPtr) {
            let tempAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
            buildAlloca(function, expr.span, tempAlloc, size);
            buildStore(function, expr.span, tempAlloc, reg);
            return tempAlloc;
        }
        return reg;
    } else if (expr.kind == EXPR_SIZEOF) {
        let t: &Type = getType(&expr.typeState);
        let target: &Type = getType(&at(&typeNodes, expr.lhs).typeState);
        let reg: RegIndex = allocateRegister(function, t);
        let size: usize = getSize(target);
        buildLoadInteger(function, expr.span, reg, t, size);
        if (needsPtr) {
            let tempAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
            buildAlloca(function, expr.span, tempAlloc, size);
            buildStore(function, expr.span, tempAlloc, reg);
            return tempAlloc;
        }
        return reg;
    } else if (expr.kind == EXPR_AS) {
        return generateBytecodeExprAs(this, function, expr);
    } else if (expr.kind == EXPR_STRUCT_INIT) {
        let strukt: &Type = getType(&expr.typeState);
        assert(isStruct(strukt), "Expected Struct Type in EXPR_STRUCT_INIT");
        let structDecl: &ParsedStructDecl = at(&structDecls, strukt.typeIndex);
        let reg: RegIndex = allocateRegister(function, strukt);
        buildCreateStruct(function, expr.span, reg);
        for (let i: usize = 0; i < expr.structInitContext.fieldLength; i = i + 1) {
            let name: Token = getFieldNameAtIndex(&expr.structInitContext, i);
            let field: &ParsedExpr = getFieldExprAtIndex(&expr.structInitContext, i);
            let index: usize = getFieldIndex(structDecl, &name.content);
            let result: RegIndex = generateBytecodeExpr(this, function, field, false);
            buildInsertValue(function, field.span, reg, index, result);
        }
        if (needsPtr) {
            let structAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(strukt)));
            buildAlloca(function, expr.span, structAlloc, getSize(strukt));
            buildStore(function, expr.span, structAlloc, reg);
            return structAlloc;
        }
        return reg;
    } else if (expr.kind == EXPR_UNION_INIT) {
        return generateBytecodeExprUnionInit(this, function, expr, needsPtr);
    } else {
        unreachable("Exhaustive handling of expressions in IRGen.generateBytecodeExpr");
    }
}

func generateBytecodeExprUnionInit(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprUnionInit");
    assert(expr.kind == EXPR_UNION_INIT);
    // union = [tag, data]
    let typ: &Type = getType(&expr.typeState);
    assert(isUnion(typ), "Expected Union Type in EXPR_UNION_INIT");
    let decl = at(&unionDecls, typ.typeIndex);
    let variant = *at(&decl.variants, typ.arraySize);
    assert(decl.variants.length < 256, "IRGen assumes that the tag of an union fits in a single byte");
    let size = getSize(typ);
    assert(size >= 1, "Expected union instance to be at least one byte");
    let start = allocateRegister(function, at(&types, intoPointer(typ)));
    buildAlloca(function, expr.span, start, size);
    let empty = allocateRegister(function, typ);
    buildCreateUnion(function, expr.span, empty);
    buildStore(function, expr.span, start, empty);
    let usizeType = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
    let sizeReg = allocateRegister(function, usizeType);
    let offsetReg = allocateRegister(function, usizeType);
    let tmp = allocateRegister(function, at(&types, intoPointer(typ)));
    let base = allocateRegister(function, at(&types, intoPointer(typ)));
    buildMove(function, expr.span, tmp, start);
    {
        // tag
        let u8 = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        let tag = allocateRegister(function, u8);
        buildLoadInteger(function, expr.span, tag, u8, typ.arraySize);
        buildStore(function, expr.span, start, tag);

        // offset tmp by tag
        buildLoadInteger(function, expr.span, sizeReg, usizeType, 1);
        buildPtrToInt(function, expr.span, tmp, tmp);
        buildBinaryOp(function, expr.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
        buildIntToPtr(function, expr.span, tmp, tmp);
    }
    buildMove(function, expr.span, base, tmp);
    if (variant.kind == UNION_VARIANT_EMPTY) {
        // nothing to do here
        // REVIEW: Maybe allow things like  union { A = 12, B = 23 }  ?
    } else if (variant.kind == UNION_VARIANT_TUPLE) {
        // The Type Checker overwrites the original expr.kind, however because we have a tuple, we
        // know the original kind was EXPR_CALL
        for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
            let field: &ParsedExpr = at(&exprs, getElementAtIndex(&expr.arrayContext, i));
            let result: RegIndex = generateBytecodeExpr(this, function, field, true);
            buildLoadInteger(function, field.span, sizeReg, usizeType, getSize(getType(&field.typeState)));
            buildMemcpy(function, field.span, result, tmp, sizeReg);
            if (i != expr.arrayContext.elemLength - 1) {
                buildPtrToInt(function, expr.span, tmp, tmp);
                buildBinaryOp(function, expr.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, expr.span, tmp, tmp);
            }
        }
    } else if (variant.kind == UNION_VARIANT_STRUCT) {
        // The Type Checker overwrites the original expr.kind, however because we have a tuple, we
        // know the original kind was EXPR_STRUCT_INIT
        for (let i: usize = 0; i < expr.structInitContext.fieldLength; i = i + 1) {
            let name: Token = getFieldNameAtIndex(&expr.structInitContext, i);
            let field: &ParsedExpr = getFieldExprAtIndex(&expr.structInitContext, i);
            let result: RegIndex = generateBytecodeExpr(this, function, field, true);
            {
                let index: usize = 0;
                let offset: usize = 0;
                getFieldIndexAndOffset(variant, &name.content, &index, &offset);
                buildLoadInteger(function, field.span, offsetReg, usizeType, offset);
                buildPtrToInt(function, expr.span, base, base);
                buildPtrToInt(function, expr.span, tmp, tmp);
                buildBinaryOp(function, expr.span, INSTR_INT_ADD, tmp, base, offsetReg);
                buildIntToPtr(function, expr.span, tmp, tmp);
                buildIntToPtr(function, expr.span, base, base);
            }
            buildLoadInteger(function, field.span, sizeReg, usizeType, getSize(getType(&field.typeState)));
            buildMemcpy(function, field.span, result, tmp, sizeReg);
        }
    } else {
        unreachable("Exhaustive handling of union variants in generateBytecodeExprIdentifier");
    }
    if (needsPtr) {
        return start;
    } else {
        let dst = allocateRegister(function, typ);
        buildLoad(function, expr.span, dst, start);
        return dst;
    }
}

func generateBytecodeExprAs(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprAs");
    let result: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let current: &Type = getType(&at(&exprs, expr.lhs).typeState);
    let target: &Type = getType(&at(&typeNodes, expr.rhs).typeState);
    let exType: &Type = getType(&expr.typeState);
    assert(equals(target, exType));
    let dst: RegIndex = allocateRegister(function, target);
    if (isInteger(current) && isPointer(target)) {
        buildIntToPtr(function, expr.span, dst, result);
    } else if (isPointer(current) && isInteger(target)) {
        buildPtrToInt(function, expr.span, dst, result);
    } else if (isPointer(current) && isPointer(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isAny(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isAny(target)) {
        buildMove(function, expr.span, dst, result);
    } else if ((isChar(current) || isInteger(current)) && (isChar(target) || isInteger(target))) {
        if (getSize(current) < getSize(target)) {
            if (isSignedInteger(current)) {
                buildIntSignExtend(function, expr.span, dst, result, getSize(target) * 8);
            } else {
                buildIntZeroExtend(function, expr.span, dst, result, getSize(target) * 8);
            }
        } else if (getSize(current) > getSize(target)) {
            buildIntTruncate(function, expr.span, dst, result, getSize(target) * 8);
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else if (isInteger(current) && isFloat(target)) {
        if (getSize(target) == 4) buildIntToF32(function, expr.span, dst, result);
        else if (getSize(target) == 8) buildIntToF64(function, expr.span, dst, result);
        else unreachable("int to float");
    } else if (isFloat(current) && isInteger(target)) {
        if (getSize(current) == 4) buildF32ToInt(function, expr.span, dst, result);
        else if (getSize(current) == 8) buildF64ToInt(function, expr.span, dst, result);
        else unreachable("float to int");
    } else if (isFloat(current) && isFloat(target)) {
        if (getSize(current) < getSize(target)) {
            assert(getSize(current) == 4);
            assert(getSize(target) == 8);
            buildF32ToF64(function, expr.span, dst, result);
        } else if (getSize(current) > getSize(target)) {
            assert(getSize(current) == 8);
            assert(getSize(target) == 4);
            buildF64ToF32(function, expr.span, dst, result);
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else {
        unreachable("Exhaustive handling of variations in generateBytecodeExprAs");
    }
    return dst;
}
func generateBytecodeExprModuleAccess(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprModuleAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_MODULE);
    assert(isSuccess(&expr.typeState), "Expected valid Module state in IRGen");
    let lhs: &ParsedExpr = at(&exprs, expr.lhs);
    let rhs: &ParsedExpr = at(&exprs, expr.rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else if (isUnion(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else {
        unreachable("generateBytecodeExprModuleAccess: Unexpected type of LHS");
    }
}

func generateBytecodeExprMemberAccess(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprMemberAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_DOT);
    assert(isSuccess(&expr.typeState), "Expected valid Member state in IRGen");
    let lhs: &ParsedExpr = at(&exprs, expr.lhs);
    let rhs: &ParsedExpr = at(&exprs, expr.rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    }
    assert(isStruct(instance) || isStructPointer(instance), "Expected (ptr to) struct in MemberAccess");
    assert(rhs.kind == EXPR_NAME);
    let result: RegIndex = generateBytecodeExpr(this, function, lhs, !isStructPointer(instance));
    let _t: &Type = getRegister(function, result).typ;
    assert(isStruct(_t) || isStructPointer(_t), "Expected (ptr to) struct in Field Access");
    if (!isStructPointer(_t)) {
        let t1: &Type = at(&types, intoPointer(_t));
        let alloca: RegIndex = allocateRegister(function, t1);
        buildAlloca(function, expr.span, alloca, getSize(_t));
        buildStore(function, expr.span, alloca, result);
        result = alloca;
        _t = t1;
    }
    assert(isStructPointer(_t), "Expected ptr to struct in Field Access");
    let structType: &Type = getUnderlyingType(_t, false);
    // `result` contains a pointer to a struct instance at this point
    let decl: &ParsedStructDecl = at(&structDecls, structType.typeIndex);
    let index: usize = getFieldIndex(decl, &rhs.origToken.content);
    let _f: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, index);
    let fieldType: &Type = getType(&_f.typeState);
    let fieldPtr: RegIndex = allocateRegister(function, at(&types, intoPointer(fieldType)));
    buildGetFieldPtr(function, expr.span, fieldPtr, result, index);
    if (needsPtr) {
        return fieldPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, fieldType);
        buildLoad(function, expr.span, dst, fieldPtr);
        return dst;
    }
}

func prepareReturnValue(this: &IRGen, span: Span, function: &IRFunc, base: RegIndex, args: RegIndexList, retType: &Type, retPtr: RegIndex, needsPtr: bool) -> RegIndex {
    let retVal: RegIndex = blank;
    if (getSize(retType) > 8) {
        let reg: RegIndex = allocateRegister(function, retType);
        buildCall(function, span, retPtr, base, args);
        if (needsPtr) {
            retVal = retPtr;
        } else {
            buildLoad(function, span, reg, retPtr);
            retVal = reg;
        }
    } else {
        if (isStruct(retType)) {
            let reg: RegIndex = getRegisterForSize(this, function, getSize(retType));
            buildCall(function, span, reg, base, args);
            let v: RegIndex = allocateRegister(function, retType);
            let t: &Type = getRegister(function, v).typ;
            let r: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
            let s: usize = getSize(t);
            assert(s <= 8);
            buildAlloca(function, span, r, s);
            buildStore(function, span, r, reg);
            if (needsPtr) {
                retVal = r;
            } else {
                buildLoad(function, span, v, r);
                retVal = v;
            }
        } else {
            let reg: RegIndex = allocateRegister(function, retType);
            buildCall(function, span, reg, base, args);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(retType)));
                buildAlloca(function, span, tempAlloc, getSize(retType));
                buildStore(function, span, tempAlloc, reg);
                retVal = tempAlloc;
            } else {
                retVal = reg;
            }
        }
    }
    let ft: &Type = getRegister(function, base).typ;
    if (isPointer(ft)) ft = getUnderlyingType(ft, true);
    assert(isFunction(ft), "IRGen: Base is not a function");
    if (isNoreturn(ft)) {
        buildUnreachable(function, span);
    }
    return retVal;
}

func generateBytecodeExprIndexedAccess(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprIndexedAccess");
    assert(expr.kind == EXPR_BINARY);
    assert(expr.op == BIN_INDEXED_ACCESS);
    let arrExpr: &ParsedExpr = at(&exprs, expr.lhs);
    let lhsType: &Type = getType(&arrExpr.typeState);
    assert(isArray(lhsType) || isPointer(lhsType), "Expected Ptr or Array as LHS in IndexedAccess");
    let lhs: RegIndex = generateBytecodeExpr(this, function, arrExpr, isArray(lhsType));
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    assert(isPointer(getRegister(function, lhs).typ), "Expected Ptr as LHS in IndexedAccess");
    assert(isInteger(getRegister(function, rhs).typ), "Expected Int as RHS in IndexedAccess");
    let elemType: &Type = getType(&expr.typeState);
    let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
    let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
    if (isArray(lhsType)) {
        // if (index >= size) panic("Index out of bounds");
        let arrType: &Type = getType(&arrExpr.typeState);
        let elemCount: usize = getSize(arrType) / getSize(elemType);
        let cond: RegIndex = allocateRegister(function, boolType);
        let size: RegIndex = allocateRegister(function, usizeType);
        let panic: IRBlockID = appendBlock(function);
        let normal: IRBlockID = appendBlock(function);
        buildLoadInteger(function, expr.span, size, usizeType, elemCount);
        buildBinaryOp(function, expr.span, INSTR_INT_CMP_GTE, cond, rhs, size);
        buildCondBr(function, expr.span, cond, panic, normal);

        setCurrentBlock(function, panic);
        let err: RegIndex = allocateRegister(function, newType(TYPE_KIND_POINTER, TYPE_CHAR));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&expr.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": RUNTIME ERROR: Index out of bounds: Array of size ");
        pushNumber(&s, elemCount);
        pushStr(&s, " has no index %d\n");
        drop(&_s);
        buildLoadString(function, expr.span, err, asSubStr(&s));
        let indexoob: String = newStringFromStrLit("index_oobPci64rN");
        if (!containsKey(&this.functions, &indexoob)) {
            fprintf(stderr, "%s Could not generate index check for array access!\n", FATAL_STR);
            fprintf(stderr, "%s: Reason: Could not find function `index_oob`!\n", NOTE_STR);
            fprintf(stderr, "%s: Please import `prelude.bufo` and try again.\n", NOTE_STR);
            exit(1);
        }
        let funcID: usize = getFunctionByName(this, &indexoob);
        let args: RegIndexList = blank;
        push(&args, err);
        push(&args, rhs);
        let reg: RegIndex = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_NONE));
        {
            let ft = newType(TYPE_KIND_FUNCTION, TYPE_NONE);
            ft.arraySize = ft.arraySize | FUNC_TYPE_VARIADIC;
            let dst = allocateRegister(function, ft);
            buildLoadFunctionPtr(function, expr.span, dst, funcID);
            buildCall(function, expr.span, reg, dst, args);
        }
        buildUnreachable(function, expr.span);
        setCurrentBlock(function, normal);
    }
    let elemPtr: RegIndex = allocateRegister(function, at(&types, intoPointer(elemType)));
    let indices: RegIndexList = blank;
    if (isArray(lhsType)) {
        let index: RegIndex = allocateRegister(function, usizeType);
        buildLoadInteger(function, expr.span, index, usizeType, 0);
        push(&indices, index);
    }
    push(&indices, rhs);
    buildGetElementPtr(function, expr.span, elemPtr, lhs, indices);
    if (needsPtr) {
        return elemPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, elemType);
        buildLoad(function, expr.span, dst, elemPtr);
        return dst;
    }
}

func generateBytecodeExprIdentifier(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprIdentifier");
    assert(isIdentifier(expr));
    let isGlobal: bool = false;
    let entry: &IRScopeEntry = getIdentifierByName(this, function, expr.origToken.content, &isGlobal);
    if (entry != null) {
        let varType: &Type = getType(&expr.typeState);
        if (function.comptimeLevel > 0 && !entry.isComptime) {
            unreachable("Crossing the boundary: comptime IR needs runtime value - The Checker should've caught this");
        }
        if (needsPtr) {
            if (isGlobal) {
                let ptrType: &Type = at(&types, intoPointer(varType));
                let global: RegIndex = allocateRegister(function, ptrType);
                if (entry.isComptime) {
                    let val: RegIndex = allocateRegister(function, varType);
                    buildAlloca(function, expr.span, global, getSize(varType));
                    buildFetchGlobalComptimeValue(function, expr.span, val, entry.ptr);
                    buildStore(function, expr.span, global, val);
                } else {
                    buildFetchGlobalPointer(function, expr.span, global, entry.ptr);
                }
                return global;
            } else {
                if (entry.isComptime) {
                    let ptrType: &Type = at(&types, intoPointer(varType));
                    let global: RegIndex = allocateRegister(function, ptrType);
                    let val: RegIndex = allocateRegister(function, varType);
                    buildAlloca(function, expr.span, global, getSize(varType));
                    buildFetchLocalComptimeValue(function, expr.span, val, entry.ptr);
                    buildStore(function, expr.span, global, val);
                    return global;
                } else {
                    return entry.ptr;
                }
            }
        } else {
            let val: RegIndex = allocateRegister(function, varType);
            if (isGlobal) {
                if (entry.isComptime) {
                    buildFetchGlobalComptimeValue(function, expr.span, val, entry.ptr);
                } else {
                    buildFetchGlobalRuntimeValue(function, expr.span, val, entry.ptr);
                }
            } else {
                if (entry.isComptime) {
                    buildFetchLocalComptimeValue(function, expr.span, val, entry.ptr);
                } else {
                    buildLoad(function, expr.span, val, entry.ptr);
                }
            }
            return val;
        }
    } else {
        let t = getType(&expr.typeState);
        if (isModule(t)) {
            return allocateRegister(function, t);
        } else if (isFunction(t)) {
            let name: String = getMangledName(at(&funcDecls, expr.lhs));
            let funcID: usize = getFunctionByName(this, &name);
            let dst = allocateRegister(function, t);
            buildLoadFunctionPtr(function, expr.span, dst, funcID);
            return dst;
        } else if (isUnion(t)) {
            unreachable("generateBytecodeExprIdentifier: Unions should be handled in generateBytecodeExprIdentifier");
        } else {
            unreachable("Exhaustive handling of types in generateBytecodeExprIdentifier");
        }
    }
}

func generateBytecodeExprArithmetic(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprArithmetic");
    assert(isArithmetic(expr));
    let lhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    let lhsType: &Type = getType(&at(&exprs, expr.lhs).typeState);
    let rhsType: &Type = getType(&at(&exprs, expr.rhs).typeState);
    let res: &Type = getType(&expr.typeState);
    let dst: RegIndex = allocateRegister(function, res);
    // OPT: Specialized 8bit, 16bit, etc. variations
    if (expr.op == BIN_PLUS) {
        if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
            buildBinaryOp(function, expr.span, INSTR_INT_ADD, dst, lhs, rhs);
        } else if (isPointer(lhsType) && isInteger(rhsType)) {
            assert(isPointer(res), "PTR + INT expected to be PTR");
            buildPtrToInt(function, expr.span, lhs, lhs);
            buildBinaryOp(function, expr.span, INSTR_INT_ADD, dst, lhs, rhs);
            buildIntToPtr(function, expr.span, dst, dst);
        } else if (isInteger(lhsType) && isPointer(rhsType)) {
            assert(isPointer(res), "INT + PTR expected to be PTR");
            buildPtrToInt(function, expr.span, rhs, rhs);
            buildBinaryOp(function, expr.span, INSTR_INT_ADD, dst, lhs, rhs);
            buildIntToPtr(function, expr.span, dst, dst);
        } else if (isFloat(lhsType) && isFloat(rhsType)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_ADD, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_PLUS");
        }
    } else if (expr.op == BIN_SUB) {
        let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
            buildBinaryOp(function, expr.span, INSTR_INT_SUB, dst, lhs, rhs);
        } else if (isPointer(lhsType) && isInteger(rhsType)) {
            assert(isPointer(res), "PTR - INT expected to be PTR");
            let tmp1: RegIndex = allocateRegister(function, usizeType);
            let tmp2: RegIndex = allocateRegister(function, usizeType);
            buildPtrToInt(function, expr.span, tmp1, lhs);
            buildBinaryOp(function, expr.span, INSTR_INT_SUB, tmp2, tmp1, rhs);
            buildIntToPtr(function, expr.span, dst, tmp2);
        } else if (isInteger(lhsType) && isPointer(rhsType)) {
            assert(isPointer(res), "INT - PTR expected to be PTR");
            let tmp1: RegIndex = allocateRegister(function, usizeType);
            let tmp2: RegIndex = allocateRegister(function, usizeType);
            buildPtrToInt(function, expr.span, tmp1, rhs);
            buildBinaryOp(function, expr.span, INSTR_INT_SUB, tmp2, lhs, tmp1);
            buildIntToPtr(function, expr.span, dst, tmp2);
        } else if (isPointer(lhsType) && isPointer(rhsType)) {
            assert(isInteger(res), "PTR - PTR expected to be INT");
            let tmp1: RegIndex = allocateRegister(function, usizeType);
            let tmp2: RegIndex = allocateRegister(function, usizeType);
            buildPtrToInt(function, expr.span, tmp1, lhs);
            buildPtrToInt(function, expr.span, tmp2, rhs);
            buildBinaryOp(function, expr.span, INSTR_INT_SUB, dst, tmp1, tmp2);
        } else if (isFloat(lhsType) && isFloat(rhsType)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_SUB, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_SUB");
        }
    } else if (expr.op == BIN_MULT) {
        if (isInteger(res)) {
            buildBinaryOp(function, expr.span, INSTR_INT_MUL, dst, lhs, rhs);
        } else if (isFloat(res)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_MUL, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_MULT");
        }
    } else if (expr.op == BIN_DIV) {
        if (isInteger(res)) {
            buildBinaryOp(function, expr.span, INSTR_INT_DIV, dst, lhs, rhs);
        } else if (isFloat(res)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_DIV, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_DIV");
        }
    } else if (expr.op == BIN_MOD) {
        if (isInteger(res)) {
            buildBinaryOp(function, expr.span, INSTR_INT_MOD, dst, lhs, rhs);
        } else if (isFloat(res)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_MOD, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_MOD");
        }
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprArithmetic");
    }
    return dst;
}

func generateBytecodeExprComparison(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprComparison");
    assert(isComparison(expr));
    let lhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    let res: &Type = getType(&expr.typeState);
    assert(isBoolean(res), "Comparison expected to evaluate to Bool");
    let dst: RegIndex = allocateRegister(function, res);
    // OPT: Specialized 8bit, 16bit, etc. variations
    let t: &Type = getRegister(function, lhs).typ;
    if (expr.op == BIN_CMP_EQ) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_EQ, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_EQ, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_EQ");
        }
    } else if (expr.op == BIN_CMP_NEQ) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_NEQ, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_NEQ, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_NEQ");
        }
    } else if (expr.op == BIN_CMP_GT) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_GT, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_GT, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GT");
        }
    } else if (expr.op == BIN_CMP_GTE) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_GTE, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_GTE, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GTE");
        }
    } else if (expr.op == BIN_CMP_LT) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_LT, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_LT, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LT");
        }
    } else if (expr.op == BIN_CMP_LTE) {
        if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_LTE, dst, lhs, rhs);
        } else if (isFloat(t)) {
            buildBinaryOp(function, expr.span, INSTR_FLOAT_CMP_LTE, dst, lhs, rhs);
        } else {
            unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LTE");
        }
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprComparison");
    }
    return dst;
}

func generateBytecodeExprLogical(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprLogical");
    assert(isLogical(expr));
    let lhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    let t: &Type = getType(&expr.typeState);
    let dst: RegIndex = allocateRegister(function, t);
    if (expr.op == BIN_LAND) {
        buildBinaryOp(function, expr.span, INSTR_LOGICAL_AND, dst, lhs, rhs);
    } else if (expr.op == BIN_LOR) {
        buildBinaryOp(function, expr.span, INSTR_LOGICAL_OR, dst, lhs, rhs);
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprLogical");
    }
    return dst;
}

func generateBytecodeExprBitwise(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprBitwise");
    assert(isBitwise(expr));
    let lhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    let t: &Type = getType(&expr.typeState);
    let dst: RegIndex = allocateRegister(function, t);
    if (expr.op == BIN_BAND) {
        buildBinaryOp(function, expr.span, INSTR_BITWISE_AND, dst, lhs, rhs);
    } else if (expr.op == BIN_BOR) {
        buildBinaryOp(function, expr.span, INSTR_BITWISE_OR, dst, lhs, rhs);
    } else if (expr.op == BIN_BXOR) {
        buildBinaryOp(function, expr.span, INSTR_BITWISE_XOR, dst, lhs, rhs);
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprBitwise");
    }
    return dst;
}

func loadLiteral(this: &IRGen, function: &IRFunc, reg: RegIndex, tkn: &Token) -> RegIndex {
    let typ = getRegister(function, reg).typ;
    if (isInteger(typ) || isChar(typ)) {
        let _value: u64 = toU64(&tkn.content);
        let value: usize = _value as usize;
        let size: usize = bitCount(value);
        let typsize: usize = getSize(typ) * 8;
        if (isSignedInteger(typ)) size = size + 1;
        if (size > typsize) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            fprintf(stderr, "%s: %s: Integer literal (value=%llu) is too big for target type %s.\n",
                loc.buffer, ERR_STR, _value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        buildLoadInteger(function, tkn.span, reg, typ, value);
    } else if (isFloat(typ)) {
        let value: f64 = toF64(&tkn.content);
        assert(value >= 0, "Expected FloatLit value to be positive");
        let typmax: f64 = getMaxFloatValue(typ);
        if (value >= typmax) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            fprintf(stderr, "%s: %s: Float literal (value=%f) is too big for target type %s.\n",
                loc.buffer, ERR_STR, value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        if (getSize(typ) == 4) buildLoadF32(function, tkn.span, reg, value as f32);
        else if (getSize(typ) == 8) buildLoadF64(function, tkn.span, reg, value);
        else unreachable("load float");
    } else {
        unreachable("loadLiteral: Expected Integer, Char or Float");
    }
    return reg;
}

func generateBytecodeExprLiteral(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprLiteral");
    assert(isLiteral(expr));
    let t: &Type = getType(&expr.typeState);
    let reg: RegIndex = allocateRegister(function, t);
    if (expr.kind == EXPR_INT_LIT) {
        loadLiteral(this, function, reg, &expr.origToken);
    } else if (expr.kind == EXPR_STRING_LIT) {
        assert(isPointerTo(t, TYPE_CHAR), "StrLit expected to be &char");
        let name: SubStr = expr.origToken.content;
        buildLoadString(function, expr.span, reg, name);
    } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
        assert(isBoolean(t), "true and false expected to be bool");
        let v: usize = 0;
        if (expr.kind == EXPR_TRUE) v = 1;
        buildLoadBool(function, expr.span, reg, v);
    } else if (expr.kind == EXPR_NULL) {
        assert(isPointer(t), "null expected to be pointer");
        buildLoadNull(function, expr.span, reg);
    } else if (expr.kind == EXPR_CHAR_LIT) {
        assert(isChar(t), "CharLit expected to be char");
        buildLoadInteger(function, expr.span, reg, t, getChar(&expr.origToken.content, 0) as usize);
    } else if (expr.kind == EXPR_ARRAY_LIT) {
        assert(isArray(t), "ArrayLit expected to be array");
        if (getSize(t) > 4096) warning("Array Literal is big and slows down the IR");
        if (expr.arrayContext.size == 0) {
            if (getSize(t) == 0 && *flags.warnSimple) {
                // array literal of the form []
                let loc = toString(&expr.span);
                fprintf(stderr, "%s: %s: Array is zero-sized and can never be indexed into.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            buildCreateArray(function, expr.span, reg);
            for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
                let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&expr.arrayContext, i));
                let result: RegIndex = generateBytecodeExpr(this, function, elem, false);
                buildInsertValue(function, expr.span, reg, i, result);
            }
            if (needsPtr) {
                let subType: &Type = at(&types, intoPointer(t));
                let ptr: RegIndex = allocateRegister(function, subType);
                buildAlloca(function, expr.span, ptr, getSize(t));
                buildStore(function, expr.span, ptr, reg);
                return ptr;
            } else {
                return reg;
            }
        } else {
            let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&expr.arrayContext, 0));
            let value: RegIndex = generateBytecodeExpr(this, function, elem, false);
            let usizeType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
            let boolType: &Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            let elemType: &Type = getType(&elem.typeState);
            let arrayPtr: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
            let zero: RegIndex = allocateRegister(function, usizeType);
            let one: RegIndex = allocateRegister(function, usizeType);
            let index: RegIndex = allocateRegister(function, usizeType);
            let indexPtr: RegIndex = allocateRegister(function, at(&types, intoPointer(usizeType)));
            let size: RegIndex = allocateRegister(function, usizeType);
            let cond: RegIndex = allocateRegister(function, boolType);
            let elemPtr: RegIndex = allocateRegister(function, elemType);

            let start: IRBlockID = appendBlock(function);
            let body: IRBlockID = appendBlock(function);
            let end: IRBlockID = appendBlock(function);

            buildAlloca(function, expr.span, arrayPtr, getSize(t));
            buildAlloca(function, expr.span, indexPtr, getSize(usizeType));
            buildLoadInteger(function, expr.span, zero, usizeType, 0);
            buildLoadInteger(function, expr.span, one, usizeType, 1);
            buildStore(function, expr.span, indexPtr, zero);
            buildLoadInteger(function, expr.span, size, usizeType, expr.arrayContext.size);
            buildBr(function, expr.span, start);

            setCurrentBlock(function, start);
            buildLoad(function, expr.span, index, indexPtr);
            buildBinaryOp(function, expr.span, INSTR_INT_CMP_LT, cond, index, size);
            buildCondBr(function, expr.span, cond, body, end);

            setCurrentBlock(function, body);
            let indices: RegIndexList = blank;
            push(&indices, zero);
            push(&indices, index);
            buildGetElementPtr(function, expr.span, elemPtr, arrayPtr, indices);
            buildStore(function, expr.span, elemPtr, value);

            buildLoad(function, expr.span, index, indexPtr);
            buildBinaryOp(function, expr.span, INSTR_INT_ADD, index, index, one);
            buildStore(function, expr.span, indexPtr, index);
            buildBr(function, expr.span, start);

            setCurrentBlock(function, end);
            if (needsPtr) {
                return arrayPtr;
            } else {
                buildLoad(function, expr.span, reg, arrayPtr);
                return reg;
            }
        }
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprLiteral");
    }
    if (needsPtr) {
        let tempAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(t)));
        buildAlloca(function, expr.span, tempAlloc, getSize(t));
        buildStore(function, expr.span, tempAlloc, reg);
        return tempAlloc;
    }
    return reg;
}

func generateBytecodeExprAssignment(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprAssignment");
    assert(isAssignment(expr));
    let lhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), true);
    let rhs: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.rhs), false);
    assert(isPointer(getRegister(function, lhs).typ), "Assignment expected Ptr as LHS");
    buildStore(function, expr.span, lhs, rhs);
    return rhs;
}

func generateBytecodeExprUnary(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprUnary");
    assert(isUnary(expr));
    if (expr.op == UNARY_COMPTIME) {
        startComptime(function);
        let subexpr: &ParsedExpr = at(&exprs, expr.lhs);
        let result: RegIndex = generateBytecodeExpr(this, function, subexpr, false);
        let exprType = getType(&expr.typeState);
        let r: RegIndex = allocateRegister(function, exprType);
        endComptime(function);
        buildFetchLocalComptimeValue(function, expr.span, r, result);
        if (needsPtr) {
            let subType: &Type = at(&types, intoPointer(exprType));
            let ptr: RegIndex = allocateRegister(function, subType);
            buildAlloca(function, expr.span, ptr, getSize(exprType));
            buildStore(function, expr.span, ptr, r);
            return ptr;
        } else {
            return r;
        }
    } else if (expr.op == UNARY_DEREF) {
        let subexpr: &ParsedExpr = at(&exprs, expr.lhs);
        let result: RegIndex = generateBytecodeExpr(this, function, subexpr, false);
        let ptr: &IRReg = getRegister(function, result);
        assert(isPointer(ptr.typ), "Expected Ptr SubExpr in Unary Deref");
        if (needsPtr) {
            return result;
        } else {
            let t: &Type = getType(&expr.typeState);
            let val: RegIndex = allocateRegister(function, t);
            buildLoad(function, expr.span, val, result);
            return val;
        }
    } else if (expr.op == UNARY_REF) {
        let subExpr: &ParsedExpr = at(&exprs, expr.lhs);
        let result: RegIndex = generateBytecodeExpr(this, function, subExpr, true);
        let ptrReg: &IRReg = getRegister(function, result);
        if (needsPtr || !isPointer(ptrReg.typ)) {
            let subType: &Type = at(&types, intoPointer(ptrReg.typ));
            let ptr: RegIndex = allocateRegister(function, subType);
            buildAlloca(function, expr.span, ptr, getSize(ptrReg.typ));
            buildStore(function, expr.span, ptr, result);
            return ptr;
        } else {
            return result;
        }
    } else if (expr.op == UNARY_NOT) {
        let result: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
        let r: RegIndex = allocateRegister(function, getType(&expr.typeState));
        buildLogicalNot(function, expr.span, r, result);
        return r;
    } else if (expr.op == UNARY_MINUS) {
        let result: RegIndex = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
        let t: &Type = getType(&expr.typeState);
        if (isInteger(t)) {
            let zero: RegIndex = allocateRegister(function, t);
            buildLoadInteger(function, expr.span, zero, t, 0);
            buildBinaryOp(function, expr.span, INSTR_INT_SUB, result, zero, result);
        } else if (isFloat(t)) {
            let zero: RegIndex = allocateRegister(function, t);
            if (getSize(t) == 4) buildLoadF32(function, expr.span, zero, 0);
            else if (getSize(t) == 8) buildLoadF64(function, expr.span, zero, 0);
            else unreachable("negation float");
            buildBinaryOp(function, expr.span, INSTR_FLOAT_SUB, result, zero, result);
        } else {
            unreachable("Exhaustive handling of negation variants in generateBytecodeExprUnary");
        }
        return result;
    } else {
        unreachable("Exhaustive handling of ops in generateBytecodeExprUnary");
    }
}

func prepareParameter(this: &IRGen, function: &IRFunc, index: usize, span: Span, name: SubStr, typ: &Type, retValue: bool) {
    trace("IRGen.prepareParameter");
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        } else if (size <= 2) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
        } else if (size <= 4) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
        } else if (size <= 8) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
        } else {
            t = newType(TYPE_KIND_POINTER, TYPE_U8);
        }
        let value: RegIndex = allocateRegister(function, t);
        buildGetParam(function, span, value, index, getSize(t));
        // value contains prepared struct
        let allocType: &Type = at(&types, intoPointer(typ));
        let allocReg: RegIndex = allocateRegister(function, allocType);
        if (isPointer(t)) {
            let instance: RegIndex = allocateRegister(function, typ);
            buildLoad(function, span, instance, value);

            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, instance);
            addEntry(last(&function.scopes), name, allocReg, false);
        } else {
            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, value);
            addEntry(last(&function.scopes), name, allocReg, false);
        }
    } else if (getSize(typ) > 8) {
        let t = newType(TYPE_KIND_POINTER, TYPE_U8);
        let value: RegIndex = allocateRegister(function, t);
        let allocType: &Type = at(&types, intoPointer(typ));
        let allocReg: RegIndex = allocateRegister(function, allocType);
        buildGetParam(function, span, value, index, getSize(t));
        let instance: RegIndex = allocateRegister(function, typ);
        buildLoad(function, span, instance, value);

        buildAlloca(function, span, allocReg, getSize(typ));
        buildStore(function, span, allocReg, instance);
        addEntry(last(&function.scopes), name, allocReg, false);
    } else {
        let allocType: &Type = at(&types, intoPointer(typ));
        let allocReg: RegIndex = allocateRegister(function, allocType);
        let value: RegIndex = allocateRegister(function, typ);
        buildGetParam(function, span, value, index, getSize(typ));

        if (retValue) {
            assert(index == 0);
            (*function).retPtr = value;
        } else {
            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, value);
            addEntry(last(&function.scopes), name, allocReg, false);
        }
    }
}

func getRegisterForSize(this: &IRGen, function: &IRFunc, size: usize) -> RegIndex {
    trace("IRGen.getRegisterForSize");
    let v: RegIndex = blank;
    if (size <= 1) {
        v = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_U8));
    } else if (size <= 2) {
        v = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_U16));
    } else if (size <= 4) {
        v = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_U32));
    } else if (size <= 8) {
        v = allocateRegister(function, newType(TYPE_KIND_PRIMITIVE, TYPE_U64));
    } else {
        unreachable("getRegisterForSize called with size > 8");
    }
    return v;
}

func prepareArgument(this: &IRGen, function: &IRFunc, span: Span, value: RegIndex, typ: &Type) -> RegIndex {
    trace("IRGen.prepareArgument");
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let alloc: RegIndex = allocateRegister(function, at(&types, intoPointer(typ)));
        buildAlloca(function, span, alloc, size);
        buildStore(function, span, alloc, value);
        if (size > 8) return alloc;
        let v: RegIndex = getRegisterForSize(this, function, size);
        buildLoad(function, span, v, alloc);
        return v;
    } else if (getSize(typ) > 8) {
        // Following the ABI, all parameters that don't fit in a register get passed by pointer
        let tempAlloc: RegIndex = allocateRegister(function, at(&types, intoPointer(typ)));
        buildAlloca(function, span, tempAlloc, getSize(typ));
        buildStore(function, span, tempAlloc, value);
        return tempAlloc;
    } else {
        return value;
    }
}

func generateBytecodeExprCall(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprCall");
    assert(isCall(expr));
    let base = generateBytecodeExpr(this, function, at(&exprs, expr.lhs), false);
    let typ: &Type = getType(&expr.typeState);
    let args: RegIndexList = blank;
    let retPtr: RegIndex = blank;
    if (getSize(typ) > 8) {
        retPtr = allocateRegister(function, at(&types, intoPointer(typ)));
        buildAlloca(function, expr.span, retPtr, getSize(typ));
        push(&args, retPtr);
    }
    for (let i: usize = 0; i < expr.arrayContext.elemLength; i = i + 1) {
        let arg: &ParsedExpr = at(&exprs, getElementAtIndex(&expr.arrayContext, i));
        let argType: &Type = getType(&arg.typeState);
        let result: RegIndex = generateBytecodeExpr(this, function, arg, false);
        push(&args, prepareArgument(this, function, arg.span, result, argType));
    }
    return prepareReturnValue(this, expr.span, function, base, args, typ, retPtr, needsPtr);
}

func newIRGenerator() -> IRGen {
    return IRGen {
        globalScope: IRFunc {
            name: newStringFromStrLit("__global__"),
            originalID: funcDecls.length + 1,
            comptimeLevel: 0,
        },
    };
}
