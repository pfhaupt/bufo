import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "type_info.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/hashmaps.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../frontend/lexer.bufo";
import "../middleend/lookup.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./codegen_llvm.bufo";
import "./LLVM/values.bufo";

struct RegIndex {
    i: usize;
}
func equals(this: &RegIndex, other: &RegIndex) -> bool {
    return this.i == other.i;
}

struct IRReg {
    isComptime: bool;
    offset: usize;
    typ: &Type;
}
func equals(this: &IRReg, other: &IRReg) -> bool {
    unreachable("IRReg.equals is not implemented yet");
}

// NOTE: When you update this list, you must also update the function pointers in the interpreter
// FIXME: IMPORTANT: Make this an union
comptime INSTR_INVALID             : usize = 0;
comptime INSTR_ALLOCA              : usize = 1;
comptime INSTR_GET_PARAM           : usize = 2;
comptime INSTR_STORE               : usize = 3;
comptime INSTR_FETCH_GLOBAL_PTR    : usize = 4;
comptime INSTR_FETCH_GLOBAL_VALUE  : usize = 5;
comptime INSTR_FETCH_COMPTIME_VALUE: usize = 6;
comptime INSTR_LOAD_FUNCTION_PTR   : usize = 7;
comptime INSTR_LOAD                : usize = 8;
comptime INSTR_MOVE                : usize = 9;
comptime INSTR_CALL                : usize = 10;
comptime INSTR_RETURN_EXPR         : usize = 11;
comptime INSTR_RETURN_VOID         : usize = 12;
comptime INSTR_LOAD_STRING         : usize = 13;
comptime INSTR_LOAD_BOOL           : usize = 14;
comptime INSTR_LOAD_I8             : usize = 15;
comptime INSTR_LOAD_U8             : usize = 16;
comptime INSTR_LOAD_I16            : usize = 17;
comptime INSTR_LOAD_U16            : usize = 18;
comptime INSTR_LOAD_I32            : usize = 19;
comptime INSTR_LOAD_U32            : usize = 20;
comptime INSTR_LOAD_I64            : usize = 21;
comptime INSTR_LOAD_U64            : usize = 22;
comptime INSTR_LOAD_NULL           : usize = 23;
comptime INSTR_LOAD_F32            : usize = 24;
comptime INSTR_LOAD_F64            : usize = 25;
comptime INSTR_LOAD_BLANK          : usize = 26;
comptime INSTR_COND_BR             : usize = 27;
comptime INSTR_BR                  : usize = 28;
comptime INSTR_INT_ADD             : usize = 29;
comptime INSTR_INT_SUB             : usize = 30;
comptime INSTR_INT_MUL             : usize = 31;
comptime INSTR_INT_DIV             : usize = 32;
comptime INSTR_INT_MOD             : usize = 33;
comptime INSTR_INT_CMP_EQ          : usize = 34;
comptime INSTR_INT_CMP_NEQ         : usize = 35;
comptime INSTR_INT_CMP_GT          : usize = 36;
comptime INSTR_INT_CMP_GTE         : usize = 37;
comptime INSTR_INT_CMP_LT          : usize = 38;
comptime INSTR_INT_CMP_LTE         : usize = 39;
comptime INSTR_FLOAT_ADD           : usize = 40;
comptime INSTR_FLOAT_SUB           : usize = 41;
comptime INSTR_FLOAT_MUL           : usize = 42;
comptime INSTR_FLOAT_DIV           : usize = 43;
comptime INSTR_FLOAT_MOD           : usize = 44;
comptime INSTR_FLOAT_CMP_EQ        : usize = 45;
comptime INSTR_FLOAT_CMP_NEQ       : usize = 46;
comptime INSTR_FLOAT_CMP_GT        : usize = 47;
comptime INSTR_FLOAT_CMP_GTE       : usize = 48;
comptime INSTR_FLOAT_CMP_LT        : usize = 49;
comptime INSTR_FLOAT_CMP_LTE       : usize = 50;
comptime INSTR_LOGICAL_NOT         : usize = 51;
comptime INSTR_LOGICAL_AND         : usize = 52;
comptime INSTR_LOGICAL_OR          : usize = 53;
comptime INSTR_BITWISE_AND         : usize = 54;
comptime INSTR_BITWISE_OR          : usize = 55;
comptime INSTR_BITWISE_XOR         : usize = 56;
comptime INSTR_INSERT_VALUE        : usize = 57;
comptime INSTR_INT_SIGN_EXTEND     : usize = 58;
comptime INSTR_INT_ZERO_EXTEND     : usize = 59;
comptime INSTR_INT_TRUNCATE        : usize = 60;
comptime INSTR_INT_TO_F32          : usize = 61;
comptime INSTR_INT_TO_F64          : usize = 62;
comptime INSTR_F32_TO_INT          : usize = 63;
comptime INSTR_F64_TO_INT          : usize = 64;
comptime INSTR_F32_TO_F64          : usize = 65;
comptime INSTR_F64_TO_F32          : usize = 66;
comptime INSTR_CREATE_ARRAY        : usize = 67;
comptime INSTR_CREATE_STRUCT       : usize = 68;
comptime INSTR_CREATE_UNION        : usize = 69;
comptime INSTR_PTR_TO_INT          : usize = 70;
comptime INSTR_INT_TO_PTR          : usize = 71;
comptime INSTR_GET_FIELD_PTR       : usize = 72;
comptime INSTR_GET_ELEMENT_PTR     : usize = 73;
comptime INSTR_UNREACHABLE         : usize = 74;
comptime INSTR_UNTERMINATED        : usize = 75;
comptime INSTR_MEMCPY              : usize = 76;
comptime INSTR_EMIT_ASSEMBLY       : usize = 77;
comptime INSTR_INTO_IR_VALUE       : usize = 78;
comptime INSTR_DEBUG_INFO_ALLOCA   : usize = 79;
comptime INSTR_DEBUG_INFO_PARAM    : usize = 80;
struct IRInstr {
    kind: usize;
    span: Span;
    isComptime: bool;
    dst: RegIndex;
    src: RegIndex;
    op1: RegIndex;
    args: RegIndexList;
}
func equals(this: &IRInstr, other: &IRInstr) -> bool {
    unreachable("IRInstr.equals is not implemented yet");
}
func isTerminator(this: &IRInstr) -> bool {
    return this.kind == INSTR_RETURN_EXPR
        || this.kind == INSTR_RETURN_VOID
        || this.kind == INSTR_COND_BR
        || this.kind == INSTR_BR
        || this.kind == INSTR_UNREACHABLE
        || this.kind == INSTR_UNTERMINATED;
}
func dump(this: &IRInstr) {
    if (!*flags.emitBIR && this.isComptime) C::printf("\x1b[92m");
    if (*flags.debug) {
        let s = toString(&this.span);
        C::printf("%s ", s.buffer);
        drop(&s);
    }
    if (this.kind == INSTR_ALLOCA) C::printf("r%llu = Alloca %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_PARAM) C::printf("r%llu = GetParam %llu (%llu bytes)", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_STORE) C::printf("Store r%llu, r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_PTR) C::printf("r%llu = FetchGlobalPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_VALUE) C::printf("r%llu = FetchGlobalValue r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_COMPTIME_VALUE) C::printf("r%llu = FetchComptimeValue r%llu, global=%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD) C::printf("r%llu = Load r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_FUNCTION_PTR) C::printf("r%llu = LoadFunctionPtr %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_MOVE) C::printf("r%llu = Move r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CALL) {
        C::printf("r%llu = Call r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            C::printf(", r%llu", at(&this.args, i).i);
        }
    } else if (this.kind == INSTR_RETURN_EXPR) C::printf("RetExpr r%llu", this.src.i);
    else if (this.kind == INSTR_RETURN_VOID) C::printf("RetVoid");
    else if (this.kind == INSTR_LOAD_STRING) C::printf("r%llu = LoadString %p, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD_BOOL) C::printf("r%llu = Load Bool %hhu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I8) C::printf("r%llu = Load I8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U8) C::printf("r%llu = Load U8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I16) C::printf("r%llu = Load I16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U16) C::printf("r%llu = Load U16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I32) C::printf("r%llu = Load I32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U32) C::printf("r%llu = Load U32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I64) C::printf("r%llu = Load I64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U64) C::printf("r%llu = Load U64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_NULL) C::printf("r%llu = Load Null", this.dst.i);
    else if (this.kind == INSTR_LOAD_F32) C::printf("r%llu = Load F32 %f", this.dst.i, *(&this.src.i as &f32) as f64);
    else if (this.kind == INSTR_LOAD_F64) C::printf("r%llu = Load F64 %f", this.dst.i, *(&this.src.i as &f64));
    else if (this.kind == INSTR_LOAD_BLANK) C::printf("r%llu = Load Blank", this.dst.i);
    else if (this.kind == INSTR_COND_BR) C::printf("CondBr r%llu, true=%llu, false=%llu", this.src.i, this.dst.i, this.op1.i);
    else if (this.kind == INSTR_BR) C::printf("Br %llu", this.dst.i);
    else if (this.kind == INSTR_INT_ADD) C::printf("r%llu = AddInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SUB) C::printf("r%llu = SubInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MUL) C::printf("r%llu = MulInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_DIV) C::printf("r%llu = DivInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MOD) C::printf("r%llu = ModInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_EQ) C::printf("r%llu = ICmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_NEQ) C::printf("r%llu = ICmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GT) C::printf("r%llu = ICmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GTE) C::printf("r%llu = ICmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LT) C::printf("r%llu = ICmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LTE) C::printf("r%llu = ICmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_ADD) C::printf("r%llu = AddFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_SUB) C::printf("r%llu = SubFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MUL) C::printf("r%llu = MulFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_DIV) C::printf("r%llu = DivFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MOD) C::printf("r%llu = ModFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_EQ) C::printf("r%llu = FCmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_NEQ) C::printf("r%llu = FCmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GT) C::printf("r%llu = FCmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GTE) C::printf("r%llu = FCmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LT) C::printf("r%llu = FCmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LTE) C::printf("r%llu = FCmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_NOT) C::printf("r%llu = LNot r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOGICAL_AND) C::printf("r%llu = LAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_OR) C::printf("r%llu = LOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_AND) C::printf("r%llu = BAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_OR) C::printf("r%llu = BOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_XOR) C::printf("r%llu = BXOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INSERT_VALUE) C::printf("r%llu = InsertValue r%llu, %llu, r%llu", this.dst.i, this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SIGN_EXTEND) C::printf("r%llu = IntSExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_ZERO_EXTEND) C::printf("r%llu = IntZExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TRUNCATE) C::printf("r%llu = IntTrunc r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TO_F32) C::printf("r%llu = IntToF32 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) C::printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_INT) C::printf("r%llu = F32ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_INT) C::printf("r%llu = F64ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) C::printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_F64) C::printf("r%llu = FloatExt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_F32) C::printf("r%llu = FloatTrunc r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CREATE_ARRAY) C::printf("r%llu = CreateArray", this.dst.i);
    else if (this.kind == INSTR_CREATE_STRUCT) C::printf("r%llu = CreateStruct", this.dst.i);
    else if (this.kind == INSTR_CREATE_UNION) C::printf("r%llu = CreateUnion", this.dst.i);
    else if (this.kind == INSTR_PTR_TO_INT) C::printf("r%llu = PtrToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_PTR) C::printf("r%llu = IntToPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_FIELD_PTR) C::printf("r%llu = GetFieldPtr r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_UNREACHABLE) C::printf("unreachable");
    else if (this.kind == INSTR_UNTERMINATED) C::printf("<unterminated block>");
    else if (this.kind == INSTR_MEMCPY) C::printf("Memcpy r%llu, r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_EMIT_ASSEMBLY) C::printf("EmitAsm r%llu (%s)", this.src.i, toString(this.op1.i as &Type).buffer);
    else if (this.kind == INSTR_INTO_IR_VALUE) C::printf("r%llu = IntoIRValue r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_DEBUG_INFO_ALLOCA) C::printf("<Debug Info Alloca>");
    else if (this.kind == INSTR_DEBUG_INFO_PARAM) C::printf("<Debug Info Param>");
    else if (this.kind == INSTR_GET_ELEMENT_PTR) {
        C::printf("r%llu = GetElementPtr r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            C::printf(", r%llu", at(&this.args, i).i);
        }
    } else {
        C::fprintf(stderr, "kind: %llu\n", this.kind);
        unreachable("Exhaustive handling in IRInstr.dump()");
    }
    if (!*flags.emitBIR && this.isComptime) C::printf("\x1b[0m\n"); else C::printf("\n");
}

struct LoopBlock {
    before: IRBlockID;
    after: IRBlockID;
}
func equals(this: &LoopBlock, other: &LoopBlock) -> bool {
    return this.before.i == other.before.i && this.after.i == other.after.i;
}

struct IRBlockID {
    i: usize;
}
struct IRBlock {
    parent: String;
    id: IRBlockID;
    instructions: IRInstrList;
}
func equals(this: &IRBlock, other: &IRBlock) -> bool {
    return equals(&this.parent, &other.parent) && this.id.i == other.id.i;
}
func isTerminated(this: &IRBlock) -> bool {
    if (this.instructions.length == 0) return false;
    return isTerminator(last(&this.instructions));
}
func dump(this: &IRBlock) {
    C::printf("b%llu:\n", this.id);
    for (let i: usize = 0; i < this.instructions.length; i = i + 1) {
        C::printf("  %4d: ", i);
        dump(at(&this.instructions, i));
    }
}
func pushInstruction(this: &IRBlock, instr: IRInstr) {
    push(&this.instructions, instr);
}
func insertInstruction(this: &IRBlock, index: usize, instr: IRInstr) {
    assert(index <= this.instructions.length, "Out of bounds in insertInstruction");
    let instructions = IRInstrList {};
    for (let i: usize = 0; i < index; i = i + 1) {
        push(&instructions, *at(&this.instructions, i));
    }
    push(&instructions, instr);
    for (let i: usize = index; i < this.instructions.length; i = i + 1) {
        push(&instructions, *at(&this.instructions, i));
    }
    drop(&this.instructions);
    this.instructions = instructions;
}

struct IRFunc {
    originalID: usize;
    name: String;
    span: Span;
    comptimeLevel: usize;
    scopes: IRScopeList;
    registers: IRRegList;
    blocks: IRBlockList;
    loopBlocks: LoopBlockList;
    currentBlock: IRBlockID;
    llvmFunc: LLVMValue;
    retPtr: RegIndex;
    attrs: ParsedAttributeList;
    returnBlockID: IRBlockID;
    returnAlloc: RegIndex;
    allocaCounter: usize;
}
func hasAttribute(this: &IRFunc, attr: usize) -> bool {
    for (let i: usize = 0; i < this.attrs.length; i = i + 1) {
        if (at(&this.attrs, i).kind == attr) return true;
    }
    return false;
}
func isExtern(this: &IRFunc) -> bool {
    return isExtern(getFuncNode(this));
}
func appendBlock(this: &IRFunc) -> IRBlockID {
    let id: IRBlockID = IRBlockID { i: this.blocks.length };
    push(&this.blocks, IRBlock {
        parent: this.name,
        id: id,
    });
    return id;
}
func setCurrentBlock(this: &IRFunc, id: IRBlockID) {
    assert(id.i < this.blocks.length, "setCurrentBlock called with invalid ID");
    this.currentBlock = id;
}
func getCurrentBlock(this: &IRFunc) -> IRBlockID {
    assert(this.blocks.length > 0, "getCurrentBlock called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlock points to invalid block");
    return this.currentBlock;
}
func getCurrentBlockAsRef(this: &IRFunc) -> &IRBlock {
    assert(this.blocks.length > 0, "getCurrentBlockAsRef called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlockAsRef points to invalid block");
    return at(&this.blocks, this.currentBlock.i);
}
func getBlockByID(this: &IRFunc, id: IRBlockID) -> &IRBlock {
    assert(this.blocks.length > 0, "getBlockByID called on empty IRFunc");
    assert(id.i < this.blocks.length, "getBlockByID called with invalid ID");
    return at(&this.blocks, id.i);
}
func pushLoopBlocks(this: &IRFunc, before: IRBlockID, after: IRBlockID) {
    push(&this.loopBlocks, LoopBlock {
        before: before,
        after: after,
    });
}
func popLoopBlocks(this: &IRFunc) {
    pop(&this.loopBlocks);
}
func getFuncNode(this: &IRFunc) -> &ParsedFuncDecl {
    return at(&funcDecls, this.originalID);
}
func dumpInstructions(this: &IRFunc) {
    C::printf("%s:\n", this.name.buffer);
    for (let i: usize = 0; i < this.blocks.length; i = i + 1) {
        dump(at(&this.blocks, i));
    }
}
func equals(this: &IRFunc, other: &IRFunc) -> bool {
    unreachable("IRFunc.equals is not implemented yet");
}
func enterScope(this: &IRFunc) -> usize {
    push(&this.scopes, blank);
    return this.scopes.length;
}
func leaveScope(this: &IRFunc) -> usize {
    let s: usize = this.scopes.length;
    pop(&this.scopes);
    return s;
}
func startComptime(this: &IRFunc) {
    this.comptimeLevel = this.comptimeLevel + 1;
}
func endComptime(this: &IRFunc) {
    assert(this.comptimeLevel > 0);
    this.comptimeLevel = this.comptimeLevel - 1;
}
func getRegisterSizeInBytes(this: &IRFunc) -> usize {
    let size: usize = 0;
    for (let i: usize = 0; i < this.registers.length; i = i + 1) {
        let reg: &IRReg = getRegister(this, RegIndex { i: i });
        size = size + getSizeInBytes(reg.typ);
    }
    return size;
}
func allocateRegister(this: &IRFunc, typ: &Type) -> RegIndex {
    let size: usize = this.registers.length;
    let offset: usize = 0;
    if (size > 0) {
        let last: &IRReg = last(&this.registers);
        offset = last.offset + getSizeInBytes(last.typ);
    }
    push(&this.registers, IRReg {
        isComptime: this.comptimeLevel > 0,
        offset: offset,
        typ: typ,
    });
    return RegIndex { i: size };
}
func getRegister(this: &IRFunc, index: RegIndex) -> &IRReg {
    assert(index.i < this.registers.length, "Out of bounds access in IRFunc.getRegister");
    return at(&this.registers, index.i);
}
func getIdentifierByName(this: &IRFunc, name: SubStr) -> &IRScopeEntry {
    for (let _i: usize = 0; _i < this.scopes.length; _i = _i + 1) {
        let i: usize = this.scopes.length - _i - 1;
        let entry: &IRScopeEntry = getIdentifierByName(at(&this.scopes, i), name);
        if (entry != null) {
            return entry;
        }
    }
    return null;
}
func pushInstruction(this: &IRFunc, instr: IRInstr) {
    assert(this.blocks.length > 0, "IRFunc.pushInstruction called on empty block list");
    assert(this.currentBlock.i < this.blocks.length, "IRFunc.pushInstruction: Current block was invalid");
    pushInstruction(at(&this.blocks, this.currentBlock.i), instr);
}
comptime PARAM_SHIFT: usize = 6;
func buildDebugInfoParam(this: &IRFunc, span: Span, dst: RegIndex, index: usize, name: SubStr) {
    let val = shiftLeft(name.start as usize, PARAM_SHIFT) + index;
    pushInstruction(this, IRInstr {
        kind: INSTR_DEBUG_INFO_PARAM,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
        op1: RegIndex { i: name.len },
    });
}
func buildDebugInfoAlloca(this: &IRFunc, span: Span, dst: RegIndex, name: SubStr) {
    pushInstruction(this, IRInstr {
        kind: INSTR_DEBUG_INFO_ALLOCA,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: name.start as usize },
        op1: RegIndex { i: name.len },
    });
}
func buildAlloca(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    let alloca: IRInstr = IRInstr {
        kind: INSTR_ALLOCA,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    };
    let entry: &IRBlock = getBlockByID(this, IRBlockID { i: 0 });
    insertInstruction(entry, this.allocaCounter, alloca);
    this.allocaCounter = this.allocaCounter + 1;
}
func buildFetchGlobalPointer(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalRuntimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 1 },
    });
}
func buildFetchLocalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 0 },
    });
}
func buildLoadFunctionPtr(this: &IRFunc, span: Span, dst: RegIndex, funcID: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_FUNCTION_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: funcID },
    });
}
func buildLoad(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildMove(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MOVE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetParam(this: &IRFunc, span: Span, dst: RegIndex, index: usize, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_PARAM,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: index },
        op1: RegIndex { i: size },
    });
}
func buildStore(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_STORE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCall(this: &IRFunc, span: Span, dst: RegIndex, funcID: RegIndex, args: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CALL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: funcID,
        args: args,
    });
}
func buildReturnExpr(this: &IRFunc, span: Span, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_EXPR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        src: val,
    });
}
func buildReturnEmpty(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_VOID,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildLoadString(this: &IRFunc, span: Span, dst: RegIndex, str: SubStr) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_STRING,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: str.start as usize },
        op1: RegIndex { i: str.len },
    });
}
func buildLoadBool(this: &IRFunc, span: Span, dst: RegIndex, val: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BOOL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadInteger(this: &IRFunc, span: Span, dst: RegIndex, t: &Type, val: usize) {
    let kind: usize = INSTR_LOAD_I8;
    if (isChar(t)) {
        kind = INSTR_LOAD_U8;
    } else {
        assert(isInteger(t), "IRFunc.buildLoadInteger got non-int type");
        let size: usize = getSizeInBytes(t);
        if (size == 2) kind = INSTR_LOAD_I16;
        if (size == 4) kind = INSTR_LOAD_I32;
        if (size == 8) kind = INSTR_LOAD_I64;
        if (!isSignedInteger(t)) kind = kind + 1;
    }
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadNull(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_NULL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildLoadF32(this: &IRFunc, span: Span, dst: RegIndex, val: f32) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadF64(this: &IRFunc, span: Span, dst: RegIndex, val: f64) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadBlank(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BLANK,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    });
}
func buildLogicalNot(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOGICAL_NOT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildBinaryOp(this: &IRFunc, span: Span, kind: usize, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: lhs,
        op1: rhs,
    });
}
func buildInsertValue(this: &IRFunc, span: Span, aggr: RegIndex, index: usize, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INSERT_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: aggr,
        src: RegIndex { i: index },
        op1: val,
    });
}
func buildUnreachable(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNREACHABLE,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildUnterminated(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNTERMINATED,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildBr(this: &IRFunc, span: Span, block: IRBlockID) {
    assert(block.i < this.blocks.length, "buildBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: block.i },
    });
}
func buildCondBr(this: &IRFunc, span: Span, cond: RegIndex, drue: IRBlockID, falze: IRBlockID) {
    assert(drue.i < this.blocks.length, "buildCondBr called with invalid ID");
    assert(falze.i < this.blocks.length, "buildCondBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_COND_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: drue.i },
        src: cond,
        op1: RegIndex { i: falze.i },
    });
}
func buildBreak(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.after);
    return true;
}
func buildContinue(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.before);
    return true;
}
func buildIntSignExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_SIGN_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntZeroExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_ZERO_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntTruncate(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TRUNCATE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildF32ToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF32ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCreateArray(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_ARRAY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateStruct(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_STRUCT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateUnion(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_UNION,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildPtrToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_PTR_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToPtr(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetFieldPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, index: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_FIELD_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        op1: RegIndex { i: index },
    });
}
func buildGetElementPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, indices: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_ELEMENT_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        args: indices,
    });
}
func buildMemcpy(this: &IRFunc, span: Span, src: RegIndex, dst: RegIndex, size: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MEMCPY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: size,
    });
}
func buildEmitAssembly(this: &IRFunc, span: Span, context: RegIndex, fnType: &Type) {
    pushInstruction(this, IRInstr {
        kind: INSTR_EMIT_ASSEMBLY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        src: context,
        op1: RegIndex { i: fnType as usize }
    });
}
func buildIntoIRValue(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INTO_IR_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
struct IRScopeEntry {
    name: SubStr;
    ptr: RegIndex;
    isComptime: bool;
}
func equals(this: &IRScopeEntry, other: &IRScopeEntry) -> bool {
    unreachable("IRScopeEntry.equals is not implemented yet");
}

struct IRScope {
    entries: IRScopeEntryList;
}
func equals(this: &IRScope, other: &IRScope) -> bool {
        unreachable("IRScope.equals is not implemented yet");
}
func addEntry(this: &IRScope, name: SubStr, ptr: RegIndex, isComptime: bool) {
    push(&this.entries, IRScopeEntry {
        name: name,
        ptr: ptr,
        isComptime: isComptime,
    });
}
func getIdentifierByName(this: &IRScope, name: SubStr) -> &IRScopeEntry {
    for (let i: usize = 0; i < this.entries.length; i = i + 1) {
        let entry: &IRScopeEntry = at(&this.entries, i);
        if (equals(&name, &entry.name)) {
            return entry;
        }
    }
    return null;
}

struct IRGen {
    lookup: &Lookup;
    globalScope: IRFunc;
    initRuntime: IRFunc;
    functions: String_IRFuncHashMap;
    type_info_table: TypeInfoTable;
    type_info_array_register: RegIndex;
    error: bool;
}
func getIdentifierByName(this: &IRGen, function: &IRFunc, name: SubStr, isGlobal: &bool) -> &IRScopeEntry {
    let entry: &IRScopeEntry = getIdentifierByName(function, name);
    if (entry != null) {
        *isGlobal = false;
        return entry;
    }
    entry = getIdentifierByName(&this.globalScope, name);
    if (entry != null) {
        *isGlobal = true;
        return entry;
    }
    return null;
}
func getFunctionByName(this: &IRGen, name: &String) -> usize {
    return indexOf(&this.functions, name);
}
func getFunctionByMangledName(this: &IRGen, name: &char, imp: &char) -> usize {
    let fn = newStringFromStrLit(name);
    if (!containsKey(&this.functions, &fn)) {
        C::fprintf(stderr, "%s Could not insert implicit function call! Reason: Could not find function `%s`!\n", FATAL_STR, name);
        C::fprintf(stderr, "%s: Certain features in the language require extra support from the standard library. ", NOTE_STR);
        C::fprintf(stderr,     "Normally the compiler automatically imports the required files, however it seems like it failed this time.\n");
        C::fprintf(stderr, "%s: Please import `%s` and try again.\n", NOTE_STR, imp);
        C::fprintf(stderr, "%s: Please create a bug report on https://github.com/pfhaupt/bufo/issues/new.\n", NOTE_STR);
        C::exit(2);
    }
    let funcID: usize = getFunctionByName(this, &fn);
    drop(&fn);
    return funcID;
}
func fillLookup(this: &IRGen, project: &ParsedFile) -> bool {
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let function: &ParsedFuncDecl = at(&funcDecls, i);
        if (function.ignored) continue;
        let name: String = getMangledName(function);
        if (containsKey(&this.functions, &name)) {
            let fn = get(&this.functions, &name);
            let loc = toString(&function.span);
            let loc1 = toString(&fn.span);
            C::fprintf(stderr, "%s: %s Hash collision - Function Lookup already contains function!\n", loc.buffer, FATAL_STR);
            C::fprintf(stderr, "%s: %s Function with mangled name %s already defined here!\n", loc1.buffer, FATAL_STR, name.buffer);
            drop(&loc1);
            drop(&loc);
            C::exit(2);
        }
        let irfunc: IRFunc = IRFunc {
            name: name,
            span: function.span,
            originalID: getID(function),
            comptimeLevel: 0,
            attrs: function.attrs,
        };
        add(&this.functions, name, irfunc);
    }
    return true;
}

func generateTypeInfoTable(this: &IRGen, function: &IRFunc, project: &ParsedFile) -> bool {
    comptime NAME = BUILD_A_KEYWORD("TypeInfo");
    comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
    let ti_file = getFileByFileName(FILE);
    if (ti_file == null) {
        // If we never imported the file, we can safely assume that we don't need Type Info.
        return true;
    }
    let context = findUnionByNameInFile(this.lookup, &FILE, &NAME);
    assert(context != null, "generateTypeInfoTable: Could not find union context for TypeInfo");

    let file = getParentFile(context.global);
    for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
        let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&file.mod.tlis, j));
        if (tli.ignored) continue;
        if (tli.kind == TLI_VAR_DECL) {
            generateBytecodeStmt(this, function, at(&stmts, tli.nodeID));
            // generateBytecode will iterate over this file again,
            // but we don't want to generate two statements
            tli.ignored = true;
        }
    }

    let table: TypeInfoTable = blank;
    // Fill table with unique types
    for (let i: usize = 0; i < types.length; i = i + 1) {
        let t = at(&types, i);
        match (t) {
            &Type::Unknown => {
                let u = TypeInfo::Unknown;
                if (!contains(&table, &u)) push_entry(&table, u);
            }
            &Type::Prim(prim) => {
                assert(i < PRIM_TYPE_COUNT, "nope");
                let name = toString(at(&types, i));
                push_entry(&table, TypeInfo::Primitive { name: asSubStr(&name), size_in_bytes: getSizeInBytes(t), align_in_bytes: getAlignmentInBytes(t) });
            }
            &Type::Ptr(underlying) => {
                let name = toString(at(&types, i));
                let p = TypeInfo::Pointer { name: asSubStr(&name) };
                if (!contains(&table, &p)) push_entry(&table, p);
            }
            &Type::Variadic(_) => {
                let name = toString(at(&types, i));
                let v = TypeInfo::Variadic { name: asSubStr(&name) };
                if (!contains(&table, &v)) push_entry(&table, v);
            }
            &Type::Array(elem, len) => {
                let name = toString(at(&types, i));
                let a = TypeInfo::Array { name: asSubStr(&name), size_in_bytes: getSizeInBytes(t), align_in_bytes: getAlignmentInBytes(t), elem_count: len };
                if (!contains(&table, &a)) push_entry(&table, a);
            }
            &Type::Func(args, ret, _) => {
                let name = toString(at(&types, i));
                let f = TypeInfo::Function { name: asSubStr(&name) };
                if (!contains(&table, &f)) push_entry(&table, f);
            }
            &Type::Struct(decl) => {
                let name = getFullName(decl);
                let s = TypeInfo::Struct { name: asSubStr(&name), size_in_bytes: getSizeInBytes(t), align_in_bytes: getAlignmentInBytes(t) };
                if (!contains(&table, &s)) push_entry(&table, s);
            }
            &Type::Union(decl, _) => {
                let name = getFullName(decl);
                let u = TypeInfo::Union { name: asSubStr(&name), size_in_bytes: getSizeInBytes(t), align_in_bytes: getAlignmentInBytes(t) };
                if (!contains(&table, &u)) push_entry(&table, u);
            }
            &Type::Tuple(_elems) => {
                let name = toString(at(&types, i));
                let a = TypeInfo::Tuple { name: asSubStr(&name), size_in_bytes: getSizeInBytes(t), align_in_bytes: getAlignmentInBytes(t) };
                if (!contains(&table, &a)) push_entry(&table, a);
            }
            &Type::Module(_) => { }
            _ => { unreachable("generateTypeInfoTable: Exhaustive handling of Type kinds when filling"); }
        }
    }
    // Backpatch type references
    for (let i: usize = 0; i < types.length; i = i + 1) {
        let t = at(&types, i);
        match (t) {
            &Type::Prim(prim) => { }
            &Type::Ptr(underlying) => {
                let name = asSubStr(&toString(at(&types, i)));
                let s = TypeInfo::Pointer { name: name };
                let ptr_index = index_of(&table, &s);
                assert(ptr_index != table.length);
                let ptr_info = &table.elements[ptr_index];
                assert(tag(ptr_info) == comptime tag(&TypeInfo::Pointer));
                assert(equals(&name, &get_name(ptr_info)));
                let underlying_index = index_of_type(&table, underlying);
                assert(underlying_index != table.length, "Underlying type info does not exist");
                *ptr_info = TypeInfo::Pointer { name: name, underlying: underlying_index };
            }
            &Type::Variadic(underlying) => {
                let name = asSubStr(&toString(at(&types, i)));
                let s = TypeInfo::Variadic { name: name };
                let var_index = index_of(&table, &s);
                assert(var_index != table.length);
                let var_info = &table.elements[var_index];
                assert(tag(var_info) == comptime tag(&TypeInfo::Variadic));
                assert(equals(&name, &get_name(var_info)));
                let underlying_index = index_of_type(&table, underlying);
                assert(underlying_index != table.length, "Underlying type info does not exist");
                *var_info = TypeInfo::Variadic { name: name, underlying: underlying_index };
            }
            &Type::Array(elem, len) => {
                let name = asSubStr(&toString(at(&types, i)));
                let a = TypeInfo::Array { name: name };
                let array_index = index_of(&table, &a);
                assert(array_index != table.length);
                let array_info = &table.elements[array_index];
                assert(tag(array_info) == comptime tag(&TypeInfo::Array));
                assert(equals(&name, &get_name(array_info)));
                match (array_info) {
                    &TypeInfo::Array { _, _, _, elem_index, l } => {
                        elem_index = index_of_type(&table, elem);
                        assert(len == l);
                    }
                    _ => { unreachable(); }
                }
            }
            &Type::Func(args, ret, attr) => {
                let name = asSubStr(&toString(at(&types, i)));
                let f = TypeInfo::Function { name: name };
                let function_index = index_of(&table, &f);
                assert(function_index != table.length);
                let function_info = &table.elements[function_index];
                assert(tag(function_info) == comptime tag(&TypeInfo::Function));
                assert(equals(&name, &get_name(function_info)));
                let arg_list: &TypeInfoList = null;
                let ret_index: &usize = null;
                match (function_info) {
                    &TypeInfo::Function { _, args, ret } => {
                        arg_list = &args;
                        ret_index = &ret;
                    }
                    _ => { unreachable(); }
                }
                if (arg_list.length > 0) continue;
                for (let j: usize = 0; j < args.length; j = j + 1) {
                    let index = index_of_type(&table, *at(&args, j));
                    assert(index != table.length, "Argument type info does not exist");
                    push(arg_list, index);
                }
                *ret_index = index_of_type(&table, ret);
                assert(*ret_index != table.length, "Return type info does not exist");
            }
            &Type::Struct(decl) => {
                let name = asSubStr(&getFullName(decl));
                let s = TypeInfo::Struct { name: name };
                let struct_index = index_of(&table, &s);
                assert(struct_index != table.length);
                let struct_info = &table.elements[struct_index];
                assert(tag(struct_info) == comptime tag(&TypeInfo::Struct));
                assert(equals(&name, &get_name(struct_info)));
                let struct_fields: &FieldTypeInfoList = null;
                match (struct_info) {
                    &TypeInfo::Struct { name, _, _, fields } => { struct_fields = &fields; }
                    _ => { unreachable(); }
                }
                if (struct_fields.length > 0) continue;
                for (let j: usize = 0; j < decl.context.fieldLength; j = j + 1) {
                    let name = getFieldNameAtIndex(&decl.context, j);
                    let type_decl = getFieldTypeAtIndex(&decl.context, j);
                    let type = getType(&type_decl.typeState);
                    let index = index_of_type(&table, type);
                    assert(index != table.length, "Struct field type info does not exist");
                    push(struct_fields, FieldTypeInfo {
                        name: name.content,
                        type: index,
                        offset_in_bytes: getFieldOffset(decl, &name.content, false),
                    });
                }
            }
            &Type::Union(decl, _) => {
                let name = asSubStr(&getFullName(decl));
                let u = TypeInfo::Union { name: name };
                let union_index = index_of(&table, &u);
                assert(union_index != table.length);
                let union_info = &table.elements[union_index];
                assert(tag(union_info) == comptime tag(&TypeInfo::Union));
                assert(equals(&name, &get_name(union_info)));
                let variant_list: &UnionVariantTypeInfoList = null;
                match (union_info) {
                    &TypeInfo::Union { name, _, _, variants } => { variant_list = &variants; }
                    _ => { unreachable(); }
                }
                if (variant_list.length > 0) continue;
                for (let j: usize = 0; j < decl.variants.length; j = j + 1) {
                    let variant = decl.variants.elements[j];
                    let variant_info = UnionVariantTypeInfo::Empty{};
                    if (variant.kind == UNION_VARIANT_EMPTY) {
                        variant_info = UnionVariantTypeInfo::Empty { name: variant.name.content };
                    } else if (variant.kind == UNION_VARIANT_TUPLE) {
                        let tuple_fields: TypeInfoList = blank;
                        for (let k: usize = 0; k < variant.fields.length; k = k + 1) {
                            let type_decl = variant.fields.elements[k];
                            let type = getType(&type_decl.typeState);
                            let index = index_of_type(&table, type);
                            assert(index != table.length, "Union variant field type info does not exist");
                            push(&tuple_fields, index);
                        }
                        variant_info = UnionVariantTypeInfo::Tuple {
                            name: variant.name.content,
                            fields: tuple_fields,
                        };
                    } else if (variant.kind == UNION_VARIANT_STRUCT) {
                        let struct_fields: FieldTypeInfoList = blank;
                        assert(variant.fields.length == variant.names.length);
                        for (let k: usize = 0; k < variant.fields.length; k = k + 1) {
                            let name = variant.names.elements[k];
                            let type_decl = variant.fields.elements[k];
                            let type = getType(&type_decl.typeState);
                            let index = index_of_type(&table, type);
                            assert(index != table.length, "Union variant field type info does not exist");
                            let _size: usize = 0;
                            let offset: usize = 0;
                            getFieldOffsetAndSize(variant, k, &offset, &_size, false);
                            push(&struct_fields, FieldTypeInfo {
                                name: name.content,
                                type: index,
                                offset_in_bytes: offset,
                            });
                        }
                        variant_info = UnionVariantTypeInfo::Struct {
                            name: variant.name.content,
                            fields: struct_fields,
                        };
                    } else {
                        unreachable();
                    }
                    push(variant_list, variant_info);
                }
            }
            &Type::Module(_) => { }
            &Type::Unknown => { }
            &Type::Tuple(elems) => {
                let name = asSubStr(&toString(at(&types, i)));
                let a = TypeInfo::Tuple { name: name };
                let tuple_index = index_of(&table, &a);
                assert(tuple_index != table.length);
                let tuple_info = &table.elements[tuple_index];
                assert(tag(tuple_info) == comptime tag(&TypeInfo::Tuple));
                assert(equals(&name, &get_name(tuple_info)));
                let elem_list: &TypeInfoList = null;
                match (tuple_info) {
                    &TypeInfo::Tuple { _, _, _, elems } => {
                        elem_list = &elems;
                    }
                    _ => { unreachable(); }
                }
                if (elem_list.length > 0) continue;
                for (let j: usize = 0; j < elems.length; j = j + 1) {
                    let index = index_of_type(&table, elems.elements[j]);
                    assert(index != table.length, "Argument type info does not exist");
                    push(elem_list, index);
                }
            }
            _ => { unreachable("generateTypeInfoTable: Exhaustive handling of Type kinds when patching"); }
        }
    }
    // Remove every type info that's isolated, i.e. not referred to by any other type
    // Structs and Unions are always included (aka the "root" of the type info tree),
    // but because the type checker often also generates intermediate, incomplete types
    // especially in the context of functions, the table contains info for types that
    // can literally never be accessed anywhere at runtime, no matter how hard the user tries.
    // So it's safe to remove them, which should reduce the final table size quite a bit.
    // Algorithm:
    //   while table.size changes:
    //     table:  [0 1 2 3 4 5]
    //     usage:
    //       1 is a struct
    //       0 -> 3
    //       1 -> 0
    //     count:  [1 1 0 1 0 0]
    //     remove: [2 4 5]
    //     actual: [0 1 3]
    //     for every usage:
    //       decrement index by how many indices smaller than it were removed
    //       i.e. 0 -> 3: one index below 3 got removed (2) => 0 -> 2
    // Fixpoint algorithm
    //   Does it always terminate?
    //     break if size unchanged
    //     two cases:
    //       we didn't remove an item -> size unchanged, halt
    //       we removed an item -> finite size got smaller, finite steps until halts
    //                             because once we have no items, we can no longer
    //                             remove them, 0 is lower bound
    let length = table.length;
    while (true) {
        let count: UsizeList = blank;
        initBlank(&count, table.length);
        for (let i: usize = 0; i < table.length; i = i + 1) {
            match (&table.elements[i]) {
                &TypeInfo::Array { _, _, _, elem, _ } => { count.elements[elem] = count.elements[elem] + 1; }
                &TypeInfo::Pointer { _, under } => { count.elements[under] = count.elements[under] + 1; }
                &TypeInfo::Variadic { _, under } => { count.elements[under] = count.elements[under] + 1; }
                &TypeInfo::Function { _, args, ret } => {
                    let is_unknown = func (table: &TypeInfoTable, index: usize) -> bool {
                        // TODO: Make let a pattern
                        match (table.elements[index]) {
                            TypeInfo::Unknown => { return true; }
                            _ => { }
                        }
                        return false;
                    };
                    // The compiler needs incomplete function types to infer proper call candidates
                    // We don't want those types at runtime.
                    let needed = true;
                    for (let j: usize = 0; j < args.length; j = j + 1) {
                        if (is_unknown(&table, args.elements[j])) {
                            needed = false;
                        }
                    }
                    needed = needed && !is_unknown(&table, ret);
                    if (needed) count.elements[i] = count.elements[i] + 1;
                    for (let j: usize = 0; j < args.length; j = j + 1) {
                        let elem = args.elements[j];
                        count.elements[elem] = count.elements[elem] + 1;
                    }
                    count.elements[ret] = count.elements[ret] + 1;
                }
                &TypeInfo::Struct { _, _, _, fields } => {
                    count.elements[i] = count.elements[i] + 1;
                    for (let j: usize = 0; j < fields.length; j = j + 1) {
                        let elem = fields.elements[j].type;
                        count.elements[elem] = count.elements[elem] + 1;
                    }
                }
                &TypeInfo::Union { _, _, _, variants } => {
                    count.elements[i] = count.elements[i] + 1;
                    for (let j: usize = 0; j < variants.length; j = j + 1) {
                        let var = &variants.elements[j];
                        match (var) {
                            &UnionVariantTypeInfo::Empty { .. } => { },
                            &UnionVariantTypeInfo::Tuple { _, fields } => {
                                for (let k: usize = 0; k < fields.length; k = k + 1) {
                                    let elem = fields.elements[k];
                                    count.elements[elem] = count.elements[elem] + 1;
                                }
                            }
                            &UnionVariantTypeInfo::Struct { _, fields } => {
                                for (let k: usize = 0; k < fields.length; k = k + 1) {
                                    let elem = fields.elements[k].type;
                                    count.elements[elem] = count.elements[elem] + 1;
                                }
                            }
                            _ => { unreachable(); }
                        }
                    }
                }
                &TypeInfo::Primitive { .. } => {
                    count.elements[i] = count.elements[i] + 1;
                }
                &TypeInfo::Tuple { _, _, _, elements } => {
                    count.elements[i] = count.elements[i] + 1;
                    for (let j: usize = 0; j < elements.length; j = j + 1) {
                        let elem = elements.elements[j];
                        count.elements[elem] = count.elements[elem] + 1;
                    }
                }
                &TypeInfo::Unknown => { }
                _ => { unreachable("generateTypeInfoTable: Exhaustive handling of Type kinds when counting"); }
            }
        }
        let remove: UsizeList = blank;
        let new_table: TypeInfoTable = blank;
        for (let i: usize = 0; i < count.length; i = i + 1) {
            if (count.elements[i] != 0) {
                push_entry(&new_table, table.elements[i]);
            } else {
                push(&remove, i);
            }
        }
        let count_offset = func (removed: &UsizeList, index: usize) -> usize {
            let offset: usize = 0;
            // OPT: Binary search, the list is sorted
            for (let i: usize = 0; i < removed.length; i = i + 1) {
                let removed_index = removed.elements[i];
                if (removed_index > index) break;
                offset = offset + 1;
            }
            return offset;
        };
        for (let i: usize = 0; i < new_table.length; i = i + 1) {
            match (&new_table.elements[i]) {
                &TypeInfo::Array { _, _, _, elem, _ } => { elem = elem - count_offset(&remove, elem); }
                &TypeInfo::Pointer { _, under } => { under = under - count_offset(&remove, under); }
                &TypeInfo::Variadic { _, under } => { under = under - count_offset(&remove, under); }
                &TypeInfo::Function { _, args, ret } => {
                    for (let j: usize = 0; j < args.length; j = j + 1) {
                        args.elements[j] = args.elements[j] - count_offset(&remove, args.elements[j]);
                    }
                    ret = ret - count_offset(&remove, ret);
                }
                &TypeInfo::Struct { _, _, _, fields } => {
                    for (let j: usize = 0; j < fields.length; j = j + 1) {
                        fields.elements[j].type = fields.elements[j].type - count_offset(&remove, fields.elements[j].type);
                    }
                }
                &TypeInfo::Union { _, _, _, variants } => {
                    for (let j: usize = 0; j < variants.length; j = j + 1) {
                        let var = &variants.elements[j];
                        match (var) {
                            &UnionVariantTypeInfo::Empty { .. } => { },
                            &UnionVariantTypeInfo::Tuple { _, fields } => {
                                for (let k: usize = 0; k < fields.length; k = k + 1) {
                                    fields.elements[k] = fields.elements[k] - count_offset(&remove, fields.elements[k]);
                                }
                            }
                            &UnionVariantTypeInfo::Struct { _, fields } => {
                                for (let k: usize = 0; k < fields.length; k = k + 1) {
                                    fields.elements[k].type = fields.elements[k].type - count_offset(&remove, fields.elements[k].type);
                                }
                            }
                            _ => { unreachable(); }
                        }
                    }
                }
                &TypeInfo::Primitive { .. } => { }
                &TypeInfo::Unknown => { }
                &TypeInfo::Tuple { _, _, _, elements } => {
                    for (let j: usize = 0; j < elements.length; j = j + 1) {
                        elements.elements[j] = elements.elements[j] - count_offset(&remove, elements.elements[j]);
                    }
                }
                _ => { unreachable("generateTypeInfoTable: Exhaustive handling of Type kinds when removing"); }
            }
        }
        table = new_table;
        if (table.length == length) break;
        length = table.length;
    }
    let t: &Type = intoArrayType(context.type, table.length);
    assert(getSizeInBytes(t) == sizeof TypeInfo * table.length, "Size mismatch");
    let reg: RegIndex = allocateRegister(function, t);
    buildCreateArray(function, context.global.span, reg);
    let global_table = allocateRegister(function, intoPointer(t));
    buildAlloca(function, context.global.span, global_table, getSizeInBytes(t));
    buildStore(function, context.global.span, global_table, reg);

    let isGlobal = false;
    let global_type_info_table = getIdentifierByName(this, function, comptime newSubStrOfStrLit("type_info_table"), &isGlobal);
    assert(global_type_info_table != null, "Could not find global type info table variable");
    buildStore(function, context.global.span, global_type_info_table.ptr, global_table);
    this.type_info_table = table;
    this.type_info_array_register = global_table;
    return true;
}

func generateRuntimeTypeInfo(this: &IRGen) -> bool {
    comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
    comptime TI = BUILD_A_KEYWORD("TypeInfo");
    comptime FTI = BUILD_A_KEYWORD("FieldTypeInfo");
    comptime UVTI = BUILD_A_KEYWORD("UnionVariantTypeInfo");
    let context = findUnionByNameInFile(this.lookup, &FILE, &TI);
    assert(context != null, "generateRuntimeInitialization: Could not find union context for TypeInfo");
    let _fieldTypeInfo = findStructByNameInFile(this.lookup, &FILE, &FTI);
    assert(_fieldTypeInfo != null, "generateRuntimeInitialization: Could not find context for FieldTypeInfo");
    let _unionVariantTypeInfo = findUnionByNameInFile(this.lookup, &FILE, &UVTI);
    assert(_unionVariantTypeInfo != null, "generateRuntimeInitialization: Could not find context for UnionVariantTypeInfo");

    let fieldTypeInfo = _fieldTypeInfo.type;
    let unionVariantTypeInfo = _unionVariantTypeInfo.type;

    let span = context.global.span;

    let function = &this.initRuntime;

    let typeInfoPtr: &Type = intoPointer(context.type);
    let u8Type: &Type = wrap(Type::Prim(PrimType::U8));
    let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
    let charPtrType = wrap(Type::Ptr(wrap(Type::Prim(PrimType::Char))));
    let fieldTypeInfoPtr = wrap(Type::Ptr(fieldTypeInfo));

    let global_table = allocateRegister(function, typeInfoPtr);
    buildFetchGlobalPointer(function, span, global_table, this.type_info_array_register);

    let elemPtr = allocateRegister(function, typeInfoPtr);
    let tagReg = allocateRegister(function, u8Type);
    let index = allocateRegister(function, usizeType);
    let indices: RegIndexList = blank;
    push(&indices, index);
    let reg = allocateRegister(function, charPtrType);
    let tmp = allocateRegister(function, usizeType);
    let ftiReg = allocateRegister(function, fieldTypeInfo);
    let fieldPtr = allocateRegister(function, intoPointer(fieldTypeInfo));
    let variantPtr = allocateRegister(function, intoPointer(unionVariantTypeInfo));

    let field_index = allocateRegister(function, usizeType);
    let field_indices: RegIndexList = blank;
    push(&field_indices, field_index);

    let variant_index = allocateRegister(function, usizeType);
    let variant_indices: RegIndexList = blank;
    push(&variant_indices, variant_index);

    let write_at_offset = func (function: &IRFunc, span: Span, ptr: RegIndex, tmp: RegIndex, byte_offset: usize, val: RegIndex) {
        let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
        buildLoadInteger(function, span, tmp, usizeType, byte_offset);
        buildPtrToInt(function, span, ptr, ptr);
        buildBinaryOp(function, span, INSTR_INT_ADD, tmp, tmp, ptr);
        buildIntToPtr(function, span, tmp, tmp);
        buildStore(function, span, tmp, val);
    };

    let alloc_list = func (this: &IRGen, function: &IRFunc, span: Span, ti: &Type, len: usize) -> RegIndex {
        let typ = wrap(Type::Array(ti, len));
        let arrTypPtr = intoPointer(typ);
        let pt = intoPointer(ti);
        let local = allocateRegister(function, pt);
        let s = getSizeInBytes(ti);

        let arrAlloc = allocateRegister(&this.globalScope, arrTypPtr);
        buildAlloca(&this.globalScope, span, arrAlloc, s * len);
        let arrReg = allocateRegister(&this.globalScope, typ);
        buildLoadBlank(&this.globalScope, span, arrReg, s * len);
        buildStore(&this.globalScope, span, arrAlloc, arrReg);

        buildFetchGlobalPointer(function, span, local, arrAlloc);
        arrReg = allocateRegister(function, typ);
        buildLoadBlank(function, span, arrReg, s * len);
        buildStore(function, span, local, arrReg);
        return local;
    };

    for (let i: usize = 0; i < this.type_info_table.length; i = i + 1) {
        buildLoadInteger(function, span, index, usizeType, i);
        buildGetElementPtr(function, span, elemPtr, global_table, indices);

        let info = &this.type_info_table.elements[i];
        buildLoadInteger(function, span, tagReg, u8Type, tag(info) as usize);
        write_at_offset(function, span, elemPtr, tmp, 0, tagReg);

        // TODO: The big TODO in generateBytecodeExprUnionInit will also destroy this initialization
        let name = get_name(info);
        buildLoadString(function, span, reg, name);
        write_at_offset(function, span, elemPtr, tmp, 1, reg);
        buildLoadInteger(function, span, index, usizeType, name.len);
        write_at_offset(function, span, elemPtr, tmp, 9, index);

        // TODO: TypeInfo contains the same lists in various variants, we could
        //       create common wrapper functions to emit the correct IR, which would
        //       reduce the surface area for bugs in case we extend the TypeInfo definition.
        match (info) {
            &TypeInfo::Array { _, size_in_bytes, align_in_bytes, elem, elem_count } => {
                buildLoadInteger(function, span, index, usizeType, size_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 17, index);
                buildLoadInteger(function, span, index, usizeType, align_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 25, index);
                buildLoadInteger(function, span, index, usizeType, elem);
                write_at_offset(function, span, elemPtr, tmp, 33, index);
                buildLoadInteger(function, span, index, usizeType, elem_count);
                write_at_offset(function, span, elemPtr, tmp, 41, index);
            }
            &TypeInfo::Pointer { _, underlying } => {
                buildLoadInteger(function, span, index, usizeType, underlying);
                write_at_offset(function, span, elemPtr, tmp, 17, index);
            }
            &TypeInfo::Variadic { _, underlying } => {
                buildLoadInteger(function, span, index, usizeType, underlying);
                write_at_offset(function, span, elemPtr, tmp, 17, index);
            }
            &TypeInfo::Function { _, args, ret } => {
                let local_args = alloc_list(this, function, span, usizeType, args.length);
                for (let j: usize = 0; j < args.length; j = j + 1) {
                    buildLoadInteger(function, span, field_index, usizeType, j);
                    buildGetElementPtr(function, span, fieldPtr, local_args, field_indices);

                    buildLoadInteger(function, span, index, usizeType, args.elements[j]);
                    write_at_offset(function, span, fieldPtr, tmp, 0, index);
                }
                write_at_offset(function, span, elemPtr, tmp, 17, local_args);
                buildLoadInteger(function, span, field_index, usizeType, args.length);
                write_at_offset(function, span, elemPtr, tmp, 25, field_index);
                write_at_offset(function, span, elemPtr, tmp, 33, field_index);

                buildLoadInteger(function, span, field_index, usizeType, ret);
                write_at_offset(function, span, elemPtr, tmp, 41, field_index);
            }
            &TypeInfo::Struct { _, size_in_bytes, align_in_bytes, fields } => {
                let local_fields = alloc_list(this, function, span, fieldTypeInfo, fields.length);

                for (let j: usize = 0; j < fields.length; j = j + 1) {
                    buildLoadInteger(function, span, field_index, usizeType, j);
                    buildGetElementPtr(function, span, fieldPtr, local_fields, field_indices);
                    let fieldName = fields.elements[j].name;

                    buildLoadString(function, span, reg, fieldName);
                    write_at_offset(function, span, fieldPtr, tmp, 0, reg);
                    buildLoadInteger(function, span, index, usizeType, fieldName.len);
                    write_at_offset(function, span, fieldPtr, tmp, 8, index);
                    buildLoadInteger(function, span, index, usizeType, fields.elements[j].type);
                    write_at_offset(function, span, fieldPtr, tmp, 16, index);
                    buildLoadInteger(function, span, index, usizeType, fields.elements[j].offset_in_bytes);
                    write_at_offset(function, span, fieldPtr, tmp, 24, index);
                }

                buildLoadInteger(function, span, field_index, usizeType, size_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 17, field_index);
                buildLoadInteger(function, span, field_index, usizeType, align_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 25, field_index);
                write_at_offset(function, span, elemPtr, tmp, 33, local_fields);
                buildLoadInteger(function, span, field_index, usizeType, fields.length);
                write_at_offset(function, span, elemPtr, tmp, 41, field_index);
                write_at_offset(function, span, elemPtr, tmp, 49, field_index);
            }
            &TypeInfo::Union { _, size_in_bytes, align_in_bytes, variants } => {
                let local_variants = alloc_list(this, function, span, unionVariantTypeInfo, variants.length);
                for (let j: usize = 0; j < variants.length; j = j + 1) {
                    let var = &variants.elements[j];
                    buildLoadInteger(function, span, variant_index, usizeType, j);
                    buildGetElementPtr(function, span, variantPtr, local_variants, variant_indices);

                    buildLoadInteger(function, span, tagReg, u8Type, tag(var) as usize);
                    write_at_offset(function, span, variantPtr, tmp, 0, tagReg);

                    let variantName = get_name(var);
                    buildLoadString(function, span, reg, variantName);
                    write_at_offset(function, span, variantPtr, tmp, 1, reg);
                    buildLoadInteger(function, span, index, usizeType, variantName.len);
                    write_at_offset(function, span, variantPtr, tmp, 9, index);

                    match (var) {
                        &UnionVariantTypeInfo::Empty { .. } => { },
                        &UnionVariantTypeInfo::Tuple { _, fields } => {
                            let local_fields = alloc_list(this, function, span, usizeType, fields.length);

                            for (let k: usize = 0; k < fields.length; k = k + 1) {
                                buildLoadInteger(function, span, field_index, usizeType, k);
                                buildGetElementPtr(function, span, fieldPtr, local_fields, field_indices);

                                buildLoadInteger(function, span, index, usizeType, fields.elements[k]);
                                write_at_offset(function, span, fieldPtr, tmp, 0, index);
                            }

                            write_at_offset(function, span, variantPtr, tmp, 17, local_fields);
                            buildLoadInteger(function, span, variant_index, usizeType, fields.length);
                            write_at_offset(function, span, variantPtr, tmp, 25, variant_index);
                            write_at_offset(function, span, variantPtr, tmp, 33, variant_index);
                        }
                        &UnionVariantTypeInfo::Struct { _, fields } => {
                            let local_fields = alloc_list(this, function, span, fieldTypeInfo, fields.length);

                            for (let k: usize = 0; k < fields.length; k = k + 1) {
                                buildLoadInteger(function, span, field_index, usizeType, k);
                                buildGetElementPtr(function, span, fieldPtr, local_fields, field_indices);
                                let fieldName = fields.elements[k].name;

                                buildLoadString(function, span, reg, fieldName);
                                write_at_offset(function, span, fieldPtr, tmp, 0, reg);
                                buildLoadInteger(function, span, index, usizeType, fieldName.len);
                                write_at_offset(function, span, fieldPtr, tmp, 8, index);
                                buildLoadInteger(function, span, index, usizeType, fields.elements[k].type);
                                write_at_offset(function, span, fieldPtr, tmp, 16, index);
                                buildLoadInteger(function, span, index, usizeType, fields.elements[k].offset_in_bytes);
                                write_at_offset(function, span, fieldPtr, tmp, 24, index);
                            }

                            write_at_offset(function, span, variantPtr, tmp, 17, local_fields);
                            buildLoadInteger(function, span, variant_index, usizeType, fields.length);
                            write_at_offset(function, span, variantPtr, tmp, 25, variant_index);
                            write_at_offset(function, span, variantPtr, tmp, 33, variant_index);
                        }
                        _ => { unreachable(); }
                    }
                }
                buildLoadInteger(function, span, variant_index, usizeType, size_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 17, variant_index);
                buildLoadInteger(function, span, variant_index, usizeType, align_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 25, variant_index);

                write_at_offset(function, span, elemPtr, tmp, 33, local_variants);
                buildLoadInteger(function, span, variant_index, usizeType, variants.length);
                write_at_offset(function, span, elemPtr, tmp, 41, variant_index);
                write_at_offset(function, span, elemPtr, tmp, 49, variant_index);
            }
            &TypeInfo::Primitive { _, size_in_bytes, align_in_bytes } => {
                buildLoadInteger(function, span, index, usizeType, size_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 17, index);
                buildLoadInteger(function, span, index, usizeType, align_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 25, index);
            }
            &TypeInfo::Tuple { _, size_in_bytes, align_in_bytes, elements } => {
                let local_elements = alloc_list(this, function, span, usizeType, elements.length);
                for (let j: usize = 0; j < elements.length; j = j + 1) {
                    buildLoadInteger(function, span, field_index, usizeType, j);
                    buildGetElementPtr(function, span, fieldPtr, local_elements, field_indices);

                    buildLoadInteger(function, span, index, usizeType, elements.elements[j]);
                    write_at_offset(function, span, fieldPtr, tmp, 0, index);
                }

                buildLoadInteger(function, span, index, usizeType, size_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 17, index);
                buildLoadInteger(function, span, index, usizeType, align_in_bytes);
                write_at_offset(function, span, elemPtr, tmp, 25, index);

                write_at_offset(function, span, elemPtr, tmp, 33, local_elements);
                buildLoadInteger(function, span, field_index, usizeType, elements.length);
                write_at_offset(function, span, elemPtr, tmp, 41, field_index);
                write_at_offset(function, span, elemPtr, tmp, 49, field_index);
            }
            &TypeInfo::Unknown => { }
            _ => { unreachable("generateRuntimeTypeInfo: Exhaustive handling of Type kinds"); }
        }
    }
    return true;
}

func generateRuntimeInitialization(this: &IRGen, project: &ParsedFile) -> bool {
    this.initRuntime = IRFunc {
        name: comptime newReadonlyString(".init_runtime"),
    };
    let scope: usize = enterScope(&this.initRuntime);
    let entry: IRBlockID = appendBlock(&this.initRuntime);
    setCurrentBlock(&this.initRuntime, entry);

    comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
    let ti_file = getFileByFileName(FILE);
    if (ti_file != null) {
        if (!generateRuntimeTypeInfo(this)) return false;
    }

    buildReturnEmpty(&this.initRuntime, project.mod.span);
    return true;
}

func generateBytecode(this: &IRGen, project: &ParsedFile) -> bool {
    if (!fillLookup(this, project))
        return false;
    let scope: usize = enterScope(&this.globalScope);
    assert(this.globalScope.scopes.length == 1, "Expected only one valid scope");
    let entry: IRBlockID = appendBlock(&this.globalScope);
    setCurrentBlock(&this.globalScope, entry);
    if (!generateTypeInfoTable(this, &this.globalScope, project))
        return false;
    if (!generateRuntimeInitialization(this, project))
        return false;
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&file.mod.tlis, j));
            if (tli.ignored) continue;
            if (tli.kind == TLI_VAR_DECL) {
                generateBytecodeStmt(this, &this.globalScope, at(&stmts, tli.nodeID));
            }
        }
    }
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let fn: &ParsedFuncDecl = at(&funcDecls, i);
        generateFunction(this, fn);
    }
    if (*flags.emitBIR) {
        // TODO: Emit to file
        dumpInstructions(&this.globalScope);
        dumpInstructions(&this.initRuntime);
        let fns = asList(&this.functions);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            dumpInstructions(at(&fns, i));
        }
        drop(&fns);
    }
    return !this.error;
}

func generateFunctionHeader(this: &IRGen, function: &IRFunc, retType: &Type, params: &ParamContext) {
    let entry: IRBlockID = appendBlock(function);
    setCurrentBlock(function, entry);
    if (hasAttribute(at(&funcDecls, function.originalID), ATTR_NAKED)) return;
    let offset: usize = 0;
    if (getSizeInBytes(retType) > 8) {
        offset = 1;
        prepareParameter(this, function, 0, blank, newSubStrOfStrLit("ret"), intoPointer(retType), true);
    }
    for (let i: usize = 0; i < params.paramLength; i = i + 1) {
        let name: Token = getNameAtIndex(params, i);
        let typDecl: &ParsedTypeNode = getTypeAtIndex(params, i);
        let pType: &Type = getType(&typDecl.typeState);
        prepareParameter(this, function, i + offset, name.span, name.content, pType, false);
    }
}

func generateFunctionBody(this: &IRGen, function: &IRFunc, body: &ParsedBlock, retTypeNode: &ParsedTypeNode) {
    let retType: &Type = getType(&retTypeNode.typeState);
    let isNakedFn = hasAttribute(at(&funcDecls, function.originalID), ATTR_NAKED);
    if (function.returnBlockID.i == 0) {
        let curr = getCurrentBlock(function);
        function.returnBlockID = appendBlock(function);
        if (isNone(retType)) {
            setCurrentBlock(function, function.returnBlockID);
            buildReturnEmpty(function, retTypeNode.span);
            setCurrentBlock(function, curr);
        } else if (isNakedFn) {
            assert(getSizeInBytes(retType) <= 8, "Naked functions can only return types that fit into a register");
            let reg = allocateRegister(function, retType);
            setCurrentBlock(function, function.returnBlockID);
            buildLoadBlank(function, retTypeNode.span, reg, getSizeInBytes(retType));
            buildReturnExpr(function, retTypeNode.span, reg);
            setCurrentBlock(function, curr);
        } else {
            function.returnAlloc = allocateRegister(function, intoPointer(retType));
            buildAlloca(function, retTypeNode.span, function.returnAlloc, getSizeInBytes(retType));
            setCurrentBlock(function, function.returnBlockID);
            let result = allocateRegister(function, retType);
            buildLoad(function, retTypeNode.span, result, function.returnAlloc);
            if (getSizeInBytes(retType) > 8) {
                buildStore(function, retTypeNode.span, function.retPtr, result);
                buildReturnExpr(function, retTypeNode.span, function.retPtr);
            } else {
                if (isComposite(retType)) {
                    let v: RegIndex = getRegisterForSize(this, function, getSizeInBytes(retType));
                    let t: &Type = getRegister(function, v).typ;
                    let r: RegIndex = allocateRegister(function, intoPointer(t));
                    let s: usize = getSizeInBytes(t);
                    assert(s <= 8);
                    buildAlloca(function, retTypeNode.span, r, s);
                    buildStore(function, retTypeNode.span, r, result);
                    buildLoad(function, retTypeNode.span, v, r);
                    buildReturnExpr(function, retTypeNode.span, v);
                } else {
                    buildReturnExpr(function, retTypeNode.span, result);
                }
            }
            setCurrentBlock(function, curr);
        }
    }
    if (*flags.trace) {
        let fn = getFuncNode(function);
        let isEnter = equals(&fn.name.content, &newSubStrOfStrLit("traceEnter"));
        let isLeave = equals(&fn.name.content, &newSubStrOfStrLit("traceLeave"));
        let init = func (function: &IRFunc, fn: &ParsedFuncDecl) -> RegIndexList {
            let args = RegIndexList { };
            // Function name
            let reg = allocateRegister(function, wrap(Type::Ptr(wrap(Type::Prim(PrimType::Char)))));
            let name = toString(&fn.name.content);
            buildLoadString(function, function.span, reg, asSubStr(&name));
            push(&args, reg);
            return args;
        };
        if (!isEnter && !isLeave) {
            let funcID: usize = 0;
            let args: RegIndexList = blank;
            // traceEnter
            funcID = getFunctionByMangledName(this, "traceEnterPcrN", "trace.bufo");
            args = init(function, fn);
            generateImplicitCall(this, function, function.span, funcID, wrap(Type::Prim(PrimType::None)), args);
            // function body
            generateBytecodeBlock(this, function, body);
            // traceLeave
            funcID = getFunctionByMangledName(this, "traceLeavePcrN", "trace.bufo");
            let curr = getCurrentBlock(function);
            setCurrentBlock(function, function.returnBlockID);
            let block = getCurrentBlockAsRef(function);
            if (isTerminated(block)) {
                let term = *pop(&block.instructions);
                args = init(function, fn);
                generateImplicitCall(this, function, function.span, funcID, wrap(Type::Prim(PrimType::None)), args);
                push(&block.instructions, term);
            } else {
                args = init(function, fn);
                generateImplicitCall(this, function, function.span, funcID, wrap(Type::Prim(PrimType::None)), args);
            }
            setCurrentBlock(function, curr);
        } else {
            generateBytecodeBlock(this, function, body);
        }
    } else {
        generateBytecodeBlock(this, function, body);
    }
    let curr: &IRBlock = getCurrentBlockAsRef(function);
    if (!isTerminated(curr)) {
        if (isNone(retType) || isNakedFn) {
            buildBr(function, body.span, function.returnBlockID);
        } else {
            buildUnterminated(function, body.span);
        }
    }
    let after: usize = leaveScope(function);
    assert(after == 1, "Scope imbalance detected");
}

func generateFunction(this: &IRGen, funcDecl: &ParsedFuncDecl) {
    if (funcDecl.ignored) return;
    assert(isSuccess(&funcDecl.typeState), "Expected valid FuncDecl type in IRGen");
    let name: String = getMangledName(funcDecl);
    let function: &IRFunc = get(&this.functions, &name);
    assert(function != null, "Expected to find function in lookup");
    assert(equals(&function.name, &name), "functions.get() retrieved wrong IRFunc");
    drop(&name);
    if (isExtern(funcDecl)) {
        return;
    }
    let scope: usize = enterScope(function);
    assert(scope == 1, "Expected function to enter first scope");
    let retDecl: &ParsedTypeNode = funcDecl.retType;
    generateFunctionHeader(this, function, getType(&retDecl.typeState), &funcDecl.params);
    generateFunctionBody(this, function, funcDecl.body, funcDecl.retType);
}

func generateBytecodeBlock(this: &IRGen, function: &IRFunc, block: &ParsedBlock) {
    if (block.ignored) return;
    assert(isSuccess(&block.typeState), "Expected valid Block type in IRGen");
    let scope: usize = enterScope(function);
    let f: &ParsedFuncDecl = getFuncNode(function);
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmt: &ParsedStmt = getStmtAtIndex(block, i);
        generateBytecodeStmt(this, function, stmt);
        let curr: &IRBlock = getCurrentBlockAsRef(function);
        if (isTerminated(curr)) {
            if (i != block.stmtLength - 1) {
                let loc: String = toString(&getStmtAtIndex(block, i + 1).span);
                C::fprintf(stderr, "%s: %s: Unreachable code.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            break;
        }
    }
    let after: usize = leaveScope(function);
    assert(scope == after, "Scope imbalance detected");
}

func generateBytecodeStmt(this: &IRGen, function: &IRFunc, stmt: &ParsedStmt) {
    match (&stmt.data) {
        &StmtData::VarDecl(decl) => {
            let expr: &ParsedExpr = decl.expr;
            if (decl.isComptime) startComptime(function);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let patReg = generateBytecodePattern(this, function, result, decl.pat, false /* don't care */, decl.isComptime);
            if (decl.trampoline != null) {
                let trampoline = appendBlock(function);
                let after = appendBlock(function);
                buildCondBr(function, decl.trampoline.span, patReg, after, trampoline);

                setCurrentBlock(function, trampoline);
                generateBytecodeBlock(this, function, decl.trampoline);
                let curr = getCurrentBlockAsRef(function);
                if (!isTerminated(curr)) {
                    let loc = toString(&decl.trampoline.span);
                    C::fprintf(stderr, "%s: %s: Trampolines must always terminate.\n", loc.buffer, ERR_STR);
                    drop(&loc);
                    this.error = true;
                }

                setCurrentBlock(function, after);
            }
            if (decl.isComptime) endComptime(function);
        }
        &StmtData::ReturnEmpty => {
            buildBr(function, stmt.span, function.returnBlockID);
        }
        &StmtData::ReturnExpr(expr) => {
            let typ: &Type = getType(&expr.typeState);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            buildStore(function, stmt.span, function.returnAlloc, result);
            buildBr(function, stmt.span, function.returnBlockID);
        }
        &StmtData::Expr(expr) => { generateBytecodeExpr(this, function, expr, false); }
        &StmtData::Block(block) => { generateBytecodeBlock(this, function, block); }
        &StmtData::If(cond, then) => {
            let condReg = generateBytecodeExpr(this, function, cond, false);
            let thenBlock = appendBlock(function);
            let contBlock = appendBlock(function);
            buildCondBr(function, stmt.span, condReg, thenBlock, contBlock);

            setCurrentBlock(function, thenBlock);
            generateBytecodeStmt(this, function, then);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, contBlock);
            }
            setCurrentBlock(function, contBlock);
        }
        &StmtData::IfElse(cond, then, elze) => {
            let condReg = generateBytecodeExpr(this, function, cond, false);
            let thenBlockID = appendBlock(function);
            let elzeBlockID = appendBlock(function);
            buildCondBr(function, stmt.span, condReg, thenBlockID, elzeBlockID);

            setCurrentBlock(function, thenBlockID);
            generateBytecodeStmt(this, function, then);
            thenBlockID = getCurrentBlock(function);

            setCurrentBlock(function, elzeBlockID);
            generateBytecodeStmt(this, function, elze);
            elzeBlockID = getCurrentBlock(function);

            let thenBlock: &IRBlock = getBlockByID(function, thenBlockID);
            let elzeBlock: &IRBlock = getBlockByID(function, elzeBlockID);
            let thenTerm: bool = isTerminated(thenBlock);
            let elseTerm: bool = isTerminated(elzeBlock);
            if (thenTerm && elseTerm) {
                // nothing to do here
            } else if (thenTerm && !elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, elzeBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else if (!thenTerm && elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, thenBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, thenBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, elzeBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            }
        }
        &StmtData::While(cond, body) => {
            let condBlock: IRBlockID = appendBlock(function);
            let bodyBlock: IRBlockID = appendBlock(function);
            let afterBlock: IRBlockID = appendBlock(function);
            pushLoopBlocks(function, condBlock, afterBlock);
            buildBr(function, stmt.span, condBlock);

            setCurrentBlock(function, condBlock);
            let condReg: RegIndex = generateBytecodeExpr(this, function, cond, false);
            buildCondBr(function, stmt.span, condReg, bodyBlock, afterBlock);

            setCurrentBlock(function, bodyBlock);
            generateBytecodeStmt(this, function, body);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, condBlock);
            }

            setCurrentBlock(function, afterBlock);
            popLoopBlocks(function);
        }
        &StmtData::IfLet(pat, expr, block) => {
            let scope: usize = enterScope(function);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let patReg = generateBytecodePattern(this, function, result, pat, false /* don't care */);

            let jump = appendBlock(function);
            let after = appendBlock(function);
            buildCondBr(function, stmt.span, patReg, jump, after);

            setCurrentBlock(function, jump);
            generateBytecodeBlock(this, function, block);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, after);
            }
            setCurrentBlock(function, after);
            leaveScope(function);
        }
        &StmtData::IfLetElse(pat, expr, block, elze) => {
            let scope: usize = enterScope(function);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let patReg = generateBytecodePattern(this, function, result, pat, false /* don't care */);

            let jumpTrue = appendBlock(function);
            let jumpFalse = appendBlock(function);
            buildCondBr(function, stmt.span, patReg, jumpTrue, jumpFalse);

            setCurrentBlock(function, jumpTrue);
            generateBytecodeBlock(this, function, block);
            jumpTrue = getCurrentBlock(function);
            leaveScope(function);

            setCurrentBlock(function, jumpFalse);
            generateBytecodeBlock(this, function, elze);
            jumpFalse = getCurrentBlock(function);

            let jumpTrueBlock: &IRBlock = getBlockByID(function, jumpTrue);
            let jumpFalseBlock: &IRBlock = getBlockByID(function, jumpFalse);
            let jumpTrueTerm: bool = isTerminated(jumpTrueBlock);
            let jumpFalseTerm: bool = isTerminated(jumpFalseBlock);
            if (jumpTrueTerm && jumpFalseTerm) {
                // nothing to do here
            } else if (jumpTrueTerm && !jumpFalseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, jumpFalse);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else if (!jumpTrueTerm && jumpFalseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, jumpTrue);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, jumpTrue);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, jumpFalse);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            }
        }
        &StmtData::WhileLet(pat, expr, block) => {
            let scope: usize = enterScope(function);
            let condBlock = appendBlock(function);
            let bodyBlock = appendBlock(function);
            let afterBlock = appendBlock(function);
            pushLoopBlocks(function, condBlock, afterBlock);
            buildBr(function, stmt.span, condBlock);

            setCurrentBlock(function, condBlock);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            let patReg = generateBytecodePattern(this, function, result, pat, false /* don't care */);
            buildCondBr(function, stmt.span, patReg, bodyBlock, afterBlock);

            setCurrentBlock(function, bodyBlock);
            generateBytecodeBlock(this, function, block);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, condBlock);
            }

            setCurrentBlock(function, afterBlock);
            popLoopBlocks(function);
            leaveScope(function);
        }
        &StmtData::CFor { init, cond, step, body } => {
            let initBlock = appendBlock(function);
            let condBlock = appendBlock(function);
            let stepBlock = appendBlock(function);
            let bodyBlock = appendBlock(function);
            let afterBlock = appendBlock(function);
            pushLoopBlocks(function, stepBlock, afterBlock);
            buildBr(function, stmt.span, initBlock);
            let scope = enterScope(function);

            setCurrentBlock(function, initBlock);
            generateBytecodeStmt(this, function, init);
            if (!isTerminated(getCurrentBlockAsRef(function))) {
                buildBr(function, init.span, condBlock);
            }

            setCurrentBlock(function, condBlock);
            let condReg = generateBytecodeExpr(this, function, cond, false);
            buildCondBr(function, cond.span, condReg, bodyBlock, afterBlock);

            setCurrentBlock(function, stepBlock);
            generateBytecodeExpr(this, function, step, false);
            buildBr(function, step.span, condBlock);

            setCurrentBlock(function, bodyBlock);
            generateBytecodeStmt(this, function, body);
            if (!isTerminated(getCurrentBlockAsRef(function))) {
                buildBr(function, body.span, stepBlock);
            }

            let after = leaveScope(function);
            assert(scope == after, "Scope imbalance in for-loop");
            setCurrentBlock(function, afterBlock);
            popLoopBlocks(function);
        }
        &StmtData::Break => {
            if (!buildBreak(function, stmt.span)) {
                todo_with_msg("break outside of loop");
            }
        }
        &StmtData::Continue => {
            if (!buildContinue(function, stmt.span)) {
                todo_with_msg("continue outside of loop");
            }
        }
        &StmtData::Match(_, _, _) => {
            generateBytecodeMatchStmt(this, function, stmt);
        }
        &StmtData::Asm(fn, args) => {
            let retType = getReturnType(getType(&fn.typeState));
            assert(getSizeInBytes(retType) > 8, "Expected Inline Assembly function to return ASMContext");
            let irArgs: RegIndexList = blank;
            let retPtr: RegIndex = blank;
            {
                retPtr = allocateRegister(function, intoPointer(retType));
                startComptime(function);
                buildAlloca(function, stmt.span, retPtr, getSizeInBytes(retType));
                endComptime(function);
                push(&irArgs, retPtr);
            }
            comptime IR_VALUE = BUILD_A_KEYWORD("IRValue");
            comptime ASM_FILE = BUILD_A_KEYWORD("asm.bufo");
            let lookup: TypeLookup = blank;
            let unions = searchAllFilesForTypeName(this.lookup, &IR_VALUE);
            let context: &UnionLookup = null;
            for (let i: usize = 0; i < unions.length; i = i + 1) {
                let l = at(&unions, i);
                if (l.kind == TYPE_LOOKUP_UNION) {
                    let u = l.actual as &UnionLookup;
                    let decl = u.global;
                    if (!decl.parent.isFile) continue;
                    let parent = at(&files, decl.parent.id as usize);
                    let filePath = toString(&parent.origin);
                    let fileName = getFileName(&filePath);
                    drop(&filePath);
                    if (equals(&asSubStr(&fileName), &ASM_FILE)) {
                        assert(context == null, "How did we find another asm.bufo?");
                        context = u;
                    }
                    drop(&fileName);
                }
            }
            assert(context != null, "Could not find IRValue!");
            let regValueType = context.type;
            for (let i: usize = 0; i < args.length; i = i + 1) {
                let arg = *at(&args, i);
                let result = generateBytecodeExpr(this, function, arg, false);
                startComptime(function);
                let regValue = allocateRegister(function, regValueType);
                buildIntoIRValue(function, arg.span, regValue, result);
                push(&irArgs, prepareArgument(this, function, arg.span, regValue, regValueType));
                endComptime(function);
            }
            startComptime(function);
            let base = generateBytecodeExpr(this, function, fn, false);
            let reg = prepareReturnValue(this, stmt.span, function, base, irArgs, retType, retPtr, false);
            endComptime(function);
            buildEmitAssembly(function, stmt.span, reg, getType(&fn.typeState));
        }
        unknown => {
            C::fprintf(stderr, "%s generateBytecodeStmt: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
}

func generateBytecodeMatchStmt(this: &IRGen, function: &IRFunc, match: &ParsedStmt) {
    let expr: &ParsedExpr = null;
    let patterns: &ParsedPatternList = null;
    let stmts: &ParsedStmtList = null;
    match (&match.data) {
        &StmtData::Match(_expr, _patterns, _stmts) => {
            expr = _expr;
            patterns = &_patterns;
            stmts = &_stmts;
        }
        _ => { unreachable(); }
    }
    assert(patterns.length == stmts.length);
    let state = match.typeState;
    assert(isPattern(&state));
    let patState = getPatState(&state);
    assert(patState.complete, "generateBytecodeMatchStmt: Non-exhaustive pattern");
    let exprReg = generateBytecodeExpr(this, function, expr, false);
    let end = appendBlock(function);
    for (let i: usize = 0; i < patterns.length; i = i + 1) {
        let pat = *at(patterns, i);
        let stmt = *at(stmts, i);
        let scope: usize = enterScope(function);
        let patReg = generateBytecodePattern(this, function, exprReg, pat, false /* don't care */);
        let matchBlock = appendBlock(function);
        let nextBlock = appendBlock(function);
        buildCondBr(function, match.span, patReg, matchBlock, nextBlock);
        setCurrentBlock(function, matchBlock);
        generateBytecodeStmt(this, function, stmt);
        if (!isTerminated(getCurrentBlockAsRef(function))) {
            buildBr(function, stmt.span, end);
        }
        setCurrentBlock(function, nextBlock);
        let after = leaveScope(function);
        assert(scope == after, "Scope imbalance in match");
    }
    // in the normal control flow, we should at some point always go into a matchBlock, which jumps
    // to the end. If we don't, there's an internal compiler bug, which is why we put an unreachable
    // here.
    let funcID = getFunctionByMangledName(this, "unreachablePcrN", "prelude.bufo");
    let args: RegIndexList = blank;
    {
        let err: RegIndex = allocateRegister(function, wrap(Type::Prim(PrimType::Char)));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&match.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": FATAL COMPILER ERROR: match-statement reached guard block!\n");
        pushString(&s, &_s);
        pushStr(&s, ": This should never happen, as all match-patterns eventually lead to the real block.\n");
        pushString(&s, &_s);
        pushStr(&s, ": Please submit a bug report.\n");
        drop(&_s);
        buildLoadString(function, match.span, err, asSubStr(&s));
        push(&args, err);
    }
    generateImplicitCall(this, function, match.span, funcID, wrap(Type::Prim(PrimType::None)), args);
    buildUnreachable(function, match.span);
    setCurrentBlock(function, end);
}

func generateBytecodePattern(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, inOrigMemory: bool) -> RegIndex {
    return generateBytecodePattern(this, function, expr, pat, inOrigMemory, false);
}
func generateBytecodePattern(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, inOrigMemory: bool, isComptimeVariable: bool) -> RegIndex {
    let type = getRegister(function, expr).typ;
    let success = allocateRegister(function, wrap(Type::Prim(PrimType::Bool)));
    match (&pat.data) {
        &Pattern::Ident(name) => {
            // FIXME: This pattern doesn't update DebugInfo of the identifier properly
            if (isComptimeVariable) {
                addVariable(this, function, pat.span, last(&function.scopes), name.content, expr, true);
            } else if (inOrigMemory) {
                addVariable(this, function, pat.span, last(&function.scopes), name.content, expr, false);
            } else {
                let allocReg = allocateRegister(function, intoPointer(type));
                buildAlloca(function, pat.span, allocReg, getSizeInBytes(type));
                buildStore(function, pat.span, allocReg, expr);
                addVariable(this, function, pat.span, last(&function.scopes), name.content, allocReg, false);
            }
            buildLoadBool(function, pat.span, success, 1);
        }
        &Pattern::Reference(sub) => {
            assert(isPointer(type), "Reference Pattern expected pointer type");
            let under = getUnderlyingType(type, false);
            if (isPointer(under)) {
                let reg = allocateRegister(function, under);
                buildLoad(function, pat.span, reg, expr);
                return generateBytecodePattern(this, function, reg, sub, true, isComptimeVariable);
            } else {
                return generateBytecodePattern(this, function, expr, sub, true, isComptimeVariable);
            }
        }
        &Pattern::PatWithType(sub, _) => {
            return generateBytecodePattern(this, function, expr, sub, inOrigMemory, isComptimeVariable);
        }
        &Pattern::Null => {
            assert(isPointer(type), "Null Pattern expected pointer type");
            let reg = allocateRegister(function, type);
            buildLoadNull(function, pat.span, reg);
            buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, reg);
        }
        &Pattern::Boolean(true) => {
            if (inOrigMemory) {
                assert(isPointer(type), "Boolean Pattern inOrigMemory expected pointer");
                assert(isPointerTo(type, wrap(Type::Prim(PrimType::Bool))), "Boolean Pattern inOrigMemory expected pointer to bool");
                let _expr = allocateRegister(function, getUnderlyingType(type, false));
                buildLoad(function, pat.span, _expr, expr);
                buildMove(function, pat.span, success, _expr);
            } else {
                buildMove(function, pat.span, success, expr);
            }
        }
        &Pattern::Boolean(false) => {
            if (inOrigMemory) {
                assert(isPointer(type), "Boolean Pattern inOrigMemory expected pointer");
                assert(isPointerTo(type, wrap(Type::Prim(PrimType::Bool))), "Boolean Pattern inOrigMemory expected pointer to bool");
                let _expr = allocateRegister(function, getUnderlyingType(type, false));
                buildLoad(function, pat.span, _expr, expr);
                buildLogicalNot(function, pat.span, success, _expr);
            } else {
                buildLogicalNot(function, pat.span, success, expr);
            }
        }
        &Pattern::Struct(_, _) => {
            buildLoadBool(function, pat.span, success, 1);
            generateBytecodePatternStruct(this, function, expr, pat, success, inOrigMemory, isComptimeVariable);
        }
        &Pattern::Path(_, sub) => {
            buildLoadBool(function, pat.span, success, 1);
            let ptr = isPointer(type);
            if (ptr) type = getUnderlyingType(type, false);
            if (isUnion(type)) {
                generateBytecodePatternUnion(this, function, expr, pat, success, ptr || inOrigMemory, isComptimeVariable);
            } else if (isStruct(type)) {
                generateBytecodePatternStruct(this, function, expr, sub, success, ptr || inOrigMemory, isComptimeVariable);
            } else {
                unreachable("generateBytecodePattern(PATTERN_PATH): Exhaustive handling of variations");
            }
        }
        &Pattern::Number(ident) => {
            let number: RegIndex = blank;
            let real = type;
            if (inOrigMemory) {
                assert(isPointer(real), "generateBytecodePattern: Number inOrigMemory");
                real = getUnderlyingType(real, false);
                let _expr = allocateRegister(function, real);
                buildLoad(function, pat.span, _expr, expr);
                expr = _expr;
            }
            number = allocateRegister(function, real);
            loadLiteral(this, function, number, &ident);
            if (isInteger(real)) {
                buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, number);
            } else if (isFloat(real)) {
                buildBinaryOp(function, pat.span, INSTR_FLOAT_CMP_EQ, success, expr, number);
            } else {
                unreachable("Exhaustive handling of number types in IRGen.generateBytecodePattern");
            }
        }
        &Pattern::Wildcard => { buildLoadBool(function, pat.span, success, 1); }
        &Pattern::Rest => { buildLoadBool(function, pat.span, success, 1); }
        &Pattern::Tuple(_) => {
            buildLoadBool(function, pat.span, success, 1);
            generateBytecodePatternTuple(this, function, expr, pat, success, inOrigMemory, isComptimeVariable);
        }
        _ => { unreachable("Exhaustive handling of patterns in IRGen.generateBytecodePattern"); }
    }
    return success;
}
func generateBytecodePatternTuple(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool, isComptimeVariable: bool) {
    let type = getRegister(function, expr).typ;
    let Pattern::Tuple(subPatterns) = pat.data else {
        unreachable("generateBytecodePatternTuple: Not a tuple pattern");
    };
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        let &Type::Ptr(&Type::Tuple(elems)) = type else {
            unreachable("generateBytecodePatternTuple: Not a tuple ptr");
        };
        for (let i: usize = 0; i < elems.length; i = i + 1) {
            let subPat = *at(&subPatterns, i);
            let fieldType = intoPointer(elems.elements[i]);
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, subExpr, expr, i);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, true, isComptimeVariable);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    } else {
        let &Type::Tuple(elems) = type else {
            unreachable("generateBytecodePatternTuple: Not a tuple type");
        };
        let allocReg = allocateRegister(function, intoPointer(type));
        buildAlloca(function, pat.span, allocReg, getSizeInBytes(type));
        buildStore(function, pat.span, allocReg, expr);
        expr = allocReg;
        for (let i: usize = 0; i < elems.length; i = i + 1) {
            let subPat = *at(&subPatterns, i);
            let fieldType = elems.elements[i];
            let fieldPtr = allocateRegister(function, intoPointer(fieldType));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, fieldPtr, expr, i);
            buildLoad(function, pat.span, subExpr, fieldPtr);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, false, isComptimeVariable);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    }
}

func generateBytecodePatternStruct(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool, isComptimeVariable: bool) {
    let type = getRegister(function, expr).typ;
    let subPatterns: &ParsedPatternList = null;
    match (&pat.data) {
        &Pattern::Struct(_, patterns) => { subPatterns = &patterns; }
        _ => { unreachable(); }
    }
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        let decl: &ParsedStructDecl = null;
        match (type) {
            &Type::Ptr(&Type::Struct(_decl)) => { decl = _decl; }
            _ => { unreachable("In Memory Struct Pattern expected pointer to struct type"); }
        }
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = intoPointer(getType(&fieldNode.typeState));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, subExpr, expr, i);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, true, isComptimeVariable);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    } else {
        let decl: &ParsedStructDecl = null;
        match (type) {
            &Type::Struct(_decl) => { decl = _decl; }
            _ => { unreachable("Struct Pattern expected struct type"); }
        }
        let allocReg = allocateRegister(function, intoPointer(type));
        buildAlloca(function, pat.span, allocReg, getSizeInBytes(type));
        buildStore(function, pat.span, allocReg, expr);
        expr = allocReg;
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldPtr = allocateRegister(function, intoPointer(fieldType));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, fieldPtr, expr, i);
            buildLoad(function, pat.span, subExpr, fieldPtr);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, false, isComptimeVariable);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    }
}

func generateBytecodePatternUnion(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool, isComptimeVariable: bool) {
    // FIXME: Handling of IR for unions is always so awkward
    let type = getRegister(function, expr).typ;
    let name: &Token = null;
    let subPatterns: ParsedPatternList = blank;
    match (&pat.data) {
        &Pattern::Path(_, &ParsedPattern { _, _, Pattern::Ident(ident) }) => {
            name = &ident;
        }
        &Pattern::Path(_, &ParsedPattern { _, _, Pattern::Struct(ident, pats) }) => {
            name = &ident;
            subPatterns = pats;
        }
        _ => { unreachable(); }
    }
    let usizeType = wrap(Type::Prim(PrimType::Usize));
    let sizeReg = allocateRegister(function, usizeType);
    let tagMatch = allocateRegister(function, wrap(Type::Prim(PrimType::Bool)));
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        let decl: &ParsedUnionDecl = null;
        match (type) {
            &Type::Ptr(&Type::Union(_decl, _)) => { decl = _decl; }
            _ => { unreachable("In Memory Union Pattern expected pointer type"); }
        }
        let smol = PrimType::U8;
        if (decl.variants.length >= 256) smol = PrimType::U16;
        let tagType = wrap(Type::Prim(smol));
        let tagReg = allocateRegister(function, tagType);
        let tagPtr = allocateRegister(function, intoPointer(tagType));
        let tagVal = allocateRegister(function, tagType);
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, name, &variant);
        assert(found);
        let tmp = allocateRegister(function, intoPointer(type));
        buildMove(function, pat.span, tmp, expr);
        {
            // tagReg check
            buildLoadInteger(function, name.span, tagReg, tagType, getVariantTag(decl, variant));
            buildMove(function, name.span, tagPtr, tmp);
            buildLoad(function, name.span, tagVal, tagPtr);
            buildBinaryOp(function, name.span, INSTR_INT_CMP_EQ, tagMatch, tagReg, tagVal);
            buildBinaryOp(function, name.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tagReg
            let offset: usize = 1;
            if (decl.variants.length >= 256) offset = 2;
            buildLoadInteger(function, name.span, sizeReg, usizeType, offset);
            buildPtrToInt(function, name.span, tmp, tmp);
            buildBinaryOp(function, name.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, name.span, tmp, tmp);
        }
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSizeInBytes(fieldType);
            let subPtr = allocateRegister(function, intoPointer(fieldType));
            buildMove(function, subSubPat.span, subPtr, tmp);
            let sub = generateBytecodePattern(this, function, subPtr, subSubPat, true, isComptimeVariable);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
            if (i != subPatterns.length - 1) {
                buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    } else {
        let decl: &ParsedUnionDecl = null;
        match (type) {
            &Type::Union(_decl, _) => { decl = _decl; }
            _ => { unreachable("Union Pattern expected union type"); }
        }
        let smol = PrimType::U8;
        if (decl.variants.length >= 256) smol = PrimType::U16;
        let tagType = wrap(Type::Prim(smol));
        let tagReg = allocateRegister(function, tagType);
        let tagPtr = allocateRegister(function, intoPointer(tagType));
        let tagVal = allocateRegister(function, tagType);
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, name, &variant);
        assert(found);
        let allocReg = allocateRegister(function, intoPointer(type));
        buildAlloca(function, pat.span, allocReg, getSizeInBytes(type));
        buildStore(function, pat.span, allocReg, expr);
        let tmp = allocateRegister(function, intoPointer(type));
        buildMove(function, pat.span, tmp, allocReg);
        {
            // tagReg check
            buildLoadInteger(function, name.span, tagReg, tagType, getVariantTag(decl, variant));
            buildMove(function, name.span, tagPtr, allocReg);
            buildLoad(function, name.span, tagVal, tagPtr);
            buildBinaryOp(function, name.span, INSTR_INT_CMP_EQ, tagMatch, tagReg, tagVal);
            buildBinaryOp(function, name.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tagReg
            let offset: usize = 1;
            if (decl.variants.length >= 256) offset = 2;
            buildLoadInteger(function, name.span, sizeReg, usizeType, offset);
            buildPtrToInt(function, name.span, tmp, tmp);
            buildBinaryOp(function, name.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, name.span, tmp, tmp);
        }
        expr = allocReg;
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSizeInBytes(fieldType);
            let subAlloc = allocateRegister(function, intoPointer(fieldType));
            let subExpr = allocateRegister(function, fieldType);
            buildAlloca(function, subSubPat.span, subAlloc, fieldSize);
            buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
            buildMemcpy(function, subSubPat.span, tmp, subAlloc, sizeReg);
            buildLoad(function, subSubPat.span, subExpr, subAlloc);
            let sub = generateBytecodePattern(this, function, subExpr, subSubPat, false, isComptimeVariable);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
            if (i != subPatterns.length - 1) {
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    }
}

func generateBytecodeExpr(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    if (expr.ignored) return blank;
    assert(isSuccess(&expr.typeState), "Expected valid Expr type in IRGen");
    match (&expr.data) {
        &ExprData::IntLit(_)    => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::StrLit(_)    => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::CharLit(_)   => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::ArrayLit(_)  => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::Ident(ident) => { return generateBytecodeExprIdentifier(this, function, &ident, needsPtr); }
        &ExprData::Unary(unary) => {
            return generateBytecodeExprUnary(this, function, expr.span, &unary, getType(&expr.typeState), needsPtr);
        }
        &ExprData::Binary(binary) => {
            return generateBytecodeExprBinary(this, function, &binary, getType(&expr.typeState), needsPtr);
        }
        &ExprData::Call(call) => { return generateBytecodeExprCall(this, function, &call, needsPtr); }
        &ExprData::Sizeof(typeNode) => {
            let t: &Type = getType(&expr.typeState);
            let target: &Type = getType(&typeNode.typeState);
            let reg: RegIndex = allocateRegister(function, t);
            let size: usize = getSizeInBytes(target);
            buildLoadInteger(function, expr.span, reg, t, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::StructInit(init) => {
            let strukt: &Type = getType(&expr.typeState);
            let structDecl: &ParsedStructDecl = null;
            match (strukt) {
                &Type::Struct(_decl) => { structDecl = _decl; }
                _ => { unreachable("Expected Struct Type in EXPR_STRUCT_INIT"); }
            }
            let reg: RegIndex = allocateRegister(function, strukt);
            buildCreateStruct(function, expr.span, reg);
            for (let i: usize = 0; i < init.context.fieldLength; i = i + 1) {
                let name: Token = getFieldNameAtIndex(&init.context, i);
                let field: &ParsedExpr = getFieldExprAtIndex(&init.context, i);
                let index: usize = getFieldIndex(structDecl, &name.content);
                let result: RegIndex = generateBytecodeExpr(this, function, field, false);
                buildInsertValue(function, field.span, reg, index, result);
            }
            if (needsPtr) {
                let structAlloc: RegIndex = allocateRegister(function, intoPointer(strukt));
                buildAlloca(function, expr.span, structAlloc, getSizeInBytes(strukt));
                buildStore(function, expr.span, structAlloc, reg);
                return structAlloc;
            }
            return reg;
        }
        &ExprData::UnionInit(init) => {
            return generateBytecodeExprUnionInit(this, function, expr.span, &init, getType(&expr.typeState), needsPtr);
        }
        &ExprData::As(_,_) => { return generateBytecodeExprAs(this, function, expr, needsPtr); }
        &ExprData::Null => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::Blank => {
            let t: &Type = getType(&expr.typeState);
            let size: usize = getSizeInBytes(t);
            let reg: RegIndex = allocateRegister(function, t);
            buildLoadBlank(function, expr.span, reg, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::True => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::False => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::Func(decl) => {
            let name: String = getMangledName(decl);
            let funcID: usize = getFunctionByName(this, &name);
            let dst = allocateRegister(function, getType(&decl.typeState));
            buildLoadFunctionPtr(function, expr.span, dst, funcID);
            return dst;
        }
        &ExprData::TypeInfo(typeNode) => {
            let target: &Type = getType(&typeNode.typeState);
            let typeInfo: &Type = getType(&expr.typeState);
            let reg = generateTypeInfo(this, function, expr.span, target);
            if (needsPtr) {
                let size: usize = getSizeInBytes(typeInfo);
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(typeInfo));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::AsData(exprNode) => {
            let subExpr = generateBytecodeExpr(this, function, exprNode, true);
            let target: &Type = getType(&exprNode.typeState);
            let data: &Type = getType(&expr.typeState);
            let reg = allocateRegister(function, data);
            buildCreateStruct(function, expr.span, reg);
            buildInsertValue(function, expr.span, reg, 0, subExpr);
            {
                let ti = generateTypeInfo(this, function, expr.span, target);
                buildInsertValue(function, expr.span, reg, 1, ti);
            }
            if (needsPtr) {
                let size: usize = getSizeInBytes(data);
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(data));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::Variadic(vals) => {
            // f(..., v1, v2, v3)
            // tmp = [v1, v2, v3]
            // var = { &tmp, 3 }
            let varType: &Type = getType(&expr.typeState);
            assert(isVariadicType(varType), "ExprData::Variadic() is not variadic?");
            let subType = getUnderlyingType(varType, false);
            let count = vals.length;

            // Create tmp
            let newType = intoArrayType(subType, count);
            let reg = allocateRegister(function, newType);
            buildCreateArray(function, expr.span, reg);
            for (let i: usize = 0; i < vals.length; i = i + 1) {
                let result: RegIndex = generateBytecodeExpr(this, function, *at(&vals, i), false);
                buildInsertValue(function, expr.span, reg, i, result);
            }
            // Pointer to tmp
            let alloca = allocateRegister(function, intoPointer(newType));
            buildAlloca(function, expr.span, alloca, getSizeInBytes(newType));
            buildStore(function, expr.span, alloca, reg);

            // length of variadic
            let usizeType = wrap(Type::Prim(PrimType::Usize));
            let sizeReg = allocateRegister(function, usizeType);
            buildLoadInteger(function, expr.span, sizeReg, usizeType, vals.length);

            // Wrapper struct
            reg = allocateRegister(function, varType);
            buildCreateStruct(function, expr.span, reg);
            buildInsertValue(function, expr.span, reg, 0, alloca);
            buildInsertValue(function, expr.span, reg, 1, sizeReg);
            assert(!needsPtr, "needsPtr for ExprData::Variadic?");
            return reg;
        }
        &ExprData::Tuple(elems) => {
            let tuple: &Type = getType(&expr.typeState);
            let reg: RegIndex = allocateRegister(function, tuple);
            buildCreateStruct(function, expr.span, reg);
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                let e = elems.elements[i];
                let result: RegIndex = generateBytecodeExpr(this, function, e, false);
                buildInsertValue(function, e.span, reg, i, result);
            }
            if (needsPtr) {
                let structAlloc: RegIndex = allocateRegister(function, intoPointer(tuple));
                buildAlloca(function, expr.span, structAlloc, getSizeInBytes(tuple));
                buildStore(function, expr.span, structAlloc, reg);
                return structAlloc;
            }
            return reg;
        }
        unknown => {
            C::fprintf(stderr, "%s generateBytecodeExpr: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
    unreachable("Exhaustive handling of ops in generateBytecodeExpr");
}

func generateTypeInfo(this: &IRGen, function: &IRFunc, span: Span, type: &Type) -> RegIndex {
    let index = index_of_type(&this.type_info_table, type);
    assert(index < this.type_info_table.length, "generateTypeInfo: Info for type doesn't exist");

    let isGlobal = false;
    let global_type_info_table = getIdentifierByName(this, function, comptime newSubStrOfStrLit("type_info_table"), &isGlobal);
    assert(global_type_info_table != null, "generateTypeInfo: Could not find global type info table variable");
    assert(isGlobal, "generateTypeInfo: Global type info table is not global");

    comptime NAME = BUILD_A_KEYWORD("TypeInfo");
    comptime FILE = BUILD_A_KEYWORD("type_info.bufo");
    let context = findUnionByNameInFile(this.lookup, &FILE, &NAME);
    assert(context != null, "generateTypeInfo: Could not find union context for TypeInfo");
    let typeInfo = context.type;

    let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
    let indexReg = allocateRegister(function, usizeType);
    let indices: RegIndexList = blank;
    buildLoadInteger(function, span, indexReg, usizeType, index);
    push(&indices, indexReg);

    let info = allocateRegister(function, typeInfo);
    let info_ptr = allocateRegister(function, intoPointer(typeInfo));
    buildFetchGlobalPointer(function, span, info_ptr, global_type_info_table.ptr);
    buildLoad(function, span, info_ptr, info_ptr);
    buildGetElementPtr(function, span, info_ptr, info_ptr, indices);
    buildLoad(function, span, info, info_ptr);
    return info;
}

func generateBytecodeExprBinary(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    match (expr) {
        &BinaryExpr::Path(..) => { return generateBytecodeExprPathAccess(this, function, expr, needsPtr); }
        &BinaryExpr::Dot(..) => { return generateBytecodeExprMemberAccess(this, function, expr, needsPtr); }
        &BinaryExpr::Assign(..) => { return generateBytecodeExprAssignment(this, function, expr); }
        &BinaryExpr::Plus(..) => { return generateBytecodeExprArithmetic(this, function, expr, type, needsPtr); }
        &BinaryExpr::Sub(..) => { return generateBytecodeExprArithmetic(this, function, expr, type, needsPtr); }
        &BinaryExpr::Mult(..) => { return generateBytecodeExprArithmetic(this, function, expr, type, needsPtr); }
        &BinaryExpr::Div(..) => { return generateBytecodeExprArithmetic(this, function, expr, type, needsPtr); }
        &BinaryExpr::Mod(..) => { return generateBytecodeExprArithmetic(this, function, expr, type, needsPtr); }
        &BinaryExpr::CmpEq(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpNeq(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpGt(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpGte(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpLt(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpLte(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::LogAnd(..) => { return generateBytecodeExprLogical(this, function, expr, type); }
        &BinaryExpr::LogOr(..) => { return generateBytecodeExprLogical(this, function, expr, type); }
        &BinaryExpr::BitAnd(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::BitOr(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::BitXor(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::Indexed(..) => { return generateBytecodeExprIndexedAccess(this, function, expr, type, needsPtr); }
        unknown => {
            C::fprintf(stderr, "%s generateBytecodeExprBinary: Unhandled tag %hhu!\n", FATAL_STR, tag(unknown));
            C::exit(2);
        }
    }
    unreachable("generateBytecodeExprBinary: Exhaustive handling of binary ops");
}

func generateBytecodeExprUnionInit(this: &IRGen, function: &IRFunc, span: Span, expr: &UnionExpr, type: &Type, needsPtr: bool) -> RegIndex {
    // union = [tag, data]
    let decl: &ParsedUnionDecl = null;
    let variant: &ParsedUnionVariant = null;
    let tag: usize = 0;
    match (type) {
        &Type::Union(_decl, _variant) => {
            decl = _decl;
            variant = *at(&decl.variants, _variant);
            tag = _variant;
        }
        _ => { unreachable("Expected Union Type in EXPR_UNION_INIT"); }
    }
    assert(decl.variants.length < 65536, "IRGen assumes that the tag of an union fits in at most two bytes");
    let size = getSizeInBytes(type);
    assert(size >= 1, "Expected union instance to be at least one byte");
    let start = allocateRegister(function, intoPointer(type));
    buildAlloca(function, span, start, size);
    let empty = allocateRegister(function, type);
    buildCreateUnion(function, span, empty);
    buildStore(function, span, start, empty);
    let usizeType = wrap(Type::Prim(PrimType::Usize));
    let sizeReg = allocateRegister(function, usizeType);
    let offsetReg = allocateRegister(function, usizeType);
    let tmp = allocateRegister(function, intoPointer(type));
    let base = allocateRegister(function, intoPointer(type));
    buildMove(function, span, tmp, start);
    {
        // tag
        let smol = PrimType::U8;
        if (decl.variants.length >= 256) smol = PrimType::U16;
        let tagType = wrap(Type::Prim(smol));
        let tagReg = allocateRegister(function, tagType);
        buildLoadInteger(function, span, tagReg, tagType, tag);
        buildStore(function, span, start, tagReg);

        // offset tmp by tag
        let offset: usize = 1;
        if (decl.variants.length >= 256) offset = 2;
        buildLoadInteger(function, span, sizeReg, usizeType, offset);
        buildPtrToInt(function, span, tmp, tmp);
        buildBinaryOp(function, span, INSTR_INT_ADD, tmp, tmp, sizeReg);
        buildIntToPtr(function, span, tmp, tmp);
    }
    buildMove(function, span, base, tmp);
    // FIXME: Payload of unions should be padded to fit their alignment
    // NOTE:  This will also break pattern matching and debug info
    // FIXME: FIXME ABOVE IS IMPORTANT
    // FIXME: FIXME ABOVE IS IMPORTANT
    // FIXME: FIXME ABOVE IS IMPORTANT
    match (expr) {
        &UnionExpr::Empty => {
            // nothing to do here
            // REVIEW: Maybe allow things like  union { A = 12, B = 23 }  ?
        }
        &UnionExpr::Tuple(tuple) => {
            assert(variant.kind == UNION_VARIANT_TUPLE, "UnionExpr::Tuple did not get Tuple variant");
            for (let i: usize = 0; i < tuple.args.length; i = i + 1) {
                let field: &ParsedExpr = *at(&tuple.args, i);
                let result: RegIndex = generateBytecodeExpr(this, function, field, true);
                buildLoadInteger(function, field.span, sizeReg, usizeType, getSizeInBytes(getType(&field.typeState)));
                buildMemcpy(function, field.span, result, tmp, sizeReg);
                if (i != tuple.args.length - 1) {
                    buildPtrToInt(function, span, tmp, tmp);
                    buildBinaryOp(function, span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                    buildIntToPtr(function, span, tmp, tmp);
                }
            }
        }
        &UnionExpr::Struct(context) => {
            assert(variant.kind == UNION_VARIANT_STRUCT, "UnionExpr::Struct did not get Struct variant");
            for (let i: usize = 0; i < context.context.fieldLength; i = i + 1) {
                let name: Token = getFieldNameAtIndex(&context.context, i);
                let field: &ParsedExpr = getFieldExprAtIndex(&context.context, i);
                let result: RegIndex = generateBytecodeExpr(this, function, field, true);
                let size: usize = 0;
                let offset: usize = 0;
                {
                    let index: usize = getFieldIndex(variant, &name.content);
                    getFieldOffsetAndSize(variant, index, &offset, &size, false);
                    buildLoadInteger(function, field.span, offsetReg, usizeType, offset);
                    buildPtrToInt(function, span, base, base);
                    buildPtrToInt(function, span, tmp, tmp);
                    buildBinaryOp(function, span, INSTR_INT_ADD, tmp, base, offsetReg);
                    buildIntToPtr(function, span, tmp, tmp);
                    buildIntToPtr(function, span, base, base);
                }
                buildLoadInteger(function, field.span, sizeReg, usizeType, size);
                buildMemcpy(function, field.span, result, tmp, sizeReg);
            }
        }
        _ => { unreachable(); }
    }
    if (needsPtr) {
        return start;
    } else {
        let dst = allocateRegister(function, type);
        buildLoad(function, span, dst, start);
        return dst;
    }
}

func generateBytecodeExprAs(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    let orig: &ParsedExpr = null;
    let typeNode: &ParsedTypeNode = null;
    match (expr.data) {
        ExprData::As(_orig, _type) => { orig = _orig; typeNode = _type; }
        _ => { unreachable(); }
    }
    let current: &Type = getType(&orig.typeState);
    let target: &Type = getType(&typeNode.typeState);
    let result: RegIndex = generateBytecodeExpr(this, function, orig, isData(current));
    let dst: RegIndex = allocateRegister(function, target);
    if (isData(current)) {
        // TODO: Runtime check that whatever we're loading is actually behind the Data
        let fieldPtr = allocateRegister(function, intoPointer(intoPointer(target)));
        buildGetFieldPtr(function, expr.span, fieldPtr, result, 0);
        buildLoad(function, expr.span, fieldPtr, fieldPtr);
        buildLoad(function, expr.span, dst, fieldPtr);
    } else if (isData(target)) {
        unreachable("generateBytecodeExprAs: <something> as Data should've been handled by the Type Checker");
    } else if (isInteger(current) && isPointer(target)) {
        buildIntToPtr(function, expr.span, dst, result);
    } else if (isPointer(current) && isInteger(target)) {
        buildPtrToInt(function, expr.span, dst, result);
    } else if (isPointer(current) && isPointer(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isAny(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isAny(target)) {
        buildMove(function, expr.span, dst, result);
    } else if ((isChar(current) || isInteger(current)) && (isChar(target) || isInteger(target))) {
        if (getSizeInBits(current) < getSizeInBits(target)) {
            if (isSignedInteger(current)) {
                buildIntSignExtend(function, expr.span, dst, result, getSizeInBits(target));
            } else {
                buildIntZeroExtend(function, expr.span, dst, result, getSizeInBits(target));
            }
        } else if (getSizeInBits(current) > getSizeInBits(target)) {
            buildIntTruncate(function, expr.span, dst, result, getSizeInBits(target));
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else if (isInteger(current) && isFloat(target)) {
        if (getSizeInBytes(target) == 4) buildIntToF32(function, expr.span, dst, result);
        else if (getSizeInBytes(target) == 8) buildIntToF64(function, expr.span, dst, result);
        else unreachable("int to float");
    } else if (isFloat(current) && isInteger(target)) {
        if (getSizeInBytes(current) == 4) buildF32ToInt(function, expr.span, dst, result);
        else if (getSizeInBytes(current) == 8) buildF64ToInt(function, expr.span, dst, result);
        else unreachable("float to int");
    } else if (isBoolean(current) && isInteger(target)) {
        if (isSignedInteger(current)) {
            buildIntSignExtend(function, expr.span, dst, result, getSizeInBits(target));
        } else {
            buildIntZeroExtend(function, expr.span, dst, result, getSizeInBits(target));
        }
    } else if (isInteger(current) && isBoolean(target)) {
        let zero: RegIndex = allocateRegister(function, current);
        buildLoadInteger(function, expr.span, zero, current, 0);
        buildBinaryOp(function, expr.span, INSTR_INT_CMP_NEQ, dst, result, zero);
    } else if (isFloat(current) && isFloat(target)) {
        if (getSizeInBytes(current) < getSizeInBytes(target)) {
            assert(getSizeInBytes(current) == 4);
            assert(getSizeInBytes(target) == 8);
            buildF32ToF64(function, expr.span, dst, result);
        } else if (getSizeInBytes(current) > getSizeInBytes(target)) {
            assert(getSizeInBytes(current) == 8);
            assert(getSizeInBytes(target) == 4);
            buildF64ToF32(function, expr.span, dst, result);
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else {
        unreachable("Exhaustive handling of variations in generateBytecodeExprAs");
    }
    if (needsPtr) {
        let tempAlloc: RegIndex = allocateRegister(function, intoPointer(target));
        buildAlloca(function, expr.span, tempAlloc, getSizeInBytes(target));
        buildStore(function, expr.span, tempAlloc, dst);
        dst = tempAlloc;
    }
    return dst;
}
func generateBytecodeExprPathAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, needsPtr: bool) -> RegIndex {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else if (isUnion(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else {
        unreachable("generateBytecodeExprModuleAccess: Unexpected type of LHS");
    }
}

func generateBytecodeExprMemberAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, needsPtr: bool) -> RegIndex {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    }
    assert(isVariadicType(instance)
        || isStruct(instance)
        || isStructPointer(instance)
        || isTuple(instance)
        || isTuplePointer(instance), "Expected (ptr to) struct or tuple in MemberAccess");
    let _needsPtr = !isStructPointer(instance) && !isTuplePointer(instance);
    let result: RegIndex = generateBytecodeExpr(this, function, lhs, _needsPtr);
    let index: usize = 1;
    let fieldType: &Type = null;
    if (isVariadicType(instance)) {
        let name: Token = blank;
        match (rhs.data) {
            ExprData::Ident(ident) => { name = ident.name; }
            _ => { unreachable("Expected Identifier as RHS of member access"); }
        }
        assert(equals(&name.content, &comptime newSubStrOfStrLit("length")), "not length");
        fieldType = wrap(Type::Prim(PrimType::Usize));
        index = 1;
    } else {
        let _t: &Type = getRegister(function, result).typ;
        if (isStruct(_t) || isStructPointer(_t)) {
            if (!isStructPointer(_t)) {
                let t1: &Type = intoPointer(_t);
                let alloca: RegIndex = allocateRegister(function, t1);
                buildAlloca(function, lhs.span, alloca, getSizeInBytes(_t));
                buildStore(function, lhs.span, alloca, result);
                result = alloca;
                _t = t1;
            }
            let decl: &ParsedStructDecl = null;
            match (_t) {
                &Type::Ptr(&Type::Struct(_decl)) => { decl = _decl; }
                _ => { unreachable("Expected ptr to struct in Field Access"); }
            }
            // `result` contains a pointer to a struct instance at this point
            let name: Token = blank;
            match (rhs.data) {
                ExprData::Ident(ident) => { name = ident.name; }
                _ => { unreachable("Expected Identifier as RHS of member access"); }
            }
            index = getFieldIndex(decl, &name.content);
            let _f: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, index);
            fieldType = getType(&_f.typeState);
        } else if (isTuple(_t) || isTuplePointer(_t)) {
            if (!isTuplePointer(_t)) {
                let t1: &Type = intoPointer(_t);
                let alloca: RegIndex = allocateRegister(function, t1);
                buildAlloca(function, lhs.span, alloca, getSizeInBytes(_t));
                buildStore(function, lhs.span, alloca, result);
                result = alloca;
                _t = t1;
            }
            let ExprData::IntLit(tkn) = rhs.data else {
                unreachable("Expected Number as RHS of member access");
            };
            index = toU64(&tkn.content) as usize;
            let &Type::Ptr(&Type::Tuple(tElems)) = _t else {
                unreachable("Not tuple");
            };
            fieldType = tElems.elements[index];
        }
    }
    let fieldPtr = allocateRegister(function, intoPointer(fieldType));
    buildGetFieldPtr(function, lhs.span, fieldPtr, result, index);
    if (needsPtr) {
        return fieldPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, fieldType);
        buildLoad(function, lhs.span, dst, fieldPtr);
        return dst;
    }
}

func prepareReturnValue(this: &IRGen, span: Span, function: &IRFunc, base: RegIndex, args: RegIndexList, retType: &Type, retPtr: RegIndex, needsPtr: bool) -> RegIndex {
    let retVal: RegIndex = blank;
    if (getSizeInBytes(retType) > 8) {
        let reg: RegIndex = allocateRegister(function, retType);
        buildCall(function, span, retPtr, base, args);
        if (needsPtr) {
            retVal = retPtr;
        } else {
            buildLoad(function, span, reg, retPtr);
            retVal = reg;
        }
    } else {
        if (isStruct(retType)) {
            let reg: RegIndex = getRegisterForSize(this, function, getSizeInBytes(retType));
            buildCall(function, span, reg, base, args);
            let v: RegIndex = allocateRegister(function, retType);
            let t: &Type = getRegister(function, v).typ;
            let r: RegIndex = allocateRegister(function, intoPointer(t));
            let s: usize = getSizeInBytes(t);
            assert(s <= 8);
            buildAlloca(function, span, r, s);
            buildStore(function, span, r, reg);
            if (needsPtr) {
                retVal = r;
            } else {
                buildLoad(function, span, v, r);
                retVal = v;
            }
        } else {
            let reg: RegIndex = allocateRegister(function, retType);
            buildCall(function, span, reg, base, args);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(retType));
                buildAlloca(function, span, tempAlloc, getSizeInBytes(retType));
                buildStore(function, span, tempAlloc, reg);
                retVal = tempAlloc;
            } else {
                retVal = reg;
            }
        }
    }
    let ft: &Type = getRegister(function, base).typ;
    if (isPointer(ft)) ft = getUnderlyingType(ft, true);
    assert(isFunction(ft), "IRGen: Base is not a function");
    if (isNoreturn(ft)) {
        buildUnreachable(function, span);
    }
    return retVal;
}

func generateImplicitCall(this: &IRGen, function: &IRFunc, span: Span, funcID: usize, retType: &Type, args: RegIndexList) -> RegIndex {
    let reg: RegIndex = allocateRegister(function, retType);
    {
        let ft = wrap(Type::Func(blank, retType, FuncAttr {
            isVariadic: true // REVIEW: Why?
        }));
        let dst = allocateRegister(function, ft);
        buildLoadFunctionPtr(function, span, dst, funcID);
        buildCall(function, span, reg, dst, args);
    }
    return reg;
}

func generateBytecodeExprIndexedAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsType: &Type = getType(&lhs.typeState);
    assert(isVariadicType(lhsType) || isArray(lhsType) || isPointer(lhsType), "Expected Array, Ptr or VarArg as LHS in IndexedAccess");
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, !isPointer(lhsType));
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isPointer(getRegister(function, lhsReg).typ), "Expected Ptr as LHS in IndexedAccess");
    assert(isInteger(getRegister(function, rhsReg).typ), "Expected Int as RHS in IndexedAccess");
    let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
    let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
    if (isArray(lhsType) && !*flags.opt) {
        // if (index >= size) panic("Index out of bounds");
        let arrType: &Type = getType(&lhs.typeState);
        let elemCount: usize = getSizeInBytes(arrType) / getSizeInBytes(type);
        let cond: RegIndex = allocateRegister(function, boolType);
        let size: RegIndex = allocateRegister(function, usizeType);
        let panic: IRBlockID = appendBlock(function);
        let normal: IRBlockID = appendBlock(function);
        buildLoadInteger(function, lhs.span, size, usizeType, elemCount);
        buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GTE, cond, rhsReg, size);
        buildCondBr(function, lhs.span, cond, panic, normal);

        setCurrentBlock(function, panic);
        let err: RegIndex = allocateRegister(function, wrap(Type::Ptr(wrap(Type::Prim(PrimType::Char)))));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&lhs.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": RUNTIME ERROR: Index out of bounds: Array of size ");
        pushNumber(&s, elemCount);
        pushStr(&s, " has no index %d\n");
        drop(&_s);
        buildLoadString(function, lhs.span, err, asSubStr(&s));
        let funcID = getFunctionByMangledName(this, "index_oobPci64rN", "prelude.bufo");
        let args: RegIndexList = blank;
        push(&args, err);
        push(&args, rhsReg);
        generateImplicitCall(this, function, lhs.span, funcID, wrap(Type::Prim(PrimType::None)), args);
        buildUnreachable(function, lhs.span);
        setCurrentBlock(function, normal);
    }
    let elemPtr: RegIndex = allocateRegister(function, intoPointer(type));
    let indices: RegIndexList = blank;
    if (isArray(lhsType)) {
        let index: RegIndex = allocateRegister(function, usizeType);
        buildLoadInteger(function, lhs.span, index, usizeType, 0);
        push(&indices, index);
    }
    if (isVariadicType(lhsType)) {
        // lhsReg contains *{ *[...], len }
        // GetFieldPtr => **[...]
        // Load => *[...]
        // GetElementPtr[0, index] => Deref Load, Index into Array
        let ptr: RegIndex = allocateRegister(function, intoPointer(getUnderlyingType(lhsType, false)));
        buildGetFieldPtr(function, lhs.span, ptr, lhsReg, 0);
        buildLoad(function, lhs.span, ptr, ptr);
        push(&indices, rhsReg);
        buildGetElementPtr(function, lhs.span, elemPtr, ptr, indices);
    } else {
        push(&indices, rhsReg);
        buildGetElementPtr(function, lhs.span, elemPtr, lhsReg, indices);
    }
    if (needsPtr) {
        return elemPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, type);
        buildLoad(function, lhs.span, dst, elemPtr);
        return dst;
    }
}

func addParameter(this: &IRGen, function: &IRFunc, span: Span, scope: &IRScope, name: SubStr, reg: RegIndex, index: usize, isComptime: bool) {
    addEntry(scope, name, reg, isComptime);
    if (*flags.debug) {
        buildDebugInfoParam(function, span, reg, index, name);
    }
}
func addVariable(this: &IRGen, function: &IRFunc, span: Span, scope: &IRScope, name: SubStr, reg: RegIndex, isComptime: bool) {
    addEntry(scope, name, reg, isComptime);
    if (*flags.debug) {
        buildDebugInfoAlloca(function, span, reg, name);
    }
}

func generateBytecodeExprIdentifier(this: &IRGen, function: &IRFunc, expr: &IdentExpr, needsPtr: bool) -> RegIndex {
    let isGlobal: bool = false;
    let type = expr.type;
    assert(type != null, "IRGen: IdentExpr has unset type!");
    let entry: &IRScopeEntry = getIdentifierByName(this, function, expr.name.content, &isGlobal);
    if (entry != null) {
        if (function.comptimeLevel > 0 && !entry.isComptime) {
            unreachable("Crossing the boundary: comptime IR needs runtime value - The Checker should've caught this");
        }
        if (needsPtr) {
            if (isGlobal) {
                let ptrType: &Type = intoPointer(type);
                let global: RegIndex = allocateRegister(function, ptrType);
                if (entry.isComptime) {
                    let val: RegIndex = allocateRegister(function, type);
                    buildAlloca(function, expr.name.span, global, getSizeInBytes(type));
                    buildFetchGlobalComptimeValue(function, expr.name.span, val, entry.ptr);
                    buildStore(function, expr.name.span, global, val);
                } else {
                    buildFetchGlobalPointer(function, expr.name.span, global, entry.ptr);
                }
                return global;
            } else {
                if (entry.isComptime) {
                    let ptrType: &Type = intoPointer(type);
                    let global: RegIndex = allocateRegister(function, ptrType);
                    let val: RegIndex = allocateRegister(function, type);
                    buildAlloca(function, expr.name.span, global, getSizeInBytes(type));
                    buildFetchLocalComptimeValue(function, expr.name.span, val, entry.ptr);
                    buildStore(function, expr.name.span, global, val);
                    return global;
                } else {
                    return entry.ptr;
                }
            }
        } else {
            let val: RegIndex = allocateRegister(function, type);
            if (isGlobal) {
                if (entry.isComptime) {
                    buildFetchGlobalComptimeValue(function, expr.name.span, val, entry.ptr);
                } else {
                    buildFetchGlobalRuntimeValue(function, expr.name.span, val, entry.ptr);
                }
            } else {
                if (entry.isComptime) {
                    buildFetchLocalComptimeValue(function, expr.name.span, val, entry.ptr);
                } else {
                    buildLoad(function, expr.name.span, val, entry.ptr);
                }
            }
            return val;
        }
    } else {
        if (isModule(type)) {
            return allocateRegister(function, type);
        } else if (isFunction(type)) {
            let name: String = getMangledName(at(&funcDecls, expr.origID));
            if (*flags.opt) {
                // When --opt is provided, we replace all assertions with empty function calls
                if (equals(&name, &comptime newReadonlyString("assertBPcrN"))) {
                    name = newStringFromStrLit("_empty_assertBPcrN");
                } else if (equals(&name, &comptime newReadonlyString("assertBrN"))) {
                    name = newStringFromStrLit("_empty_assertBrN");
                }
            }
            let funcID: usize = getFunctionByName(this, &name);
            let dst = allocateRegister(function, type);
            buildLoadFunctionPtr(function, expr.name.span, dst, funcID);
            return dst;
        } else {
            unreachable("Exhaustive handling of types in generateBytecodeExprIdentifier");
        }
    }
}

func generateBytecodeExprArithmetic(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    assert(isArithmetic(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsType: &Type = getType(&lhs.typeState);
    let rhsType: &Type = getType(&rhs.typeState);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    // OPT: Specialized 8bit, 16bit, etc. variations
    match (expr) {
        &BinaryExpr::Plus(_,_) => {
            if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
            } else if (isPointer(lhsType) && isInteger(rhsType)) {
                assert(isPointer(type), "PTR + INT expected to be PTR");
                buildPtrToInt(function, lhs.span, lhsReg, lhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
                buildIntToPtr(function, lhs.span, dst, dst);
            } else if (isInteger(lhsType) && isPointer(rhsType)) {
                assert(isPointer(type), "INT + PTR expected to be PTR");
                buildPtrToInt(function, lhs.span, rhsReg, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
                buildIntToPtr(function, lhs.span, dst, dst);
            } else if (isFloat(lhsType) && isFloat(rhsType)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_ADD, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_PLUS");
            }
        }
        &BinaryExpr::Sub(_,_) => {
            let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
            if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, dst, lhsReg, rhsReg);
            } else if (isPointer(lhsType) && isInteger(rhsType)) {
                assert(isPointer(type), "PTR - INT expected to be PTR");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, lhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, tmp2, tmp1, rhsReg);
                buildIntToPtr(function, lhs.span, dst, tmp2);
            } else if (isInteger(lhsType) && isPointer(rhsType)) {
                assert(isPointer(type), "INT - PTR expected to be PTR");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, tmp2, lhsReg, tmp1);
                buildIntToPtr(function, lhs.span, dst, tmp2);
            } else if (isPointer(lhsType) && isPointer(rhsType)) {
                assert(isInteger(type), "PTR - PTR expected to be INT");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, lhsReg);
                buildPtrToInt(function, lhs.span, tmp2, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, dst, tmp1, tmp2);
            } else if (isFloat(lhsType) && isFloat(rhsType)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_SUB, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_SUB");
            }
        }
        &BinaryExpr::Mult(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_MUL, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_MUL, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_MULT");
            }
        }
        &BinaryExpr::Div(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_DIV, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_DIV, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_DIV");
            }
        }
        &BinaryExpr::Mod(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_MOD, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_MOD, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_MOD");
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprArithmetic"); }
    }
    if (needsPtr) {
        let subType: &Type = intoPointer(type);
        let ptr: RegIndex = allocateRegister(function, subType);
        buildAlloca(function, lhs.span, ptr, getSizeInBytes(type));
        buildStore(function, lhs.span, ptr, dst);
        return ptr;
    } else {
        return dst;
    }
}

func generateBytecodeExprComparison(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    assert(isComparison(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isBoolean(type), "Comparison expected to evaluate to Bool");
    let dst: RegIndex = allocateRegister(function, type);
    // OPT: Specialized 8bit, 16bit, etc. variations
    let t: &Type = getRegister(function, lhsReg).typ;
    match (expr) {
        &BinaryExpr::CmpEq(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_EQ, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_EQ, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_EQ");
            }
        }
        &BinaryExpr::CmpNeq(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_NEQ, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_NEQ, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_NEQ");
            }
        }
        &BinaryExpr::CmpGt(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GT, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_GT, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GT");
            }
        }
        &BinaryExpr::CmpGte(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GTE, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_GTE, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GTE");
            }
        }
        &BinaryExpr::CmpLt(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_LT, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_LT, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LT");
            }
        }
        &BinaryExpr::CmpLte(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_LTE, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_LTE, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LTE");
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprComparison"); }
    }
    return dst;
}

func generateBytecodeExprLogical(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    assert(isLogical(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    match (expr) {
        &BinaryExpr::LogAnd(_,_) => { buildBinaryOp(function, lhs.span, INSTR_LOGICAL_AND, dst, lhsReg, rhsReg); }
        &BinaryExpr::LogOr(_,_)  => { buildBinaryOp(function, lhs.span, INSTR_LOGICAL_OR, dst, lhsReg, rhsReg); }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprLogical"); }
    }
    return dst;
}

func generateBytecodeExprBitwise(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    assert(isBitwise(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    match (expr) {
        &BinaryExpr::BitAnd(_,_) => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_AND, dst, lhsReg, rhsReg); }
        &BinaryExpr::BitOr(_,_)  => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_OR, dst, lhsReg, rhsReg); }
        &BinaryExpr::BitXor(_,_) => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_XOR, dst, lhsReg, rhsReg); }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprBitwise"); }
    }
    return dst;
}

func loadLiteral(this: &IRGen, function: &IRFunc, reg: RegIndex, tkn: &Token) -> RegIndex {
    let typ = getRegister(function, reg).typ;
    if (isInteger(typ) || isChar(typ)) {
        let _value: u64 = toU64(&tkn.content);
        let value: usize = _value as usize;
        let size: usize = bitCount(value);
        let typsize: usize = getSizeInBits(typ);
        if (isSignedInteger(typ)) size = size + 1;
        if (size > typsize) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            C::fprintf(stderr, "%s: %s: Integer literal (value=%llu) is too big for target type %s.\n",
                loc.buffer, ERR_STR, _value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        buildLoadInteger(function, tkn.span, reg, typ, value);
    } else if (isFloat(typ)) {
        let value: f64 = toF64(&tkn.content);
        assert(value >= 0, "Expected FloatLit value to be positive");
        let typmax: f64 = getMaxFloatValue(typ);
        if (value >= typmax) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            C::fprintf(stderr, "%s: %s: Float literal (value=%f) is too big for target type %s.\n",
                loc.buffer, ERR_STR, value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        if (getSizeInBytes(typ) == 4) buildLoadF32(function, tkn.span, reg, value as f32);
        else if (getSizeInBytes(typ) == 8) buildLoadF64(function, tkn.span, reg, value);
        else unreachable("load float");
    } else {
        unreachable("loadLiteral: Expected Integer, Char or Float");
    }
    return reg;
}

func generateBytecodeExprLiteral(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    assert(isLiteral(expr));
    let t: &Type = getType(&expr.typeState);
    let reg: RegIndex = allocateRegister(function, t);
    match (&expr.data) {
        &ExprData::IntLit(value)  => { loadLiteral(this, function, reg, &value); }
        &ExprData::StrLit(value)  => { buildLoadString(function, expr.span, reg, value.content); }
        &ExprData::True           => { buildLoadBool(function, expr.span, reg, 1); }
        &ExprData::False          => { buildLoadBool(function, expr.span, reg, 0); }
        &ExprData::Null           => { buildLoadNull(function, expr.span, reg); }
        &ExprData::CharLit(value) => { buildLoadInteger(function, expr.span, reg, t, value.content.start[0] as usize); }
        &ExprData::ArrayLit(context) => {
            assert(isArray(t), "ArrayLit expected to be array");
            if (getSizeInBytes(t) > 4096) warning("Array Literal is big and slows down the IR");
            if (context.size == 0) {
                if (getSizeInBytes(t) == 0 && *flags.warnSimple) {
                    // array literal of the form []
                    let loc = toString(&expr.span);
                    C::fprintf(stderr, "%s: %s: Array is zero-sized and can never be indexed into.\n", loc.buffer, WARN_STR);
                    drop(&loc);
                }
                buildCreateArray(function, expr.span, reg);
                for (let i: usize = 0; i < context.elemLength; i = i + 1) {
                    let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&context, i));
                    let result: RegIndex = generateBytecodeExpr(this, function, elem, false);
                    buildInsertValue(function, expr.span, reg, i, result);
                }
                if (needsPtr) {
                    let subType: &Type = intoPointer(t);
                    let ptr: RegIndex = allocateRegister(function, subType);
                    buildAlloca(function, expr.span, ptr, getSizeInBytes(t));
                    buildStore(function, expr.span, ptr, reg);
                    return ptr;
                } else {
                    return reg;
                }
            } else {
                let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&context, 0));
                let value: RegIndex = generateBytecodeExpr(this, function, elem, false);
                let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
                let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
                let elemType: &Type = getType(&elem.typeState);
                let arrayPtr: RegIndex = allocateRegister(function, intoPointer(t));
                let zero: RegIndex = allocateRegister(function, usizeType);
                let one: RegIndex = allocateRegister(function, usizeType);
                let index: RegIndex = allocateRegister(function, usizeType);
                let indexPtr: RegIndex = allocateRegister(function, intoPointer(usizeType));
                let size: RegIndex = allocateRegister(function, usizeType);
                let cond: RegIndex = allocateRegister(function, boolType);
                let elemPtr: RegIndex = allocateRegister(function, intoPointer(elemType));

                let start: IRBlockID = appendBlock(function);
                let body: IRBlockID = appendBlock(function);
                let end: IRBlockID = appendBlock(function);

                buildAlloca(function, expr.span, arrayPtr, getSizeInBytes(t));
                buildAlloca(function, expr.span, indexPtr, getSizeInBytes(usizeType));
                buildLoadInteger(function, expr.span, zero, usizeType, 0);
                buildLoadInteger(function, expr.span, one, usizeType, 1);
                buildStore(function, expr.span, indexPtr, zero);
                buildLoadInteger(function, expr.span, size, usizeType, context.size);
                buildBr(function, expr.span, start);

                setCurrentBlock(function, start);
                buildLoad(function, expr.span, index, indexPtr);
                buildBinaryOp(function, expr.span, INSTR_INT_CMP_LT, cond, index, size);
                buildCondBr(function, expr.span, cond, body, end);

                setCurrentBlock(function, body);
                let indices: RegIndexList = blank;
                push(&indices, zero);
                push(&indices, index);
                buildGetElementPtr(function, expr.span, elemPtr, arrayPtr, indices);
                buildStore(function, expr.span, elemPtr, value);

                buildLoad(function, expr.span, index, indexPtr);
                buildBinaryOp(function, expr.span, INSTR_INT_ADD, index, index, one);
                buildStore(function, expr.span, indexPtr, index);
                buildBr(function, expr.span, start);

                setCurrentBlock(function, end);
                if (needsPtr) {
                    return arrayPtr;
                } else {
                    buildLoad(function, expr.span, reg, arrayPtr);
                    return reg;
                }
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprLiteral"); }
    }
    if (needsPtr) {
        let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
        buildAlloca(function, expr.span, tempAlloc, getSizeInBytes(t));
        buildStore(function, expr.span, tempAlloc, reg);
        return tempAlloc;
    }
    return reg;
}

func generateBytecodeExprAssignment(this: &IRGen, function: &IRFunc, expr: &BinaryExpr) -> RegIndex {
    assert(isAssignment(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, true);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isPointer(getRegister(function, lhsReg).typ), "Assignment expected Ptr as LHS");
    buildStore(function, lhs.span, lhsReg, rhsReg);
    return rhsReg;
}

func generateBytecodeExprUnary(this: &IRGen, function: &IRFunc, span: Span, expr: &UnaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    match (expr) {
        &UnaryExpr::Comptime(subExpr) => {
            startComptime(function);
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let r: RegIndex = allocateRegister(function, type);
            endComptime(function);
            buildFetchLocalComptimeValue(function, span, r, result);
            if (needsPtr) {
                let subType: &Type = intoPointer(type);
                let ptr: RegIndex = allocateRegister(function, subType);
                buildAlloca(function, span, ptr, getSizeInBytes(type));
                buildStore(function, span, ptr, r);
                return ptr;
            } else {
                return r;
            }
        }
        &UnaryExpr::Deref(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let ptr: &IRReg = getRegister(function, result);
            assert(isPointer(ptr.typ), "Expected Ptr SubExpr in Unary Deref");
            if (needsPtr) {
                return result;
            } else {
                let val: RegIndex = allocateRegister(function, type);
                buildLoad(function, span, val, result);
                return val;
            }
        }
        &UnaryExpr::Ref(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, true);
            let ptrReg: &IRReg = getRegister(function, result);
            if (needsPtr || !isPointer(ptrReg.typ)) {
                let subType: &Type = intoPointer(ptrReg.typ);
                let ptr: RegIndex = allocateRegister(function, subType);
                buildAlloca(function, span, ptr, getSizeInBytes(ptrReg.typ));
                buildStore(function, span, ptr, result);
                return ptr;
            } else {
                return result;
            }
        }
        &UnaryExpr::Not(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let r: RegIndex = allocateRegister(function, type);
            buildLogicalNot(function, span, r, result);
            return r;
        }
        &UnaryExpr::Negate(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            if (isInteger(type)) {
                let zero: RegIndex = allocateRegister(function, type);
                buildLoadInteger(function, span, zero, type, 0);
                buildBinaryOp(function, span, INSTR_INT_SUB, result, zero, result);
            } else if (isFloat(type)) {
                let zero: RegIndex = allocateRegister(function, type);
                if (getSizeInBytes(type) == 4) buildLoadF32(function, span, zero, 0);
                else if (getSizeInBytes(type) == 8) buildLoadF64(function, span, zero, 0);
                else unreachable("negation float");
                buildBinaryOp(function, span, INSTR_FLOAT_SUB, result, zero, result);
            } else {
                unreachable("Exhaustive handling of negation variants in generateBytecodeExprUnary");
            }
            return result;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of ops in generateBytecodeExprUnary");
}

func prepareParameter(this: &IRGen, function: &IRFunc, index: usize, span: Span, name: SubStr, typ: &Type, retValue: bool) {
    let storeOnStack = false;

    if(equals(flags.target, &OS_LINUX)) {
        storeOnStack = (isComposite(typ) && getSizeInBytes(typ) > 2*8) || getSizeInBytes(typ) > 8;
    } else if(equals(flags.target, &OS_WINDOWS)) {
        storeOnStack = getSizeInBytes(typ) > 8;
    } else unreachable("OS ABI");

    if (storeOnStack) {
        let t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        let value: RegIndex = allocateRegister(function, t);
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        buildGetParam(function, span, value, index, getSizeInBytes(t));
        let instance: RegIndex = allocateRegister(function, typ);
        buildLoad(function, span, instance, value);

        buildAlloca(function, span, allocReg, getSizeInBytes(typ));
        buildStore(function, span, allocReg, instance);
        addParameter(this, function, span, last(&function.scopes), name, allocReg, index, false);
    } else if (isComposite(typ)) {
        let size = getSizeInBytes(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        //} else if (equals(flags.target, &OS_LINUX) && size <= 2*8) {
        //    t = intoPointer(typ);
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        let value: RegIndex = allocateRegister(function, t);
        buildGetParam(function, span, value, index, getSizeInBytes(t));
        // value contains prepared struct
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        if (isPointer(t)) {
            let instance: RegIndex = allocateRegister(function, typ);
            buildLoad(function, span, instance, value);

            buildAlloca(function, span, allocReg, getSizeInBytes(typ));
            buildStore(function, span, allocReg, instance);
            addParameter(this, function, span, last(&function.scopes), name, allocReg, index, false);
        } else {
            buildAlloca(function, span, allocReg, getSizeInBytes(typ));
            buildStore(function, span, allocReg, value);
            addParameter(this, function, span, last(&function.scopes), name, allocReg, index, false);
        }
    } else {
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        let value: RegIndex = allocateRegister(function, typ);
        buildGetParam(function, span, value, index, getSizeInBytes(typ));

        if (retValue) {
            assert(index == 0);
            (*function).retPtr = value;
        } else {
            buildAlloca(function, span, allocReg, getSizeInBytes(typ));
            buildStore(function, span, allocReg, value);
            addParameter(this, function, span, last(&function.scopes), name, allocReg, index, false);
        }
    }
}

func getRegisterForSize(this: &IRGen, function: &IRFunc, size: usize) -> RegIndex {
    let v: RegIndex = blank;
    if (size <= 1) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U8)));
    } else if (size <= 2) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U16)));
    } else if (size <= 4) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U32)));
    } else if (size <= 8) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U64)));
    } else {
        if(equals(flags.target, &OS_LINUX)) {
            todo_with_msg("LINUX: getRegisterForSize called with size > 8");
            /* this is needed for SysV ABI structs that are <= 2*8 bytes in size */
            if(size <= 2*8) v = allocateRegister(function, wrap(Type::Array(wrap(Type::Prim(PrimType::U8)), size)));
            else unreachable("getRegisterForSize called with size > 8");
        } else if(equals(flags.target, &OS_WINDOWS)) {
            unreachable("getRegisterForSize called with size > 8");
        } else { unreachable("getRegisterForSize: unknown target"); }
    }
    return v;
}

@os(LINUX) func splitStructIntoRegs(typ: &Type) -> (usize, usize) {
    assert(isComposite(typ), "LINUX: splitStructIntoRegs called on non-composite");
    let size: usize = getSizeInBytes(typ);
    assert(size <= 2*8, "LINUX: splitStructIntoRegs called on too big struct");
    if(size <= 8) return (size, 0);
    else return (8 as usize, size - 8);
}

func prepareArgument(this: &IRGen, function: &IRFunc, span: Span, value: RegIndex, typ: &Type) -> RegIndex {
    if(equals(flags.target, &OS_LINUX)) {
        if(isComposite(typ)) {
            /* break up into 1 or 2 regs and use those */
            let size = getSizeInBytes(typ);

            let alloc: RegIndex = allocateRegister(function, intoPointer(typ));
            buildAlloca(function, span, alloc, size);
            buildStore(function, span, alloc, value);
            if (size > 2*8) return alloc; /* if it's bigger than two pointers, pass as pointer */

            let (a, b) = splitStructIntoRegs(typ);
            if(b != 0) {
                if(*flags.verbose) C::printf("%s: %s: TODO[Linux]: use multiple regs for small structs\n", toString(&span).buffer, NOTE_STR);
                return alloc;
            }

            let v: RegIndex = getRegisterForSize(this, function, a);
            buildLoad(function, span, v, alloc);
            return v;

            //return value;
        } else {
            if(getSizeInBytes(typ) > 8) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(typ));
                buildAlloca(function, span, tempAlloc, getSizeInBytes(typ));
                buildStore(function, span, tempAlloc, value);
                return tempAlloc;
            } else return value;
        }
    } else if(equals(flags.target, &OS_WINDOWS)) {
        if (getSizeInBytes(typ) > 8) {
            // Following the ABI, all parameters that don't fit in a register get passed by pointer
            let tempAlloc: RegIndex = allocateRegister(function, intoPointer(typ));
            buildAlloca(function, span, tempAlloc, getSizeInBytes(typ));
            buildStore(function, span, tempAlloc, value);
            return tempAlloc;
        } else if (isComposite(typ)) {
            // if(equals(flags.target, &OS_LINUX)) todo_with_msg("move structure for penger machine");
            let size: usize = getSizeInBytes(typ);
            let alloc: RegIndex = allocateRegister(function, intoPointer(typ));
            buildAlloca(function, span, alloc, size);
            buildStore(function, span, alloc, value);
            if (size > 8) return alloc;
            let v: RegIndex = getRegisterForSize(this, function, size);
            buildLoad(function, span, v, alloc);
            return v;
        } else {
            return value;
        }
    } else { unreachable("prepareArgument ABI"); }
}

func generateBytecodeExprCall(this: &IRGen, function: &IRFunc, expr: &CallExpr, needsPtr: bool) -> RegIndex {
    let base = generateBytecodeExpr(this, function, expr.base, false);
    let typ: &Type = expr.retType;
    assert(typ != null, "IRGen: CallExpr has invalid return type");
    let args: RegIndexList = blank;
    let retPtr: RegIndex = blank;
    if (getSizeInBytes(typ) > 8) {
        retPtr = allocateRegister(function, intoPointer(typ));
        buildAlloca(function, expr.span, retPtr, getSizeInBytes(typ));
        push(&args, retPtr);
    }
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let arg: &ParsedExpr = *at(&expr.args, i);
        let argType: &Type = getType(&arg.typeState);
        let result: RegIndex = generateBytecodeExpr(this, function, arg, false);
        push(&args, prepareArgument(this, function, arg.span, result, argType));
    }
    return prepareReturnValue(this, expr.span, function, base, args, typ, retPtr, needsPtr);
}

func newIRGenerator(lookup: &Lookup) -> IRGen {
    return IRGen {
        globalScope: IRFunc {
            name: newStringFromStrLit("__global__"),
            originalID: funcDecls.length + 1,
            comptimeLevel: 0,
        },
        lookup: lookup
    };
}
