import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/hashmaps.bufo";
import "../util/lists.bufo";
import "../util/arena.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../frontend/lexer.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./LLVM/values.bufo";

struct RegIndex {
    i: usize;
}
func equals(this: &RegIndex, other: &RegIndex) -> bool {
    return this.i == other.i;
}

struct IRReg {
    isComptime: bool;
    offset: usize;
    typ: &Type;
}
func equals(this: &IRReg, other: &IRReg) -> bool {
    unreachable("IRReg.equals is not implemented yet");
}

// NOTE: When you update this list, you must also update the function pointers in the interpreter
comptime INSTR_INVALID: usize = 0;
comptime INSTR_ALLOCA: usize = 1;
comptime INSTR_GET_PARAM: usize = 2;
comptime INSTR_STORE: usize = 3;
comptime INSTR_FETCH_GLOBAL_PTR: usize = 4;
comptime INSTR_FETCH_GLOBAL_VALUE: usize = 5;
comptime INSTR_FETCH_COMPTIME_VALUE: usize = 6;
comptime INSTR_LOAD_FUNCTION_PTR: usize = 7;
comptime INSTR_LOAD: usize = 8;
comptime INSTR_MOVE: usize = 9;
comptime INSTR_CALL: usize = 10;
comptime INSTR_RETURN_EXPR: usize = 11;
comptime INSTR_RETURN_VOID: usize = 12;
comptime INSTR_LOAD_STRING: usize = 13;
comptime INSTR_LOAD_BOOL: usize = 14;
comptime INSTR_LOAD_I8: usize = 15;
comptime INSTR_LOAD_U8: usize = 16;
comptime INSTR_LOAD_I16: usize = 17;
comptime INSTR_LOAD_U16: usize = 18;
comptime INSTR_LOAD_I32: usize = 19;
comptime INSTR_LOAD_U32: usize = 20;
comptime INSTR_LOAD_I64: usize = 21;
comptime INSTR_LOAD_U64: usize = 22;
comptime INSTR_LOAD_NULL: usize = 23;
comptime INSTR_LOAD_F32: usize = 24;
comptime INSTR_LOAD_F64: usize = 25;
comptime INSTR_LOAD_BLANK: usize = 26;
comptime INSTR_COND_BR: usize = 27;
comptime INSTR_BR: usize = 28;
comptime INSTR_INT_ADD: usize = 29;
comptime INSTR_INT_SUB: usize = 30;
comptime INSTR_INT_MUL: usize = 31;
comptime INSTR_INT_DIV: usize = 32;
comptime INSTR_INT_MOD: usize = 33;
comptime INSTR_INT_CMP_EQ: usize = 34;
comptime INSTR_INT_CMP_NEQ: usize = 35;
comptime INSTR_INT_CMP_GT: usize = 36;
comptime INSTR_INT_CMP_GTE: usize = 37;
comptime INSTR_INT_CMP_LT: usize = 38;
comptime INSTR_INT_CMP_LTE: usize = 39;
comptime INSTR_FLOAT_ADD: usize = 40;
comptime INSTR_FLOAT_SUB: usize = 41;
comptime INSTR_FLOAT_MUL: usize = 42;
comptime INSTR_FLOAT_DIV: usize = 43;
comptime INSTR_FLOAT_MOD: usize = 44;
comptime INSTR_FLOAT_CMP_EQ: usize = 45;
comptime INSTR_FLOAT_CMP_NEQ: usize = 46;
comptime INSTR_FLOAT_CMP_GT: usize = 47;
comptime INSTR_FLOAT_CMP_GTE: usize = 48;
comptime INSTR_FLOAT_CMP_LT: usize = 49;
comptime INSTR_FLOAT_CMP_LTE: usize = 50;
comptime INSTR_LOGICAL_NOT: usize = 51;
comptime INSTR_LOGICAL_AND: usize = 52;
comptime INSTR_LOGICAL_OR: usize = 53;
comptime INSTR_BITWISE_AND: usize = 54;
comptime INSTR_BITWISE_OR: usize = 55;
comptime INSTR_BITWISE_XOR: usize = 56;
comptime INSTR_INSERT_VALUE: usize = 57;
comptime INSTR_INT_SIGN_EXTEND: usize = 58;
comptime INSTR_INT_ZERO_EXTEND: usize = 59;
comptime INSTR_INT_TRUNCATE: usize = 60;
comptime INSTR_INT_TO_F32: usize = 61;
comptime INSTR_INT_TO_F64: usize = 62;
comptime INSTR_F32_TO_INT: usize = 63;
comptime INSTR_F64_TO_INT: usize = 64;
comptime INSTR_F32_TO_F64: usize = 65;
comptime INSTR_F64_TO_F32: usize = 66;
comptime INSTR_CREATE_ARRAY: usize = 67;
comptime INSTR_CREATE_STRUCT: usize = 68;
comptime INSTR_CREATE_UNION: usize = 69;
comptime INSTR_PTR_TO_INT: usize = 70;
comptime INSTR_INT_TO_PTR: usize = 71;
comptime INSTR_GET_FIELD_PTR: usize = 72;
comptime INSTR_GET_ELEMENT_PTR: usize = 73;
comptime INSTR_UNREACHABLE: usize = 74;
comptime INSTR_UNTERMINATED: usize = 75;
comptime INSTR_MEMCPY: usize = 76;
struct IRInstr {
    kind: usize;
    span: Span;
    isComptime: bool;
    dst: RegIndex;
    src: RegIndex;
    op1: RegIndex;
    args: RegIndexList;
}
func equals(this: &IRInstr, other: &IRInstr) -> bool {
    unreachable("IRInstr.equals is not implemented yet");
}
func isTerminator(this: &IRInstr) -> bool {
    return this.kind == INSTR_RETURN_EXPR
        || this.kind == INSTR_RETURN_VOID
        || this.kind == INSTR_COND_BR
        || this.kind == INSTR_BR
        || this.kind == INSTR_UNREACHABLE
        || this.kind == INSTR_UNTERMINATED;
}
func dump(this: &IRInstr) {
    if (!*flags.emitBIR && this.isComptime) printf("\x1b[92m");
    if (PRINT_DEBUG) {
        let s = toString(&this.span);
        printf("%s ", s.buffer);
        drop(&s);
    }
    if (this.kind == INSTR_ALLOCA) printf("r%llu = Alloca %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_PARAM) printf("r%llu = GetParam %llu (%llu bytes)", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_STORE) printf("Store r%llu, r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_PTR) printf("r%llu = FetchGlobalPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_GLOBAL_VALUE) printf("r%llu = FetchGlobalValue r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_FETCH_COMPTIME_VALUE) printf("r%llu = FetchComptimeValue r%llu, global=%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD) printf("r%llu = Load r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_FUNCTION_PTR) printf("r%llu = LoadFunctionPtr %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_MOVE) printf("r%llu = Move r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CALL) {
        printf("r%llu = Call r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            printf(", r%llu", at(&this.args, i).i);
        }
    } else if (this.kind == INSTR_RETURN_EXPR) printf("RetExpr r%llu", this.src.i);
    else if (this.kind == INSTR_RETURN_VOID) printf("RetVoid");
    else if (this.kind == INSTR_LOAD_STRING) printf("r%llu = LoadString %p, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOAD_BOOL) printf("r%llu = Load Bool %hhu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I8) printf("r%llu = Load I8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U8) printf("r%llu = Load U8 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I16) printf("r%llu = Load I16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U16) printf("r%llu = Load U16 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I32) printf("r%llu = Load I32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U32) printf("r%llu = Load U32 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_I64) printf("r%llu = Load I64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_U64) printf("r%llu = Load U64 %llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOAD_NULL) printf("r%llu = Load Null", this.dst.i);
    else if (this.kind == INSTR_LOAD_F32) printf("r%llu = Load F32 %f", this.dst.i, *(&this.src.i as &f32) as f64);
    else if (this.kind == INSTR_LOAD_F64) printf("r%llu = Load F64 %f", this.dst.i, *(&this.src.i as &f64));
    else if (this.kind == INSTR_LOAD_BLANK) printf("r%llu = Load Blank", this.dst.i);
    else if (this.kind == INSTR_COND_BR) printf("CondBr r%llu, true=%llu, false=%llu", this.src.i, this.dst.i, this.op1.i);
    else if (this.kind == INSTR_BR) printf("Br %llu", this.dst.i);
    else if (this.kind == INSTR_INT_ADD) printf("r%llu = AddInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SUB) printf("r%llu = SubInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MUL) printf("r%llu = MulInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_DIV) printf("r%llu = DivInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_MOD) printf("r%llu = ModInt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_EQ) printf("r%llu = ICmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_NEQ) printf("r%llu = ICmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GT) printf("r%llu = ICmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_GTE) printf("r%llu = ICmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LT) printf("r%llu = ICmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_CMP_LTE) printf("r%llu = ICmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_ADD) printf("r%llu = AddFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_SUB) printf("r%llu = SubFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MUL) printf("r%llu = MulFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_DIV) printf("r%llu = DivFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_MOD) printf("r%llu = ModFloat r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_EQ) printf("r%llu = FCmpEq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_NEQ) printf("r%llu = FCmpNeq r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GT) printf("r%llu = FCmpGt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_GTE) printf("r%llu = FCmpGte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LT) printf("r%llu = FCmpLt r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_FLOAT_CMP_LTE) printf("r%llu = FCmpLte r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_NOT) printf("r%llu = LNot r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_LOGICAL_AND) printf("r%llu = LAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_LOGICAL_OR) printf("r%llu = LOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_AND) printf("r%llu = BAnd r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_OR) printf("r%llu = BOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_BITWISE_XOR) printf("r%llu = BXOr r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INSERT_VALUE) printf("r%llu = InsertValue r%llu, %llu, r%llu", this.dst.i, this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_SIGN_EXTEND) printf("r%llu = IntSExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_ZERO_EXTEND) printf("r%llu = IntZExt r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TRUNCATE) printf("r%llu = IntTrunc r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_INT_TO_F32) printf("r%llu = IntToF32 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_INT) printf("r%llu = F32ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_INT) printf("r%llu = F64ToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_F64) printf("r%llu = IntToF64 r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F32_TO_F64) printf("r%llu = FloatExt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_F64_TO_F32) printf("r%llu = FloatTrunc r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_CREATE_ARRAY) printf("r%llu = CreateArray", this.dst.i);
    else if (this.kind == INSTR_CREATE_STRUCT) printf("r%llu = CreateStruct", this.dst.i);
    else if (this.kind == INSTR_CREATE_UNION) printf("r%llu = CreateUnion", this.dst.i);
    else if (this.kind == INSTR_PTR_TO_INT) printf("r%llu = PtrToInt r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_INT_TO_PTR) printf("r%llu = IntToPtr r%llu", this.dst.i, this.src.i);
    else if (this.kind == INSTR_GET_FIELD_PTR) printf("r%llu = GetFieldPtr r%llu, %llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_UNREACHABLE) printf("unreachable");
    else if (this.kind == INSTR_UNTERMINATED) printf("<unterminated block>");
    else if (this.kind == INSTR_MEMCPY) printf("Memcpy r%llu, r%llu, r%llu", this.dst.i, this.src.i, this.op1.i);
    else if (this.kind == INSTR_GET_ELEMENT_PTR) {
        printf("r%llu = GetElementPtr r%llu", this.dst.i, this.src.i);
        for (let i: usize = 0; i < this.args.length; i = i + 1) {
            printf(", r%llu", at(&this.args, i).i);
        }
    } else {
        fprintf(stderr, "kind: %llu\n", this.kind);
        unreachable("Exhaustive handling in IRInstr.dump()");
    }
    if (!*flags.emitBIR && this.isComptime) printf("\x1b[0m\n"); else printf("\n");
}

struct LoopBlock {
    before: IRBlockID;
    after: IRBlockID;
}
func equals(this: &LoopBlock, other: &LoopBlock) -> bool {
    return this.before.i == other.before.i && this.after.i == other.after.i;
}

struct IRBlockID {
    i: usize;
}
struct IRBlock {
    parent: String;
    id: IRBlockID;
    instructions: IRInstrList;
}
func equals(this: &IRBlock, other: &IRBlock) -> bool {
    return equals(&this.parent, &other.parent) && this.id.i == other.id.i;
}
func isTerminated(this: &IRBlock) -> bool {
    trace("IRBlock.isTerminated");
    if (this.instructions.length == 0) return false;
    return isTerminator(last(&this.instructions));
}
func dump(this: &IRBlock) {
    printf("b%llu:\n", this.id);
    for (let i: usize = 0; i < this.instructions.length; i = i + 1) {
        printf("  %4d: ", i);
        dump(at(&this.instructions, i));
    }
}
func pushInstruction(this: &IRBlock, instr: IRInstr) {
    trace("IRBlock.pushInstruction");
    push(&this.instructions, instr);
}

struct IRFunc {
    originalID: usize;
    name: String;
    span: Span;
    comptimeLevel: usize;
    scopes: IRScopeList;
    registers: IRRegList;
    blocks: IRBlockList;
    loopBlocks: LoopBlockList;
    currentBlock: IRBlockID;
    llvmFunc: LLVMValue;
    retPtr: RegIndex;
    attrs: ParsedAttributeList;
    returnBlockID: IRBlockID;
    returnAlloc: RegIndex;
}
func hasAttribute(this: &IRFunc, attr: usize) -> bool {
    trace("IRFunc.hasAttribute");
    for (let i: usize = 0; i < this.attrs.length; i = i + 1) {
        if (at(&this.attrs, i).kind == attr) return true;
    }
    return false;
}
func isExtern(this: &IRFunc) -> bool {
    return isExtern(getFuncNode(this));
}
func appendBlock(this: &IRFunc) -> IRBlockID {
    let id: IRBlockID = IRBlockID { i: this.blocks.length };
    push(&this.blocks, IRBlock {
        parent: this.name,
        id: id,
    });
    return id;
}
func setCurrentBlock(this: &IRFunc, id: IRBlockID) {
    assert(id.i < this.blocks.length, "setCurrentBlock called with invalid ID");
    this.currentBlock = id;
}
func getCurrentBlock(this: &IRFunc) -> IRBlockID {
    assert(this.blocks.length > 0, "getCurrentBlock called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlock points to invalid block");
    return this.currentBlock;
}
func getCurrentBlockAsRef(this: &IRFunc) -> &IRBlock {
    assert(this.blocks.length > 0, "getCurrentBlockAsRef called on empty IRFunc");
    assert(this.currentBlock.i < this.blocks.length, "getCurrentBlockAsRef points to invalid block");
    return at(&this.blocks, this.currentBlock.i);
}
func getBlockByID(this: &IRFunc, id: IRBlockID) -> &IRBlock {
    assert(this.blocks.length > 0, "getBlockByID called on empty IRFunc");
    assert(id.i < this.blocks.length, "getBlockByID called with invalid ID");
    return at(&this.blocks, id.i);
}
func pushLoopBlocks(this: &IRFunc, before: IRBlockID, after: IRBlockID) {
    push(&this.loopBlocks, LoopBlock {
        before: before,
        after: after,
    });
}
func popLoopBlocks(this: &IRFunc) {
    pop(&this.loopBlocks);
}
func getFuncNode(this: &IRFunc) -> &ParsedFuncDecl {
    return at(&funcDecls, this.originalID);
}
func dumpInstructions(this: &IRFunc) {
    printf("%s:\n", this.name.buffer);
    for (let i: usize = 0; i < this.blocks.length; i = i + 1) {
        dump(at(&this.blocks, i));
    }
}
func equals(this: &IRFunc, other: &IRFunc) -> bool {
    unreachable("IRFunc.equals is not implemented yet");
}
func enterScope(this: &IRFunc) -> usize {
    push(&this.scopes, blank);
    return this.scopes.length;
}
func leaveScope(this: &IRFunc) -> usize {
    let s: usize = this.scopes.length;
    pop(&this.scopes);
    return s;
}
func startComptime(this: &IRFunc) {
    this.comptimeLevel = this.comptimeLevel + 1;
}
func endComptime(this: &IRFunc) {
    assert(this.comptimeLevel > 0);
    this.comptimeLevel = this.comptimeLevel - 1;
}
func getRegisterSizeInBytes(this: &IRFunc) -> usize {
    let size: usize = 0;
    for (let i: usize = 0; i < this.registers.length; i = i + 1) {
        let reg: &IRReg = getRegister(this, RegIndex { i: i });
        size = size + getSize(reg.typ);
    }
    return size;
}
func allocateRegister(this: &IRFunc, typ: &Type) -> RegIndex {
    trace("IRFunc.allocateRegister");
    let size: usize = this.registers.length;
    let offset: usize = 0;
    if (size > 0) {
        let last: &IRReg = last(&this.registers);
        offset = last.offset + getSize(last.typ);
    }
    push(&this.registers, IRReg {
        isComptime: this.comptimeLevel > 0,
        offset: offset,
        typ: typ,
    });
    return RegIndex { i: size };
}
func getRegister(this: &IRFunc, index: RegIndex) -> &IRReg {
    assert(index.i < this.registers.length, "Out of bounds access in IRFunc.getRegister");
    return at(&this.registers, index.i);
}
func getIdentifierByName(this: &IRFunc, name: SubStr) -> &IRScopeEntry {
    trace("IRFunc.getIdentifierByName");
    for (let _i: usize = 0; _i < this.scopes.length; _i = _i + 1) {
        let i: usize = this.scopes.length - _i - 1;
        let entry: &IRScopeEntry = getIdentifierByName(at(&this.scopes, i), name);
        if (entry != null) {
            return entry;
        }
    }
    return null;
}
func pushInstruction(this: &IRFunc, instr: IRInstr) {
    trace("IRFunc.pushInstruction");
    assert(this.blocks.length > 0, "IRFunc.pushInstruction called on empty block list");
    assert(this.currentBlock.i < this.blocks.length, "IRFunc.pushInstruction: Current block was invalid");
    pushInstruction(at(&this.blocks, this.currentBlock.i), instr);
}
func buildAlloca(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    let alloca: IRInstr = IRInstr {
        kind: INSTR_ALLOCA,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    };
    let entry: &IRBlock = getBlockByID(this, IRBlockID { i: 0 });
    if (isTerminated(entry)) {
        assert(entry.instructions.length > 0);
        pushInstruction(entry, alloca);
        let l: usize = entry.instructions.length;
        let last: &IRInstr = at(&entry.instructions, l - 1);
        let prev: &IRInstr = at(&entry.instructions, l - 2);
        let i1: IRInstr = *last;
        *last = *prev;
        *prev = i1;
    } else {
        pushInstruction(entry, alloca);
    }
}
func buildFetchGlobalPointer(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalRuntimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_GLOBAL_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
    });
}
func buildFetchGlobalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 1 },
    });
}
func buildFetchLocalComptimeValue(this: &IRFunc, span: Span, dst: RegIndex, globalIndex: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_FETCH_COMPTIME_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: globalIndex,
        op1: RegIndex { i: 0 },
    });
}
func buildLoadFunctionPtr(this: &IRFunc, span: Span, dst: RegIndex, funcID: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_FUNCTION_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: funcID },
    });
}
func buildLoad(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildMove(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MOVE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetParam(this: &IRFunc, span: Span, dst: RegIndex, index: usize, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_PARAM,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: index },
        op1: RegIndex { i: size },
    });
}
func buildStore(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_STORE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCall(this: &IRFunc, span: Span, dst: RegIndex, funcID: RegIndex, args: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CALL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: funcID,
        args: args,
    });
}
func buildReturnExpr(this: &IRFunc, span: Span, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_EXPR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        src: val,
    });
}
func buildReturnEmpty(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_RETURN_VOID,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildLoadString(this: &IRFunc, span: Span, dst: RegIndex, str: SubStr) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_STRING,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: str.start as usize },
        op1: RegIndex { i: str.len },
    });
}
func buildLoadBool(this: &IRFunc, span: Span, dst: RegIndex, val: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BOOL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadInteger(this: &IRFunc, span: Span, dst: RegIndex, t: &Type, val: usize) {
    let kind: usize = INSTR_LOAD_I8;
    if (isChar(t)) {
        kind = INSTR_LOAD_U8;
    } else {
        assert(isInteger(t), "IRFunc.buildLoadInteger got non-int type");
        let size: usize = getSize(t);
        if (size == 2) kind = INSTR_LOAD_I16;
        if (size == 4) kind = INSTR_LOAD_I32;
        if (size == 8) kind = INSTR_LOAD_I64;
        if (!isSignedInteger(t)) kind = kind + 1;
    }
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: val },
    });
}
func buildLoadNull(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_NULL,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildLoadF32(this: &IRFunc, span: Span, dst: RegIndex, val: f32) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadF64(this: &IRFunc, span: Span, dst: RegIndex, val: f64) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: *(&val as &usize) },
    });
}
func buildLoadBlank(this: &IRFunc, span: Span, dst: RegIndex, size: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOAD_BLANK,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: RegIndex { i: size },
    });
}
func buildLogicalNot(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_LOGICAL_NOT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildBinaryOp(this: &IRFunc, span: Span, kind: usize, dst: RegIndex, lhs: RegIndex, rhs: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: kind,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: lhs,
        op1: rhs,
    });
}
func buildInsertValue(this: &IRFunc, span: Span, aggr: RegIndex, index: usize, val: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INSERT_VALUE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: aggr,
        src: RegIndex { i: index },
        op1: val,
    });
}
func buildUnreachable(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNREACHABLE,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildUnterminated(this: &IRFunc, span: Span) {
    pushInstruction(this, IRInstr {
        kind: INSTR_UNTERMINATED,
        span: span,
        isComptime: this.comptimeLevel > 0,
    });
}
func buildBr(this: &IRFunc, span: Span, block: IRBlockID) {
    assert(block.i < this.blocks.length, "buildBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: block.i },
    });
}
func buildCondBr(this: &IRFunc, span: Span, cond: RegIndex, drue: IRBlockID, falze: IRBlockID) {
    assert(drue.i < this.blocks.length, "buildCondBr called with invalid ID");
    assert(falze.i < this.blocks.length, "buildCondBr called with invalid ID");
    pushInstruction(this, IRInstr {
        kind: INSTR_COND_BR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: RegIndex { i: drue.i },
        src: cond,
        op1: RegIndex { i: falze.i },
    });
}
func buildBreak(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.after);
    return true;
}
func buildContinue(this: &IRFunc, span: Span) -> bool {
    if (this.loopBlocks.length == 0) return false;
    let block: &LoopBlock = last(&this.loopBlocks);
    buildBr(this, span, block.before);
    return true;
}
func buildIntSignExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_SIGN_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntZeroExtend(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_ZERO_EXTEND,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildIntTruncate(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex, bits: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TRUNCATE,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: RegIndex { i: bits },
    });
}
func buildF32ToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF32(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F32,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToF64(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_F64,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF32ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F32_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildF64ToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_F64_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildCreateArray(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_ARRAY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateStruct(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_STRUCT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildCreateUnion(this: &IRFunc, span: Span, dst: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_CREATE_UNION,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
    });
}
func buildPtrToInt(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_PTR_TO_INT,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildIntToPtr(this: &IRFunc, span: Span, dst: RegIndex, src: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_INT_TO_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
    });
}
func buildGetFieldPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, index: usize) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_FIELD_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        op1: RegIndex { i: index },
    });
}
func buildGetElementPtr(this: &IRFunc, span: Span, elem: RegIndex, aggr: RegIndex, indices: RegIndexList) {
    pushInstruction(this, IRInstr {
        kind: INSTR_GET_ELEMENT_PTR,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: elem,
        src: aggr,
        args: indices,
    });
}
func buildMemcpy(this: &IRFunc, span: Span, src: RegIndex, dst: RegIndex, size: RegIndex) {
    pushInstruction(this, IRInstr {
        kind: INSTR_MEMCPY,
        span: span,
        isComptime: this.comptimeLevel > 0,
        dst: dst,
        src: src,
        op1: size,
    });
}

struct IRScopeEntry {
    name: SubStr;
    ptr: RegIndex;
    isComptime: bool;
}
func equals(this: &IRScopeEntry, other: &IRScopeEntry) -> bool {
    unreachable("IRScopeEntry.equals is not implemented yet");
}

struct IRScope {
    entries: IRScopeEntryList;
}
func equals(this: &IRScope, other: &IRScope) -> bool {
        unreachable("IRScope.equals is not implemented yet");
}
func addEntry(this: &IRScope, name: SubStr, ptr: RegIndex, isComptime: bool) {
    push(&this.entries, IRScopeEntry {
        name: name,
        ptr: ptr,
        isComptime: isComptime,
    });
}
func getIdentifierByName(this: &IRScope, name: SubStr) -> &IRScopeEntry {
    for (let i: usize = 0; i < this.entries.length; i = i + 1) {
        let entry: &IRScopeEntry = at(&this.entries, i);
        if (equals(&name, &entry.name)) {
            return entry;
        }
    }
    return null;
}

struct IRGen {
    globalScope: IRFunc;
    functions: String_IRFuncHashMap;
    error: bool;
}
func getIdentifierByName(this: &IRGen, function: &IRFunc, name: SubStr, isGlobal: &bool) -> &IRScopeEntry {
    trace("IRGen.getIdentifierByName");
    let entry: &IRScopeEntry = getIdentifierByName(function, name);
    if (entry != null) {
        *isGlobal = false;
        return entry;
    }
    entry = getIdentifierByName(&this.globalScope, name);
    if (entry != null) {
        *isGlobal = true;
        return entry;
    }
    return null;
}
func getFunctionByName(this: &IRGen, name: &String) -> usize {
    return indexOf(&this.functions, name);
}
func fillLookup(this: &IRGen, project: &ParsedFile) -> bool {
    trace("IRGen.fillLookup");
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let function: &ParsedFuncDecl = at(&funcDecls, i);
        if (function.ignored) continue;
        let name: String = getMangledName(function);
        if (containsKey(&this.functions, &name)) {
            let fn = get(&this.functions, &name);
            let loc = toString(&function.span);
            let loc1 = toString(&fn.span);
            fprintf(stderr, "%s: %s Hash collision - Function Lookup already contains function!\n", loc.buffer, FATAL_STR);
            fprintf(stderr, "%s: %s Function with mangled name %s already defined here!\n", loc1.buffer, FATAL_STR, name.buffer);
            drop(&loc1);
            drop(&loc);
            exit(2);
        }
        let irfunc: IRFunc = IRFunc {
            name: name,
            span: function.span,
            originalID: getID(function),
            comptimeLevel: 0,
            attrs: function.attrs,
        };
        add(&this.functions, name, irfunc);
    }
    return true;
}
func generateBytecode(this: &IRGen, project: &ParsedFile) -> bool {
    trace("IRGen.generateBytecode");
    if (!fillLookup(this, project))
        return false;
    let scope: usize = enterScope(&this.globalScope);
    assert(this.globalScope.scopes.length == 1, "Expected only one valid scope");
    let entry: IRBlockID = appendBlock(&this.globalScope);
    setCurrentBlock(&this.globalScope, entry);
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let file: &ParsedFile = at(&files, i);
        for (let j: usize = 0; j < file.mod.tlis.length; j = j + 1) {
            let tli: &ParsedTopLevelItem = at(&topLevelItems, *at(&file.mod.tlis, j));
            if (tli.ignored) continue;
            if (tli.kind == TLI_VAR_DECL) {
                generateBytecodeStmt(this, &this.globalScope, at(&stmts, tli.nodeID));
            }
        }
    }
    for (let i: usize = 0; i < funcDecls.length; i = i + 1) {
        let fn: &ParsedFuncDecl = at(&funcDecls, i);
        generateFunction(this, fn);
    }
    if (*flags.emitBIR) {
        // TODO: Emit to file
        dumpInstructions(&this.globalScope);
        let fns = asList(&this.functions);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            dumpInstructions(at(&fns, i));
        }
        drop(&fns);
    }
    return !this.error;
}

func generateFunctionHeader(this: &IRGen, function: &IRFunc, retType: &Type, params: &ParamContext) {
    trace("IRGen.generateFunctionHeader");
    let entry: IRBlockID = appendBlock(function);
    setCurrentBlock(function, entry);
    let offset: usize = 0;
    if (getSize(retType) > 8) {
        offset = 1;
        prepareParameter(this, function, 0, blank, newSubStrOfStrLit("ret"), intoPointer(retType), true);
    }
    for (let i: usize = 0; i < params.paramLength; i = i + 1) {
        let name: Token = getNameAtIndex(params, i);
        let typDecl: &ParsedTypeNode = getTypeAtIndex(params, i);
        let pType: &Type = getType(&typDecl.typeState);
        prepareParameter(this, function, i + offset, name.span, name.content, pType, false);
    }
}

func generateFunctionBody(this: &IRGen, function: &IRFunc, body: &ParsedBlock, retTypeNode: &ParsedTypeNode) {
    trace("IRGen.generateFunctionBody");
    let retType: &Type = getType(&retTypeNode.typeState);
    if (function.returnBlockID.i == 0) {
        let curr = getCurrentBlock(function);
        function.returnBlockID = appendBlock(function);
        if (isNone(retType)) {
            setCurrentBlock(function, function.returnBlockID);
            buildReturnEmpty(function, retTypeNode.span);
            setCurrentBlock(function, curr);
        } else {
            function.returnAlloc = allocateRegister(function, intoPointer(retType));
            buildAlloca(function, retTypeNode.span, function.returnAlloc, getSize(retType));
            setCurrentBlock(function, function.returnBlockID);
            let result = allocateRegister(function, retType);
            buildLoad(function, retTypeNode.span, result, function.returnAlloc);
            if (getSize(retType) > 8) {
                buildStore(function, retTypeNode.span, function.retPtr, result);
                buildReturnExpr(function, retTypeNode.span, function.retPtr);
            } else {
                if (isStruct(retType)) {
                    let v: RegIndex = getRegisterForSize(this, function, getSize(retType));
                    let t: &Type = getRegister(function, v).typ;
                    let r: RegIndex = allocateRegister(function, intoPointer(t));
                    let s: usize = getSize(t);
                    assert(s <= 8);
                    buildAlloca(function, retTypeNode.span, r, s);
                    buildStore(function, retTypeNode.span, r, result);
                    buildLoad(function, retTypeNode.span, v, r);
                    buildReturnExpr(function, retTypeNode.span, v);
                } else {
                    buildReturnExpr(function, retTypeNode.span, result);
                }
            }
            setCurrentBlock(function, curr);
        }
    }
    generateBytecodeBlock(this, function, body);
    let curr: &IRBlock = getCurrentBlockAsRef(function);
    if (!isTerminated(curr)) {
        if (isNone(retType)) {
            buildReturnEmpty(function, body.span);
        } else {
            buildUnterminated(function, body.span);
        }
    }
    let after: usize = leaveScope(function);
    assert(after == 1, "Scope imbalance detected");
}

func generateFunction(this: &IRGen, funcDecl: &ParsedFuncDecl) {
    trace("IRGen.generateFunction");
    if (funcDecl.ignored) return;
    assert(isSuccess(&funcDecl.typeState), "Expected valid FuncDecl type in IRGen");
    let name: String = getMangledName(funcDecl);
    let function: &IRFunc = get(&this.functions, &name);
    assert(function != null, "Expected to find function in lookup");
    assert(equals(&function.name, &name), "functions.get() retrieved wrong IRFunc");
    drop(&name);
    if (isExtern(funcDecl)) {
        return;
    }
    let scope: usize = enterScope(function);
    assert(scope == 1, "Expected function to enter first scope");
    let retDecl: &ParsedTypeNode = funcDecl.retType;
    generateFunctionHeader(this, function, getType(&retDecl.typeState), &funcDecl.params);
    generateFunctionBody(this, function, funcDecl.body, funcDecl.retType);
}

func generateBytecodeBlock(this: &IRGen, function: &IRFunc, block: &ParsedBlock) {
    trace("IRGen.generateBytecodeBlock");
    if (block.ignored) return;
    assert(isSuccess(&block.typeState), "Expected valid Block type in IRGen");
    let scope: usize = enterScope(function);
    let f: &ParsedFuncDecl = getFuncNode(function);
    for (let i: usize = 0; i < block.stmtLength; i = i + 1) {
        let stmt: &ParsedStmt = getStmtAtIndex(block, i);
        generateBytecodeStmt(this, function, stmt);
        let curr: &IRBlock = getCurrentBlockAsRef(function);
        if (isTerminated(curr)) {
            if (i != block.stmtLength - 1) {
                let loc: String = toString(&getStmtAtIndex(block, i + 1).span);
                fprintf(stderr, "%s: %s: Unreachable code.\n", loc.buffer, WARN_STR);
                drop(&loc);
            }
            break;
        }
    }
    let after: usize = leaveScope(function);
    assert(scope == after, "Scope imbalance detected");
}

func generateBytecodeStmt(this: &IRGen, function: &IRFunc, stmt: &ParsedStmt) {
    trace("IRGen.generateBytecodeStmt");
    match (&stmt.data) {
        &StmtData::VarDecl(decl) => {
            let expr: &ParsedExpr = decl.expr;
            if (decl.isComptime) {
                startComptime(function);
                let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
                let scope: &IRScope = last(&function.scopes);
                addEntry(scope, decl.name.content, result, true);
                endComptime(function);
            } else {
                let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
                let typ: &Type = getType(&stmt.typeState);
                let allocaType: &Type = intoPointer(typ);
                let ptr: RegIndex = allocateRegister(function, allocaType);
                buildAlloca(function, stmt.span, ptr, getSize(typ));
                buildStore(function, stmt.span, ptr, result);
                let scope: &IRScope = last(&function.scopes);
                addEntry(scope, decl.name.content, ptr, false);
            }
        }
        &StmtData::ReturnEmpty => {
            buildBr(function, stmt.span, function.returnBlockID);
        }
        &StmtData::ReturnExpr(expr) => {
            let typ: &Type = getType(&expr.typeState);
            let result: RegIndex = generateBytecodeExpr(this, function, expr, false);
            buildStore(function, stmt.span, function.returnAlloc, result);
            buildBr(function, stmt.span, function.returnBlockID);
        }
        &StmtData::Expr(expr) => { generateBytecodeExpr(this, function, expr, false); }
        &StmtData::Block(block) => { generateBytecodeBlock(this, function, block); }
        &StmtData::If(cond, then) => {
            let condReg = generateBytecodeExpr(this, function, cond, false);
            let thenBlock = appendBlock(function);
            let contBlock = appendBlock(function);
            buildCondBr(function, stmt.span, condReg, thenBlock, contBlock);

            setCurrentBlock(function, thenBlock);
            generateBytecodeStmt(this, function, then);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, contBlock);
            }
            setCurrentBlock(function, contBlock);
        }
        &StmtData::IfElse(cond, then, elze) => {
            let condReg = generateBytecodeExpr(this, function, cond, false);
            let thenBlockID = appendBlock(function);
            let elzeBlockID = appendBlock(function);
            buildCondBr(function, stmt.span, condReg, thenBlockID, elzeBlockID);

            setCurrentBlock(function, thenBlockID);
            generateBytecodeStmt(this, function, then);
            thenBlockID = getCurrentBlock(function);

            setCurrentBlock(function, elzeBlockID);
            generateBytecodeStmt(this, function, elze);
            elzeBlockID = getCurrentBlock(function);

            let thenBlock: &IRBlock = getBlockByID(function, thenBlockID);
            let elzeBlock: &IRBlock = getBlockByID(function, elzeBlockID);
            let thenTerm: bool = isTerminated(thenBlock);
            let elseTerm: bool = isTerminated(elzeBlock);
            if (thenTerm && elseTerm) {
                // nothing to do here
            } else if (thenTerm && !elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, elzeBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else if (!thenTerm && elseTerm) {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, thenBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            } else {
                let after: IRBlockID = appendBlock(function);
                setCurrentBlock(function, thenBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, elzeBlockID);
                buildBr(function, stmt.span, after);
                setCurrentBlock(function, after);
            }
        }
        &StmtData::While(cond, body) => {
            let condBlock: IRBlockID = appendBlock(function);
            let bodyBlock: IRBlockID = appendBlock(function);
            let afterBlock: IRBlockID = appendBlock(function);
            pushLoopBlocks(function, condBlock, afterBlock);
            buildBr(function, stmt.span, condBlock);

            setCurrentBlock(function, condBlock);
            let cond: RegIndex = generateBytecodeExpr(this, function, cond, false);
            buildCondBr(function, stmt.span, cond, bodyBlock, afterBlock);

            setCurrentBlock(function, bodyBlock);
            generateBytecodeStmt(this, function, body);
            let curr: &IRBlock = getCurrentBlockAsRef(function);
            if (!isTerminated(curr)) {
                buildBr(function, stmt.span, condBlock);
            }

            setCurrentBlock(function, afterBlock);
            popLoopBlocks(function);
        }
        &StmtData::CFor { init, cond, step, body } => {
            let initBlock = appendBlock(function);
            let condBlock = appendBlock(function);
            let stepBlock = appendBlock(function);
            let bodyBlock = appendBlock(function);
            let afterBlock = appendBlock(function);
            pushLoopBlocks(function, stepBlock, afterBlock);
            buildBr(function, stmt.span, initBlock);
            let scope = enterScope(function);

            setCurrentBlock(function, initBlock);
            generateBytecodeStmt(this, function, init);
            if (!isTerminated(getCurrentBlockAsRef(function))) {
                buildBr(function, init.span, condBlock);
            }

            setCurrentBlock(function, condBlock);
            let condReg = generateBytecodeExpr(this, function, cond, false);
            buildCondBr(function, cond.span, condReg, bodyBlock, afterBlock);

            setCurrentBlock(function, stepBlock);
            generateBytecodeExpr(this, function, step, false);
            buildBr(function, step.span, condBlock);

            setCurrentBlock(function, bodyBlock);
            generateBytecodeStmt(this, function, body);
            if (!isTerminated(getCurrentBlockAsRef(function))) {
                buildBr(function, body.span, stepBlock);
            }

            let after = leaveScope(function);
            assert(scope == after, "Scope imbalance in for-loop");
            setCurrentBlock(function, afterBlock);
        }
        &StmtData::Break => {
            if (!buildBreak(function, stmt.span)) {
                todo_with_msg("break outside of loop");
            }
        }
        &StmtData::Continue => {
            if (!buildContinue(function, stmt.span)) {
                todo_with_msg("continue outside of loop");
            }
        }
        &StmtData::Match(_, _, _) => {
            generateBytecodeMatchStmt(this, function, stmt);
        }
        unknown => {
            fprintf(stderr, "%s generateBytecodeStmt: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
}

func generateBytecodeMatchStmt(this: &IRGen, function: &IRFunc, match: &ParsedStmt) {
    trace("IRGen.generateBytecodeMatchStmt");
    let expr: &ParsedExpr = null;
    let patterns: &ParsedPatternList = null;
    let stmts: &ParsedStmtList = null;
    match (&match.data) {
        &StmtData::Match(_expr, _patterns, _stmts) => {
            expr = _expr;
            patterns = &_patterns;
            stmts = &_stmts;
        }
        _ => { unreachable(); }
    }
    assert(patterns.length == stmts.length);
    let state = match.typeState;
    assert(isPattern(&state));
    let patState = getPatState(&state);
    assert(patState.complete, "generateBytecodeMatchStmt: Non-exhaustive pattern");
    let exprReg = generateBytecodeExpr(this, function, expr, false);
    let end = appendBlock(function);
    for (let i: usize = 0; i < patterns.length; i = i + 1) {
        let pat = *at(patterns, i);
        let stmt = *at(stmts, i);
        let scope: usize = enterScope(function);
        let patReg = generateBytecodePattern(this, function, exprReg, pat, false /* don't care */);
        let matchBlock = appendBlock(function);
        let nextBlock = appendBlock(function);
        buildCondBr(function, match.span, patReg, matchBlock, nextBlock);
        setCurrentBlock(function, matchBlock);
        generateBytecodeStmt(this, function, stmt);
        if (!isTerminated(getCurrentBlockAsRef(function))) {
            buildBr(function, stmt.span, end);
        }
        setCurrentBlock(function, nextBlock);
        let after = leaveScope(function);
        assert(scope == after, "Scope imbalance in match");
    }
    // in the normal control flow, we should at some point always go into a matchBlock, which jumps
    // to the end. If we don't, there's an internal compiler bug, which is why we put an unreachable
    // here.
    let unreachable: String = newStringFromStrLit("unreachablePcrN");
    if (!containsKey(&this.functions, &unreachable)) {
        fprintf(stderr, "%s Could not generate match guard check!\n", FATAL_STR);
        fprintf(stderr, "%s: Reason: Could not find function `unreachable`!\n", NOTE_STR);
        fprintf(stderr, "%s: Please import `prelude.bufo` and try again.\n", NOTE_STR);
        exit(1);
    }
    let funcID: usize = getFunctionByName(this, &unreachable);
    let args: RegIndexList = blank;
    {
        let err: RegIndex = allocateRegister(function, wrap(Type::Prim(PrimType::Char)));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&match.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": FATAL COMPILER ERROR: match-statement reached guard block!\n");
        pushString(&s, &_s);
        pushStr(&s, ": This should never happen, as all match-patterns eventually lead to the real block.\n");
        pushString(&s, &_s);
        pushStr(&s, ": Please submit a bug report.\n");
        drop(&_s);
        buildLoadString(function, match.span, err, asSubStr(&s));
        push(&args, err);
    }
    let reg: RegIndex = allocateRegister(function, wrap(Type::Prim(PrimType::None)));
    {
        let ft = wrap(Type::Func(blank, wrap(Type::Prim(PrimType::None)), FuncAttr {
            isVariadic: true // REVIEW: Why?
        }));
        let dst = allocateRegister(function, ft);
        buildLoadFunctionPtr(function, match.span, dst, funcID);
        buildCall(function, match.span, reg, dst, args);
    }
    buildUnreachable(function, match.span);
    setCurrentBlock(function, end);
}

func generateBytecodePattern(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, inOrigMemory: bool) -> RegIndex {
    trace("IRGen.generateBytecodePattern");
    let type = getRegister(function, expr).typ;
    let success = allocateRegister(function, wrap(Type::Prim(PrimType::Bool)));
    match (&pat.data) {
        &Pattern::Ident(name) => {
            if (inOrigMemory) {
                addEntry(last(&function.scopes), name.content, expr, false);
            } else {
                let allocReg = allocateRegister(function, intoPointer(type));
                buildAlloca(function, pat.span, allocReg, getSize(type));
                buildStore(function, pat.span, allocReg, expr);
                addEntry(last(&function.scopes), name.content, allocReg, false);
            }
            buildLoadBool(function, pat.span, success, 1);
        }
        &Pattern::Reference(sub) => {
            assert(isPointer(type), "Reference Pattern expected pointer type");
            let under = getUnderlyingType(type, false);
            if (isPointer(under)) {
                let reg = allocateRegister(function, under);
                buildLoad(function, pat.span, reg, expr);
                return generateBytecodePattern(this, function, reg, sub, true);
            } else {
                return generateBytecodePattern(this, function, expr, sub, true);
            }
        }
        &Pattern::Null => {
            assert(isPointer(type), "Null Pattern expected pointer type");
            let reg = allocateRegister(function, type);
            buildLoadNull(function, pat.span, reg);
            buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, reg);
        }
        &Pattern::Boolean(true) => {
            if (inOrigMemory) {
                assert(isPointer(type), "Boolean Pattern inOrigMemory expected pointer");
                assert(isPointerTo(type, wrap(Type::Prim(PrimType::Bool))), "Boolean Pattern inOrigMemory expected pointer to bool");
                let _expr = allocateRegister(function, getUnderlyingType(type, false));
                buildLoad(function, pat.span, _expr, expr);
                buildMove(function, pat.span, success, _expr);
            } else {
                buildMove(function, pat.span, success, expr);
            }
        }
        &Pattern::Boolean(false) => {
            if (inOrigMemory) {
                assert(isPointer(type), "Boolean Pattern inOrigMemory expected pointer");
                assert(isPointerTo(type, wrap(Type::Prim(PrimType::Bool))), "Boolean Pattern inOrigMemory expected pointer to bool");
                let _expr = allocateRegister(function, getUnderlyingType(type, false));
                buildLoad(function, pat.span, _expr, expr);
                buildLogicalNot(function, pat.span, success, _expr);
            } else {
                buildLogicalNot(function, pat.span, success, expr);
            }
        }
        &Pattern::Struct(_, _) => {
            buildLoadBool(function, pat.span, success, 1);
            generateBytecodePatternStruct(this, function, expr, pat, success, inOrigMemory);
        }
        &Pattern::Path(_, sub) => {
            buildLoadBool(function, pat.span, success, 1);
            let ptr = isPointer(type);
            if (ptr) type = getUnderlyingType(type, false);
            if (isUnion(type)) {
                generateBytecodePatternUnion(this, function, expr, pat, success, ptr || inOrigMemory);
            } else if (isStruct(type)) {
                generateBytecodePatternStruct(this, function, expr, sub, success, ptr || inOrigMemory);
            } else {
                unreachable("generateBytecodePattern(PATTERN_PATH): Exhaustive handling of variations");
            }
        }
        &Pattern::Number(ident) => {
            let number: RegIndex = blank;
            let real = type;
            if (inOrigMemory) {
                assert(isPointer(real), "generateBytecodePattern: Number inOrigMemory");
                real = getUnderlyingType(real, false);
                let _expr = allocateRegister(function, real);
                buildLoad(function, pat.span, _expr, expr);
                expr = _expr;
            }
            number = allocateRegister(function, real);
            loadLiteral(this, function, number, &ident);
            if (isInteger(real)) {
                buildBinaryOp(function, pat.span, INSTR_INT_CMP_EQ, success, expr, number);
            } else if (isFloat(real)) {
                buildBinaryOp(function, pat.span, INSTR_FLOAT_CMP_EQ, success, expr, number);
            } else {
                unreachable("Exhaustive handling of number types in IRGen.generateBytecodePattern");
            }
        }
        &Pattern::Wildcard => { buildLoadBool(function, pat.span, success, 1); }
        &Pattern::Rest => { buildLoadBool(function, pat.span, success, 1); }
        _ => { unreachable("Exhaustive handling of patterns in IRGen.generateBytecodePattern"); }
    }
    return success;
}

func generateBytecodePatternStruct(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool) {
    trace("IRGen.generateBytecodePatternStruct");
    let type = getRegister(function, expr).typ;
    let subPatterns: &ParsedPatternList = null;
    match (&pat.data) {
        &Pattern::Struct(_, patterns) => { subPatterns = &patterns; }
        _ => { unreachable(); }
    }
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        let decl: &ParsedStructDecl = null;
        match (type) {
            &Type::Ptr(&Type::Struct(_decl)) => { decl = _decl; }
            _ => { unreachable("In Memory Struct Pattern expected pointer to struct type"); }
        }
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = intoPointer(getType(&fieldNode.typeState));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, subExpr, expr, i);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, true);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    } else {
        let decl: &ParsedStructDecl = null;
        match (type) {
            &Type::Struct(_decl) => { decl = _decl; }
            _ => { unreachable("Struct Pattern expected struct type"); }
        }
        let allocReg = allocateRegister(function, intoPointer(type));
        buildAlloca(function, pat.span, allocReg, getSize(type));
        buildStore(function, pat.span, allocReg, expr);
        expr = allocReg;
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let subPat = *at(subPatterns, i);
            let fieldNode = getFieldTypeAtIndex(&decl.context, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldPtr = allocateRegister(function, intoPointer(fieldType));
            let subExpr = allocateRegister(function, fieldType);
            buildGetFieldPtr(function, pat.span, fieldPtr, expr, i);
            buildLoad(function, pat.span, subExpr, fieldPtr);
            let sub = generateBytecodePattern(this, function, subExpr, subPat, false);
            buildBinaryOp(function, subPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subPat.data) == comptime tag(&Pattern::Rest)) break;
        }
    }
}

func generateBytecodePatternUnion(this: &IRGen, function: &IRFunc, expr: RegIndex, pat: &ParsedPattern, success: RegIndex, inOrigMemory: bool) {
    trace("IRGen.generateBytecodePatternUnion");
    // FIXME: Handling of IR for unions is always so awkward
    let type = getRegister(function, expr).typ;
    let name: &Token = null;
    let subPatterns: ParsedPatternList = blank;
    match (&pat.data) {
        &Pattern::Path(_, &ParsedPattern { _, _, Pattern::Ident(ident) }) => {
            name = &ident;
        }
        &Pattern::Path(_, &ParsedPattern { _, _, Pattern::Struct(ident, pats) }) => {
            name = &ident;
            subPatterns = pats;
        }
        _ => { unreachable(); }
    }
    let u8Type = wrap(Type::Prim(PrimType::U8));
    let usizeType = wrap(Type::Prim(PrimType::Usize));
    let sizeReg = allocateRegister(function, usizeType);
    let tagReg = allocateRegister(function, u8Type);
    let tagMatch = allocateRegister(function, wrap(Type::Prim(PrimType::Bool)));
    let tagPtr = allocateRegister(function, intoPointer(u8Type));
    let tagVal = allocateRegister(function, u8Type);
    // REVIEW: Can we condense the branches?
    if (inOrigMemory) {
        let decl: &ParsedUnionDecl = null;
        match (type) {
            &Type::Ptr(&Type::Union(_decl, _)) => { decl = _decl; }
            _ => { unreachable("In Memory Union Pattern expected pointer type"); }
        }
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, name, &variant);
        assert(found);
        let tmp = allocateRegister(function, intoPointer(type));
        buildMove(function, pat.span, tmp, expr);
        {
            // tagReg check
            buildLoadInteger(function, name.span, tagReg, u8Type, getVariantTag(decl, variant));
            buildMove(function, name.span, tagPtr, tmp);
            buildLoad(function, name.span, tagVal, tagPtr);
            buildBinaryOp(function, name.span, INSTR_INT_CMP_EQ, tagMatch, tagReg, tagVal);
            buildBinaryOp(function, name.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tagReg
            buildLoadInteger(function, name.span, sizeReg, usizeType, 1);
            buildPtrToInt(function, name.span, tmp, tmp);
            buildBinaryOp(function, name.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, name.span, tmp, tmp);
        }
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSize(fieldType);
            let subPtr = allocateRegister(function, intoPointer(fieldType));
            buildMove(function, subSubPat.span, subPtr, tmp);
            let sub = generateBytecodePattern(this, function, subPtr, subSubPat, true);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
            if (i != subPatterns.length - 1) {
                buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    } else {
        let decl: &ParsedUnionDecl = null;
        match (type) {
            &Type::Union(_decl, _) => { decl = _decl; }
            _ => { unreachable("Union Pattern expected union type"); }
        }
        let variant: &ParsedUnionVariant = null;
        let found = resolveVariantByName(decl, name, &variant);
        assert(found);
        let allocReg = allocateRegister(function, intoPointer(type));
        buildAlloca(function, pat.span, allocReg, getSize(type));
        buildStore(function, pat.span, allocReg, expr);
        let tmp = allocateRegister(function, intoPointer(type));
        buildMove(function, pat.span, tmp, allocReg);
        {
            // tagReg check
            buildLoadInteger(function, name.span, tagReg, u8Type, getVariantTag(decl, variant));
            buildMove(function, name.span, tagPtr, allocReg);
            buildLoad(function, name.span, tagVal, tagPtr);
            buildBinaryOp(function, name.span, INSTR_INT_CMP_EQ, tagMatch, tagReg, tagVal);
            buildBinaryOp(function, name.span, INSTR_LOGICAL_AND, success, success, tagMatch);

            // offset tmp by tagReg
            buildLoadInteger(function, name.span, sizeReg, usizeType, 1);
            buildPtrToInt(function, name.span, tmp, tmp);
            buildBinaryOp(function, name.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
            buildIntToPtr(function, name.span, tmp, tmp);
        }
        expr = allocReg;
        for (let i: usize = 0; i < variant.fields.length; i = i + 1) {
            let subSubPat = *at(&subPatterns, i);
            let fieldNode = *at(&variant.fields, i);
            let fieldType = getType(&fieldNode.typeState);
            let fieldSize = getSize(fieldType);
            let subAlloc = allocateRegister(function, intoPointer(fieldType));
            let subExpr = allocateRegister(function, fieldType);
            buildAlloca(function, subSubPat.span, subAlloc, fieldSize);
            buildLoadInteger(function, subSubPat.span, sizeReg, usizeType, fieldSize);
            buildMemcpy(function, subSubPat.span, tmp, subAlloc, sizeReg);
            buildLoad(function, subSubPat.span, subExpr, subAlloc);
            let sub = generateBytecodePattern(this, function, subExpr, subSubPat, false);
            buildBinaryOp(function, subSubPat.span, INSTR_LOGICAL_AND, success, success, sub);
            if (tag(&subSubPat.data) == comptime tag(&Pattern::Rest)) break;
            if (i != subPatterns.length - 1) {
                buildPtrToInt(function, subSubPat.span, tmp, tmp);
                buildBinaryOp(function, subSubPat.span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                buildIntToPtr(function, subSubPat.span, tmp, tmp);
            }
        }
    }
}

func generateBytecodeExpr(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExpr");
    if (expr.ignored) return blank;
    assert(isSuccess(&expr.typeState), "Expected valid Expr type in IRGen");
    match (&expr.data) {
        &ExprData::IntLit(_)    => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::StrLit(_)    => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::CharLit(_)   => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::ArrayLit(_)  => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::Ident(ident) => { return generateBytecodeExprIdentifier(this, function, &ident, needsPtr); }
        &ExprData::Unary(unary) => {
            return generateBytecodeExprUnary(this, function, expr.span, &unary, getType(&expr.typeState), needsPtr);
        }
        &ExprData::Binary(binary) => {
            return generateBytecodeExprBinary(this, function, &binary, getType(&expr.typeState), needsPtr);
        }
        &ExprData::Call(call) => { return generateBytecodeExprCall(this, function, &call, needsPtr); }
        &ExprData::Sizeof(typeNode) => {
            let t: &Type = getType(&expr.typeState);
            let target: &Type = getType(&typeNode.typeState);
            let reg: RegIndex = allocateRegister(function, t);
            let size: usize = getSize(target);
            buildLoadInteger(function, expr.span, reg, t, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::StructInit(init) => {
            let strukt: &Type = getType(&expr.typeState);
            let structDecl: &ParsedStructDecl = null;
            match (strukt) {
                &Type::Struct(_decl) => { structDecl = _decl; }
                _ => { unreachable("Expected Struct Type in EXPR_STRUCT_INIT"); }
            }
            let reg: RegIndex = allocateRegister(function, strukt);
            buildCreateStruct(function, expr.span, reg);
            for (let i: usize = 0; i < init.context.fieldLength; i = i + 1) {
                let name: Token = getFieldNameAtIndex(&init.context, i);
                let field: &ParsedExpr = getFieldExprAtIndex(&init.context, i);
                let index: usize = getFieldIndex(structDecl, &name.content);
                let result: RegIndex = generateBytecodeExpr(this, function, field, false);
                buildInsertValue(function, field.span, reg, index, result);
            }
            if (needsPtr) {
                let structAlloc: RegIndex = allocateRegister(function, intoPointer(strukt));
                buildAlloca(function, expr.span, structAlloc, getSize(strukt));
                buildStore(function, expr.span, structAlloc, reg);
                return structAlloc;
            }
            return reg;
        }
        &ExprData::UnionInit(init) => {
            return generateBytecodeExprUnionInit(this, function, expr.span, &init, getType(&expr.typeState), needsPtr);
        }
        &ExprData::As(_,_) => { return generateBytecodeExprAs(this, function, expr); }
        &ExprData::Null => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::Blank => {
            let t: &Type = getType(&expr.typeState);
            let size: usize = getSize(t);
            let reg: RegIndex = allocateRegister(function, t);
            buildLoadBlank(function, expr.span, reg, size);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
                buildAlloca(function, expr.span, tempAlloc, size);
                buildStore(function, expr.span, tempAlloc, reg);
                return tempAlloc;
            }
            return reg;
        }
        &ExprData::True => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        &ExprData::False => { return generateBytecodeExprLiteral(this, function, expr, needsPtr); }
        unknown => {
            fprintf(stderr, "%s generateBytecodeExpr: Unknown tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    unreachable("Exhaustive handling of ops in generateBytecodeExpr");
}

func generateBytecodeExprBinary(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    match (expr) {
        &BinaryExpr::Path(..) => { return generateBytecodeExprPathAccess(this, function, expr, needsPtr); }
        &BinaryExpr::Dot(..) => { return generateBytecodeExprMemberAccess(this, function, expr, needsPtr); }
        &BinaryExpr::Assign(..) => { return generateBytecodeExprAssignment(this, function, expr); }
        &BinaryExpr::Plus(..) => { return generateBytecodeExprArithmetic(this, function, expr, type); }
        &BinaryExpr::Sub(..) => { return generateBytecodeExprArithmetic(this, function, expr, type); }
        &BinaryExpr::Mult(..) => { return generateBytecodeExprArithmetic(this, function, expr, type); }
        &BinaryExpr::Div(..) => { return generateBytecodeExprArithmetic(this, function, expr, type); }
        &BinaryExpr::Mod(..) => { return generateBytecodeExprArithmetic(this, function, expr, type); }
        &BinaryExpr::CmpEq(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpNeq(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpGt(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpGte(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpLt(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::CmpLte(..) => { return generateBytecodeExprComparison(this, function, expr, type); }
        &BinaryExpr::LogAnd(..) => { return generateBytecodeExprLogical(this, function, expr, type); }
        &BinaryExpr::LogOr(..) => { return generateBytecodeExprLogical(this, function, expr, type); }
        &BinaryExpr::BitAnd(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::BitOr(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::BitXor(..) => { return generateBytecodeExprBitwise(this, function, expr, type); }
        &BinaryExpr::Indexed(..) => { return generateBytecodeExprIndexedAccess(this, function, expr, type, needsPtr); }
        unknown => {
            fprintf(stderr, "%s generateBytecodeExprBinary: Unhandled tag %hhu!\n", FATAL_STR, tag(unknown));
            exit(2);
        }
    }
    unreachable("generateBytecodeExprBinary: Exhaustive handling of binary ops");
}

func generateBytecodeExprUnionInit(this: &IRGen, function: &IRFunc, span: Span, expr: &UnionExpr, type: &Type, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprUnionInit");
    // union = [tag, data]
    let decl: &ParsedUnionDecl = null;
    let variant: &ParsedUnionVariant = null;
    let tag: usize = 0;
    match (type) {
        &Type::Union(_decl, _variant) => {
            decl = _decl;
            variant = *at(&decl.variants, _variant);
            tag = _variant;
        }
        _ => { unreachable("Expected Union Type in EXPR_UNION_INIT"); }
    }
    assert(decl.variants.length < 256, "IRGen assumes that the tag of an union fits in a single byte");
    let size = getSize(type);
    assert(size >= 1, "Expected union instance to be at least one byte");
    let start = allocateRegister(function, intoPointer(type));
    buildAlloca(function, span, start, size);
    let empty = allocateRegister(function, type);
    buildCreateUnion(function, span, empty);
    buildStore(function, span, start, empty);
    let usizeType = wrap(Type::Prim(PrimType::Usize));
    let sizeReg = allocateRegister(function, usizeType);
    let offsetReg = allocateRegister(function, usizeType);
    let tmp = allocateRegister(function, intoPointer(type));
    let base = allocateRegister(function, intoPointer(type));
    buildMove(function, span, tmp, start);
    {
        // tag
        let u8 = wrap(Type::Prim(PrimType::U8));
        let tagReg = allocateRegister(function, u8);
        buildLoadInteger(function, span, tagReg, u8, tag);
        buildStore(function, span, start, tagReg);

        // offset tmp by tag
        buildLoadInteger(function, span, sizeReg, usizeType, 1);
        buildPtrToInt(function, span, tmp, tmp);
        buildBinaryOp(function, span, INSTR_INT_ADD, tmp, tmp, sizeReg);
        buildIntToPtr(function, span, tmp, tmp);
    }
    buildMove(function, span, base, tmp);
    match (expr) {
        &UnionExpr::Empty => {
            // nothing to do here
            // REVIEW: Maybe allow things like  union { A = 12, B = 23 }  ?
        }
        &UnionExpr::Tuple(tuple) => {
            assert(variant.kind == UNION_VARIANT_TUPLE, "UnionExpr::Tuple did not get Tuple variant");
            for (let i: usize = 0; i < tuple.args.length; i = i + 1) {
                let field: &ParsedExpr = *at(&tuple.args, i);
                let result: RegIndex = generateBytecodeExpr(this, function, field, true);
                buildLoadInteger(function, field.span, sizeReg, usizeType, getSize(getType(&field.typeState)));
                buildMemcpy(function, field.span, result, tmp, sizeReg);
                if (i != tuple.args.length - 1) {
                    buildPtrToInt(function, span, tmp, tmp);
                    buildBinaryOp(function, span, INSTR_INT_ADD, tmp, tmp, sizeReg);
                    buildIntToPtr(function, span, tmp, tmp);
                }
            }
        }
        &UnionExpr::Struct(context) => {
            assert(variant.kind == UNION_VARIANT_STRUCT, "UnionExpr::Struct did not get Struct variant");
            for (let i: usize = 0; i < context.context.fieldLength; i = i + 1) {
                let name: Token = getFieldNameAtIndex(&context.context, i);
                let field: &ParsedExpr = getFieldExprAtIndex(&context.context, i);
                let result: RegIndex = generateBytecodeExpr(this, function, field, true);
                {
                    let index: usize = 0;
                    let offset: usize = 0;
                    getFieldIndexAndOffset(variant, &name.content, &index, &offset);
                    buildLoadInteger(function, field.span, offsetReg, usizeType, offset);
                    buildPtrToInt(function, span, base, base);
                    buildPtrToInt(function, span, tmp, tmp);
                    buildBinaryOp(function, span, INSTR_INT_ADD, tmp, base, offsetReg);
                    buildIntToPtr(function, span, tmp, tmp);
                    buildIntToPtr(function, span, base, base);
                }
                buildLoadInteger(function, field.span, sizeReg, usizeType, getSize(getType(&field.typeState)));
                buildMemcpy(function, field.span, result, tmp, sizeReg);
            }
        }
        _ => { unreachable(); }
    }
    if (needsPtr) {
        return start;
    } else {
        let dst = allocateRegister(function, type);
        buildLoad(function, span, dst, start);
        return dst;
    }
}

func generateBytecodeExprAs(this: &IRGen, function: &IRFunc, expr: &ParsedExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprAs");
    let orig: &ParsedExpr = null;
    let typeNode: &ParsedTypeNode = null;
    match (expr.data) {
        ExprData::As(_orig, _type) => { orig = _orig; typeNode = _type; }
        _ => { unreachable(); }
    }
    let result: RegIndex = generateBytecodeExpr(this, function, orig, false);
    let current: &Type = getType(&orig.typeState);
    let target: &Type = getType(&typeNode.typeState);
    let dst: RegIndex = allocateRegister(function, target);
    if (isInteger(current) && isPointer(target)) {
        buildIntToPtr(function, expr.span, dst, result);
    } else if (isPointer(current) && isInteger(target)) {
        buildPtrToInt(function, expr.span, dst, result);
    } else if (isPointer(current) && isPointer(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isAny(current) && isFunction(target)) {
        buildMove(function, expr.span, dst, result);
    } else if (isFunction(current) && isAny(target)) {
        buildMove(function, expr.span, dst, result);
    } else if ((isChar(current) || isInteger(current)) && (isChar(target) || isInteger(target))) {
        if (getSize(current) < getSize(target)) {
            if (isSignedInteger(current)) {
                buildIntSignExtend(function, expr.span, dst, result, getSize(target) * 8);
            } else {
                buildIntZeroExtend(function, expr.span, dst, result, getSize(target) * 8);
            }
        } else if (getSize(current) > getSize(target)) {
            buildIntTruncate(function, expr.span, dst, result, getSize(target) * 8);
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else if (isInteger(current) && isFloat(target)) {
        if (getSize(target) == 4) buildIntToF32(function, expr.span, dst, result);
        else if (getSize(target) == 8) buildIntToF64(function, expr.span, dst, result);
        else unreachable("int to float");
    } else if (isFloat(current) && isInteger(target)) {
        if (getSize(current) == 4) buildF32ToInt(function, expr.span, dst, result);
        else if (getSize(current) == 8) buildF64ToInt(function, expr.span, dst, result);
        else unreachable("float to int");
    } else if (isFloat(current) && isFloat(target)) {
        if (getSize(current) < getSize(target)) {
            assert(getSize(current) == 4);
            assert(getSize(target) == 8);
            buildF32ToF64(function, expr.span, dst, result);
        } else if (getSize(current) > getSize(target)) {
            assert(getSize(current) == 8);
            assert(getSize(target) == 4);
            buildF64ToF32(function, expr.span, dst, result);
        } else {
            buildMove(function, expr.span, dst, result);
        }
    } else {
        unreachable("Exhaustive handling of variations in generateBytecodeExprAs");
    }
    return dst;
}
func generateBytecodeExprPathAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprPathAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else if (isUnion(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    } else {
        unreachable("generateBytecodeExprModuleAccess: Unexpected type of LHS");
    }
}

func generateBytecodeExprMemberAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprMemberAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let instance: &Type = getType(&lhs.typeState);
    if (isModule(instance)) {
        return generateBytecodeExpr(this, function, rhs, needsPtr);
    }
    assert(isStruct(instance) || isStructPointer(instance), "Expected (ptr to) struct in MemberAccess");
    let result: RegIndex = generateBytecodeExpr(this, function, lhs, !isStructPointer(instance));
    let _t: &Type = getRegister(function, result).typ;
    assert(isStruct(_t) || isStructPointer(_t), "Expected (ptr to) struct in Field Access");
    if (!isStructPointer(_t)) {
        let t1: &Type = intoPointer(_t);
        let alloca: RegIndex = allocateRegister(function, t1);
        buildAlloca(function, lhs.span, alloca, getSize(_t));
        buildStore(function, lhs.span, alloca, result);
        result = alloca;
        _t = t1;
    }
    let decl: &ParsedStructDecl = null;
    match (_t) {
        &Type::Ptr(&Type::Struct(_decl)) => { decl = _decl; }
        _ => { unreachable("Expected ptr to struct in Field Access"); }
    }
    // `result` contains a pointer to a struct instance at this point
    let name: Token = blank;
    match (rhs.data) {
        ExprData::Ident(ident) => { name = ident.name; }
        _ => { unreachable("Expected Identifier as RHS of member access"); }
    }
    let index: usize = getFieldIndex(decl, &name.content);
    let _f: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, index);
    let fieldType: &Type = getType(&_f.typeState);
    let fieldPtr: RegIndex = allocateRegister(function, intoPointer(fieldType));
    buildGetFieldPtr(function, lhs.span, fieldPtr, result, index);
    if (needsPtr) {
        return fieldPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, fieldType);
        buildLoad(function, lhs.span, dst, fieldPtr);
        return dst;
    }
}

func prepareReturnValue(this: &IRGen, span: Span, function: &IRFunc, base: RegIndex, args: RegIndexList, retType: &Type, retPtr: RegIndex, needsPtr: bool) -> RegIndex {
    let retVal: RegIndex = blank;
    if (getSize(retType) > 8) {
        let reg: RegIndex = allocateRegister(function, retType);
        buildCall(function, span, retPtr, base, args);
        if (needsPtr) {
            retVal = retPtr;
        } else {
            buildLoad(function, span, reg, retPtr);
            retVal = reg;
        }
    } else {
        if (isStruct(retType)) {
            let reg: RegIndex = getRegisterForSize(this, function, getSize(retType));
            buildCall(function, span, reg, base, args);
            let v: RegIndex = allocateRegister(function, retType);
            let t: &Type = getRegister(function, v).typ;
            let r: RegIndex = allocateRegister(function, intoPointer(t));
            let s: usize = getSize(t);
            assert(s <= 8);
            buildAlloca(function, span, r, s);
            buildStore(function, span, r, reg);
            if (needsPtr) {
                retVal = r;
            } else {
                buildLoad(function, span, v, r);
                retVal = v;
            }
        } else {
            let reg: RegIndex = allocateRegister(function, retType);
            buildCall(function, span, reg, base, args);
            if (needsPtr) {
                let tempAlloc: RegIndex = allocateRegister(function, intoPointer(retType));
                buildAlloca(function, span, tempAlloc, getSize(retType));
                buildStore(function, span, tempAlloc, reg);
                retVal = tempAlloc;
            } else {
                retVal = reg;
            }
        }
    }
    let ft: &Type = getRegister(function, base).typ;
    if (isPointer(ft)) ft = getUnderlyingType(ft, true);
    assert(isFunction(ft), "IRGen: Base is not a function");
    if (isNoreturn(ft)) {
        buildUnreachable(function, span);
    }
    return retVal;
}

func generateBytecodeExprIndexedAccess(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprIndexedAccess");
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsType: &Type = getType(&lhs.typeState);
    assert(isArray(lhsType) || isPointer(lhsType), "Expected Ptr or Array as LHS in IndexedAccess");
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, isArray(lhsType));
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isPointer(getRegister(function, lhsReg).typ), "Expected Ptr as LHS in IndexedAccess");
    assert(isInteger(getRegister(function, rhsReg).typ), "Expected Int as RHS in IndexedAccess");
    let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
    let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
    if (isArray(lhsType)) {
        // if (index >= size) panic("Index out of bounds");
        let arrType: &Type = getType(&lhs.typeState);
        let elemCount: usize = getSize(arrType) / getSize(type);
        let cond: RegIndex = allocateRegister(function, boolType);
        let size: RegIndex = allocateRegister(function, usizeType);
        let panic: IRBlockID = appendBlock(function);
        let normal: IRBlockID = appendBlock(function);
        buildLoadInteger(function, lhs.span, size, usizeType, elemCount);
        buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GTE, cond, rhsReg, size);
        buildCondBr(function, lhs.span, cond, panic, normal);

        setCurrentBlock(function, panic);
        let err: RegIndex = allocateRegister(function, wrap(Type::Ptr(wrap(Type::Prim(PrimType::Char)))));
        // FIXME: Don't use mangled name?
        let s: String = copy(&function.name);
        let _s: String = toString(&lhs.span);
        pushChar(&s, ':');
        pushString(&s, &_s);
        pushStr(&s, ": RUNTIME ERROR: Index out of bounds: Array of size ");
        pushNumber(&s, elemCount);
        pushStr(&s, " has no index %d\n");
        drop(&_s);
        buildLoadString(function, lhs.span, err, asSubStr(&s));
        let indexoob: String = newStringFromStrLit("index_oobPci64rN");
        if (!containsKey(&this.functions, &indexoob)) {
            fprintf(stderr, "%s Could not generate index check for array access!\n", FATAL_STR);
            fprintf(stderr, "%s: Reason: Could not find function `index_oob`!\n", NOTE_STR);
            fprintf(stderr, "%s: Please import `prelude.bufo` and try again.\n", NOTE_STR);
            exit(1);
        }
        let funcID: usize = getFunctionByName(this, &indexoob);
        let args: RegIndexList = blank;
        push(&args, err);
        push(&args, rhsReg);
        let reg: RegIndex = allocateRegister(function, wrap(Type::Prim(PrimType::None)));
        {
            let ft = wrap(Type::Func(blank, wrap(Type::Prim(PrimType::None)), FuncAttr {
                isVariadic: true // REVIEW: Why?
            }));
            let dst = allocateRegister(function, ft);
            buildLoadFunctionPtr(function, lhs.span, dst, funcID);
            buildCall(function, lhs.span, reg, dst, args);
        }
        buildUnreachable(function, lhs.span);
        setCurrentBlock(function, normal);
    }
    let elemPtr: RegIndex = allocateRegister(function, intoPointer(type));
    let indices: RegIndexList = blank;
    if (isArray(lhsType)) {
        let index: RegIndex = allocateRegister(function, usizeType);
        buildLoadInteger(function, lhs.span, index, usizeType, 0);
        push(&indices, index);
    }
    push(&indices, rhsReg);
    buildGetElementPtr(function, lhs.span, elemPtr, lhsReg, indices);
    if (needsPtr) {
        return elemPtr;
    } else {
        let dst: RegIndex = allocateRegister(function, type);
        buildLoad(function, lhs.span, dst, elemPtr);
        return dst;
    }
}

func generateBytecodeExprIdentifier(this: &IRGen, function: &IRFunc, expr: &IdentExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprIdentifier");
    let isGlobal: bool = false;
    let type = expr.type;
    assert(type != null, "IRGen: IdentExpr has unset type!");
    let entry: &IRScopeEntry = getIdentifierByName(this, function, expr.name.content, &isGlobal);
    if (entry != null) {
        if (function.comptimeLevel > 0 && !entry.isComptime) {
            unreachable("Crossing the boundary: comptime IR needs runtime value - The Checker should've caught this");
        }
        if (needsPtr) {
            if (isGlobal) {
                let ptrType: &Type = intoPointer(type);
                let global: RegIndex = allocateRegister(function, ptrType);
                if (entry.isComptime) {
                    let val: RegIndex = allocateRegister(function, type);
                    buildAlloca(function, expr.name.span, global, getSize(type));
                    buildFetchGlobalComptimeValue(function, expr.name.span, val, entry.ptr);
                    buildStore(function, expr.name.span, global, val);
                } else {
                    buildFetchGlobalPointer(function, expr.name.span, global, entry.ptr);
                }
                return global;
            } else {
                if (entry.isComptime) {
                    let ptrType: &Type = intoPointer(type);
                    let global: RegIndex = allocateRegister(function, ptrType);
                    let val: RegIndex = allocateRegister(function, type);
                    buildAlloca(function, expr.name.span, global, getSize(type));
                    buildFetchLocalComptimeValue(function, expr.name.span, val, entry.ptr);
                    buildStore(function, expr.name.span, global, val);
                    return global;
                } else {
                    return entry.ptr;
                }
            }
        } else {
            let val: RegIndex = allocateRegister(function, type);
            if (isGlobal) {
                if (entry.isComptime) {
                    buildFetchGlobalComptimeValue(function, expr.name.span, val, entry.ptr);
                } else {
                    buildFetchGlobalRuntimeValue(function, expr.name.span, val, entry.ptr);
                }
            } else {
                if (entry.isComptime) {
                    buildFetchLocalComptimeValue(function, expr.name.span, val, entry.ptr);
                } else {
                    buildLoad(function, expr.name.span, val, entry.ptr);
                }
            }
            return val;
        }
    } else {
        if (isModule(type)) {
            return allocateRegister(function, type);
        } else if (isFunction(type)) {
            let name: String = getMangledName(at(&funcDecls, expr.origID));
            let funcID: usize = getFunctionByName(this, &name);
            let dst = allocateRegister(function, type);
            buildLoadFunctionPtr(function, expr.name.span, dst, funcID);
            return dst;
        } else {
            unreachable("Exhaustive handling of types in generateBytecodeExprIdentifier");
        }
    }
}

func generateBytecodeExprArithmetic(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    trace("IRGen.generateBytecodeExprArithmetic");
    assert(isArithmetic(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsType: &Type = getType(&lhs.typeState);
    let rhsType: &Type = getType(&rhs.typeState);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    // OPT: Specialized 8bit, 16bit, etc. variations
    match (expr) {
        &BinaryExpr::Plus(_,_) => {
            if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
            } else if (isPointer(lhsType) && isInteger(rhsType)) {
                assert(isPointer(type), "PTR + INT expected to be PTR");
                buildPtrToInt(function, lhs.span, lhsReg, lhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
                buildIntToPtr(function, lhs.span, dst, dst);
            } else if (isInteger(lhsType) && isPointer(rhsType)) {
                assert(isPointer(type), "INT + PTR expected to be PTR");
                buildPtrToInt(function, lhs.span, rhsReg, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_ADD, dst, lhsReg, rhsReg);
                buildIntToPtr(function, lhs.span, dst, dst);
            } else if (isFloat(lhsType) && isFloat(rhsType)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_ADD, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_PLUS");
            }
        }
        &BinaryExpr::Sub(_,_) => {
            let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
            if ((isInteger(lhsType) || isChar(lhsType)) && (isInteger(rhsType) || isChar(rhsType))) {
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, dst, lhsReg, rhsReg);
            } else if (isPointer(lhsType) && isInteger(rhsType)) {
                assert(isPointer(type), "PTR - INT expected to be PTR");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, lhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, tmp2, tmp1, rhsReg);
                buildIntToPtr(function, lhs.span, dst, tmp2);
            } else if (isInteger(lhsType) && isPointer(rhsType)) {
                assert(isPointer(type), "INT - PTR expected to be PTR");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, tmp2, lhsReg, tmp1);
                buildIntToPtr(function, lhs.span, dst, tmp2);
            } else if (isPointer(lhsType) && isPointer(rhsType)) {
                assert(isInteger(type), "PTR - PTR expected to be INT");
                let tmp1: RegIndex = allocateRegister(function, usizeType);
                let tmp2: RegIndex = allocateRegister(function, usizeType);
                buildPtrToInt(function, lhs.span, tmp1, lhsReg);
                buildPtrToInt(function, lhs.span, tmp2, rhsReg);
                buildBinaryOp(function, lhs.span, INSTR_INT_SUB, dst, tmp1, tmp2);
            } else if (isFloat(lhsType) && isFloat(rhsType)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_SUB, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_SUB");
            }
        }
        &BinaryExpr::Mult(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_MUL, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_MUL, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_MULT");
            }
        }
        &BinaryExpr::Div(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_DIV, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_DIV, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_DIV");
            }
        }
        &BinaryExpr::Mod(_,_) => {
            if (isInteger(type)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_MOD, dst, lhsReg, rhsReg);
            } else if (isFloat(type)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_MOD, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_MOD");
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprArithmetic"); }
    }
    return dst;
}

func generateBytecodeExprComparison(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    trace("IRGen.generateBytecodeExprComparison");
    assert(isComparison(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isBoolean(type), "Comparison expected to evaluate to Bool");
    let dst: RegIndex = allocateRegister(function, type);
    // OPT: Specialized 8bit, 16bit, etc. variations
    let t: &Type = getRegister(function, lhsReg).typ;
    match (expr) {
        &BinaryExpr::CmpEq(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_EQ, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_EQ, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_EQ");
            }
        }
        &BinaryExpr::CmpNeq(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_NEQ, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_NEQ, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_NEQ");
            }
        }
        &BinaryExpr::CmpGt(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GT, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_GT, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GT");
            }
        }
        &BinaryExpr::CmpGte(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_GTE, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_GTE, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_GTE");
            }
        }
        &BinaryExpr::CmpLt(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_LT, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_LT, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LT");
            }
        }
        &BinaryExpr::CmpLte(_,_) => {
            if (isInteger(t) || isChar(t) || isPointer(t) || isBoolean(t)) {
                buildBinaryOp(function, lhs.span, INSTR_INT_CMP_LTE, dst, lhsReg, rhsReg);
            } else if (isFloat(t)) {
                buildBinaryOp(function, lhs.span, INSTR_FLOAT_CMP_LTE, dst, lhsReg, rhsReg);
            } else {
                unreachable("IRGen: Exhaustive handling of types for BIN_CMP_LTE");
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprComparison"); }
    }
    return dst;
}

func generateBytecodeExprLogical(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    trace("IRGen.generateBytecodeExprLogical");
    assert(isLogical(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    match (expr) {
        &BinaryExpr::LogAnd(_,_) => { buildBinaryOp(function, lhs.span, INSTR_LOGICAL_AND, dst, lhsReg, rhsReg); }
        &BinaryExpr::LogOr(_,_)  => { buildBinaryOp(function, lhs.span, INSTR_LOGICAL_OR, dst, lhsReg, rhsReg); }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprLogical"); }
    }
    return dst;
}

func generateBytecodeExprBitwise(this: &IRGen, function: &IRFunc, expr: &BinaryExpr, type: &Type) -> RegIndex {
    trace("IRGen.generateBytecodeExprBitwise");
    assert(isBitwise(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, false);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    let dst: RegIndex = allocateRegister(function, type);
    match (expr) {
        &BinaryExpr::BitAnd(_,_) => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_AND, dst, lhsReg, rhsReg); }
        &BinaryExpr::BitOr(_,_)  => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_OR, dst, lhsReg, rhsReg); }
        &BinaryExpr::BitXor(_,_) => { buildBinaryOp(function, lhs.span, INSTR_BITWISE_XOR, dst, lhsReg, rhsReg); }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprBitwise"); }
    }
    return dst;
}

func loadLiteral(this: &IRGen, function: &IRFunc, reg: RegIndex, tkn: &Token) -> RegIndex {
    let typ = getRegister(function, reg).typ;
    if (isInteger(typ) || isChar(typ)) {
        let _value: u64 = toU64(&tkn.content);
        let value: usize = _value as usize;
        let size: usize = bitCount(value);
        let typsize: usize = getSize(typ) * 8;
        if (isSignedInteger(typ)) size = size + 1;
        if (size > typsize) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            fprintf(stderr, "%s: %s: Integer literal (value=%llu) is too big for target type %s.\n",
                loc.buffer, ERR_STR, _value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        buildLoadInteger(function, tkn.span, reg, typ, value);
    } else if (isFloat(typ)) {
        let value: f64 = toF64(&tkn.content);
        assert(value >= 0, "Expected FloatLit value to be positive");
        let typmax: f64 = getMaxFloatValue(typ);
        if (value >= typmax) {
            let loc = toString(&tkn.span);
            let ts = toString(typ);
            fprintf(stderr, "%s: %s: Float literal (value=%f) is too big for target type %s.\n",
                loc.buffer, ERR_STR, value, ts.buffer);
            drop(&ts);
            drop(&loc);
            this.error = true;
        }
        if (getSize(typ) == 4) buildLoadF32(function, tkn.span, reg, value as f32);
        else if (getSize(typ) == 8) buildLoadF64(function, tkn.span, reg, value);
        else unreachable("load float");
    } else {
        unreachable("loadLiteral: Expected Integer, Char or Float");
    }
    return reg;
}

func generateBytecodeExprLiteral(this: &IRGen, function: &IRFunc, expr: &ParsedExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprLiteral");
    assert(isLiteral(expr));
    let t: &Type = getType(&expr.typeState);
    let reg: RegIndex = allocateRegister(function, t);
    match (&expr.data) {
        &ExprData::IntLit(value)  => { loadLiteral(this, function, reg, &value); }
        &ExprData::StrLit(value)  => { buildLoadString(function, expr.span, reg, value.content); }
        &ExprData::True           => { buildLoadBool(function, expr.span, reg, 1); }
        &ExprData::False          => { buildLoadBool(function, expr.span, reg, 0); }
        &ExprData::Null           => { buildLoadNull(function, expr.span, reg); }
        &ExprData::CharLit(value) => { buildLoadInteger(function, expr.span, reg, t, getChar(&value.content, 0) as usize); }
        &ExprData::ArrayLit(context) => {
            assert(isArray(t), "ArrayLit expected to be array");
            if (getSize(t) > 4096) warning("Array Literal is big and slows down the IR");
            if (context.size == 0) {
                if (getSize(t) == 0 && *flags.warnSimple) {
                    // array literal of the form []
                    let loc = toString(&expr.span);
                    fprintf(stderr, "%s: %s: Array is zero-sized and can never be indexed into.\n", loc.buffer, WARN_STR);
                    drop(&loc);
                }
                buildCreateArray(function, expr.span, reg);
                for (let i: usize = 0; i < context.elemLength; i = i + 1) {
                    let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&context, i));
                    let result: RegIndex = generateBytecodeExpr(this, function, elem, false);
                    buildInsertValue(function, expr.span, reg, i, result);
                }
                if (needsPtr) {
                    let subType: &Type = intoPointer(t);
                    let ptr: RegIndex = allocateRegister(function, subType);
                    buildAlloca(function, expr.span, ptr, getSize(t));
                    buildStore(function, expr.span, ptr, reg);
                    return ptr;
                } else {
                    return reg;
                }
            } else {
                let elem: &ParsedExpr = at(&exprs, getElementAtIndex(&context, 0));
                let value: RegIndex = generateBytecodeExpr(this, function, elem, false);
                let usizeType: &Type = wrap(Type::Prim(PrimType::Usize));
                let boolType: &Type = wrap(Type::Prim(PrimType::Bool));
                let elemType: &Type = getType(&elem.typeState);
                let arrayPtr: RegIndex = allocateRegister(function, intoPointer(t));
                let zero: RegIndex = allocateRegister(function, usizeType);
                let one: RegIndex = allocateRegister(function, usizeType);
                let index: RegIndex = allocateRegister(function, usizeType);
                let indexPtr: RegIndex = allocateRegister(function, intoPointer(usizeType));
                let size: RegIndex = allocateRegister(function, usizeType);
                let cond: RegIndex = allocateRegister(function, boolType);
                let elemPtr: RegIndex = allocateRegister(function, elemType);

                let start: IRBlockID = appendBlock(function);
                let body: IRBlockID = appendBlock(function);
                let end: IRBlockID = appendBlock(function);

                buildAlloca(function, expr.span, arrayPtr, getSize(t));
                buildAlloca(function, expr.span, indexPtr, getSize(usizeType));
                buildLoadInteger(function, expr.span, zero, usizeType, 0);
                buildLoadInteger(function, expr.span, one, usizeType, 1);
                buildStore(function, expr.span, indexPtr, zero);
                buildLoadInteger(function, expr.span, size, usizeType, context.size);
                buildBr(function, expr.span, start);

                setCurrentBlock(function, start);
                buildLoad(function, expr.span, index, indexPtr);
                buildBinaryOp(function, expr.span, INSTR_INT_CMP_LT, cond, index, size);
                buildCondBr(function, expr.span, cond, body, end);

                setCurrentBlock(function, body);
                let indices: RegIndexList = blank;
                push(&indices, zero);
                push(&indices, index);
                buildGetElementPtr(function, expr.span, elemPtr, arrayPtr, indices);
                buildStore(function, expr.span, elemPtr, value);

                buildLoad(function, expr.span, index, indexPtr);
                buildBinaryOp(function, expr.span, INSTR_INT_ADD, index, index, one);
                buildStore(function, expr.span, indexPtr, index);
                buildBr(function, expr.span, start);

                setCurrentBlock(function, end);
                if (needsPtr) {
                    return arrayPtr;
                } else {
                    buildLoad(function, expr.span, reg, arrayPtr);
                    return reg;
                }
            }
        }
        _ => { unreachable("Exhaustive handling of ops in generateBytecodeExprLiteral"); }
    }
    if (needsPtr) {
        let tempAlloc: RegIndex = allocateRegister(function, intoPointer(t));
        buildAlloca(function, expr.span, tempAlloc, getSize(t));
        buildStore(function, expr.span, tempAlloc, reg);
        return tempAlloc;
    }
    return reg;
}

func generateBytecodeExprAssignment(this: &IRGen, function: &IRFunc, expr: &BinaryExpr) -> RegIndex {
    trace("IRGen.generateBytecodeExprAssignment");
    assert(isAssignment(expr));
    let lhs: &ParsedExpr = null;
    let rhs: &ParsedExpr = null;
    extractOperands(expr, &lhs, &rhs);
    let lhsReg: RegIndex = generateBytecodeExpr(this, function, lhs, true);
    let rhsReg: RegIndex = generateBytecodeExpr(this, function, rhs, false);
    assert(isPointer(getRegister(function, lhsReg).typ), "Assignment expected Ptr as LHS");
    buildStore(function, lhs.span, lhsReg, rhsReg);
    return rhsReg;
}

func generateBytecodeExprUnary(this: &IRGen, function: &IRFunc, span: Span, expr: &UnaryExpr, type: &Type, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprUnary");
    match (expr) {
        &UnaryExpr::Comptime(subExpr) => {
            startComptime(function);
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let r: RegIndex = allocateRegister(function, type);
            endComptime(function);
            buildFetchLocalComptimeValue(function, span, r, result);
            if (needsPtr) {
                let subType: &Type = intoPointer(type);
                let ptr: RegIndex = allocateRegister(function, subType);
                buildAlloca(function, span, ptr, getSize(type));
                buildStore(function, span, ptr, r);
                return ptr;
            } else {
                return r;
            }
        }
        &UnaryExpr::Deref(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let ptr: &IRReg = getRegister(function, result);
            assert(isPointer(ptr.typ), "Expected Ptr SubExpr in Unary Deref");
            if (needsPtr) {
                return result;
            } else {
                let val: RegIndex = allocateRegister(function, type);
                buildLoad(function, span, val, result);
                return val;
            }
        }
        &UnaryExpr::Ref(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, true);
            let ptrReg: &IRReg = getRegister(function, result);
            if (needsPtr || !isPointer(ptrReg.typ)) {
                let subType: &Type = intoPointer(ptrReg.typ);
                let ptr: RegIndex = allocateRegister(function, subType);
                buildAlloca(function, span, ptr, getSize(ptrReg.typ));
                buildStore(function, span, ptr, result);
                return ptr;
            } else {
                return result;
            }
        }
        &UnaryExpr::Not(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            let r: RegIndex = allocateRegister(function, type);
            buildLogicalNot(function, span, r, result);
            return r;
        }
        &UnaryExpr::Negate(subExpr) => {
            let result: RegIndex = generateBytecodeExpr(this, function, subExpr, false);
            if (isInteger(type)) {
                let zero: RegIndex = allocateRegister(function, type);
                buildLoadInteger(function, span, zero, type, 0);
                buildBinaryOp(function, span, INSTR_INT_SUB, result, zero, result);
            } else if (isFloat(type)) {
                let zero: RegIndex = allocateRegister(function, type);
                if (getSize(type) == 4) buildLoadF32(function, span, zero, 0);
                else if (getSize(type) == 8) buildLoadF64(function, span, zero, 0);
                else unreachable("negation float");
                buildBinaryOp(function, span, INSTR_FLOAT_SUB, result, zero, result);
            } else {
                unreachable("Exhaustive handling of negation variants in generateBytecodeExprUnary");
            }
            return result;
        }
        _ => { }
    }
    unreachable("Exhaustive handling of ops in generateBytecodeExprUnary");
}

func prepareParameter(this: &IRGen, function: &IRFunc, index: usize, span: Span, name: SubStr, typ: &Type, retValue: bool) {
    trace("IRGen.prepareParameter");
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        let value: RegIndex = allocateRegister(function, t);
        buildGetParam(function, span, value, index, getSize(t));
        // value contains prepared struct
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        if (isPointer(t)) {
            let instance: RegIndex = allocateRegister(function, typ);
            buildLoad(function, span, instance, value);

            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, instance);
            addEntry(last(&function.scopes), name, allocReg, false);
        } else {
            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, value);
            addEntry(last(&function.scopes), name, allocReg, false);
        }
    } else if (getSize(typ) > 8) {
        let t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        let value: RegIndex = allocateRegister(function, t);
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        buildGetParam(function, span, value, index, getSize(t));
        let instance: RegIndex = allocateRegister(function, typ);
        buildLoad(function, span, instance, value);

        buildAlloca(function, span, allocReg, getSize(typ));
        buildStore(function, span, allocReg, instance);
        addEntry(last(&function.scopes), name, allocReg, false);
    } else {
        let allocType: &Type = intoPointer(typ);
        let allocReg: RegIndex = allocateRegister(function, allocType);
        let value: RegIndex = allocateRegister(function, typ);
        buildGetParam(function, span, value, index, getSize(typ));

        if (retValue) {
            assert(index == 0);
            (*function).retPtr = value;
        } else {
            buildAlloca(function, span, allocReg, getSize(typ));
            buildStore(function, span, allocReg, value);
            addEntry(last(&function.scopes), name, allocReg, false);
        }
    }
}

func getRegisterForSize(this: &IRGen, function: &IRFunc, size: usize) -> RegIndex {
    trace("IRGen.getRegisterForSize");
    let v: RegIndex = blank;
    if (size <= 1) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U8)));
    } else if (size <= 2) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U16)));
    } else if (size <= 4) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U32)));
    } else if (size <= 8) {
        v = allocateRegister(function, wrap(Type::Prim(PrimType::U64)));
    } else {
        unreachable("getRegisterForSize called with size > 8");
    }
    return v;
}

func prepareArgument(this: &IRGen, function: &IRFunc, span: Span, value: RegIndex, typ: &Type) -> RegIndex {
    trace("IRGen.prepareArgument");
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let alloc: RegIndex = allocateRegister(function, intoPointer(typ));
        buildAlloca(function, span, alloc, size);
        buildStore(function, span, alloc, value);
        if (size > 8) return alloc;
        let v: RegIndex = getRegisterForSize(this, function, size);
        buildLoad(function, span, v, alloc);
        return v;
    } else if (getSize(typ) > 8) {
        // Following the ABI, all parameters that don't fit in a register get passed by pointer
        let tempAlloc: RegIndex = allocateRegister(function, intoPointer(typ));
        buildAlloca(function, span, tempAlloc, getSize(typ));
        buildStore(function, span, tempAlloc, value);
        return tempAlloc;
    } else {
        return value;
    }
}

func generateBytecodeExprCall(this: &IRGen, function: &IRFunc, expr: &CallExpr, needsPtr: bool) -> RegIndex {
    trace("IRGen.generateBytecodeExprCall");
    let base = generateBytecodeExpr(this, function, expr.base, false);
    let typ: &Type = expr.retType;
    assert(typ != null, "IRGen: CallExpr has invalid return type");
    let args: RegIndexList = blank;
    let retPtr: RegIndex = blank;
    if (getSize(typ) > 8) {
        retPtr = allocateRegister(function, intoPointer(typ));
        buildAlloca(function, expr.span, retPtr, getSize(typ));
        push(&args, retPtr);
    }
    for (let i: usize = 0; i < expr.args.length; i = i + 1) {
        let arg: &ParsedExpr = *at(&expr.args, i);
        let argType: &Type = getType(&arg.typeState);
        let result: RegIndex = generateBytecodeExpr(this, function, arg, false);
        push(&args, prepareArgument(this, function, arg.span, result, argType));
    }
    return prepareReturnValue(this, expr.span, function, base, args, typ, retPtr, needsPtr);
}

func newIRGenerator() -> IRGen {
    return IRGen {
        globalScope: IRFunc {
            name: newStringFromStrLit("__global__"),
            originalID: funcDecls.length + 1,
            comptimeLevel: 0,
        },
    };
}
