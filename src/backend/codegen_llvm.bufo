import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/hashmaps.bufo";
import "../util/arena.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./irgen.bufo";
import "./interp.bufo";
import "./LLVM/bindings.bufo";
import "./LLVM/module.bufo";
import "./LLVM/context.bufo";
import "./LLVM/builder.bufo";
import "./LLVM/values.bufo";
import "./LLVM/types.bufo";
import "./LLVM/basic_block.bufo";
import "./LLVM/pass_manager.bufo";
import "./LLVM/target.bufo";

struct RegValue {
    isLLVM: bool;
    regValue: InterpReg;
    llvmValue: LLVMValue;
}
func equals(this: &RegValue, other: &RegValue) -> bool {
    todo_with_msg("RegValue.equals");
}
func asInterp(this: &RegValue, err: &char) -> InterpReg {
    assert(!this.isLLVM, err);
    return this.regValue;
}
func asLLVM(this: &RegValue, err: &char) -> LLVMValue {
    assert(this.isLLVM, err);
    return this.llvmValue;
}

struct LLVMCodegen {
    llvmContext: LLVMContext;
    llvmModule: LLVMModule;
    llvmBuilder: LLVMBuilder;
    llvmTargetMachine: LLVMTargetMachine;
    irGen: &IRGen;
    interp: &IRInterp;
    global: RegValueList;
}

func generateExecutable(this: &LLVMCodegen, outPath: SubStr) -> bool {
    // struct IRGen {
    //     globalScope: IRFunc;
    //     functions: String_IRFuncHashMap;
    trace("LLVMCodegen.generateExecutable");
    let fns: IRFuncList = asList(&this.irGen.functions);
    if (PRINT_DEBUG) {
        dumpInstructions(&this.irGen.globalScope);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            let f: &IRFunc = at(&fns, i);
            dumpInstructions(f);
        }
    }
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        generateLLVMFunctionHeader(this, at(&fns, i));
    }
    if (!generateEntryPoint(this)) return false;
    if (!generateGlobal(this, &this.irGen.globalScope)) return false;
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        let f: &IRFunc = at(&fns, i);
        if (!generateFunction(this, i, f)) return false;
    }
    if (PRINT_DEBUG) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_before.ll"));
    if (!verify(&this.llvmModule)) return false;
    let pm: LLVMPassManager = createPassManager(&this.llvmModule);
    addPromoteMemoryToRegisterPass(&pm);
    addAlwaysInlinerPass(&pm);
    addCFGSimplificationPass(&pm);
    addGlobalDCEPass(&pm);
    while (runOn(&pm, this.llvmModule)) {}
    if (PRINT_DEBUG) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_after.ll"));
    let objPath: String = toString(&outPath);
    pushStr(&objPath, ".obj");
    if (*flags.verbose) {
        printf("[INFO] Saving object file at %s\n", objPath.buffer);
    }
    writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMObjectFile, objPath.buffer);
    if (*flags.emitASM) {
        let asmPath = toString(&outPath);
        pushStr(&asmPath, ".s");
        printf("[INFO] Saving assembly code in %s\n", asmPath.buffer);
        writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMAssemblyFile, asmPath.buffer);
        drop(&asmPath);
    }
    if (*flags.emitLLVM) {
        let llvmPath = toString(&outPath);
        pushStr(&llvmPath, ".ll");
        printf("[INFO] Saving LLVM IR in %s\n", llvmPath.buffer);
        writeToFile(&this.llvmModule, asSubStr(&llvmPath));
        drop(&llvmPath);
    }
    return true;
}
func generateEntryPoint(this: &LLVMCodegen) -> bool {
    trace("LLVMCodegen.generateEntryPoint");
    // FIXME: Currently we hardcode the entry point.
    //        It would be cooler if the prelude or standard library did that.
    //        Needs more features though, like being able to provide custom
    //        names that overwrite the mangling
    let mainName: SubStr = newSubStrOfStrLit("maini32PPcri32");
    if (!hasFunction(&this.llvmModule, mainName)) {
        fprintf(stderr, "%s Could not find main function!\n", FATAL_STR);
        fprintf(stderr, "%s: The compiler currently requires that the input file also defines a main function.\n", NOTE_STR);
        fprintf(stderr, "%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n", NOTE_STR);
        return false;
    }
    let mainFunc: LLVMValue = getFunction(&this.llvmModule, mainName);
    let retType: LLVMType = createIntegerType(&this.llvmContext, 32);
    let params: LLVMTypeList = blank;
    push(&params, createIntegerType(&this.llvmContext, 32));
    let _p: LLVMType = createIntegerType(&this.llvmContext, 8);
    push(&params, intoPointerType(&_p));
    let retFnType: LLVMType = intoFunctionType(&retType, params, false);
    assert(!hasFunction(&this.llvmModule, newSubStrOfStrLit("main")));
    let main: LLVMValue = addFunction(&this.llvmModule, newSubStrOfStrLit("main"), retFnType);
    let entry: LLVMBasicBlock = appendBasicBlock(&this.llvmContext, main, newSubStrOfStrLit("entry"));
    positionAtEnd(&this.llvmBuilder, entry);
    let args: LLVMValueList = blank;
    push(&args, getNthParam(&main, 0));
    push(&args, getNthParam(&main, 1));
    let v: LLVMValue = buildCall(&this.llvmBuilder, mainFunc, retFnType, args, retType, newSubStrOfStrLit("entry"));
    buildReturn(&this.llvmBuilder, v);
    return true;
}
func generateGlobal(this: &LLVMCodegen, global: &IRFunc) -> bool {
    trace("LLVMCodegen.generateGlobal");
    this.global = blank;
    initBlank(&this.global, global.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(global);
    let llvmFunc: LLVMValue = blank;
    let blocks: LLVMBasicBlockList = blank;
    pushRegisterStack(this.interp, defaultSpan(), funcSize);
    this.interp.globalRegisters = &this.global;
    this.interp.globalRegBase = this.interp.regStackBase;
    assert(global.blocks.length == 1, "Expected to only find one IRBlock in global scope");
    generateBlock(this, &llvmFunc, global, &blocks, at(&global.blocks, 0), &this.global);
    return true;
}

func generateLLVMFunctionHeader(this: &LLVMCodegen, irFunc: &IRFunc) {
    let llvmFunc: LLVMValue = blank;
    let function: &ParsedFuncDecl = getFuncNode(irFunc);
    let llvmFuncType = generateLLVMFunctionType(this, getType(&function.typeState));
    let llvmFuncValue: LLVMValue = addFunction(&this.llvmModule, asSubStr(&irFunc.name), llvmFuncType);
    if (hasAttribute(irFunc, ATTR_NORETURN)) {
        let id = LLVM::GetEnumAttributeKindForName("noreturn", 8 /* sizeof "noreturn" */);
        assert(id != 0, "Could not get noreturn attribute from LLVM");
        addAttribute(&llvmFuncValue, U32_MAX, createEnumAttribute(&this.llvmContext, id, 1));
    }
    (*irFunc).llvmFunc = llvmFuncValue;
    let origFunc: &IRFunc = get(&this.irGen.functions, &irFunc.name);
    (*origFunc).llvmFunc = llvmFuncValue;
}

func prepareReturnType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareReturnType");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        } else if (size <= 2) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
        } else if (size <= 4) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
        } else if (size <= 8) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
        } else {
            t = newType(TYPE_KIND_POINTER, TYPE_U8);
        }
        return generateLLVMType(this, t);
    } else {
        return generateLLVMType(this, typ);
    }
}

func prepareParameter(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareParameter");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        } else if (size <= 2) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
        } else if (size <= 4) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
        } else if (size <= 8) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
        } else {
            t = newType(TYPE_KIND_POINTER, TYPE_U8);
        }
        return generateLLVMType(this, t);
    } else if (getSize(typ) > 8) {
        return generateLLVMType(this, at(&types, intoPointer(typ)));
    } else {
        return generateLLVMType(this, typ);
    }
}

func getLLVMTypeSize(this: &LLVMCodegen, typ: &LLVMType) -> usize {
    trace("LLVMCodegen.getLLVMTypeSize");
    let data: LLVMTargetData = getTargetData(&this.llvmTargetMachine);
    let s1: usize = getStoreSize(&data, typ);
    let s2: usize = getABISize(&data, typ);
    let s3: usize = getBitSize(&data, typ) / 8;
    assert(s1 == s2 && s1 == s3 && s2 == s3, "LLVMTargetData returned different type sizes");
    return s1;
}

func generateFunction(this: &LLVMCodegen, index: usize, irFunc: &IRFunc) -> bool {
    trace("LLVMCodegen.generateFunction");
    if (isExtern(irFunc)) return true;
    let llvmFuncValue: LLVMValue = irFunc.llvmFunc;
    assert(!LLVM::isNull(llvmFuncValue.ref));
    let blocks: LLVMBasicBlockList = blank;
    initBlank(&blocks, irFunc.blocks.length);
    assert(blocks.length != 0, "Every IRFunc has at least one instruction");
    *(at(&blocks, 0)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("entry"));
    for (let i: usize = 1; i < irFunc.blocks.length; i = i + 1) {
        *(at(&blocks, i)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("b"));
    }
    let regs: RegValueList = blank;
    initBlank(&regs, irFunc.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    pushRegisterStack(this.interp, irFunc.span, funcSize);
    for (let i: usize = 0; i < irFunc.blocks.length; i = i + 1) {
        let block: &IRBlock = getBlockByID(irFunc, IRBlockID { i: i });
        positionAtEnd(&this.llvmBuilder, *at(&blocks, i));
        generateBlock(this, &llvmFuncValue, irFunc, &blocks, block, &regs);
    }
    popRegisterStack(this.interp, irFunc.span, funcSize);
    return true;
}
func generateBlock(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    llvmBlocks: &LLVMBasicBlockList,
    block: &IRBlock,
    regs: &RegValueList,
) {
    for (let i: usize = 0; i < block.instructions.length; i = i + 1) {
        let instr: &IRInstr = at(&block.instructions, i);
        let val: RegValue = blank;
        if (instr.isComptime) {
            val = RegValue {
                isLLVM: false,
                regValue: evaluateSingle(this.interp, irFunc, instr, regs, false),
                llvmValue: blank,
            };
        } else {
            val = RegValue {
                isLLVM: true,
                regValue: blank,
                llvmValue: generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs),
            };
        }
        if (!isTerminator(instr)) {
            *(at(regs, instr.dst.i)) = val;
        }
    }
}

func generateLLVMInstr(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    blocks: &LLVMBasicBlockList,
    instr: &IRInstr,
    regs: &RegValueList,
) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMInstr");
    let isGlobal: bool = LLVM::isNull(llvmFunc.ref);
    if (instr.kind == INSTR_ALLOCA) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isPointer(reg.typ), "LLVM Alloca expected ptr dst");
        let t: &Type = getUnderlyingType(reg.typ, false);
        let typ: LLVMType = generateLLVMType(this, t);
        if (isGlobal) {
            return addGlobal(&this.llvmModule, typ, 0, newSubStrOfStrLit("g"));
        } else {
            return buildAlloca(&this.llvmBuilder, typ, newSubStrOfStrLit("v"));
        }
    } else if (instr.kind == INSTR_GET_PARAM) {
        assert(!isGlobal);
        let param: LLVMValue = getNthParam(llvmFunc, instr.src.i);
        setName(&param, newSubStrOfStrLit("p"));
        return param;
    } else if (instr.kind == INSTR_STORE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Store");
        let srcVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Store");
        if (isGlobal) {
            setInitializer(&dstVal, srcVal);
        } else {
            buildStore(&this.llvmBuilder, dstVal, srcVal);
        }
        return dstVal;
    } else if (instr.kind == INSTR_LOAD_FUNCTION_PTR) {
        let called: &IRFunc = at(&this.irGen.functions, instr.src.i);
        return called.llvmFunc;
    } else if (instr.kind == INSTR_LOAD) {
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: &RegValue = at(regs, instr.src.i);
        if (reg.isLLVM) {
            let srcVal: LLVMValue = asLLVM(reg, "LLVM Load");
            if (isGlobal) {
                todo_with_msg("LLVM global load");
            } else {
                return buildLoad(&this.llvmBuilder, dstTyp, srcVal, newSubStrOfStrLit("load"));
            }
        } else {
            let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM Load from comptime"));
            return generateLLVMValueFromComptimeValue(this, typ, *(start as &usize) as &u8);
        }
    } else if (instr.kind == INSTR_MOVE) {
        return asLLVM(at(regs, instr.src.i), "LLVM Move");
    } else if (instr.kind == INSTR_FETCH_GLOBAL_PTR) {
        let val: &RegValue = at(&this.global, instr.src.i);
        if (val.isLLVM) {
            return asLLVM(val, "We just checked if it is LLVM");
        } else {
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            return generateLLVMValueFromComptimePtr(this, typ, reg);
        }
    } else if (instr.kind == INSTR_FETCH_GLOBAL_VALUE) {
        let val: &RegValue = at(&this.global, instr.src.i);
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        assert(val.isLLVM, "FetchGlobalValue got non-LLVM src");
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: LLVMValue = asLLVM(val, "We just checked if it is LLVM");
        return buildLoad(&this.llvmBuilder, dstTyp, reg, newSubStrOfStrLit("fetchglobalval"));
    } else if (instr.kind == INSTR_FETCH_COMPTIME_VALUE) {
        if (instr.op1.i == 1) {
            // Global fetch
            let val: &RegValue = at(&this.global, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!val.isLLVM, "FetchComptimeValue global=1 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getGlobalPointer(this.interp, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        } else {
            // Local fetch
            let val: &RegValue = at(regs, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!val.isLLVM, "FetchComptimeValue global=0 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getComptimePointer(this, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        }
    } else if (instr.kind == INSTR_INT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntAdd(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("iadd"));
    } else if (instr.kind == INSTR_INT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntSub(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("isub"));
    } else if (instr.kind == INSTR_INT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMul(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imul"));
    } else if (instr.kind == INSTR_INT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntDiv(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("idiv"));
    } else if (instr.kind == INSTR_INT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMod(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imod"));
    } else if (instr.kind == INSTR_FLOAT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddFloat");
        return buildFloatAdd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fadd"));
    } else if (instr.kind == INSTR_FLOAT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubFloat");
        return buildFloatSub(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fsub"));
    } else if (instr.kind == INSTR_FLOAT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulFloat");
        return buildFloatMul(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmul"));
    } else if (instr.kind == INSTR_FLOAT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivFloat");
        return buildFloatDiv(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fdiv"));
    } else if (instr.kind == INSTR_FLOAT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModFloat");
        return buildFloatMod(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmod"));
    } else if (instr.kind == INSTR_INT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpNeq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntNE, lhsVal, rhsVal, newSubStrOfStrLit("icmpne"));
    } else if (instr.kind == INSTR_INT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpEq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntEQ, lhsVal, rhsVal, newSubStrOfStrLit("icmpeq"));
    } else if (instr.kind == INSTR_INT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLT, lhsVal, rhsVal, newSubStrOfStrLit("icmpslt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULT, lhsVal, rhsVal, newSubStrOfStrLit("icmpult"));
    } else if (instr.kind == INSTR_INT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsle"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULE, lhsVal, rhsVal, newSubStrOfStrLit("icmpule"));
    } else if (instr.kind == INSTR_INT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpsgt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpugt"));
    } else if (instr.kind == INSTR_INT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsge"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpuge"));
    } else if (instr.kind == INSTR_FLOAT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpNeq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUNE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpne"));
    } else if (instr.kind == INSTR_FLOAT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpEq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUEQ, lhsVal, rhsVal, newSubStrOfStrLit("fcmpeq"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpult"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpule"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpugt"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpuge"));
    } else if (instr.kind == INSTR_LOGICAL_NOT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Not");
        return buildNot(&this.llvmBuilder, val, newSubStrOfStrLit("lnot"));
    } else if (instr.kind == INSTR_LOGICAL_OR || instr.kind == INSTR_BITWISE_OR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Or");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical Or");
        return buildOr(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("lor"));
    } else if (instr.kind == INSTR_LOGICAL_AND || instr.kind == INSTR_BITWISE_AND) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical And");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical And");
        return buildAnd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("land"));
    } else if (instr.kind == INSTR_BITWISE_XOR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Bitwise Xor");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Bitwise Xor");
        return buildXor(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("bxor"));
    } else if (instr.kind == INSTR_CALL) {
        let calledFunc: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Call");
        assert(!LLVM::isNull(calledFunc.ref), "Call tried to call invalid LLVMValue");
        let args: LLVMValueList = blank;
        initBlank(&args, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&args, i)) = asLLVM(argReg, "LLVM Call Arg");
        }
        let base: &IRReg = getRegister(irFunc, instr.src);
        let bt = base.typ;
        if (isPointer(bt)) bt = getUnderlyingType(bt, true);
        assert(isFunction(bt), "Call tried to call non-function base");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let retType = generateLLVMType(this, reg.typ);
        let fnType = generateLLVMFunctionType(this, bt);
        return buildCall(&this.llvmBuilder, calledFunc, fnType, args, retType, newSubStrOfStrLit("call"));
    } else if (instr.kind == INSTR_COND_BR) {
        let cond: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM CondBr");
        buildCondBr(&this.llvmBuilder, cond, *at(blocks, instr.dst.i), *at(blocks, instr.op1.i));
        return blank;
    } else if (instr.kind == INSTR_UNREACHABLE) {
        buildUnreachable(&this.llvmBuilder, );
        return blank;
    } else if (instr.kind == INSTR_UNTERMINATED) {
        fprintf(stderr, "%s %s: UNTERMINATED BLOCK FOUND!!!\n", toString(&instr.span).buffer, FATAL_STR);
        unreachable("LLVM: Received INSTR_UNTERMINATED, Control Flow Analysis should've caught this!");
    } else if (instr.kind == INSTR_BR) {
        buildBr(&this.llvmBuilder, *at(blocks, instr.dst.i));
        return blank;
    } else if (instr.kind == INSTR_RETURN_EXPR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM RetExpr");
        buildReturn(&this.llvmBuilder, val);
        return blank;
    } else if (instr.kind == INSTR_RETURN_VOID) {
        buildReturnVoid(&this.llvmBuilder, );
        return blank;
    } else if (instr.kind == INSTR_LOAD_I8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_F32) {
        let t: LLVMType = createFloatType(&this.llvmContext, );
        return constFloat(&t, *(&instr.src.i as &f32) as f64);
    } else if (instr.kind == INSTR_LOAD_F64) {
        let t: LLVMType = createDoubleType(&this.llvmContext, );
        return constFloat(&t, *(&instr.src.i as &f64));
    } else if (instr.kind == INSTR_LOAD_BOOL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 1);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_NULL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        let pt: LLVMType = intoPointerType(&t);
        return constZero(&pt);
    } else if (instr.kind == INSTR_LOAD_BLANK) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_ARRAY) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isArray(reg.typ), "LLVM Expected Array in INSTR_CREATE_ARRAY");
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_STRUCT) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_UNION) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_INSERT_VALUE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM InsertValue");
        let index: usize = instr.src.i;
        let elemVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM InsertValue");
        let newVal: LLVMValue = buildInsertValue(&this.llvmBuilder, 
            dstVal,
            elemVal,
            index as u32,
            "arr_elem",
        );
        return newVal;
    } else if (instr.kind == INSTR_PTR_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM PtrToInt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        return buildPtrToInt(&this.llvmBuilder, val, typ, newSubStrOfStrLit("p2i"));
    } else if (instr.kind == INSTR_INT_TO_PTR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToPtr");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        let ptr: LLVMType = intoPointerType(&typ);
        return buildIntToPtr(&this.llvmBuilder, val, ptr, newSubStrOfStrLit("i2p"));
    } else if (instr.kind == INSTR_INT_TO_F32 || instr.kind == INSTR_INT_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToF32 / IntToF64");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = createFloatType(&this.llvmContext, );
        if (instr.kind == INSTR_INT_TO_F64) typ = createDoubleType(&this.llvmContext, );
        return buildIntToFloat(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("i2f"));
    } else if (instr.kind == INSTR_F32_TO_INT || instr.kind == INSTR_F64_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToInt / F64ToInt");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return buildFloatToInt(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("f2i"));
    } else if (instr.kind == INSTR_F32_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToF64");
        let typ: LLVMType = createDoubleType(&this.llvmContext, );
        return buildFloatExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f32tof64"));
    } else if (instr.kind == INSTR_F64_TO_F32) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F64ToF32");
        let typ: LLVMType = createFloatType(&this.llvmContext, );
        return buildFloatTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f64tof32"));
    } else if (instr.kind == INSTR_INT_SIGN_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntSignExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntSignExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("sext"));
    } else if (instr.kind == INSTR_INT_ZERO_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntZeroExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntZeroExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("zext"));
    } else if (instr.kind == INSTR_INT_TRUNCATE) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntTrunc");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("trunc"));
    } else if (instr.kind == INSTR_LOAD_STRING) {
        return buildGlobalStringPtr(&this.llvmBuilder, instr.src.i as &char, newSubStrOfStrLit("str"));
    } else if (instr.kind == INSTR_GET_ELEMENT_PTR) {
        let indices: LLVMValueList = blank;
        initBlank(&indices, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&indices, i)) = asLLVM(argReg, "LLVM GEP Index");
        }
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetElementPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        let underlying: &Type = getUnderlyingType(ptr, false);
        return buildGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, indices, newSubStrOfStrLit("gep"));
    } else if (instr.kind == INSTR_GET_FIELD_PTR) {
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetFieldPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        assert(isPointer(ptr), "LLVM GetFieldPtr wants ptr reg");
        let aggrType: LLVMType = getType(&aggr);
        assert(isPointer(&aggrType), "Expected Pointer to Struct in GetFieldPtr");
        let underlying: &Type = getUnderlyingType(ptr, false);
        assert(isStruct(underlying), "LLVM GetFieldPtr wants ptr to struct");
        return buildStructGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, instr.op1.i, newSubStrOfStrLit("field_ptr"));
    } else if (instr.kind == INSTR_MEMCPY) {
        let src: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Memcpy src");
        let dst: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Memcpy dst");
        let size: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Memcpy op1");
        buildMemcpy(&this.llvmBuilder, dst, 1, src, 1, size);
        return dst;
    } else {
        printf("LLVM %llu\n", instr.kind);
        todo_with_msg("unknown llvm kind");
    }
}

func getComptimePointer(this: &LLVMCodegen, reg: &InterpReg) -> &u8 {
    trace("LLVMCodegen.getComptimePointer");
    let start: &u8 = getRegStackPointer(this.interp, reg);
    assert(start >= this.interp.regStackStart, "Expected comptime value to be allocated on Interp Reg Stack");
    assert(start < this.interp.regStackStart + REG_STACK_SIZE, "Expected comptime value to be allocated on Interp Reg Stack");
    return start;
}

func generateLLVMValueFromComptimePtr(this: &LLVMCodegen, typ: &Type, reg: InterpReg) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimePtr");
    assert(isPointer(typ), "generateLLVMValueFromComptimePtr expected Pointer");
    assert(reg.size == 8, "generateLLVMValueFromComptimePtr expected Pointer sized register");
    let underlying: &Type = getUnderlyingType(typ, false);
    // load value from interp
    let start: &u8 = getComptimePointer(this, &reg);
    let val: LLVMValue = generateLLVMValueFromComptimeValue(this, underlying, start);
    // allocate it somewhere
    let _underlying: LLVMType = generateLLVMType(this, getUnderlyingType(typ, false));
    let alloc: LLVMValue = buildAlloca(&this.llvmBuilder, _underlying, newSubStrOfStrLit("comptimeToLLVM"));
    buildStore(&this.llvmBuilder, alloc, val);
    // return pointer to that
    return alloc;
}
func generateLLVMValueFromComptimeValue(this: &LLVMCodegen, typ: &Type, start: &u8) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimeValue");
    assert(start != null, "generateLLVMValueFromComptimeValue got nullptr");
    let size: usize = getSize(typ);
    if (isPrimitive(typ)) {
        if (isInteger(typ)) {
            // Note: LLVM doesn't care about signedness for integers, that's all handled in the instructions
            if (size == 1) {
                let val: u8 = *(start as &u8);
                let t: LLVMType = createIntegerType(&this.llvmContext, 8);
                return constInt(&t, val as usize, false);
            } else if (size == 2) {
                let val: u16 = *(start as &u16);
                let t: LLVMType = createIntegerType(&this.llvmContext, 16);
                return constInt(&t, val as usize, false);
            } else if (size == 4) {
                let val: u32 = *(start as &u32);
                let t: LLVMType = createIntegerType(&this.llvmContext, 32);
                return constInt(&t, val as usize, false);
            } else if (size == 8) {
                let val: u64 = *(start as &u64);
                let t: LLVMType = createIntegerType(&this.llvmContext, 64);
                return constInt(&t, val as usize, false);
            } else {
                unreachable("unexpected int size");
            }
        } else if (isFloat(typ)) {
            if (size == 4) {
                let val = *(start as &f32);
                let t = createFloatType(&this.llvmContext, );
                return constFloat(&t, val as f64);
            } else if (size == 8) {
                let val = *(start as &f64);
                let t = createDoubleType(&this.llvmContext, );
                return constFloat(&t, val);
            } else {
                unreachable("unexpected float size");
            }
        } else if (isBoolean(typ)) {
            let val: u8 = *(start as &u8);
            assert(val == 0 || val == 1, "comptime bool is not 0 or 1");
            let t: LLVMType = createIntegerType(&this.llvmContext, 1);
            return constInt(&t, val as usize, false);
        } else if (isNone(typ)) {
            let t: LLVMType = createIntegerType(&this.llvmContext, 1);
            return constInt(&t, 1, false);
        } else {
            todo_with_msg("prim");
        }
    } else if (isStruct(typ)) {
        let decl: &ParsedStructDecl = at(&structDecls, typ.typeIndex);
        let lType: LLVMType = generateLLVMType(this, typ);
        assert(isStruct(&lType), "Expected LLVMType to be struct for comptime struct");
        let strukt: LLVMValue = constZero(&lType);
        let offset: usize = 0;
        let _size: usize = 0;
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
            let fType: &Type = getType(&tDecl.typeState);
            getFieldOffsetAndSize(decl, i, &offset, &_size);
            let elemVal: LLVMValue = generateLLVMValueFromComptimeValue(this, fType, start + offset);
            strukt = buildInsertValue(&this.llvmBuilder, strukt, elemVal, i as u32, "comptime_struct_field");
        }
        return strukt;
    } else if (isArray(typ)) {
        let llvmType = generateLLVMType(this, typ);
        let elemType = getUnderlyingType(typ, false);
        let elemSize = getSize(elemType);
        let array = constZero(&llvmType);
        for (let i: usize = 0; i < typ.arraySize; i = i + 1) {
            let offset = elemSize * i;
            let elem = generateLLVMValueFromComptimeValue(this, elemType, start + offset);
            array = buildInsertValue(&this.llvmBuilder, array, elem, i as u32, "comptime_array_elem");
        }
        return array;
    } else if (isPointer(typ)) {
        let underlying: &Type = getUnderlyingType(typ, false);
        if (isChar(underlying)) {
            return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        }
        todo_with_msg("comptime to LLVM pointer");
    } else if (isFunction(typ)) {
        let id: usize = *(start as &usize);
        return at(&this.irGen.functions, id).llvmFunc;
    } else {
        unreachable("Exhaustive handling in generateLLVMValueFromComptime");
    }
}

func generateLLVMFunctionType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.generateLLVMFunctionType");
    assert(isFunction(typ), "generateLLVMFunctionType called on non function");
    let params: LLVMTypeList = blank;
    let retType = at(&types, typ.typeIndex);
    if (getSize(retType) > 8) {
        retType = at(&types, intoPointer(retType));
        push(&params, prepareParameter(this, retType));
    }
    for (let i: usize = 0; i < typ.fnParams.length; i = i + 1) {
        let t: &Type = getType(getParam(typ, i));
        push(&params, prepareParameter(this, t));
    }
    let isVarArg = isVariadic(typ);
    let llvmType: LLVMType = prepareReturnType(this, retType);
    let llvmFuncType: LLVMType = intoFunctionType(&llvmType, params, isVarArg);
    return llvmFuncType;
}

func generateLLVMType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.generateLLVMType");
    if (isPrimitive(typ)) {
        if (isInteger(typ)) {
            return createIntegerType(&this.llvmContext, getSize(typ) as i64 * 8);
        } else if (isChar(typ)) {
            return createIntegerType(&this.llvmContext, 8);
        } else if (isBoolean(typ)) {
            return createIntegerType(&this.llvmContext, 1);
        } else if (isFloat(typ)) {
            if (typ.typeIndex == TYPE_F32) return createFloatType(&this.llvmContext, );
            else if (typ.typeIndex == TYPE_F64) return createDoubleType(&this.llvmContext, );
            unreachable("Expected TYPE_F32 or TYPE_F64");
        } else if (isNone(typ)) {
            return createVoidType(&this.llvmContext, );
        } else if (isAny(typ)) {
            let t: LLVMType = createIntegerType(&this.llvmContext, 64);
            return intoPointerType(&t);
        } else {
            fprintf(stderr, "%llu %llu\n", typ.kind, typ.typeIndex);
            todo_with_msg("generate primitive type");
        }
    } else if (isPointer(typ)) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return intoPointerType(&t);
    } else if (isFunction(typ)) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return intoPointerType(&t);
    } else if (isArray(typ)) {
        let t: LLVMType = generateLLVMType(this, at(&types, typ.typeIndex));
        return intoArrayType(&t, typ.arraySize as u32);
    } else if (isStruct(typ)) {
        let decl: &ParsedStructDecl = at(&structDecls, typ.typeIndex);
        let fields: &LLVMType = malloc(decl.context.fieldLength * sizeof LLVMType);
        assert(fields != null, "Could not allocate memory in LLVMCodegen.generateLLVMType");
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
            fields[i] = generateLLVMType(this, getType(&tDecl.typeState));
        }
        let t: LLVMType = createStructType(&this.llvmContext, fields, decl.context.fieldLength as u32, false);
        free(fields);
        return t;
    } else if (isUnion(typ)) {
        let decl: &ParsedUnionDecl = at(&unionDecls, typ.typeIndex);
        let size = getSize(typ) as u32;
        if (size == 0) {
            assert(decl.variants.length == 0, "LLVM: Union has size 0, but contains variants");
            return createStructType(&this.llvmContext, null, 0, false);
        }
        // Unions store the tag and an array of bytes
        let tag: LLVMType = generateLLVMType(this, newType(TYPE_KIND_PRIMITIVE, TYPE_U8));
        let data = intoArrayType(&tag, size - 1); // - 1 because tag is stored differently
        let fields = [tag, data];
        return createStructType(&this.llvmContext, &fields[0], 2, false);
    } else {
        todo_with_msg("generate llvm type");
    }
}

func newLLVMCodegen(name: SubStr, irGen: &IRGen, interp: &IRInterp) -> LLVMCodegen {
    let llvmContext: LLVMContext = newLLVMContext();
    let llvmModule: LLVMModule = createModuleWithName(&llvmContext, name);
    let llvmBuilder: LLVMBuilder = createBuilder(&llvmContext);
    initializeTargets(&llvmContext);
    let target: LLVMTarget = createTarget(&llvmContext, "x86-64");
    let triple: &char = createTargetTriple(&llvmContext, "x86-64");
    let targetMachine: LLVMTargetMachine = createTargetMachine(&target, triple, "x86-64", "");
    setTriple(&llvmModule, triple);
    let l: LLVMTargetData = getTargetData(&targetMachine);
    setDataLayout(&llvmModule, getDataLayout(&l));
    return LLVMCodegen {
        llvmContext: llvmContext,
        llvmModule: llvmModule,
        llvmBuilder: llvmBuilder,
        llvmTargetMachine: targetMachine,
        irGen: irGen,
        interp: interp,
        global: blank,
    };
}
