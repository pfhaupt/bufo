import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "asm.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/hashmaps.bufo";
import "../util/arena.bufo";
import "../frontend/lexer.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "../middleend/lookup.bufo";
import "./irgen.bufo";
import "./interp.bufo";
import "./LLVM/bindings.bufo";
import "./LLVM/module.bufo";
import "./LLVM/context.bufo";
import "./LLVM/builder.bufo";
import "./LLVM/values.bufo";
import "./LLVM/types.bufo";
import "./LLVM/basic_block.bufo";
import "./LLVM/pass_manager.bufo";
import "./LLVM/target.bufo";
import "./LLVM/debug_info.bufo";
import "./LLVM/metadata.bufo";

union RegValue {
    None,
    LLVM(LLVMValue),
    Interp(InterpReg),
    Both(LLVMValue, InterpReg),
}
func equals(this: &RegValue, other: &RegValue) -> bool {
    todo_with_msg("RegValue.equals");
}
func addInterpValue(this: &RegValue, val: InterpReg) {
    match (this) {
        &RegValue::LLVM(llvm) => { *this = RegValue::Both(llvm, val); }
        &RegValue::Interp(_) => { *this = RegValue::Interp(val); }
        &RegValue::None => { *this = RegValue::Interp(val); }
        &RegValue::Both(llvm, _) => { *this = RegValue::Both(llvm, val); }
        _ => { unreachable(); }
    }
}
func addLLVMValue(this: &RegValue, val: LLVMValue) {
    match (this) {
        &RegValue::LLVM(_) => { *this = RegValue::LLVM(val); }
        &RegValue::Interp(interp) => { *this = RegValue::Both(val, interp); }
        &RegValue::None => { *this = RegValue::LLVM(val); }
        &RegValue::Both(_, interp) => { *this = RegValue::Both(val, interp); }
        _ => { unreachable(); }
    }
}
func asInterp(this: &RegValue, err: &char) -> InterpReg {
    match (this) {
        &RegValue::Interp(interp) => { return interp; }
        &RegValue::Both(_, interp) => { return interp; }
        _ => { }
    }
    unreachable(err);
}
func asLLVM(this: &RegValue, err: &char) -> LLVMValue {
    match (this) {
        &RegValue::LLVM(llvm) => { return llvm; }
        &RegValue::Both(llvm, _) => { return llvm; }
        _ => { }
    }
    unreachable(err);
}
func isLLVM(this: &RegValue) -> bool {
    match (this) {
        &RegValue::LLVM(_) => { return true; }
        &RegValue::Both(_, _) => { return true; }
        _ => { }
    }
    return false;
}
func isInterp(this: &RegValue) -> bool {
    match (this) {
        &RegValue::Interp(_) => { return true; }
        &RegValue::Both(_, _) => { return true; }
        _ => { }
    }
    return false;
}

struct LLVMCodegen {
    llvmContext: LLVMContext;
    llvmModule: LLVMModule;
    llvmBuilder: LLVMBuilder;
    llvmTargetMachine: LLVMTargetMachine;
    llvmDIBuilder: LLVMDIBuilder;
    irGen: &IRGen;
    interp: &IRInterp;
    global: RegValueList;
}

func generateDebugInfo(this: &LLVMCodegen, argc: i32, argv: &&char) -> bool {
    assert(!LLVM::isNull(this.llvmDIBuilder.ref), "Can't generate debug info because DIBuilder is null!");
    assert(types.length == debugTypes.length, "Expected to have as many debug types as normal types");
    let producer = newSubStrOfStrLit("Bufo Programming Language");
    let cli = newStringFromStrLit(argv[0]);
    for (let i: i32 = 1; i < argc; i = i + 1) {
        pushChar(&cli, ' ');
        pushStr(&cli, argv[i as usize]);
    }
    for (let i: usize = 0; i < files.length; i = i + 1) {
        let f = at(&files, i);
        let path = toString(&f.origin);
        let root = getRoot(&path);
        let file = getFileName(&path);
        let diFile = createFile(this.llvmDIBuilder, file.buffer, file.length, root.buffer, root.length);
        assert(!LLVM::isNull(diFile.ref), "Could not create debug file");
        let diUnit = createCompileUnit(this.llvmDIBuilder, LLVMDWARFSourceLanguageC, diFile, producer,
                    newLLVMBool(*flags.opt), asSubStr(&cli), 0, blank, LLVMDWARFEmissionKindFull,
                    0, newLLVMBool(true), newLLVMBool(true), blank, blank);
        assert(!LLVM::isNull(diUnit.ref), "Could not create Compile Unit");
        f.debugInfo = DebugInfo {
            diFile: diFile,
            diUnit: diUnit,
        };
        // REVIEW: Can we free `root` and `file` here?
        drop(&file);
        drop(&root);
        drop(&path);
    }
    assert(types.length >= PRIM_TYPE_COUNT, "Expected to find at least all primitive types");
    for (let i: usize = 0; i < PRIM_TYPE_COUNT; i = i + 1) {
        *at(&debugTypes, i) = createDebugInfoForPrimitiveType(this.llvmDIBuilder, at(&types, i));
    }
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl = at(&structDecls, i);
        decl.debugInfo = DebugInfo {
            diType: LLVMMetadata {
                ref: LLVM::TemporaryMDNode(this.llvmContext.ref, null, 0)
            }
        };
    }
    for (let i: usize = 0; i < unionDecls.length; i = i + 1) {
        let decl = at(&unionDecls, i);
        decl.debugInfo = DebugInfo {
            diType: LLVMMetadata {
                ref: LLVM::TemporaryMDNode(this.llvmContext.ref, null, 0)
            }
        };
    }
    for (let i: usize = 0; i < structDecls.length; i = i + 1) {
        let decl = at(&structDecls, i);
        if (decl.ignored) continue;
        let fts = getType(&decl.typeState);
        let file = getParentFile(decl);
        let diFile = file.debugInfo.diFile;
        let diType = createDebugInfoForStructType(this.llvmDIBuilder, diFile, fts);
        decl.debugInfo = DebugInfo {
            diFile: diFile,
            diType: diType,
        };
    }
    for (let i: usize = 0; i < unionDecls.length; i = i + 1) {
        let decl = at(&unionDecls, i);
        if (decl.ignored) continue;
        let fts = getType(&decl.typeState);
        let file = getParentFile(decl);
        let diFile = file.debugInfo.diFile;
        let diType = createDebugInfoForUnionType(this.llvmDIBuilder, diFile, fts, this.llvmContext);
        decl.debugInfo = DebugInfo {
            diFile: diFile,
            diType: diType,
        };
    }
    drop(&cli);
    return true;
}
func generateExecutable(this: &LLVMCodegen, outPath: SubStr, argc: i32, argv: &&char) -> bool {
    let fns: IRFuncList = asList(&this.irGen.functions);
    if (*flags.debug) {
        if (!generateDebugInfo(this, argc, argv)) return false;
        if (*flags.verbose) {
            // REVIEW: Remove this?
            dumpInstructions(&this.irGen.globalScope);
            for (let i: usize = 0; i < fns.length; i = i + 1) {
                let f: &IRFunc = at(&fns, i);
                dumpInstructions(f);
            }
        }
    }
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        generateLLVMFunctionHeader(this, at(&fns, i));
    }
    if (!generateRuntimeInitialization(this, &this.irGen.initRuntime)) return false;
    if (!generateEntryPoint(this)) return false;
    if (!generateGlobal(this, &this.irGen.globalScope)) return false;
    if (!_generateFunction(this, &this.irGen.initRuntime)) return false;
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        let f: &IRFunc = at(&fns, i);
        if (!generateFunction(this, f)) return false;
    }
    if (*flags.debug) {
        // TODO: Delete old debug info
        finalizeDIBuilder(this.llvmDIBuilder);
    }
    if (*flags.debug && *flags.emitLLVM) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_before.ll"));
    if (!verify(&this.llvmModule)) return false;
    if (*flags.opt) {
        let passOptions = createPassBuilderOptions();
        // Not sure if we need this, we just verified the module
        // setVerifyEach(passOptions, newLLVMBool(*flags.debug));
        // Debug Logging is very noisy :^)
        // setDebugLogging(passOptions, newLLVMBool(*flags.debug));
        // TODO: Find out what this AAPipeline is for
        // setAAPipeline(passOptions, "");
        // TODO: Play around with these settings
        setLoopInterleaving(passOptions, newLLVMBool(true));
        setLoopVectorization(passOptions, newLLVMBool(true));
        setSLPVectorization(passOptions, newLLVMBool(true));
        setLoopUnrolling(passOptions, newLLVMBool(true));
        setForgetAllSCEVInLoopUnroll(passOptions, newLLVMBool(true));
        setLicmMssaOptCap(passOptions, 100);
        setLicmMssaNoAccForPromotionCap(passOptions, 8);
        setCallGraphProfile(passOptions, newLLVMBool(true));
        setMergeFunctions(passOptions, newLLVMBool(true));
        setInlinerThreshold(passOptions, 250);
        // TODO: Play with some passes to figure out a good mix of optimizations
        if (!runPasses(this.llvmModule, "default<O3>", this.llvmTargetMachine, passOptions)) {
            return false;
        }
        disposePassBuilderOptions(passOptions);
    }
    if (*flags.debug && *flags.emitLLVM) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_after.ll"));
    let objPath: String = toString(&outPath);
    pushStr(&objPath, ".obj");
    if (*flags.verbose) {
        C::printf("[INFO] Saving object file at %s\n", objPath.buffer);
    }
    writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMObjectFile, objPath.buffer);
    if (*flags.emitASM) {
        let asmPath = toString(&outPath);
        pushStr(&asmPath, ".s");
        C::printf("[INFO] Saving assembly code in %s\n", asmPath.buffer);
        writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMAssemblyFile, asmPath.buffer);
        drop(&asmPath);
    }
    if (*flags.emitLLVM) {
        let llvmPath = toString(&outPath);
        pushStr(&llvmPath, ".ll");
        C::printf("[INFO] Saving LLVM IR in %s\n", llvmPath.buffer);
        writeToFile(&this.llvmModule, asSubStr(&llvmPath));
        drop(&llvmPath);
    }
    return true;
}
func generateRuntimeInitialization(this: &LLVMCodegen, initRuntime: &IRFunc) -> bool {
    let rt_type = wrap(Type::Func(blank, wrap(Type::Prim(PrimType::None)), blank));
    let llvmFuncType = generateLLVMFunctionType(this, rt_type);
    let llvmFuncValue = addFunction(&this.llvmModule, asSubStr(&initRuntime.name), llvmFuncType);
    if (*flags.debug) {
        let file: &ParsedFile = null;
        for (let i: usize = 0; i < files.length; i = i + 1) {
            let f = at(&files, i);
            if (endsWith(&f.origin, &asSubStr(flags.file))) {
                file = f;
                break;
            }
        }
        assert(file != null);
        let line: usize = 0;
        let col: usize = 0;
        getLineAndColumnFromSpan(file, &initRuntime.span, &line, &col);
        let linkage = asSubStr(&initRuntime.name);
        let diFile = file.debugInfo.diFile;
        let diUnit = file.debugInfo.diUnit;
        assert(!LLVM::isNull(diFile.ref), "DebugInfo File is null");
        assert(!LLVM::isNull(diUnit.ref), "DebugInfo Unit is null");
        let sp = createFunction(this.llvmDIBuilder, diUnit, asSubStr(&initRuntime.name), linkage, diFile, line as u32,
            createSubroutineType(this.llvmDIBuilder, diFile, rt_type), newLLVMBool(false),
            newLLVMBool(true), line as u32, LLVMDIFlagPrototyped, newLLVMBool(*flags.opt));
        setSubprogram(llvmFuncValue, sp);
    }
    initRuntime.llvmFunc = llvmFuncValue;
    return true;
}
func generateEntryPoint(this: &LLVMCodegen) -> bool {
    if (*flags.noEntry) return true;
    let realMainName: SubStr = newSubStrOfStrLit("__real_main");
    if (!hasFunction(&this.llvmModule, realMainName)) {
        C::fprintf(stderr, "%s Could not find entry point!\n", FATAL_STR);
        C::fprintf(stderr, "%s: Expected to find `std/runtime.bufo` in the list of imports, but failed!\n", NOTE_STR);
        return false;
    }
    let realMainFunc: LLVMValue = getFunction(&this.llvmModule, realMainName);

    // FIXME: Would be cool if we could also specify functions like `func main() {}` here that dont take arguments
    let mainName: SubStr = newSubStrOfStrLit("maini32PPcri32");
    if (!hasFunction(&this.llvmModule, mainName)) {
        C::fprintf(stderr, "%s Could not find main function!\n", FATAL_STR);
        C::fprintf(stderr, "%s: The compiler currently requires that the input file also defines a main function.\n", NOTE_STR);
        C::fprintf(stderr, "%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n", NOTE_STR);
        return false;
    }
    let mainFunc: LLVMValue = getFunction(&this.llvmModule, mainName);
    let retType: LLVMType = createIntegerType(&this.llvmContext, 32);
    let params: LLVMTypeList = blank;
    push(&params, createIntegerType(&this.llvmContext, 32));
    let _p: LLVMType = createIntegerType(&this.llvmContext, 8);
    push(&params, intoPointerType(&_p));
    push(&params, intoPointerType(&createIntegerType(&this.llvmContext, 64)));
    let retFnType: LLVMType = intoFunctionType(&retType, params, false);
    assert(!hasFunction(&this.llvmModule, newSubStrOfStrLit("main")));
    let main: LLVMValue = addFunction(&this.llvmModule, newSubStrOfStrLit("main"), retFnType);
    let entry: LLVMBasicBlock = appendBasicBlock(&this.llvmContext, main, newSubStrOfStrLit("entry"));
    positionAtEnd(&this.llvmBuilder, entry);
    let args: LLVMValueList = blank;
    {
        comptime rt_name = newSubStrOfStrLit(".init_runtime");
        assert(hasFunction(&this.llvmModule, rt_name), "Could not find .init_runtime");
        let runtime_func: LLVMValue = getFunction(&this.llvmModule, rt_name);
        let _retType: LLVMType = createVoidType(&this.llvmContext);
        let _params: LLVMTypeList = blank;
        let _retFnType: LLVMType = intoFunctionType(&_retType, _params, false);
        buildCall(&this.llvmBuilder, runtime_func, _retFnType, blank, _retType, newSubStrOfStrLit("entry"));
    }
    push(&args, getNthParam(&main, 0));
    push(&args, getNthParam(&main, 1));
    push(&args, mainFunc);
    let v: LLVMValue = buildCall(&this.llvmBuilder, realMainFunc, retFnType, args, retType, newSubStrOfStrLit("entry"));
    buildReturn(&this.llvmBuilder, v);
    return true;
}
func generateGlobal(this: &LLVMCodegen, global: &IRFunc) -> bool {
    this.global = blank;
    initBlank(&this.global, global.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(global);
    let llvmFunc: LLVMValue = blank;
    let blocks: LLVMBasicBlockList = blank;
    pushRegisterStack(this.interp, defaultSpan(), funcSize);
    this.interp.globalRegisters = &this.global;
    this.interp.globalRegBase = this.interp.regStackBase;
    assert(global.blocks.length == 1, "Expected to only find one IRBlock in global scope");
    generateBlock(this, &llvmFunc, global, &blocks, at(&global.blocks, 0), &this.global);
    return true;
}

func generateLLVMFunctionHeader(this: &LLVMCodegen, irFunc: &IRFunc) {
    let llvmFunc: LLVMValue = blank;
    let function: &ParsedFuncDecl = getFuncNode(irFunc);
    let llvmFuncType = generateLLVMFunctionType(this, getType(&function.typeState));
    let llvmFuncValue: LLVMValue = addFunction(&this.llvmModule, asSubStr(&irFunc.name), llvmFuncType);
    if (hasAttribute(irFunc, ATTR_NORETURN)) {
        let id = LLVM::GetEnumAttributeKindForName("noreturn", 8 /* sizeof "noreturn" */);
        assert(id != 0, "Could not get noreturn attribute from LLVM");
        addAttribute(&llvmFuncValue, U32_MAX, createEnumAttribute(&this.llvmContext, id, 1));
    }
    if (hasAttribute(irFunc, ATTR_NAKED)) {
        let id = LLVM::GetEnumAttributeKindForName("naked", 5 /* sizeof "naked" */);
        assert(id != 0, "Could not get naked attribute from LLVM");
        addAttribute(&llvmFuncValue, U32_MAX, createEnumAttribute(&this.llvmContext, id, 1));
    }
    if (*flags.debug) {
        let file = getParentFile(function);
        let line: usize = 0;
        let col: usize = 0;
        getLineAndColumnFromSpan(file, &function.span, &line, &col);
        let linkage = asSubStr(&irFunc.name);
        let diFile = file.debugInfo.diFile;
        let diUnit = file.debugInfo.diUnit;
        assert(!LLVM::isNull(diFile.ref), "DebugInfo File is null");
        assert(!LLVM::isNull(diUnit.ref), "DebugInfo Unit is null");
        let sp = createFunction(this.llvmDIBuilder, diUnit, function.name.content, linkage, diFile, line as u32,
            createSubroutineType(this.llvmDIBuilder, diFile, getType(&function.typeState)), newLLVMBool(false),
            newLLVMBool(!isExtern(function)), line as u32, LLVMDIFlagPrototyped, newLLVMBool(*flags.opt));
        setSubprogram(llvmFuncValue, sp);
    }
    irFunc.llvmFunc = llvmFuncValue;
    let origFunc: &IRFunc = get(&this.irGen.functions, &irFunc.name);
    origFunc.llvmFunc = llvmFuncValue;
}

func prepareReturnType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSizeInBytes(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        return generateLLVMType(this, t);
    } else {
        return generateLLVMType(this, typ);
    }
}

func prepareParameter(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSizeInBytes(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        return generateLLVMType(this, t);
    } else if (getSizeInBytes(typ) > 8) {
        return generateLLVMType(this, intoPointer(typ));
    } else {
        return generateLLVMType(this, typ);
    }
}

func getLLVMTypeSize(this: &LLVMCodegen, typ: &LLVMType) -> usize {
    let data: LLVMTargetData = getTargetData(&this.llvmTargetMachine);
    let s1: usize = getStoreSize(&data, typ);
    let s2: usize = getABISize(&data, typ);
    let s3: usize = getBitSize(&data, typ) / 8;
    assert(s1 == s2 && s1 == s3 && s2 == s3, "LLVMTargetData returned different type sizes");
    return s1;
}

func _generateFunction(this: &LLVMCodegen, irFunc: &IRFunc) -> bool {
    let llvmFuncValue: LLVMValue = irFunc.llvmFunc;
    assert(!LLVM::isNull(llvmFuncValue.ref));
    let blocks: LLVMBasicBlockList = blank;
    initBlank(&blocks, irFunc.blocks.length);
    assert(blocks.length != 0, "Every IRFunc has at least one instruction");
    *(at(&blocks, 0)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("entry"));
    for (let i: usize = 1; i < irFunc.blocks.length; i = i + 1) {
        *(at(&blocks, i)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("b"));
    }
    let regs: RegValueList = blank;
    initBlank(&regs, irFunc.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    pushRegisterStack(this.interp, irFunc.span, funcSize);
    if (*flags.debug) resetCurrentDebugLocation(this.llvmDIBuilder, this.llvmBuilder);
    for (let i: usize = 0; i < irFunc.blocks.length; i = i + 1) {
        let block: &IRBlock = getBlockByID(irFunc, IRBlockID { i: i });
        positionAtEnd(&this.llvmBuilder, *at(&blocks, i));
        generateBlock(this, &llvmFuncValue, irFunc, &blocks, block, &regs);
    }
    popRegisterStack(this.interp, irFunc.span, funcSize);
    return true;
}

func generateFunction(this: &LLVMCodegen, irFunc: &IRFunc) -> bool {
    if (isExtern(irFunc)) return true;
    return _generateFunction(this, irFunc);
}
func generateBlock(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    llvmBlocks: &LLVMBasicBlockList,
    block: &IRBlock,
    regs: &RegValueList,
) {
    for (let i: usize = 0; i < block.instructions.length; i = i + 1) {
        let instr: &IRInstr = at(&block.instructions, i);
        if (*flags.debug) {
            let isGlobal = LLVM::isNull(llvmFunc.ref);
            if (!isGlobal) {
                setCurrentDebugLocation(this.llvmDIBuilder, this.llvmBuilder, this.llvmContext, *llvmFunc, irFunc, instr.span);
            }
        }
        if (instr.kind == INSTR_ALLOCA) {
            if (!instr.isComptime) {
                let llvm = generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs);
                addLLVMValue((at(regs, instr.dst.i)), llvm);
            }
            let interp = evaluateSingle(this.interp, irFunc, instr, regs, true);
            addInterpValue((at(regs, instr.dst.i)), interp);
        } else if (instr.isComptime) {
            let val = evaluateSingle(this.interp, irFunc, instr, regs, false);
            if (!isTerminator(instr)) addInterpValue((at(regs, instr.dst.i)), val);
        } else {
            let val = generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs);
            if (!isTerminator(instr)) addLLVMValue((at(regs, instr.dst.i)), val);
        }
    }
}

func generateLLVMInstr(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    blocks: &LLVMBasicBlockList,
    instr: &IRInstr,
    regs: &RegValueList,
) -> LLVMValue {
    let isGlobal: bool = LLVM::isNull(llvmFunc.ref);
    if (instr.kind == INSTR_DEBUG_INFO_PARAM) {
        assert(*flags.debug);
        assert(!isGlobal);
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let dstLLVM = asLLVM(at(regs, instr.dst.i), "LLVM DebugInfo Param");
        let file = at(&files, instr.span.file);
        let line: usize = 0;
        let col: usize = 0;
        getLineAndColumnFromSpan(file, &instr.span, &line, &col);
        let diFile = file.debugInfo.diFile;
        assert(isPointer(reg.typ), "LLVM DebugInfo Param non-ptr");
        let mt = createType(this.llvmDIBuilder, diFile, getUnderlyingType(reg.typ, false));
        let start = shiftRight(instr.src.i, PARAM_SHIFT) as &char;
        let index = instr.src.i % shiftLeft(1, PARAM_SHIFT);
        let scope = getSubprogram(*llvmFunc);
        let meta = createParameterVariable(this.llvmDIBuilder, scope,
            newSubStr(start, 0, instr.op1.i), index as u32 + 1, diFile, line as u32, mt, newLLVMBool(true), LLVMDIFlagZero);
        let expr = createExpression(this.llvmDIBuilder, null, 0);
        let loc = createDebugLocation(this.llvmContext, line as u32, col as u32, scope);
        insertDeclareRecordAtEnd(this.llvmDIBuilder, dstLLVM, meta, expr, loc, getInsertBlock(&this.llvmBuilder));
        return dstLLVM;
    } else if (instr.kind == INSTR_DEBUG_INFO_ALLOCA) {
        assert(*flags.debug);
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let dstLLVM = asLLVM(at(regs, instr.dst.i), "LLVM DebugInfo Alloca");
        let file = at(&files, instr.span.file);
        let line: usize = 0;
        let col: usize = 0;
        getLineAndColumnFromSpan(file, &instr.span, &line, &col);
        let expr = createExpression(this.llvmDIBuilder, null, 0);
        assert(isPointer(reg.typ), "LLVM DebugInfo Alloca non-ptr");
        let diFile = file.debugInfo.diFile;
        let mt = createType(this.llvmDIBuilder, diFile, getUnderlyingType(reg.typ, false));
        if (isGlobal) {
            let meta = LLVMMetadata {
                ref: LLVM::DIBuilderCreateGlobalVariableExpression(this.llvmDIBuilder.ref, file.debugInfo.diUnit.ref,
                    instr.src.i as &char, instr.op1.i, instr.src.i as &char, instr.op1.i, diFile.ref,
                    line as u32, mt.ref, newLLVMBool(true), expr.ref, blank, getAlignmentInBits(reg.typ) as u32)
            };
            assert(!LLVM::isNull(meta.ref), "Could not create global variable expression");
            LLVM::GlobalSetMetadata(dstLLVM.ref, 0, meta.ref);
            return dstLLVM;
        }
        let scope = getSubprogram(*llvmFunc);
        let meta = createAutoVariable(this.llvmDIBuilder, scope,
            SubStr { start: instr.src.i as &char, len: instr.op1.i }, diFile, line as u32,
            mt, newLLVMBool(true), LLVMDIFlagZero, getAlignmentInBits(reg.typ) as u32);
        assert(!LLVM::isNull(meta.ref), "Could not get scope for DebugInfo-Alloca");
        let loc = createDebugLocation(this.llvmContext, line as u32, col as u32, scope);
        insertDeclareRecordAtEnd(this.llvmDIBuilder, dstLLVM, meta, expr, loc, getInsertBlock(&this.llvmBuilder));
        return dstLLVM;
    } else if (instr.kind == INSTR_ALLOCA) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isPointer(reg.typ), "LLVM Alloca expected ptr dst");
        let t: &Type = getUnderlyingType(reg.typ, false);
        let typ: LLVMType = generateLLVMType(this, t);
        if (isGlobal) {
            return addGlobal(&this.llvmModule, typ, 0, newSubStrOfStrLit("g"));
        } else {
            return buildAlloca(&this.llvmBuilder, typ, newSubStrOfStrLit("v"));
        }
    } else if (instr.kind == INSTR_GET_PARAM) {
        assert(!isGlobal);
        let param: LLVMValue = getNthParam(llvmFunc, instr.src.i);
        setName(&param, newSubStrOfStrLit("p"));
        return param;
    } else if (instr.kind == INSTR_STORE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Store dst");
        let srcVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Store src");
        if (isGlobal) {
            setInitializer(&dstVal, srcVal);
        } else {
            buildStore(&this.llvmBuilder, dstVal, srcVal);
        }
        return dstVal;
    } else if (instr.kind == INSTR_LOAD_FUNCTION_PTR) {
        let called: &IRFunc = at(&this.irGen.functions, instr.src.i);
        return called.llvmFunc;
    } else if (instr.kind == INSTR_LOAD) {
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: &RegValue = at(regs, instr.src.i);
        if (isLLVM(reg)) {
            let srcVal: LLVMValue = asLLVM(reg, "LLVM Load");
            if (isGlobal) {
                return getInitializer(&srcVal);
            } else {
                return buildLoad(&this.llvmBuilder, dstTyp, srcVal, newSubStrOfStrLit("load"));
            }
        } else {
            let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM Load from comptime"));
            return generateLLVMValueFromComptimeValue(this, typ, *(start as &usize) as &u8);
        }
    } else if (instr.kind == INSTR_MOVE) {
        return asLLVM(at(regs, instr.src.i), "LLVM Move");
    } else if (instr.kind == INSTR_FETCH_GLOBAL_PTR) {
        let val: &RegValue = at(&this.global, instr.src.i);
        if (isLLVM(val)) {
            return asLLVM(val, "We just checked if it is LLVM");
        } else {
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            return generateLLVMValueFromComptimePtr(this, typ, reg);
        }
    } else if (instr.kind == INSTR_FETCH_GLOBAL_VALUE) {
        let val: &RegValue = at(&this.global, instr.src.i);
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        assert(isLLVM(val), "FetchGlobalValue got non-LLVM src");
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: LLVMValue = asLLVM(val, "We just checked if it is LLVM");
        return buildLoad(&this.llvmBuilder, dstTyp, reg, newSubStrOfStrLit("fetchglobalval"));
    } else if (instr.kind == INSTR_FETCH_COMPTIME_VALUE) {
        if (instr.op1.i == 1) {
            // Global fetch
            let val: &RegValue = at(&this.global, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!isLLVM(val), "FetchComptimeValue global=1 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getGlobalPointer(this.interp, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        } else {
            // Local fetch
            let val: &RegValue = at(regs, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!isLLVM(val), "FetchComptimeValue global=0 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getComptimePointer(this, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        }
    } else if (instr.kind == INSTR_INT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntAdd(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("iadd"));
    } else if (instr.kind == INSTR_INT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntSub(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("isub"));
    } else if (instr.kind == INSTR_INT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMul(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imul"));
    } else if (instr.kind == INSTR_INT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntDiv(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("idiv"));
    } else if (instr.kind == INSTR_INT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMod(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imod"));
    } else if (instr.kind == INSTR_FLOAT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddFloat");
        return buildFloatAdd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fadd"));
    } else if (instr.kind == INSTR_FLOAT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubFloat");
        return buildFloatSub(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fsub"));
    } else if (instr.kind == INSTR_FLOAT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulFloat");
        return buildFloatMul(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmul"));
    } else if (instr.kind == INSTR_FLOAT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivFloat");
        return buildFloatDiv(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fdiv"));
    } else if (instr.kind == INSTR_FLOAT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModFloat");
        return buildFloatMod(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmod"));
    } else if (instr.kind == INSTR_INT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpNeq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntNE, lhsVal, rhsVal, newSubStrOfStrLit("icmpne"));
    } else if (instr.kind == INSTR_INT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpEq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntEQ, lhsVal, rhsVal, newSubStrOfStrLit("icmpeq"));
    } else if (instr.kind == INSTR_INT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLT, lhsVal, rhsVal, newSubStrOfStrLit("icmpslt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULT, lhsVal, rhsVal, newSubStrOfStrLit("icmpult"));
    } else if (instr.kind == INSTR_INT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsle"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULE, lhsVal, rhsVal, newSubStrOfStrLit("icmpule"));
    } else if (instr.kind == INSTR_INT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpsgt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpugt"));
    } else if (instr.kind == INSTR_INT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsge"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpuge"));
    } else if (instr.kind == INSTR_FLOAT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpNeq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUNE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpne"));
    } else if (instr.kind == INSTR_FLOAT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpEq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUEQ, lhsVal, rhsVal, newSubStrOfStrLit("fcmpeq"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpult"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpule"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpugt"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpuge"));
    } else if (instr.kind == INSTR_LOGICAL_NOT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Not");
        return buildNot(&this.llvmBuilder, val, newSubStrOfStrLit("lnot"));
    } else if (instr.kind == INSTR_LOGICAL_OR || instr.kind == INSTR_BITWISE_OR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Or");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical Or");
        return buildOr(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("lor"));
    } else if (instr.kind == INSTR_LOGICAL_AND || instr.kind == INSTR_BITWISE_AND) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical And");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical And");
        return buildAnd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("land"));
    } else if (instr.kind == INSTR_BITWISE_XOR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Bitwise Xor");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Bitwise Xor");
        return buildXor(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("bxor"));
    } else if (instr.kind == INSTR_CALL) {
        let calledFunc: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Call");
        assert(!LLVM::isNull(calledFunc.ref), "Call tried to call invalid LLVMValue");
        let args: LLVMValueList = blank;
        initBlank(&args, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&args, i)) = asLLVM(argReg, "LLVM Call Arg");
        }
        let base: &IRReg = getRegister(irFunc, instr.src);
        let bt = base.typ;
        if (isPointer(bt)) bt = getUnderlyingType(bt, true);
        assert(isFunction(bt), "Call tried to call non-function base");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let retType = generateLLVMType(this, reg.typ);
        let fnType = generateLLVMFunctionType(this, bt);
        return buildCall(&this.llvmBuilder, calledFunc, fnType, args, retType, newSubStrOfStrLit("call"));
    } else if (instr.kind == INSTR_COND_BR) {
        let cond: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM CondBr");
        buildCondBr(&this.llvmBuilder, cond, *at(blocks, instr.dst.i), *at(blocks, instr.op1.i));
        return blank;
    } else if (instr.kind == INSTR_UNREACHABLE) {
        buildUnreachable(&this.llvmBuilder);
        return blank;
    } else if (instr.kind == INSTR_UNTERMINATED) {
        C::fprintf(stderr, "%s %s: UNTERMINATED BLOCK FOUND!!!\n", toString(&instr.span).buffer, FATAL_STR);
        unreachable("LLVM: Received INSTR_UNTERMINATED, Control Flow Analysis should've caught this!");
    } else if (instr.kind == INSTR_BR) {
        buildBr(&this.llvmBuilder, *at(blocks, instr.dst.i));
        return blank;
    } else if (instr.kind == INSTR_RETURN_EXPR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM RetExpr");
        buildReturn(&this.llvmBuilder, val);
        return blank;
    } else if (instr.kind == INSTR_RETURN_VOID) {
        buildReturnVoid(&this.llvmBuilder);
        return blank;
    } else if (instr.kind == INSTR_LOAD_I8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_F32) {
        let t: LLVMType = createFloatType(&this.llvmContext);
        return constFloat(&t, *(&instr.src.i as &f32) as f64);
    } else if (instr.kind == INSTR_LOAD_F64) {
        let t: LLVMType = createDoubleType(&this.llvmContext);
        return constFloat(&t, *(&instr.src.i as &f64));
    } else if (instr.kind == INSTR_LOAD_BOOL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 1);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_NULL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        let pt: LLVMType = intoPointerType(&t);
        return constZero(&pt);
    } else if (instr.kind == INSTR_LOAD_BLANK) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_ARRAY) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isArray(reg.typ), "LLVM Expected Array in INSTR_CREATE_ARRAY");
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_STRUCT) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_UNION) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_INSERT_VALUE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM InsertValue");
        let index: usize = instr.src.i;
        let elemVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM InsertValue");
        let newVal: LLVMValue = buildInsertValue(&this.llvmBuilder, 
            dstVal,
            elemVal,
            index as u32,
            "arr_elem",
        );
        return newVal;
    } else if (instr.kind == INSTR_PTR_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM PtrToInt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        return buildPtrToInt(&this.llvmBuilder, val, typ, newSubStrOfStrLit("p2i"));
    } else if (instr.kind == INSTR_INT_TO_PTR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToPtr");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        let ptr: LLVMType = intoPointerType(&typ);
        return buildIntToPtr(&this.llvmBuilder, val, ptr, newSubStrOfStrLit("i2p"));
    } else if (instr.kind == INSTR_INT_TO_F32 || instr.kind == INSTR_INT_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToF32 / IntToF64");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = createFloatType(&this.llvmContext);
        if (instr.kind == INSTR_INT_TO_F64) typ = createDoubleType(&this.llvmContext);
        return buildIntToFloat(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("i2f"));
    } else if (instr.kind == INSTR_F32_TO_INT || instr.kind == INSTR_F64_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToInt / F64ToInt");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return buildFloatToInt(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("f2i"));
    } else if (instr.kind == INSTR_F32_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToF64");
        let typ: LLVMType = createDoubleType(&this.llvmContext);
        return buildFloatExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f32tof64"));
    } else if (instr.kind == INSTR_F64_TO_F32) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F64ToF32");
        let typ: LLVMType = createFloatType(&this.llvmContext);
        return buildFloatTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f64tof32"));
    } else if (instr.kind == INSTR_INT_SIGN_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntSignExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntSignExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("sext"));
    } else if (instr.kind == INSTR_INT_ZERO_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntZeroExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntZeroExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("zext"));
    } else if (instr.kind == INSTR_INT_TRUNCATE) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntTrunc");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("trunc"));
    } else if (instr.kind == INSTR_LOAD_STRING) {
        return buildGlobalStringPtr(&this.llvmBuilder, instr.src.i as &char, newSubStrOfStrLit("str"));
    } else if (instr.kind == INSTR_GET_ELEMENT_PTR) {
        let indices: LLVMValueList = blank;
        initBlank(&indices, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&indices, i)) = asLLVM(argReg, "LLVM GEP Index");
        }
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetElementPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        let underlying: &Type = getUnderlyingType(ptr, false);
        return buildGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, indices, newSubStrOfStrLit("gep"));
    } else if (instr.kind == INSTR_GET_FIELD_PTR) {
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetFieldPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        assert(isPointer(ptr), "LLVM GetFieldPtr wants ptr reg");
        let aggrType: LLVMType = getType(&aggr);
        assert(isPointer(&aggrType), "Expected Pointer to Struct in GetFieldPtr");
        let underlying: &Type = getUnderlyingType(ptr, false);
        assert(isVariadicType(underlying) || isStruct(underlying) || isTuple(underlying), "LLVM GetFieldPtr wants ptr to struct");
        return buildStructGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, instr.op1.i, newSubStrOfStrLit("field_ptr"));
    } else if (instr.kind == INSTR_MEMCPY) {
        let src: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Memcpy src");
        let dst: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Memcpy dst");
        let size: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Memcpy op1");
        buildMemcpy(&this.llvmBuilder, dst, 1, src, 1, size);
        return dst;
    } else if (instr.kind == INSTR_EMIT_ASSEMBLY) {
        let reg = at(regs, instr.src.i);
        let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM EmitAsm src"));
        let fnType = instr.op1.i as &Type;
        let context = start as &ASMContext;
        let retType = generateTypeFromASM(this, context);
        let args = collectValuesFromASM(this, context);
        let params: LLVMTypeList = blank;
        for (let i: usize = 0; i < args.length; i = i + 1) {
            push(&params, getType(&args.elements[i]));
        }
        let asmFn = intoFunctionType(&retType, params, false);
        let asmCall = getInlineAsm(&asmFn, context);
        return buildCall(&this.llvmBuilder, asmCall, asmFn, args, retType, newSubStrOfStrLit("asm"));
    } else {
        C::printf("LLVM %llu\n", instr.kind);
        todo_with_msg("unknown llvm kind");
    }
}
func collectValuesFromASM(this: &LLVMCodegen, context: &ASMContext) -> LLVMValueList {
    let list: LLVMValueList = blank;
    for (let i: usize = 0; i < context.args.length; i = i + 1) {
        push(&list, newLLVMValueFromRef(getArg(context, i)));
    }
    return list;
}
func generateTypeFromASM(this: &LLVMCodegen, context: &ASMContext) -> LLVMType {
    if (context.out.length == 0) return createVoidType(&this.llvmContext);
    if (context.out.length == 1) {
        let arg = newLLVMValueFromRef(getArg(context, 0));
        return getType(&arg);
    }
    let fields: &LLVMType = C::calloc(context.out.length, sizeof LLVMType);
    assert(fields != null);
    for (let i: usize = 0; i < context.out.length; i = i + 1) {
        let arg = newLLVMValueFromRef(getArg(context, i));
        fields[i] = getType(&arg);
    }
    let t = createStructType(&this.llvmContext, fields, context.out.length as u32, false);
    C::free(fields);
    return t;
}

func getComptimePointer(this: &LLVMCodegen, reg: &InterpReg) -> &u8 {
    let start: &u8 = getRegStackPointer(this.interp, reg);
    assert(start >= this.interp.regStackStart, "Expected comptime value to be allocated on Interp Reg Stack");
    assert(start < this.interp.regStackStart + REG_STACK_SIZE, "Expected comptime value to be allocated on Interp Reg Stack");
    return start;
}

func generateLLVMValueFromComptimePtr(this: &LLVMCodegen, typ: &Type, reg: InterpReg) -> LLVMValue {
    assert(isPointer(typ), "generateLLVMValueFromComptimePtr expected Pointer");
    assert(reg.size == 8, "generateLLVMValueFromComptimePtr expected Pointer sized register");
    let underlying: &Type = getUnderlyingType(typ, false);
    // load value from interp
    let start: &u8 = getComptimePointer(this, &reg);
    let val: LLVMValue = generateLLVMValueFromComptimeValue(this, underlying, start);
    // allocate it somewhere
    let _underlying: LLVMType = generateLLVMType(this, getUnderlyingType(typ, false));
    let alloc: LLVMValue = buildAlloca(&this.llvmBuilder, _underlying, newSubStrOfStrLit("comptimeToLLVM"));
    buildStore(&this.llvmBuilder, alloc, val);
    // return pointer to that
    return alloc;
}
func generateLLVMValueFromComptimeValue(this: &LLVMCodegen, typ: &Type, start: &u8) -> LLVMValue {
    assert(start != null, "generateLLVMValueFromComptimeValue got nullptr");
    let size: usize = getSizeInBytes(typ);
    match (typ) {
        &Type::Prim(prim) => {
            if (isInteger(typ)) {
                // Note: LLVM doesn't care about signedness for integers, that's all handled in the instructions
                if (size == 1) {
                    let val: u8 = *(start as &u8);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 8);
                    return constInt(&t, val as usize, false);
                } else if (size == 2) {
                    let val: u16 = *(start as &u16);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 16);
                    return constInt(&t, val as usize, false);
                } else if (size == 4) {
                    let val: u32 = *(start as &u32);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 32);
                    return constInt(&t, val as usize, false);
                } else if (size == 8) {
                    let val: u64 = *(start as &u64);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 64);
                    return constInt(&t, val as usize, false);
                } else {
                    unreachable("unexpected int size");
                }
            } else if (isFloat(typ)) {
                if (size == 4) {
                    let val = *(start as &f32);
                    let t = createFloatType(&this.llvmContext);
                    return constFloat(&t, val as f64);
                } else if (size == 8) {
                    let val = *(start as &f64);
                    let t = createDoubleType(&this.llvmContext);
                    return constFloat(&t, val);
                } else {
                    unreachable("unexpected float size");
                }
            } else if (isBoolean(typ)) {
                let val: u8 = *(start as &u8);
                assert(val == 0 || val == 1, "comptime bool is not 0 or 1");
                let t: LLVMType = createIntegerType(&this.llvmContext, 1);
                return constInt(&t, val as usize, false);
            } else if (isNone(typ)) {
                let t: LLVMType = createIntegerType(&this.llvmContext, 1);
                return constInt(&t, 1, false);
            } else {
                todo_with_msg("prim");
            }
        }
        &Type::Struct(decl) => {
            let lType: LLVMType = generateLLVMType(this, typ);
            assert(isStruct(&lType), "Expected LLVMType to be struct for comptime struct");
            let strukt: LLVMValue = constZero(&lType);
            let offset: usize = 0;
            let _size: usize = 0;
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                let fType: &Type = getType(&tDecl.typeState);
                getFieldOffsetAndSize(decl, i, &offset, &_size, false);
                let elemVal: LLVMValue = generateLLVMValueFromComptimeValue(this, fType, start + offset);
                strukt = buildInsertValue(&this.llvmBuilder, strukt, elemVal, i as u32, "comptime_struct_field");
            }
            return strukt;
        }
        &Type::Union(decl, variant) => {
            let lType: LLVMType = generateLLVMType(this, typ);
            assert(isStruct(&lType), "Expected LLVMType to be struct for comptime union");
            let union: LLVMValue = constZero(&lType);
            if (size == 0) {
                return union;
            }
            let smol = PrimType::U8;
            if (decl.variants.length >= 256) smol = PrimType::U16;
            let byte = wrap(Type::Prim(smol));
            {
                let tag = generateLLVMValueFromComptimeValue(this, byte, start);
                union = buildInsertValue(&this.llvmBuilder, union, tag, 0, "comptime_union_tag");
            }
            {
                // FIXME: The line below fails LLVM validation
                // let data = generateLLVMValueFromComptimeValue(this, wrap(Type::Array(byte, size - 1)), start + 1);
                let dataSize = size - 1;
                let offset = start + 1;
                if (decl.variants.length >= 256) {
                    dataSize = size - 2;
                    offset = start + 2;
                }
                let byt = wrap(Type::Prim(PrimType::U8));
                let data = generateLLVMValueFromComptimeValue(this, wrap(Type::Array(byt, dataSize)), offset);
                union = buildInsertValue(&this.llvmBuilder, union, data, 1, "comptime_union_tag");
            }
            return union;
        }
        &Type::Array(elemType, size) => {
            let llvmType = generateLLVMType(this, typ);
            let elemSize = getSizeInBytes(elemType);
            let array = constZero(&llvmType);
            for (let i: usize = 0; i < size; i = i + 1) {
                let offset = elemSize * i;
                let elem = generateLLVMValueFromComptimeValue(this, elemType, start + offset);
                array = buildInsertValue(&this.llvmBuilder, array, elem, i as u32, "comptime_array_elem");
            }
            return array;
        }
        // FIXME: Short-Circuiting for Pattern Matching so it doesn't deref this Ptr and segfault :^)
        // &Type::Ptr(&Type::Prim(PrimType::Char)) => {
        //     return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        // }
        &Type::Func(_,_,_) => {
            let id: usize = *(start as &usize);
            return at(&this.irGen.functions, id).llvmFunc;
        }
        &Type::Ptr(&Type::Prim(PrimType::Char)) => {
            return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        }
        typ => {
            C::fprintf(stderr, "%s\n", toString(typ).buffer);
            todo_with_msg("generateLLVMValueFromComptime");
        }
    }
    unreachable("Exhaustive handling in generateLLVMValueFromComptime");
}

func generateLLVMFunctionType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    let fnParams: TypeList = blank;
    let retType: &Type = null;
    let isVarArg = false;
    match (typ) {
        &Type::Func(_params, _ret, attr) => {
            fnParams = _params;
            retType = _ret;
            isVarArg = attr.isVariadic;
        }
        _ => { unreachable("generateLLVMFunctionType called on non function"); }
    }
    let params: LLVMTypeList = blank;
    if (getSizeInBytes(retType) > 8) {
        retType = intoPointer(retType);
        push(&params, prepareParameter(this, retType));
    }
    for (let i: usize = 0; i < fnParams.length; i = i + 1) {
        let t: &Type = *at(&fnParams, i);
        push(&params, prepareParameter(this, t));
    }
    let llvmType: LLVMType = prepareReturnType(this, retType);
    let llvmFuncType: LLVMType = intoFunctionType(&llvmType, params, isVarArg);
    return llvmFuncType;
}

func generateLLVMType(this: &LLVMCodegen, type: &Type) -> LLVMType {
    let typ: LLVMType = blank;
    match (type) {
        &Type::Prim(_) => {
            if (isInteger(type)) {
                typ = createIntegerType(&this.llvmContext, getSizeInBits(type) as i64);
            } else if (isChar(type)) {
                typ = createIntegerType(&this.llvmContext, 8);
            } else if (isBoolean(type)) {
                typ = createIntegerType(&this.llvmContext, 1);
            } else if (isFloat(type)) {
                match (type) {
                    &Type::Prim(PrimType::F32) => { typ = createFloatType(&this.llvmContext); }
                    &Type::Prim(PrimType::F64) => { typ = createDoubleType(&this.llvmContext); }
                    _ => { unreachable("Expected TYPE_F32 or TYPE_F64"); }
                }
            } else if (isNone(type)) {
                typ = createVoidType(&this.llvmContext);
            } else if (isAny(type)) {
                typ = intoPointerType(&createIntegerType(&this.llvmContext, 64));
            } else {
                C::fprintf(stderr, "%s\n", toString(type).buffer);
                todo_with_msg("generate primitive type");
            }
        }
        &Type::Ptr(_) => { typ = intoPointerType(&createIntegerType(&this.llvmContext, 64)); }
        &Type::Func(_,_,_) => { typ = intoPointerType(&createIntegerType(&this.llvmContext, 64)); }
        &Type::Array(under, size) => { typ = intoArrayType(&generateLLVMType(this, under), size as u32); }
        &Type::Struct(decl) => {
            let fields: &LLVMType = C::malloc(decl.context.fieldLength * sizeof LLVMType);
            assert(fields != null, "Could not allocate memory in LLVMCodegen.generateLLVMType");
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                fields[i] = generateLLVMType(this, getType(&tDecl.typeState));
            }
            let t: LLVMType = createStructType(&this.llvmContext, fields, decl.context.fieldLength as u32, false);
            C::free(fields);
            typ = t;
        }
        &Type::Union(decl, _) => {
            let size = getSizeInBytes(type) as u32;
            if (size == 0) {
                assert(decl.variants.length == 0, "LLVM: Union has size 0, but contains variants");
                typ = createStructType(&this.llvmContext, null, 0, false);
            } else {
                // Unions store the tag and an array of bytes
                let smol = PrimType::U8;
                let offset: u32 = 1;
                if (decl.variants.length >= 256) {
                    smol = PrimType::U16;
                    offset = 2;
                }
                let tag: LLVMType = generateLLVMType(this, wrap(Type::Prim(smol)));
                let data = intoArrayType(&tag, size - offset); // tag is stored differently
                let fields = [tag, data];
                typ = createStructType(&this.llvmContext, &fields[0], 2, false);
            }
        }
        &Type::Variadic(_) => {
            let fields: &LLVMType = C::calloc(2, sizeof LLVMType);
            assert(fields != null);
            fields[0] = intoPointerType(&createIntegerType(&this.llvmContext, 64));
            fields[1] = createIntegerType(&this.llvmContext, 64);
            typ = createStructType(&this.llvmContext, fields, 2, false);
        }
        &Type::Tuple(elems) => {
            let fields: &LLVMType = C::malloc(elems.length * sizeof LLVMType);
            assert(fields != null, "Could not allocate memory in LLVMCodegen.generateLLVMType");
            for (let i: usize = 0; i < elems.length; i = i + 1) {
                fields[i] = generateLLVMType(this, elems.elements[i]);
            }
            let t: LLVMType = createStructType(&this.llvmContext, fields, elems.length as u32, false);
            C::free(fields);
            typ = t;
        }
        _ => {
            todo_with_msg("generate llvm type");
        }
    }
    return typ;
}

func newLLVMCodegen(name: SubStr, irGen: &IRGen, interp: &IRInterp) -> LLVMCodegen {
    let llvmContext: LLVMContext = newLLVMContext();
    let llvmModule: LLVMModule = createModuleWithName(&llvmContext, name);
    let llvmBuilder: LLVMBuilder = createBuilder(&llvmContext);
    let llvmDIBuilder = createDIBuilder(llvmModule);
    initializeTargets(&llvmContext);
    let target: LLVMTarget = createTarget(&llvmContext, "x86-64");
    let triple: &char = createTargetTriple(&llvmContext, "x86-64");
    let options = createTargetMachineOptions();
    // REVIEW: Where do we get an ABI-string from? Do we even need to specify one?
    // setABI(options, "???");
    setCPU(options, "x86-64");
    // REVIEW: Why does stuff break when we specify other values for OptLevel, RelocMode, CodeModel?
    setCodeGenOptLevel(options, LLVM::CodeGenOptLevel::None);
    setRelocMode(options, LLVM::RelocMode::Default);
    setCodeModel(options, LLVM::CodeModel::Default);
    let targetMachine: LLVMTargetMachine = createTargetMachineWithOptions(target, triple, options);
    disposeTargetMachineOptions(options);
    setTriple(&llvmModule, triple);
    let l: LLVMTargetData = getTargetData(&targetMachine);
    setDataLayout(&llvmModule, getDataLayout(&l));
    {
        let u32: LLVMType = createIntegerType(&llvmContext, 32);
        addModuleFlag(llvmModule, LLVMModuleFlagBehaviorError, newSubStrOfStrLit("CodeView"), constInt(&u32, 1, false));
        addModuleFlag(llvmModule, LLVMModuleFlagBehaviorWarning, newSubStrOfStrLit("Debug Info Version"), constInt(&u32, 3, false));
    }
    return LLVMCodegen {
        llvmContext: llvmContext,
        llvmModule: llvmModule,
        llvmBuilder: llvmBuilder,
        llvmTargetMachine: targetMachine,
        llvmDIBuilder: llvmDIBuilder,
        irGen: irGen,
        interp: interp,
        global: blank,
    };
}
