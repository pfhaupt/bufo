import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "asm.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../util/hashmaps.bufo";
import "../util/arena.bufo";
import "../frontend/nodes.bufo";
import "../frontend/context.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./irgen.bufo";
import "./interp.bufo";
import "./LLVM/bindings.bufo";
import "./LLVM/module.bufo";
import "./LLVM/context.bufo";
import "./LLVM/builder.bufo";
import "./LLVM/values.bufo";
import "./LLVM/types.bufo";
import "./LLVM/basic_block.bufo";
import "./LLVM/pass_manager.bufo";
import "./LLVM/target.bufo";

union RegValue {
    None,
    LLVM(LLVMValue),
    Interp(InterpReg),
    Both(LLVMValue, InterpReg),
}
func equals(this: &RegValue, other: &RegValue) -> bool {
    todo_with_msg("RegValue.equals");
}
func addInterpValue(this: &RegValue, val: InterpReg) {
    match (this) {
        &RegValue::LLVM(llvm) => { *this = RegValue::Both(llvm, val); }
        &RegValue::Interp(_) => { *this = RegValue::Interp(val); }
        &RegValue::None => { *this = RegValue::Interp(val); }
        &RegValue::Both(llvm, _) => { *this = RegValue::Both(llvm, val); }
        _ => { unreachable(); }
    }
}
func addLLVMValue(this: &RegValue, val: LLVMValue) {
    match (this) {
        &RegValue::LLVM(_) => { *this = RegValue::LLVM(val); }
        &RegValue::Interp(interp) => { *this = RegValue::Both(val, interp); }
        &RegValue::None => { *this = RegValue::LLVM(val); }
        &RegValue::Both(_, interp) => { *this = RegValue::Both(val, interp); }
        _ => { unreachable(); }
    }
}
func asInterp(this: &RegValue, err: &char) -> InterpReg {
    match (this) {
        &RegValue::Interp(interp) => { return interp; }
        &RegValue::Both(_, interp) => { return interp; }
        _ => { }
    }
    unreachable(err);
}
func asLLVM(this: &RegValue, err: &char) -> LLVMValue {
    match (this) {
        &RegValue::LLVM(llvm) => { return llvm; }
        &RegValue::Both(llvm, _) => { return llvm; }
        _ => { }
    }
    unreachable(err);
}
func isLLVM(this: &RegValue) -> bool {
    match (this) {
        &RegValue::LLVM(_) => { return true; }
        &RegValue::Both(_, _) => { return true; }
        _ => { }
    }
    return false;
}
func isInterp(this: &RegValue) -> bool {
    match (this) {
        &RegValue::Interp(_) => { return true; }
        &RegValue::Both(_, _) => { return true; }
        _ => { }
    }
    return false;
}

struct LLVMCodegen {
    llvmContext: LLVMContext;
    llvmModule: LLVMModule;
    llvmBuilder: LLVMBuilder;
    llvmTargetMachine: LLVMTargetMachine;
    irGen: &IRGen;
    interp: &IRInterp;
    global: RegValueList;
}

func generateExecutable(this: &LLVMCodegen, outPath: SubStr) -> bool {
    // struct IRGen {
    //     globalScope: IRFunc;
    //     functions: String_IRFuncHashMap;
    trace("LLVMCodegen.generateExecutable");
    let fns: IRFuncList = asList(&this.irGen.functions);
    if (*flags.debug) {
        dumpInstructions(&this.irGen.globalScope);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            let f: &IRFunc = at(&fns, i);
            dumpInstructions(f);
        }
    }
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        generateLLVMFunctionHeader(this, at(&fns, i));
    }
    if (!generateEntryPoint(this)) return false;
    if (!generateGlobal(this, &this.irGen.globalScope)) return false;
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        let f: &IRFunc = at(&fns, i);
        if (!generateFunction(this, i, f)) return false;
    }
    if (*flags.debug) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_before.ll"));
    if (!verify(&this.llvmModule)) return false;
    let pm: LLVMPassManager = createPassManager(&this.llvmModule);
    addPromoteMemoryToRegisterPass(&pm);
    addAlwaysInlinerPass(&pm);
    addCFGSimplificationPass(&pm);
    addGlobalDCEPass(&pm);
    while (runOn(&pm, this.llvmModule)) {}
    if (*flags.debug) writeToFile(&this.llvmModule, newSubStrOfStrLit("debug_after.ll"));
    let objPath: String = toString(&outPath);
    pushStr(&objPath, ".obj");
    if (*flags.verbose) {
        C::printf("[INFO] Saving object file at %s\n", objPath.buffer);
    }
    writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMObjectFile, objPath.buffer);
    if (*flags.emitASM) {
        let asmPath = toString(&outPath);
        pushStr(&asmPath, ".s");
        C::printf("[INFO] Saving assembly code in %s\n", asmPath.buffer);
        writeToFile(&this.llvmTargetMachine, this.llvmModule, LLVMAssemblyFile, asmPath.buffer);
        drop(&asmPath);
    }
    if (*flags.emitLLVM) {
        let llvmPath = toString(&outPath);
        pushStr(&llvmPath, ".ll");
        C::printf("[INFO] Saving LLVM IR in %s\n", llvmPath.buffer);
        writeToFile(&this.llvmModule, asSubStr(&llvmPath));
        drop(&llvmPath);
    }
    return true;
}
func generateEntryPoint(this: &LLVMCodegen) -> bool {
    trace("LLVMCodegen.generateEntryPoint");
    if (*flags.dontLink) return true;
    // FIXME: Currently we hardcode the entry point.
    //        It would be cooler if the prelude or standard library did that.
    //        Needs more features though, like being able to provide custom
    //        names that overwrite the mangling
    let mainName: SubStr = newSubStrOfStrLit("maini32PPcri32");
    if (!hasFunction(&this.llvmModule, mainName)) {
        C::fprintf(stderr, "%s Could not find main function!\n", FATAL_STR);
        C::fprintf(stderr, "%s: The compiler currently requires that the input file also defines a main function.\n", NOTE_STR);
        C::fprintf(stderr, "%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n", NOTE_STR);
        return false;
    }
    let mainFunc: LLVMValue = getFunction(&this.llvmModule, mainName);
    let retType: LLVMType = createIntegerType(&this.llvmContext, 32);
    let params: LLVMTypeList = blank;
    push(&params, createIntegerType(&this.llvmContext, 32));
    let _p: LLVMType = createIntegerType(&this.llvmContext, 8);
    push(&params, intoPointerType(&_p));
    let retFnType: LLVMType = intoFunctionType(&retType, params, false);
    assert(!hasFunction(&this.llvmModule, newSubStrOfStrLit("main")));
    let main: LLVMValue = addFunction(&this.llvmModule, newSubStrOfStrLit("main"), retFnType);
    let entry: LLVMBasicBlock = appendBasicBlock(&this.llvmContext, main, newSubStrOfStrLit("entry"));
    positionAtEnd(&this.llvmBuilder, entry);
    let args: LLVMValueList = blank;
    push(&args, getNthParam(&main, 0));
    push(&args, getNthParam(&main, 1));
    let v: LLVMValue = buildCall(&this.llvmBuilder, mainFunc, retFnType, args, retType, newSubStrOfStrLit("entry"));
    buildReturn(&this.llvmBuilder, v);
    return true;
}
func generateGlobal(this: &LLVMCodegen, global: &IRFunc) -> bool {
    trace("LLVMCodegen.generateGlobal");
    this.global = blank;
    initBlank(&this.global, global.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(global);
    let llvmFunc: LLVMValue = blank;
    let blocks: LLVMBasicBlockList = blank;
    pushRegisterStack(this.interp, defaultSpan(), funcSize);
    this.interp.globalRegisters = &this.global;
    this.interp.globalRegBase = this.interp.regStackBase;
    assert(global.blocks.length == 1, "Expected to only find one IRBlock in global scope");
    generateBlock(this, &llvmFunc, global, &blocks, at(&global.blocks, 0), &this.global);
    return true;
}

func generateLLVMFunctionHeader(this: &LLVMCodegen, irFunc: &IRFunc) {
    let llvmFunc: LLVMValue = blank;
    let function: &ParsedFuncDecl = getFuncNode(irFunc);
    let llvmFuncType = generateLLVMFunctionType(this, getType(&function.typeState));
    let llvmFuncValue: LLVMValue = addFunction(&this.llvmModule, asSubStr(&irFunc.name), llvmFuncType);
    if (hasAttribute(irFunc, ATTR_NORETURN)) {
        let id = LLVM::GetEnumAttributeKindForName("noreturn", 8 /* sizeof "noreturn" */);
        assert(id != 0, "Could not get noreturn attribute from LLVM");
        addAttribute(&llvmFuncValue, U32_MAX, createEnumAttribute(&this.llvmContext, id, 1));
    }
    (*irFunc).llvmFunc = llvmFuncValue;
    let origFunc: &IRFunc = get(&this.irGen.functions, &irFunc.name);
    (*origFunc).llvmFunc = llvmFuncValue;
}

func prepareReturnType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareReturnType");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        return generateLLVMType(this, t);
    } else {
        return generateLLVMType(this, typ);
    }
}

func prepareParameter(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareParameter");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (isStruct(typ)) {
        let size: usize = getSize(typ);
        let t: &Type = null;
        if (size <= 1) {
            t = wrap(Type::Prim(PrimType::U8));
        } else if (size <= 2) {
            t = wrap(Type::Prim(PrimType::U16));
        } else if (size <= 4) {
            t = wrap(Type::Prim(PrimType::U32));
        } else if (size <= 8) {
            t = wrap(Type::Prim(PrimType::U64));
        } else {
            t = wrap(Type::Ptr(wrap(Type::Prim(PrimType::U8))));
        }
        return generateLLVMType(this, t);
    } else if (getSize(typ) > 8) {
        return generateLLVMType(this, intoPointer(typ));
    } else {
        return generateLLVMType(this, typ);
    }
}

func getLLVMTypeSize(this: &LLVMCodegen, typ: &LLVMType) -> usize {
    trace("LLVMCodegen.getLLVMTypeSize");
    let data: LLVMTargetData = getTargetData(&this.llvmTargetMachine);
    let s1: usize = getStoreSize(&data, typ);
    let s2: usize = getABISize(&data, typ);
    let s3: usize = getBitSize(&data, typ) / 8;
    assert(s1 == s2 && s1 == s3 && s2 == s3, "LLVMTargetData returned different type sizes");
    return s1;
}

func generateFunction(this: &LLVMCodegen, index: usize, irFunc: &IRFunc) -> bool {
    trace("LLVMCodegen.generateFunction");
    if (isExtern(irFunc)) return true;
    let llvmFuncValue: LLVMValue = irFunc.llvmFunc;
    assert(!LLVM::isNull(llvmFuncValue.ref));
    let blocks: LLVMBasicBlockList = blank;
    initBlank(&blocks, irFunc.blocks.length);
    assert(blocks.length != 0, "Every IRFunc has at least one instruction");
    *(at(&blocks, 0)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("entry"));
    for (let i: usize = 1; i < irFunc.blocks.length; i = i + 1) {
        *(at(&blocks, i)) = appendBasicBlock(&this.llvmContext, llvmFuncValue, newSubStrOfStrLit("b"));
    }
    let regs: RegValueList = blank;
    initBlank(&regs, irFunc.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    pushRegisterStack(this.interp, irFunc.span, funcSize);
    for (let i: usize = 0; i < irFunc.blocks.length; i = i + 1) {
        let block: &IRBlock = getBlockByID(irFunc, IRBlockID { i: i });
        positionAtEnd(&this.llvmBuilder, *at(&blocks, i));
        generateBlock(this, &llvmFuncValue, irFunc, &blocks, block, &regs);
    }
    popRegisterStack(this.interp, irFunc.span, funcSize);
    return true;
}
func generateBlock(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    llvmBlocks: &LLVMBasicBlockList,
    block: &IRBlock,
    regs: &RegValueList,
) {
    for (let i: usize = 0; i < block.instructions.length; i = i + 1) {
        let instr: &IRInstr = at(&block.instructions, i);
        if (instr.kind == INSTR_ALLOCA) {
            let llvm = generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs);
            let interp = evaluateSingle(this.interp, irFunc, instr, regs, true);
            addLLVMValue((at(regs, instr.dst.i)), llvm);
            addInterpValue((at(regs, instr.dst.i)), interp);
        } else if (instr.isComptime) {
            let val = evaluateSingle(this.interp, irFunc, instr, regs, false);
            if (!isTerminator(instr)) addInterpValue((at(regs, instr.dst.i)), val);
        } else {
            let val = generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs);
            if (!isTerminator(instr)) addLLVMValue((at(regs, instr.dst.i)), val);
        }
    }
}

func generateLLVMInstr(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    blocks: &LLVMBasicBlockList,
    instr: &IRInstr,
    regs: &RegValueList,
) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMInstr");
    let isGlobal: bool = LLVM::isNull(llvmFunc.ref);
    if (instr.kind == INSTR_ALLOCA) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isPointer(reg.typ), "LLVM Alloca expected ptr dst");
        let t: &Type = getUnderlyingType(reg.typ, false);
        let typ: LLVMType = generateLLVMType(this, t);
        if (isGlobal) {
            return addGlobal(&this.llvmModule, typ, 0, newSubStrOfStrLit("g"));
        } else {
            return buildAlloca(&this.llvmBuilder, typ, newSubStrOfStrLit("v"));
        }
    } else if (instr.kind == INSTR_GET_PARAM) {
        assert(!isGlobal);
        let param: LLVMValue = getNthParam(llvmFunc, instr.src.i);
        setName(&param, newSubStrOfStrLit("p"));
        return param;
    } else if (instr.kind == INSTR_STORE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Store dst");
        let srcVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Store src");
        if (isGlobal) {
            setInitializer(&dstVal, srcVal);
        } else {
            buildStore(&this.llvmBuilder, dstVal, srcVal);
        }
        return dstVal;
    } else if (instr.kind == INSTR_LOAD_FUNCTION_PTR) {
        let called: &IRFunc = at(&this.irGen.functions, instr.src.i);
        return called.llvmFunc;
    } else if (instr.kind == INSTR_LOAD) {
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: &RegValue = at(regs, instr.src.i);
        if (isLLVM(reg)) {
            let srcVal: LLVMValue = asLLVM(reg, "LLVM Load");
            if (isGlobal) {
                todo_with_msg("LLVM global load");
            } else {
                return buildLoad(&this.llvmBuilder, dstTyp, srcVal, newSubStrOfStrLit("load"));
            }
        } else {
            let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM Load from comptime"));
            return generateLLVMValueFromComptimeValue(this, typ, *(start as &usize) as &u8);
        }
    } else if (instr.kind == INSTR_MOVE) {
        return asLLVM(at(regs, instr.src.i), "LLVM Move");
    } else if (instr.kind == INSTR_FETCH_GLOBAL_PTR) {
        let val: &RegValue = at(&this.global, instr.src.i);
        if (isLLVM(val)) {
            return asLLVM(val, "We just checked if it is LLVM");
        } else {
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            return generateLLVMValueFromComptimePtr(this, typ, reg);
        }
    } else if (instr.kind == INSTR_FETCH_GLOBAL_VALUE) {
        let val: &RegValue = at(&this.global, instr.src.i);
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        assert(isLLVM(val), "FetchGlobalValue got non-LLVM src");
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: LLVMValue = asLLVM(val, "We just checked if it is LLVM");
        return buildLoad(&this.llvmBuilder, dstTyp, reg, newSubStrOfStrLit("fetchglobalval"));
    } else if (instr.kind == INSTR_FETCH_COMPTIME_VALUE) {
        if (instr.op1.i == 1) {
            // Global fetch
            let val: &RegValue = at(&this.global, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!isLLVM(val), "FetchComptimeValue global=1 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getGlobalPointer(this.interp, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        } else {
            // Local fetch
            let val: &RegValue = at(regs, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!isLLVM(val), "FetchComptimeValue global=0 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getComptimePointer(this, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        }
    } else if (instr.kind == INSTR_INT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntAdd(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("iadd"));
    } else if (instr.kind == INSTR_INT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntSub(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("isub"));
    } else if (instr.kind == INSTR_INT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMul(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imul"));
    } else if (instr.kind == INSTR_INT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntDiv(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("idiv"));
    } else if (instr.kind == INSTR_INT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModInt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        return buildIntMod(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imod"));
    } else if (instr.kind == INSTR_FLOAT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddFloat");
        return buildFloatAdd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fadd"));
    } else if (instr.kind == INSTR_FLOAT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubFloat");
        return buildFloatSub(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fsub"));
    } else if (instr.kind == INSTR_FLOAT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulFloat");
        return buildFloatMul(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmul"));
    } else if (instr.kind == INSTR_FLOAT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivFloat");
        return buildFloatDiv(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fdiv"));
    } else if (instr.kind == INSTR_FLOAT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModFloat");
        return buildFloatMod(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmod"));
    } else if (instr.kind == INSTR_INT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpNeq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntNE, lhsVal, rhsVal, newSubStrOfStrLit("icmpne"));
    } else if (instr.kind == INSTR_INT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpEq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntEQ, lhsVal, rhsVal, newSubStrOfStrLit("icmpeq"));
    } else if (instr.kind == INSTR_INT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLT, lhsVal, rhsVal, newSubStrOfStrLit("icmpslt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULT, lhsVal, rhsVal, newSubStrOfStrLit("icmpult"));
    } else if (instr.kind == INSTR_INT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsle"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULE, lhsVal, rhsVal, newSubStrOfStrLit("icmpule"));
    } else if (instr.kind == INSTR_INT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGt");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpsgt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpugt"));
    } else if (instr.kind == INSTR_INT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGte");
        let signed: bool = isSignedInteger(getRegister(irFunc, instr.src).typ);
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsge"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpuge"));
    } else if (instr.kind == INSTR_FLOAT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpNeq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUNE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpne"));
    } else if (instr.kind == INSTR_FLOAT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpEq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUEQ, lhsVal, rhsVal, newSubStrOfStrLit("fcmpeq"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpult"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpule"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpugt"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpuge"));
    } else if (instr.kind == INSTR_LOGICAL_NOT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Not");
        return buildNot(&this.llvmBuilder, val, newSubStrOfStrLit("lnot"));
    } else if (instr.kind == INSTR_LOGICAL_OR || instr.kind == INSTR_BITWISE_OR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Or");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical Or");
        return buildOr(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("lor"));
    } else if (instr.kind == INSTR_LOGICAL_AND || instr.kind == INSTR_BITWISE_AND) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical And");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical And");
        return buildAnd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("land"));
    } else if (instr.kind == INSTR_BITWISE_XOR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Bitwise Xor");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Bitwise Xor");
        return buildXor(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("bxor"));
    } else if (instr.kind == INSTR_CALL) {
        let calledFunc: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Call");
        assert(!LLVM::isNull(calledFunc.ref), "Call tried to call invalid LLVMValue");
        let args: LLVMValueList = blank;
        initBlank(&args, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&args, i)) = asLLVM(argReg, "LLVM Call Arg");
        }
        let base: &IRReg = getRegister(irFunc, instr.src);
        let bt = base.typ;
        if (isPointer(bt)) bt = getUnderlyingType(bt, true);
        assert(isFunction(bt), "Call tried to call non-function base");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let retType = generateLLVMType(this, reg.typ);
        let fnType = generateLLVMFunctionType(this, bt);
        return buildCall(&this.llvmBuilder, calledFunc, fnType, args, retType, newSubStrOfStrLit("call"));
    } else if (instr.kind == INSTR_COND_BR) {
        let cond: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM CondBr");
        buildCondBr(&this.llvmBuilder, cond, *at(blocks, instr.dst.i), *at(blocks, instr.op1.i));
        return blank;
    } else if (instr.kind == INSTR_UNREACHABLE) {
        buildUnreachable(&this.llvmBuilder);
        return blank;
    } else if (instr.kind == INSTR_UNTERMINATED) {
        C::fprintf(stderr, "%s %s: UNTERMINATED BLOCK FOUND!!!\n", toString(&instr.span).buffer, FATAL_STR);
        unreachable("LLVM: Received INSTR_UNTERMINATED, Control Flow Analysis should've caught this!");
    } else if (instr.kind == INSTR_BR) {
        buildBr(&this.llvmBuilder, *at(blocks, instr.dst.i));
        return blank;
    } else if (instr.kind == INSTR_RETURN_EXPR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM RetExpr");
        buildReturn(&this.llvmBuilder, val);
        return blank;
    } else if (instr.kind == INSTR_RETURN_VOID) {
        buildReturnVoid(&this.llvmBuilder);
        return blank;
    } else if (instr.kind == INSTR_LOAD_I8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U8) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 8);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U16) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 16);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U32) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 32);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U64) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_F32) {
        let t: LLVMType = createFloatType(&this.llvmContext);
        return constFloat(&t, *(&instr.src.i as &f32) as f64);
    } else if (instr.kind == INSTR_LOAD_F64) {
        let t: LLVMType = createDoubleType(&this.llvmContext);
        return constFloat(&t, *(&instr.src.i as &f64));
    } else if (instr.kind == INSTR_LOAD_BOOL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 1);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_NULL) {
        let t: LLVMType = createIntegerType(&this.llvmContext, 64);
        let pt: LLVMType = intoPointerType(&t);
        return constZero(&pt);
    } else if (instr.kind == INSTR_LOAD_BLANK) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_ARRAY) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(isArray(reg.typ), "LLVM Expected Array in INSTR_CREATE_ARRAY");
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_STRUCT) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_UNION) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_INSERT_VALUE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM InsertValue");
        let index: usize = instr.src.i;
        let elemVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM InsertValue");
        let newVal: LLVMValue = buildInsertValue(&this.llvmBuilder, 
            dstVal,
            elemVal,
            index as u32,
            "arr_elem",
        );
        return newVal;
    } else if (instr.kind == INSTR_PTR_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM PtrToInt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        return buildPtrToInt(&this.llvmBuilder, val, typ, newSubStrOfStrLit("p2i"));
    } else if (instr.kind == INSTR_INT_TO_PTR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToPtr");
        let typ: LLVMType = createIntegerType(&this.llvmContext, 64);
        let ptr: LLVMType = intoPointerType(&typ);
        return buildIntToPtr(&this.llvmBuilder, val, ptr, newSubStrOfStrLit("i2p"));
    } else if (instr.kind == INSTR_INT_TO_F32 || instr.kind == INSTR_INT_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToF32 / IntToF64");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = createFloatType(&this.llvmContext);
        if (instr.kind == INSTR_INT_TO_F64) typ = createDoubleType(&this.llvmContext);
        return buildIntToFloat(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("i2f"));
    } else if (instr.kind == INSTR_F32_TO_INT || instr.kind == INSTR_F64_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToInt / F64ToInt");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let signed: bool = isSignedInteger(reg.typ);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return buildFloatToInt(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("f2i"));
    } else if (instr.kind == INSTR_F32_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToF64");
        let typ: LLVMType = createDoubleType(&this.llvmContext);
        return buildFloatExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f32tof64"));
    } else if (instr.kind == INSTR_F64_TO_F32) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F64ToF32");
        let typ: LLVMType = createFloatType(&this.llvmContext);
        return buildFloatTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f64tof32"));
    } else if (instr.kind == INSTR_INT_SIGN_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntSignExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntSignExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("sext"));
    } else if (instr.kind == INSTR_INT_ZERO_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntZeroExt");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntZeroExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("zext"));
    } else if (instr.kind == INSTR_INT_TRUNCATE) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntTrunc");
        let typ: LLVMType = createIntegerType(&this.llvmContext, instr.op1.i as i64);
        return buildIntTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("trunc"));
    } else if (instr.kind == INSTR_LOAD_STRING) {
        return buildGlobalStringPtr(&this.llvmBuilder, instr.src.i as &char, newSubStrOfStrLit("str"));
    } else if (instr.kind == INSTR_GET_ELEMENT_PTR) {
        let indices: LLVMValueList = blank;
        initBlank(&indices, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&indices, i)) = asLLVM(argReg, "LLVM GEP Index");
        }
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetElementPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        let underlying: &Type = getUnderlyingType(ptr, false);
        return buildGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, indices, newSubStrOfStrLit("gep"));
    } else if (instr.kind == INSTR_GET_FIELD_PTR) {
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetFieldPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        assert(isPointer(ptr), "LLVM GetFieldPtr wants ptr reg");
        let aggrType: LLVMType = getType(&aggr);
        assert(isPointer(&aggrType), "Expected Pointer to Struct in GetFieldPtr");
        let underlying: &Type = getUnderlyingType(ptr, false);
        assert(isStruct(underlying), "LLVM GetFieldPtr wants ptr to struct");
        return buildStructGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, instr.op1.i, newSubStrOfStrLit("field_ptr"));
    } else if (instr.kind == INSTR_MEMCPY) {
        let src: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Memcpy src");
        let dst: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Memcpy dst");
        let size: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Memcpy op1");
        buildMemcpy(&this.llvmBuilder, dst, 1, src, 1, size);
        return dst;
    } else if (instr.kind == INSTR_EMIT_ASSEMBLY) {
        let reg = at(regs, instr.src.i);
        let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM EmitAsm src"));
        let fnType = instr.op1.i as &Type;
        let context = start as &ASMContext;
        let retType = generateTypeFromASM(this, context);
        let args = collectValuesFromASM(this, context);
        let params: LLVMTypeList = blank;
        for (let i: usize = 0; i < args.length; i = i + 1) {
            push(&params, getType(&args.elements[i]));
        }
        let asmFn = intoFunctionType(&retType, params, false);
        let asmCall = getInlineAsm(&asmFn, context);
        return buildCall(&this.llvmBuilder, asmCall, asmFn, args, retType, newSubStrOfStrLit("asm"));
    } else {
        C::printf("LLVM %llu\n", instr.kind);
        todo_with_msg("unknown llvm kind");
    }
}
func collectValuesFromASM(this: &LLVMCodegen, context: &ASMContext) -> LLVMValueList {
    let list: LLVMValueList = blank;
    for (let i: usize = 0; i < context.args.length; i = i + 1) {
        push(&list, newLLVMValueFromRef(getArg(context, i)));
    }
    return list;
}
func generateTypeFromASM(this: &LLVMCodegen, context: &ASMContext) -> LLVMType {
    if (context.out.length == 0) return createVoidType(&this.llvmContext);
    if (context.out.length == 1) {
        let arg = newLLVMValueFromRef(getArg(context, 0));
        return getType(&arg);
    }
    let fields: &LLVMType = C::calloc(context.out.length, sizeof LLVMType);
    assert(fields != null);
    for (let i: usize = 0; i < context.out.length; i = i + 1) {
        let arg = newLLVMValueFromRef(getArg(context, i));
        fields[i] = getType(&arg);
    }
    let t = createStructType(&this.llvmContext, fields, context.out.length as u32, false);
    C::free(fields);
    return t;
}

func getComptimePointer(this: &LLVMCodegen, reg: &InterpReg) -> &u8 {
    trace("LLVMCodegen.getComptimePointer");
    let start: &u8 = getRegStackPointer(this.interp, reg);
    assert(start >= this.interp.regStackStart, "Expected comptime value to be allocated on Interp Reg Stack");
    assert(start < this.interp.regStackStart + REG_STACK_SIZE, "Expected comptime value to be allocated on Interp Reg Stack");
    return start;
}

func generateLLVMValueFromComptimePtr(this: &LLVMCodegen, typ: &Type, reg: InterpReg) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimePtr");
    assert(isPointer(typ), "generateLLVMValueFromComptimePtr expected Pointer");
    assert(reg.size == 8, "generateLLVMValueFromComptimePtr expected Pointer sized register");
    let underlying: &Type = getUnderlyingType(typ, false);
    // load value from interp
    let start: &u8 = getComptimePointer(this, &reg);
    let val: LLVMValue = generateLLVMValueFromComptimeValue(this, underlying, start);
    // allocate it somewhere
    let _underlying: LLVMType = generateLLVMType(this, getUnderlyingType(typ, false));
    let alloc: LLVMValue = buildAlloca(&this.llvmBuilder, _underlying, newSubStrOfStrLit("comptimeToLLVM"));
    buildStore(&this.llvmBuilder, alloc, val);
    // return pointer to that
    return alloc;
}
func generateLLVMValueFromComptimeValue(this: &LLVMCodegen, typ: &Type, start: &u8) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimeValue");
    assert(start != null, "generateLLVMValueFromComptimeValue got nullptr");
    let size: usize = getSize(typ);
    match (typ) {
        &Type::Prim(prim) => {
            if (isInteger(typ)) {
                // Note: LLVM doesn't care about signedness for integers, that's all handled in the instructions
                if (size == 1) {
                    let val: u8 = *(start as &u8);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 8);
                    return constInt(&t, val as usize, false);
                } else if (size == 2) {
                    let val: u16 = *(start as &u16);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 16);
                    return constInt(&t, val as usize, false);
                } else if (size == 4) {
                    let val: u32 = *(start as &u32);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 32);
                    return constInt(&t, val as usize, false);
                } else if (size == 8) {
                    let val: u64 = *(start as &u64);
                    let t: LLVMType = createIntegerType(&this.llvmContext, 64);
                    return constInt(&t, val as usize, false);
                } else {
                    unreachable("unexpected int size");
                }
            } else if (isFloat(typ)) {
                if (size == 4) {
                    let val = *(start as &f32);
                    let t = createFloatType(&this.llvmContext);
                    return constFloat(&t, val as f64);
                } else if (size == 8) {
                    let val = *(start as &f64);
                    let t = createDoubleType(&this.llvmContext);
                    return constFloat(&t, val);
                } else {
                    unreachable("unexpected float size");
                }
            } else if (isBoolean(typ)) {
                let val: u8 = *(start as &u8);
                assert(val == 0 || val == 1, "comptime bool is not 0 or 1");
                let t: LLVMType = createIntegerType(&this.llvmContext, 1);
                return constInt(&t, val as usize, false);
            } else if (isNone(typ)) {
                let t: LLVMType = createIntegerType(&this.llvmContext, 1);
                return constInt(&t, 1, false);
            } else {
                todo_with_msg("prim");
            }
        }
        &Type::Struct(decl) => {
            let lType: LLVMType = generateLLVMType(this, typ);
            assert(isStruct(&lType), "Expected LLVMType to be struct for comptime struct");
            let strukt: LLVMValue = constZero(&lType);
            let offset: usize = 0;
            let _size: usize = 0;
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                let fType: &Type = getType(&tDecl.typeState);
                getFieldOffsetAndSize(decl, i, &offset, &_size);
                let elemVal: LLVMValue = generateLLVMValueFromComptimeValue(this, fType, start + offset);
                strukt = buildInsertValue(&this.llvmBuilder, strukt, elemVal, i as u32, "comptime_struct_field");
            }
            return strukt;
        }
        &Type::Union(decl, variant) => {
            let lType: LLVMType = generateLLVMType(this, typ);
            assert(isStruct(&lType), "Expected LLVMType to be struct for comptime union");
            let union: LLVMValue = constZero(&lType);
            if (size == 0) {
                return union;
            }
            let smol = PrimType::U8;
            if (decl.variants.length >= 256) smol = PrimType::U16;
            let byte = wrap(Type::Prim(smol));
            {
                let tag = generateLLVMValueFromComptimeValue(this, byte, start);
                buildInsertValue(&this.llvmBuilder, union, tag, 0, "comptime_union_tag");
            }
            {
                // FIXME: The line below fails LLVM validation
                // let data = generateLLVMValueFromComptimeValue(this, wrap(Type::Array(byte, size - 1)), start + 1);
                let dataSize = size - 1;
                let offset = start + 1;
                if (decl.variants.length >= 256) {
                    dataSize = size - 2;
                    offset = start + 2;
                }
                let byt = wrap(Type::Prim(PrimType::U8));
                let data = generateLLVMValueFromComptimeValue(this, wrap(Type::Array(byt, dataSize)), offset);
                buildInsertValue(&this.llvmBuilder, union, data, 1, "comptime_union_tag");
            }
            return union;
        }
        &Type::Array(elemType, size) => {
            let llvmType = generateLLVMType(this, typ);
            let elemSize = getSize(elemType);
            let array = constZero(&llvmType);
            for (let i: usize = 0; i < size; i = i + 1) {
                let offset = elemSize * i;
                let elem = generateLLVMValueFromComptimeValue(this, elemType, start + offset);
                array = buildInsertValue(&this.llvmBuilder, array, elem, i as u32, "comptime_array_elem");
            }
            return array;
        }
        // FIXME: Short-Circuiting for Pattern Matching so it doesn't deref this Ptr and segfault :^)
        // &Type::Ptr(&Type::Prim(PrimType::Char)) => {
        //     return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        // }
        &Type::Func(_,_,_) => {
            let id: usize = *(start as &usize);
            return at(&this.irGen.functions, id).llvmFunc;
        }
        &Type::Ptr(&Type::Prim(PrimType::Char)) => {
            return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        }
        typ => {
            C::fprintf(stderr, "%s\n", toString(typ).buffer);
            todo_with_msg("generateLLVMValueFromComptime");
        }
    }
    unreachable("Exhaustive handling in generateLLVMValueFromComptime");
}

func generateLLVMFunctionType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.generateLLVMFunctionType");
    let fnParams: TypeList = blank;
    let retType: &Type = null;
    let isVarArg = false;
    match (typ) {
        &Type::Func(_params, _ret, attr) => {
            fnParams = _params;
            retType = _ret;
            isVarArg = attr.isVariadic;
        }
        _ => { unreachable("generateLLVMFunctionType called on non function"); }
    }
    let params: LLVMTypeList = blank;
    if (getSize(retType) > 8) {
        retType = intoPointer(retType);
        push(&params, prepareParameter(this, retType));
    }
    for (let i: usize = 0; i < fnParams.length; i = i + 1) {
        let t: &Type = *at(&fnParams, i);
        push(&params, prepareParameter(this, t));
    }
    let llvmType: LLVMType = prepareReturnType(this, retType);
    let llvmFuncType: LLVMType = intoFunctionType(&llvmType, params, isVarArg);
    return llvmFuncType;
}

func generateLLVMType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.generateLLVMType");
    match (typ) {
        &Type::Prim(_) => {
            if (isInteger(typ)) {
                return createIntegerType(&this.llvmContext, getSize(typ) as i64 * 8);
            } else if (isChar(typ)) {
                return createIntegerType(&this.llvmContext, 8);
            } else if (isBoolean(typ)) {
                return createIntegerType(&this.llvmContext, 1);
            } else if (isFloat(typ)) {
                match (typ) {
                    &Type::Prim(PrimType::F32) => { return createFloatType(&this.llvmContext); }
                    &Type::Prim(PrimType::F64) => { return createDoubleType(&this.llvmContext); }
                    _ => { unreachable("Expected TYPE_F32 or TYPE_F64"); }
                }
            } else if (isNone(typ)) {
                return createVoidType(&this.llvmContext);
            } else if (isAny(typ)) {
                return intoPointerType(&createIntegerType(&this.llvmContext, 64));
            } else {
                C::fprintf(stderr, "%s\n", toString(typ).buffer);
                todo_with_msg("generate primitive type");
            }
        }
        &Type::Ptr(_) => { return intoPointerType(&createIntegerType(&this.llvmContext, 64)); }
        &Type::Func(_,_,_) => { return intoPointerType(&createIntegerType(&this.llvmContext, 64)); }
        &Type::Array(under, size) => { return intoArrayType(&generateLLVMType(this, under), size as u32); }
        &Type::Struct(decl) => {
            let fields: &LLVMType = C::malloc(decl.context.fieldLength * sizeof LLVMType);
            assert(fields != null, "Could not allocate memory in LLVMCodegen.generateLLVMType");
            for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
                let tDecl: &ParsedTypeNode = getFieldTypeAtIndex(&decl.context, i);
                fields[i] = generateLLVMType(this, getType(&tDecl.typeState));
            }
            let t: LLVMType = createStructType(&this.llvmContext, fields, decl.context.fieldLength as u32, false);
            C::free(fields);
            return t;
        }
        &Type::Union(decl, _) => {
            let size = getSize(typ) as u32;
            if (size == 0) {
                assert(decl.variants.length == 0, "LLVM: Union has size 0, but contains variants");
                return createStructType(&this.llvmContext, null, 0, false);
            }
            // Unions store the tag and an array of bytes
            let smol = PrimType::U8;
            let offset: u32 = 1;
            if (decl.variants.length >= 256) {
                smol = PrimType::U16;
                offset = 2;
            }
            let tag: LLVMType = generateLLVMType(this, wrap(Type::Prim(smol)));
            let data = intoArrayType(&tag, size - offset); // tag is stored differently
            let fields = [tag, data];
            return createStructType(&this.llvmContext, &fields[0], 2, false);
        }
        _ => { }
    }
    todo_with_msg("generate llvm type");
}

func newLLVMCodegen(name: SubStr, irGen: &IRGen, interp: &IRInterp) -> LLVMCodegen {
    let llvmContext: LLVMContext = newLLVMContext();
    let llvmModule: LLVMModule = createModuleWithName(&llvmContext, name);
    let llvmBuilder: LLVMBuilder = createBuilder(&llvmContext);
    initializeTargets(&llvmContext);
    let target: LLVMTarget = createTarget(&llvmContext, "x86-64");
    let triple: &char = createTargetTriple(&llvmContext, "x86-64");
    let targetMachine: LLVMTargetMachine = createTargetMachine(&target, triple, "x86-64", "");
    setTriple(&llvmModule, triple);
    let l: LLVMTargetData = getTargetData(&targetMachine);
    setDataLayout(&llvmModule, getDataLayout(&l));
    return LLVMCodegen {
        llvmContext: llvmContext,
        llvmModule: llvmModule,
        llvmBuilder: llvmBuilder,
        llvmTargetMachine: targetMachine,
        irGen: irGen,
        interp: interp,
        global: blank,
    };
}
