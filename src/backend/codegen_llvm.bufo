import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../bufo.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../frontend/nodes.bufo";
import "../middleend/types.bufo";
import "../middleend/checker.bufo";
import "./irgen.bufo";
import "./interp.bufo";
import "./LLVM/bindings.bufo";
import "./LLVM/module.bufo";
import "./LLVM/context.bufo";
import "./LLVM/builder.bufo";
import "./LLVM/values.bufo";
import "./LLVM/types.bufo";
import "./LLVM/basic_block.bufo";
import "./LLVM/pass_manager.bufo";
import "./LLVM/target.bufo";

struct RegValue {
    isLLVM: bool;
    regValue: InterpReg;
    llvmValue: LLVMValue;
}
func equals(this: &RegValue, other: &RegValue) -> bool {
    todo_with_msg("RegValue.equals");
}
func asInterp(this: &RegValue, err: &char) -> InterpReg {
    assert(!this.isLLVM, err);
    return this.regValue;
}
func asLLVM(this: &RegValue, err: &char) -> LLVMValue {
    assert(this.isLLVM, err);
    return this.llvmValue;
}

struct LLVMCodegen {
    llvmContext: LLVMContext;
    llvmModule: LLVMModule;
    llvmBuilder: LLVMBuilder;
    llvmTargetMachine: LLVMTargetMachine;
    irGen: &IRGen;
    interp: &IRInterp;
    global: RegValueList;
}

func generateExecutable(this: &LLVMCodegen, outPath: SubStr) -> bool {
    // struct IRGen {
    //     globalScope: IRFunc;
    //     functions: String_IRFuncHashMap;
    trace("LLVMCodegen.generateExecutable");
    let fns: IRFuncList = this.irGen.functions.asList();
    if (PRINT_DEBUG) {
        dumpInstructions(&this.irGen.globalScope);
        for (let i: usize = 0; i < fns.length; i = i + 1) {
            let f: &IRFunc = at(&fns, i);
            dumpInstructions(f);
        }
    }
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        generateLLVMFunctionHeader(this, at(&fns, i));
    }
    if (!generateEntryPoint(this)) return false;
    if (!generateGlobal(this, &this.irGen.globalScope)) return false;
    for (let i: usize = 0; i < fns.length; i = i + 1) {
        let f: &IRFunc = at(&fns, i);
        if (!generateFunction(this, i, f)) return false;
    }
    if (PRINT_DEBUG) this.llvmModule.writeToFile(newSubStrOfStrLit("debug_before.ll"));
    if (!this.llvmModule.verify()) return false;
    let pm: LLVMPassManager = this.llvmModule.createPassManager();
    pm.addPromoteMemoryToRegisterPass();
    pm.addAlwaysInlinerPass();
    pm.addCFGSimplificationPass();
    pm.addGlobalDCEPass();
    while (true) if (!pm.runOn(this.llvmModule)) break;
    if (PRINT_DEBUG) this.llvmModule.writeToFile(newSubStrOfStrLit("debug_after.ll"));
    let path: String = outPath.toString();
    path.pushStr(".obj");
    if (*flags.verbose) {
        printf("[INFO] Saving object file at %s\n", path.chars());
    }
    this.llvmTargetMachine.writeToFile(this.llvmModule, LLVMObjectFile, path.chars());
    // path = outPath.toString();
    // path.pushStr(".s");
    // printf("written to: %s\n", path.chars());
    // this.llvmTargetMachine.writeToFile(this.llvmModule, LLVMAssemblyFile, path.chars());
    return true;
}
func generateEntryPoint(this: &LLVMCodegen) -> bool {
    trace("LLVMCodegen.generateEntryPoint");
    // FIXME: Currently we hardcode the entry point.
    //        It would be cooler if the prelude or standard library did that.
    //        Needs more features though, like being able to provide custom
    //        names that overwrite the mangling
    let mainName: SubStr = newSubStrOfStrLit("maini32PPcri32");
    if (!this.llvmModule.hasFunction(mainName)) {
        fprintf(stderr, "%s Could not find main function!\n", FATAL_STR);
        fprintf(stderr, "%s: The compiler currently requires that the input file also defines a main function.\n", NOTE_STR);
        fprintf(stderr, "%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n", NOTE_STR);
        return false;
    }
    let mainFunc: LLVMValue = this.llvmModule.getFunction(mainName);
    let retType: LLVMType = this.llvmContext.createIntegerType(32);
    let params: LLVMTypeList = blank;
    push(&params, this.llvmContext.createIntegerType(32));
    let _p: LLVMType = this.llvmContext.createIntegerType(8);
    push(&params, intoPointerType(&_p));
    let retFnType: LLVMType = intoFunctionType(&retType, params, false);
    assert(!this.llvmModule.hasFunction(newSubStrOfStrLit("main")));
    let main: LLVMValue = this.llvmModule.addFunction(newSubStrOfStrLit("main"), retFnType);
    let entry: LLVMBasicBlock = this.llvmContext.appendBasicBlock(main, newSubStrOfStrLit("entry"));
    positionAtEnd(&this.llvmBuilder, entry);
    let args: LLVMValueList = blank;
    push(&args, getNthParam(&main, 0));
    push(&args, getNthParam(&main, 1));
    let v: LLVMValue = buildCall(&this.llvmBuilder, mainFunc, args, newSubStrOfStrLit("entry"));
    buildReturn(&this.llvmBuilder, v);
    return true;
}
func generateGlobal(this: &LLVMCodegen, global: &IRFunc) -> bool {
    trace("LLVMCodegen.generateGlobal");
    this.global = blank;
    initBlank(&this.global, global.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(global);
    let llvmFunc: LLVMValue = blank;
    let blocks: LLVMBasicBlockList = blank;
    pushRegisterStack(this.interp, defaultSpan(), funcSize);
    this.interp.globalRegisters = &this.global;
    this.interp.globalRegBase = this.interp.regStackBase;
    assert(global.blocks.length == 1, "Expected to only find one IRBlock in global scope");
    generateBlock(this, &llvmFunc, global, &blocks, at(&global.blocks, 0), &this.global);
    return true;
}

func generateLLVMFunctionHeader(this: &LLVMCodegen, irFunc: &IRFunc) {
    let llvmFunc: LLVMValue = blank;
    let retType: &Type = null;
    let params: LLVMTypeList = blank;
    let isVarArg: bool = false;
    if (irFunc.isMethod) {
        let method: &ParsedMethod = getMethodNode(irFunc);
        let typeDecl: &ParsedTypeNode = typeNodes.at(method.retTypeID);
        retType = types.at(getType(&typeDecl.typeState));
        if (retType.getSize() > 8) {
            retType = types.at(retType.intoPointer());
            push(&params, prepareParameter(this, retType));
        }
        for (let i: usize = 0; i < method.params.paramLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = typeNodes.at(method.params.getTypeAtIndex(i));
            let t: &Type = types.at(getType(&tDecl.typeState));
            push(&params, prepareParameter(this, t));
        }
        isVarArg = method.params.isVarArg;
    } else {
        let function: &ParsedFuncDecl = getFuncNode(irFunc);
        let typeDecl: &ParsedTypeNode = typeNodes.at(function.retTypeID);
        retType = types.at(getType(&typeDecl.typeState));
        if (retType.getSize() > 8) {
            retType = types.at(retType.intoPointer());
            push(&params, prepareParameter(this, retType));
        }
        for (let i: usize = 0; i < function.params.paramLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = typeNodes.at(function.params.getTypeAtIndex(i));
            let t: &Type = types.at(getType(&tDecl.typeState));
            push(&params, prepareParameter(this, t));
        }
        isVarArg = function.params.isVarArg;
    }
    let llvmType: LLVMType = prepareReturnType(this, retType);
    let llvmFuncType: LLVMType = intoFunctionType(&llvmType, params, isVarArg);
    let llvmFuncValue: LLVMValue = this.llvmModule.addFunction(irFunc.name.asSubStr(), llvmFuncType);
    if (hasAttribute(irFunc, ATTR_NORETURN)) {
        let id = LLVMGetEnumAttributeKindForName("noreturn", 8 /* sizeof "noreturn" */);
        assert(id != 0, "Could not get noreturn attribute from LLVM");
        addAttribute(&llvmFuncValue, U32_MAX, this.llvmContext.createEnumAttribute(id, 1));
    }
    (*irFunc).llvmFunc = llvmFuncValue;
    let origFunc: &IRFunc = this.irGen.functions.get(&irFunc.name);
    (*origFunc).llvmFunc = llvmFuncValue;
}

func prepareReturnType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareReturnType");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (typ.isStruct()) {
        let size: usize = typ.getSize();
        let t: &Type = null;
        if (size <= 1) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        } else if (size <= 2) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
        } else if (size <= 4) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
        } else if (size <= 8) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
        } else {
            t = newType(TYPE_KIND_POINTER, TYPE_U8);
        }
        return generateLLVMType(this, t);
    } else {
        return generateLLVMType(this, typ);
    }
}

func prepareParameter(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.prepareParameter");
    // FIXME: Kinda sucks that we have to do this both in the IRGen and here
    if (typ.isStruct()) {
        let size: usize = typ.getSize();
        let t: &Type = null;
        if (size <= 1) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U8);
        } else if (size <= 2) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U16);
        } else if (size <= 4) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U32);
        } else if (size <= 8) {
            t = newType(TYPE_KIND_PRIMITIVE, TYPE_U64);
        } else {
            t = newType(TYPE_KIND_POINTER, TYPE_U8);
        }
        return generateLLVMType(this, t);
    } else if (typ.getSize() > 8) {
        return generateLLVMType(this, types.at(typ.intoPointer()));
    } else {
        return generateLLVMType(this, typ);
    }
}

func getLLVMTypeSize(this: &LLVMCodegen, typ: &LLVMType) -> usize {
    trace("LLVMCodegen.getLLVMTypeSize");
    let data: LLVMTargetData = this.llvmTargetMachine.getTargetData();
    let s1: usize = data.getStoreSize(typ);
    let s2: usize = data.getABISize(typ);
    let s3: usize = data.getBitSize(typ) / 8;
    assert(s1 == s2 && s1 == s3 && s2 == s3, "LLVMTargetData returned different type sizes");
    return s1;
}

func generateFunction(this: &LLVMCodegen, index: usize, irFunc: &IRFunc) -> bool {
    trace("LLVMCodegen.generateFunction");
    if (isExtern(irFunc)) return true;
    let llvmFuncValue: LLVMValue = irFunc.llvmFunc;
    assert(!llvmFuncValue.ref.isNull());
    let blocks: LLVMBasicBlockList = blank;
    initBlank(&blocks, irFunc.blocks.length);
    assert(blocks.length != 0, "Every IRFunc has at least one instruction");
    *(at(&blocks, 0)) = this.llvmContext.appendBasicBlock(llvmFuncValue, newSubStrOfStrLit("entry"));
    for (let i: usize = 1; i < irFunc.blocks.length; i = i + 1) {
        *(at(&blocks, i)) = this.llvmContext.appendBasicBlock(llvmFuncValue, newSubStrOfStrLit("b"));
    }
    let regs: RegValueList = blank;
    initBlank(&regs, irFunc.registers.length);
    let funcSize: usize = getRegisterSizeInBytes(irFunc);
    pushRegisterStack(this.interp, irFunc.span, funcSize);
    for (let i: usize = 0; i < irFunc.blocks.length; i = i + 1) {
        let block: &IRBlock = getBlockByID(irFunc, IRBlockID { i: i });
        positionAtEnd(&this.llvmBuilder, *at(&blocks, i));
        generateBlock(this, &llvmFuncValue, irFunc, &blocks, block, &regs);
    }
    popRegisterStack(this.interp, irFunc.span, funcSize);
    return true;
}
func generateBlock(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    llvmBlocks: &LLVMBasicBlockList,
    block: &IRBlock,
    regs: &RegValueList,
) {
    for (let i: usize = 0; i < block.instructions.length; i = i + 1) {
        let instr: &IRInstr = at(&block.instructions, i);
        let val: RegValue = blank;
        if (instr.isComptime) {
            val = RegValue {
                isLLVM: false,
                regValue: evaluateSingle(this.interp, irFunc, instr, regs, false),
                llvmValue: blank,
            };
        } else {
            val = RegValue {
                isLLVM: true,
                regValue: blank,
                llvmValue: generateLLVMInstr(this, llvmFunc, irFunc, llvmBlocks, instr, regs),
            };
        }
        if (!isTerminator(instr)) {
            *(at(regs, instr.dst.i)) = val;
        }
    }
}

func generateLLVMInstr(
    this: &LLVMCodegen,
    llvmFunc: &LLVMValue,
    irFunc: &IRFunc,
    blocks: &LLVMBasicBlockList,
    instr: &IRInstr,
    regs: &RegValueList,
) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMInstr");
    let isGlobal: bool = llvmFunc.ref.isNull();
    if (instr.kind == INSTR_ALLOCA) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(reg.typ.isPointer(), "LLVM Alloca expected ptr dst");
        let t: &Type = reg.typ.getUnderlyingType(false);
        let typ: LLVMType = generateLLVMType(this, t);
        if (isGlobal) {
            return this.llvmModule.addGlobal(typ, 0, newSubStrOfStrLit("g"));
        } else {
            return buildAlloca(&this.llvmBuilder, typ, newSubStrOfStrLit("v"));
        }
    } else if (instr.kind == INSTR_GET_PARAM) {
        assert(!isGlobal);
        let param: LLVMValue = getNthParam(llvmFunc, instr.src.i);
        setName(&param, newSubStrOfStrLit("p"));
        return param;
    } else if (instr.kind == INSTR_STORE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM Store");
        let srcVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Store");
        if (isGlobal) {
            setInitializer(&dstVal, srcVal);
        } else {
            buildStore(&this.llvmBuilder, dstVal, srcVal);
        }
        return dstVal;
    } else if (instr.kind == INSTR_LOAD) {
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: &RegValue = at(regs, instr.src.i);
        if (reg.isLLVM) {
            let srcVal: LLVMValue = asLLVM(reg, "LLVM Load");
            if (isGlobal) {
                todo_with_msg("LLVM global load");
            } else {
                return buildLoad(&this.llvmBuilder, dstTyp, srcVal, newSubStrOfStrLit("load"));
            }
        } else {
            let start: &u8 = getRegStackPointer(this.interp, &asInterp(reg, "LLVM Load from comptime"));
            return generateLLVMValueFromComptimeValue(this, typ, *(start as &usize) as &u8);
        }
    } else if (instr.kind == INSTR_MOVE) {
        return asLLVM(at(regs, instr.src.i), "LLVM Move");
    } else if (instr.kind == INSTR_FETCH_GLOBAL_PTR) {
        let val: &RegValue = at(&this.global, instr.src.i);
        if (val.isLLVM) {
            return asLLVM(val, "We just checked if it is LLVM");
        } else {
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            return generateLLVMValueFromComptimePtr(this, typ, reg);
        }
    } else if (instr.kind == INSTR_FETCH_GLOBAL_VALUE) {
        let val: &RegValue = at(&this.global, instr.src.i);
        let typ: &Type = getRegister(irFunc, instr.dst).typ;
        assert(val.isLLVM, "FetchGlobalValue got non-LLVM src");
        let dstTyp: LLVMType = generateLLVMType(this, typ);
        let reg: LLVMValue = asLLVM(val, "We just checked if it is LLVM");
        return buildLoad(&this.llvmBuilder, dstTyp, reg, newSubStrOfStrLit("fetchglobalval"));
    } else if (instr.kind == INSTR_FETCH_COMPTIME_VALUE) {
        if (instr.op1.i == 1) {
            // Global fetch
            let val: &RegValue = at(&this.global, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!val.isLLVM, "FetchComptimeValue global=1 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getGlobalPointer(this.interp, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        } else {
            // Local fetch
            let val: &RegValue = at(regs, instr.src.i);
            let typ: &Type = getRegister(irFunc, instr.dst).typ;
            assert(!val.isLLVM, "FetchComptimeValue global=0 got non-Interp src");
            let reg: InterpReg = asInterp(val, "We just checked if it is Interp");
            let start: &u8 = getComptimePointer(this, &reg);
            return generateLLVMValueFromComptimeValue(this, typ, start);
        }
    } else if (instr.kind == INSTR_INT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddInt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        return buildIntAdd(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("iadd"));
    } else if (instr.kind == INSTR_INT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubInt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        return buildIntSub(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("isub"));
    } else if (instr.kind == INSTR_INT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulInt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        return buildIntMul(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imul"));
    } else if (instr.kind == INSTR_INT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivInt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        return buildIntDiv(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("idiv"));
    } else if (instr.kind == INSTR_INT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModInt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModInt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        return buildIntMod(&this.llvmBuilder, lhsVal, rhsVal, signed, newSubStrOfStrLit("imod"));
    } else if (instr.kind == INSTR_FLOAT_ADD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM AddFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM AddFloat");
        return buildFloatAdd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fadd"));
    } else if (instr.kind == INSTR_FLOAT_SUB) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM SubFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM SubFloat");
        return buildFloatSub(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fsub"));
    } else if (instr.kind == INSTR_FLOAT_MUL) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM MulFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM MulFloat");
        return buildFloatMul(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmul"));
    } else if (instr.kind == INSTR_FLOAT_DIV) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM DivFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM DivFloat");
        return buildFloatDiv(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fdiv"));
    } else if (instr.kind == INSTR_FLOAT_MOD) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ModFloat");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ModFloat");
        return buildFloatMod(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("fmod"));
    } else if (instr.kind == INSTR_INT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpNeq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntNE, lhsVal, rhsVal, newSubStrOfStrLit("icmpne"));
    } else if (instr.kind == INSTR_INT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpEq");
        return buildIntCompare(&this.llvmBuilder, LLVMIntEQ, lhsVal, rhsVal, newSubStrOfStrLit("icmpeq"));
    } else if (instr.kind == INSTR_INT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLT, lhsVal, rhsVal, newSubStrOfStrLit("icmpslt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULT, lhsVal, rhsVal, newSubStrOfStrLit("icmpult"));
    } else if (instr.kind == INSTR_INT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpLte");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSLE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsle"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntULE, lhsVal, rhsVal, newSubStrOfStrLit("icmpule"));
    } else if (instr.kind == INSTR_INT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGt");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpsgt"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGT, lhsVal, rhsVal, newSubStrOfStrLit("icmpugt"));
    } else if (instr.kind == INSTR_INT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM ICmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM ICmpGte");
        let signed: bool = getRegister(irFunc, instr.src).typ.isSignedInteger();
        if (signed) return buildIntCompare(&this.llvmBuilder, LLVMIntSGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpsge"));
        else return buildIntCompare(&this.llvmBuilder, LLVMIntUGE, lhsVal, rhsVal, newSubStrOfStrLit("icmpuge"));
    } else if (instr.kind == INSTR_FLOAT_CMP_NEQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpNeq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpNeq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUNE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpne"));
    } else if (instr.kind == INSTR_FLOAT_CMP_EQ) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpEq");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpEq");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUEQ, lhsVal, rhsVal, newSubStrOfStrLit("fcmpeq"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpult"));
    } else if (instr.kind == INSTR_FLOAT_CMP_LTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpLte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpLte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealULE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpule"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GT) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGt");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGt");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGT, lhsVal, rhsVal, newSubStrOfStrLit("fcmpugt"));
    } else if (instr.kind == INSTR_FLOAT_CMP_GTE) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM FCmpGte");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM FCmpGte");
        return buildFloatCompare(&this.llvmBuilder, LLVMRealUGE, lhsVal, rhsVal, newSubStrOfStrLit("fcmpuge"));
    } else if (instr.kind == INSTR_LOGICAL_NOT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Not");
        return buildNot(&this.llvmBuilder, val, newSubStrOfStrLit("lnot"));
    } else if (instr.kind == INSTR_LOGICAL_OR || instr.kind == INSTR_BITWISE_OR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical Or");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical Or");
        return buildOr(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("lor"));
    } else if (instr.kind == INSTR_LOGICAL_AND || instr.kind == INSTR_BITWISE_AND) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Logical And");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Logical And");
        return buildAnd(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("land"));
    } else if (instr.kind == INSTR_BITWISE_XOR) {
        let lhsVal: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM Bitwise Xor");
        let rhsVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM Bitwise Xor");
        return buildXor(&this.llvmBuilder, lhsVal, rhsVal, newSubStrOfStrLit("bxor"));
    } else if (instr.kind == INSTR_CALL) {
        let called: &IRFunc = this.irGen.functions.at(instr.src.i);
        let calledFunc: LLVMValue = this.llvmModule.getFunction(called.name.asSubStr());
        assert(!calledFunc.ref.isNull(), "Call tried to call invalid LLVMValue");
        let args: LLVMValueList = blank;
        initBlank(&args, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&args, i)) = asLLVM(argReg, "LLVM Call Arg");
        }
        return buildCall(&this.llvmBuilder, calledFunc, args, newSubStrOfStrLit("call"));
    } else if (instr.kind == INSTR_COND_BR) {
        let cond: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM CondBr");
        buildCondBr(&this.llvmBuilder, cond, *at(blocks, instr.dst.i), *at(blocks, instr.op1.i));
        return blank;
    } else if (instr.kind == INSTR_UNREACHABLE) {
        buildUnreachable(&this.llvmBuilder, );
        return blank;
    } else if (instr.kind == INSTR_BR) {
        buildBr(&this.llvmBuilder, *at(blocks, instr.dst.i));
        return blank;
    } else if (instr.kind == INSTR_RETURN_EXPR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM RetExpr");
        buildReturn(&this.llvmBuilder, val);
        return blank;
    } else if (instr.kind == INSTR_RETURN_VOID) {
        buildReturnVoid(&this.llvmBuilder, );
        return blank;
    } else if (instr.kind == INSTR_LOAD_I8) {
        let t: LLVMType = this.llvmContext.createIntegerType(8);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U8) {
        let t: LLVMType = this.llvmContext.createIntegerType(8);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I16) {
        let t: LLVMType = this.llvmContext.createIntegerType(16);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U16) {
        let t: LLVMType = this.llvmContext.createIntegerType(16);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I32) {
        let t: LLVMType = this.llvmContext.createIntegerType(32);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U32) {
        let t: LLVMType = this.llvmContext.createIntegerType(32);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_I64) {
        let t: LLVMType = this.llvmContext.createIntegerType(64);
        return constInt(&t, instr.src.i, true);
    } else if (instr.kind == INSTR_LOAD_U64) {
        let t: LLVMType = this.llvmContext.createIntegerType(64);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_F32) {
        let t: LLVMType = this.llvmContext.createFloatType();
        return constFloat(&t, *(&instr.src.i as &f32) as f64);
    } else if (instr.kind == INSTR_LOAD_F64) {
        let t: LLVMType = this.llvmContext.createDoubleType();
        return constFloat(&t, *(&instr.src.i as &f64));
    } else if (instr.kind == INSTR_LOAD_BOOL) {
        let t: LLVMType = this.llvmContext.createIntegerType(1);
        return constInt(&t, instr.src.i, false);
    } else if (instr.kind == INSTR_LOAD_NULL) {
        let t: LLVMType = this.llvmContext.createIntegerType(64);
        let pt: LLVMType = intoPointerType(&t);
        return constZero(&pt);
    } else if (instr.kind == INSTR_LOAD_BLANK) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_ARRAY) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        assert(reg.typ.isArray(), "LLVM Expected Array in INSTR_CREATE_ARRAY");
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_CREATE_STRUCT) {
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return constZero(&typ);
    } else if (instr.kind == INSTR_INSERT_VALUE) {
        let dstVal: LLVMValue = asLLVM(at(regs, instr.dst.i), "LLVM InsertValue");
        let index: usize = instr.src.i;
        let elemVal: LLVMValue = asLLVM(at(regs, instr.op1.i), "LLVM InsertValue");
        let newVal: LLVMValue = buildInsertValue(&this.llvmBuilder, 
            dstVal,
            elemVal,
            index as u32,
            "arr_elem",
        );
        return newVal;
    } else if (instr.kind == INSTR_PTR_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM PtrToInt");
        let typ: LLVMType = this.llvmContext.createIntegerType(64);
        return buildPtrToInt(&this.llvmBuilder, val, typ, newSubStrOfStrLit("p2i"));
    } else if (instr.kind == INSTR_INT_TO_PTR) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToPtr");
        let typ: LLVMType = this.llvmContext.createIntegerType(64);
        let ptr: LLVMType = intoPointerType(&typ);
        return buildIntToPtr(&this.llvmBuilder, val, ptr, newSubStrOfStrLit("i2p"));
    } else if (instr.kind == INSTR_INT_TO_F32 || instr.kind == INSTR_INT_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntToF32 / IntToF64");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let signed: bool = reg.typ.isSignedInteger();
        let typ: LLVMType = this.llvmContext.createFloatType();
        if (instr.kind == INSTR_INT_TO_F64) typ = this.llvmContext.createDoubleType();
        return buildIntToFloat(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("i2f"));
    } else if (instr.kind == INSTR_F32_TO_INT || instr.kind == INSTR_F64_TO_INT) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToInt / F64ToInt");
        let reg: &IRReg = getRegister(irFunc, instr.dst);
        let signed: bool = reg.typ.isSignedInteger();
        let typ: LLVMType = generateLLVMType(this, reg.typ);
        return buildFloatToInt(&this.llvmBuilder, val, typ, signed, newSubStrOfStrLit("f2i"));
    } else if (instr.kind == INSTR_F32_TO_F64) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F32ToF64");
        let typ: LLVMType = this.llvmContext.createDoubleType();
        return buildFloatExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f32tof64"));
    } else if (instr.kind == INSTR_F64_TO_F32) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM F64ToF32");
        let typ: LLVMType = this.llvmContext.createFloatType();
        return buildFloatTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("f64tof32"));
    } else if (instr.kind == INSTR_INT_SIGN_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntSignExt");
        let typ: LLVMType = this.llvmContext.createIntegerType(instr.op1.i as i64);
        return buildIntSignExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("sext"));
    } else if (instr.kind == INSTR_INT_ZERO_EXTEND) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntZeroExt");
        let typ: LLVMType = this.llvmContext.createIntegerType(instr.op1.i as i64);
        return buildIntZeroExtend(&this.llvmBuilder, val, typ, newSubStrOfStrLit("zext"));
    } else if (instr.kind == INSTR_INT_TRUNCATE) {
        let val: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM IntTrunc");
        let typ: LLVMType = this.llvmContext.createIntegerType(instr.op1.i as i64);
        return buildIntTruncate(&this.llvmBuilder, val, typ, newSubStrOfStrLit("trunc"));
    } else if (instr.kind == INSTR_LOAD_STRING) {
        return buildGlobalStringPtr(&this.llvmBuilder, instr.src.i as &char, newSubStrOfStrLit("str"));
    } else if (instr.kind == INSTR_GET_ELEMENT_PTR) {
        let indices: LLVMValueList = blank;
        initBlank(&indices, instr.args.length);
        for (let i: usize = 0; i < instr.args.length; i = i + 1) {
            let _a: &RegIndex = at(&instr.args, i);
            let reg: &IRReg = getRegister(irFunc, *_a);
            let argReg: &RegValue = at(regs, _a.i);
            *(at(&indices, i)) = asLLVM(argReg, "LLVM GEP Index");
        }
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetElementPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        let underlying: &Type = ptr.getUnderlyingType(false);
        return buildGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, indices, newSubStrOfStrLit("gep"));
    } else if (instr.kind == INSTR_GET_FIELD_PTR) {
        let aggr: LLVMValue = asLLVM(at(regs, instr.src.i), "LLVM GetFieldPtr");
        let reg: &IRReg = getRegister(irFunc, instr.src);
        let ptr: &Type = reg.typ;
        assert(ptr.isPointer(), "LLVM GetFieldPtr wants ptr reg");
        let aggrType: LLVMType = getType(&aggr);
        assert(isPointer(&aggrType), "Expected Pointer to Struct in GetFieldPtr");
        let underlying: &Type = ptr.getUnderlyingType(false);
        assert(underlying.isStruct(), "LLVM GetFieldPtr wants ptr to struct");
        return buildStructGEP(&this.llvmBuilder, generateLLVMType(this, underlying), aggr, instr.op1.i, newSubStrOfStrLit("field_ptr"));
    } else {
        printf("LLVM %llu\n", instr.kind);
        todo_with_msg("unknown llvm kind");
    }
}

func getComptimePointer(this: &LLVMCodegen, reg: &InterpReg) -> &u8 {
    trace("LLVMCodegen.getComptimePointer");
    let start: &u8 = getRegStackPointer(this.interp, reg);
    assert(start >= this.interp.regStackStart, "Expected comptime value to be allocated on Interp Reg Stack");
    assert(start < this.interp.regStackStart + REG_STACK_SIZE, "Expected comptime value to be allocated on Interp Reg Stack");
    return start;
}

func generateLLVMValueFromComptimePtr(this: &LLVMCodegen, typ: &Type, reg: InterpReg) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimePtr");
    assert(typ.isPointer(), "generateLLVMValueFromComptimePtr expected Pointer");
    assert(reg.size == 8, "generateLLVMValueFromComptimePtr expected Pointer sized register");
    let underlying: &Type = typ.getUnderlyingType(false);
    // load value from interp
    let start: &u8 = getComptimePointer(this, &reg);
    let val: LLVMValue = generateLLVMValueFromComptimeValue(this, underlying, start);
    // allocate it somewhere
    let _underlying: LLVMType = generateLLVMType(this, typ.getUnderlyingType(false));
    let alloc: LLVMValue = buildAlloca(&this.llvmBuilder, _underlying, newSubStrOfStrLit("comptimeToLLVM"));
    buildStore(&this.llvmBuilder, alloc, val);
    // return pointer to that
    return alloc;
}
func generateLLVMValueFromComptimeValue(this: &LLVMCodegen, typ: &Type, start: &u8) -> LLVMValue {
    trace("LLVMCodegen.generateLLVMValueFromComptimeValue");
    assert(start != null, "generateLLVMValueFromComptimeValue got nullptr");
    let size: usize = typ.getSize();
    if (typ.isPrimitive()) {
        if (typ.isInteger()) {
            // Note: LLVM doesn't care about signedness for integers, that's all handled in the instructions
            if (size == 1) {
                let val: u8 = *(start as &u8);
                let t: LLVMType = this.llvmContext.createIntegerType(8);
                return constInt(&t, val as usize, false);
            } else if (size == 2) {
                let val: u16 = *(start as &u16);
                let t: LLVMType = this.llvmContext.createIntegerType(16);
                return constInt(&t, val as usize, false);
            } else if (size == 4) {
                let val: u32 = *(start as &u32);
                let t: LLVMType = this.llvmContext.createIntegerType(32);
                return constInt(&t, val as usize, false);
            } else if (size == 8) {
                let val: u64 = *(start as &u64);
                let t: LLVMType = this.llvmContext.createIntegerType(64);
                return constInt(&t, val as usize, false);
            } else {
                unreachable("unexpected int size");
            }
        } else if (typ.isFloat()) {
            if (size == 4) {
                let val = *(start as &f32);
                let t = this.llvmContext.createFloatType();
                return constFloat(&t, val as f64);
            } else if (size == 8) {
                let val = *(start as &f64);
                let t = this.llvmContext.createDoubleType();
                return constFloat(&t, val);
            } else {
                unreachable("unexpected float size");
            }
        } else if (typ.isBoolean()) {
            let val: u8 = *(start as &u8);
            assert(val == 0 || val == 1, "comptime bool is not 0 or 1");
            let t: LLVMType = this.llvmContext.createIntegerType(1);
            return constInt(&t, val as usize, false);
        } else {
            todo_with_msg("prim");
        }
    } else if (typ.isStruct()) {
        let decl: &ParsedStructDecl = structDecls.at(typ.typeIndex);
        let lType: LLVMType = generateLLVMType(this, typ);
        assert(isStruct(&lType), "Expected LLVMType to be struct for comptime struct");
        let strukt: LLVMValue = constZero(&lType);
        let offset: usize = 0;
        let _size: usize = 0;
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = typeNodes.at(decl.context.getFieldTypeAtIndex(i));
            let fType: &Type = types.at(getType(&tDecl.typeState));
            getFieldOffsetAndSize(decl, i, &offset, &_size);
            let elemVal: LLVMValue = generateLLVMValueFromComptimeValue(this, fType, start + offset);
            strukt = buildInsertValue(&this.llvmBuilder, 
                strukt,
                elemVal,
                i as u32,
                "comptime_struct_field",
            );
        }
        return strukt;
    } else if (typ.isArray()) {
        todo_with_msg("comptime to LLVM array");
    } else if (typ.isPointer()) {
        let underlying: &Type = typ.getUnderlyingType(false);
        if (underlying.isChar()) {
            return buildGlobalStringPtr(&this.llvmBuilder, *(start as &usize) as &char, newSubStrOfStrLit("comptime_str"));
        }
        todo_with_msg("comptime to LLVM pointer");
    } else {
        unreachable("Exhaustive handling in generateLLVMValueFromComptime");
    }
}

func generateLLVMType(this: &LLVMCodegen, typ: &Type) -> LLVMType {
    trace("LLVMCodegen.generateLLVMType");
    if (typ.isPrimitive()) {
        if (typ.isInteger()) {
            return this.llvmContext.createIntegerType(typ.getSize() as i64 * 8);
        } else if (typ.isChar()) {
            return this.llvmContext.createIntegerType(8);
        } else if (typ.isBoolean()) {
            return this.llvmContext.createIntegerType(1);
        } else if (typ.isFloat()) {
            if (typ.typeIndex == TYPE_F32) return this.llvmContext.createFloatType();
            else if (typ.typeIndex == TYPE_F64) return this.llvmContext.createDoubleType();
            unreachable("Expected TYPE_F32 or TYPE_F64");
        } else if (typ.isNone()) {
            return this.llvmContext.createVoidType();
        } else if (typ.isAny()) {
            let t: LLVMType = this.llvmContext.createIntegerType(64);
            return intoPointerType(&t);
        } else {
            fprintf(stderr, "%llu %llu\n", typ.kind, typ.typeIndex);
            todo_with_msg("generate primitive type");
        }
    } else if (typ.isPointer()) {
        let t: LLVMType = this.llvmContext.createIntegerType(64);
        return intoPointerType(&t);
    } else if (typ.isArray()) {
        let t: LLVMType = generateLLVMType(this, types.at(typ.typeIndex));
        return intoArrayType(&t, typ.arraySize as u32);
    } else if (typ.isStruct()) {
        let decl: &ParsedStructDecl = structDecls.at(typ.typeIndex);
        let fields: &LLVMType = malloc(decl.context.fieldLength * sizeof LLVMType);
        assert(fields != null, "Could not allocate memory in LLVMCodegen.generateLLVMType");
        for (let i: usize = 0; i < decl.context.fieldLength; i = i + 1) {
            let tDecl: &ParsedTypeNode = typeNodes.at(decl.context.getFieldTypeAtIndex(i));
            fields[i] = generateLLVMType(this, types.at(getType(&tDecl.typeState)));
        }
        let t: LLVMType = this.llvmContext.createStructType(&*fields, decl.context.fieldLength as u32, false);
        free(fields);
        return t;
    } else {
        todo_with_msg("generate llvm type");
    }
}

func newLLVMCodegen(name: SubStr, irGen: &IRGen, interp: &IRInterp) -> LLVMCodegen {
    let llvmContext: LLVMContext = newLLVMContext();
    let llvmModule: LLVMModule = llvmContext.createModuleWithName(name);
    let llvmBuilder: LLVMBuilder = llvmContext.createBuilder();
    llvmContext.initializeTargets();
    let target: LLVMTarget = llvmContext.createTarget("x86-64");
    let triple: &char = llvmContext.createTargetTriple("x86-64");
    let targetMachine: LLVMTargetMachine = target.createTargetMachine(triple, "x86-64", "");
    llvmModule.setTriple(triple);
    let l: LLVMTargetData = targetMachine.getTargetData();
    llvmModule.setDataLayout(l.getDataLayout());
    return LLVMCodegen {
        llvmContext: llvmContext,
        llvmModule: llvmModule,
        llvmBuilder: llvmBuilder,
        llvmTargetMachine: targetMachine,
        irGen: irGen,
        interp: interp,
        global: blank,
    };
}
