import "prelude.bufo";
import "libc.bufo";
import "bufo.bufo";
import "../LLVM/types.bufo";
import "../LLVM/module.bufo";
import "../LLVM/bindings.bufo";

struct LLVMDataLayout {
    ref: &char;
}

struct LLVMTargetData {
    ref: LLVM::TargetDataRef;
}

func getBitSize(this: &LLVMTargetData, typ: &LLVMType) -> usize {
    return LLVM::SizeOfTypeInBits(this.ref, typ.ref);
}
func getABISize(this: &LLVMTargetData, typ: &LLVMType) -> usize {
    return LLVM::ABISizeOfType(this.ref, typ.ref);
}
func getStoreSize(this: &LLVMTargetData, typ: &LLVMType) -> usize {
    return LLVM::StoreSizeOfType(this.ref, typ.ref);
}
func getDataLayout(this: &LLVMTargetData) -> LLVMDataLayout {
    let c: &char = LLVM::CopyStringRepOfTargetData(this.ref);
    if (*flags.debug) {
        C::printf("[INFO] LLVM Data Layout: %s\n", c);
    }
    return LLVMDataLayout {
        ref: c
    };
}

func newLLVMTargetDataFromRef(ref: LLVM::TargetDataRef) -> LLVMTargetData {
    return LLVMTargetData {
        ref: ref,
    };
}

struct LLVMTarget {
    ref: LLVM::TargetRef;
}

func createTargetMachine(this: &LLVMTarget, triple: &char, cpu: &char, features: &char) -> LLVMTargetMachine {
    let target = LLVM::CreateTargetMachine(this.ref, triple, cpu, features, 0, 0, 0);
    assert(!LLVM::isNull(target), "Could not create target machine");
    return newLLVMTargetMachineFromRef(target);
}
func createTargetMachineWithOptions(this: LLVMTarget, triple: &char, options: LLVMTargetMachineOptions) -> LLVMTargetMachine {
    let target = LLVM::CreateTargetMachineWithOptions(this.ref, triple, options.ref);
    assert(!LLVM::isNull(target), "Could not create target machine");
    return newLLVMTargetMachineFromRef(target);
}

func newLLVMTargetFromRef(ref: LLVM::TargetRef) -> LLVMTarget {
    return LLVMTarget {
        ref: ref,
    };
}

struct LLVMTargetMachine {
    ref: LLVM::TargetMachineRef;
}

func writeToFile(this: &LLVMTargetMachine, mod: LLVMModule, mode: i32, filepath: &char) {
    let err: LLVMString = blank;
    if (LLVM::TargetMachineEmitToFile(this.ref, mod.ref, filepath, mode, &err) != 0) {
        C::fprintf(stderr, "%s Could not write LLVM module to file!\n", FATAL_STR);
        C::fprintf(stderr, "%s %s\n", FATAL_STR, err.chars);
        C::exit(1);
    }
}

func getTargetData(this: &LLVMTargetMachine) -> LLVMTargetData {
    let data: LLVM::TargetDataRef = LLVM::CreateTargetDataLayout(this.ref);
    assert(!LLVM::isNull(data), "Could not get TargetData");
    return newLLVMTargetDataFromRef(data);
}

func newLLVMTargetMachineFromRef(ref: LLVM::TargetMachineRef) -> LLVMTargetMachine {
    return LLVMTargetMachine {
        ref: ref,
    };
}

struct LLVMTargetMachineOptions {
    ref: LLVM::TargetMachineOptionsRef;
}

func createTargetMachineOptions() -> LLVMTargetMachineOptions {
    let opt = LLVM::CreateTargetMachineOptions();
    assert(!LLVM::isNull(opt), "Could not create target machine options");
    return LLVMTargetMachineOptions { ref: opt };
}
func disposeTargetMachineOptions(opt: LLVMTargetMachineOptions) {
    LLVM::DisposeTargetMachineOptions(opt.ref);
}

func setCPU(opt: LLVMTargetMachineOptions, cpu: &char) {
    LLVM::TargetMachineOptionsSetCPU(opt.ref, cpu);
}
func setFeatures(opt: LLVMTargetMachineOptions, features: &char) {
    LLVM::TargetMachineOptionsSetFeatures(opt.ref, features);
}
func setABI(opt: LLVMTargetMachineOptions, ABI: &char) {
    LLVM::TargetMachineOptionsSetABI(opt.ref, ABI);
}
func setCodeGenOptLevel(opt: LLVMTargetMachineOptions, level: LLVM::CodeGenOptLevel) {
    LLVM::TargetMachineOptionsSetCodeGenOptLevel(opt.ref, LLVM::asI32(&level));
}
func setRelocMode(opt: LLVMTargetMachineOptions, reloc: LLVM::RelocMode) {
    LLVM::TargetMachineOptionsSetRelocMode(opt.ref, LLVM::asI32(&reloc));
}
func setCodeModel(opt: LLVMTargetMachineOptions, model: LLVM::CodeModel) {
    LLVM::TargetMachineOptionsSetCodeModel(opt.ref, LLVM::asI32(&model));
}
