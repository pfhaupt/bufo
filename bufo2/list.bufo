
import "type_info.bufo";
import "libc.bufo";
import "prelude.bufo";

struct GAF_List {
    elements: Any;
    length: usize;
    capacity: usize;
    type: TypeInfo;
    type_size: usize;
}

func new_GAF_List(ti: TypeInfo) -> GAF_List {
    return GAF_List {
        elements: null,
        length: 0,
        capacity: 0,
        type: ti,
        type_size: get_size(&ti),
    };
}

func push(list: &GAF_List, elem: Data) {
    assert(equals(&list.type, &elem.info), "GAF_List.push: Attempted to push invalid element");
    if (list.length >= list.capacity) {
        let new_cap: usize = list.capacity * 2;
        if (new_cap == 0) new_cap = 32;
        list.elements = C::realloc(list.elements, new_cap * list.type_size);
        assert(list.elements != null, "GAF_List.push: Could not allocate memory");
        list.capacity = new_cap;
    }
    C::memcpy(list.elements as &usize + list.length * list.type_size, elem.ptr, list.type_size);
    list.length = list.length + 1;
}

func pop(list: &GAF_List, dst: Any) {
    assert(list.length > 0, "GAF_List.pop: Attempted to pop from empty list");
    list.length = list.length - 1;
    let elem = list.elements as &usize + list.length * list.type_size;
    C::memcpy(dst, elem, list.type_size);
}

func get_ref(list: &GAF_List, index: usize, dst: Any) {
    assert(index < list.length, "GAF_List.get_ref: Out of bounds access");
    *(dst as &usize) = (list.elements as &usize + index * list.type_size) as usize;
}

func swap_remove(list: &GAF_List, index: usize) {
    assert(index < list.length, "GAF_List.swap_remove: Out of bounds removal");
    let dst = list.elements as &usize + index * list.type_size;
    let src = list.elements as &usize + (list.length - 1) * list.type_size;
    C::memcpy(dst, src, list.type_size);
    list.length = list.length - 1;
}

