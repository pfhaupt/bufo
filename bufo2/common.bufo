
import "libc.bufo";
import "prelude.bufo";
import "type_info.bufo";
import "substr.bufo";
import "string.bufo";
import "hashmap.bufo";
import "format.bufo";

import "corot.bufo";

func wrap(d: Data) -> Any {
    let size = get_size(&d.info);
    let ptr = C::malloc(size);
    assert(ptr != null, "wrap failed");
    C::memcpy(ptr, d.ptr, size);
    return ptr;
}

struct Loc {
    file: &char;
    offset: usize; // TODO: line and column
}

func new_loc(offset: usize) -> Loc {
    return Loc {
        file: "idk where",
        offset: offset,
    };
}

union Message {
    Todo(Loc, String),
    Error(Loc, String),
    Warning(Loc, String),
    Note(Loc, String),
    Debug(Loc, String),
}

func todo(loc: Loc, fmt: &char, args: ...Data) -> Message {
    comptime TODO_STR: &char = "\x1b[95mTODO\x1b[0m";
    let s: String = newStringFromStrLit(TODO_STR);
    pushChar(&s, ':');
    pushChar(&s, ' ');
    format(&s, fmt, args);
    return Message::Todo(loc, s);
}

func dbg(loc: Loc, fmt: &char, args: ...Data) -> Message {
    comptime DEBUG_STR: &char = "\x1b[96mDEBUG\x1b[0m";
    let s: String = newStringFromStrLit(DEBUG_STR);
    pushChar(&s, ':');
    pushChar(&s, ' ');
    format(&s, fmt, args);
    return Message::Debug(loc, s);
}

func note(loc: Loc, fmt: &char, args: ...Data) -> Message {
    let s: String = newStringFromStrLit(NOTE_STR);
    pushChar(&s, ':');
    pushChar(&s, ' ');
    format(&s, fmt, args);
    return Message::Note(loc, s);
}

func error(loc: Loc, fmt: &char, args: ...Data) -> Message {
    let s: String = newStringFromStrLit(ERR_STR);
    pushChar(&s, ':');
    pushChar(&s, ' ');
    format(&s, fmt, args);
    return Message::Error(loc, s);
}

comptime PRINT_DEBUG = true;
let error_happened: bool = false;
func message(errors: ...Message) {
    let had_error = false;
    for (let i: usize = 0; i < errors.length; i = i + 1) {
        let loc: Loc = blank;
        let msg: String = blank;
        match (errors[i]) {
            Message::Todo   (_loc, _msg) => { loc = _loc; msg = _msg; had_error = true; }
            Message::Error  (_loc, _msg) => { loc = _loc; msg = _msg; had_error = true; }
            Message::Warning(_loc, _msg) => { loc = _loc; msg = _msg; }
            Message::Note   (_loc, _msg) => { loc = _loc; msg = _msg; }
            Message::Debug  (_loc, _msg) => {
                if (!PRINT_DEBUG) { drop(&_msg); continue; }
                loc = _loc; msg = _msg;
            }
            _ => { unreachable("message"); }
        }
        C::fprintf(stderr, "%s:%llu: %.*s\n", loc.file, loc.offset, msg.length, msg.buffer);
        drop(&msg);
    }
    if (had_error) {
        error_happened = true;
        _finish_current();
    }
}
