// Builtin Types:
#include <stdbool.h> // bool
#include <stddef.h>  // NULL
#include <stdint.h>
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef void *Any;
typedef void none;
typedef float f32;
typedef double f64;
typedef u64 usize;
// C doesn't have f32 % f32 etc.
float fmodf(float x, float y);
double fmod(double x, double y);

// Struct Declarations:
typedef struct StringList_s StringList_s;
typedef struct String_s String_s;
typedef struct SubStr_s SubStr_s;
typedef struct StringBuffer_s StringBuffer_s;
typedef struct BOOL_s BOOL_s;
typedef struct Handle_s Handle_s;
typedef struct StartupInfo_s StartupInfo_s;
typedef struct SecurityAttributes_s SecurityAttributes_s;
typedef struct ProcessInformation_s ProcessInformation_s;
typedef struct FileTime_s FileTime_s;
typedef struct Cmd_s Cmd_s;
typedef struct LLVM_TargetMachineOptionsRef_s LLVM_TargetMachineOptionsRef_s;
typedef struct LLVM_TargetMachineRef_s LLVM_TargetMachineRef_s;
typedef struct LLVM_TargetRef_s LLVM_TargetRef_s;
typedef struct LLVM_TargetDataRef_s LLVM_TargetDataRef_s;
typedef struct LLVM_ContextRef_s LLVM_ContextRef_s;
typedef struct LLVM_ModuleRef_s LLVM_ModuleRef_s;
typedef struct LLVM_BuilderRef_s LLVM_BuilderRef_s;
typedef struct LLVM_BasicBlockRef_s LLVM_BasicBlockRef_s;
typedef struct LLVM_ValueRef_s LLVM_ValueRef_s;
typedef struct LLVM_TypeRef_s LLVM_TypeRef_s;
typedef struct LLVM_AttributeRef_s LLVM_AttributeRef_s;
typedef struct LLVM_PassBuilderOptionsRef_s LLVM_PassBuilderOptionsRef_s;
typedef struct LLVM_ErrorRef_s LLVM_ErrorRef_s;
typedef struct LLVM_DIBuilderRef_s LLVM_DIBuilderRef_s;
typedef struct LLVM_MetadataRef_s LLVM_MetadataRef_s;
typedef struct LLVM_DbgRecordRef_s LLVM_DbgRecordRef_s;
typedef struct LLVMBool_s LLVMBool_s;
typedef struct LLVMString_s LLVMString_s;
typedef struct InterpReg_s InterpReg_s;
typedef struct IRValueList_s IRValueList_s;
typedef struct ASMContext_s ASMContext_s;
typedef struct Token_s Token_s;
typedef struct TypeInfoTable_s TypeInfoTable_s;
typedef struct TypeInfoList_s TypeInfoList_s;
typedef struct FieldTypeInfoList_s FieldTypeInfoList_s;
typedef struct FieldTypeInfo_s FieldTypeInfo_s;
typedef struct UnionVariantTypeInfoList_s UnionVariantTypeInfoList_s;
typedef struct Data_s Data_s;
typedef struct LLVMMetadata_s LLVMMetadata_s;
typedef struct ArenaBlock_s ArenaBlock_s;
typedef struct ParsedConfigArena_s ParsedConfigArena_s;
typedef struct ParsedFileArena_s ParsedFileArena_s;
typedef struct ParsedTopLevelItemArena_s ParsedTopLevelItemArena_s;
typedef struct ParsedModuleArena_s ParsedModuleArena_s;
typedef struct ParsedStructDeclArena_s ParsedStructDeclArena_s;
typedef struct ParsedUnionDeclArena_s ParsedUnionDeclArena_s;
typedef struct ParsedUnionVariantArena_s ParsedUnionVariantArena_s;
typedef struct ParsedFuncDeclArena_s ParsedFuncDeclArena_s;
typedef struct ParsedBlockArena_s ParsedBlockArena_s;
typedef struct ParsedStmtArena_s ParsedStmtArena_s;
typedef struct ParsedExprArena_s ParsedExprArena_s;
typedef struct ParsedTypeNodeArena_s ParsedTypeNodeArena_s;
typedef struct TypeArena_s TypeArena_s;
typedef struct DLLArena_s DLLArena_s;
typedef struct ParsedPatternArena_s ParsedPatternArena_s;
typedef struct LLVMMetadataArena_s LLVMMetadataArena_s;
typedef struct Lexer_s Lexer_s;
typedef struct String_IRFuncEntry_s String_IRFuncEntry_s;
typedef struct String_IRFuncHashMap_s String_IRFuncHashMap_s;
typedef struct ByteBuffer_s ByteBuffer_s;
typedef struct Function_s Function_s;
typedef struct GPR_s GPR_s;
typedef struct FPR_s FPR_s;
typedef struct ImmI8_s ImmI8_s;
typedef struct ImmI16_s ImmI16_s;
typedef struct ImmI32_s ImmI32_s;
typedef struct ImmI64_s ImmI64_s;
typedef struct ImmF32_s ImmF32_s;
typedef struct ImmF64_s ImmF64_s;
typedef struct Assembler_s Assembler_s;
typedef struct CallStackInfo_s CallStackInfo_s;
typedef struct CallStack_s CallStack_s;
typedef struct IRInterp_s IRInterp_s;
typedef struct LLVMBasicBlock_s LLVMBasicBlock_s;
typedef struct LLVMAttribute_s LLVMAttribute_s;
typedef struct LLVMValue_s LLVMValue_s;
typedef struct LLVMType_s LLVMType_s;
typedef struct LLVMPassBuilderOptions_s LLVMPassBuilderOptions_s;
typedef struct LLVMDataLayout_s LLVMDataLayout_s;
typedef struct LLVMTargetData_s LLVMTargetData_s;
typedef struct LLVMTarget_s LLVMTarget_s;
typedef struct LLVMTargetMachine_s LLVMTargetMachine_s;
typedef struct LLVMTargetMachineOptions_s LLVMTargetMachineOptions_s;
typedef struct LLVMModule_s LLVMModule_s;
typedef struct LLVMBuilder_s LLVMBuilder_s;
typedef struct LLVMContext_s LLVMContext_s;
typedef struct DebugInfo_s DebugInfo_s;
typedef struct LLVMDIBuilder_s LLVMDIBuilder_s;
typedef struct LLVMDbgRecord_s LLVMDbgRecord_s;
typedef struct LLVMCodegen_s LLVMCodegen_s;
typedef struct RegIndex_s RegIndex_s;
typedef struct IRReg_s IRReg_s;
typedef struct IRInstr_s IRInstr_s;
typedef struct LoopBlock_s LoopBlock_s;
typedef struct IRBlockID_s IRBlockID_s;
typedef struct IRBlock_s IRBlock_s;
typedef struct IRFunc_s IRFunc_s;
typedef struct IRScopeEntry_s IRScopeEntry_s;
typedef struct IRScope_s IRScope_s;
typedef struct IRGen_s IRGen_s;
typedef struct Parser_s Parser_s;
typedef struct Lookup_s Lookup_s;
typedef struct FileLookup_s FileLookup_s;
typedef struct ImportLookup_s ImportLookup_s;
typedef struct ModuleLookup_s ModuleLookup_s;
typedef struct MLConfig_s MLConfig_s;
typedef struct FunctionLookup_s FunctionLookup_s;
typedef struct TypeLookup_s TypeLookup_s;
typedef struct StructLookup_s StructLookup_s;
typedef struct UnionLookup_s UnionLookup_s;
typedef struct UnionVariantLookup_s UnionVariantLookup_s;
typedef struct VariableLookup_s VariableLookup_s;
typedef struct ScopeLookup_s ScopeLookup_s;
typedef struct PatState_s PatState_s;
typedef struct TypeChecker_s TypeChecker_s;
typedef struct ArrayContext_s ArrayContext_s;
typedef struct StructContext_s StructContext_s;
typedef struct StructInitContext_s StructInitContext_s;
typedef struct ParamContext_s ParamContext_s;
typedef struct IfContext_s IfContext_s;
typedef struct FuncAttr_s FuncAttr_s;
typedef struct ParsedAttributeList_s ParsedAttributeList_s;
typedef struct FunctionLookupList_s FunctionLookupList_s;
typedef struct StructLookupList_s StructLookupList_s;
typedef struct ScopeLookupList_s ScopeLookupList_s;
typedef struct TypeLookupList_s TypeLookupList_s;
typedef struct VariableLookupList_s VariableLookupList_s;
typedef struct ImportLookupList_s ImportLookupList_s;
typedef struct ModuleLookupList_s ModuleLookupList_s;
typedef struct TCStateList_s TCStateList_s;
typedef struct RegIndexList_s RegIndexList_s;
typedef struct IRInstrList_s IRInstrList_s;
typedef struct IRScopeList_s IRScopeList_s;
typedef struct IRRegList_s IRRegList_s;
typedef struct IRBlockList_s IRBlockList_s;
typedef struct LoopBlockList_s LoopBlockList_s;
typedef struct IRScopeEntryList_s IRScopeEntryList_s;
typedef struct IRFuncList_s IRFuncList_s;
typedef struct LLVMTypeList_s LLVMTypeList_s;
typedef struct RegValueList_s RegValueList_s;
typedef struct LLVMBasicBlockList_s LLVMBasicBlockList_s;
typedef struct LLVMValueList_s LLVMValueList_s;
typedef struct UsizeList_s UsizeList_s;
typedef struct ConfigList_s ConfigList_s;
typedef struct TokenList_s TokenList_s;
typedef struct ParsedTypeNodeList_s ParsedTypeNodeList_s;
typedef struct ParsedUnionVariantList_s ParsedUnionVariantList_s;
typedef struct UnionLookupList_s UnionLookupList_s;
typedef struct UnionVariantLookupList_s UnionVariantLookupList_s;
typedef struct ParsedPatternList_s ParsedPatternList_s;
typedef struct ParsedStmtList_s ParsedStmtList_s;
typedef struct ParsedExprList_s ParsedExprList_s;
typedef struct TypeList_s TypeList_s;
typedef struct ParsedConfig_s ParsedConfig_s;
typedef struct ParsedFile_s ParsedFile_s;
typedef struct TLIParent_s TLIParent_s;
typedef struct ParsedTopLevelItem_s ParsedTopLevelItem_s;
typedef struct DLL_s DLL_s;
typedef struct ParsedModule_s ParsedModule_s;
typedef struct ParsedStructDecl_s ParsedStructDecl_s;
typedef struct ParsedUnionDecl_s ParsedUnionDecl_s;
typedef struct ParsedUnionVariant_s ParsedUnionVariant_s;
typedef struct ParsedFuncDecl_s ParsedFuncDecl_s;
typedef struct ParsedBlock_s ParsedBlock_s;
typedef struct VarDecl_s VarDecl_s;
typedef struct ParsedStmt_s ParsedStmt_s;
typedef struct ParsedTypeNode_s ParsedTypeNode_s;
typedef struct IdentExpr_s IdentExpr_s;
typedef struct StructExpr_s StructExpr_s;
typedef struct CallExpr_s CallExpr_s;
typedef struct ParsedExpr_s ParsedExpr_s;
typedef struct ParsedPattern_s ParsedPattern_s;
typedef struct Span_s Span_s;
typedef struct Flag_s Flag_s;
typedef struct FlagParser_s FlagParser_s;
typedef struct GAF_List_s GAF_List_s;
typedef struct GAF_HashMap_s GAF_HashMap_s;
typedef struct GAF_HashSet_s GAF_HashSet_s;
typedef struct Var_Context_s Var_Context_s;
typedef struct CStack_s CStack_s;
typedef struct CGen_s CGen_s;
typedef struct TypeDeclEntry_s TypeDeclEntry_s;
typedef struct Flags_s Flags_s;

// Union Declarations:
typedef struct LLVM_CodeGenOptLevel_u LLVM_CodeGenOptLevel_u;
typedef struct LLVM_RelocMode_u LLVM_RelocMode_u;
typedef struct LLVM_CodeModel_u LLVM_CodeModel_u;
typedef struct IRValue_u IRValue_u;
typedef struct ASMDialect_u ASMDialect_u;
typedef struct ASMConstraint_u ASMConstraint_u;
typedef struct ASMLoc_u ASMLoc_u;
typedef struct UnionVariantTypeInfo_u UnionVariantTypeInfo_u;
typedef struct TypeInfo_u TypeInfo_u;
typedef struct RegValue_u RegValue_u;
typedef struct TCState_u TCState_u;
typedef struct PrimType_u PrimType_u;
typedef struct Type_u Type_u;
typedef struct ParsedAttribute_u ParsedAttribute_u;
typedef struct Config_u Config_u;
typedef struct ParsedUnionVariantData_u ParsedUnionVariantData_u;
typedef struct StmtData_u StmtData_u;
typedef struct Assoc_u Assoc_u;
typedef struct ExprData_u ExprData_u;
typedef struct UnaryExpr_u UnaryExpr_u;
typedef struct BinaryExpr_u BinaryExpr_u;
typedef struct UnionExpr_u UnionExpr_u;
typedef struct Pattern_u Pattern_u;
typedef struct FlagData_u FlagData_u;

// Tuple Types:
typedef struct tuple_1017 tuple_1017;
typedef struct tuple_4302 tuple_4302;
typedef struct tuple_4431 tuple_4431;
typedef struct tuple_4518 tuple_4518;

// Array Types:
typedef struct array_384 array_384;
typedef struct array_5216 array_5216;
typedef struct array_5263 array_5263;
typedef struct array_5566 array_5566;
typedef struct array_5926 array_5926;
typedef struct array_6084 array_6084;
typedef struct array_27633 array_27633;
typedef struct array_30032 array_30032;
typedef struct array_30033 array_30033;
typedef struct array_32406 array_32406;
typedef struct array_33255 array_33255;

struct StringList_s {
    String_s *elements;
    usize length;
    usize capacity;
};
struct String_s {
    char *buffer;
    usize length;
    usize capacity;
};
struct SubStr_s {
    char *start;
    usize len;
};
struct StringBuffer_s {
    SubStr_s *data;
    usize length;
    usize capacity;
};
struct BOOL_s {
    i32 i;
};
struct Handle_s {
    usize ptr;
};
struct StartupInfo_s {
    u32 cb;
    char *lpReserved;
    char *lpDesktop;
    char *lpTitle;
    u32 dwX;
    u32 dwY;
    u32 dwXSize;
    u32 dwYSize;
    u32 dwXCountChars;
    u32 dwYCountChars;
    u32 dwFillAttribute;
    u32 dwFlags;
    u16 wShowWindow;
    u16 cbReserved2;
    u8 *lpReserved2;
    Handle_s hStdInput;
    Handle_s hStdOutput;
    Handle_s hStdError;
};
struct SecurityAttributes_s {
    u32 nLength;
    Any lpSecurityDescriptor;
    bool bInheritHandle;
};
struct ProcessInformation_s {
    Handle_s hProcess;
    Handle_s hThread;
    u32 dwProcessId;
    u32 dwThreadId;
};
struct FileTime_s {
    usize time;
};
struct Cmd_s {
    bool log;
    StringBuffer_s buf;
};
struct LLVM_TargetMachineOptionsRef_s {
    Any ptr;
};
struct LLVM_TargetMachineRef_s {
    Any ptr;
};
struct LLVM_TargetRef_s {
    Any ptr;
};
struct LLVM_TargetDataRef_s {
    Any ptr;
};
struct LLVM_ContextRef_s {
    Any ptr;
};
struct LLVM_ModuleRef_s {
    Any ptr;
};
struct LLVM_BuilderRef_s {
    Any ptr;
};
struct LLVM_BasicBlockRef_s {
    Any ptr;
};
struct LLVM_ValueRef_s {
    Any ptr;
};
struct LLVM_TypeRef_s {
    Any ptr;
};
struct LLVM_AttributeRef_s {
    Any ptr;
};
struct LLVM_PassBuilderOptionsRef_s {
    Any ptr;
};
struct LLVM_ErrorRef_s {
    Any ptr;
};
struct LLVM_DIBuilderRef_s {
    Any ptr;
};
struct LLVM_MetadataRef_s {
    Any ptr;
};
struct LLVM_DbgRecordRef_s {
    Any ptr;
};
struct LLVMBool_s {
    i32 val;
};
struct LLVMString_s {
    char *chars;
};
struct InterpReg_s {
    usize offset;
    usize size;
};
struct IRValueList_s {
    IRValue_u *elements;
    usize length;
    usize capacity;
};
struct ASMDialect_u {
    u8 tag;
};
struct ASMContext_s {
    String_s code;
    StringList_s out;
    StringList_s in;
    StringList_s clobber;
    IRValueList_s args;
    bool sideEffects;
    bool alignedStack;
    ASMDialect_u dialect;
    bool canThrow;
};
struct Span_s {
    usize file;
    usize start;
    usize end;
};
struct Token_s {
    Span_s span;
    SubStr_s content;
    usize kind;
};
struct TypeInfoTable_s {
    TypeInfo_u *elements;
    usize length;
    usize capacity;
};
struct TypeInfoList_s {
    usize *elements;
    usize length;
    usize capacity;
};
struct FieldTypeInfoList_s {
    FieldTypeInfo_s *elements;
    usize length;
    usize capacity;
};
struct FieldTypeInfo_s {
    SubStr_s name;
    usize type;
    usize offset_in_bytes;
};
struct UnionVariantTypeInfoList_s {
    UnionVariantTypeInfo_u *elements;
    usize length;
    usize capacity;
};
struct TypeInfo_u {
    u8 tag;
    union {
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
        } variant1;
        struct {
            SubStr_s _0;
            usize _1;
        } variant2;
        struct {
            SubStr_s _0;
            usize _1;
        } variant3;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            usize _3;
            usize _4;
        } variant4;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            FieldTypeInfoList_s _3;
        } variant5;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            UnionVariantTypeInfoList_s _3;
        } variant6;
        struct {
            SubStr_s _0;
            TypeInfoList_s _1;
            usize _2;
        } variant7;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            TypeInfoList_s _3;
        } variant8;
    } payload;
};
struct Data_s {
    Any ptr;
    TypeInfo_u info;
};
struct LLVMMetadata_s {
    LLVM_MetadataRef_s ref;
};
struct ArenaBlock_s {
    Any elements;
    usize length;
    usize capacity;
    usize elemSize;
    ArenaBlock_s *next;
};
struct ParsedConfigArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedFileArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedTopLevelItemArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedModuleArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedStructDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedUnionDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedUnionVariantArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedFuncDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedBlockArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedStmtArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedExprArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedTypeNodeArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct TypeArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct DLLArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedPatternArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct LLVMMetadataArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct Lexer_s {
    usize fileID;
    SubStr_s content;
    usize ptr;
    usize len;
};
struct IRScopeList_s {
    IRScope_s *elements;
    usize length;
    usize capacity;
};
struct IRRegList_s {
    IRReg_s *elements;
    usize length;
    usize capacity;
};
struct IRBlockList_s {
    IRBlock_s *elements;
    usize length;
    usize capacity;
};
struct LoopBlockList_s {
    LoopBlock_s *elements;
    usize length;
    usize capacity;
};
struct IRBlockID_s {
    usize i;
};
struct LLVMValue_s {
    LLVM_ValueRef_s ref;
};
struct RegIndex_s {
    usize i;
};
struct ParsedAttributeList_s {
    ParsedAttribute_u *elements;
    usize length;
    usize capacity;
};
struct IRFunc_s {
    usize originalID;
    String_s name;
    Span_s span;
    usize comptimeLevel;
    IRScopeList_s scopes;
    IRRegList_s registers;
    IRBlockList_s blocks;
    LoopBlockList_s loopBlocks;
    IRBlockID_s currentBlock;
    LLVMValue_s llvmFunc;
    RegIndex_s retPtr;
    ParsedAttributeList_s attrs;
    IRBlockID_s returnBlockID;
    RegIndex_s returnAlloc;
    usize allocaCounter;
};
struct String_IRFuncEntry_s {
    bool set;
    String_s key;
    IRFunc_s value;
};
struct String_IRFuncHashMap_s {
    String_IRFuncEntry_s *elements;
    usize length;
    usize capacity;
    bool locked;
};
struct ByteBuffer_s {
    u8 *elements;
    usize length;
    usize capacity;
};
struct Function_s {
    u64 (*run)(none);
    usize size;
};
struct GPR_s {
    u8 r;
};
struct FPR_s {
    u8 r;
};
struct ImmI8_s {
    u8 b;
};
struct ImmI16_s {
    u16 b;
};
struct ImmI32_s {
    u32 b;
};
struct ImmI64_s {
    u64 b;
};
struct ImmF32_s {
    f32 b;
};
struct ImmF64_s {
    f64 b;
};
struct CallStackInfo_s {
    Span_s span;
    String_s name;
};
struct CallStack_s {
    CallStackInfo_s *elements;
    usize length;
    usize capacity;
};
struct IRInterp_s {
    IRGen_s *irGen;
    u8 *regStackStart;
    RegValueList_s *globalRegisters;
    u8 *globalRegBase;
    u8 *regStackBase;
    u8 *realStackStart;
    u8 *realStackPointer;
    u8 *realStackBase;
    u8 *argStack;
    usize argStackLength;
    usize argStackCapacity;
    CallStack_s callStack;
};
struct LLVMBasicBlock_s {
    LLVM_BasicBlockRef_s ref;
};
struct LLVMAttribute_s {
    LLVM_AttributeRef_s ref;
};
struct LLVMType_s {
    LLVM_TypeRef_s ref;
};
struct LLVMPassBuilderOptions_s {
    LLVM_PassBuilderOptionsRef_s ref;
};
struct LLVMDataLayout_s {
    char *ref;
};
struct LLVMTargetData_s {
    LLVM_TargetDataRef_s ref;
};
struct LLVMTarget_s {
    LLVM_TargetRef_s ref;
};
struct LLVMTargetMachine_s {
    LLVM_TargetMachineRef_s ref;
};
struct LLVMTargetMachineOptions_s {
    LLVM_TargetMachineOptionsRef_s ref;
};
struct LLVMModule_s {
    LLVM_ModuleRef_s ref;
};
struct LLVMBuilder_s {
    LLVM_BuilderRef_s ref;
};
struct LLVMContext_s {
    LLVM_ContextRef_s ref;
};
struct DebugInfo_s {
    LLVMMetadata_s diUnit;
    LLVMMetadata_s diFile;
    LLVMMetadata_s diType;
};
struct LLVMDIBuilder_s {
    LLVM_DIBuilderRef_s ref;
};
struct LLVMDbgRecord_s {
    LLVM_DbgRecordRef_s ref;
};
struct RegValueList_s {
    RegValue_u *elements;
    usize length;
    usize capacity;
};
struct LLVMCodegen_s {
    LLVMContext_s llvmContext;
    LLVMModule_s llvmModule;
    LLVMBuilder_s llvmBuilder;
    LLVMTargetMachine_s llvmTargetMachine;
    LLVMDIBuilder_s llvmDIBuilder;
    IRGen_s *irGen;
    IRInterp_s *interp;
    RegValueList_s global;
};
struct IRReg_s {
    bool isComptime;
    usize offset;
    Type_u *typ;
};
struct RegIndexList_s {
    RegIndex_s *elements;
    usize length;
    usize capacity;
};
struct IRInstr_s {
    usize kind;
    Span_s span;
    bool isComptime;
    RegIndex_s dst;
    RegIndex_s src;
    RegIndex_s op1;
    RegIndexList_s args;
};
struct LoopBlock_s {
    IRBlockID_s before;
    IRBlockID_s after;
};
struct IRInstrList_s {
    IRInstr_s *elements;
    usize length;
    usize capacity;
};
struct IRBlock_s {
    String_s parent;
    IRBlockID_s id;
    IRInstrList_s instructions;
};
struct IRScopeEntry_s {
    SubStr_s name;
    RegIndex_s ptr;
    bool isComptime;
};
struct IRScopeEntryList_s {
    IRScopeEntry_s *elements;
    usize length;
    usize capacity;
};
struct IRScope_s {
    IRScopeEntryList_s entries;
};
struct IRGen_s {
    Lookup_s *lookup;
    IRFunc_s globalScope;
    IRFunc_s initRuntime;
    String_IRFuncHashMap_s functions;
    TypeInfoTable_s type_info_table;
    RegIndex_s type_info_array_register;
    bool error;
};
struct Parser_s {
    Lexer_s lexer;
    usize anonFnCount;
    String_s *importRoots;
    usize importRootLength;
    usize importRootCapacity;
};
struct ModuleLookupList_s {
    ModuleLookup_s *elements;
    usize length;
    usize capacity;
};
struct Lookup_s {
    ModuleLookupList_s files;
};
struct ImportLookupList_s {
    ImportLookup_s *elements;
    usize length;
    usize capacity;
};
struct FunctionLookupList_s {
    FunctionLookup_s *elements;
    usize length;
    usize capacity;
};
struct StructLookupList_s {
    StructLookup_s *elements;
    usize length;
    usize capacity;
};
struct UnionLookupList_s {
    UnionLookup_s *elements;
    usize length;
    usize capacity;
};
struct ScopeLookupList_s {
    ScopeLookup_s *elements;
    usize length;
    usize capacity;
};
struct ModuleLookup_s {
    usize globalID;
    Lookup_s *globalLookup;
    ParsedModule_s *parent;
    Token_s name;
    ImportLookupList_s imports;
    ModuleLookupList_s modules;
    FunctionLookupList_s functions;
    StructLookupList_s structs;
    UnionLookupList_s unions;
    ScopeLookupList_s variables;
};
struct FileLookup_s {
    usize globalID;
    SubStr_s origin;
    ModuleLookup_s mod;
};
struct ImportLookup_s {
    Span_s span;
    usize fileID;
};
struct MLConfig_s {
    bool checkSelf;
    bool checkImport;
    bool checkModule;
    bool checkParent;
    bool allowData;
};
struct TLIParent_s {
    bool isFile;
    u32 id;
};
struct PatState_s {
    bool complete;
};
struct TCState_u {
    u8 tag;
    union {
        struct {
            usize _0;
        } variant2;
        struct {
            Type_u *_0;
        } variant3;
        struct {
            PatState_s _0;
        } variant5;
    } payload;
};
struct VariableLookupList_s {
    VariableLookup_s *elements;
    usize length;
    usize capacity;
};
struct FunctionLookup_s {
    usize globalID;
    TLIParent_s parent;
    Token_s name;
    TCState_u fnType;
    VariableLookupList_s params;
    bool isVarArg;
};
struct TypeLookup_s {
    usize kind;
    Any actual;
};
struct StructLookup_s {
    usize globalID;
    TLIParent_s parent;
    Token_s name;
    VariableLookupList_s fields;
    Type_u *type;
};
struct UnionVariantLookupList_s {
    UnionVariantLookup_s *elements;
    usize length;
    usize capacity;
};
struct UnionLookup_s {
    ParsedUnionDecl_s *global;
    TLIParent_s parent;
    Token_s name;
    UnionVariantLookupList_s variants;
    Type_u *type;
};
struct UnionVariantLookup_s {
    ParsedUnionVariant_s *global;
    usize tag;
    TCState_u typeState;
};
struct VariableLookup_s {
    usize globalID;
    Token_s name;
    TCState_u typeState;
    bool isComptime;
};
struct ScopeLookup_s {
    VariableLookupList_s variables;
};
struct TypeChecker_s {
    usize comptimeDepth;
    ModuleLookup_s *currentModule;
    FunctionLookup_s *currentFunction;
    usize anonFuncDepth;
    Lookup_s lookup;
    bool typeError;
};
struct ArrayContext_s {
    usize *elemList;
    usize elemLength;
    usize elemCapacity;
    usize size;
};
struct StructContext_s {
    Token_s *fieldNames;
    ParsedTypeNode_s **fieldTypes;
    usize fieldLength;
    usize fieldCapacity;
};
struct StructInitContext_s {
    Token_s *fieldNames;
    ParsedExpr_s **fieldExprs;
    usize fieldLength;
    usize fieldCapacity;
};
struct ParamContext_s {
    Token_s *paramNames;
    ParsedTypeNode_s **paramTypes;
    usize paramLength;
    usize paramCapacity;
    bool isVarArg;
};
struct IfContext_s {
    ParsedStmt_s *thenBody;
    ParsedStmt_s *elseBody;
    bool hasElse;
};
struct FuncAttr_s {
    bool isVariadic;
    bool isNoreturn;
};
struct TypeLookupList_s {
    TypeLookup_s *elements;
    usize length;
    usize capacity;
};
struct TCStateList_s {
    TCState_u *elements;
    usize length;
    usize capacity;
};
struct IRFuncList_s {
    IRFunc_s *elements;
    usize length;
    usize capacity;
};
struct LLVMTypeList_s {
    LLVMType_s *elements;
    usize length;
    usize capacity;
};
struct LLVMBasicBlockList_s {
    LLVMBasicBlock_s *elements;
    usize length;
    usize capacity;
};
struct LLVMValueList_s {
    LLVMValue_s *elements;
    usize length;
    usize capacity;
};
struct UsizeList_s {
    usize *elements;
    usize length;
    usize capacity;
};
struct ConfigList_s {
    Config_u *elements;
    usize length;
    usize capacity;
};
struct TokenList_s {
    Token_s *elements;
    usize length;
    usize capacity;
};
struct ParsedTypeNodeList_s {
    ParsedTypeNode_s **elements;
    usize length;
    usize capacity;
};
struct ParsedUnionVariantList_s {
    ParsedUnionVariant_s **elements;
    usize length;
    usize capacity;
};
struct ParsedPatternList_s {
    ParsedPattern_s **elements;
    usize length;
    usize capacity;
};
struct ParsedStmtList_s {
    ParsedStmt_s **elements;
    usize length;
    usize capacity;
};
struct ParsedExprList_s {
    ParsedExpr_s **elements;
    usize length;
    usize capacity;
};
struct TypeList_s {
    Type_u **elements;
    usize length;
    usize capacity;
};
struct ParsedConfig_s {
    bool ignored;
    Span_s span;
    ConfigList_s configs;
};
struct ParsedFile_s {
    bool ignored;
    SubStr_s origin;
    SubStr_s src;
    ParsedModule_s *mod;
    DebugInfo_s debugInfo;
};
struct ParsedTopLevelItem_s {
    bool ignored;
    TLIParent_s parent;
    usize kind;
    Span_s span;
    usize nodeID;
    ParsedAttributeList_s attributes;
    TCState_u typeState;
};
struct DLL_s {
    String_s path;
    Handle_s handle;
};
struct ParsedModule_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    UsizeList_s tlis;
    UsizeList_s dlls;
};
struct ParsedStructDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    StructContext_s context;
    TCState_u typeState;
    DebugInfo_s debugInfo;
    bool isDataDefinition;
};
struct ParsedUnionDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    ParsedUnionVariantList_s variants;
    TCState_u typeState;
    DebugInfo_s debugInfo;
};
struct ParsedUnionVariantData_u {
    u8 tag;
    union {
        struct {
            ParsedTypeNodeList_s _0;
        } variant1;
        struct {
            ParsedTypeNodeList_s _0;
            TokenList_s _1;
        } variant2;
    } payload;
};
struct ParsedUnionVariant_s {
    bool ignored;
    TLIParent_s parent;
    Span_s span;
    Token_s name;
    ParsedUnionVariantData_u data;
};
struct ParsedFuncDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    ParamContext_s params;
    ParsedTypeNode_s *retType;
    ParsedBlock_s *body;
    ParsedAttributeList_s attrs;
    bool isComptime;
    TCState_u typeState;
    DLL_s *dllHandle;
    DebugInfo_s debugInfo;
};
struct ParsedBlock_s {
    bool ignored;
    Span_s span;
    ParsedStmt_s **stmtList;
    usize stmtLength;
    usize stmtCapacity;
    TCState_u typeState;
};
struct VarDecl_s {
    ParsedPattern_s *pat;
    ParsedExpr_s *expr;
    ParsedBlock_s *trampoline;
    bool isComptime;
    bool isGlobal;
    usize origin;
};
struct StmtData_u {
    u8 tag;
    union {
        struct {
            VarDecl_s _0;
        } variant0;
        struct {
            ParsedExpr_s *_0;
        } variant2;
        struct {
            ParsedExpr_s *_0;
        } variant3;
        struct {
            ParsedBlock_s *_0;
        } variant4;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
        } variant5;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
            ParsedStmt_s *_2;
        } variant6;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
        } variant7;
        struct {
            ParsedStmt_s *_0;
            ParsedExpr_s *_1;
            ParsedExpr_s *_2;
            ParsedStmt_s *_3;
        } variant8;
        struct {
            ParsedExpr_s *_0;
            ParsedPatternList_s _1;
            ParsedStmtList_s _2;
        } variant11;
        struct {
            ParsedExpr_s *_0;
            ParsedExprList_s _1;
        } variant12;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
        } variant13;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
            ParsedBlock_s *_3;
        } variant14;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
        } variant15;
    } payload;
};
struct ParsedStmt_s {
    bool ignored;
    Span_s span;
    StmtData_u data;
    TCState_u typeState;
};
struct ParsedTypeNode_s {
    bool ignored;
    Span_s span;
    usize kind;
    ParsedTypeNode_s *underlyingID;
    ParsedTypeNodeList_s fnParams;
    usize arraySize;
    Token_s nameTkn;
    TCState_u typeState;
};
struct IdentExpr_s {
    Token_s name;
    bool isGlobal;
    usize origID;
    Type_u *type;
};
struct StructExpr_s {
    Token_s name;
    StructInitContext_s context;
};
struct CallExpr_s {
    Span_s span;
    ParsedExpr_s *base;
    ParsedExprList_s args;
    Type_u *retType;
    bool isUnion;
};
struct UnaryExpr_u {
    u8 tag;
    union {
        struct {
            ParsedExpr_s *_0;
        } variant0;
        struct {
            ParsedExpr_s *_0;
        } variant1;
        struct {
            ParsedExpr_s *_0;
        } variant2;
        struct {
            ParsedExpr_s *_0;
        } variant3;
        struct {
            ParsedExpr_s *_0;
        } variant4;
    } payload;
};
struct BinaryExpr_u {
    u8 tag;
    union {
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant0;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant1;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant2;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant3;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant4;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant5;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant6;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant7;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant8;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant9;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant10;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant11;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant12;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant13;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant14;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant15;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant16;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant17;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant18;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant19;
    } payload;
};
struct UnionExpr_u {
    u8 tag;
    union {
        struct {
            CallExpr_s _0;
        } variant0;
        struct {
            StructExpr_s _0;
        } variant1;
    } payload;
};
struct ExprData_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant0;
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            ArrayContext_s _0;
        } variant3;
        struct {
            IdentExpr_s _0;
        } variant4;
        struct {
            UnaryExpr_u _0;
        } variant5;
        struct {
            BinaryExpr_u _0;
        } variant6;
        struct {
            CallExpr_s _0;
        } variant7;
        struct {
            ParsedTypeNode_s *_0;
        } variant8;
        struct {
            StructExpr_s _0;
        } variant9;
        struct {
            UnionExpr_u _0;
        } variant10;
        struct {
            ParsedExpr_s *_0;
            ParsedTypeNode_s *_1;
        } variant11;
        struct {
            ParsedFuncDecl_s *_0;
        } variant16;
        struct {
            ParsedTypeNode_s *_0;
        } variant17;
        struct {
            ParsedExpr_s *_0;
        } variant18;
        struct {
            ParsedExprList_s _0;
        } variant19;
        struct {
            ParsedExprList_s _0;
        } variant20;
    } payload;
};
struct ParsedExpr_s {
    bool ignored;
    Span_s span;
    ExprData_u data;
    TCState_u typeState;
};
struct Pattern_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            ParsedPattern_s *_0;
            ParsedTypeNode_s *_1;
        } variant3;
        struct {
            ParsedPattern_s *_0;
        } variant4;
        struct {
            Token_s _0;
            ParsedPatternList_s _1;
        } variant5;
        struct {
            Token_s _0;
            ParsedPattern_s *_1;
        } variant6;
        struct {
            ParsedPatternList_s _0;
        } variant7;
        struct {
            bool _0;
        } variant9;
    } payload;
};
struct ParsedPattern_s {
    bool ignored;
    Span_s span;
    Pattern_u data;
};
struct FlagData_u {
    u8 tag;
    union {
        struct {
            String_s _0;
        } variant1;
        struct {
            bool _0;
        } variant2;
    } payload;
};
struct Flag_s {
    bool found;
    usize mode;
    char *short_;
    char *long_;
    char *descr;
    FlagData_u data;
};
struct array_384 {
    Flag_s arr[32];
};
struct FlagParser_s {
    String_s programName;
    bool *helpFlag;
    array_384 flags;
    usize flagCount;
    StringList_s errors;
};
struct GAF_List_s {
    Any elements;
    usize length;
    usize capacity;
    TypeInfo_u type;
    usize type_size;
};
struct GAF_HashMap_s {
    Any elements;
    Any keys;
    bool *set_elements;
    usize length;
    usize capacity;
    TypeInfo_u key_type;
    usize key_type_size;
    TypeInfo_u value_type;
    usize value_type_size;
    usize (*key_hash_fn)(Data_s);
    bool (*key_equals_fn)(Data_s, Data_s);
};
struct GAF_HashSet_s {
    GAF_HashMap_s _map;
};
struct Var_Context_s {
    bool bound_in_reference_pattern;
};
struct CStack_s {
    GAF_HashMap_s variables;
};
struct CGen_s {
    GAF_List_s stack;
    GAF_HashMap_s variadic_map;
    GAF_HashMap_s array_map_declared;
    GAF_HashMap_s array_map_defined;
    GAF_HashMap_s tuple_map_declared;
    GAF_HashMap_s tuple_map_defined;
    TypeInfoTable_s type_info_table;
};
struct TypeDeclEntry_s {
    String_s c_code;
    bool generated;
};
struct Flags_s {
    String_s *file;
    String_s *out;
    bool *verbose;
    bool *warnSimple;
    bool *warnExtra;
    bool *warnUnused;
    String_s *target;
    bool *checkOnly;
    bool *emitASM;
    bool *emitBIR;
    bool *emitLLVM;
    bool *transpileToC;
    bool *dontLink;
    bool *noEntry;
    bool *linkDynamic;
    bool *debug;
    bool *trace;
    bool *opt;
    bool *disableExternalComptime;
    bool *disableInlineAssembly;
};
struct LLVM_CodeGenOptLevel_u {
    u8 tag;
};
struct LLVM_RelocMode_u {
    u8 tag;
};
struct LLVM_CodeModel_u {
    u8 tag;
};
struct IRValue_u {
    u8 tag;
    union {
        struct {
            LLVM_ValueRef_s _0;
        } variant1;
        struct {
            InterpReg_s _0;
        } variant2;
        struct {
            LLVM_ValueRef_s _0;
            InterpReg_s _1;
        } variant3;
    } payload;
};
struct ASMLoc_u {
    u8 tag;
    union {
        struct {
            char *_0;
        } variant1;
    } payload;
};
struct ASMConstraint_u {
    u8 tag;
    union {
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant0;
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant1;
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant2;
        struct {
            ASMLoc_u _0;
        } variant3;
    } payload;
};
struct UnionVariantTypeInfo_u {
    u8 tag;
    union {
        struct {
            SubStr_s _0;
        } variant0;
        struct {
            SubStr_s _0;
            TypeInfoList_s _1;
        } variant1;
        struct {
            SubStr_s _0;
            FieldTypeInfoList_s _1;
        } variant2;
    } payload;
};
struct RegValue_u {
    u8 tag;
    union {
        struct {
            LLVMValue_s _0;
        } variant1;
        struct {
            InterpReg_s _0;
        } variant2;
        struct {
            LLVMValue_s _0;
            InterpReg_s _1;
        } variant3;
    } payload;
};
struct PrimType_u {
    u8 tag;
};
struct Type_u {
    u8 tag;
    union {
        struct {
            Type_u *_0;
        } variant2;
        struct {
            PrimType_u _0;
        } variant3;
        struct {
            Type_u *_0;
        } variant4;
        struct {
            Type_u *_0;
            usize _1;
        } variant5;
        struct {
            TypeList_s _0;
            Type_u *_1;
            FuncAttr_s _2;
        } variant6;
        struct {
            ParsedStructDecl_s *_0;
        } variant7;
        struct {
            ParsedUnionDecl_s *_0;
            usize _1;
        } variant8;
        struct {
            ParsedModule_s *_0;
        } variant9;
        struct {
            TypeList_s _0;
        } variant10;
    } payload;
};
struct ParsedAttribute_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
    } payload;
};
struct Config_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant0;
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            Token_s _0;
        } variant3;
        struct {
            Token_s _0;
        } variant4;
    } payload;
};
struct Assoc_u {
    u8 tag;
};
struct tuple_1017 {
    bool _0;
    ParsedTypeNodeList_s *_1;
};
struct tuple_4302 {
    Var_Context_s _0;
    bool _1;
};
struct tuple_4431 {
    String_s _0;
    String_s _1;
};
struct tuple_4518 {
    Data_s _0;
    Data_s _1;
};
struct array_5216 {
    char arr[16];
};
struct array_5263 {
    InterpReg_s (*arr[81])(IRInterp_s *, IRFunc_s *, IRInstr_s *, RegValueList_s *, bool);
};
struct array_5566 {
    char arr[260];
};
struct array_5926 {
    char arr[50];
};
struct array_6084 {
    char arr[1024];
};
struct array_27633 {
    LLVMType_s arr[2];
};
struct array_30032 {
    GPR_s arr[4];
};
struct array_30033 {
    FPR_s arr[4];
};
struct array_32406 {
    LLVM_MetadataRef_s arr[2];
};
struct array_33255 {
    char *arr[26];
};

Any _fdopen(i32 fd, char *mode);
usize _snprintf(Any buffer, usize size, char *format, ...);
char *_fullpath(char *absPath, char *relPath, i32 maxLength);
i32 scanf(char *fmt, ...);
usize strlen(char *string);
i32 strcmp(char *s1, char *s2);
i32 strncmp(char *s1, char *s2, usize n);
char *strchr(char *s, char c);
Any malloc(usize bytes);
Any calloc(usize num, usize size);
Any realloc(Any ptr, usize new_size);
none free(Any ptr);
Any memcpy(Any dest, Any src, usize count);
i32 memcmp(Any lhs, Any rhs, usize count);
Any memset(Any s, i32 b, usize count);
Any C_aligned_allocuszuszrAny(usize alignment, usize size);
Any _aligned_malloc(usize size, usize alignment);
Any fopen(char *filename, char *mode);
usize fread(Any buffer, usize size, usize count, Any stream);
usize fwrite(Any buffer, usize size, usize count, Any stream);
i32 fclose(Any stream);
none fprintf(Any stream, char *msg, ...);
i32 fflush(Any stream);
char *getenv(char *name);
usize printf(char *msg, ...);
char putchar(char ch);
usize puts(char *s);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none abort(none);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none C_exiti32rN(i32 code);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none exit(i32 code);
none pushPS6808S0540rN(StringList_s *this, String_s element);
String_s *atPS6808uszrPS0540(StringList_s *this, usize index);
String_s *lastPS6808rPS0540(StringList_s *this);
usize hashPS0540rusz(String_s *this);
String_s toAbsolutePathPS0540rS0540(String_s *this);
String_s getFileNamePS0540rS0540(String_s *this);
String_s getRootPS0540rS0540(String_s *this);
none dropPS0540rN(String_s *this);
String_s copyPS0540rS0540(String_s *this);
none resizePS0540uszrN(String_s *this, usize newCap);
none printPS0540rN(String_s *this);
SubStr_s asSubStrPS0540rS7720(String_s *this);
SubStr_s substringPS0540uszuszrS7720(String_s *this, usize start, usize end);
none pushNumberPS0540uszrN(String_s *this, usize num);
none pushNumberAsHexPS0540uszrN(String_s *this, usize num);
none pushNumberPS0540f32rN(String_s *this, f32 i);
none pushNumberPS0540f64rN(String_s *this, f64 num);
none pushNumberPS0540u8rN(String_s *this, u8 i);
none pushNumberPS0540u16rN(String_s *this, u16 i);
none pushNumberPS0540u32rN(String_s *this, u32 i);
none pushNumberPS0540u64rN(String_s *this, u64 i);
none pushNumberPS0540i8rN(String_s *this, i8 i);
none pushNumberPS0540i16rN(String_s *this, i16 i);
none pushNumberPS0540i32rN(String_s *this, i32 i);
none pushNumberPS0540i64rN(String_s *this, i64 i);
none pushCharPS0540crN(String_s *this, char ch);
none pushHexPS0540u8rN(String_s *this, u8 hex);
none pushSubStrPS0540PS7720rN(String_s *this, SubStr_s *sub);
none pushStringPS0540PS0540rN(String_s *this, String_s *s);
none pushStrPS0540PcrN(String_s *this, char *s);
bool isNumberPS0540rB(String_s *this);
i64 toI64PS0540ri64(String_s *this);
u64 toU64PS0540ru64(String_s *this);
none replacePS0540ccrN(String_s *this, char what, char with);
StringList_s splitByPS0540FB_cPuszrS6808(String_s *this, bool (*pred)(char, usize *));
bool equalsPS0540PS0540rB(String_s *this, String_s *other);
String_s newStringrS0540(none);
String_s newReadonlyStringPcrS0540(char *s);
String_s newStringFromStrLitPcrS0540(char *s);
bool canReadFileToStringPcPS0540rB(char *path, String_s *source);
String_s readFileToStringPcrS0540(char *path);
none writeStringToFilePcS0540rN(char *path, String_s s);
bool isEmptyPS7720rB(SubStr_s *this);
usize hashPS7720uszrusz(SubStr_s *this, usize length);
usize hashPS7720rusz(SubStr_s *this);
u8 lexOrderPS7720PS7720ru8(SubStr_s *this, SubStr_s *other);
bool equalsPS7720PS7720rB(SubStr_s *this, SubStr_s *other);
none printPS7720rN(SubStr_s *this);
String_s getPathParentPS7720rS0540(SubStr_s *this);
String_s toStringPS7720rS0540(SubStr_s *this);
bool beginsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *prefix);
bool endsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *suffix);
none skipUntilPS7720FBcrN(SubStr_s *this, bool (*pred)(char));
SubStr_s splitNextPS7720FBcrS7720(SubStr_s *this, bool (*pred)(char));
none advancePS7720rN(SubStr_s *this);
none advancePS7720uszrN(SubStr_s *this, usize step);
SubStr_s substringPS7720uszuszrS7720(SubStr_s *this, usize start, usize end);
bool hasSpacePS7720rB(SubStr_s *this);
bool isNumberPS7720rB(SubStr_s *this);
u64 toU64PS7720ru64(SubStr_s *this);
f64 toF64PS7720rf64(SubStr_s *this);
SubStr_s newSubStrOfStrLitPcrS7720(char *orig);
SubStr_s newSubStrPcuszuszrS7720(char *orig, usize start, usize end);
SubStr_s newSubStrOfStringPS0540uszuszrS7720(String_s *orig, usize start, usize end);
SubStr_s defaultSubStrrS7720(none);
u8 tagAnyru8(Any union_);
SubStr_s comptimeSubStrPcrS7720(char *s);
none setupStdHandlesrN(none);
usize comptimeStrlenPcrusz(char *str);
usize pow2uszrusz(usize exp);
usize powuszuszrusz(usize base, usize exp);
usize shiftLeftuszuszrusz(usize base, usize bits);
usize shiftRightuszuszrusz(usize base, usize bits);
usize bitCountuszrusz(usize val);
bool isNumericcrB(char ch);
bool isAlphabeticcrB(char ch);
u8 asHexcru8(char ch);
bool isHexDigitcrB(char ch);
bool isWhitespacecrB(char ch);
bool isAlphanumericcrB(char ch);
bool isAsciiUppercasecrB(char ch);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none index_oobPci64rN(char* msg, i64 index);
none _empty_assertBrN(bool cond);
none _empty_assertBPcrN(bool cond, char *msg);
none assertBrN(bool cond);
none _assertBPcrN(bool cond, char *msg);
none assertBPcrN(bool cond, char *msg);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablerN(none);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablePcrN(char* msg);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none todo_with_msgPcrN(char* msg);
none warningPcrN(char *msg);
none resizePS6678uszrN(StringBuffer_s *this, usize newCap);
none addPS6678S7720rN(StringBuffer_s *this, SubStr_s str);
char *getNthAsCharPtrPS6678uszrPc(StringBuffer_s *this, usize index);
none extendPS6678PS6678rN(StringBuffer_s *this, StringBuffer_s *other);
String_s toCmdStringPS6678rS0540(StringBuffer_s *this);
StringBuffer_s newStringBufferrS6678(none);
bool successS1457rB(BOOL_s b);
bool failedS1457rB(BOOL_s b);
bool isNullS9457rB(Handle_s h);
BOOL_s CreateProcessA(char *lpApplicationName, char *lpCommandLine, SecurityAttributes_s *lpProcessAttributes, SecurityAttributes_s *lpThreadAttributes, BOOL_s bInheritHandles, u32 dwCreationFlags,
                      Any lpEnvironment, char *lpCurrentDirectory, StartupInfo_s *lpStartupInfo, ProcessInformation_s *lpProcessInformation);
Handle_s CreateFileA(char *lpFileName, u32 dwDesiredAccess, u32 dwShareMode, SecurityAttributes_s *lpSecurityAttributes, u32 dwCreationDisposition, u32 dwFlagsAndAttributes, Handle_s hTemplateFile);
u32 GetFileAttributesA(char *path);
Handle_s GetStdHandle(u32 handle);
BOOL_s CloseHandle(Handle_s handle);
u32 WaitForSingleObject(Handle_s hHandle, u32 dwMilliseconds);
BOOL_s GetExitCodeProcess(Handle_s proc, u32 *exitStatus);
u32 GetLastError(none);
BOOL_s GetFileTime(Handle_s hFile, FileTime_s *lpCreationTime, FileTime_s *lpLastAccessTime, FileTime_s *lpLastWriteTime);
Handle_s LoadLibraryA(char *lpLibFileName);
BOOL_s FreeLibrary(Handle_s hLibModule);
Handle_s GetProcAddress(Handle_s handle, char *name);
Any VirtualAlloc(Any idk, usize bytes, u32 flags, u32 pFlags);
BOOL_s VirtualFree(Any address, usize bytes, u32 flags);
u32 GetModuleFileNameA(Handle_s hModule, char *lpFileName, u32 nSize);
u32 FormatMessageA(u32 dwFlags, char *lpSource, u32 dwMessageId, u32 dwLanguageId, char **lpBuffer, u32 nSize, ...);
usize getLastModifiedPcrusz(char *filePath);
bool waitForProcessS9457rB(Handle_s proc);
bool dirExistsPcrB(char *path);
bool tryFindPcrB(char *program);
bool runCmdSyncS3657rB(Cmd_s cmd);
Handle_s runCmdAsyncS3657rS9457(Cmd_s cmd);
char *WinErroru32rPc(u32 error);
none addPS3657PcrN(Cmd_s *this, char *arg);
none addSubStrPS3657S7720rN(Cmd_s *this, SubStr_s arg);
none addManyPS3657S6678rN(Cmd_s *this, StringBuffer_s args);
bool runSyncPS3657rB(Cmd_s *this);
Handle_s runAsyncPS3657rS9457(Cmd_s *this);
String_s toStringPS3657rS0540(Cmd_s *this);
char **asCharPtrsPS3657rPPc(Cmd_s *this);
Cmd_s newCmdrS3657(none);
Cmd_s newCmdFromStrLitPcrS3657(char *command);
bool moveFilePcPcrB(char *from, char *to);
bool deleteFilePcrB(char *path);
bool LLVM_isNullS3482rB(LLVM_TargetMachineOptionsRef_s this);
bool LLVM_isNullS5038rB(LLVM_TargetMachineRef_s this);
bool LLVM_isNullS3497rB(LLVM_TargetRef_s this);
bool LLVM_isNullS6307rB(LLVM_TargetDataRef_s this);
bool LLVM_isNullS4183rB(LLVM_ContextRef_s this);
bool LLVM_isNullS3816rB(LLVM_ModuleRef_s this);
bool LLVM_isNullS3273rB(LLVM_BuilderRef_s this);
bool LLVM_isNullS6239rB(LLVM_BasicBlockRef_s this);
bool LLVM_isNullS1407rB(LLVM_ValueRef_s this);
bool LLVM_isNullS6708rB(LLVM_TypeRef_s this);
bool LLVM_isNullS8710rB(LLVM_AttributeRef_s this);
bool LLVM_isNullS7356rB(LLVM_PassBuilderOptionsRef_s this);
bool LLVM_isNullS0284rB(LLVM_ErrorRef_s this);
bool LLVM_isNullS1302rB(LLVM_DIBuilderRef_s this);
bool LLVM_isNullS9683rB(LLVM_MetadataRef_s this);
bool LLVM_isNullS5902rB(LLVM_DbgRecordRef_s this);
i32 LLVM_asI32Anyri32(Any u);
LLVM_TargetRef_s LLVMGetTargetFromName(char *name);
i32 LLVM_InitializeNativeAsmParser(none);
i32 LLVM_InitializeNativeAsmPrinter(none);
i32 LLVM_InitializeNativeDisassembler(none);
i32 LLVM_InitializeNativeTarget(none);
LLVM_TargetMachineRef_s LLVMCreateTargetMachine(LLVM_TargetRef_s T, char *Triple, char *CPU, char *Features, i32 Level, i32 Reloc, i32 CodeModel);
LLVM_TargetMachineRef_s LLVMCreateTargetMachineWithOptions(LLVM_TargetRef_s T, char *Triple, LLVM_TargetMachineOptionsRef_s Options);
i32 LLVMTargetMachineEmitToFile(LLVM_TargetMachineRef_s T, LLVM_ModuleRef_s M, char *path, i32 opts, LLVMString_s *err);
LLVM_TargetDataRef_s LLVMCreateTargetDataLayout(LLVM_TargetMachineRef_s T);
usize LLVMStoreSizeOfType(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
usize LLVMABISizeOfType(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
usize LLVMSizeOfTypeInBits(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
char *LLVMCopyStringRepOfTargetData(LLVM_TargetDataRef_s T);
LLVM_TargetMachineOptionsRef_s LLVMCreateTargetMachineOptions(none);
none LLVMDisposeTargetMachineOptions(LLVM_TargetMachineOptionsRef_s Options);
none LLVMTargetMachineOptionsSetCPU(LLVM_TargetMachineOptionsRef_s Options, char *CPU);
none LLVMTargetMachineOptionsSetFeatures(LLVM_TargetMachineOptionsRef_s Options, char *Features);
none LLVMTargetMachineOptionsSetABI(LLVM_TargetMachineOptionsRef_s Options, char *ABI);
none LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVM_TargetMachineOptionsRef_s Options, i32 Level);
none LLVMTargetMachineOptionsSetRelocMode(LLVM_TargetMachineOptionsRef_s Options, i32 Reloc);
none LLVMTargetMachineOptionsSetCodeModel(LLVM_TargetMachineOptionsRef_s Options, i32 CodeModel);
LLVM_ContextRef_s LLVMContextCreate(none);
none LLVMContextDispose(LLVM_ContextRef_s context);
LLVM_ModuleRef_s LLVMModuleCreateWithNameInContext(char *id, LLVM_ContextRef_s C);
LLVM_TypeRef_s LLVMIntTypeInContext(LLVM_ContextRef_s c, u32 bits);
LLVM_TypeRef_s LLVMFloatTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMDoubleTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMVoidTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMStructTypeInContext(LLVM_ContextRef_s c, LLVM_TypeRef_s *ElementTypes, u32 ElementCount, LLVMBool_s Packed);
LLVM_AttributeRef_s LLVMCreateEnumAttribute(LLVM_ContextRef_s c, u32 KindID, u64 Val);
char *LLVMPrintModuleToString(LLVM_ModuleRef_s M);
LLVMBool_s LLVMPrintModuleToFile(LLVM_ModuleRef_s M, char *Filename, LLVMString_s *ErrorMessage);
LLVM_ValueRef_s LLVMGetNamedFunction(LLVM_ModuleRef_s M, char *Name);
LLVM_ValueRef_s LLVMAddFunction(LLVM_ModuleRef_s M, char *name, LLVM_TypeRef_s FunctionTy);
LLVM_ValueRef_s LLVMAddGlobalInAddressSpace(LLVM_ModuleRef_s M, LLVM_TypeRef_s Ty, char *Name, u32 AddressSpace);
LLVM_ValueRef_s LLVMGetNamedGlobal(LLVM_ModuleRef_s M, char *Name);
LLVMBool_s LLVMVerifyModule(LLVM_ModuleRef_s M, i32 mode, LLVMString_s *code);
none LLVMSetDataLayout(LLVM_ModuleRef_s M, char *Data);
none LLVMSetTarget(LLVM_ModuleRef_s M, char *Target);
none LLVMAddModuleFlag(LLVM_ModuleRef_s M, i32 Behavior, char *Key, usize KeyLen, LLVM_MetadataRef_s Val);
LLVM_ErrorRef_s LLVMRunPasses(LLVM_ModuleRef_s M, char *Passes, LLVM_TargetMachineRef_s TM, LLVM_PassBuilderOptionsRef_s Options);
LLVM_ErrorRef_s LLVMRunPassesOnFunction(LLVM_ValueRef_s F, char *Passes, LLVM_TargetMachineRef_s TM, LLVM_PassBuilderOptionsRef_s Options);
LLVM_PassBuilderOptionsRef_s LLVMCreatePassBuilderOptions(none);
none LLVMDisposePassBuilderOptions(LLVM_PassBuilderOptionsRef_s Options);
none LLVMPassBuilderOptionsSetVerifyEach(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s VerifyEach);
none LLVMPassBuilderOptionsSetDebugLogging(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s DebugLogging);
none LLVMPassBuilderOptionsSetAAPipeline(LLVM_PassBuilderOptionsRef_s Options, char *AAPipeline);
none LLVMPassBuilderOptionsSetLoopInterleaving(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopInterleaving);
none LLVMPassBuilderOptionsSetLoopVectorization(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopVectorization);
none LLVMPassBuilderOptionsSetSLPVectorization(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s SLPVectorization);
none LLVMPassBuilderOptionsSetLoopUnrolling(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopUnrolling);
none LLVMPassBuilderOptionsSetForgetAllSCEVInLoopUnroll(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s ForgetAllSCEVInLoopUnroll);
none LLVMPassBuilderOptionsSetLicmMssaOptCap(LLVM_PassBuilderOptionsRef_s Options, u32 LicmMssaOptCap);
none LLVMPassBuilderOptionsSetLicmMssaNoAccForPromotionCap(LLVM_PassBuilderOptionsRef_s Options, u32 LicmMssaNoAccForPromotionCap);
none LLVMPassBuilderOptionsSetCallGraphProfile(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s CallGraphProfile);
none LLVMPassBuilderOptionsSetMergeFunctions(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s MergeFunctions);
none LLVMPassBuilderOptionsSetInlinerThreshold(LLVM_PassBuilderOptionsRef_s Options, i32 Threshold);
LLVM_BasicBlockRef_s LLVMAppendBasicBlockInContext(LLVM_ContextRef_s C, LLVM_ValueRef_s FnRef, char *name);
LLVM_BasicBlockRef_s LLVMGetInsertBlock(LLVM_BuilderRef_s Builder);
LLVM_ValueRef_s LLVMGetBasicBlockParent(LLVM_BasicBlockRef_s Block);
LLVM_BasicBlockRef_s LLVMGetFirstBasicBlock(LLVM_ValueRef_s Fn);
LLVM_ValueRef_s LLVMGetLastInstruction(LLVM_BasicBlockRef_s Block);
LLVM_BuilderRef_s LLVMCreateBuilderInContext(LLVM_ContextRef_s context);
LLVM_BuilderRef_s LLVMCreateBuilder(none);
none LLVMPositionBuilder(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderBeforeDbgRecords(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block, LLVM_ValueRef_s Inst);
none LLVMPositionBuilderBefore(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderAtEnd(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block);
LLVM_MetadataRef_s LLVMGetCurrentDebugLocation2(LLVM_BuilderRef_s Builder);
none LLVMSetCurrentDebugLocation2(LLVM_BuilderRef_s Builder, LLVM_MetadataRef_s loc);
none LLVMSetInstDebugLocation(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Inst);
LLVM_ValueRef_s LLVMBuildRetVoid(LLVM_BuilderRef_s B);
LLVM_ValueRef_s LLVMBuildRet(LLVM_BuilderRef_s B, LLVM_ValueRef_s Value);
LLVM_ValueRef_s LLVMBuildAlloca(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, char *Name);
LLVM_ValueRef_s LLVMBuildStore(LLVM_BuilderRef_s B, LLVM_ValueRef_s Value, LLVM_ValueRef_s Ptr);
LLVM_ValueRef_s LLVMBuildInsertValue(LLVM_BuilderRef_s B, LLVM_ValueRef_s AggVal, LLVM_ValueRef_s EltVal, u32 Index, char *Name);
LLVM_ValueRef_s LLVMBuildBr(LLVM_BuilderRef_s B, LLVM_BasicBlockRef_s Dest);
LLVM_ValueRef_s LLVMBuildCondBr(LLVM_BuilderRef_s B, LLVM_ValueRef_s If, LLVM_BasicBlockRef_s Then, LLVM_BasicBlockRef_s Else);
LLVM_ValueRef_s LLVMBuildLoad2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Ptr, char *name);
LLVM_ValueRef_s LLVMBuildAdd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSub(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildMul(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildUDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSRem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildURem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFAdd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFSub(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFMul(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFRem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildICmp(LLVM_BuilderRef_s B, i32 pred, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFCmp(LLVM_BuilderRef_s B, i32 pred, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildNot(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, char *name);
LLVM_ValueRef_s LLVMBuildOr(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildAnd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildXor(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildPtrToInt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Ptr, LLVM_TypeRef_s Int, char *name);
LLVM_ValueRef_s LLVMBuildIntToPtr(LLVM_BuilderRef_s B, LLVM_ValueRef_s Ptr, LLVM_TypeRef_s Int, char *name);
LLVM_ValueRef_s LLVMBuildSIToFP(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildUIToFP(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildFPToSI(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildFPToUI(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildCall2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Fn, LLVM_ValueRef_s *Args, u32 NumArgs, char *Name);
LLVM_ValueRef_s LLVMBuildGlobalStringPtr(LLVM_BuilderRef_s B, char *Str, char *Name);
LLVM_ValueRef_s LLVMBuildSExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildZExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildTrunc(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildStructGEP2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Pointer, u32 Idx, char *Name);
LLVM_ValueRef_s LLVMBuildGEP2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Pointer, LLVM_ValueRef_s *Indices, u32 Length, char *Name);
LLVM_ValueRef_s LLVMBuildFPExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildFPTrunc(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildUnreachable(LLVM_BuilderRef_s B);
LLVM_ValueRef_s LLVMBuildMemCpy(LLVM_BuilderRef_s B, LLVM_ValueRef_s Dst, u32 DstAlign, LLVM_ValueRef_s Src, u32 SrcAlign, LLVM_ValueRef_s Size);
LLVM_TypeRef_s LLVMTypeOf(LLVM_ValueRef_s Val);
LLVM_ValueRef_s LLVMConstInt(LLVM_TypeRef_s IntTy, usize N, LLVMBool_s SignExtend);
LLVM_ValueRef_s LLVMConstReal(LLVM_TypeRef_s RealTy, f64 F);
LLVM_ValueRef_s LLVMConstNull(LLVM_TypeRef_s Ty);
none LLVMDumpValue(LLVM_ValueRef_s V);
LLVM_TypeRef_s LLVMGlobalGetValueType(LLVM_ValueRef_s Val);
none LLVMAddAttributeAtIndex(LLVM_ValueRef_s Val, u32 index, LLVM_AttributeRef_s Attr);
none LLVMSetAlignment(LLVM_ValueRef_s Val, u32 Bytes);
none LLVMGlobalSetMetadata(LLVM_ValueRef_s Global, u32 Kind, LLVM_MetadataRef_s MD);
LLVM_ValueRef_s LLVMIsAGlobalVariable(LLVM_ValueRef_s Val);
none LLVMSetInitializer(LLVM_ValueRef_s GlobalVar, LLVM_ValueRef_s ConstantVal);
LLVM_ValueRef_s LLVMGetInitializer(LLVM_ValueRef_s GlobalVar);
LLVM_ValueRef_s LLVMGetParam(LLVM_ValueRef_s FnRef, u32 index);
none LLVMSetValueName2(LLVM_ValueRef_s Val, char *Name, usize NameLen);
none LLVMSetValueName(LLVM_ValueRef_s Val, char *Name);
char *LLVMGetValueName2(LLVM_ValueRef_s Val, usize *Length);
char *LLVMGetValueName(LLVM_ValueRef_s Val);
u32 LLVMGetEnumAttributeKindForName(char *Name, usize SLen);
LLVM_TypeRef_s LLVMFunctionType(LLVM_TypeRef_s ReturnType, LLVM_TypeRef_s *ParamTypes, u32 ParamCount, LLVMBool_s IsVarArg);
LLVM_TypeRef_s LLVMPointerType(LLVM_TypeRef_s ElementType, u32 AddressSpace);
LLVM_TypeRef_s LLVMArrayType(LLVM_TypeRef_s ElementType, u32 size);
none LLVMGetParamTypes(LLVM_TypeRef_s FunctionTy, LLVM_TypeRef_s *Dest);
u32 LLVMCountParamTypes(LLVM_TypeRef_s FunctionTy);
LLVM_TypeRef_s LLVMGetReturnType(LLVM_TypeRef_s FunctionTy);
char *LLVMPrintTypeToString(LLVM_TypeRef_s Ty);
LLVM_ValueRef_s LLVMGetInlineAsm(LLVM_TypeRef_s Ty, char *AsmString, usize AsmStringSize, char *Constraints, usize ConstraintsSize, LLVMBool_s HasSideEffects, LLVMBool_s IsAlignStack, u32 Dialect,
                                 LLVMBool_s CanThrow);
i32 LLVMGetTypeKind(LLVM_TypeRef_s Ty);
LLVM_DIBuilderRef_s LLVMCreateDIBuilder(LLVM_ModuleRef_s M);
none LLVMDisposeDIBuilder(LLVM_DIBuilderRef_s Builder);
none LLVMDIBuilderFinalize(LLVM_DIBuilderRef_s Builder);
LLVM_MetadataRef_s LLVMDIBuilderCreateCompileUnit(LLVM_DIBuilderRef_s Builder, i32 Lang, LLVM_MetadataRef_s FileRef, char *Producer, usize ProducerLen, LLVMBool_s isOptimized, char *Flags,
                                                  usize FlagsLen, u32 RuntimeVer, char *SplitName, usize SplitNameLen, i32 Kind, u32 DWOId, LLVMBool_s SplitDebugInlining,
                                                  LLVMBool_s DebugInfoForProfiling, char *SysRoot, usize SysRootLen, char *SDK, usize SDKLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateExpression(LLVM_DIBuilderRef_s Builder, usize *Addr, usize Length);
LLVM_MetadataRef_s LLVMDIBuilderCreateFile(LLVM_DIBuilderRef_s Builder, char *Filename, usize FilenameLen, char *Directory, usize DirectoryLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateFunction(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, char *LinkageName, usize LinkageNameLen, LLVM_MetadataRef_s File,
                                               u32 LineNo, LLVM_MetadataRef_s Ty, LLVMBool_s IsLocalToUnit, LLVMBool_s IsDefinition, u32 ScopeLine, i32 Flags, LLVMBool_s IsOptimized);
LLVM_MetadataRef_s LLVMDIBuilderCreateDebugLocation(LLVM_ContextRef_s Ctx, u32 Line, u32 Col, LLVM_MetadataRef_s Scope, LLVM_MetadataRef_s InlinedAt);
LLVM_MetadataRef_s LLVMDIBuilderCreateAutoVariable(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNo, LLVM_MetadataRef_s Ty,
                                                   LLVMBool_s AlwaysPreserve, i32 Flags, u32 AlignInBits);
LLVM_MetadataRef_s LLVMDIBuilderCreateBasicType(LLVM_DIBuilderRef_s Builder, char *Name, usize NameLen, u64 SizeInBits, u32 Encoding, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreateParameterVariable(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, u32 ArgNo, LLVM_MetadataRef_s File, u32 LineNo,
                                                        LLVM_MetadataRef_s Ty, LLVMBool_s AlwaysPreserve, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreatePointerType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s PointeeTy, u64 SizeInBits, u32 AlignInBits, u32 AddressSpace, char *Name, usize NameLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateStructType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                 u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s DerivedFrom, LLVM_MetadataRef_s *Elements, u32 NumElements, u32 RunTimeLang,
                                                 LLVM_MetadataRef_s VTableHolder, char *UniqueId, usize UniqueIdLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateVariantPart(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                  u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s Discriminator, LLVM_MetadataRef_s *Elements, u32 NumElements, char *Unique, usize UniqueLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateVariantMemberType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                        u32 AlignInBits, u64 OffsetInBits, LLVM_ValueRef_s Discriminant, i32 Flags, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateMemberType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                 u32 AlignInBits, u64 OffsetInBits, i32 Flags, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateSubroutineType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s File, LLVM_MetadataRef_s *ParameterTypes, u32 NumParameterTypes, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreateTypedef(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Type, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNo, LLVM_MetadataRef_s Scope,
                                              u32 AlignInBits);
LLVM_MetadataRef_s LLVMDIBuilderCreateUnionType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s *Elements, u32 NumElements, u32 RunTimeLang, char *UniqueId, usize UniqueLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateArrayType(LLVM_DIBuilderRef_s Builder, u64 Size, u32 AlignInBits, LLVM_MetadataRef_s Ty, LLVM_MetadataRef_s *Subscripts, u32 NumSubscripts);
LLVM_MetadataRef_s LLVMDIBuilderCreateArtificialType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateUnspecifiedType(LLVM_DIBuilderRef_s Builder, char *Name, usize NameLen);
LLVM_DbgRecordRef_s LLVMDIBuilderInsertDeclareRecordAtEnd(LLVM_DIBuilderRef_s Builder, LLVM_ValueRef_s Storage, LLVM_MetadataRef_s VarInfo, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s DebugLoc,
                                                          LLVM_BasicBlockRef_s Block);
LLVM_DbgRecordRef_s LLVMDIBuilderInsertDeclareRecordBefore(LLVM_DIBuilderRef_s Builder, LLVM_ValueRef_s Storage, LLVM_MetadataRef_s VarInfo, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s DebugLoc,
                                                           LLVM_ValueRef_s Instr);
LLVM_MetadataRef_s LLVMDIBuilderCreateGlobalVariableExpression(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, char *Linkage, usize LinkLen, LLVM_MetadataRef_s File,
                                                               u32 LineNo, LLVM_MetadataRef_s Ty, LLVMBool_s LocalToUnit, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s Decl, u32 AlignInBits);
none LLVMMetadataReplaceAllUsesWith(LLVM_MetadataRef_s TempTargetMetadata, LLVM_MetadataRef_s Replacement);
none LLVMSetSubprogram(LLVM_ValueRef_s Func, LLVM_MetadataRef_s SP);
LLVM_MetadataRef_s LLVMGetSubprogram(LLVM_ValueRef_s Func);
LLVM_MetadataRef_s LLVMTemporaryMDNode(LLVM_ContextRef_s Ctx, LLVM_MetadataRef_s *Data, usize NumElements);
none LLVMDisposeTemporaryMDNode(LLVM_MetadataRef_s TempNode);
LLVM_MetadataRef_s LLVMValueAsMetadata(LLVM_ValueRef_s Val);
u32 LLVMGetMDKindID(char *Name, u32 NameLen);
LLVMBool_s newLLVMBoolBrS2924(bool b);
bool equalsPS9925PS9925rB(InterpReg_s *this, InterpReg_s *other);
InterpReg_s asInterpPU9869PcrS9925(IRValue_u *this, char *err);
LLVM_ValueRef_s asLLVMPU9869PcrS1407(IRValue_u *this, char *err);
none pushPS1193U9869rN(IRValueList_s *this, IRValue_u element);
IRValue_u *atPS1193uszrPU9869(IRValueList_s *this, usize index);
LLVM_ValueRef_s getArgPS6859uszrS1407(ASMContext_s *context, usize index);
none pushPS6859PcrN(ASMContext_s *context, char *code);
none inPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint);
none outPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint);
String_s constrainPS6859U6852rS0540(ASMContext_s *context, ASMLoc_u loc);
none constrainPS6859U9995rN(ASMContext_s *context, ASMConstraint_u cons);
none constrainPS6859PcrN(ASMContext_s *context, char *code);
String_s collectPS6859rS0540(ASMContext_s *context);
char *tokenKindToStringuszrPc(usize kind);
none printPS6070rN(Token_s *this);
String_s getLocationPS6070rS0540(Token_s *this);
String_s toStringPS6070rS0540(Token_s *this);
SubStr_s getSubStrPS6070rS7720(Token_s *this);
Span_s getSpanPS6070rS8951(Token_s *this);
bool equalsPS6070PS6070rB(Token_s *this, Token_s *other);
Token_s dummyTokenuszrS6070(usize kind);
Token_s newTokenuszPS7720uszuszrS6070(usize fileID, SubStr_s *sub, usize start, usize kind);
Token_s newTokenEOFuszuszrS6070(usize fileID, usize start);
Token_s defaultTokenrS6070(none);
none push_entryPS3131U7843rN(TypeInfoTable_s *table, TypeInfo_u info);
usize index_ofPS3131PU7843rusz(TypeInfoTable_s *table, TypeInfo_u *info);
bool containsPS3131PU7843rB(TypeInfoTable_s *table, TypeInfo_u *info);
none pushPS2495uszrN(TypeInfoList_s *this, usize element);
none pushPS0131S3911rN(FieldTypeInfoList_s *this, FieldTypeInfo_s element);
none pushPS3117U0081rN(UnionVariantTypeInfoList_s *this, UnionVariantTypeInfo_u element);
SubStr_s get_namePU0081rS7720(UnionVariantTypeInfo_u *info);
bool equalsPU7843PU7843rB(TypeInfo_u *ti1, TypeInfo_u *ti2);
usize get_sizePU7843rusz(TypeInfo_u *info);
usize get_alignPU7843rusz(TypeInfo_u *info);
SubStr_s get_namePU7843rS7720(TypeInfo_u *info);
none pushPS3111AnyuszrN(ArenaBlock_s *this, Any elem, usize newCap);
Any atPS3111uszrAny(ArenaBlock_s *this, usize index);
Any lastPS3111rAny(ArenaBlock_s *this);
usize indexOfPS3111Anyrusz(ArenaBlock_s *this, Any elem);
ArenaBlock_s *allocateBlockuszuszrPS3111(usize cap, usize size);
none pushPS9153S0890rN(ParsedConfigArena_s *this, ParsedConfig_s elem);
ParsedConfig_s *atPS9153uszrPS0890(ParsedConfigArena_s *this, usize index);
ParsedConfig_s *lastPS9153rPS0890(ParsedConfigArena_s *this);
usize indexOfPS9153PS0890rusz(ParsedConfigArena_s *this, ParsedConfig_s *elem);
none pushPS9483S1892rN(ParsedFileArena_s *this, ParsedFile_s elem);
ParsedFile_s *atPS9483uszrPS1892(ParsedFileArena_s *this, usize index);
ParsedFile_s *lastPS9483rPS1892(ParsedFileArena_s *this);
usize indexOfPS9483PS1892rusz(ParsedFileArena_s *this, ParsedFile_s *elem);
none pushPS9029S1038rN(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s elem);
ParsedTopLevelItem_s *atPS9029uszrPS1038(ParsedTopLevelItemArena_s *this, usize index);
ParsedTopLevelItem_s *lastPS9029rPS1038(ParsedTopLevelItemArena_s *this);
usize indexOfPS9029PS1038rusz(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s *elem);
none pushPS7393S1882rN(ParsedModuleArena_s *this, ParsedModule_s elem);
ParsedModule_s *atPS7393uszrPS1882(ParsedModuleArena_s *this, usize index);
ParsedModule_s *lastPS7393rPS1882(ParsedModuleArena_s *this);
usize indexOfPS7393PS1882rusz(ParsedModuleArena_s *this, ParsedModule_s *elem);
none pushPS2168S5521rN(ParsedStructDeclArena_s *this, ParsedStructDecl_s elem);
ParsedStructDecl_s *atPS2168uszrPS5521(ParsedStructDeclArena_s *this, usize index);
ParsedStructDecl_s *lastPS2168rPS5521(ParsedStructDeclArena_s *this);
usize indexOfPS2168PS5521rusz(ParsedStructDeclArena_s *this, ParsedStructDecl_s *elem);
none pushPS4268S0997rN(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s elem);
ParsedUnionDecl_s *atPS4268uszrPS0997(ParsedUnionDeclArena_s *this, usize index);
ParsedUnionDecl_s *lastPS4268rPS0997(ParsedUnionDeclArena_s *this);
usize indexOfPS4268PS0997rusz(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s *elem);
none pushPS4249S3506rN(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s elem);
ParsedUnionVariant_s *atPS4249uszrPS3506(ParsedUnionVariantArena_s *this, usize index);
ParsedUnionVariant_s *lastPS4249rPS3506(ParsedUnionVariantArena_s *this);
usize indexOfPS4249PS3506rusz(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s *elem);
none pushPS4111S4904rN(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s elem);
ParsedFuncDecl_s *atPS4111uszrPS4904(ParsedFuncDeclArena_s *this, usize index);
ParsedFuncDecl_s *lastPS4111rPS4904(ParsedFuncDeclArena_s *this);
usize indexOfPS4111PS4904rusz(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s *elem);
none pushPS8646S7247rN(ParsedBlockArena_s *this, ParsedBlock_s elem);
ParsedBlock_s *atPS8646uszrPS7247(ParsedBlockArena_s *this, usize index);
ParsedBlock_s *lastPS8646rPS7247(ParsedBlockArena_s *this);
usize indexOfPS8646PS7247rusz(ParsedBlockArena_s *this, ParsedBlock_s *elem);
none pushPS8227S1100rN(ParsedStmtArena_s *this, ParsedStmt_s elem);
ParsedStmt_s *atPS8227uszrPS1100(ParsedStmtArena_s *this, usize index);
ParsedStmt_s *lastPS8227rPS1100(ParsedStmtArena_s *this);
usize indexOfPS8227PS1100rusz(ParsedStmtArena_s *this, ParsedStmt_s *elem);
none pushPS7882S2435rN(ParsedExprArena_s *this, ParsedExpr_s elem);
ParsedExpr_s *atPS7882uszrPS2435(ParsedExprArena_s *this, usize index);
ParsedExpr_s *lastPS7882rPS2435(ParsedExprArena_s *this);
usize indexOfPS7882PS2435rusz(ParsedExprArena_s *this, ParsedExpr_s *elem);
none pushPS4419S1372rN(ParsedTypeNodeArena_s *this, ParsedTypeNode_s elem);
ParsedTypeNode_s *atPS4419uszrPS1372(ParsedTypeNodeArena_s *this, usize index);
ParsedTypeNode_s *lastPS4419rPS1372(ParsedTypeNodeArena_s *this);
usize indexOfPS4419PS1372rusz(ParsedTypeNodeArena_s *this, ParsedTypeNode_s *elem);
none pushPS4174U5175rN(TypeArena_s *this, Type_u elem);
Type_u *atPS4174uszrPU5175(TypeArena_s *this, usize index);
Type_u *lastPS4174rPU5175(TypeArena_s *this);
usize indexOfPS4174PU5175rusz(TypeArena_s *this, Type_u *elem);
none pushPS8168S3633rN(DLLArena_s *this, DLL_s elem);
DLL_s *atPS8168uszrPS3633(DLLArena_s *this, usize index);
DLL_s *lastPS8168rPS3633(DLLArena_s *this);
usize indexOfPS8168PS3633rusz(DLLArena_s *this, DLL_s *elem);
none pushPS8361S1826rN(ParsedPatternArena_s *this, ParsedPattern_s elem);
ParsedPattern_s *atPS8361uszrPS1826(ParsedPatternArena_s *this, usize index);
ParsedPattern_s *lastPS8361rPS1826(ParsedPatternArena_s *this);
usize indexOfPS8361PS1826rusz(ParsedPatternArena_s *this, ParsedPattern_s *elem);
none pushPS7368S5777rN(LLVMMetadataArena_s *this, LLVMMetadata_s elem);
LLVMMetadata_s *atPS7368uszrPS5777(LLVMMetadataArena_s *this, usize index);
LLVMMetadata_s *lastPS7368rPS5777(LLVMMetadataArena_s *this);
usize indexOfPS7368PS5777rusz(LLVMMetadataArena_s *this, LLVMMetadata_s *elem);
SubStr_s BUILD_A_KEYWORDPcrS7720(char *s);
bool isKeywordPS3493PS7720rB(Lexer_s *this, SubStr_s *word);
char escapeCharSequencePS3493PS7720PS0540Puszrc(Lexer_s *this, SubStr_s *tmp, String_s *s, usize *len);
bool advancePS3493rB(Lexer_s *this);
Token_s peekPS3493rS6070(Lexer_s *this);
Token_s nextPS3493rS6070(Lexer_s *this);
Token_s __nextPS3493BrS6070(Lexer_s *this, bool peek);
Lexer_s newLexeruszS7720rS3493(usize fileID, SubStr_s content);
IRFuncList_s asListPS2612rS8040(String_IRFuncHashMap_s *this);
bool needsResizePS2612rB(String_IRFuncHashMap_s *this);
usize indexOfPS2612PS0540rusz(String_IRFuncHashMap_s *this, String_s *key);
IRFunc_s *atPS2612uszrPS7132(String_IRFuncHashMap_s *this, usize index);
none resizeIfNecessaryPS2612rN(String_IRFuncHashMap_s *this);
none addPS2612S0540S7132rN(String_IRFuncHashMap_s *this, String_s key, IRFunc_s value);
IRFunc_s *getPS2612PS0540rPS7132(String_IRFuncHashMap_s *this, String_s *key);
String_IRFuncEntry_s *getEntryPS2612PS0540rPS0516(String_IRFuncHashMap_s *this, String_s *key);
String_IRFuncEntry_s *getAtIndexPS2612uszrPS0516(String_IRFuncHashMap_s *this, usize index);
bool containsKeyPS2612PS0540rB(String_IRFuncHashMap_s *this, String_s *key);
none freeS1803rN(Function_s fn);
none pushPS5123ccccccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8);
none pushPS5123ccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4);
none pushPS5123cccrN(ByteBuffer_s *buf, char b1, char b2, char b3);
none pushPS5123ccrN(ByteBuffer_s *buf, char b1, char b2);
none pushPS5123crN(ByteBuffer_s *buf, char b1);
none pushPS5123u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2);
none pushPS5123u8u8u8u8u8u8u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2, u8 b3, u8 b4, u8 b5, u8 b6, u8 b7, u8 b8);
none pushPS5123u8rN(ByteBuffer_s *buf, u8 element);
none extendPS5123PS5123rN(ByteBuffer_s *buf, ByteBuffer_s *other);
none pushImmPS5123S8630rN(ByteBuffer_s *bytes, ImmI32_s imm);
none pushImmPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm);
none modRMPS5123u8u8S7038rN(ByteBuffer_s *bytes, u8 addr, u8 opext, GPR_s reg);
none modPrefixPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r);
none movPS5123S7038S7038rN(ByteBuffer_s *bytes, GPR_s to, GPR_s from);
none movPS5123S5949S5363rN(ByteBuffer_s *bytes, FPR_s r, ImmF32_s imm);
none movPS5123S5949S5464rN(ByteBuffer_s *bytes, FPR_s r, ImmF64_s imm);
none movPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none movPS5123S7038S8731rN(ByteBuffer_s *bytes, GPR_s r, ImmI64_s imm);
none pushPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg);
none popPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg);
none movPS5123S7038u32S8731rN(ByteBuffer_s *bytes, GPR_s r, u32 offset, ImmI64_s imm);
none addPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none subPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none callPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r);
none pushPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm);
none pushPS2247S6579rN(CallStack_s *this, CallStackInfo_s element);
CallStackInfo_s *atPS2247uszrPS6579(CallStack_s *this, usize index);
CallStackInfo_s *popPS2247rPS6579(CallStack_s *this);
CallStackInfo_s *lastPS2247rPS6579(CallStack_s *this);
none dumpRegisterStackPS3154uszrN(IRInterp_s *this, usize bytes);
u8 *getGlobalPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg);
u8 *getRegStackPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg);
u8 *advanceRealStackPS3154S8951uszrPu8(IRInterp_s *this, Span_s span, usize size);
none pushArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size);
none popArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size);
InterpReg_s evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateAllocaPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetParamPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateStorePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateMovePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCondBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseXorPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateSinglePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
bool evaluateBlockPS3154PS7192PS7132PS5884BrB(IRInterp_s *this, IRBlockID_s *blockID, IRFunc_s *irFunc, RegValueList_s *regs, bool forcedComptime);
Function_s compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803(IRInterp_s *this, IRFunc_s *currFunc, IRFunc_s *calledFunc, IRInstr_s *instr, usize fn, RegValueList_s *regs);
none evaluateCallPS3154S8951PS7132PS5884rN(IRInterp_s *this, Span_s span, IRFunc_s *irFunc, RegValueList_s *regs);
none pushRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size);
none popRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size);
none pushCallStackPS3154S8951S0540rN(IRInterp_s *this, Span_s span, String_s name);
none popCallStackPS3154rN(IRInterp_s *this);
none dumpCallStackPS3154PS0540rN(IRInterp_s *this, String_s *loc);
IRInterp_s newIRInterpreterPS9562rS3154(IRGen_s *irGen);
bool equalsPS7469PS7469rB(LLVMBasicBlock_s *this, LLVMBasicBlock_s *other);
none guardReferencePS7469rN(LLVMBasicBlock_s *this);
LLVMValue_s getParentPS7469rS8925(LLVMBasicBlock_s *this);
bool getLastInstructionPS7469PS8925rB(LLVMBasicBlock_s *this, LLVMValue_s *out);
LLVMBasicBlock_s newLLVMBasicBlockFromRefS6239rS7469(LLVM_BasicBlockRef_s ref);
LLVMAttribute_s newLLVMAttributeFromRefS8710rS6660(LLVM_AttributeRef_s ref);
bool equalsPS8925PS8925rB(LLVMValue_s *this, LLVMValue_s *other);
none guardReferencePS8925rN(LLVMValue_s *this);
bool isStructValuePS8925rB(LLVMValue_s *this);
none dumpPS8925rN(LLVMValue_s *this);
LLVMType_s getGlobalTypePS8925rS0706(LLVMValue_s *this);
LLVMValue_s getNthParamPS8925uszrS8925(LLVMValue_s *this, usize index);
LLVMBasicBlock_s getFirstBasicBlockPS8925rS7469(LLVMValue_s *this);
LLVMType_s getTypePS8925rS0706(LLVMValue_s *this);
none setNamePS8925S7720rN(LLVMValue_s *this, SubStr_s name);
SubStr_s getNamePS8925rS7720(LLVMValue_s *this);
none setInitializerPS8925S8925rN(LLVMValue_s *this, LLVMValue_s val);
LLVMValue_s getInitializerPS8925rS8925(LLVMValue_s *this);
none addAttributePS8925u32S6660rN(LLVMValue_s *this, u32 index, LLVMAttribute_s attr);
LLVMValue_s newLLVMValueFromRefS1407rS8925(LLVM_ValueRef_s ref);
bool equalsPS0706PS0706rB(LLVMType_s *this, LLVMType_s *other);
bool isFunctionPS0706rB(LLVMType_s *this);
LLVMType_s getReturnTypePS0706rS0706(LLVMType_s *this);
bool isVoidPS0706rB(LLVMType_s *this);
bool isStructPS0706rB(LLVMType_s *this);
bool isPointerPS0706rB(LLVMType_s *this);
char *toCharsPS0706rPc(LLVMType_s *this);
LLVMType_s intoFunctionTypePS0706S4318BrS0706(LLVMType_s *this, LLVMTypeList_s params, bool varArg);
LLVMType_s intoPointerTypePS0706rS0706(LLVMType_s *this);
LLVMType_s intoArrayTypePS0706u32rS0706(LLVMType_s *this, u32 size);
LLVMValue_s constIntPS0706uszBrS8925(LLVMType_s *this, usize value, bool signExtend);
LLVMValue_s constZeroPS0706rS8925(LLVMType_s *this);
LLVMValue_s constFloatPS0706f64rS8925(LLVMType_s *this, f64 value);
LLVMValue_s getInlineAsmPS0706PS6859rS8925(LLVMType_s *this, ASMContext_s *context);
LLVMType_s newLLVMTypeFromRefS6708rS0706(LLVM_TypeRef_s ref);
LLVMPassBuilderOptions_s createPassBuilderOptionsrS4890(none);
none disposePassBuilderOptionsS4890rN(LLVMPassBuilderOptions_s opt);
none setVerifyEachS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s verify);
none setDebugLoggingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s debug);
none setAAPipelineS4890PcrN(LLVMPassBuilderOptions_s opt, char *pipeline);
none setLoopInterleavingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s interleave);
none setLoopVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize);
none setSLPVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize);
none setLoopUnrollingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s unroll);
none setForgetAllSCEVInLoopUnrollS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s forget);
none setLicmMssaOptCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap);
none setLicmMssaNoAccForPromotionCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap);
none setCallGraphProfileS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s profile);
none setMergeFunctionsS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s merge);
none setInlinerThresholdS4890i32rN(LLVMPassBuilderOptions_s opt, i32 threshold);
usize getBitSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
usize getABISizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
usize getStoreSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
LLVMDataLayout_s getDataLayoutPS8369rS7896(LLVMTargetData_s *this);
LLVMTargetData_s newLLVMTargetDataFromRefS6307rS8369(LLVM_TargetDataRef_s ref);
LLVMTargetMachine_s createTargetMachinePS4231PcPcPcrS7964(LLVMTarget_s *this, char *triple, char *cpu, char *features);
LLVMTargetMachine_s createTargetMachineWithOptionsS4231PcS6312rS7964(LLVMTarget_s this, char *triple, LLVMTargetMachineOptions_s options);
LLVMTarget_s newLLVMTargetFromRefS3497rS4231(LLVM_TargetRef_s ref);
none writeToFilePS7964S1718i32PcrN(LLVMTargetMachine_s *this, LLVMModule_s mod, i32 mode, char *filepath);
LLVMTargetData_s getTargetDataPS7964rS8369(LLVMTargetMachine_s *this);
LLVMTargetMachine_s newLLVMTargetMachineFromRefS5038rS7964(LLVM_TargetMachineRef_s ref);
LLVMTargetMachineOptions_s createTargetMachineOptionsrS6312(none);
none disposeTargetMachineOptionsS6312rN(LLVMTargetMachineOptions_s opt);
none setCPUS6312PcrN(LLVMTargetMachineOptions_s opt, char *cpu);
none setFeaturesS6312PcrN(LLVMTargetMachineOptions_s opt, char *features);
none setABIS6312PcrN(LLVMTargetMachineOptions_s opt, char *ABI);
none setCodeGenOptLevelS6312U5589rN(LLVMTargetMachineOptions_s opt, LLVM_CodeGenOptLevel_u level);
none setRelocModeS6312U2415rN(LLVMTargetMachineOptions_s opt, LLVM_RelocMode_u reloc);
none setCodeModelS6312U0545rN(LLVMTargetMachineOptions_s opt, LLVM_CodeModel_u model);
none printPS1718rN(LLVMModule_s *this);
none setTriplePS1718PcrN(LLVMModule_s *this, char *triple);
none setDataLayoutPS1718S7896rN(LLVMModule_s *this, LLVMDataLayout_s layout);
bool writeToFilePS1718S7720rB(LLVMModule_s *this, SubStr_s path);
bool verifyPS1718rB(LLVMModule_s *this);
LLVMValue_s addFunctionPS1718S7720S0706rS8925(LLVMModule_s *this, SubStr_s name, LLVMType_s function);
bool hasFunctionPS1718S7720rB(LLVMModule_s *this, SubStr_s name);
LLVMValue_s getFunctionPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name);
LLVMValue_s addGlobalPS1718S0706u32S7720rS8925(LLVMModule_s *this, LLVMType_s typ, u32 space, SubStr_s name);
LLVMValue_s getGlobalPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name);
bool runPassesS1718PcS7964S4890rB(LLVMModule_s this, char *passes, LLVMTargetMachine_s target, LLVMPassBuilderOptions_s options);
none addModuleFlagS1718i32S7720S8925rN(LLVMModule_s this, i32 behavior, SubStr_s flag, LLVMValue_s value);
LLVMModule_s newLLVMModuleFromRefS3816rS1718(LLVM_ModuleRef_s ref);
none guardReferencePS6343rN(LLVMBuilder_s *this);
none positionAtEndPS6343S7469rN(LLVMBuilder_s *this, LLVMBasicBlock_s block);
none positionBeforePS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s instr);
LLVMBasicBlock_s getInsertBlockPS6343rS7469(LLVMBuilder_s *this);
LLVMValue_s buildInsertValuePS6343S8925S8925u32PcrS8925(LLVMBuilder_s *this, LLVMValue_s aggregate, LLVMValue_s element, u32 offset, char *name);
LLVMValue_s buildAllocaPS6343S0706S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildStorePS6343S8925S8925rS8925(LLVMBuilder_s *this, LLVMValue_s ptr, LLVMValue_s value);
LLVMValue_s buildLoadPS6343S0706S8925S7720rS8925(LLVMBuilder_s *this, LLVMType_s pType, LLVMValue_s ptr, SubStr_s name);
none buildReturnPS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s value);
none buildReturnVoidPS6343rN(LLVMBuilder_s *this);
LLVMValue_s buildBrPS6343S7469rS8925(LLVMBuilder_s *this, LLVMBasicBlock_s dest);
LLVMValue_s buildCondBrPS6343S8925S7469S7469rS8925(LLVMBuilder_s *this, LLVMValue_s cond, LLVMBasicBlock_s tru, LLVMBasicBlock_s fals);
LLVMValue_s buildIntAddPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntSubPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntMulPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntDivPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntModPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildFloatAddPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatSubPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatMulPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatDivPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatModPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildIntComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildNotPS6343S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, SubStr_s name);
LLVMValue_s buildOrPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildAndPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildXorPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildPtrToIntPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntToPtrPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntToFloatPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name);
LLVMValue_s buildFloatToIntPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name);
LLVMValue_s buildIntSignExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntZeroExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildFloatExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildFloatTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildCallPS6343S8925S0706S8201S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s fn, LLVMType_s fnType, LLVMValueList_s args, LLVMType_s retType, SubStr_s name);
LLVMValue_s buildGlobalStringPtrPS6343PcS7720rS8925(LLVMBuilder_s *this, char *start, SubStr_s name);
LLVMValue_s buildStructGEPPS6343S0706S8925uszS7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, usize index, SubStr_s name);
LLVMValue_s buildGEPPS6343S0706S8925S8201S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, LLVMValueList_s indices, SubStr_s name);
none buildUnreachablePS6343rN(LLVMBuilder_s *this);
LLVMValue_s buildMemcpyPS6343S8925u32S8925u32S8925rS8925(LLVMBuilder_s *this, LLVMValue_s dst, u32 dstAlign, LLVMValue_s src, u32 srcAlign, LLVMValue_s size);
LLVMBuilder_s newLLVMBuilderFromRefS3273rS6343(LLVM_BuilderRef_s ref);
none dropPS0773rN(LLVMContext_s *this);
none guardReferencePS0773rN(LLVMContext_s *this);
none initializeTargetsPS0773rN(LLVMContext_s *this);
LLVMTarget_s createTargetPS0773PcrS4231(LLVMContext_s *this, char *name);
char *createTargetTriplePS0773PcrPc(LLVMContext_s *this, char *name);
LLVMModule_s createModuleWithNamePS0773S7720rS1718(LLVMContext_s *this, SubStr_s name);
LLVMBuilder_s createBuilderPS0773rS6343(LLVMContext_s *this);
LLVMType_s createIntegerTypePS0773i64rS0706(LLVMContext_s *this, i64 bitsize);
LLVMType_s createFloatTypePS0773rS0706(LLVMContext_s *this);
LLVMType_s createDoubleTypePS0773rS0706(LLVMContext_s *this);
LLVMType_s createStructTypePS0773PS0706u32BrS0706(LLVMContext_s *this, LLVMType_s *elements, u32 count, bool packed);
LLVMType_s createVoidTypePS0773rS0706(LLVMContext_s *this);
LLVMBasicBlock_s appendBasicBlockPS0773S8925S7720rS7469(LLVMContext_s *this, LLVMValue_s fn, SubStr_s name);
LLVMAttribute_s createEnumAttributePS0773u32u64rS6660(LLVMContext_s *this, u32 id, u64 val);
LLVMContext_s newLLVMContextrS0773(none);
LLVMDIBuilder_s createDIBuilderS1718rS1476(LLVMModule_s mod);
none disposeDIBuilderS1476rN(LLVMDIBuilder_s builder);
none finalizeDIBuilderS1476rN(LLVMDIBuilder_s builder);
LLVMMetadata_s createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777(LLVMDIBuilder_s builder, i32 lang, LLVMMetadata_s file, SubStr_s producer, LLVMBool_s isOptimized,
                                                                                                     SubStr_s flags, u32 runtimeVer, SubStr_s splitName, i32 kind, u32 dwoid,
                                                                                                     LLVMBool_s splitDebugInlining, LLVMBool_s debugInfoForProfiling, SubStr_s sysRoot, SubStr_s sdk);
LLVMMetadata_s createFileS1476PcuszPcuszrS5777(LLVMDIBuilder_s builder, char *filename, usize fileLen, char *dir, usize dirLen);
LLVMMetadata_s createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, SubStr_s linkage, LLVMMetadata_s file, u32 line,
                                                                                          LLVMMetadata_s type, LLVMBool_s localToUnit, LLVMBool_s isDefinition, u32 scopeLine, i32 flags,
                                                                                          LLVMBool_s isOptimized);
LLVMMetadata_s createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, u32 arg, LLVMMetadata_s file, u32 line,
                                                                                    LLVMMetadata_s ty, LLVMBool_s alwaysPreserve, i32 flags);
LLVMMetadata_s createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, LLVMMetadata_s file, u32 line, LLVMMetadata_s ty,
                                                                               LLVMBool_s alwaysPreserve, i32 flags, u32 align);
u32 getEncodingU7375ru32(PrimType_u p);
SubStr_s getFullNameU7375rS7720(PrimType_u p);
LLVMMetadata_s createSubroutineTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
LLVMMetadata_s createDebugInfoForPrimitiveTypeS1476PU5175rS5777(LLVMDIBuilder_s builder, Type_u *type);
LLVMMetadata_s createDebugInfoForStructTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
LLVMMetadata_s createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, LLVMContext_s llvmContext);
LLVMMetadata_s createTagTypeS1476S5777PU5175uszrS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, usize line);
LLVMMetadata_s createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, usize line, i32 flags);
LLVMMetadata_s createTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
none setSubprogramS8925S5777rN(LLVMValue_s fn, LLVMMetadata_s sp);
LLVMMetadata_s getSubprogramS8925rS5777(LLVMValue_s fn);
LLVMMetadata_s createExpressionS1476PuszuszrS5777(LLVMDIBuilder_s diBuilder, usize *addr, usize length);
LLVMMetadata_s createDebugLocationS0773u32u32S5777rS5777(LLVMContext_s ctx, u32 line, u32 col, LLVMMetadata_s scope);
none setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder, LLVMContext_s ctx, LLVMValue_s fn, IRFunc_s *irFunc, Span_s span);
none resetCurrentDebugLocationS1476S6343rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder);
LLVMDbgRecord_s insertDeclareRecordBeforeS1476S8925S5777S5777S5777S8925rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                              LLVMValue_s instr);
LLVMDbgRecord_s insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                             LLVMBasicBlock_s block);
bool equalsPU5952PU5952rB(RegValue_u *this, RegValue_u *other);
none addInterpValuePU5952S9925rN(RegValue_u *this, InterpReg_s val);
none addLLVMValuePU5952S8925rN(RegValue_u *this, LLVMValue_s val);
InterpReg_s asInterpPU5952PcrS9925(RegValue_u *this, char *err);
LLVMValue_s asLLVMPU5952PcrS8925(RegValue_u *this, char *err);
bool isLLVMPU5952rB(RegValue_u *this);
bool isInterpPU5952rB(RegValue_u *this);
bool generateDebugInfoPS4053i32PPcrB(LLVMCodegen_s *this, i32 argc, char **argv);
bool generateExecutablePS4053S7720i32PPcrB(LLVMCodegen_s *this, SubStr_s outPath, i32 argc, char **argv);
bool generateRuntimeInitializationPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *initRuntime);
bool generateEntryPointPS4053rB(LLVMCodegen_s *this);
bool generateGlobalPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *global);
none generateLLVMFunctionHeaderPS4053PS7132rN(LLVMCodegen_s *this, IRFunc_s *irFunc);
LLVMType_s prepareReturnTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
LLVMType_s prepareParameterPS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
usize getLLVMTypeSizePS4053PS0706rusz(LLVMCodegen_s *this, LLVMType_s *typ);
bool _generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc);
bool generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc);
none generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *llvmBlocks, IRBlock_s *block, RegValueList_s *regs);
LLVMValue_s generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *blocks, IRInstr_s *instr,
                                                                        RegValueList_s *regs);
LLVMValueList_s collectValuesFromASMPS4053PS6859rS8201(LLVMCodegen_s *this, ASMContext_s *context);
LLVMType_s generateTypeFromASMPS4053PS6859rS0706(LLVMCodegen_s *this, ASMContext_s *context);
u8 *getComptimePointerPS4053PS9925rPu8(LLVMCodegen_s *this, InterpReg_s *reg);
LLVMValue_s generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925(LLVMCodegen_s *this, Type_u *typ, InterpReg_s reg);
LLVMValue_s generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925(LLVMCodegen_s *this, Type_u *typ, u8 *start);
LLVMType_s generateLLVMFunctionTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
LLVMType_s generateLLVMTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *type);
LLVMCodegen_s newLLVMCodegenS7720PS9562PS3154rS4053(SubStr_s name, IRGen_s *irGen, IRInterp_s *interp);
bool equalsPS6939PS6939rB(RegIndex_s *this, RegIndex_s *other);
bool equalsPS1534PS1534rB(IRReg_s *this, IRReg_s *other);
bool equalsPS7680PS7680rB(IRInstr_s *this, IRInstr_s *other);
bool isTerminatorPS7680rB(IRInstr_s *this);
none dumpPS7680rN(IRInstr_s *this);
bool equalsPS0666PS0666rB(LoopBlock_s *this, LoopBlock_s *other);
bool equalsPS9435PS9435rB(IRBlock_s *this, IRBlock_s *other);
bool isTerminatedPS9435rB(IRBlock_s *this);
none dumpPS9435rN(IRBlock_s *this);
none pushInstructionPS9435S7680rN(IRBlock_s *this, IRInstr_s instr);
none insertInstructionPS9435uszS7680rN(IRBlock_s *this, usize index, IRInstr_s instr);
bool hasAttributePS7132U4360rB(IRFunc_s *this, ParsedAttribute_u attr);
bool isExternPS7132rB(IRFunc_s *this);
IRBlockID_s appendBlockPS7132rS7192(IRFunc_s *this);
none setCurrentBlockPS7132S7192rN(IRFunc_s *this, IRBlockID_s id);
IRBlockID_s getCurrentBlockPS7132rS7192(IRFunc_s *this);
IRBlock_s *getCurrentBlockAsRefPS7132rPS9435(IRFunc_s *this);
IRBlock_s *getBlockByIDPS7132S7192rPS9435(IRFunc_s *this, IRBlockID_s id);
none pushLoopBlocksPS7132S7192S7192rN(IRFunc_s *this, IRBlockID_s before, IRBlockID_s after);
none popLoopBlocksPS7132rN(IRFunc_s *this);
ParsedFuncDecl_s *getFuncNodePS7132rPS4904(IRFunc_s *this);
none dumpInstructionsPS7132rN(IRFunc_s *this);
bool equalsPS7132PS7132rB(IRFunc_s *this, IRFunc_s *other);
usize enterScopePS7132rusz(IRFunc_s *this);
usize leaveScopePS7132rusz(IRFunc_s *this);
none startComptimePS7132rN(IRFunc_s *this);
none endComptimePS7132rN(IRFunc_s *this);
usize getRegisterSizeInBytesPS7132rusz(IRFunc_s *this);
RegIndex_s allocateRegisterPS7132PU5175rS6939(IRFunc_s *this, Type_u *typ);
IRReg_s *getRegisterPS7132S6939rPS1534(IRFunc_s *this, RegIndex_s index);
IRScopeEntry_s *getIdentifierByNamePS7132S7720rPS9676(IRFunc_s *this, SubStr_s name);
none pushInstructionPS7132S7680rN(IRFunc_s *this, IRInstr_s instr);
none buildDebugInfoParamPS7132S8951S6939uszS7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, SubStr_s name);
none buildDebugInfoAllocaPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s name);
none buildAllocaPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size);
none buildFetchGlobalPointerPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchLocalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildLoadFunctionPtrPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize funcID);
none buildLoadPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildMovePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildGetParamPS7132S8951S6939uszuszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, usize size);
none buildStorePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildCallPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s funcID, RegIndexList_s args);
none buildReturnExprPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s val);
none buildReturnEmptyPS7132S8951rN(IRFunc_s *this, Span_s span);
none buildLoadStringPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s str);
none buildLoadBoolPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize val);
none buildLoadIntegerPS7132S8951S6939PU5175uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, Type_u *t, usize val);
none buildLoadNullPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildLoadF32PS7132S8951S6939f32rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f32 val);
none buildLoadF64PS7132S8951S6939f64rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f64 val);
none buildLoadBlankPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size);
none buildLogicalNotPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildBinaryOpPS7132S8951uszS6939S6939S6939rN(IRFunc_s *this, Span_s span, usize kind, RegIndex_s dst, RegIndex_s lhs, RegIndex_s rhs);
none buildInsertValuePS7132S8951S6939uszS6939rN(IRFunc_s *this, Span_s span, RegIndex_s aggr, usize index, RegIndex_s val);
none buildUnreachablePS7132S8951rN(IRFunc_s *this, Span_s span);
none buildUnterminatedPS7132S8951rN(IRFunc_s *this, Span_s span);
none buildBrPS7132S8951S7192rN(IRFunc_s *this, Span_s span, IRBlockID_s block);
none buildCondBrPS7132S8951S6939S7192S7192rN(IRFunc_s *this, Span_s span, RegIndex_s cond, IRBlockID_s drue, IRBlockID_s falze);
bool buildBreakPS7132S8951rB(IRFunc_s *this, Span_s span);
bool buildContinuePS7132S8951rB(IRFunc_s *this, Span_s span);
none buildIntSignExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildIntZeroExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildIntTruncatePS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildF32ToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF64ToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF32ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF64ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildCreateArrayPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildCreateStructPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildCreateUnionPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildPtrToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToPtrPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildGetFieldPtrPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, usize index);
none buildGetElementPtrPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, RegIndexList_s indices);
none buildMemcpyPS7132S8951S6939S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s src, RegIndex_s dst, RegIndex_s size);
none buildEmitAssemblyPS7132S8951S6939PU5175rN(IRFunc_s *this, Span_s span, RegIndex_s context, Type_u *fnType);
none buildIntoIRValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
bool equalsPS9676PS9676rB(IRScopeEntry_s *this, IRScopeEntry_s *other);
bool equalsPS7082PS7082rB(IRScope_s *this, IRScope_s *other);
none addEntryPS7082S7720S6939BrN(IRScope_s *this, SubStr_s name, RegIndex_s ptr, bool isComptime);
IRScopeEntry_s *getIdentifierByNamePS7082S7720rPS9676(IRScope_s *this, SubStr_s name);
IRScopeEntry_s *getIdentifierByNamePS9562PS7132S7720PBrPS9676(IRGen_s *this, IRFunc_s *function, SubStr_s name, bool *isGlobal);
usize getFunctionByNamePS9562PS0540rusz(IRGen_s *this, String_s *name);
usize getFunctionByMangledNamePS9562PcPcrusz(IRGen_s *this, char *name, char *imp);
bool fillLookupPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
bool _anon_26_0PS3131uszrB(TypeInfoTable_s *table, usize index);
usize _anon_26_1PS4113uszrusz(UsizeList_s *removed, usize index);
TypeInfoTable_s generateTypeInfoTablerS3131(none);
bool generateTypeInfoTablePS9562PS7132PS1892rB(IRGen_s *this, IRFunc_s *function, ParsedFile_s *project);
none _anon_26_2PS7132S8951S6939S6939uszS6939rN(IRFunc_s *function, Span_s span, RegIndex_s ptr, RegIndex_s tmp, usize byte_offset, RegIndex_s val);
RegIndex_s _anon_26_3PS9562PS7132S8951PU5175uszrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *ti, usize len);
bool generateRuntimeTypeInfoPS9562rB(IRGen_s *this);
bool generateRuntimeInitializationPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
bool generateBytecodePS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
none generateFunctionHeaderPS9562PS7132PU5175PS9803rN(IRGen_s *this, IRFunc_s *function, Type_u *retType, ParamContext_s *params);
RegIndexList_s _anon_26_4PS7132PS4904rS9911(IRFunc_s *function, ParsedFuncDecl_s *fn);
none generateFunctionBodyPS9562PS7132PS7247PS1372rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *body, ParsedTypeNode_s *retTypeNode);
none generateFunctionPS9562PS4904rN(IRGen_s *this, ParsedFuncDecl_s *funcDecl);
none generateBytecodeBlockPS9562PS7132PS7247rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *block);
none generateBytecodeStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *stmt);
none generateBytecodeMatchStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *match);
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory);
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory, bool isComptimeVariable);
none generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable);
none generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                   bool isComptimeVariable);
none generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable);
RegIndex_s generateBytecodeExprPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateTypeInfoPS9562PS7132S8951PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *type);
RegIndex_s generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnionExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprAsPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr);
RegIndex_s generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr);
RegIndex_s prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939(IRGen_s *this, Span_s span, IRFunc_s *function, RegIndex_s base, RegIndexList_s args, Type_u *retType, RegIndex_s retPtr,
                                                                           bool needsPtr);
RegIndex_s generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, usize funcID, Type_u *retType, RegIndexList_s args);
RegIndex_s generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
none addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, usize index, bool isComptime);
none addVariablePS9562PS7132S8951PS7082S7720S6939BrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, bool isComptime);
RegIndex_s generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939(IRGen_s *this, IRFunc_s *function, IdentExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s loadLiteralPS9562PS7132S6939PS6070rS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s reg, Token_s *tkn);
RegIndex_s generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr);
RegIndex_s generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnaryExpr_u *expr, Type_u *type, bool needsPtr);
none prepareParameterPS9562PS7132uszS8951S7720PU5175BrN(IRGen_s *this, IRFunc_s *function, usize index, Span_s span, SubStr_s name, Type_u *typ, bool retValue);
RegIndex_s getRegisterForSizePS9562PS7132uszrS6939(IRGen_s *this, IRFunc_s *function, usize size);
RegIndex_s prepareArgumentPS9562PS7132S8951S6939PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, RegIndex_s value, Type_u *typ);
RegIndex_s generateBytecodeExprCallPS9562PS7132PS3328BrS6939(IRGen_s *this, IRFunc_s *function, CallExpr_s *expr, bool needsPtr);
IRGen_s newIRGeneratorPS7791rS9562(Lookup_s *lookup);
none addImportRootPS2466S7720rN(Parser_s *this, SubStr_s filePath);
String_s getImportRootAtIndexPS2466uszrS0540(Parser_s *this, usize index);
none inheritImportRootsPS2466PS2466rN(Parser_s *this, Parser_s *parent);
Token_s expectSoftIdentifierPS2466rS6070(Parser_s *this);
Token_s expectPS2466uszrS6070(Parser_s *this, usize tknKind);
bool eatPS2466uszrB(Parser_s *this, usize tknKind);
bool atPS2466uszrB(Parser_s *this, usize tknKind);
bool parsedEOFPS2466rB(Parser_s *this);
bool _anon_25_1PS2466PS1892S7720rB(Parser_s *this, ParsedFile_s *root, SubStr_s name);
none _anon_25_0PS2466PS1892BPcrN(Parser_s *this, ParsedFile_s *root, bool cond, char *name);
ParsedFile_s parseProjectPS2466S7720rS1892(Parser_s *this, SubStr_s root);
none parseFilePS2466S7720PS1892rN(Parser_s *this, SubStr_s root, ParsedFile_s *file);
bool parseAttributesPS2466PS4756BrB(Parser_s *this, ParsedAttributeList_s *attrs, bool inModule);
ParsedTopLevelItem_s *parseTopLevelItemPS2466S4756BrPS1038(Parser_s *this, ParsedAttributeList_s attributes, bool skip);
ParsedTopLevelItem_s *parseTopLevelItemPS2466S5656S4756BrPS1038(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes, bool skip);
ParsedModule_s *parseModulePS2466S5656S4756rPS1882(Parser_s *this, TLIParent_s _parent, ParsedAttributeList_s modAttr);
ParsedConfig_s *parseConfigPS2466S5656S4756rPS0890(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes);
ParsedTopLevelItem_s *parseImportPS2466BrPS1038(Parser_s *this, bool skip);
ParsedTopLevelItem_s *parseImportByNamePS2466S8951S0540BrPS1038(Parser_s *this, Span_s loc, String_s file, bool skip);
ParsedUnionDecl_s *parseUnionDeclPS2466S5656rPS0997(Parser_s *this, TLIParent_s parent);
ParsedUnionVariant_s *parseUnionVariantPS2466S5656rPS3506(Parser_s *this, TLIParent_s parent);
ParsedStructDecl_s *parseStructDeclPS2466S5656rPS5521(Parser_s *this, TLIParent_s parent);
ParsedFuncDecl_s *parseFuncDeclPS2466S5656BrPS4904(Parser_s *this, TLIParent_s parent, bool isExtern);
ParsedTypeNode_s *parseReturnTypePS2466rPS1372(Parser_s *this);
ParamContext_s parseParametersPS2466rS9803(Parser_s *this);
ParsedBlock_s *parseBlockPS2466rPS7247(Parser_s *this);
ParsedStmt_s *parseStmtPS2466rPS1100(Parser_s *this);
ParsedStmt_s *parseMatchStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedPattern_s *parsePatternPS2466rPS1826(Parser_s *this);
ParsedStmt_s *parseForStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseWhileStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseReturnStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseIfStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseVarDeclStmtPS2466S6070BrPS1100(Parser_s *this, Token_s kw, bool isGlobal);
ParsedTypeNode_s *parseTypeNodePS2466rPS1372(Parser_s *this);
ParsedTypeNodeList_s _anon_25_2PS2466BrS6760(Parser_s *this, bool allowedVariadic);
ParsedTypeNode_s *parseTypeNodePS2466BrPS1372(Parser_s *this, bool allowedVariadic);
ParsedExpr_s *parseExprPS2466rPS2435(Parser_s *this);
ParsedExpr_s *parseExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
ParsedExpr_s *__parseExprPS2466uszU6350rPS2435(Parser_s *this, usize precedence, Assoc_u associativity);
ParsedExpr_s *__parseExprPS2466uszU6350BrPS2435(Parser_s *this, usize precedence, Assoc_u associativity, bool struct_init_allowed);
ParsedExpr_s *parsePrimaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
ParsedExpr_s *parseSecondaryExprPS2466PS2435uszU6350BrPS2435(Parser_s *this, ParsedExpr_s *lhs, usize precedence, Assoc_u associativity, bool struct_init_allowed);
ParsedExpr_s *parseUnaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
bool matchesBinaryExprPS2466rB(Parser_s *this);
bool matchesUnaryExprPS2466rB(Parser_s *this);
usize getBinaryPrecedencePS2466PS6070rusz(Parser_s *this, Token_s *tkn);
Assoc_u getBinaryAssociativityPS2466PS6070rU6350(Parser_s *this, Token_s *tkn);
usize getUnaryPrecedencePS2466uszrusz(Parser_s *this, usize tknKind);
Parser_s newParserFromSourceuszS7720rS2466(usize fileID, SubStr_s src);
ModuleLookup_s *insertFilePS7791PS1892rPS0997(Lookup_s *this, ParsedFile_s *file);
FunctionLookup_s *getFunctionByGlobalIDPS7791uszrPS0677(Lookup_s *this, usize funcID);
ModuleLookup_s *getModuleByGlobalIDPS7791uszrPS0997(Lookup_s *this, usize modID);
StructLookup_s *getStructByGlobalIDPS7791uszrPS4228(Lookup_s *this, usize structID);
UnionLookup_s *getUnionByGlobalDeclPS7791PS0997rPS1592(Lookup_s *this, ParsedUnionDecl_s *decl);
TypeLookup_s getTypeLookupForTypePS7791PU5175rS6177(Lookup_s *this, Type_u *typ);
StructLookup_s *findStructByNameInFilePS7791PS7720PS7720rPS4228(Lookup_s *this, SubStr_s *file, SubStr_s *name);
UnionLookup_s *findUnionByNameInFilePS7791PS7720PS7720rPS1592(Lookup_s *this, SubStr_s *file, SubStr_s *name);
TypeLookupList_s searchAllFilesForTypeNamePS7791PS7720rS1581(Lookup_s *this, SubStr_s *name);
FunctionLookupList_s searchAllFilesForFunctionNamePS7791PS6070rS8385(Lookup_s *this, Token_s *name);
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070rS3313(Lookup_s *this, Token_s *name);
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070BrS3313(Lookup_s *this, Token_s *name, bool globalOnly);
bool equalsPS5071PS5071rB(FileLookup_s *this, FileLookup_s *other);
bool insertTLIPS0997PS1038rB(ModuleLookup_s *this, ParsedTopLevelItem_s *tli);
bool _anon_24_0PS1913PS6661PS1826PS6070rB(ScopeLookup_s *globalScope, VariableLookup_s *lookup, ParsedPattern_s *pat, Token_s *name);
bool insertVariablesPS0997PS1826PS1913BrB(ModuleLookup_s *this, ParsedPattern_s *pat, ScopeLookup_s *globalScope, bool isComptime);
bool containsDuplicateFunctionPS0997PS0677PPS0677rB(ModuleLookup_s *this, FunctionLookup_s *function, FunctionLookup_s **dupl);
bool equalsPS6218PS6218rB(ImportLookup_s *this, ImportLookup_s *other);
bool equalsPS0997PS0997rB(ModuleLookup_s *this, ModuleLookup_s *other);
FunctionLookup_s *getFunctionByGlobalIDPS0997uszrPS0677(ModuleLookup_s *this, usize funcID);
FunctionLookup_s *getFunctionByGlobalIDPS0997uszBrPS0677(ModuleLookup_s *this, usize funcID, bool checkImport);
ModuleLookup_s *getModuleByGlobalIDPS0997uszrPS0997(ModuleLookup_s *this, usize modID);
ModuleLookup_s *getModuleByGlobalIDPS0997uszBrPS0997(ModuleLookup_s *this, usize modID, bool checkImport);
StructLookup_s *getStructByGlobalIDPS0997uszrPS4228(ModuleLookup_s *this, usize structID);
StructLookup_s *getStructByGlobalIDPS0997uszBrPS4228(ModuleLookup_s *this, usize structID, bool checkImport);
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997rPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl);
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997BrPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl, bool checkImport);
u32 resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32(ModuleLookup_s *this, Token_s *name, VariableLookup_s **var, TypeLookup_s *typ, FunctionLookupList_s *fun);
bool resolveModuleByNamePS0997PS6070PPS0997rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod);
bool resolveModuleByNamePS0997PS6070PPS0997S5972rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod, MLConfig_s c);
bool resolveVariableByNamePS0997PS6070PS5541PS6661rB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var);
bool resolveVariableByNamePS0997PS6070PS5541PS6661BrB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var, bool checkImport);
StructLookupList_s resolveAllStructsWithFieldPS0997PS6070PU5175rS7392(ModuleLookup_s *this, Token_s *name, Type_u *typ);
bool resolveTypeByNamePS0997PS7720PS6177rB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ);
bool resolveTypeByNamePS0997PS7720PS6177BrB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ, bool checkImport);
FunctionLookupList_s resolveFunctionByNamePS0997PS6070rS8385(ModuleLookup_s *this, Token_s *name);
FunctionLookupList_s resolveFunctionByNamePS0997PS6070BrS8385(ModuleLookup_s *this, Token_s *name, bool checkImport);
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ);
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ, MLConfig_s config);
bool resolveUnionByNamePS0997PS6070PPS1592rB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion);
bool resolveUnionByNamePS0997PS6070PPS1592BrB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion, bool checkImport);
none addParameterPS0677uszS6070U9661rN(FunctionLookup_s *this, usize globalID, Token_s name, TCState_u typeState);
bool checkForDuplicateParamPS0677PS6070PS6661rB(FunctionLookup_s *this, Token_s *name, VariableLookup_s *dupl);
bool equalsPS0677PS0677rB(FunctionLookup_s *this, FunctionLookup_s *other);
String_s getNamePS6177rS0540(TypeLookup_s *this);
String_s getLocationPS6177rS0540(TypeLookup_s *this);
bool equalsPS6177PS6177rB(TypeLookup_s *this, TypeLookup_s *other);
bool isStructPS6177rB(TypeLookup_s *this);
bool isUnionPS6177rB(TypeLookup_s *this);
StructLookup_s *asStructPS6177rPS4228(TypeLookup_s *this);
UnionLookup_s *asUnionPS6177rPS1592(TypeLookup_s *this);
TypeLookup_s newTypeLookupuszAnyrS6177(usize kind, Any actual);
TypeLookup_s asTypeLookupPS4228rS6177(StructLookup_s *this);
bool equalsPS4228PS4228rB(StructLookup_s *this, StructLookup_s *other);
bool resolveFieldByNamePS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *out);
bool hasFieldPS4228PS7720rB(StructLookup_s *this, SubStr_s *name);
usize getIndexByNamePS4228PS6070rusz(StructLookup_s *this, Token_s *name);
bool checkForDuplicateFieldPS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *dupl);
none addFieldPS4228uszS6070U9661rN(StructLookup_s *this, usize globalID, Token_s name, TCState_u typeState);
TypeLookup_s asTypeLookupPS1592rS6177(UnionLookup_s *this);
bool equalsPS1592PS1592rB(UnionLookup_s *this, UnionLookup_s *other);
bool resolveVariantByNamePS1592PS6070PPS2365rB(UnionLookup_s *this, Token_s *name, UnionVariantLookup_s **variant);
bool checkForDuplicateVariantPS1592PS3506PPS2365rB(UnionLookup_s *this, ParsedUnionVariant_s *curr, UnionVariantLookup_s **dupl);
none addVariantPS1592PS3506U9661rN(UnionLookup_s *this, ParsedUnionVariant_s *variant, TCState_u typeState);
bool equalsPS2365PS2365rB(UnionVariantLookup_s *this, UnionVariantLookup_s *other);
bool checkForDuplicateNamePS2365PS6070PPS6070rB(UnionVariantLookup_s *this, Token_s *name, Token_s **dupl);
StructLookup_s intoStructLookupPS2365rS4228(UnionVariantLookup_s *this);
bool isParameterPS6661rB(VariableLookup_s *this);
bool equalsPS6661PS6661rB(VariableLookup_s *this, VariableLookup_s *other);
bool equalsPS1913PS1913rB(ScopeLookup_s *this, ScopeLookup_s *other);
none addVariablePS1913S6661rN(ScopeLookup_s *this, VariableLookup_s variable);
bool isKnownVariablePS1913S7720PS6070rB(ScopeLookup_s *this, SubStr_s name, Token_s *existing);
bool getVarIndexByNamePS1913S7720PuszrB(ScopeLookup_s *this, SubStr_s name, usize *index);
bool getVariableByNamePS1913S7720PS6661rB(ScopeLookup_s *this, SubStr_s name, VariableLookup_s *var);
VariableLookup_s *getVariableAtIndexPS1913uszrPS6661(ScopeLookup_s *this, usize index);
none clearPS1913rN(ScopeLookup_s *this);
bool equalsPU9661PU9661rB(TCState_u *this, TCState_u *other);
bool isInvalidPU9661rB(TCState_u *this);
bool wantsInferPU9661rB(TCState_u *this);
bool isCriticalErrorPU9661rB(TCState_u *this);
bool isErrorPU9661rB(TCState_u *this);
bool isSuccessPU9661rB(TCState_u *this);
bool isTypePU9661rB(TCState_u *this);
bool isPatternPU9661rB(TCState_u *this);
Type_u *getTypePU9661rPU5175(TCState_u *this);
usize getErrorPU9661rusz(TCState_u *this);
PatState_s getPatStatePU9661rS1259(TCState_u *this);
none enterAnonFuncPS3900rN(TypeChecker_s *this);
none leaveAnonFuncPS3900rN(TypeChecker_s *this);
none enterComptimePS3900rN(TypeChecker_s *this);
none leaveComptimePS3900rN(TypeChecker_s *this);
char *pluszPcPcrPc(usize count, char *s1, char *s2);
TCState_u reportUnknownIdentifierPS3900PS6070rU9661(TypeChecker_s *this, Token_s *name);
none reportVerboseNotePS3900S0540uszPcPcrN(TypeChecker_s *this, String_s loc, usize count, char *s1, char *s2);
TCState_u reportTypeMismatchPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *expected, Type_u *got);
TCState_u reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Type_u *lhsType, Span_s rhsSpan, Type_u *rhsType);
TCState_u reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Span_s rhsSpan);
TCState_u reportDuplicateFieldPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s fieldToken, Span_s declSpan);
TCState_u reportDuplicateParameterPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s paramToken, Span_s declSpan);
TCState_u reportUnknownFieldPS3900S6070PS4228BrU9661(TypeChecker_s *this, Token_s name, StructLookup_s *decl, bool isUnion);
TCState_u reportUnknownTypePS3900PS0997S6070S1581rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name, TypeLookupList_s alternatives);
TCState_u reportDuplicateFunctionPS3900PS0677PS0677rU9661(TypeChecker_s *this, FunctionLookup_s *f1, FunctionLookup_s *f2);
TCState_u reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661(TypeChecker_s *this, Token_s ident, Type_u *fnType, FunctionLookupList_s *functions);
TCState_u reportVariableRedeclarationPS3900S6070S6070rU9661(TypeChecker_s *this, Token_s newDecl, Token_s oldDecl);
TCState_u reportRecursiveTypePS3900PS6177PS1581rU9661(TypeChecker_s *this, TypeLookup_s *checked, TypeLookupList_s *cycle);
TCState_u reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *from, Type_u *to);
TCState_u reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *typ);
TCState_u reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661(TypeChecker_s *this, Token_s ident, VariableLookup_s *var);
TCState_u reportAnyDereferencePS3900PS2435rU9661(TypeChecker_s *this, ParsedExpr_s *expr);
TCState_u reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *tuple, usize index);
TCState_u reportCouldNotInferTypePS3900S8951rU9661(TypeChecker_s *this, Span_s span);
TCState_u reportMemberAccessNoOptionsPS3900S8951rU9661(TypeChecker_s *this, Span_s span);
TCState_u reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661(TypeChecker_s *this, Span_s span, StructLookupList_s *structs);
TCState_u reportFunctionCallTooManyOptionsPS3900PS3328rU9661(TypeChecker_s *this, CallExpr_s *expr);
TCState_u reportCallToNonFunctionPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *base);
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args);
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args, bool atLeast);
TCState_u reportUnknownSubmodulePS3900PS0997S6070rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name);
TCState_u reportUnknownModulePS3900S6070rU9661(TypeChecker_s *this, Token_s name);
TCState_u reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661(TypeChecker_s *this, Span_s span, Token_s name, TypeLookup_s typ);
TCState_u reportDuplicateVariantPS3900PS3506PS2365rU9661(TypeChecker_s *this, ParsedUnionVariant_s *orig, UnionVariantLookup_s *dupl);
TCState_u reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661(TypeChecker_s *this, ParsedUnionVariant_s *variant, Token_s *first, Token_s *dupl);
TCState_u reportImpossiblePatternPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
TCState_u reportNotEnoughPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
char *_anon_23_0U3836rPc(ParsedUnionVariantData_u data);
TCState_u reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661(TypeChecker_s *this, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, Span_s span, ParsedUnionVariantData_u gotVar);
TCState_u reportInvalidVariantPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
char *_anon_23_1U3836rPc(ParsedUnionVariantData_u data);
TCState_u reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type, ParsedUnionVariantData_u expVar, ParsedUnionVariantData_u gotVar);
TCState_u reportNoSuchVariantPS3900PS1592S6070rU9661(TypeChecker_s *this, UnionLookup_s *lookup, Token_s tkn);
TCState_u reportTooManyPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
TCState_u reportStatementInNakedFunctionPS3900PS1100rU9661(TypeChecker_s *this, ParsedStmt_s *stmt);
TCState_u reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted);
TCState_u reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted);
TCState_u reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661(TypeChecker_s *this, ParsedStmt_s *stmt, usize argCount, usize paramCount);
TCState_u reportMissingTrampolinePS3900S8951rU9661(TypeChecker_s *this, Span_s span);
none reportUnnecessaryTrampolinePS3900S8951rN(TypeChecker_s *this, Span_s span);
none emergencyPrintPS3900S8951rN(TypeChecker_s *this, Span_s where);
bool typeCheckProjectPS3900PS1892rB(TypeChecker_s *this, ParsedFile_s *project);
bool dfsPS3900PU5175PS1581PS1581rB(TypeChecker_s *this, Type_u *type, TypeLookupList_s *visited, TypeLookupList_s *finished);
bool dfsPS3900S6177PS1581PS1581rB(TypeChecker_s *this, TypeLookup_s typeLookup, TypeLookupList_s *visited, TypeLookupList_s *finished);
bool findRecursiveTypesPS3900rB(TypeChecker_s *this);
bool fillLookupPS3900rB(TypeChecker_s *this);
bool typeCheckFilesPS3900rB(TypeChecker_s *this);
TCState_u typeCheckModulePS3900uszPS5541rU9661(TypeChecker_s *this, usize modID, ScopeLookupList_s *scopes);
TCState_u typeCheckUnionDeclPS3900PS0997rU9661(TypeChecker_s *this, ParsedUnionDecl_s *onion);
TCState_u typeCheckStructDeclPS3900uszrU9661(TypeChecker_s *this, usize structID);
TCState_u typeCheckFunctionPS3900uszPS5541BrU9661(TypeChecker_s *this, usize funcID, ScopeLookupList_s *scopes, bool signatureOnly);
TCState_u typeCheckFunctionPS3900PS4904PS5541BrU9661(TypeChecker_s *this, ParsedFuncDecl_s *function, ScopeLookupList_s *scopes, bool signatureOnly);
TCState_u typeCheckBlockPS3900PS7247PS5541BrU9661(TypeChecker_s *this, ParsedBlock_s *block, ScopeLookupList_s *scopes, bool nakedFunc);
TCState_u typeCheckStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, ScopeLookupList_s *scopes);
TCState_u typeCheckMatchStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *match, ScopeLookupList_s *scopes);
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope);
TCState_u _anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, Token_s ident, ScopeLookupList_s *scopes, ScopeLookup_s *scope,
                                                               bool globalScope);
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope, bool globalScope);
TCState_u typeCheckVarDeclPS3900uszPS5541BrU9661(TypeChecker_s *this, usize varDeclID, ScopeLookupList_s *scopes, bool globalScope);
TCState_u handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661(TypeChecker_s *this, Span_s span, ParsedPattern_s *pat, ParsedExpr_s *expr, ScopeLookupList_s *scopes, bool globalScope);
TCState_u typeCheckVarDeclPS3900PS1100PS5541BrU9661(TypeChecker_s *this, ParsedStmt_s *varDecl, ScopeLookupList_s *scopes, bool globalScope);
TCState_u typeCheckExprPS3900uszPS5541rU9661(TypeChecker_s *this, usize exprID, ScopeLookupList_s *scopes);
TCState_u typeCheckExprPS3900PS2435PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedExpr_s *curr, ParsedTypeNode_s *type, ScopeLookupList_s *scopes);
TCState_u typeCheckExprUnaryPS3900PU5427PS5541rU9661(TypeChecker_s *this, UnaryExpr_u *unary, ScopeLookupList_s *scopes);
TCState_u _anon_23_3PS3900PS7823PS0643PS5541BrU9661(TypeChecker_s *this, ParsedExprList_s *args, TypeList_s *params, ScopeLookupList_s *scopes, bool variadic);
TCState_u typeCheckExprCallPS3900PS3328PS5541rU9661(TypeChecker_s *this, CallExpr_s *call, ScopeLookupList_s *scopes);
TCState_u typeCheckExprStructInitPS3900PS4761PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckIdentifierPS3900PS7464PS5541rU9661(TypeChecker_s *this, IdentExpr_s *ident, ScopeLookupList_s *scopes);
TCState_u typeCheckExprBinaryPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprLogicalPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprBitwisePS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprAssignPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes);
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes, bool isUnion);
TCState_u typeCheckExprPathAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *unionType, ScopeLookupList_s *scopes);
TCState_u typeCheckExprMemberAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u checkIfInferIsNeededPS3900uszPU9661uszPU9661PS5541rU9661(TypeChecker_s *this, usize lhsID, TCState_u *lhsState, usize rhsID, TCState_u *rhsState, ScopeLookupList_s *scopes);
TCState_u checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *lhsExpr, TCState_u *lhsState, ParsedExpr_s *rhsExpr, TCState_u *rhsState,
                                                                         ScopeLookupList_s *scopes);
TCState_u inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedPattern_s *pat, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900uszuszPS5541rU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900uszPU5175PS5541rU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes);
TCState_u tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoExprPS3900uszuszPS5541BrU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661(TypeChecker_s *this, Span_s span, UnaryExpr_u *unary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *binary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661(TypeChecker_s *this, IdentExpr_s *ident, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661(TypeChecker_s *this, CallExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u typeCheckExprArithmeticPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprComparisonPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckTypeNodePS3900PS1372rU9661(TypeChecker_s *this, ParsedTypeNode_s *typeNode);
TypeChecker_s newTypeCheckerrS3900(none);
none addElementPS8905PS2435rN(ArrayContext_s *this, ParsedExpr_s *elem);
usize getElementAtIndexPS8905uszrusz(ArrayContext_s *this, usize index);
none addFieldPS7871S6070PS1372rN(StructContext_s *this, Token_s name, ParsedTypeNode_s *typ);
Token_s getFieldNameAtIndexPS7871uszrS6070(StructContext_s *this, usize index);
ParsedTypeNode_s *getFieldTypeAtIndexPS7871uszrPS1372(StructContext_s *this, usize index);
usize getFieldIndexPS7871PS7720rusz(StructContext_s *this, SubStr_s *name);
usize getFieldOffsetPS7871PS7720rusz(StructContext_s *this, SubStr_s *name);
none addFieldPS6291S6070PS2435rN(StructInitContext_s *this, Token_s name, ParsedExpr_s *expr);
Token_s getFieldNameAtIndexPS6291uszrS6070(StructInitContext_s *this, usize index);
ParsedExpr_s *getFieldExprAtIndexPS6291uszrPS2435(StructInitContext_s *this, usize index);
none addParameterPS9803S6070PS1372rN(ParamContext_s *this, Token_s name, ParsedTypeNode_s *typ);
bool hasThisPS9803rB(ParamContext_s *this);
Token_s getNameAtIndexPS9803uszrS6070(ParamContext_s *this, usize index);
ParsedTypeNode_s *getTypeAtIndexPS9803uszrPS1372(ParamContext_s *this, usize index);
usize nextMultipleOfuszuszrusz(usize a, usize b);
usize index_of_typePS3131PU5175rusz(TypeInfoTable_s *table, Type_u *type);
bool containsInvalidTypePU5175rB(Type_u *this);
String_s getMangledNamePU5175rS0540(Type_u *this);
usize getIDPU5175rusz(Type_u *this);
bool equalsPU5175PU5175rB(Type_u *this, Type_u *other);
bool _equalsPU5175PU5175BrB(Type_u *this, Type_u *other, bool allowData);
bool isUnknownPU5175rB(Type_u *this);
bool isFloatPU5175rB(Type_u *this);
bool isIntegerPU5175rB(Type_u *this);
bool isSignedIntegerPU5175rB(Type_u *this);
bool isUnsignedIntegerPU5175rB(Type_u *this);
bool isVariadicTypePU5175rB(Type_u *this);
bool isCharPU5175rB(Type_u *this);
bool isBooleanPU5175rB(Type_u *this);
bool isNonePU5175rB(Type_u *this);
bool isAnyPU5175rB(Type_u *this);
bool isDataPU5175rB(Type_u *this);
bool isPrimitivePU5175rB(Type_u *this);
bool isFunctionPU5175rB(Type_u *this);
bool isVariadicPU5175rB(Type_u *this);
bool isNoreturnPU5175rB(Type_u *this);
bool isPointerPU5175rB(Type_u *this);
bool isStructPointerPU5175rB(Type_u *this);
bool isTuplePointerPU5175rB(Type_u *this);
bool isArrayPointerPU5175rB(Type_u *this);
bool isPointerToPU5175PU5175rB(Type_u *this, Type_u *typ);
bool isModulePU5175rB(Type_u *this);
bool isStructPU5175rB(Type_u *this);
bool isUnionPU5175rB(Type_u *this);
bool isArrayPU5175rB(Type_u *this);
bool isTuplePU5175rB(Type_u *this);
bool isStructArrayPU5175rB(Type_u *this);
Type_u *getUnderlyingTypePU5175BrPU5175(Type_u *this, bool deep);
String_s toStringPU5175rS0540(Type_u *this);
usize getAlignmentInBitsPU5175rusz(Type_u *this);
usize getAlignmentInBytesPU5175rusz(Type_u *this);
usize getSizeInBitsPU5175rusz(Type_u *this);
usize getSizeInBytesPU5175rusz(Type_u *this);
Type_u *getParamPU5175uszrPU5175(Type_u *fnType, usize id);
Type_u *getReturnTypePU5175rPU5175(Type_u *fnType);
Type_u *getTupleElementPU5175uszrPU5175(Type_u *tuple, usize index);
f64 getMaxFloatValuePU5175rf64(Type_u *this);
Type_u *intoPointerPU5175rPU5175(Type_u *this);
Type_u *intoArrayTypePU5175uszrPU5175(Type_u *this, usize size);
Type_u *copyPU5175rPU5175(Type_u *this);
Type_u *wrapU5175rPU5175(Type_u t);
ParsedExpr_s *popPS7823uszrPS2435(ParsedExprList_s *this, usize index);
none pushPS0643PU5175rN(TypeList_s *this, Type_u *element);
Type_u **atPS0643uszrPPU5175(TypeList_s *this, usize index);
none pushPS7823PS2435rN(ParsedExprList_s *this, ParsedExpr_s *element);
ParsedExpr_s **atPS7823uszrPPS2435(ParsedExprList_s *this, usize index);
none pushPS3288PS1100rN(ParsedStmtList_s *this, ParsedStmt_s *element);
ParsedStmt_s **atPS3288uszrPPS1100(ParsedStmtList_s *this, usize index);
none pushPS1982PS1826rN(ParsedPatternList_s *this, ParsedPattern_s *element);
ParsedPattern_s **atPS1982uszrPPS1826(ParsedPatternList_s *this, usize index);
none pushPS4601S2365rN(UnionVariantLookupList_s *this, UnionVariantLookup_s element);
UnionVariantLookup_s *atPS4601uszrPS2365(UnionVariantLookupList_s *this, usize index);
bool containsPS4601PS2365rB(UnionVariantLookupList_s *this, UnionVariantLookup_s *element);
none pushPS4836S1592rN(UnionLookupList_s *this, UnionLookup_s element);
UnionLookup_s *popPS4836rPS1592(UnionLookupList_s *this);
UnionLookup_s *atPS4836uszrPS1592(UnionLookupList_s *this, usize index);
bool containsPS4836PS1592rB(UnionLookupList_s *this, UnionLookup_s *element);
UnionLookup_s *lastPS4836rPS1592(UnionLookupList_s *this);
none pushPS0030PS3506rN(ParsedUnionVariantList_s *this, ParsedUnionVariant_s *element);
ParsedUnionVariant_s **atPS0030uszrPPS3506(ParsedUnionVariantList_s *this, usize index);
none pushPS6760PS1372rN(ParsedTypeNodeList_s *this, ParsedTypeNode_s *element);
ParsedTypeNode_s **atPS6760uszrPPS1372(ParsedTypeNodeList_s *this, usize index);
none pushPS9938S6070rN(TokenList_s *this, Token_s element);
Token_s *atPS9938uszrPS6070(TokenList_s *this, usize index);
none pushPS1575U7467rN(ConfigList_s *this, Config_u element);
none pushPS5121S0997rN(ModuleLookupList_s *this, ModuleLookup_s element);
bool containsPS5121PS0997rB(ModuleLookupList_s *this, ModuleLookup_s *element);
ModuleLookup_s *atPS5121uszrPS0997(ModuleLookupList_s *this, usize index);
Config_u *atPS1575uszrPU7467(ConfigList_s *this, usize index);
ModuleLookup_s *lastPS5121rPS0997(ModuleLookupList_s *this);
none initBlankPS4756uszrN(ParsedAttributeList_s *this, usize newCap);
none pushPS4756U4360rN(ParsedAttributeList_s *this, ParsedAttribute_u element);
ParsedAttribute_u *popPS4756rPU4360(ParsedAttributeList_s *this);
ParsedAttribute_u *atPS4756uszrPU4360(ParsedAttributeList_s *this, usize index);
bool containsPS4756PU4360rB(ParsedAttributeList_s *this, ParsedAttribute_u *element);
ParsedAttribute_u *lastPS4756rPU4360(ParsedAttributeList_s *this);
none extendPS4756PS4756rN(ParsedAttributeList_s *this, ParsedAttributeList_s *other);
none dropPS4756rN(ParsedAttributeList_s *this);
none clearPS4756rN(ParsedAttributeList_s *this);
none initBlankPS8385uszrN(FunctionLookupList_s *this, usize newCap);
none pushPS8385S0677rN(FunctionLookupList_s *this, FunctionLookup_s element);
FunctionLookup_s *popPS8385rPS0677(FunctionLookupList_s *this);
FunctionLookup_s *atPS8385uszrPS0677(FunctionLookupList_s *this, usize index);
bool containsPS8385PS0677rB(FunctionLookupList_s *this, FunctionLookup_s *element);
FunctionLookup_s *lastPS8385rPS0677(FunctionLookupList_s *this);
none extendPS8385PS8385rN(FunctionLookupList_s *this, FunctionLookupList_s *other);
none dropPS8385rN(FunctionLookupList_s *this);
none clearPS8385rN(FunctionLookupList_s *this);
none initBlankPS7392uszrN(StructLookupList_s *this, usize newCap);
none pushPS7392S4228rN(StructLookupList_s *this, StructLookup_s element);
StructLookup_s *popPS7392rPS4228(StructLookupList_s *this);
StructLookup_s *atPS7392uszrPS4228(StructLookupList_s *this, usize index);
bool containsPS7392PS4228rB(StructLookupList_s *this, StructLookup_s *element);
StructLookup_s *lastPS7392rPS4228(StructLookupList_s *this);
none extendPS7392PS7392rN(StructLookupList_s *this, StructLookupList_s *other);
none dropPS7392rN(StructLookupList_s *this);
none clearPS7392rN(StructLookupList_s *this);
none initBlankPS5541uszrN(ScopeLookupList_s *this, usize newCap);
none pushPS5541S1913rN(ScopeLookupList_s *this, ScopeLookup_s element);
ScopeLookup_s *popPS5541rPS1913(ScopeLookupList_s *this);
ScopeLookup_s *atPS5541uszrPS1913(ScopeLookupList_s *this, usize index);
bool containsPS5541PS1913rB(ScopeLookupList_s *this, ScopeLookup_s *element);
ScopeLookup_s *lastPS5541rPS1913(ScopeLookupList_s *this);
none extendPS5541PS5541rN(ScopeLookupList_s *this, ScopeLookupList_s *other);
none dropPS5541rN(ScopeLookupList_s *this);
none clearPS5541rN(ScopeLookupList_s *this);
none initBlankPS1581uszrN(TypeLookupList_s *this, usize newCap);
none pushPS1581S6177rN(TypeLookupList_s *this, TypeLookup_s element);
TypeLookup_s *popPS1581rPS6177(TypeLookupList_s *this);
TypeLookup_s *atPS1581uszrPS6177(TypeLookupList_s *this, usize index);
bool containsPS1581PS6177rB(TypeLookupList_s *this, TypeLookup_s *element);
TypeLookup_s *lastPS1581rPS6177(TypeLookupList_s *this);
none extendPS1581PS1581rN(TypeLookupList_s *this, TypeLookupList_s *other);
none dropPS1581rN(TypeLookupList_s *this);
none clearPS1581rN(TypeLookupList_s *this);
none initBlankPS3313uszrN(VariableLookupList_s *this, usize newCap);
none pushPS3313S6661rN(VariableLookupList_s *this, VariableLookup_s element);
VariableLookup_s *popPS3313rPS6661(VariableLookupList_s *this);
VariableLookup_s *atPS3313uszrPS6661(VariableLookupList_s *this, usize index);
bool containsPS3313PS6661rB(VariableLookupList_s *this, VariableLookup_s *element);
VariableLookup_s *lastPS3313rPS6661(VariableLookupList_s *this);
none extendPS3313PS3313rN(VariableLookupList_s *this, VariableLookupList_s *other);
none dropPS3313rN(VariableLookupList_s *this);
none clearPS3313rN(VariableLookupList_s *this);
none initBlankPS3606uszrN(ImportLookupList_s *this, usize newCap);
none pushPS3606S6218rN(ImportLookupList_s *this, ImportLookup_s element);
ImportLookup_s *popPS3606rPS6218(ImportLookupList_s *this);
ImportLookup_s *atPS3606uszrPS6218(ImportLookupList_s *this, usize index);
bool containsPS3606PS6218rB(ImportLookupList_s *this, ImportLookup_s *element);
ImportLookup_s *lastPS3606rPS6218(ImportLookupList_s *this);
none extendPS3606PS3606rN(ImportLookupList_s *this, ImportLookupList_s *other);
none dropPS3606rN(ImportLookupList_s *this);
none clearPS3606rN(ImportLookupList_s *this);
none initBlankPS9625uszrN(TCStateList_s *this, usize newCap);
none pushPS9625U9661rN(TCStateList_s *this, TCState_u element);
TCState_u *popPS9625rPU9661(TCStateList_s *this);
TCState_u *atPS9625uszrPU9661(TCStateList_s *this, usize index);
bool containsPS9625PU9661rB(TCStateList_s *this, TCState_u *element);
TCState_u *lastPS9625rPU9661(TCStateList_s *this);
none extendPS9625PS9625rN(TCStateList_s *this, TCStateList_s *other);
none dropPS9625rN(TCStateList_s *this);
none clearPS9625rN(TCStateList_s *this);
none initBlankPS9911uszrN(RegIndexList_s *this, usize newCap);
none pushPS9911S6939rN(RegIndexList_s *this, RegIndex_s element);
RegIndex_s *popPS9911rPS6939(RegIndexList_s *this);
RegIndex_s *atPS9911uszrPS6939(RegIndexList_s *this, usize index);
bool containsPS9911PS6939rB(RegIndexList_s *this, RegIndex_s *element);
RegIndex_s *lastPS9911rPS6939(RegIndexList_s *this);
none extendPS9911PS9911rN(RegIndexList_s *this, RegIndexList_s *other);
none dropPS9911rN(RegIndexList_s *this);
none clearPS9911rN(RegIndexList_s *this);
none initBlankPS0124uszrN(IRInstrList_s *this, usize newCap);
none pushPS0124S7680rN(IRInstrList_s *this, IRInstr_s element);
IRInstr_s *popPS0124rPS7680(IRInstrList_s *this);
IRInstr_s *atPS0124uszrPS7680(IRInstrList_s *this, usize index);
bool containsPS0124PS7680rB(IRInstrList_s *this, IRInstr_s *element);
IRInstr_s *lastPS0124rPS7680(IRInstrList_s *this);
none extendPS0124PS0124rN(IRInstrList_s *this, IRInstrList_s *other);
none dropPS0124rN(IRInstrList_s *this);
none clearPS0124rN(IRInstrList_s *this);
none initBlankPS9366uszrN(IRScopeList_s *this, usize newCap);
none pushPS9366S7082rN(IRScopeList_s *this, IRScope_s element);
IRScope_s *popPS9366rPS7082(IRScopeList_s *this);
IRScope_s *atPS9366uszrPS7082(IRScopeList_s *this, usize index);
bool containsPS9366PS7082rB(IRScopeList_s *this, IRScope_s *element);
IRScope_s *lastPS9366rPS7082(IRScopeList_s *this);
none extendPS9366PS9366rN(IRScopeList_s *this, IRScopeList_s *other);
none dropPS9366rN(IRScopeList_s *this);
none clearPS9366rN(IRScopeList_s *this);
none initBlankPS2282uszrN(IRRegList_s *this, usize newCap);
none pushPS2282S1534rN(IRRegList_s *this, IRReg_s element);
IRReg_s *popPS2282rPS1534(IRRegList_s *this);
IRReg_s *atPS2282uszrPS1534(IRRegList_s *this, usize index);
bool containsPS2282PS1534rB(IRRegList_s *this, IRReg_s *element);
IRReg_s *lastPS2282rPS1534(IRRegList_s *this);
none extendPS2282PS2282rN(IRRegList_s *this, IRRegList_s *other);
none dropPS2282rN(IRRegList_s *this);
none clearPS2282rN(IRRegList_s *this);
none initBlankPS1479uszrN(IRBlockList_s *this, usize newCap);
none pushPS1479S9435rN(IRBlockList_s *this, IRBlock_s element);
IRBlock_s *popPS1479rPS9435(IRBlockList_s *this);
IRBlock_s *atPS1479uszrPS9435(IRBlockList_s *this, usize index);
bool containsPS1479PS9435rB(IRBlockList_s *this, IRBlock_s *element);
IRBlock_s *lastPS1479rPS9435(IRBlockList_s *this);
none extendPS1479PS1479rN(IRBlockList_s *this, IRBlockList_s *other);
none dropPS1479rN(IRBlockList_s *this);
none clearPS1479rN(IRBlockList_s *this);
none initBlankPS6662uszrN(LoopBlockList_s *this, usize newCap);
none pushPS6662S0666rN(LoopBlockList_s *this, LoopBlock_s element);
LoopBlock_s *popPS6662rPS0666(LoopBlockList_s *this);
LoopBlock_s *atPS6662uszrPS0666(LoopBlockList_s *this, usize index);
bool containsPS6662PS0666rB(LoopBlockList_s *this, LoopBlock_s *element);
LoopBlock_s *lastPS6662rPS0666(LoopBlockList_s *this);
none extendPS6662PS6662rN(LoopBlockList_s *this, LoopBlockList_s *other);
none dropPS6662rN(LoopBlockList_s *this);
none clearPS6662rN(LoopBlockList_s *this);
none initBlankPS5960uszrN(IRScopeEntryList_s *this, usize newCap);
none pushPS5960S9676rN(IRScopeEntryList_s *this, IRScopeEntry_s element);
IRScopeEntry_s *popPS5960rPS9676(IRScopeEntryList_s *this);
IRScopeEntry_s *atPS5960uszrPS9676(IRScopeEntryList_s *this, usize index);
bool containsPS5960PS9676rB(IRScopeEntryList_s *this, IRScopeEntry_s *element);
IRScopeEntry_s *lastPS5960rPS9676(IRScopeEntryList_s *this);
none extendPS5960PS5960rN(IRScopeEntryList_s *this, IRScopeEntryList_s *other);
none dropPS5960rN(IRScopeEntryList_s *this);
none clearPS5960rN(IRScopeEntryList_s *this);
none initBlankPS8040uszrN(IRFuncList_s *this, usize newCap);
none pushPS8040S7132rN(IRFuncList_s *this, IRFunc_s element);
IRFunc_s *popPS8040rPS7132(IRFuncList_s *this);
IRFunc_s *atPS8040uszrPS7132(IRFuncList_s *this, usize index);
bool containsPS8040PS7132rB(IRFuncList_s *this, IRFunc_s *element);
IRFunc_s *lastPS8040rPS7132(IRFuncList_s *this);
none extendPS8040PS8040rN(IRFuncList_s *this, IRFuncList_s *other);
none dropPS8040rN(IRFuncList_s *this);
none clearPS8040rN(IRFuncList_s *this);
none initBlankPS4318uszrN(LLVMTypeList_s *this, usize newCap);
none pushPS4318S0706rN(LLVMTypeList_s *this, LLVMType_s element);
LLVMType_s *popPS4318rPS0706(LLVMTypeList_s *this);
LLVMType_s *atPS4318uszrPS0706(LLVMTypeList_s *this, usize index);
bool containsPS4318PS0706rB(LLVMTypeList_s *this, LLVMType_s *element);
LLVMType_s *lastPS4318rPS0706(LLVMTypeList_s *this);
none extendPS4318PS4318rN(LLVMTypeList_s *this, LLVMTypeList_s *other);
none dropPS4318rN(LLVMTypeList_s *this);
none clearPS4318rN(LLVMTypeList_s *this);
none initBlankPS5884uszrN(RegValueList_s *this, usize newCap);
none pushPS5884U5952rN(RegValueList_s *this, RegValue_u element);
RegValue_u *popPS5884rPU5952(RegValueList_s *this);
RegValue_u *atPS5884uszrPU5952(RegValueList_s *this, usize index);
bool containsPS5884PU5952rB(RegValueList_s *this, RegValue_u *element);
RegValue_u *lastPS5884rPU5952(RegValueList_s *this);
none extendPS5884PS5884rN(RegValueList_s *this, RegValueList_s *other);
none dropPS5884rN(RegValueList_s *this);
none clearPS5884rN(RegValueList_s *this);
none initBlankPS0409uszrN(LLVMBasicBlockList_s *this, usize newCap);
none pushPS0409S7469rN(LLVMBasicBlockList_s *this, LLVMBasicBlock_s element);
LLVMBasicBlock_s *popPS0409rPS7469(LLVMBasicBlockList_s *this);
LLVMBasicBlock_s *atPS0409uszrPS7469(LLVMBasicBlockList_s *this, usize index);
bool containsPS0409PS7469rB(LLVMBasicBlockList_s *this, LLVMBasicBlock_s *element);
LLVMBasicBlock_s *lastPS0409rPS7469(LLVMBasicBlockList_s *this);
none extendPS0409PS0409rN(LLVMBasicBlockList_s *this, LLVMBasicBlockList_s *other);
none dropPS0409rN(LLVMBasicBlockList_s *this);
none clearPS0409rN(LLVMBasicBlockList_s *this);
none initBlankPS8201uszrN(LLVMValueList_s *this, usize newCap);
none pushPS8201S8925rN(LLVMValueList_s *this, LLVMValue_s element);
LLVMValue_s *popPS8201rPS8925(LLVMValueList_s *this);
LLVMValue_s *atPS8201uszrPS8925(LLVMValueList_s *this, usize index);
bool containsPS8201PS8925rB(LLVMValueList_s *this, LLVMValue_s *element);
LLVMValue_s *lastPS8201rPS8925(LLVMValueList_s *this);
none extendPS8201PS8201rN(LLVMValueList_s *this, LLVMValueList_s *other);
none dropPS8201rN(LLVMValueList_s *this);
none clearPS8201rN(LLVMValueList_s *this);
none initBlankPS4113uszrN(UsizeList_s *this, usize newCap);
none pushPS4113uszrN(UsizeList_s *this, usize element);
usize *atPS4113uszrPusz(UsizeList_s *this, usize index);
ImportLookup_s *getPS3606PS6218rPS6218(ImportLookupList_s *this, ImportLookup_s *val);
StructLookup_s *getPS7392PS4228rPS4228(StructLookupList_s *this, StructLookup_s *val);
UnionLookup_s *getPS4836PS1592rPS1592(UnionLookupList_s *this, UnionLookup_s *val);
ModuleLookup_s *getPS5121PS0997rPS0997(ModuleLookupList_s *this, ModuleLookup_s *val);
none toggleIgnoringNodesrN(none);
String_s mangleVariableNameBuszPS6070rS0540(bool global, usize fileID, Token_s *name);
String_s mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540(TLIParent_s parent, Token_s *name, ParamContext_s *params, ParsedTypeNode_s *retType, bool isComptime, ParsedAttributeList_s *attrs);
ParsedFile_s *getFileByFileNameS7720rPS1892(SubStr_s name);
bool getFileByFilePathS7720PuszrB(SubStr_s path, usize *fileID);
bool equalsPU4360PU4360rB(ParsedAttribute_u *this, ParsedAttribute_u *other);
Config_u newConfigS6070S6070rU7467(Token_s t, Token_s value);
ParsedConfig_s *newParsedConfigS8951S1575rPS0890(Span_s span, ConfigList_s cfgs);
usize getIDPS0890rusz(ParsedConfig_s *this);
ParsedTopLevelItem_s *asTLIPS0890rPS1038(ParsedConfig_s *this);
usize getIDPS1892rusz(ParsedFile_s *this);
none getLineAndColumnFromSpanPS1892PS8951PuszPuszrN(ParsedFile_s *this, Span_s *span, usize *line, usize *column);
ParsedFile_s *newParsedFileS7720S7720rPS1892(SubStr_s origin, SubStr_s src);
bool equalsPS5656PS5656rB(TLIParent_s *this, TLIParent_s *other);
ParsedStructDecl_s *asStructPS1038rPS5521(ParsedTopLevelItem_s *this);
ParsedUnionDecl_s *asUnionPS1038rPS0997(ParsedTopLevelItem_s *this);
usize getIDPS1038rusz(ParsedTopLevelItem_s *this);
ParsedTopLevelItem_s *newParsedTopLevelItemS8951uszuszrPS1038(Span_s span, usize kind, usize nodeID);
DLL_s *newDLLS0540S9457rPS3633(String_s path, Handle_s handle);
DLL_s *dllNotFoundrPS3633(none);
DLL_s *dllNoSuchFunctionrPS3633(none);
bool isNullPS3633rB(DLL_s *dll);
usize getIDPS3633rusz(DLL_s *this);
bool equalsPS1882PS1882rB(ParsedModule_s *this, ParsedModule_s *other);
UsizeList_s getConfigsPS1882rS4113(ParsedModule_s *this);
usize getIDPS1882rusz(ParsedModule_s *this);
ParsedTopLevelItem_s *asTLIPS1882rPS1038(ParsedModule_s *this);
ParsedFile_s *getParentFilePS1882rPS1892(ParsedModule_s *this);
String_s getFullNamePS1882rS0540(ParsedModule_s *this);
ParsedModule_s *newParsedModuleS5656S8951S6070S4113rPS1882(TLIParent_s parent, Span_s span, Token_s name, UsizeList_s tlis);
usize getIDPS5521rusz(ParsedStructDecl_s *this);
ParsedTopLevelItem_s *asTLIPS5521rPS1038(ParsedStructDecl_s *this);
usize getFieldIndexPS5521PS7720rusz(ParsedStructDecl_s *this, SubStr_s *name);
usize getFieldOffsetPS5521PS7720Brusz(ParsedStructDecl_s *this, SubStr_s *name, bool inBits);
none getFieldOffsetAndSizePS5521uszPuszPuszBrN(ParsedStructDecl_s *this, usize index, usize *offset, usize *size, bool inBits);
ParsedFile_s *getParentFilePS5521rPS1892(ParsedStructDecl_s *this);
ParsedModule_s *getParentModulePS5521rPS1882(ParsedStructDecl_s *this);
String_s getFullNamePS5521PcrS0540(ParsedStructDecl_s *this, char *split);
String_s getFullNamePS5521rS0540(ParsedStructDecl_s *this);
ParsedStructDecl_s *newParsedStructDeclS5656S8951S6070rPS5521(TLIParent_s parent, Span_s span, Token_s name);
usize getAlignmentInBytesPS0997rusz(ParsedUnionDecl_s *this);
usize getSizeInBytesPS0997rusz(ParsedUnionDecl_s *this);
usize getIDPS0997rusz(ParsedUnionDecl_s *this);
ParsedTopLevelItem_s *asTLIPS0997rPS1038(ParsedUnionDecl_s *this);
bool resolveVariantByNamePS0997PS6070PPS3506rB(ParsedUnionDecl_s *this, Token_s *name, ParsedUnionVariant_s **out);
usize getVariantTagPS0997PS3506rusz(ParsedUnionDecl_s *this, ParsedUnionVariant_s *variant);
ParsedFile_s *getParentFilePS0997rPS1892(ParsedUnionDecl_s *this);
String_s getFullNamePS0997PcrS0540(ParsedUnionDecl_s *this, char *split);
String_s getFullNamePS0997rS0540(ParsedUnionDecl_s *this);
ParsedUnionDecl_s *newParsedUnionDeclS5656S8951S6070rPS0997(TLIParent_s parent, Span_s span, Token_s name);
usize getIDPS3506rusz(ParsedUnionVariant_s *this);
tuple_1017 get_fieldsPS3506rT_BPS6760(ParsedUnionVariant_s *this);
Type_u *toTypePS3506rPU5175(ParsedUnionVariant_s *this);
usize getFieldIndexPS3506PS7720rusz(ParsedUnionVariant_s *this, SubStr_s *name);
none getFieldOffsetAndSizePS3506uszPuszPuszBrN(ParsedUnionVariant_s *this, usize index, usize *offset, usize *size, bool inBits);
none addFieldPS3506PS1372rN(ParsedUnionVariant_s *this, ParsedTypeNode_s *field);
Type_u *getTypeAtIndexPS3506uszrPU5175(ParsedUnionVariant_s *this, usize index);
none addNamedFieldPS3506S6070PS1372rN(ParsedUnionVariant_s *this, Token_s name, ParsedTypeNode_s *typ);
bool checkForDuplicateNamePS3506PS6070PPS6070rB(ParsedUnionVariant_s *this, Token_s *name, Token_s **dupl);
ParsedUnionVariant_s *newParsedUnionVariantS5656S8951S6070U3836rPS3506(TLIParent_s parent, Span_s span, Token_s name, ParsedUnionVariantData_u data);
bool hasAttributePS4904U4360rB(ParsedFuncDecl_s *this, ParsedAttribute_u attr);
usize getIDPS4904rusz(ParsedFuncDecl_s *this);
bool isExternPS4904rB(ParsedFuncDecl_s *this);
ParsedFile_s *getParentFilePS4904rPS1892(ParsedFuncDecl_s *this);
ParsedModule_s *getParentModulePS4904rPS1882(ParsedFuncDecl_s *this);
String_s getMangledNamePS4904rS0540(ParsedFuncDecl_s *this);
ParsedTopLevelItem_s *asTLIPS4904rPS1038(ParsedFuncDecl_s *this);
ParsedFuncDecl_s *newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904(TLIParent_s parent, Span_s span, Token_s name, ParamContext_s params, ParsedTypeNode_s *retType, ParsedBlock_s *body);
usize getIDPS7247rusz(ParsedBlock_s *this);
none addStmtPS7247PS1100rN(ParsedBlock_s *this, ParsedStmt_s *stmt);
ParsedStmt_s *getStmtAtIndexPS7247uszrPS1100(ParsedBlock_s *this, usize index);
ParsedStmt_s *into_stmtPS7247rPS1100(ParsedBlock_s *this);
ParsedBlock_s *newParsedBlockrPS7247(none);
usize getIDPS1100rusz(ParsedStmt_s *this);
ParsedTopLevelItem_s *asTLIPS1100rPS1038(ParsedStmt_s *this);
ParsedBlock_s *into_blockPS1100rPS7247(ParsedStmt_s *this);
ParsedStmt_s *newParsedStmtS8951U4263rPS1100(Span_s span, StmtData_u data);
SubStr_s BUILD_A_TYPEPcrS7720(char *s);
usize getBuiltinTypeKindS6070rusz(Token_s name);
usize getIDPS1372rusz(ParsedTypeNode_s *this);
ParsedTypeNode_s *newParsedTypeNodeS8951uszrPS1372(Span_s span, usize kind);
ParsedTypeNode_s *newBuiltinTypeDeclS8951uszrPS1372(Span_s span, usize kind);
UnaryExpr_u fromTknuszPS2435rU5427(usize kind, ParsedExpr_s *expr);
none extractOperandPU5427PPS2435rN(UnaryExpr_u *expr, ParsedExpr_s **lhs);
char *binOpAsStrPU0121rPc(BinaryExpr_u *expr);
none extractOperandsPU0121PPS2435PPS2435rN(BinaryExpr_u *expr, ParsedExpr_s **lhs, ParsedExpr_s **rhs);
BinaryExpr_u fromTknuszPS2435PS2435rU0121(usize kind, ParsedExpr_s *lhs, ParsedExpr_s *rhs);
bool isArithmeticPU0121rB(BinaryExpr_u *this);
bool isComparisonPU0121rB(BinaryExpr_u *this);
bool isLogicalPU0121rB(BinaryExpr_u *this);
bool isBitwisePU0121rB(BinaryExpr_u *this);
bool isAssignmentPU0121rB(BinaryExpr_u *this);
usize getIDPS2435rusz(ParsedExpr_s *this);
ParsedExpr_s *wrapS2435rPS2435(ParsedExpr_s this);
ParsedExpr_s *newParsedExprS8951U8798rPS2435(Span_s span, ExprData_u data);
usize intoPointerPS2435rusz(ParsedExpr_s *this);
bool isLValuePS2435rB(ParsedExpr_s *this);
bool isBlankPS2435rB(ParsedExpr_s *this);
bool isIdentifierPS2435rB(ParsedExpr_s *this);
bool isLiteralPS2435rB(ParsedExpr_s *this);
bool isUnaryPS2435rB(ParsedExpr_s *this);
bool isCallPS2435rB(ParsedExpr_s *this);
bool isAssignmentPS2435rB(ParsedExpr_s *this);
usize getIDPS1826rusz(ParsedPattern_s *this);
ParsedPattern_s *newParsedPatternS8951U9267rPS1826(Span_s span, Pattern_u pat);
String_s toStringPS1826rS0540(ParsedPattern_s *this);
bool equalsPS8951PS8951rB(Span_s *this, Span_s *other);
none printPS8951rN(Span_s *this);
String_s toStringPS8951rS0540(Span_s *this);
bool comesBeforePS8951PS8951rB(Span_s *this, Span_s *other);
Span_s newSpanuszuszuszrS8951(usize file, usize start, usize end);
Span_s newSpanBetweenPS8951PS8951rS8951(Span_s *start, Span_s *end);
Span_s defaultSpanrS8951(none);
bool isMandatoryPS7407rB(Flag_s *flag);
String_s toStringPS7407rS0540(Flag_s *this);
bool *addHelpFlagPS7660rPB(FlagParser_s *this);
Flag_s *addDefaultFlagPS7660PcPcPcuszU0121rPS7407(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode, FlagData_u data);
String_s *addStringFlagPS7660PcuszrPS0540(FlagParser_s *this, char *descr, usize mode);
String_s *addStringFlagPS7660PcPcPcrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr);
String_s *addStringFlagPS7660PcPcPcuszrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode);
bool *addBoolFlagPS7660PcPcrPB(FlagParser_s *this, char *flag, char *descr);
bool *addBoolFlagPS7660PcPcPcrPB(FlagParser_s *this, char *short_, char *long_, char *descr);
bool *addBoolFlagPS7660PcPcPcuszrPB(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode);
char *shiftArgumentPS7660Pi32PPPcrPc(FlagParser_s *this, i32 *argc, char ***argv);
none showErrorsAnyPS7660rN(Any stream, FlagParser_s *this);
none showUsageAnyPS7660rN(Any stream, FlagParser_s *this);
none showHelpAnyPS7660rN(Any stream, FlagParser_s *this);
none showHelpAnyPS7407rN(Any stream, Flag_s *this);
bool helpOrPS7660BrB(FlagParser_s *this, bool or);
String_s *emitFlagErrorPS7660PcPcrPS0540(FlagParser_s *this, char *msg, char *name);
String_s *emitFlagErrorPS7660PcrPS0540(FlagParser_s *this, char *msg);
String_s emitFlagDescriptionPS7660PS7407rS0540(FlagParser_s *this, Flag_s *f);
bool runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv);
bool _runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv);
bool analyzeControlFlowPS9562rB(IRGen_s *irgen);
none __format_helperPS0540S4175rN(String_s *out, Data_s arg);
typedef struct variadic_4480 {
    Data_s *ptr;
    usize length;
} variadic_4480;
none formatPS0540PcVS4175rN(String_s *out, char *fmt, variadic_4480 args);
String_s format1PcVS4175rS0540(char *fmt, variadic_4480 args);
none fprintPcVS4175rN(char *fmt, variadic_4480 args);
GAF_List_s new_GAF_ListU7843rS3646(TypeInfo_u ti);
none enumeratePS3646FN_uszS4175rN(GAF_List_s *this, none (*fn)(usize, Data_s));
none enumeratePS3646FN_usz_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(usize, Data_s, Any), Any arg);
none foreachPS3646FNS4175rN(GAF_List_s *this, none (*fn)(Data_s));
none foreachPS3646FN_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(Data_s, Any), Any arg);
none pushPS3646S4175rN(GAF_List_s *list, Data_s elem);
none popPS3646rN(GAF_List_s *list);
none popPS3646AnyrN(GAF_List_s *list, Any dst);
Data_s get_refPS3646uszrS4175(GAF_List_s *list, usize index);
Any get_ref_rawPS3646uszrAny(GAF_List_s *list, usize index);
none swap_removePS3646uszrN(GAF_List_s *list, usize index);
usize _anon_46_0S4175rusz(Data_s key);
bool _anon_46_1S4175S4175rB(Data_s k1, Data_s k2);
GAF_HashMap_s new_hashmap_with_substr_keyU7843rS4580(TypeInfo_u info);
usize _anon_46_2S4175rusz(Data_s key);
bool _anon_46_3S4175S4175rB(Data_s k1, Data_s k2);
GAF_HashMap_s new_hashmap_with_string_keyU7843rS4580(TypeInfo_u info);
GAF_HashMap_s new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580(TypeInfo_u key, TypeInfo_u value, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s));
none _anon_46_4S4175S4175PS3646rN(Data_s k, Data_s elem, GAF_List_s *arg);
GAF_List_s asListPS4580rS3646(GAF_HashMap_s *this);
none enumeratePS4580FN_usz_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s));
none enumeratePS4580FN_usz_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s, Any), Any arg);
none foreachPS4580FN_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s));
none foreachPS4580FN_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s, Any), Any arg);
bool needsResizePS4580rB(GAF_HashMap_s *this);
none resizeIfNecessaryPS4580rN(GAF_HashMap_s *this);
none addPS4580S4175S4175rN(GAF_HashMap_s *this, Data_s key, Data_s value);
bool containsPS4580S4175rB(GAF_HashMap_s *this, Data_s key);
Data_s getPS4580S4175rS4175(GAF_HashMap_s *this, Data_s key);
tuple_4518 getAtIndexPS4580uszrT_S4175S4175(GAF_HashMap_s *this, usize index);
GAF_HashSet_s new_substr_hashsetrS1250(none);
GAF_HashSet_s new_string_hashsetrS1250(none);
GAF_HashSet_s new_GAF_HashSetU7843FuszS4175FB_S4175S4175rS1250(TypeInfo_u key, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s));
none addPS1250S4175rN(GAF_HashSet_s *this, Data_s key);
bool containsPS1250S4175rB(GAF_HashSet_s *this, Data_s key);
CStack_s newCStackrS1662(none);
CGen_s newCGenrS9442(none);
tuple_4302 getVariableInfoPS9442S7720rT_S0610B(CGen_s *this, SubStr_s name);
String_s unescapeS7720rS0540(SubStr_s s);
String_s generateTypeNamePS9442PU5175S0540rS0540(CGen_s *this, Type_u *type, String_s nameForType);
String_s generateTypeNamePS9442PU5175S7720rS0540(CGen_s *this, Type_u *type, SubStr_s nameForType);
String_s generateTypeNamePS9442PU5175S7720uszrS0540(CGen_s *this, Type_u *type, SubStr_s nameForType, usize size);
String_s generateTypeNamePS9442PU5175rS0540(CGen_s *this, Type_u *type);
String_s generateTypeNamePS9442PS1372rS0540(CGen_s *this, ParsedTypeNode_s *type);
none makeNameCCompatiblePS0540rN(String_s *name);
none makeNameCCompatiblePS0540PcrN(String_s *name, char *prefix);
none generateBuiltinTypedefsPS0540rN(String_s *out);
none forwardDeclareTypesPS9442PS0540rN(CGen_s *this, String_s *out);
none emitTypeDeclarationPS9442PS0540PS4580PU5175rN(CGen_s *this, String_s *out, GAF_HashMap_s *map, Type_u *type);
none emitVariadicTypePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateTypeDeclarationsPS9442PS0540rN(CGen_s *this, String_s *out);
none forwardDeclareFunctionsPS9442PS0540rN(CGen_s *this, String_s *out);
none generateFunctionDefinitionsPS9442PS0540rN(CGen_s *this, String_s *out);
none _anon_44_0PS9442PS0540S6070PU5175PS2435uszrN(CGen_s *this, String_s *out, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent);
none generateGlobalVariablesPS9442PS0540rN(CGen_s *this, String_s *out);
String_s _anon_44_1PS9442S6070PS2435uszrS0540(CGen_s *this, Token_s tkn, ParsedExpr_s *expr, usize indent);
String_s generateGlobalInitPS9442PS1100uszrS0540(CGen_s *this, ParsedStmt_s *_decl, usize indent);
none generateGlobalInitializationPS9442PS0540rN(CGen_s *this, String_s *out);
none transpileToCrN(none);
none generateCCoderN(none);
none generateBuildScriptrN(none);
none generateClexeScriptrN(none);
none generateGCCScriptrN(none);
none generateClangScriptrN(none);
none generateEntrypointPS0540rN(String_s *out);
none forwardDeclareTuplePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateTupleDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none forwardDeclareArrayPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateArrayDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none forwardDeclareStructPS0540PS5521rN(String_s *out, ParsedStructDecl_s *strukt);
none generateStructDefinitionPS9442PS0540PS5521rN(CGen_s *this, String_s *out, ParsedStructDecl_s *strukt);
none forwardDeclareUnionPS0540PS0997rN(String_s *out, ParsedUnionDecl_s *onion);
none generateUnionDefinitionPS9442PS0540PS0997rN(CGen_s *this, String_s *out, ParsedUnionDecl_s *onion);
none forwardDeclareFunctionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function);
none generateFunctionDefinitionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function);
none emitFunctionSignaturePS9442PS0540S0540PS4904rN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function);
none emitFunctionSignaturePS9442PS0540S0540PS4904BrN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function, bool generateVariadics);
String_s generateBlockPS9442PS7247uszrS0540(CGen_s *this, ParsedBlock_s *block, usize indent);
String_s generateIndentuszrS0540(usize indent);
String_s generateStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent);
String_s _anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540(CGen_s *this, String_s *tmpAlloc, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent);
String_s generateVarDeclPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *_decl, usize indent);
String_s generateMatchStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent);
tuple_4431 generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s expr, Type_u *type, usize indent);
tuple_4431 generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent);
tuple_4431 generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent);
tuple_4431 generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                   usize indent);
String_s generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
String_s _generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
String_s generateTypeInfoPS9442S8951PU5175rS0540(CGen_s *this, Span_s span, Type_u *type);
String_s generateUnionInitPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *init);
bool isCLValuePS2435rB(ParsedExpr_s *this);
String_s generateUnaryExprPS9442PS0540PU5427rS0540(CGen_s *this, String_s *tmpAlloc, UnaryExpr_u *unary);
String_s generateBinaryExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
i32 maini32PPcri32(i32 argc, char **argv);
bool findStdAndAddToImportsPS2466rB(Parser_s *parser);
char *getBufoPathrPc(none);
bool linkExecutablerB(none);
i32 __real_main(i32 argc, char **argv, i32 (*main)(i32, char **));

// Global Variables:
FlagParser_s flagParser;
Flags_s flags;
SubStr_s OS_WINDOWS;
SubStr_s OS_LINUX;
char *FATAL_STR;
char *ERR_STR;
char *WARN_STR;
char *NOTE_STR;
u32 U32_MAX;
Any stdin_;
Any stdout_;
Any stderr_;
bool done;
bool PRINT_WARNING;
u8 ORDER_LESS;
u8 ORDER_EQUAL;
u8 ORDER_GREATER;
array_5216 HEX_CHAR;
usize INITIAL_STRINGBUFFER_CAP;
Handle_s INVALID_HANDLE;
u32 STD_INPUT_HANDLE;
u32 STD_OUTPUT_HANDLE;
u32 STD_ERROR_HANDLE;
u32 STARTF_USESTDHANDLES;
u32 FILE_SHARE_READ;
u32 FILE_SHARE_WRITE;
u32 GENERIC_READ;
u32 OPEN_EXISTING;
u32 INFINITE;
u32 WAIT_FAILED;
u32 FORMAT_MESSAGE_ALLOCATE_BUFFER;
u32 FORMAT_MESSAGE_FROM_SYSTEM;
u32 FORMAT_MESSAGE_IGNORE_INSERTS;
u32 FILE_ATTRIBUTE_NORMAL;
u32 FILE_ATTRIBUTE_DIRECTORY;
u32 INVALID_FILE_ATTRIBUTES;
usize NODE_ID_OFFSET;
bool ignoringNodes;
ParsedFileArena_s files;
ParsedTopLevelItemArena_s topLevelItems;
ParsedModuleArena_s modules;
ParsedStructDeclArena_s structDecls;
ParsedUnionDeclArena_s unionDecls;
ParsedUnionVariantArena_s unionVariants;
ParsedFuncDeclArena_s funcDecls;
ParsedBlockArena_s blocks;
ParsedStmtArena_s stmts;
ParsedTypeNodeArena_s typeNodes;
ParsedExprArena_s exprs;
ParsedConfigArena_s configs;
DLLArena_s dlls;
ParsedPatternArena_s patterns;
SubStr_s _ATTR_EXTERN;
SubStr_s _ATTR_OS;
SubStr_s _ATTR_NORETURN;
SubStr_s _ATTR_NAKED;
SubStr_s _ATTR_NO_MANGLE;
usize TLI_INVALID;
usize TLI_IMPORT;
usize TLI_VAR_DECL;
usize TLI_STRUCT_DECL;
usize TLI_UNION_DECL;
usize TLI_FUNC_DECL;
usize TLI_MOD_DECL;
usize TLI_CONFIG;
usize DLL_NOT_FOUND;
usize DLL_NO_SUCH_FUNCTION;
usize PARSED_TYPE_INVALID;
usize PARSED_TYPE_UNKNOWN;
usize PARSED_TYPE_NONE;
usize PARSED_TYPE_ANY;
usize PARSED_TYPE_BLANK;
usize PARSED_TYPE_I8;
usize PARSED_TYPE_I16;
usize PARSED_TYPE_I32;
usize PARSED_TYPE_I64;
usize PARSED_TYPE_U8;
usize PARSED_TYPE_U16;
usize PARSED_TYPE_U32;
usize PARSED_TYPE_U64;
usize PARSED_TYPE_USIZE;
usize PARSED_TYPE_BOOL;
usize PARSED_TYPE_CHAR;
usize PARSED_TYPE_IDENT;
usize PARSED_TYPE_REF;
usize PARSED_TYPE_ARRAY;
usize PARSED_TYPE_F32;
usize PARSED_TYPE_F64;
usize PARSED_TYPE_FUNC;
usize PARSED_TYPE_MODULE;
usize PARSED_TYPE_VARIADIC;
usize PARSED_TYPE_TUPLE;
usize PARSED_TYPE_BUILTIN;
SubStr_s ANY;
SubStr_s I8;
SubStr_s I16;
SubStr_s I32;
SubStr_s I64;
SubStr_s U8;
SubStr_s U16;
SubStr_s U32;
SubStr_s U64;
SubStr_s USIZE;
SubStr_s F32;
SubStr_s F64;
SubStr_s BOOL;
SubStr_s CHAR;
i32 LLVMVoidTypeKind;
i32 LLVMHalfTypeKind;
i32 LLVMFloatTypeKind;
i32 LLVMDoubleTypeKind;
i32 LLVMX86_FP80TypeKind;
i32 LLVMFP128TypeKind;
i32 LLVMPPC_FP128TypeKind;
i32 LLVMLabelTypeKind;
i32 LLVMIntegerTypeKind;
i32 LLVMFunctionTypeKind;
i32 LLVMStructTypeKind;
i32 LLVMArrayTypeKind;
i32 LLVMPointerTypeKind;
i32 LLVMVectorTypeKind;
i32 LLVMMetadataTypeKind;
i32 LLVMTokenTypeKind;
i32 LLVMScalableVectorTypeKind;
i32 LLVMBFloatTypeKind;
i32 LLVMX86_AMXTypeKind;
i32 LLVMTargetExtTypeKind;
i32 LLVMIntEQ;
i32 LLVMIntNE;
i32 LLVMIntUGT;
i32 LLVMIntUGE;
i32 LLVMIntULT;
i32 LLVMIntULE;
i32 LLVMIntSGT;
i32 LLVMIntSGE;
i32 LLVMIntSLT;
i32 LLVMIntSLE;
i32 LLVMRealPredicateFalse;
i32 LLVMRealOEQ;
i32 LLVMRealOGT;
i32 LLVMRealOGE;
i32 LLVMRealOLT;
i32 LLVMRealOLE;
i32 LLVMRealONE;
i32 LLVMRealORD;
i32 LLVMRealUNO;
i32 LLVMRealUEQ;
i32 LLVMRealUGT;
i32 LLVMRealUGE;
i32 LLVMRealULT;
i32 LLVMRealULE;
i32 LLVMRealUNE;
i32 LLVMRealPredicateTrue;
i32 LLVMAbortProcessAction;
i32 LLVMPrintMessageAction;
i32 LLVMReturnStatusAction;
i32 LLVMAssemblyFile;
i32 LLVMObjectFile;
i32 LLVMDIFlagZero;
i32 LLVMDIFlagPrivate;
i32 LLVMDIFlagProtected;
i32 LLVMDIFlagPublic;
i32 LLVMDIFlagFwdDecl;
i32 LLVMDIFlagAppleBlock;
i32 LLVMDIFlagReservedBit4;
i32 LLVMDIFlagVirtual;
i32 LLVMDIFlagArtificial;
i32 LLVMDIFlagExplicit;
i32 LLVMDIFlagPrototyped;
i32 LLVMDIFlagObjcClassComplete;
i32 LLVMDIFlagObjectPointer;
i32 LLVMDIFlagVector;
i32 LLVMDIFlagStaticMember;
i32 LLVMDIFlagLValueReference;
i32 LLVMDIFlagRValueReference;
i32 LLVMDIFlagReserved;
i32 LLVMDIFlagSingleInheritance;
i32 LLVMDIFlagMultipleInheritance;
i32 LLVMDIFlagVirtualInheritance;
i32 LLVMDIFlagIntroducedVirtual;
i32 LLVMDIFlagBitField;
i32 LLVMDIFlagNoReturn;
i32 LLVMDIFlagTypePassByValue;
i32 LLVMDIFlagTypePassByReference;
i32 LLVMDIFlagEnumClass;
i32 LLVMDIFlagFixedEnum;
i32 LLVMDIFlagThunk;
i32 LLVMDIFlagNonTrivial;
i32 LLVMDIFlagBigEndian;
i32 LLVMDIFlagLittleEndian;
i32 LLVMDIFlagIndirectVirtualBase;
i32 LLVMDIFlagAccessibility;
i32 LLVMDIFlagPtrToMemberRep;
i32 LLVMDWARFEmissionKindNone;
i32 LLVMDWARFEmissionKindFull;
i32 LLVMDWARFEmissionKindLineTablesOnly;
i32 LLVMDWARFSourceLanguageC89;
i32 LLVMDWARFSourceLanguageC;
i32 LLVMDWARFSourceLanguageAda83;
i32 LLVMDWARFSourceLanguageC_plus_plus;
i32 LLVMDWARFSourceLanguageCobol74;
i32 LLVMDWARFSourceLanguageCobol85;
i32 LLVMDWARFSourceLanguageFortran77;
i32 LLVMDWARFSourceLanguageFortran90;
i32 LLVMDWARFSourceLanguagePascal83;
i32 LLVMDWARFSourceLanguageModula2;
i32 LLVMDWARFSourceLanguageJava;
i32 LLVMDWARFSourceLanguageC99;
i32 LLVMDWARFSourceLanguageAda95;
i32 LLVMDWARFSourceLanguageFortran95;
i32 LLVMDWARFSourceLanguagePLI;
i32 LLVMDWARFSourceLanguageObjC;
i32 LLVMDWARFSourceLanguageObjC_plus_plus;
i32 LLVMDWARFSourceLanguageUPC;
i32 LLVMDWARFSourceLanguageD;
i32 LLVMDWARFSourceLanguagePython;
i32 LLVMDWARFSourceLanguageOpenCL;
i32 LLVMDWARFSourceLanguageGo;
i32 LLVMDWARFSourceLanguageModula3;
i32 LLVMDWARFSourceLanguageHaskell;
i32 LLVMDWARFSourceLanguageC_plus_plus_03;
i32 LLVMDWARFSourceLanguageC_plus_plus_11;
i32 LLVMDWARFSourceLanguageOCaml;
i32 LLVMDWARFSourceLanguageRust;
i32 LLVMDWARFSourceLanguageC11;
i32 LLVMDWARFSourceLanguageSwift;
i32 LLVMDWARFSourceLanguageJulia;
i32 LLVMDWARFSourceLanguageDylan;
i32 LLVMDWARFSourceLanguageC_plus_plus_14;
i32 LLVMDWARFSourceLanguageFortran03;
i32 LLVMDWARFSourceLanguageFortran08;
i32 LLVMDWARFSourceLanguageRenderScript;
i32 LLVMDWARFSourceLanguageBLISS;
i32 LLVMDWARFSourceLanguageKotlin;
i32 LLVMDWARFSourceLanguageZig;
i32 LLVMDWARFSourceLanguageCrystal;
i32 LLVMDWARFSourceLanguageC_plus_plus_17;
i32 LLVMDWARFSourceLanguageC_plus_plus_20;
i32 LLVMDWARFSourceLanguageC17;
i32 LLVMDWARFSourceLanguageFortran18;
i32 LLVMDWARFSourceLanguageAda2005;
i32 LLVMDWARFSourceLanguageAda2012;
i32 LLVMDWARFSourceLanguageHIP;
i32 LLVMDWARFSourceLanguageAssembly;
i32 LLVMDWARFSourceLanguageC_sharp;
i32 LLVMDWARFSourceLanguageMojo;
i32 LLVMDWARFSourceLanguageGLSL;
i32 LLVMDWARFSourceLanguageGLSL_ES;
i32 LLVMDWARFSourceLanguageHLSL;
i32 LLVMDWARFSourceLanguageOpenCL_CPP;
i32 LLVMDWARFSourceLanguageCPP_for_OpenCL;
i32 LLVMDWARFSourceLanguageSYCL;
i32 LLVMDWARFSourceLanguageRuby;
i32 LLVMDWARFSourceLanguageMove;
i32 LLVMDWARFSourceLanguageHylo;
i32 LLVMDWARFSourceLanguageMetal;
i32 LLVMDWARFSourceLanguageMips_Assembler;
i32 LLVMDWARFSourceLanguageGOOGLE_RenderScript;
i32 LLVMDWARFSourceLanguageBORLAND_Delphi;
i32 LLVMModuleFlagBehaviorError;
i32 LLVMModuleFlagBehaviorWarning;
i32 LLVMModuleFlagBehaviorRequire;
i32 LLVMModuleFlagBehaviorOverride;
i32 LLVMModuleFlagBehaviorAppend;
i32 LLVMModuleFlagBehaviorAppendUnique;
usize TOKEN_EOF;
usize TOKEN_IDENT;
usize TOKEN_KEYWORD;
usize TOKEN_STRING_LITERAL;
usize TOKEN_INT_LITERAL;
usize TOKEN_CHAR_LITERAL;
usize TOKEN_PAREN_OPEN;
usize TOKEN_PAREN_CLOSE;
usize TOKEN_CURLY_OPEN;
usize TOKEN_CURLY_CLOSE;
usize TOKEN_SQUARE_OPEN;
usize TOKEN_SQUARE_CLOSE;
usize TOKEN_SEMI_COLON;
usize TOKEN_COLON_SINGLE;
usize TOKEN_COLON_DOUBLE;
usize TOKEN_EQUAL_SINGLE;
usize TOKEN_EQUAL_DOUBLE;
usize TOKEN_AMPERSAND_SINGLE;
usize TOKEN_AMPERSAND_DOUBLE;
usize TOKEN_COMMA;
usize TOKEN_ARROW_THIN;
usize TOKEN_ARROW_THICK;
usize TOKEN_PLUS_SINGLE;
usize TOKEN_UNDERSCORE;
usize TOKEN_DOT;
usize TOKEN_AT;
usize TOKEN_MINUS_SINGLE;
usize TOKEN_ASTERISK_SINGLE;
usize TOKEN_NOT_EQUAL;
usize TOKEN_BANG;
usize TOKEN_SLASH_SINGLE;
usize TOKEN_LESS_THAN_EQUAL;
usize TOKEN_LESS_THAN;
usize TOKEN_GREATER_THAN_EQUAL;
usize TOKEN_GREATER_THAN;
usize TOKEN_PERCENT;
usize TOKEN_PIPE_SINGLE;
usize TOKEN_PIPE_DOUBLE;
usize TOKEN_DOTDOT;
usize TOKEN_DOTDOTDOT;
usize TOKEN_CARET;
usize TOKEN_WILDCARD;
usize PRIM_TYPE_COUNT;
TypeArena_s types;
LLVMMetadataArena_s debugTypes;
TypeInfo_u *type_info_table;
usize ARENA_SIZE_SMALL;
usize ARENA_SIZE_MEDIUM;
usize ARENA_SIZE_LARGE;
usize ARENA_SIZE_HUGE;
usize ELSE_BIT;
SubStr_s KEYWORD_LET;
SubStr_s KEYWORD_COMPTIME;
SubStr_s KEYWORD_FUNC;
SubStr_s KEYWORD_STRUCT;
SubStr_s KEYWORD_ENUM;
SubStr_s KEYWORD_UNION;
SubStr_s KEYWORD_RETURN;
SubStr_s KEYWORD_MODULE;
SubStr_s KEYWORD_IMPORT;
SubStr_s KEYWORD_IF;
SubStr_s KEYWORD_ELSE;
SubStr_s KEYWORD_WHILE;
SubStr_s KEYWORD_SIZEOF;
SubStr_s KEYWORD_AS;
SubStr_s KEYWORD_FOR;
SubStr_s KEYWORD_BREAK;
SubStr_s KEYWORD_CONTINUE;
SubStr_s KEYWORD_NULL;
SubStr_s KEYWORD_BLANK;
SubStr_s KEYWORD_TRUE;
SubStr_s KEYWORD_FALSE;
SubStr_s KEYWORD_CONFIG;
SubStr_s KEYWORD_MATCH;
SubStr_s KEYWORD_ASM;
SubStr_s KEYWORD_TYPEINFO;
usize ERROR_INVALID;
usize ERROR_NO_SUCH_MODULE;
usize ERROR_NO_SUCH_IDENTIFIER;
usize ERROR_NO_SUCH_FUNCTION;
usize ERROR_NO_SUCH_METHOD;
usize ERROR_NO_SUCH_TYPE;
usize ERROR_USE_BEFORE_DECLARATION;
usize ERROR_FIELD_COUNT_MISMATCH;
usize ERROR_INDEXED_TYPE_MISMATCH;
usize ERROR_UNEXPECTED_LITERAL;
usize ERROR_ARRAY_SIZE_MISMATCH;
usize ERROR_TYPE_MISMATCH;
usize ERROR_INVALID_POINTER_ARITHMETIC;
usize ERROR_DUPLICATE_PARAMETER;
usize ERROR_DUPLICATE_FIELD;
usize ERROR_UNKNOWN_FIELD;
usize ERROR_DUPLICATE_FUNCTION;
usize ERROR_NO_CALL_CANDIDATE;
usize ERROR_VARIABLE_REDECLARATION;
usize ERROR_RECURSIVE_TYPE;
usize ERROR_DUPLICATE_METHOD;
usize ERROR_BLANK_FOR_NULL;
usize ERROR_NON_PRIMITIVE_CAST;
usize ERROR_INDEXED_ACCESS_ON_NON_ARRAY;
usize ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT;
usize ERROR_ANY_DEREF;
usize ERROR_MEMBER_ACCESS_NON_STRUCT;
usize ERROR_MEMBER_ACCESS_NO_OPTIONS;
usize ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS;
usize ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS;
usize ERROR_CALL_TO_NON_FUNCTION;
usize ERROR_UNKNOWN_SUBMODULE;
usize ERROR_MODULE_ACCESS_NON_MODULE;
usize ERROR_DEREF_NON_POINTER;
usize ERROR_DUPLICATE_UNION_VARIANT;
usize ERROR_DUPLICATE_UNION_NAME;
usize ERROR_NON_EXHAUSTIVE_MATCH;
usize ERROR_IMPOSSIBLE_PATTERN;
usize ERROR_NULL_NON_PTR;
usize ERROR_FILE_MISSING;
usize ERROR_ASSEMBLY_IN_COMPTIME_CONTEXT;
usize ERROR_NAKED_STATEMENT;
usize ERROR_INVALID_VARIANT_INIT;
usize ERROR_NO_SUCH_VARIANT;
usize ERROR_INFER_FAILED;
usize ERROR_MISSING_TRAMPOLINE;
u32 IDENT_NONE;
u32 IDENT_FUNC;
u32 IDENT_VAR;
u32 IDENT_TYPE;
usize TYPE_LOOKUP_INVALID;
usize TYPE_LOOKUP_STRUCT;
usize TYPE_LOOKUP_UNION;
bool syntaxError;
bool needsPrelude;
bool needsAssembly;
bool needsTypeInfo;
usize INSTR_INVALID;
usize INSTR_ALLOCA;
usize INSTR_GET_PARAM;
usize INSTR_STORE;
usize INSTR_FETCH_GLOBAL_PTR;
usize INSTR_FETCH_GLOBAL_VALUE;
usize INSTR_FETCH_COMPTIME_VALUE;
usize INSTR_LOAD_FUNCTION_PTR;
usize INSTR_LOAD;
usize INSTR_MOVE;
usize INSTR_CALL;
usize INSTR_RETURN_EXPR;
usize INSTR_RETURN_VOID;
usize INSTR_LOAD_STRING;
usize INSTR_LOAD_BOOL;
usize INSTR_LOAD_I8;
usize INSTR_LOAD_U8;
usize INSTR_LOAD_I16;
usize INSTR_LOAD_U16;
usize INSTR_LOAD_I32;
usize INSTR_LOAD_U32;
usize INSTR_LOAD_I64;
usize INSTR_LOAD_U64;
usize INSTR_LOAD_NULL;
usize INSTR_LOAD_F32;
usize INSTR_LOAD_F64;
usize INSTR_LOAD_BLANK;
usize INSTR_COND_BR;
usize INSTR_BR;
usize INSTR_INT_ADD;
usize INSTR_INT_SUB;
usize INSTR_INT_MUL;
usize INSTR_INT_DIV;
usize INSTR_INT_MOD;
usize INSTR_INT_CMP_EQ;
usize INSTR_INT_CMP_NEQ;
usize INSTR_INT_CMP_GT;
usize INSTR_INT_CMP_GTE;
usize INSTR_INT_CMP_LT;
usize INSTR_INT_CMP_LTE;
usize INSTR_FLOAT_ADD;
usize INSTR_FLOAT_SUB;
usize INSTR_FLOAT_MUL;
usize INSTR_FLOAT_DIV;
usize INSTR_FLOAT_MOD;
usize INSTR_FLOAT_CMP_EQ;
usize INSTR_FLOAT_CMP_NEQ;
usize INSTR_FLOAT_CMP_GT;
usize INSTR_FLOAT_CMP_GTE;
usize INSTR_FLOAT_CMP_LT;
usize INSTR_FLOAT_CMP_LTE;
usize INSTR_LOGICAL_NOT;
usize INSTR_LOGICAL_AND;
usize INSTR_LOGICAL_OR;
usize INSTR_BITWISE_AND;
usize INSTR_BITWISE_OR;
usize INSTR_BITWISE_XOR;
usize INSTR_INSERT_VALUE;
usize INSTR_INT_SIGN_EXTEND;
usize INSTR_INT_ZERO_EXTEND;
usize INSTR_INT_TRUNCATE;
usize INSTR_INT_TO_F32;
usize INSTR_INT_TO_F64;
usize INSTR_F32_TO_INT;
usize INSTR_F64_TO_INT;
usize INSTR_F32_TO_F64;
usize INSTR_F64_TO_F32;
usize INSTR_CREATE_ARRAY;
usize INSTR_CREATE_STRUCT;
usize INSTR_CREATE_UNION;
usize INSTR_PTR_TO_INT;
usize INSTR_INT_TO_PTR;
usize INSTR_GET_FIELD_PTR;
usize INSTR_GET_ELEMENT_PTR;
usize INSTR_UNREACHABLE;
usize INSTR_UNTERMINATED;
usize INSTR_MEMCPY;
usize INSTR_EMIT_ASSEMBLY;
usize INSTR_INTO_IR_VALUE;
usize INSTR_DEBUG_INFO_ALLOCA;
usize INSTR_DEBUG_INFO_PARAM;
usize PARAM_SHIFT;
usize REG_STACK_SIZE;
usize STACK_SIZE;
array_5263 instrFns;
GPR_s RAX;
GPR_s RCX;
GPR_s RDX;
GPR_s RBX;
GPR_s RSP;
GPR_s RBP;
GPR_s RSI;
GPR_s RDI;
GPR_s R8;
GPR_s R9;
GPR_s R10;
GPR_s R11;
GPR_s R12;
GPR_s R13;
GPR_s R14;
GPR_s R15;
FPR_s XMM0;
FPR_s XMM1;
FPR_s XMM2;
FPR_s XMM3;
FPR_s XMM4;
FPR_s XMM5;
u8 ADDR_INDIRECT;
u8 ADDR_DISP8;
u8 ADDR_DISP32;
u8 ADDR_REG;
u32 DW_ATE_address;
u32 DW_ATE_boolean;
u32 DW_ATE_complex_float;
u32 DW_ATE_float;
u32 DW_ATE_signed;
u32 DW_ATE_signed_char;
u32 DW_ATE_unsigned;
u32 DW_ATE_unsigned_char;
u32 DW_ATE_imaginary_float;
u32 DW_ATE_packed_decimal;
u32 DW_ATE_numeric_string;
u32 DW_ATE_edited;
u32 DW_ATE_signed_fixed;
u32 DW_ATE_unsigned_fixed;
u32 DW_ATE_decimal_float;
u32 DW_ATE_UTF;
u32 DW_ATE_UCS;
u32 DW_ATE_ASCII;
u32 DW_ATE_lo_user;
u32 DW_ATE_hi_user;
usize FLAG_INVALID;
usize FLAG_STRING;
usize FLAG_BOOL;
usize FLAG_MODE_DEFAULT;
usize FLAG_MODE_SINGLE;
usize FLAG_MODE_MANDATORY;
usize INDENTATION_LEVEL;
none __global_init_please_dont_call_yourself(none) {
    flagParser = ((FlagParser_s){0});
    flags = ((Flags_s){0});
    OS_WINDOWS = ((comptimeSubStrPcrS7720)(("WINDOWS")));
    OS_LINUX = ((comptimeSubStrPcrS7720)(("LINUX")));
    FATAL_STR = ("\x1B[95m[FATAL]\x1B[0m");
    ERR_STR = ("\x1B[91merror\x1B[0m");
    WARN_STR = ("\x1B[93mwarning\x1B[0m");
    NOTE_STR = ("\x1B[92mnote\x1B[0m");
    U32_MAX = (((u32)(0)) - ((u32)(1)));
    stdin_ = (NULL);
    stdout_ = (NULL);
    stderr_ = (NULL);
    done = (false);
    PRINT_WARNING = (true);
    ORDER_LESS = ((u8)(0));
    ORDER_EQUAL = ((u8)(1));
    ORDER_GREATER = ((u8)(2));
    HEX_CHAR = ((array_5216){('0'), ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7'), ('8'), ('9'), ('A'), ('B'), ('C'), ('D'), ('E'), ('F')});
    INITIAL_STRINGBUFFER_CAP = ((usize)(16llu));
    INVALID_HANDLE = ((Handle_s){.ptr = ((usize)(18446744073709551615llu))});
    STD_INPUT_HANDLE = ((u32)(4294967286));
    STD_OUTPUT_HANDLE = ((u32)(4294967285));
    STD_ERROR_HANDLE = ((u32)(4294967284));
    STARTF_USESTDHANDLES = ((u32)(4));
    FILE_SHARE_READ = ((u32)(1));
    FILE_SHARE_WRITE = ((u32)(2));
    GENERIC_READ = ((u32)(2147483648));
    OPEN_EXISTING = ((u32)(3));
    INFINITE = ((u32)(999999999));
    WAIT_FAILED = ((u32)(4294967295));
    FORMAT_MESSAGE_ALLOCATE_BUFFER = ((u32)(256));
    FORMAT_MESSAGE_FROM_SYSTEM = ((u32)(4096));
    FORMAT_MESSAGE_IGNORE_INSERTS = ((u32)(512));
    FILE_ATTRIBUTE_NORMAL = ((u32)(128));
    FILE_ATTRIBUTE_DIRECTORY = ((u32)(16));
    INVALID_FILE_ATTRIBUTES = ((u32)(4294967295));
    NODE_ID_OFFSET = ((usize)(10000000000llu));
    ignoringNodes = (false);
    files = ((ParsedFileArena_s){0});
    topLevelItems = ((ParsedTopLevelItemArena_s){0});
    modules = ((ParsedModuleArena_s){0});
    structDecls = ((ParsedStructDeclArena_s){0});
    unionDecls = ((ParsedUnionDeclArena_s){0});
    unionVariants = ((ParsedUnionVariantArena_s){0});
    funcDecls = ((ParsedFuncDeclArena_s){0});
    blocks = ((ParsedBlockArena_s){0});
    stmts = ((ParsedStmtArena_s){0});
    typeNodes = ((ParsedTypeNodeArena_s){0});
    exprs = ((ParsedExprArena_s){0});
    configs = ((ParsedConfigArena_s){0});
    dlls = ((DLLArena_s){0});
    patterns = ((ParsedPatternArena_s){0});
    _ATTR_EXTERN = ((BUILD_A_KEYWORDPcrS7720)(("extern")));
    _ATTR_OS = ((BUILD_A_KEYWORDPcrS7720)(("os")));
    _ATTR_NORETURN = ((BUILD_A_KEYWORDPcrS7720)(("noreturn")));
    _ATTR_NAKED = ((BUILD_A_KEYWORDPcrS7720)(("naked")));
    _ATTR_NO_MANGLE = ((BUILD_A_KEYWORDPcrS7720)(("no_mangle")));
    TLI_INVALID = ((usize)(0llu));
    TLI_IMPORT = ((usize)(1llu));
    TLI_VAR_DECL = ((usize)(2llu));
    TLI_STRUCT_DECL = ((usize)(3llu));
    TLI_UNION_DECL = ((usize)(4llu));
    TLI_FUNC_DECL = ((usize)(5llu));
    TLI_MOD_DECL = ((usize)(6llu));
    TLI_CONFIG = ((usize)(7llu));
    DLL_NOT_FOUND = ((usize)(1llu));
    DLL_NO_SUCH_FUNCTION = ((usize)(2llu));
    PARSED_TYPE_INVALID = ((usize)(0llu));
    PARSED_TYPE_UNKNOWN = ((usize)(1llu));
    PARSED_TYPE_NONE = ((usize)(2llu));
    PARSED_TYPE_ANY = ((usize)(3llu));
    PARSED_TYPE_BLANK = ((usize)(4llu));
    PARSED_TYPE_I8 = ((usize)(5llu));
    PARSED_TYPE_I16 = ((usize)(6llu));
    PARSED_TYPE_I32 = ((usize)(7llu));
    PARSED_TYPE_I64 = ((usize)(8llu));
    PARSED_TYPE_U8 = ((usize)(9llu));
    PARSED_TYPE_U16 = ((usize)(10llu));
    PARSED_TYPE_U32 = ((usize)(11llu));
    PARSED_TYPE_U64 = ((usize)(12llu));
    PARSED_TYPE_USIZE = ((usize)(13llu));
    PARSED_TYPE_BOOL = ((usize)(14llu));
    PARSED_TYPE_CHAR = ((usize)(15llu));
    PARSED_TYPE_IDENT = ((usize)(16llu));
    PARSED_TYPE_REF = ((usize)(17llu));
    PARSED_TYPE_ARRAY = ((usize)(18llu));
    PARSED_TYPE_F32 = ((usize)(19llu));
    PARSED_TYPE_F64 = ((usize)(20llu));
    PARSED_TYPE_FUNC = ((usize)(21llu));
    PARSED_TYPE_MODULE = ((usize)(22llu));
    PARSED_TYPE_VARIADIC = ((usize)(23llu));
    PARSED_TYPE_TUPLE = ((usize)(24llu));
    PARSED_TYPE_BUILTIN = ((usize)(25llu));
    ANY = ((BUILD_A_TYPEPcrS7720)(("Any")));
    I8 = ((BUILD_A_TYPEPcrS7720)(("i8")));
    I16 = ((BUILD_A_TYPEPcrS7720)(("i16")));
    I32 = ((BUILD_A_TYPEPcrS7720)(("i32")));
    I64 = ((BUILD_A_TYPEPcrS7720)(("i64")));
    U8 = ((BUILD_A_TYPEPcrS7720)(("u8")));
    U16 = ((BUILD_A_TYPEPcrS7720)(("u16")));
    U32 = ((BUILD_A_TYPEPcrS7720)(("u32")));
    U64 = ((BUILD_A_TYPEPcrS7720)(("u64")));
    USIZE = ((BUILD_A_TYPEPcrS7720)(("usize")));
    F32 = ((BUILD_A_TYPEPcrS7720)(("f32")));
    F64 = ((BUILD_A_TYPEPcrS7720)(("f64")));
    BOOL = ((BUILD_A_TYPEPcrS7720)(("bool")));
    CHAR = ((BUILD_A_TYPEPcrS7720)(("char")));
    LLVMVoidTypeKind = ((i32)(0));
    LLVMHalfTypeKind = ((i32)(1));
    LLVMFloatTypeKind = ((i32)(2));
    LLVMDoubleTypeKind = ((i32)(3));
    LLVMX86_FP80TypeKind = ((i32)(4));
    LLVMFP128TypeKind = ((i32)(5));
    LLVMPPC_FP128TypeKind = ((i32)(6));
    LLVMLabelTypeKind = ((i32)(7));
    LLVMIntegerTypeKind = ((i32)(8));
    LLVMFunctionTypeKind = ((i32)(9));
    LLVMStructTypeKind = ((i32)(10));
    LLVMArrayTypeKind = ((i32)(11));
    LLVMPointerTypeKind = ((i32)(12));
    LLVMVectorTypeKind = ((i32)(13));
    LLVMMetadataTypeKind = ((i32)(14));
    LLVMTokenTypeKind = ((i32)(16));
    LLVMScalableVectorTypeKind = ((i32)(17));
    LLVMBFloatTypeKind = ((i32)(18));
    LLVMX86_AMXTypeKind = ((i32)(19));
    LLVMTargetExtTypeKind = ((i32)(20));
    LLVMIntEQ = ((i32)(32));
    LLVMIntNE = ((i32)(33));
    LLVMIntUGT = ((i32)(34));
    LLVMIntUGE = ((i32)(35));
    LLVMIntULT = ((i32)(36));
    LLVMIntULE = ((i32)(37));
    LLVMIntSGT = ((i32)(38));
    LLVMIntSGE = ((i32)(39));
    LLVMIntSLT = ((i32)(40));
    LLVMIntSLE = ((i32)(41));
    LLVMRealPredicateFalse = ((i32)(0));
    LLVMRealOEQ = ((i32)(1));
    LLVMRealOGT = ((i32)(2));
    LLVMRealOGE = ((i32)(3));
    LLVMRealOLT = ((i32)(4));
    LLVMRealOLE = ((i32)(5));
    LLVMRealONE = ((i32)(6));
    LLVMRealORD = ((i32)(7));
    LLVMRealUNO = ((i32)(8));
    LLVMRealUEQ = ((i32)(9));
    LLVMRealUGT = ((i32)(10));
    LLVMRealUGE = ((i32)(11));
    LLVMRealULT = ((i32)(12));
    LLVMRealULE = ((i32)(13));
    LLVMRealUNE = ((i32)(14));
    LLVMRealPredicateTrue = ((i32)(15));
    LLVMAbortProcessAction = ((i32)(0));
    LLVMPrintMessageAction = ((i32)(1));
    LLVMReturnStatusAction = ((i32)(2));
    LLVMAssemblyFile = ((i32)(0));
    LLVMObjectFile = ((i32)(1));
    LLVMDIFlagZero = ((i32)(0));
    LLVMDIFlagPrivate = ((i32)(1));
    LLVMDIFlagProtected = ((i32)(2));
    LLVMDIFlagPublic = ((i32)(3));
    LLVMDIFlagFwdDecl = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(2llu))))));
    LLVMDIFlagAppleBlock = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(3llu))))));
    LLVMDIFlagReservedBit4 = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(4llu))))));
    LLVMDIFlagVirtual = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(5llu))))));
    LLVMDIFlagArtificial = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(6llu))))));
    LLVMDIFlagExplicit = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(7llu))))));
    LLVMDIFlagPrototyped = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(8llu))))));
    LLVMDIFlagObjcClassComplete = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(9llu))))));
    LLVMDIFlagObjectPointer = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(10llu))))));
    LLVMDIFlagVector = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(11llu))))));
    LLVMDIFlagStaticMember = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(12llu))))));
    LLVMDIFlagLValueReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(13llu))))));
    LLVMDIFlagRValueReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(14llu))))));
    LLVMDIFlagReserved = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(15llu))))));
    LLVMDIFlagSingleInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(16llu))))));
    LLVMDIFlagMultipleInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(2llu)), ((usize)(16llu))))));
    LLVMDIFlagVirtualInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(3llu)), ((usize)(16llu))))));
    LLVMDIFlagIntroducedVirtual = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(18llu))))));
    LLVMDIFlagBitField = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(19llu))))));
    LLVMDIFlagNoReturn = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(20llu))))));
    LLVMDIFlagTypePassByValue = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(22llu))))));
    LLVMDIFlagTypePassByReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(23llu))))));
    LLVMDIFlagEnumClass = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(24llu))))));
    LLVMDIFlagFixedEnum = (LLVMDIFlagEnumClass);
    LLVMDIFlagThunk = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(25llu))))));
    LLVMDIFlagNonTrivial = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(26llu))))));
    LLVMDIFlagBigEndian = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(27llu))))));
    LLVMDIFlagLittleEndian = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(28llu))))));
    LLVMDIFlagIndirectVirtualBase = (((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(2llu)))))) | ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(5llu)))))));
    LLVMDIFlagAccessibility = (((LLVMDIFlagPrivate) | (LLVMDIFlagProtected)) | (LLVMDIFlagPublic));
    LLVMDIFlagPtrToMemberRep = (((LLVMDIFlagSingleInheritance) | (LLVMDIFlagMultipleInheritance)) | (LLVMDIFlagVirtualInheritance));
    LLVMDWARFEmissionKindNone = ((i32)(0));
    LLVMDWARFEmissionKindFull = ((i32)(1));
    LLVMDWARFEmissionKindLineTablesOnly = ((i32)(2));
    LLVMDWARFSourceLanguageC89 = ((i32)(0));
    LLVMDWARFSourceLanguageC = ((i32)(1));
    LLVMDWARFSourceLanguageAda83 = ((i32)(2));
    LLVMDWARFSourceLanguageC_plus_plus = ((i32)(3));
    LLVMDWARFSourceLanguageCobol74 = ((i32)(4));
    LLVMDWARFSourceLanguageCobol85 = ((i32)(5));
    LLVMDWARFSourceLanguageFortran77 = ((i32)(6));
    LLVMDWARFSourceLanguageFortran90 = ((i32)(7));
    LLVMDWARFSourceLanguagePascal83 = ((i32)(8));
    LLVMDWARFSourceLanguageModula2 = ((i32)(9));
    LLVMDWARFSourceLanguageJava = ((i32)(10));
    LLVMDWARFSourceLanguageC99 = ((i32)(11));
    LLVMDWARFSourceLanguageAda95 = ((i32)(12));
    LLVMDWARFSourceLanguageFortran95 = ((i32)(13));
    LLVMDWARFSourceLanguagePLI = ((i32)(14));
    LLVMDWARFSourceLanguageObjC = ((i32)(15));
    LLVMDWARFSourceLanguageObjC_plus_plus = ((i32)(16));
    LLVMDWARFSourceLanguageUPC = ((i32)(17));
    LLVMDWARFSourceLanguageD = ((i32)(18));
    LLVMDWARFSourceLanguagePython = ((i32)(19));
    LLVMDWARFSourceLanguageOpenCL = ((i32)(20));
    LLVMDWARFSourceLanguageGo = ((i32)(21));
    LLVMDWARFSourceLanguageModula3 = ((i32)(22));
    LLVMDWARFSourceLanguageHaskell = ((i32)(23));
    LLVMDWARFSourceLanguageC_plus_plus_03 = ((i32)(24));
    LLVMDWARFSourceLanguageC_plus_plus_11 = ((i32)(25));
    LLVMDWARFSourceLanguageOCaml = ((i32)(26));
    LLVMDWARFSourceLanguageRust = ((i32)(27));
    LLVMDWARFSourceLanguageC11 = ((i32)(28));
    LLVMDWARFSourceLanguageSwift = ((i32)(29));
    LLVMDWARFSourceLanguageJulia = ((i32)(30));
    LLVMDWARFSourceLanguageDylan = ((i32)(31));
    LLVMDWARFSourceLanguageC_plus_plus_14 = ((i32)(32));
    LLVMDWARFSourceLanguageFortran03 = ((i32)(33));
    LLVMDWARFSourceLanguageFortran08 = ((i32)(34));
    LLVMDWARFSourceLanguageRenderScript = ((i32)(35));
    LLVMDWARFSourceLanguageBLISS = ((i32)(36));
    LLVMDWARFSourceLanguageKotlin = ((i32)(37));
    LLVMDWARFSourceLanguageZig = ((i32)(38));
    LLVMDWARFSourceLanguageCrystal = ((i32)(39));
    LLVMDWARFSourceLanguageC_plus_plus_17 = ((i32)(40));
    LLVMDWARFSourceLanguageC_plus_plus_20 = ((i32)(41));
    LLVMDWARFSourceLanguageC17 = ((i32)(42));
    LLVMDWARFSourceLanguageFortran18 = ((i32)(43));
    LLVMDWARFSourceLanguageAda2005 = ((i32)(44));
    LLVMDWARFSourceLanguageAda2012 = ((i32)(45));
    LLVMDWARFSourceLanguageHIP = ((i32)(46));
    LLVMDWARFSourceLanguageAssembly = ((i32)(47));
    LLVMDWARFSourceLanguageC_sharp = ((i32)(48));
    LLVMDWARFSourceLanguageMojo = ((i32)(49));
    LLVMDWARFSourceLanguageGLSL = ((i32)(50));
    LLVMDWARFSourceLanguageGLSL_ES = ((i32)(51));
    LLVMDWARFSourceLanguageHLSL = ((i32)(52));
    LLVMDWARFSourceLanguageOpenCL_CPP = ((i32)(53));
    LLVMDWARFSourceLanguageCPP_for_OpenCL = ((i32)(54));
    LLVMDWARFSourceLanguageSYCL = ((i32)(55));
    LLVMDWARFSourceLanguageRuby = ((i32)(56));
    LLVMDWARFSourceLanguageMove = ((i32)(57));
    LLVMDWARFSourceLanguageHylo = ((i32)(58));
    LLVMDWARFSourceLanguageMetal = ((i32)(59));
    LLVMDWARFSourceLanguageMips_Assembler = ((i32)(60));
    LLVMDWARFSourceLanguageGOOGLE_RenderScript = ((i32)(61));
    LLVMDWARFSourceLanguageBORLAND_Delphi = ((i32)(62));
    LLVMModuleFlagBehaviorError = ((i32)(0));
    LLVMModuleFlagBehaviorWarning = ((i32)(1));
    LLVMModuleFlagBehaviorRequire = ((i32)(2));
    LLVMModuleFlagBehaviorOverride = ((i32)(3));
    LLVMModuleFlagBehaviorAppend = ((i32)(4));
    LLVMModuleFlagBehaviorAppendUnique = ((i32)(5));
    TOKEN_EOF = ((usize)(0llu));
    TOKEN_IDENT = ((usize)(1llu));
    TOKEN_KEYWORD = ((usize)(2llu));
    TOKEN_STRING_LITERAL = ((usize)(3llu));
    TOKEN_INT_LITERAL = ((usize)(4llu));
    TOKEN_CHAR_LITERAL = ((usize)(5llu));
    TOKEN_PAREN_OPEN = ((usize)(6llu));
    TOKEN_PAREN_CLOSE = ((usize)(7llu));
    TOKEN_CURLY_OPEN = ((usize)(8llu));
    TOKEN_CURLY_CLOSE = ((usize)(9llu));
    TOKEN_SQUARE_OPEN = ((usize)(10llu));
    TOKEN_SQUARE_CLOSE = ((usize)(11llu));
    TOKEN_SEMI_COLON = ((usize)(12llu));
    TOKEN_COLON_SINGLE = ((usize)(13llu));
    TOKEN_COLON_DOUBLE = ((usize)(14llu));
    TOKEN_EQUAL_SINGLE = ((usize)(15llu));
    TOKEN_EQUAL_DOUBLE = ((usize)(16llu));
    TOKEN_AMPERSAND_SINGLE = ((usize)(17llu));
    TOKEN_AMPERSAND_DOUBLE = ((usize)(18llu));
    TOKEN_COMMA = ((usize)(19llu));
    TOKEN_ARROW_THIN = ((usize)(20llu));
    TOKEN_ARROW_THICK = ((usize)(21llu));
    TOKEN_PLUS_SINGLE = ((usize)(22llu));
    TOKEN_UNDERSCORE = ((usize)(23llu));
    TOKEN_DOT = ((usize)(24llu));
    TOKEN_AT = ((usize)(25llu));
    TOKEN_MINUS_SINGLE = ((usize)(26llu));
    TOKEN_ASTERISK_SINGLE = ((usize)(27llu));
    TOKEN_NOT_EQUAL = ((usize)(28llu));
    TOKEN_BANG = ((usize)(29llu));
    TOKEN_SLASH_SINGLE = ((usize)(30llu));
    TOKEN_LESS_THAN_EQUAL = ((usize)(31llu));
    TOKEN_LESS_THAN = ((usize)(32llu));
    TOKEN_GREATER_THAN_EQUAL = ((usize)(33llu));
    TOKEN_GREATER_THAN = ((usize)(34llu));
    TOKEN_PERCENT = ((usize)(35llu));
    TOKEN_PIPE_SINGLE = ((usize)(36llu));
    TOKEN_PIPE_DOUBLE = ((usize)(37llu));
    TOKEN_DOTDOT = ((usize)(38llu));
    TOKEN_DOTDOTDOT = ((usize)(39llu));
    TOKEN_CARET = ((usize)(40llu));
    TOKEN_WILDCARD = ((usize)(41llu));
    PRIM_TYPE_COUNT = ((usize)(15llu));
    types = ((TypeArena_s){0});
    debugTypes = ((LLVMMetadataArena_s){0});
    type_info_table = (NULL);
    ARENA_SIZE_SMALL = ((usize)(16llu));
    ARENA_SIZE_MEDIUM = ((usize)(128llu));
    ARENA_SIZE_LARGE = ((usize)(1024llu));
    ARENA_SIZE_HUGE = ((usize)(8192llu));
    ELSE_BIT = ((pow2uszrusz)(((usize)(20llu))));
    KEYWORD_LET = ((BUILD_A_KEYWORDPcrS7720)(("let")));
    KEYWORD_COMPTIME = ((BUILD_A_KEYWORDPcrS7720)(("comptime")));
    KEYWORD_FUNC = ((BUILD_A_KEYWORDPcrS7720)(("func")));
    KEYWORD_STRUCT = ((BUILD_A_KEYWORDPcrS7720)(("struct")));
    KEYWORD_ENUM = ((BUILD_A_KEYWORDPcrS7720)(("enum")));
    KEYWORD_UNION = ((BUILD_A_KEYWORDPcrS7720)(("union")));
    KEYWORD_RETURN = ((BUILD_A_KEYWORDPcrS7720)(("return")));
    KEYWORD_MODULE = ((BUILD_A_KEYWORDPcrS7720)(("module")));
    KEYWORD_IMPORT = ((BUILD_A_KEYWORDPcrS7720)(("import")));
    KEYWORD_IF = ((BUILD_A_KEYWORDPcrS7720)(("if")));
    KEYWORD_ELSE = ((BUILD_A_KEYWORDPcrS7720)(("else")));
    KEYWORD_WHILE = ((BUILD_A_KEYWORDPcrS7720)(("while")));
    KEYWORD_SIZEOF = ((BUILD_A_KEYWORDPcrS7720)(("sizeof")));
    KEYWORD_AS = ((BUILD_A_KEYWORDPcrS7720)(("as")));
    KEYWORD_FOR = ((BUILD_A_KEYWORDPcrS7720)(("for")));
    KEYWORD_BREAK = ((BUILD_A_KEYWORDPcrS7720)(("break")));
    KEYWORD_CONTINUE = ((BUILD_A_KEYWORDPcrS7720)(("continue")));
    KEYWORD_NULL = ((BUILD_A_KEYWORDPcrS7720)(("null")));
    KEYWORD_BLANK = ((BUILD_A_KEYWORDPcrS7720)(("blank")));
    KEYWORD_TRUE = ((BUILD_A_KEYWORDPcrS7720)(("true")));
    KEYWORD_FALSE = ((BUILD_A_KEYWORDPcrS7720)(("false")));
    KEYWORD_CONFIG = ((BUILD_A_KEYWORDPcrS7720)(("config")));
    KEYWORD_MATCH = ((BUILD_A_KEYWORDPcrS7720)(("match")));
    KEYWORD_ASM = ((BUILD_A_KEYWORDPcrS7720)(("asm")));
    KEYWORD_TYPEINFO = ((BUILD_A_KEYWORDPcrS7720)(("type_info")));
    ERROR_INVALID = ((usize)(0llu));
    ERROR_NO_SUCH_MODULE = ((usize)(1llu));
    ERROR_NO_SUCH_IDENTIFIER = ((usize)(2llu));
    ERROR_NO_SUCH_FUNCTION = ((usize)(3llu));
    ERROR_NO_SUCH_METHOD = ((usize)(4llu));
    ERROR_NO_SUCH_TYPE = ((usize)(5llu));
    ERROR_USE_BEFORE_DECLARATION = ((usize)(6llu));
    ERROR_FIELD_COUNT_MISMATCH = ((usize)(7llu));
    ERROR_INDEXED_TYPE_MISMATCH = ((usize)(8llu));
    ERROR_UNEXPECTED_LITERAL = ((usize)(9llu));
    ERROR_ARRAY_SIZE_MISMATCH = ((usize)(10llu));
    ERROR_TYPE_MISMATCH = ((usize)(11llu));
    ERROR_INVALID_POINTER_ARITHMETIC = ((usize)(12llu));
    ERROR_DUPLICATE_PARAMETER = ((usize)(13llu));
    ERROR_DUPLICATE_FIELD = ((usize)(14llu));
    ERROR_UNKNOWN_FIELD = ((usize)(15llu));
    ERROR_DUPLICATE_FUNCTION = ((usize)(16llu));
    ERROR_NO_CALL_CANDIDATE = ((usize)(17llu));
    ERROR_VARIABLE_REDECLARATION = ((usize)(18llu));
    ERROR_RECURSIVE_TYPE = ((usize)(19llu));
    ERROR_DUPLICATE_METHOD = ((usize)(20llu));
    ERROR_BLANK_FOR_NULL = ((usize)(21llu));
    ERROR_NON_PRIMITIVE_CAST = ((usize)(22llu));
    ERROR_INDEXED_ACCESS_ON_NON_ARRAY = ((usize)(23llu));
    ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT = ((usize)(24llu));
    ERROR_ANY_DEREF = ((usize)(25llu));
    ERROR_MEMBER_ACCESS_NON_STRUCT = ((usize)(26llu));
    ERROR_MEMBER_ACCESS_NO_OPTIONS = ((usize)(27llu));
    ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS = ((usize)(28llu));
    ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS = ((usize)(29llu));
    ERROR_CALL_TO_NON_FUNCTION = ((usize)(30llu));
    ERROR_UNKNOWN_SUBMODULE = ((usize)(31llu));
    ERROR_MODULE_ACCESS_NON_MODULE = ((usize)(32llu));
    ERROR_DEREF_NON_POINTER = ((usize)(33llu));
    ERROR_DUPLICATE_UNION_VARIANT = ((usize)(34llu));
    ERROR_DUPLICATE_UNION_NAME = ((usize)(35llu));
    ERROR_NON_EXHAUSTIVE_MATCH = ((usize)(36llu));
    ERROR_IMPOSSIBLE_PATTERN = ((usize)(37llu));
    ERROR_NULL_NON_PTR = ((usize)(38llu));
    ERROR_FILE_MISSING = ((usize)(39llu));
    ERROR_ASSEMBLY_IN_COMPTIME_CONTEXT = ((usize)(40llu));
    ERROR_NAKED_STATEMENT = ((usize)(41llu));
    ERROR_INVALID_VARIANT_INIT = ((usize)(42llu));
    ERROR_NO_SUCH_VARIANT = ((usize)(43llu));
    ERROR_INFER_FAILED = ((usize)(44llu));
    ERROR_MISSING_TRAMPOLINE = ((usize)(45llu));
    IDENT_NONE = ((u32)(0));
    IDENT_FUNC = ((u32)(1));
    IDENT_VAR = ((u32)(2));
    IDENT_TYPE = ((u32)(3));
    TYPE_LOOKUP_INVALID = ((usize)(0llu));
    TYPE_LOOKUP_STRUCT = ((usize)(1llu));
    TYPE_LOOKUP_UNION = ((usize)(2llu));
    syntaxError = (false);
    needsPrelude = (false);
    needsAssembly = (false);
    needsTypeInfo = (false);
    INSTR_INVALID = ((usize)(0llu));
    INSTR_ALLOCA = ((usize)(1llu));
    INSTR_GET_PARAM = ((usize)(2llu));
    INSTR_STORE = ((usize)(3llu));
    INSTR_FETCH_GLOBAL_PTR = ((usize)(4llu));
    INSTR_FETCH_GLOBAL_VALUE = ((usize)(5llu));
    INSTR_FETCH_COMPTIME_VALUE = ((usize)(6llu));
    INSTR_LOAD_FUNCTION_PTR = ((usize)(7llu));
    INSTR_LOAD = ((usize)(8llu));
    INSTR_MOVE = ((usize)(9llu));
    INSTR_CALL = ((usize)(10llu));
    INSTR_RETURN_EXPR = ((usize)(11llu));
    INSTR_RETURN_VOID = ((usize)(12llu));
    INSTR_LOAD_STRING = ((usize)(13llu));
    INSTR_LOAD_BOOL = ((usize)(14llu));
    INSTR_LOAD_I8 = ((usize)(15llu));
    INSTR_LOAD_U8 = ((usize)(16llu));
    INSTR_LOAD_I16 = ((usize)(17llu));
    INSTR_LOAD_U16 = ((usize)(18llu));
    INSTR_LOAD_I32 = ((usize)(19llu));
    INSTR_LOAD_U32 = ((usize)(20llu));
    INSTR_LOAD_I64 = ((usize)(21llu));
    INSTR_LOAD_U64 = ((usize)(22llu));
    INSTR_LOAD_NULL = ((usize)(23llu));
    INSTR_LOAD_F32 = ((usize)(24llu));
    INSTR_LOAD_F64 = ((usize)(25llu));
    INSTR_LOAD_BLANK = ((usize)(26llu));
    INSTR_COND_BR = ((usize)(27llu));
    INSTR_BR = ((usize)(28llu));
    INSTR_INT_ADD = ((usize)(29llu));
    INSTR_INT_SUB = ((usize)(30llu));
    INSTR_INT_MUL = ((usize)(31llu));
    INSTR_INT_DIV = ((usize)(32llu));
    INSTR_INT_MOD = ((usize)(33llu));
    INSTR_INT_CMP_EQ = ((usize)(34llu));
    INSTR_INT_CMP_NEQ = ((usize)(35llu));
    INSTR_INT_CMP_GT = ((usize)(36llu));
    INSTR_INT_CMP_GTE = ((usize)(37llu));
    INSTR_INT_CMP_LT = ((usize)(38llu));
    INSTR_INT_CMP_LTE = ((usize)(39llu));
    INSTR_FLOAT_ADD = ((usize)(40llu));
    INSTR_FLOAT_SUB = ((usize)(41llu));
    INSTR_FLOAT_MUL = ((usize)(42llu));
    INSTR_FLOAT_DIV = ((usize)(43llu));
    INSTR_FLOAT_MOD = ((usize)(44llu));
    INSTR_FLOAT_CMP_EQ = ((usize)(45llu));
    INSTR_FLOAT_CMP_NEQ = ((usize)(46llu));
    INSTR_FLOAT_CMP_GT = ((usize)(47llu));
    INSTR_FLOAT_CMP_GTE = ((usize)(48llu));
    INSTR_FLOAT_CMP_LT = ((usize)(49llu));
    INSTR_FLOAT_CMP_LTE = ((usize)(50llu));
    INSTR_LOGICAL_NOT = ((usize)(51llu));
    INSTR_LOGICAL_AND = ((usize)(52llu));
    INSTR_LOGICAL_OR = ((usize)(53llu));
    INSTR_BITWISE_AND = ((usize)(54llu));
    INSTR_BITWISE_OR = ((usize)(55llu));
    INSTR_BITWISE_XOR = ((usize)(56llu));
    INSTR_INSERT_VALUE = ((usize)(57llu));
    INSTR_INT_SIGN_EXTEND = ((usize)(58llu));
    INSTR_INT_ZERO_EXTEND = ((usize)(59llu));
    INSTR_INT_TRUNCATE = ((usize)(60llu));
    INSTR_INT_TO_F32 = ((usize)(61llu));
    INSTR_INT_TO_F64 = ((usize)(62llu));
    INSTR_F32_TO_INT = ((usize)(63llu));
    INSTR_F64_TO_INT = ((usize)(64llu));
    INSTR_F32_TO_F64 = ((usize)(65llu));
    INSTR_F64_TO_F32 = ((usize)(66llu));
    INSTR_CREATE_ARRAY = ((usize)(67llu));
    INSTR_CREATE_STRUCT = ((usize)(68llu));
    INSTR_CREATE_UNION = ((usize)(69llu));
    INSTR_PTR_TO_INT = ((usize)(70llu));
    INSTR_INT_TO_PTR = ((usize)(71llu));
    INSTR_GET_FIELD_PTR = ((usize)(72llu));
    INSTR_GET_ELEMENT_PTR = ((usize)(73llu));
    INSTR_UNREACHABLE = ((usize)(74llu));
    INSTR_UNTERMINATED = ((usize)(75llu));
    INSTR_MEMCPY = ((usize)(76llu));
    INSTR_EMIT_ASSEMBLY = ((usize)(77llu));
    INSTR_INTO_IR_VALUE = ((usize)(78llu));
    INSTR_DEBUG_INFO_ALLOCA = ((usize)(79llu));
    INSTR_DEBUG_INFO_PARAM = ((usize)(80llu));
    PARAM_SHIFT = ((usize)(6llu));
    REG_STACK_SIZE = ((usize)(16777216llu));
    STACK_SIZE = ((usize)(4194304llu));
    instrFns = ((array_5263){(evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateAllocaPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetParamPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateStorePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateMovePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCondBrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntAddPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntSubPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntMulPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntModPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatModPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925),
                             (evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925)});
    RAX = ((GPR_s){.r = ((u8)(0))});
    RCX = ((GPR_s){.r = ((u8)(1))});
    RDX = ((GPR_s){.r = ((u8)(2))});
    RBX = ((GPR_s){.r = ((u8)(3))});
    RSP = ((GPR_s){.r = ((u8)(4))});
    RBP = ((GPR_s){.r = ((u8)(5))});
    RSI = ((GPR_s){.r = ((u8)(6))});
    RDI = ((GPR_s){.r = ((u8)(7))});
    R8 = ((GPR_s){.r = ((u8)(8))});
    R9 = ((GPR_s){.r = ((u8)(9))});
    R10 = ((GPR_s){.r = ((u8)(10))});
    R11 = ((GPR_s){.r = ((u8)(11))});
    R12 = ((GPR_s){.r = ((u8)(12))});
    R13 = ((GPR_s){.r = ((u8)(13))});
    R14 = ((GPR_s){.r = ((u8)(14))});
    R15 = ((GPR_s){.r = ((u8)(15))});
    XMM0 = ((FPR_s){.r = ((u8)(0))});
    XMM1 = ((FPR_s){.r = ((u8)(1))});
    XMM2 = ((FPR_s){.r = ((u8)(2))});
    XMM3 = ((FPR_s){.r = ((u8)(3))});
    XMM4 = ((FPR_s){.r = ((u8)(4))});
    XMM5 = ((FPR_s){.r = ((u8)(5))});
    ADDR_INDIRECT = ((u8)(0));
    ADDR_DISP8 = ((u8)(1));
    ADDR_DISP32 = ((u8)(2));
    ADDR_REG = ((u8)(3));
    DW_ATE_address = ((u32)(1));
    DW_ATE_boolean = ((u32)(2));
    DW_ATE_complex_float = ((u32)(3));
    DW_ATE_float = ((u32)(4));
    DW_ATE_signed = ((u32)(5));
    DW_ATE_signed_char = ((u32)(6));
    DW_ATE_unsigned = ((u32)(7));
    DW_ATE_unsigned_char = ((u32)(8));
    DW_ATE_imaginary_float = ((u32)(9));
    DW_ATE_packed_decimal = ((u32)(10));
    DW_ATE_numeric_string = ((u32)(11));
    DW_ATE_edited = ((u32)(12));
    DW_ATE_signed_fixed = ((u32)(13));
    DW_ATE_unsigned_fixed = ((u32)(14));
    DW_ATE_decimal_float = ((u32)(15));
    DW_ATE_UTF = ((u32)(16));
    DW_ATE_UCS = ((u32)(17));
    DW_ATE_ASCII = ((u32)(18));
    DW_ATE_lo_user = ((u32)(128));
    DW_ATE_hi_user = ((u32)(255));
    FLAG_INVALID = ((usize)(0llu));
    FLAG_STRING = ((usize)(1llu));
    FLAG_BOOL = ((usize)(2llu));
    FLAG_MODE_DEFAULT = ((usize)(0llu));
    FLAG_MODE_SINGLE = ((pow2uszrusz)(((usize)(0llu))));
    FLAG_MODE_MANDATORY = ((pow2uszrusz)(((usize)(1llu))));
    INDENTATION_LEVEL = ((usize)(4llu));
}

Any C_aligned_allocuszuszrAny(usize alignment, usize size) { return ((_aligned_malloc)((size), (alignment))); }
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none C_exiti32rN(i32 code) {
    (((fflush))((NULL)));
    (((exit))((code)));
}
none pushPS6808S0540rN(StringList_s *this, String_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(String_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StringList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
String_s *atPS6808uszrPS0540(StringList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StringList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in StringList.at")));
    return (&((((this)->elements))[(index)]));
}
String_s *lastPS6808rPS0540(StringList_s *this) { return ((atPS6808uszrPS0540)((this), (((this)->length) - ((usize)(1llu))))); }
usize hashPS0540rusz(String_s *this) {
    SubStr_s tmp_127 = ((asSubStrPS0540rS7720)((this)));

    return ((hashPS7720rusz)((&tmp_127)));
}
String_s toAbsolutePathPS0540rS0540(String_s *this) {
    char *buf = (((calloc))(((usize)(1024llu)), ((usize)(1llu))));
    ((assertBrN)(((buf) != (NULL))));
    char *abs = (((_fullpath))((buf), ((this)->buffer), ((i32)(1024))));
    ((assertBPcrN)(((abs) != (NULL)), ("Could not get absolute path")));
    String_s s = ((newStringFromStrLitPcrS0540)((buf)));
    (((free))((buf)));
    return (s);
}
String_s getFileNamePS0540rS0540(String_s *this) {
    String_s root = ((getRootPS0540rS0540)((this)));
    ((assertBPcrN)((((this)->length) > ((root).length)), ("getFileName: zero-char file name??")));
    SubStr_s tmp_195 = ((substringPS0540uszuszrS7720)((this), ((root).length), ((this)->length)));

    String_s name = ((toStringPS7720rS0540)((&tmp_195)));
    ((dropPS0540rN)((&(root))));
    return (name);
}
String_s getRootPS0540rS0540(String_s *this) {
    String_s c = ((copyPS0540rS0540)((this)));
    while ((((c).length) > ((usize)(0llu))) && (((((c).buffer))[(((c).length) - ((usize)(1llu)))]) != ('\\')))
        (((c).length) = (((c).length) - ((usize)(1llu))));
    ((assertBPcrN)((((c).length) != ((usize)(0llu))), ("getRoot: Found no root")));
    return (c);
}
none dropPS0540rN(String_s *this) { (((free))(((this)->buffer))); }
String_s copyPS0540rS0540(String_s *this) {
    Any bfr = (((calloc))(((this)->capacity), (sizeof(char))));
    ((assertBPcrN)(((bfr) != (NULL)), ("Could not copy String")));
    Any _bfr = (((memcpy))((bfr), ((this)->buffer), ((this)->capacity)));
    ((assertBrN)(((_bfr) != (NULL))));
    ((assertBrN)(((bfr) == (_bfr))));
    return ((String_s){.buffer = (bfr), .length = ((this)->length), .capacity = ((this)->capacity)});
}
none resizePS0540uszrN(String_s *this, usize newCap) {
    if ((newCap) < ((usize)(256llu)))
        ((newCap) = ((usize)(256llu)));
    char *old = ((this)->buffer);
    (((this)->buffer) = (((calloc))((newCap), (sizeof(char)))));
    ((assertBPcrN)((((this)->buffer) != (NULL)), ("Could not resize String")));
    (((memcpy))(((this)->buffer), (old), ((this)->length)));
    (((free))((old)));
    (((this)->capacity) = (newCap));
}
none printPS0540rN(String_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        (((printf))(("%c"), (*((char *)((unsigned char *)((this)->buffer) + (i))))));
    }
}
SubStr_s asSubStrPS0540rS7720(String_s *this) { return ((substringPS0540uszuszrS7720)((this), ((usize)(0llu)), ((this)->length))); }
SubStr_s substringPS0540uszuszrS7720(String_s *this, usize start, usize end) { return ((newSubStrOfStringPS0540uszuszrS7720)((this), (start), (end))); }
none pushNumberPS0540uszrN(String_s *this, usize num) {
    array_5926 bfr = ((array_5926){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((_snprintf))((NULL), ((usize)(0llu)), ("%llu"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumber()")));
    (((_snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("%llu"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberAsHexPS0540uszrN(String_s *this, usize num) {
    array_5926 bfr = ((array_5926){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((_snprintf))((NULL), ((usize)(0llu)), ("0x%llX"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumberAsHex()")));
    (((_snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("0x%llX"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberPS0540f32rN(String_s *this, f32 i) { ((pushNumberPS0540f64rN)((this), ((f64)((i))))); }
none pushNumberPS0540f64rN(String_s *this, f64 num) {
    array_5926 bfr = ((array_5926){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((_snprintf))((NULL), ((usize)(0llu)), ("%f"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumber()")));
    (((_snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("%f"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberPS0540u8rN(String_s *this, u8 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u16rN(String_s *this, u16 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u32rN(String_s *this, u32 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u64rN(String_s *this, u64 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540i8rN(String_s *this, i8 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i16rN(String_s *this, i16 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i32rN(String_s *this, i32 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i64rN(String_s *this, i64 i) {
    if ((i) < ((i64)(0ll))) {
        ((pushCharPS0540crN)((this), ('-')));
        ((i) = (-(i)));
    }

    ((pushNumberPS0540uszrN)((this), ((usize)((i)))));
}
none pushCharPS0540crN(String_s *this, char ch) {
    if ((((this)->length) >= ((this)->capacity)) || (((this)->capacity) < ((usize)(256llu)))) {
        ((resizePS0540uszrN)((this), (((usize)(2llu)) * ((this)->capacity))));
    }

    (((((this)->buffer))[((this)->length)]) = (ch));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushHexPS0540u8rN(String_s *this, u8 hex) {
    u8 lower = ((hex) % ((u8)(16)));
    u8 upper = (((hex) / ((u8)(16))) % ((u8)(16)));
    ((assertBrN)(((lower) < ((u8)(16)))));
    ((assertBrN)(((upper) < ((u8)(16)))));
    ((pushCharPS0540crN)((this), ('\\')));
    ((pushCharPS0540crN)((this), ('x')));
    ((pushCharPS0540crN)((this), (((HEX_CHAR).arr)[((usize)((upper)))])));
    ((pushCharPS0540crN)((this), (((HEX_CHAR).arr)[((usize)((lower)))])));
}
none pushSubStrPS0540PS7720rN(String_s *this, SubStr_s *sub) {
    usize newLen = (((this)->length) + ((sub)->len));
    if ((newLen) >= ((this)->capacity))
        ((resizePS0540uszrN)((this), ((newLen) + ((usize)(32llu)))));
    (((memcpy))(((char *)((unsigned char *)((this)->buffer) + (((this)->length) * (sizeof(char))))), ((sub)->start), ((sub)->len)));
    (((this)->length) = (newLen));
}
none pushStringPS0540PS0540rN(String_s *this, String_s *s) {
    SubStr_s tmp_718 = ((asSubStrPS0540rS7720)((s)));

    ((pushSubStrPS0540PS7720rN)((this), (&tmp_718)));
}
none pushStrPS0540PcrN(String_s *this, char *s) {
    usize _len = (((strlen))((s)));
    SubStr_s tmp_730 = ((SubStr_s){.start = (s), .len = (_len)});

    ((pushSubStrPS0540PS7720rN)((this), (&tmp_730)));
}
bool isNumberPS0540rB(String_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        if ((ch) == ('\0')) {
            break;
        }

        if (!((isNumericcrB)((ch)))) {
            return (false);
        }
    }

    return (((this)->length) > ((usize)(0llu)));
}
i64 toI64PS0540ri64(String_s *this) {
    ((assertBPcrN)(((isNumberPS0540rB)((this))), ("not a number")));
    i64 val = ((i64)(0ll));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        i64 digit = ((i64)(((ch) - ('0'))));
        ((val) = ((((i64)(10ll)) * (val)) + (digit)));
    }

    return (val);
}
u64 toU64PS0540ru64(String_s *this) {
    ((assertBPcrN)(((isNumberPS0540rB)((this))), ("not a number")));
    u64 val = ((u64)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        u64 digit = ((u64)(((ch) - ('0'))));
        ((val) = ((((u64)(10llu)) * (val)) + (digit)));
    }

    return (val);
}
none replacePS0540ccrN(String_s *this, char what, char with) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->buffer))[(i)]) == (what))
            (((((this)->buffer))[(i)]) = (with));
    }
}
StringList_s splitByPS0540FB_cPuszrS6808(String_s *this, bool (*pred)(char, usize *)) {
    StringList_s list = ((StringList_s){0});
    usize last = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        usize skip = ((usize)(0llu));
        if ((pred)(((((this)->buffer))[(i)]), (&(skip)))) {
            SubStr_s _s = ((substringPS0540uszuszrS7720)((this), (last), (i)));
            ((pushPS6808S0540rN)((&(list)), ((toStringPS7720rS0540)((&(_s))))));
            ((i) = ((i) + (skip)));
            ((last) = (i));
        }
    }

    if ((last) != ((this)->length)) {
        SubStr_s _s = ((substringPS0540uszuszrS7720)((this), (last), ((this)->length)));
        ((pushPS6808S0540rN)((&(list)), ((toStringPS7720rS0540)((&(_s))))));
    }

    return (list);
}
bool equalsPS0540PS0540rB(String_s *this, String_s *other) {
    if (((this)->length) != ((other)->length))
        return (false);
    SubStr_s tmp_935 = ((asSubStrPS0540rS7720)((this)));
    SubStr_s tmp_939 = ((asSubStrPS0540rS7720)((other)));

    return ((equalsPS7720PS7720rB)((&tmp_935), (&tmp_939)));
}
String_s newStringrS0540(none) {
    usize cap = ((usize)(16llu));
    Any _m = (((calloc))((cap), (sizeof(char))));
    char *buff = ((char *)((_m)));
    return ((String_s){.buffer = (buff), .length = ((usize)(0llu)), .capacity = ((usize)(16llu))});
}
String_s newReadonlyStringPcrS0540(char *s) { return ((String_s){.buffer = (s), .length = ((comptimeStrlenPcrusz)((s))), .capacity = ((comptimeStrlenPcrusz)((s)))}); }
String_s newStringFromStrLitPcrS0540(char *s) {
    usize len = (((strlen))((s)));
    char *buff = (((calloc))(((len) + ((usize)(1llu))), (sizeof(char))));
    ((assertBrN)(((buff) != (NULL))));
    (((memcpy))((buff), (s), (len)));
    return ((String_s){.buffer = ((char *)((buff))), .length = (len), .capacity = (len)});
}
bool canReadFileToStringPcPS0540rB(char *path, String_s *source) {
    Any file = (((fopen))((path), ("rb")));
    if ((file) == (NULL)) {
        return (false);
    }

    array_6084 buf = ((array_6084){
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    while (true) {
        usize size = (((fread))((&(buf)), ((usize)(1llu)), ((usize)(1024llu)), (file)));
        if ((size) == ((usize)(0llu))) {
            break;
        }

        for (usize i = ((usize)(0llu)); ((i) < (size)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushCharPS0540crN)((source), (((buf).arr)[(i)])));
        }
    }

    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
    return (true);
}
String_s readFileToStringPcrS0540(char *path) {
    String_s s = ((newStringrS0540)());
    Any file = (((fopen))((path), ("rb")));
    if ((file) == (NULL)) {
        (((fprintf))((stderr_), ("error: Could not open file `%s`.\n"), (path)));
        (((C_exiti32rN))(((i32)(1))));
    }

    array_6084 buf = ((array_6084){
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    while (true) {
        usize size = (((fread))((&(buf)), ((usize)(1llu)), ((usize)(1024llu)), (file)));
        if ((size) == ((usize)(0llu))) {
            break;
        }

        for (usize i = ((usize)(0llu)); ((i) < (size)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushCharPS0540crN)((&(s)), (((buf).arr)[(i)])));
        }
    }

    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
    return (s);
}
none writeStringToFilePcS0540rN(char *path, String_s s) {
    Any file = (((fopen))((path), ("wb")));
    if ((file) == (NULL)) {
        (((fprintf))((stderr_), ("error: Could not open file `%s`.\n"), (path)));
        (((C_exiti32rN))(((i32)(1))));
    }

    usize size = (((fwrite))(((s).buffer), ((usize)(1llu)), ((s).length), (file)));
    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
}
bool isEmptyPS7720rB(SubStr_s *this) { return (((this)->start) == (NULL)); }
usize hashPS7720uszrusz(SubStr_s *this, usize length) {
    usize d = ((powuszuszrusz)(((usize)(10llu)), (length)));
    return (((hashPS7720rusz)((this))) % (d));
}
usize hashPS7720rusz(SubStr_s *this) {
    usize hash = ((usize)(5381llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        ((hash) = ((((shiftLeftuszuszrusz)((hash), ((usize)(5llu)))) + (hash)) + ((usize)(((((this)->start))[(i)])))));
    }

    return (hash);
}
u8 lexOrderPS7720PS7720ru8(SubStr_s *this, SubStr_s *other) {
    if (((this)->len) < ((other)->len)) {
        return (ORDER_LESS);
    }

    if (((this)->len) > ((other)->len)) {
        return (ORDER_GREATER);
    }

    usize l = ((this)->len);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c1 = ((((this)->start))[(i)]);
        char c2 = ((((other)->start))[(i)]);
        if ((c1) < (c2)) {
            return (ORDER_LESS);
        }

        if ((c1) > (c2)) {
            return (ORDER_GREATER);
        }
    }

    return (ORDER_EQUAL);
}
bool equalsPS7720PS7720rB(SubStr_s *this, SubStr_s *other) {
    if (((this)->len) != ((other)->len)) {
        return (false);
    }

    usize l = ((this)->len);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c1 = ((((this)->start))[(i)]);
        char c2 = ((((other)->start))[(i)]);
        if ((c1) != (c2)) {
            return (false);
        }
    }

    return (true);
}
none printPS7720rN(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char p = ((((this)->start))[(i)]);
        ((assertBPcrN)(((p) == (((putchar))((p)))), ("Wrote wrong character in SubStr.print")));
    }
}
String_s getPathParentPS7720rS0540(SubStr_s *this) {
    String_s s = ((toStringPS7720rS0540)((this)));
    while (((s).length) > ((usize)(0llu))) {
        char c = ((((s).buffer))[(((s).length) - ((usize)(1llu)))]);
        if (((c) == ('/')) || ((c) == ('\\'))) {
            break;
        }

        ((pushCharPS0540crN)((&(s)), ('\0')));
        (((s).length) = (((s).length) - ((usize)(2llu))));
    }

    return (s);
}
String_s toStringPS7720rS0540(SubStr_s *this) {
    Any buf = (((calloc))((sizeof(char)), (((this)->len) + ((usize)(1llu)))));
    ((assertBPcrN)(((buf) != (NULL)), ("toString(SubStr)")));
    (((memcpy))((buf), ((this)->start), ((this)->len)));
    return ((String_s){.buffer = (buf), .length = ((this)->len), .capacity = (((this)->len) + ((usize)(1llu)))});
}
bool beginsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *prefix) {
    if (((prefix)->len) > ((this)->len))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((prefix)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[(i)]) != ((((prefix)->start))[(i)])) {
            return (false);
        }
    }

    return (true);
}
bool endsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *suffix) {
    if (((suffix)->len) > ((this)->len))
        return (false);
    usize offset = (((this)->len) - ((suffix)->len));
    for (usize i = ((usize)(0llu)); ((i) < ((suffix)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[((offset) + (i))]) != ((((suffix)->start))[(i)])) {
            return (false);
        }
    }

    return (true);
}
none skipUntilPS7720FBcrN(SubStr_s *this, bool (*pred)(char)) {
    while (((this)->len) > ((usize)(0llu))) {
        if (!((pred)(((((this)->start))[((usize)(0llu))])))) {
            ((advancePS7720rN)((this)));
        }

        else {
            break;
        }
    }
}
SubStr_s splitNextPS7720FBcrS7720(SubStr_s *this, bool (*pred)(char)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((pred)(((((this)->start))[(i)]))) {
            SubStr_s _s1 = ((substringPS7720uszuszrS7720)((this), ((usize)(0llu)), (i)));
            ((advancePS7720uszrN)((this), (i)));
            return (_s1);
        }
    }

    return (*(this));
}
none advancePS7720rN(SubStr_s *this) { ((advancePS7720uszrN)((this), ((usize)(1llu)))); }
none advancePS7720uszrN(SubStr_s *this, usize step) {
    ((assertBPcrN)(((step) <= ((this)->len)), ("SubStr.advance: Step too big!")));
    (((this)->start) = ((char *)((unsigned char *)((this)->start) + (step))));
    (((this)->len) = (((this)->len) - (step)));
}
SubStr_s substringPS7720uszuszrS7720(SubStr_s *this, usize start, usize end) {
    ((assertBPcrN)(((end) <= ((this)->len)), ("Index out of bounds for String Substring.")));
    ((assertBPcrN)((((end) - (start)) <= ((this)->len)), ("Invalid length for String Substring.")));
    return ((newSubStrPcuszuszrS7720)(((this)->start), (start), (end)));
}
bool hasSpacePS7720rB(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[(i)]) == (' ')) {
            return (true);
        }
    }

    return (false);
}
bool isNumberPS7720rB(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->start))[(i)]);
        if ((ch) == ('\0')) {
            break;
        }

        if (!((isNumericcrB)((ch)))) {
            return (false);
        }
    }

    return (((this)->len) > ((usize)(0llu)));
}
u64 toU64PS7720ru64(SubStr_s *this) {
    ((assertBPcrN)(((isNumberPS7720rB)((this))), ("not a number")));
    u64 val = ((u64)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->start))[(i)]);
        u64 digit = ((u64)(((ch) - ('0'))));
        ((val) = ((((u64)(10llu)) * (val)) + (digit)));
    }

    return (val);
}
f64 toF64PS7720rf64(SubStr_s *this) { return ((f64)(((toU64PS7720ru64)((this))))); }
SubStr_s newSubStrOfStrLitPcrS7720(char *orig) { return ((newSubStrPcuszuszrS7720)((orig), ((usize)(0llu)), ((comptimeStrlenPcrusz)((orig))))); }
SubStr_s newSubStrPcuszuszrS7720(char *orig, usize start, usize end) { return ((SubStr_s){.start = ((char *)((unsigned char *)(orig) + (start))), .len = ((end) - (start))}); }
SubStr_s newSubStrOfStringPS0540uszuszrS7720(String_s *orig, usize start, usize end) {
    return ((SubStr_s){.start = ((char *)((unsigned char *)((orig)->buffer) + (start))), .len = ((end) - (start))});
}
SubStr_s defaultSubStrrS7720(none) {
    char *s = ("You are not supposed to read this. Please issue a bug report.");
    usize l = (((strlen))((s)));
    return ((newSubStrPcuszuszrS7720)((s), ((usize)(0llu)), (l)));
}
u8 tagAnyru8(Any union_) { return (*((u8 *)((union_)))); }
SubStr_s comptimeSubStrPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
none setupStdHandlesrN(none) {
    if (done)
        return;
    if ((stdin_) == (NULL))
        ((stdin_) = (((_fdopen))(((i32)(0)), ("a"))));
    ((_assertBPcrN)(((stdin_) != (NULL)), ("Could not initialize STDIN!")));
    if ((stdout_) == (NULL))
        ((stdout_) = (((_fdopen))(((i32)(1)), ("a"))));
    ((_assertBPcrN)(((stdout_) != (NULL)), ("Could not initialize STDOUT!")));
    if ((stderr_) == (NULL))
        ((stderr_) = (((_fdopen))(((i32)(2)), ("a"))));
    ((_assertBPcrN)(((stderr_) != (NULL)), ("Could not initialize STDERR!")));
    ((done) = (true));
}
usize comptimeStrlenPcrusz(char *str) {
    usize len = ((usize)(0llu));
    while ((*((char *)((unsigned char *)(str) + (len)))) != ('\0'))
        ((len) = ((len) + ((usize)(1llu))));
    return (len);
}
usize pow2uszrusz(usize exp) {
    usize result = ((usize)(1llu));
    while ((exp) > ((usize)(0llu))) {
        ((result) = ((result) * ((usize)(2llu))));
        ((exp) = ((exp) - ((usize)(1llu))));
    }

    return (result);
}
usize powuszuszrusz(usize base, usize exp) {
    usize result = ((usize)(1llu));
    while ((exp) > ((usize)(0llu))) {
        ((result) = ((result) * (base)));
        ((exp) = ((exp) - ((usize)(1llu))));
    }

    return (result);
}
usize shiftLeftuszuszrusz(usize base, usize bits) {
    while ((bits) > ((usize)(0llu))) {
        ((base) = ((base) * ((usize)(2llu))));
        ((bits) = ((bits) - ((usize)(1llu))));
    }

    return (base);
}
usize shiftRightuszuszrusz(usize base, usize bits) {
    while ((bits) > ((usize)(0llu))) {
        ((base) = ((base) / ((usize)(2llu))));
        ((bits) = ((bits) - ((usize)(1llu))));
    }

    return (base);
}
usize bitCountuszrusz(usize val) {
    usize r = ((usize)(0llu));
    while ((val) > ((usize)(0llu))) {
        ((val) = ((shiftRightuszuszrusz)((val), ((usize)(1llu)))));
        ((r) = ((r) + ((usize)(1llu))));
    }

    return (r);
}
bool isNumericcrB(char ch) {
    u8 _u8 = ((u8)((ch)));
    return (((_u8) >= ((u8)(48))) && ((_u8) <= ((u8)(57))));
}
bool isAlphabeticcrB(char ch) {
    u8 _u8 = ((u8)((ch)));
    return ((((_u8) >= ((u8)(65))) && ((_u8) <= ((u8)(90)))) || (((_u8) >= ((u8)(97))) && ((_u8) <= ((u8)(122)))));
}
u8 asHexcru8(char ch) {
    ((assertBPcrN)(((isHexDigitcrB)((ch))), ("can\'t convert non-hex value to hex")));
    u8 v = ((u8)(0));
    if ((isNumericcrB)((ch)))
        ((v) = (((u8)((ch))) - ((u8)(48))));
    else if ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(70))))
        ((v) = (((u8)((ch))) - ((u8)(55))));
    else if ((((u8)((ch))) >= ((u8)(97))) && (((u8)((ch))) <= ((u8)(102))))
        ((v) = (((u8)((ch))) - ((u8)(87))));
    ((assertBPcrN)(((v) < ((u8)(16))), ("hex out of bounds")));
    return (v);
}
bool isHexDigitcrB(char ch) { return ((((isNumericcrB)((ch))) || ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(70))))) || ((((u8)((ch))) >= ((u8)(97))) && (((u8)((ch))) <= ((u8)(102))))); }
bool isWhitespacecrB(char ch) { return (((((ch) == (' ')) || ((ch) == ('\r'))) || ((ch) == ('\n'))) || ((ch) == ('\t'))); }
bool isAlphanumericcrB(char ch) { return (((isAlphabeticcrB)((ch))) || ((isNumericcrB)((ch)))); }
bool isAsciiUppercasecrB(char ch) { return ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(90)))); }
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none index_oobPci64rN(char* msg, i64 index) {
    ((setupStdHandlesrN)());
    (((fprintf))((stderr_), (msg), (index)));
    (((C_exiti32rN))(((i32)(2))));
}
none _empty_assertBrN(bool cond) {}
none _empty_assertBPcrN(bool cond, char *msg) {}
none assertBrN(bool cond) {
    if (!(cond)) {
        ((setupStdHandlesrN)());
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED\n")));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED\n")));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
none _assertBPcrN(bool cond, char *msg) {
    if (!(cond)) {
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED: %s\n"), (msg)));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED: %s\n"), (msg)));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
none assertBPcrN(bool cond, char *msg) {
    if (!(cond)) {
        ((setupStdHandlesrN)());
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED: %s\n"), (msg)));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED: %s\n"), (msg)));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablerN(none) {
    ((unreachablePcrN)(("Explicit call to unreachable()")));
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablePcrN(char* msg) {
    ((setupStdHandlesrN)());
    if ((stderr_) == (NULL)) {
        (((printf))(("%s Entered unreachable code: %s"), (FATAL_STR), (msg)));
        (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
    }

    else {
        (((fprintf))((stderr_), ("%s Entered unreachable code: %s\n"), (FATAL_STR), (msg)));
    }

    (((C_exiti32rN))(((i32)(2))));
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none todo_with_msgPcrN(char* msg) {
    ((setupStdHandlesrN)());
    if ((stderr_) == (NULL)) {
        (((printf))(("TODO: %s\n"), (msg)));
        (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
    }

    else {
        (((fprintf))((stderr_), ("TODO: %s\n"), (msg)));
    }

    (((C_exiti32rN))(((i32)(2))));
}
none warningPcrN(char *msg) {
    if (!(PRINT_WARNING))
        return;
    (((fprintf))((stderr_), ("\x1B[93m[WARNING]\x1B[0m %s\n"), (msg)));
}
none resizePS6678uszrN(StringBuffer_s *this, usize newCap) {
    Any _new = (((realloc))(((this)->data), ((newCap) * (sizeof(SubStr_s)))));
    ((assertBrN)(((_new) != (NULL))));
    (((this)->data) = ((SubStr_s *)((_new))));
    (((this)->capacity) = (newCap));
}
none addPS6678S7720rN(StringBuffer_s *this, SubStr_s str) {
    if (((this)->length) >= ((this)->capacity))
        ((resizePS6678uszrN)((this), (((usize)(2llu)) * ((this)->capacity))));
    ((*((SubStr_s *)((unsigned char *)((this)->data) + (((this)->length) * (sizeof(SubStr_s)))))) = (str));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
char *getNthAsCharPtrPS6678uszrPc(StringBuffer_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StringBuf.getNthAsCharPtr()")));
    return ((*((SubStr_s *)((unsigned char *)((this)->data) + ((index) * (sizeof(SubStr_s)))))).start);
}
none extendPS6678PS6678rN(StringBuffer_s *this, StringBuffer_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((addPS6678S7720rN)((this), (*((SubStr_s *)((unsigned char *)((other)->data) + ((i) * (sizeof(SubStr_s))))))));
    }
}
String_s toCmdStringPS6678rS0540(StringBuffer_s *this) {
    String_s s = ((newStringrS0540)());
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s str = (*((SubStr_s *)((unsigned char *)((this)->data) + ((i) * (sizeof(SubStr_s))))));
        if ((hasSpacePS7720rB)((&(str)))) {
            ((pushCharPS0540crN)((&(s)), ('\"')));
            ((pushSubStrPS0540PS7720rN)((&(s)), (&(str))));
            ((pushCharPS0540crN)((&(s)), ('\"')));
        }

        else {
            ((pushSubStrPS0540PS7720rN)((&(s)), (&(str))));
        }

        if ((i) != (((this)->length) - ((usize)(1llu))))
            ((pushCharPS0540crN)((&(s)), (' ')));
    }

    return (s);
}
StringBuffer_s newStringBufferrS6678(none) {
    Any _bfr = (((calloc))((INITIAL_STRINGBUFFER_CAP), (sizeof(SubStr_s))));
    SubStr_s *_data = ((SubStr_s *)((_bfr)));
    return ((StringBuffer_s){.data = (_data), .length = ((usize)(0llu)), .capacity = (INITIAL_STRINGBUFFER_CAP)});
}
bool successS1457rB(BOOL_s b) { return (((b).i) != ((i32)(0))); }
bool failedS1457rB(BOOL_s b) { return (((b).i) == ((i32)(0))); }
bool isNullS9457rB(Handle_s h) { return (((h).ptr) == ((usize)(0llu))); }
usize getLastModifiedPcrusz(char *filePath) {
    Handle_s file = (((CreateFileA))((filePath), (GENERIC_READ), ((FILE_SHARE_WRITE) | (FILE_SHARE_READ)), (NULL), (OPEN_EXISTING), (FILE_ATTRIBUTE_NORMAL), (INVALID_HANDLE)));
    FileTime_s time = ((FileTime_s){.time = ((usize)(0llu))});
    if ((failedS1457rB)((((GetFileTime))((file), (NULL), (NULL), (&(time)))))) {
        (((fprintf))((stderr_), ("[ERROR] Could not get time of %s: %#010x\n"), (filePath), ((WinErroru32rPc)((((GetLastError))())))));
        return (((usize)(0llu)) - ((usize)(1llu)));
    }

    BOOL_s _r = (((CloseHandle))((file)));
    ((assertBrN)(((successS1457rB)((_r)))));
    return ((time).time);
}
bool waitForProcessS9457rB(Handle_s proc) {
    u32 result = (((WaitForSingleObject))((proc), (INFINITE)));
    if ((result) == (WAIT_FAILED)) {
        (((fprintf))((stderr_), ("[ERROR] Could not wait on child process: %#010x\n"), ((WinErroru32rPc)((((GetLastError))())))));
        return (false);
    }

    u32 exitStatus = ((u32)(0));
    if ((failedS1457rB)((((GetExitCodeProcess))((proc), (&(exitStatus)))))) {
        (((fprintf))((stderr_), ("[ERROR] Could not get process exit code: %#010x\n"), ((WinErroru32rPc)((((GetLastError))())))));
        return (false);
    }

    if ((exitStatus) != ((u32)(0))) {
        return (false);
    }

    (((CloseHandle))((proc)));
    return (true);
}
bool dirExistsPcrB(char *path) {
    u32 attrib = (((GetFileAttributesA))((path)));
    return (((attrib) != (INVALID_FILE_ATTRIBUTES)) && (((attrib) & (FILE_ATTRIBUTE_DIRECTORY)) != ((u32)(0))));
}
bool tryFindPcrB(char *program) {
    String_s s = ((newStringFromStrLitPcrS0540)(("where /Q ")));
    ((pushStrPS0540PcrN)((&(s)), (program)));
    Cmd_s cmd = ((newCmdFromStrLitPcrS3657)(((s).buffer)));
    return ((runCmdSyncS3657rB)((cmd)));
}
bool runCmdSyncS3657rB(Cmd_s cmd) {
    Handle_s proc = ((runCmdAsyncS3657rS9457)((cmd)));
    if (((proc).ptr) == ((INVALID_HANDLE).ptr))
        return (false);
    return ((waitForProcessS9457rB)((proc)));
}
Handle_s runCmdAsyncS3657rS9457(Cmd_s cmd) {
    StartupInfo_s siStartInfo = ((StartupInfo_s){.cb = ((u32)(0)),
                                                 .lpReserved = (NULL),
                                                 .lpDesktop = (NULL),
                                                 .lpTitle = (NULL),
                                                 .dwX = ((u32)(0)),
                                                 .dwY = ((u32)(0)),
                                                 .dwXSize = ((u32)(0)),
                                                 .dwYSize = ((u32)(0)),
                                                 .dwXCountChars = ((u32)(0)),
                                                 .dwYCountChars = ((u32)(0)),
                                                 .dwFillAttribute = ((u32)(0)),
                                                 .dwFlags = ((u32)(0)),
                                                 .wShowWindow = ((u16)(0)),
                                                 .cbReserved2 = ((u16)(0)),
                                                 .lpReserved2 = (NULL),
                                                 .hStdInput = (((GetStdHandle))((STD_INPUT_HANDLE))),
                                                 .hStdOutput = (((GetStdHandle))((STD_OUTPUT_HANDLE))),
                                                 .hStdError = (((GetStdHandle))((STD_ERROR_HANDLE)))});
    (((siStartInfo).cb) = ((u32)((sizeof(StartupInfo_s)))));
    (((siStartInfo).dwFlags) = (((siStartInfo).dwFlags) | (STARTF_USESTDHANDLES)));
    ProcessInformation_s piProcInfo = ((ProcessInformation_s){.hProcess = (INVALID_HANDLE), .hThread = (INVALID_HANDLE), .dwProcessId = ((u32)(0)), .dwThreadId = ((u32)(0))});
    String_s str = ((toStringPS3657rS0540)((&(cmd))));
    ((pushCharPS0540crN)((&(str)), ('\0')));
    if ((cmd).log) {
        (((printf))(("[CMD] %s\n"), ((str).buffer)));
    }

    BOOL_s bSuccess = (((CreateProcessA))((NULL), (&(*((str).buffer))), (NULL), (NULL), ((BOOL_s){.i = ((i32)(1))}), ((u32)(0)), (NULL), (NULL), (&(siStartInfo)), (&(piProcInfo))));
    ((dropPS0540rN)((&(str))));
    if ((failedS1457rB)((bSuccess))) {
        (((fprintf))((stderr_), ("[ERROR] Could not create child process: %#010x\n"), ((WinErroru32rPc)((((GetLastError))())))));
        return (INVALID_HANDLE);
    }

    (((CloseHandle))(((piProcInfo).hThread)));
    return ((piProcInfo).hProcess);
}
char *WinErroru32rPc(u32 error) {
    char *message = (NULL);
    u32 lang = ((u32)(1033));
    if ((((FormatMessageA))((((FORMAT_MESSAGE_ALLOCATE_BUFFER) | (FORMAT_MESSAGE_FROM_SYSTEM)) | (FORMAT_MESSAGE_IGNORE_INSERTS)), (NULL), (error), (lang), (&(message)), ((u32)(0)), (message))) ==
        ((u32)(0))) {
        (((fprintf))((stderr_), ("%s Could not get WinError: FormatMessage failed!\n"), (FATAL_STR)));
        return (NULL);
    }

    return (message);
}
none addPS3657PcrN(Cmd_s *this, char *arg) { ((addPS6678S7720rN)((&((this)->buf)), ((newSubStrOfStrLitPcrS7720)((arg))))); }
none addSubStrPS3657S7720rN(Cmd_s *this, SubStr_s arg) { ((addPS6678S7720rN)((&((this)->buf)), (arg))); }
none addManyPS3657S6678rN(Cmd_s *this, StringBuffer_s args) { ((extendPS6678PS6678rN)((&((this)->buf)), (&(args)))); }
bool runSyncPS3657rB(Cmd_s *this) { return ((runCmdSyncS3657rB)((*(this)))); }
Handle_s runAsyncPS3657rS9457(Cmd_s *this) { return ((runCmdAsyncS3657rS9457)((*(this)))); }
String_s toStringPS3657rS0540(Cmd_s *this) { return ((toCmdStringPS6678rS0540)((&((this)->buf)))); }
char **asCharPtrsPS3657rPPc(Cmd_s *this) {
    Any _any = (((calloc))(((((this)->buf).length) + ((usize)(1llu))), (sizeof(char *))));
    ((assertBrN)(((_any) != (NULL))));
    char **_mut = ((char **)((_any)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->buf).length)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s elem = ((toStringPS7720rS0540)(((SubStr_s *)((unsigned char *)(((this)->buf).data) + ((i) * (sizeof(SubStr_s)))))));
        ((*((char **)((unsigned char *)(_mut) + ((i) * (sizeof(char *)))))) = ((char *)(((elem).buffer))));
    }

    return ((char **)((_any)));
}
Cmd_s newCmdrS3657(none) { return ((Cmd_s){.buf = ((newStringBufferrS6678)())}); }
Cmd_s newCmdFromStrLitPcrS3657(char *command) {
    Cmd_s cmd = ((newCmdrS3657)());
    usize pos = ((usize)(0llu));
    usize len = (((strlen))((command)));
    while ((pos) < (len)) {
        char *nextSpace = (((strchr))((command), (' ')));
        if ((nextSpace) == (NULL))
            break;
        usize offset = ((usize)((unsigned char *)(nextSpace) - (unsigned char *)(command)));
        SubStr_s substr = ((newSubStrPcuszuszrS7720)((command), ((usize)(0llu)), (offset)));
        ((addSubStrPS3657S7720rN)((&(cmd)), (substr)));
        ((command) = ((char *)((unsigned char *)((char *)((unsigned char *)(command) + (offset))) + ((usize)(1llu)))));
        ((pos) = (((pos) + (offset)) + ((usize)(1llu))));
    }

    if ((pos) < (len)) {
        SubStr_s rest = ((newSubStrPcuszuszrS7720)((command), ((usize)(0llu)), (((strlen))((command)))));
        ((addSubStrPS3657S7720rN)((&(cmd)), (rest)));
    }

    return (cmd);
}
bool moveFilePcPcrB(char *from, char *to) {
    Cmd_s moveCmd = ((newCmdFromStrLitPcrS3657)(("mv")));
    ((addPS3657PcrN)((&(moveCmd)), (from)));
    ((addPS3657PcrN)((&(moveCmd)), (to)));
    return ((runSyncPS3657rB)((&(moveCmd))));
}
bool deleteFilePcrB(char *path) {
    Cmd_s delCmd = ((newCmdFromStrLitPcrS3657)(("rm")));
    ((addPS3657PcrN)((&(delCmd)), (path)));
    return ((runSyncPS3657rB)((&(delCmd))));
}
bool LLVM_isNullS3482rB(LLVM_TargetMachineOptionsRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS5038rB(LLVM_TargetMachineRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3497rB(LLVM_TargetRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6307rB(LLVM_TargetDataRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS4183rB(LLVM_ContextRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3816rB(LLVM_ModuleRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3273rB(LLVM_BuilderRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6239rB(LLVM_BasicBlockRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS1407rB(LLVM_ValueRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6708rB(LLVM_TypeRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS8710rB(LLVM_AttributeRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS7356rB(LLVM_PassBuilderOptionsRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS0284rB(LLVM_ErrorRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS1302rB(LLVM_DIBuilderRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS9683rB(LLVM_MetadataRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS5902rB(LLVM_DbgRecordRef_s this) { return (((this).ptr) == (NULL)); }
i32 LLVM_asI32Anyri32(Any u) { return ((i32)((*((u8 *)((u)))))); }
LLVMBool_s newLLVMBoolBrS2924(bool b) {
    if (b)
        return ((LLVMBool_s){.val = ((i32)(1))});
    return ((LLVMBool_s){.val = ((i32)(0))});
}
bool equalsPS9925PS9925rB(InterpReg_s *this, InterpReg_s *other) { ((unreachablePcrN)(("InterpReg.equals is never called"))); }
InterpReg_s asInterpPU9869PcrS9925(IRValue_u *this, char *err) {
    bool succ_631_ = true;
    bool succ_636_ = true;

    IRValue_u *tmp_831_ = (this);
    {
        succ_631_ &= (tmp_831_->tag == 2);
        InterpReg_s *interp = &tmp_831_->payload.variant2._0;
        succ_631_ &= true;
        if (succ_631_) {
            {
                return (*interp);
            }
            goto after_831;
        }
    }
    {
        succ_636_ &= (tmp_831_->tag == 3);
        succ_636_ &= true;
        InterpReg_s *interp = &tmp_831_->payload.variant3._1;
        succ_636_ &= true;
        if (succ_636_) {
            {
                return (*interp);
            }
            goto after_831;
        }
    }
    {
        if (true) {
            {
            }
            goto after_831;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_831:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
LLVM_ValueRef_s asLLVMPU9869PcrS1407(IRValue_u *this, char *err) {
    bool succ_641_ = true;
    bool succ_646_ = true;

    IRValue_u *tmp_838_ = (this);
    {
        succ_641_ &= (tmp_838_->tag == 1);
        LLVM_ValueRef_s *llvm = &tmp_838_->payload.variant1._0;
        succ_641_ &= true;
        if (succ_641_) {
            {
                return (*llvm);
            }
            goto after_838;
        }
    }
    {
        succ_646_ &= (tmp_838_->tag == 3);
        LLVM_ValueRef_s *llvm = &tmp_838_->payload.variant3._0;
        succ_646_ &= true;
        succ_646_ &= true;
        if (succ_646_) {
            {
                return (*llvm);
            }
            goto after_838;
        }
    }
    {
        if (true) {
            {
            }
            goto after_838;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_838:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
none pushPS1193U9869rN(IRValueList_s *this, IRValue_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRValue_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRValue_u *atPS1193uszrPU9869(IRValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRValueList.at")));
    return (&((((this)->elements))[(index)]));
}
LLVM_ValueRef_s getArgPS6859uszrS1407(ASMContext_s *context, usize index) { return ((asLLVMPU9869PcrS1407)((&(((((context)->args).elements))[(index)])), ("ASMContext.getArg"))); }
none pushPS6859PcrN(ASMContext_s *context, char *code) {
    ((pushStrPS0540PcrN)((&((context)->code)), (code)));
    ((pushStrPS0540PcrN)((&((context)->code)), ("\n")));
}
none inPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint) {
    ((pushPS1193U9869rN)((&((context)->args)), (arg)));
    ((pushPS6808S0540rN)((&((context)->in)), ((newStringFromStrLitPcrS0540)((constraint)))));
}
none outPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint) {
    ((pushPS1193U9869rN)((&((context)->args)), (arg)));
    ((pushPS6808S0540rN)((&((context)->out)), ((newStringFromStrLitPcrS0540)((constraint)))));
}
String_s constrainPS6859U6852rS0540(ASMContext_s *context, ASMLoc_u loc) {
    String_s r = ((String_s){0});
    bool succ_655_ = true;
    bool succ_658_ = true;

    ASMLoc_u *tmp_870_ = (&(loc));
    {
        succ_655_ &= (tmp_870_->tag == 1);
        char **reg = &tmp_870_->payload.variant1._0;
        succ_655_ &= true;
        if (succ_655_) {
            {
                ((r) = ((newStringFromStrLitPcrS0540)(("{"))));
                ((pushStrPS0540PcrN)((&(r)), (*reg)));
                ((pushCharPS0540crN)((&(r)), ('}')));
            }
            goto after_870;
        }
    }
    {
        succ_658_ &= (tmp_870_->tag == 0);
        if (succ_658_) {
            {
                ((r) = ((newStringFromStrLitPcrS0540)(("r"))));
            }
            goto after_870;
        }
    }
    {
        ASMLoc_u **unknown = &tmp_870_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ASMContext.constrain: Unhandled tag %hhu\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_870;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_870:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (r);
}
none constrainPS6859U9995rN(ASMContext_s *context, ASMConstraint_u cons) {
    bool succ_664_ = true;
    bool succ_670_ = true;
    bool succ_676_ = true;

    ASMConstraint_u *tmp_891_ = (&(cons));
    {
        succ_664_ &= (tmp_891_->tag == 1);
        ASMLoc_u *loc = &tmp_891_->payload.variant1._0;
        succ_664_ &= true;
        IRValue_u *val = &tmp_891_->payload.variant1._1;
        succ_664_ &= true;
        if (succ_664_) {
            {
                String_s in = ((constrainPS6859U6852rS0540)((context), (*loc)));
                ((pushPS6808S0540rN)((&((context)->in)), (in)));
                ((pushPS1193U9869rN)((&((context)->args)), (*val)));
            }
            goto after_891;
        }
    }
    {
        succ_670_ &= (tmp_891_->tag == 0);
        ASMLoc_u *loc = &tmp_891_->payload.variant0._0;
        succ_670_ &= true;
        IRValue_u *val = &tmp_891_->payload.variant0._1;
        succ_670_ &= true;
        if (succ_670_) {
            {
                String_s in = ((constrainPS6859U6852rS0540)((context), (*loc)));
                String_s out = ((newStringFromStrLitPcrS0540)(("=")));
                ((pushStringPS0540PS0540rN)((&(out)), (&(in))));
                ((pushPS6808S0540rN)((&((context)->out)), (out)));
                ((pushPS6808S0540rN)((&((context)->in)), (in)));
                ((pushPS1193U9869rN)((&((context)->args)), (*val)));
            }
            goto after_891;
        }
    }
    {
        succ_676_ &= (tmp_891_->tag == 3);
        ASMLoc_u *loc = &tmp_891_->payload.variant3._0;
        succ_676_ &= true;
        if (succ_676_) {
            {
                String_s clob = ((constrainPS6859U6852rS0540)((context), (*loc)));
                String_s out = ((newStringFromStrLitPcrS0540)(("~")));
                ((pushStringPS0540PS0540rN)((&(out)), (&(clob))));
                ((pushPS6808S0540rN)((&((context)->clobber)), (out)));
            }
            goto after_891;
        }
    }
    {
        ASMConstraint_u **unknown = &tmp_891_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ASMContext.constrain: Unhandled tag %hhu\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_891;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_891:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none constrainPS6859PcrN(ASMContext_s *context, char *code) {
    usize l = (((strlen))((code)));
    char *ptr = (code);
    usize c = ((usize)(0llu));
    while ((c) < (l)) {
        while ((((ptr))[((usize)(0llu))]) != (','))
            ((ptr) = ((char *)((unsigned char *)(ptr) + ((usize)(1llu)))));
        usize diff = ((usize)((unsigned char *)(ptr) - (unsigned char *)(code)));
        String_s s = ((String_s){0});
        for (usize i = ((usize)(0llu)); ((i) < (diff)); ((i) = ((i) + ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (((code))[(i)])));
        if (((s).length) > ((usize)(0llu))) {
            if (((((s).buffer))[((usize)(0llu))]) == ('=')) {
                ((pushPS6808S0540rN)((&((context)->out)), (s)));
            }

            else if (((((s).buffer))[((usize)(0llu))]) == ('~')) {
                ((pushPS6808S0540rN)((&((context)->clobber)), (s)));
            }

            else {
                ((pushPS6808S0540rN)((&((context)->in)), (s)));
            }
        }

        ((code) = (ptr));
        ((c) = (((c) + (diff)) + ((usize)(1llu))));
        ((ptr) = ((char *)((unsigned char *)((char *)((unsigned char *)(ptr) + (diff))) + ((usize)(1llu)))));
    }
}
String_s collectPS6859rS0540(ASMContext_s *context) {
    String_s s = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((context)->out).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->out)), (i)))));
        if ((((((context)->in).length) > ((usize)(0llu))) || ((((context)->clobber).length) > ((usize)(0llu)))) || ((i) != ((((context)->out).length) - ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((context)->in).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->in)), (i)))));
        if (((((context)->clobber).length) > ((usize)(0llu))) || ((i) != ((((context)->in).length) - ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((context)->clobber).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->clobber)), (i)))));
        if ((i) != ((((context)->clobber).length) - ((usize)(1llu))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    return (s);
}
char *tokenKindToStringuszrPc(usize kind) {
    if ((kind) == (TOKEN_EOF))
        return ("TOKEN_EOF");
    else if ((kind) == (TOKEN_IDENT))
        return ("Identifier");
    else if ((kind) == (TOKEN_KEYWORD))
        return ("Keyword");
    else if ((kind) == (TOKEN_STRING_LITERAL))
        return ("String literal");
    else if ((kind) == (TOKEN_INT_LITERAL))
        return ("Integer literal");
    else if ((kind) == (TOKEN_CHAR_LITERAL))
        return ("Character literal");
    else if ((kind) == (TOKEN_PAREN_OPEN))
        return ("`(`");
    else if ((kind) == (TOKEN_PAREN_CLOSE))
        return ("`)`");
    else if ((kind) == (TOKEN_CURLY_OPEN))
        return ("`{`");
    else if ((kind) == (TOKEN_CURLY_CLOSE))
        return ("`}`");
    else if ((kind) == (TOKEN_SQUARE_OPEN))
        return ("`[`");
    else if ((kind) == (TOKEN_SQUARE_CLOSE))
        return ("`]`");
    else if ((kind) == (TOKEN_SEMI_COLON))
        return ("`;`");
    else if ((kind) == (TOKEN_COLON_SINGLE))
        return ("`:`");
    else if ((kind) == (TOKEN_COLON_DOUBLE))
        return ("`::`");
    else if ((kind) == (TOKEN_EQUAL_SINGLE))
        return ("`=`");
    else if ((kind) == (TOKEN_EQUAL_DOUBLE))
        return ("`==`");
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ("`&`");
    else if ((kind) == (TOKEN_AMPERSAND_DOUBLE))
        return ("`&&`");
    else if ((kind) == (TOKEN_COMMA))
        return ("`,`");
    else if ((kind) == (TOKEN_ARROW_THIN))
        return ("`->`");
    else if ((kind) == (TOKEN_ARROW_THICK))
        return ("`=>`");
    else if ((kind) == (TOKEN_PLUS_SINGLE))
        return ("`+`");
    else if ((kind) == (TOKEN_UNDERSCORE))
        return ("`_`");
    else if ((kind) == (TOKEN_DOT))
        return ("`.`");
    else if ((kind) == (TOKEN_AT))
        return ("`@`");
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ("`-`");
    else if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ("`*`");
    else if ((kind) == (TOKEN_NOT_EQUAL))
        return ("`!=`");
    else if ((kind) == (TOKEN_BANG))
        return ("`!`");
    else if ((kind) == (TOKEN_SLASH_SINGLE))
        return ("`/`");
    else if ((kind) == (TOKEN_LESS_THAN_EQUAL))
        return ("`<=`");
    else if ((kind) == (TOKEN_LESS_THAN))
        return ("`<`");
    else if ((kind) == (TOKEN_GREATER_THAN_EQUAL))
        return ("`>=`");
    else if ((kind) == (TOKEN_GREATER_THAN))
        return ("`>`");
    else if ((kind) == (TOKEN_PERCENT))
        return ("`%`");
    else if ((kind) == (TOKEN_PIPE_SINGLE))
        return ("`|`");
    else if ((kind) == (TOKEN_PIPE_DOUBLE))
        return ("`||`");
    else if ((kind) == (TOKEN_DOTDOT))
        return ("`..`");
    else if ((kind) == (TOKEN_DOTDOTDOT))
        return ("`...`");
    else if ((kind) == (TOKEN_CARET))
        return ("`^`");
    else if ((kind) == (TOKEN_WILDCARD))
        return ("`_`");
    ((unreachablePcrN)(("Exhaustive handling of kinds in tokenKindToString")));
}
none printPS6070rN(Token_s *this) {
    (((printf))(("kind=%llu, content="), ((this)->kind)));
    ((printPS7720rN)((&((this)->content))));
}
String_s getLocationPS6070rS0540(Token_s *this) { return ((toStringPS8951rS0540)((&((this)->span)))); }
String_s toStringPS6070rS0540(Token_s *this) { return ((toStringPS7720rS0540)((&((this)->content)))); }
SubStr_s getSubStrPS6070rS7720(Token_s *this) { return ((this)->content); }
Span_s getSpanPS6070rS8951(Token_s *this) { return ((this)->span); }
bool equalsPS6070PS6070rB(Token_s *this, Token_s *other) {
    if (((this)->kind) != ((other)->kind))
        return (false);
    if (!((equalsPS8951PS8951rB)((&((this)->span)), (&((other)->span)))))
        return (false);
    if (!((equalsPS7720PS7720rB)((&((this)->content)), (&((other)->content)))))
        return (false);
    return (true);
}
Token_s dummyTokenuszrS6070(usize kind) {
    SubStr_s tmp_4030 = ((defaultSubStrrS7720)());

    return ((newTokenuszPS7720uszuszrS6070)(((usize)(0llu)), (&tmp_4030), ((usize)(0llu)), (kind)));
}
Token_s newTokenuszPS7720uszuszrS6070(usize fileID, SubStr_s *sub, usize start, usize kind) {
    Span_s s = ((newSpanuszuszuszrS8951)((fileID), (start), ((start) + ((sub)->len))));
    return ((Token_s){.content = (*(sub)), .span = (s), .kind = (kind)});
}
Token_s newTokenEOFuszuszrS6070(usize fileID, usize start) {
    return ((Token_s){.content = ((newSubStrPcuszuszrS7720)(("End Of File"), ((usize)(0llu)), ((usize)(11llu)))),
                      .span = ((newSpanuszuszuszrS8951)((fileID), (start), ((start) + ((usize)(1llu))))),
                      .kind = (TOKEN_EOF)});
}
Token_s defaultTokenrS6070(none) { return ((Token_s){.content = ((defaultSubStrrS7720)()), .span = ((defaultSpanrS8951)()), .kind = (TOKEN_EOF)}); }
none push_entryPS3131U7843rN(TypeInfoTable_s *table, TypeInfo_u info) {
    if (((table)->length) >= ((table)->capacity)) {
        usize newCap = (((table)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((table)->elements) = (((realloc))(((table)->elements), ((newCap) * (sizeof(TypeInfo_u))))));
        ((assertBPcrN)((((table)->elements) != (NULL)), ("generateTypeInfoTable: Could not allocate memory")));
        (((table)->capacity) = (newCap));
    }

    (((((table)->elements))[((table)->length)]) = (info));
    (((table)->length) = (((table)->length) + ((usize)(1llu))));
}
usize index_ofPS3131PU7843rusz(TypeInfoTable_s *table, TypeInfo_u *info) {
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_4164 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_4168 = ((get_namePU7843rS7720)((info)));

        if ((((tagAnyru8)((&((((table)->elements))[(i)])))) == ((tagAnyru8)((info)))) && ((equalsPS7720PS7720rB)((&tmp_4164), (&tmp_4168)))) {
            return (i);
        }
    }

    return ((table)->length);
}
bool containsPS3131PU7843rB(TypeInfoTable_s *table, TypeInfo_u *info) {
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_4207 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_4211 = ((get_namePU7843rS7720)((info)));

        if ((((tagAnyru8)((&((((table)->elements))[(i)])))) == ((tagAnyru8)((info)))) && ((equalsPS7720PS7720rB)((&tmp_4207), (&tmp_4211)))) {
            return (true);
        }
    }

    return (false);
}
none pushPS2495uszrN(TypeInfoList_s *this, usize element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS0131S3911rN(FieldTypeInfoList_s *this, FieldTypeInfo_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(FieldTypeInfo_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FieldTypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS3117U0081rN(UnionVariantTypeInfoList_s *this, UnionVariantTypeInfo_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionVariantTypeInfo_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionVariantTypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
SubStr_s get_namePU0081rS7720(UnionVariantTypeInfo_u *info) {
    bool succ_800_ = true;
    bool succ_805_ = true;
    bool succ_810_ = true;

    UnionVariantTypeInfo_u *tmp_1144_ = (info);
    {
        succ_800_ &= (tmp_1144_->tag == 0);
        SubStr_s *name = &tmp_1144_->payload.variant0._0;
        succ_800_ &= true;
        if (succ_800_) {
            {
                return (*name);
            }
            goto after_1144;
        }
    }
    {
        succ_805_ &= (tmp_1144_->tag == 1);
        SubStr_s *name = &tmp_1144_->payload.variant1._0;
        succ_805_ &= true;
        succ_805_ &= true;
        if (succ_805_) {
            {
                return (*name);
            }
            goto after_1144;
        }
    }
    {
        succ_810_ &= (tmp_1144_->tag == 2);
        SubStr_s *name = &tmp_1144_->payload.variant2._0;
        succ_810_ &= true;
        succ_810_ &= true;
        if (succ_810_) {
            {
                return (*name);
            }
            goto after_1144;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1144;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1144:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of variant info kinds in get_name()")));
}
bool equalsPU7843PU7843rB(TypeInfo_u *ti1, TypeInfo_u *ti2) {
    if (((tagAnyru8)((ti1))) != ((tagAnyru8)((ti2))))
        return (false);
    SubStr_s tmp_4424 = ((get_namePU7843rS7720)((ti1)));
    SubStr_s tmp_4428 = ((get_namePU7843rS7720)((ti2)));

    return ((equalsPS7720PS7720rB)((&tmp_4424), (&tmp_4428)));
}
usize get_sizePU7843rusz(TypeInfo_u *info) {
    bool succ_817_ = true;
    bool succ_821_ = true;
    bool succ_826_ = true;
    bool succ_830_ = true;
    bool succ_838_ = true;
    bool succ_845_ = true;
    bool succ_852_ = true;
    bool succ_859_ = true;
    bool succ_862_ = true;

    TypeInfo_u *tmp_1168_ = (info);
    {
        succ_817_ &= (tmp_1168_->tag == 1);
        succ_817_ &= true;
        usize *size_in_bytes = &tmp_1168_->payload.variant1._1;
        succ_817_ &= true;
        succ_817_ &= true;
        if (succ_817_) {
            {
                return (*size_in_bytes);
            }
            goto after_1168;
        }
    }
    {
        succ_821_ &= (tmp_1168_->tag == 3);
        succ_821_ &= true;
        if (succ_821_) {
            {
                return ((usize)(8llu));
            }
            goto after_1168;
        }
    }
    {
        succ_826_ &= (tmp_1168_->tag == 2);
        succ_826_ &= true;
        succ_826_ &= true;
        if (succ_826_) {
            {
                return ((usize)(16llu));
            }
            goto after_1168;
        }
    }
    {
        succ_830_ &= (tmp_1168_->tag == 7);
        succ_830_ &= true;
        if (succ_830_) {
            {
                return ((usize)(8llu));
            }
            goto after_1168;
        }
    }
    {
        succ_838_ &= (tmp_1168_->tag == 4);
        succ_838_ &= true;
        usize *size_in_bytes = &tmp_1168_->payload.variant4._1;
        succ_838_ &= true;
        succ_838_ &= true;
        succ_838_ &= true;
        succ_838_ &= true;
        if (succ_838_) {
            {
                return (*size_in_bytes);
            }
            goto after_1168;
        }
    }
    {
        succ_845_ &= (tmp_1168_->tag == 5);
        succ_845_ &= true;
        usize *size_in_bytes = &tmp_1168_->payload.variant5._1;
        succ_845_ &= true;
        succ_845_ &= true;
        succ_845_ &= true;
        if (succ_845_) {
            {
                return (*size_in_bytes);
            }
            goto after_1168;
        }
    }
    {
        succ_852_ &= (tmp_1168_->tag == 6);
        succ_852_ &= true;
        usize *size_in_bytes = &tmp_1168_->payload.variant6._1;
        succ_852_ &= true;
        succ_852_ &= true;
        succ_852_ &= true;
        if (succ_852_) {
            {
                return (*size_in_bytes);
            }
            goto after_1168;
        }
    }
    {
        succ_859_ &= (tmp_1168_->tag == 8);
        succ_859_ &= true;
        usize *size_in_bytes = &tmp_1168_->payload.variant8._1;
        succ_859_ &= true;
        succ_859_ &= true;
        succ_859_ &= true;
        if (succ_859_) {
            {
                return (*size_in_bytes);
            }
            goto after_1168;
        }
    }
    {
        succ_862_ &= (tmp_1168_->tag == 0);
        if (succ_862_) {
            {
                ((unreachablePcrN)(("get_size(TypeInfo::Unknown)")));
            }
            goto after_1168;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1168;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1168:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_size()")));
}
usize get_alignPU7843rusz(TypeInfo_u *info) {
    bool succ_869_ = true;
    bool succ_873_ = true;
    bool succ_878_ = true;
    bool succ_882_ = true;
    bool succ_890_ = true;
    bool succ_897_ = true;
    bool succ_904_ = true;
    bool succ_911_ = true;
    bool succ_914_ = true;

    TypeInfo_u *tmp_1189_ = (info);
    {
        succ_869_ &= (tmp_1189_->tag == 1);
        succ_869_ &= true;
        succ_869_ &= true;
        usize *align_in_bytes = &tmp_1189_->payload.variant1._2;
        succ_869_ &= true;
        if (succ_869_) {
            {
                return (*align_in_bytes);
            }
            goto after_1189;
        }
    }
    {
        succ_873_ &= (tmp_1189_->tag == 3);
        succ_873_ &= true;
        if (succ_873_) {
            {
                return ((usize)(8llu));
            }
            goto after_1189;
        }
    }
    {
        succ_878_ &= (tmp_1189_->tag == 2);
        succ_878_ &= true;
        succ_878_ &= true;
        if (succ_878_) {
            {
                return ((usize)(8llu));
            }
            goto after_1189;
        }
    }
    {
        succ_882_ &= (tmp_1189_->tag == 7);
        succ_882_ &= true;
        if (succ_882_) {
            {
                return ((usize)(8llu));
            }
            goto after_1189;
        }
    }
    {
        succ_890_ &= (tmp_1189_->tag == 4);
        succ_890_ &= true;
        succ_890_ &= true;
        usize *align_in_bytes = &tmp_1189_->payload.variant4._2;
        succ_890_ &= true;
        succ_890_ &= true;
        succ_890_ &= true;
        if (succ_890_) {
            {
                return (*align_in_bytes);
            }
            goto after_1189;
        }
    }
    {
        succ_897_ &= (tmp_1189_->tag == 5);
        succ_897_ &= true;
        succ_897_ &= true;
        usize *align_in_bytes = &tmp_1189_->payload.variant5._2;
        succ_897_ &= true;
        succ_897_ &= true;
        if (succ_897_) {
            {
                return (*align_in_bytes);
            }
            goto after_1189;
        }
    }
    {
        succ_904_ &= (tmp_1189_->tag == 6);
        succ_904_ &= true;
        succ_904_ &= true;
        usize *align_in_bytes = &tmp_1189_->payload.variant6._2;
        succ_904_ &= true;
        succ_904_ &= true;
        if (succ_904_) {
            {
                return (*align_in_bytes);
            }
            goto after_1189;
        }
    }
    {
        succ_911_ &= (tmp_1189_->tag == 8);
        succ_911_ &= true;
        succ_911_ &= true;
        usize *align_in_bytes = &tmp_1189_->payload.variant8._2;
        succ_911_ &= true;
        succ_911_ &= true;
        if (succ_911_) {
            {
                return (*align_in_bytes);
            }
            goto after_1189;
        }
    }
    {
        succ_914_ &= (tmp_1189_->tag == 0);
        if (succ_914_) {
            {
                ((unreachablePcrN)(("get_size(TypeInfo::Unknown)")));
            }
            goto after_1189;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1189;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1189:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_size()")));
}
SubStr_s get_namePU7843rS7720(TypeInfo_u *info) {
    bool succ_920_ = true;
    bool succ_925_ = true;
    bool succ_930_ = true;
    bool succ_935_ = true;
    bool succ_940_ = true;
    bool succ_945_ = true;
    bool succ_950_ = true;
    bool succ_955_ = true;
    bool succ_958_ = true;

    TypeInfo_u *tmp_1210_ = (info);
    {
        succ_920_ &= (tmp_1210_->tag == 1);
        SubStr_s *name = &tmp_1210_->payload.variant1._0;
        succ_920_ &= true;
        succ_920_ &= true;
        if (succ_920_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_925_ &= (tmp_1210_->tag == 3);
        SubStr_s *name = &tmp_1210_->payload.variant3._0;
        succ_925_ &= true;
        succ_925_ &= true;
        if (succ_925_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_930_ &= (tmp_1210_->tag == 2);
        SubStr_s *name = &tmp_1210_->payload.variant2._0;
        succ_930_ &= true;
        succ_930_ &= true;
        if (succ_930_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_935_ &= (tmp_1210_->tag == 7);
        SubStr_s *name = &tmp_1210_->payload.variant7._0;
        succ_935_ &= true;
        succ_935_ &= true;
        if (succ_935_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_940_ &= (tmp_1210_->tag == 4);
        SubStr_s *name = &tmp_1210_->payload.variant4._0;
        succ_940_ &= true;
        succ_940_ &= true;
        if (succ_940_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_945_ &= (tmp_1210_->tag == 5);
        SubStr_s *name = &tmp_1210_->payload.variant5._0;
        succ_945_ &= true;
        succ_945_ &= true;
        if (succ_945_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_950_ &= (tmp_1210_->tag == 6);
        SubStr_s *name = &tmp_1210_->payload.variant6._0;
        succ_950_ &= true;
        succ_950_ &= true;
        if (succ_950_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_955_ &= (tmp_1210_->tag == 8);
        SubStr_s *name = &tmp_1210_->payload.variant8._0;
        succ_955_ &= true;
        succ_955_ &= true;
        if (succ_955_) {
            {
                return (*name);
            }
            goto after_1210;
        }
    }
    {
        succ_958_ &= (tmp_1210_->tag == 0);
        if (succ_958_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("<unknown>"))));
            }
            goto after_1210;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1210;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1210:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_name()")));
}
none pushPS3111AnyuszrN(ArenaBlock_s *this, Any elem, usize newCap) {
    if (((this)->next) != (NULL)) {
        ((pushPS3111AnyuszrN)(((this)->next), (elem), (newCap)));
        return;
    }

    else if (((this)->length) == ((this)->capacity)) {
        (((this)->next) = ((allocateBlockuszuszrPS3111)((newCap), ((this)->elemSize))));
        ((pushPS3111AnyuszrN)(((this)->next), (elem), (newCap)));
        return;
    }

    ((assertBrN)((((this)->length) < ((this)->capacity))));
    (((memcpy))(((u8 *)((unsigned char *)((u8 *)(((this)->elements))) + (((this)->length) * ((this)->elemSize)))), (elem), ((this)->elemSize)));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Any atPS3111uszrAny(ArenaBlock_s *this, usize index) {
    if ((index) >= ((this)->capacity)) {
        ((assertBPcrN)((((this)->next) != (NULL)), ("Out of bounds access in ArenaBlock")));
        return ((atPS3111uszrAny)(((this)->next), ((index) - ((this)->capacity))));
    }

    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ArenaBlock")));
    return ((usize *)((unsigned char *)((usize *)(((this)->elements))) + ((index) * ((this)->elemSize))));
}
Any lastPS3111rAny(ArenaBlock_s *this) {
    ((assertBPcrN)((((this)->length) > ((usize)(0llu))), ("ArenaBlock.last() called on empty Arena")));
    ((assertBPcrN)((((this)->next) == (NULL)), ("ArenaBlock.last() called on block in the middle of a chain")));
    return ((atPS3111uszrAny)((this), (((this)->length) - ((usize)(1llu)))));
}
usize indexOfPS3111Anyrusz(ArenaBlock_s *this, Any elem) {
    if ((((this)->elements) <= (elem)) && (((usize)((elem))) < (((usize)(((this)->elements))) + (((this)->capacity) * ((this)->elemSize))))) {
        usize index = ((((usize)((elem))) - ((usize)(((this)->elements)))) / ((this)->elemSize));
        ((assertBPcrN)(((index) < ((this)->length)), ("ArenaBlock.indexOf() does not contain the element")));
        return (index);
    }

    else {
        ((assertBPcrN)((((this)->next) != (NULL)), ("ArenaBlock.indexOf() does not contain the element")));
        return (((this)->capacity) + ((indexOfPS3111Anyrusz)(((this)->next), (elem))));
    }
}
ArenaBlock_s *allocateBlockuszuszrPS3111(usize cap, usize size) {
    Any mem = (((calloc))(((usize)(1llu)), (sizeof(ArenaBlock_s))));
    ((assertBPcrN)(((mem) != (NULL)), ("Could not allocate ArenaBlock instance")));
    Any elements = (((calloc))((cap), (size)));
    ((assertBPcrN)(((elements) != (NULL)), ("Could not allocate ArenaBlock elements")));
    ArenaBlock_s *block = ((ArenaBlock_s *)((mem)));
    ((*(block)) = ((ArenaBlock_s){.elements = (elements), .length = ((usize)(0llu)), .capacity = (cap), .next = (NULL), .elemSize = (size)}));
    return (block);
}
none pushPS9153S0890rN(ParsedConfigArena_s *this, ParsedConfig_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedConfig_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedConfig_s *atPS9153uszrPS0890(ParsedConfigArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedConfigArena.at() called on empty Arena")));
    return ((ParsedConfig_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedConfig_s *lastPS9153rPS0890(ParsedConfigArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedConfigArena.last() called on empty Arena")));
    return ((ParsedConfig_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9153PS0890rusz(ParsedConfigArena_s *this, ParsedConfig_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedConfigArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS9483S1892rN(ParsedFileArena_s *this, ParsedFile_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedFile_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedFile_s *atPS9483uszrPS1892(ParsedFileArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFileArena.at() called on empty Arena")));
    return ((ParsedFile_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedFile_s *lastPS9483rPS1892(ParsedFileArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedFileArena.last() called on empty Arena")));
    return ((ParsedFile_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9483PS1892rusz(ParsedFileArena_s *this, ParsedFile_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFileArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS9029S1038rN(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedTopLevelItem_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTopLevelItem_s *atPS9029uszrPS1038(ParsedTopLevelItemArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTopLevelItemArena.at() called on empty Arena")));
    return ((ParsedTopLevelItem_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedTopLevelItem_s *lastPS9029rPS1038(ParsedTopLevelItemArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedTopLevelItemArena.last() called on empty Arena")));
    return ((ParsedTopLevelItem_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9029PS1038rusz(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTopLevelItemArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7393S1882rN(ParsedModuleArena_s *this, ParsedModule_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedModule_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedModule_s *atPS7393uszrPS1882(ParsedModuleArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedModuleArena.at() called on empty Arena")));
    return ((ParsedModule_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedModule_s *lastPS7393rPS1882(ParsedModuleArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedModuleArena.last() called on empty Arena")));
    return ((ParsedModule_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7393PS1882rusz(ParsedModuleArena_s *this, ParsedModule_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedModuleArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS2168S5521rN(ParsedStructDeclArena_s *this, ParsedStructDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedStructDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStructDecl_s *atPS2168uszrPS5521(ParsedStructDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStructDeclArena.at() called on empty Arena")));
    return ((ParsedStructDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedStructDecl_s *lastPS2168rPS5521(ParsedStructDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedStructDeclArena.last() called on empty Arena")));
    return ((ParsedStructDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS2168PS5521rusz(ParsedStructDeclArena_s *this, ParsedStructDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStructDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4268S0997rN(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedUnionDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionDecl_s *atPS4268uszrPS0997(ParsedUnionDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionDeclArena.at() called on empty Arena")));
    return ((ParsedUnionDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedUnionDecl_s *lastPS4268rPS0997(ParsedUnionDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedUnionDeclArena.last() called on empty Arena")));
    return ((ParsedUnionDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4268PS0997rusz(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4249S3506rN(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedUnionVariant_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionVariant_s *atPS4249uszrPS3506(ParsedUnionVariantArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionVariantArena.at() called on empty Arena")));
    return ((ParsedUnionVariant_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedUnionVariant_s *lastPS4249rPS3506(ParsedUnionVariantArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedUnionVariantArena.last() called on empty Arena")));
    return ((ParsedUnionVariant_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4249PS3506rusz(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionVariantArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4111S4904rN(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_LARGE), (sizeof(ParsedFuncDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_LARGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedFuncDecl_s *atPS4111uszrPS4904(ParsedFuncDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFuncDeclArena.at() called on empty Arena")));
    return ((ParsedFuncDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedFuncDecl_s *lastPS4111rPS4904(ParsedFuncDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedFuncDeclArena.last() called on empty Arena")));
    return ((ParsedFuncDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4111PS4904rusz(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFuncDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8646S7247rN(ParsedBlockArena_s *this, ParsedBlock_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedBlock_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedBlock_s *atPS8646uszrPS7247(ParsedBlockArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedBlockArena.at() called on empty Arena")));
    return ((ParsedBlock_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedBlock_s *lastPS8646rPS7247(ParsedBlockArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedBlockArena.last() called on empty Arena")));
    return ((ParsedBlock_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8646PS7247rusz(ParsedBlockArena_s *this, ParsedBlock_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedBlockArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8227S1100rN(ParsedStmtArena_s *this, ParsedStmt_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_LARGE), (sizeof(ParsedStmt_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_LARGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStmt_s *atPS8227uszrPS1100(ParsedStmtArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStmtArena.at() called on empty Arena")));
    return ((ParsedStmt_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedStmt_s *lastPS8227rPS1100(ParsedStmtArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedStmtArena.last() called on empty Arena")));
    return ((ParsedStmt_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8227PS1100rusz(ParsedStmtArena_s *this, ParsedStmt_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStmtArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7882S2435rN(ParsedExprArena_s *this, ParsedExpr_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(ParsedExpr_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedExpr_s *atPS7882uszrPS2435(ParsedExprArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedExprArena.at() called on empty Arena")));
    return ((ParsedExpr_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedExpr_s *lastPS7882rPS2435(ParsedExprArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedExprArena.last() called on empty Arena")));
    return ((ParsedExpr_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7882PS2435rusz(ParsedExprArena_s *this, ParsedExpr_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedExprArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4419S1372rN(ParsedTypeNodeArena_s *this, ParsedTypeNode_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(ParsedTypeNode_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTypeNode_s *atPS4419uszrPS1372(ParsedTypeNodeArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTypeNodeArena.at() called on empty Arena")));
    return ((ParsedTypeNode_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedTypeNode_s *lastPS4419rPS1372(ParsedTypeNodeArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedTypeNodeArena.last() called on empty Arena")));
    return ((ParsedTypeNode_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4419PS1372rusz(ParsedTypeNodeArena_s *this, ParsedTypeNode_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTypeNodeArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4174U5175rN(TypeArena_s *this, Type_u elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(Type_u)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Type_u *atPS4174uszrPU5175(TypeArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("TypeArena.at() called on empty Arena")));
    return ((Type_u *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
Type_u *lastPS4174rPU5175(TypeArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("TypeArena.last() called on empty Arena")));
    return ((Type_u *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4174PU5175rusz(TypeArena_s *this, Type_u *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("TypeArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8168S3633rN(DLLArena_s *this, DLL_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(DLL_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
DLL_s *atPS8168uszrPS3633(DLLArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("DLLArena.at() called on empty Arena")));
    return ((DLL_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
DLL_s *lastPS8168rPS3633(DLLArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("DLLArena.last() called on empty Arena")));
    return ((DLL_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8168PS3633rusz(DLLArena_s *this, DLL_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("DLLArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8361S1826rN(ParsedPatternArena_s *this, ParsedPattern_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedPattern_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedPattern_s *atPS8361uszrPS1826(ParsedPatternArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedPatternArena.at() called on empty Arena")));
    return ((ParsedPattern_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedPattern_s *lastPS8361rPS1826(ParsedPatternArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedPatternArena.last() called on empty Arena")));
    return ((ParsedPattern_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8361PS1826rusz(ParsedPatternArena_s *this, ParsedPattern_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedPatternArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7368S5777rN(LLVMMetadataArena_s *this, LLVMMetadata_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(LLVMMetadata_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMMetadata_s *atPS7368uszrPS5777(LLVMMetadataArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("LLVMMetadataArena.at() called on empty Arena")));
    return ((LLVMMetadata_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
LLVMMetadata_s *lastPS7368rPS5777(LLVMMetadataArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("LLVMMetadataArena.last() called on empty Arena")));
    return ((LLVMMetadata_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7368PS5777rusz(LLVMMetadataArena_s *this, LLVMMetadata_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("LLVMMetadataArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
SubStr_s BUILD_A_KEYWORDPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
bool isKeywordPS3493PS7720rB(Lexer_s *this, SubStr_s *word) {
    return (
        (((((((((((((((((((((((((equalsPS7720PS7720rB)((word), (&(KEYWORD_LET)))) || ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FUNC))))) || ((equalsPS7720PS7720rB)((word), (&(KEYWORD_COMPTIME))))) ||
                             ((equalsPS7720PS7720rB)((word), (&(KEYWORD_STRUCT))))) ||
                            ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ENUM))))) ||
                           ((equalsPS7720PS7720rB)((word), (&(KEYWORD_UNION))))) ||
                          ((equalsPS7720PS7720rB)((word), (&(KEYWORD_RETURN))))) ||
                         ((equalsPS7720PS7720rB)((word), (&(KEYWORD_MODULE))))) ||
                        ((equalsPS7720PS7720rB)((word), (&(KEYWORD_IMPORT))))) ||
                       ((equalsPS7720PS7720rB)((word), (&(KEYWORD_IF))))) ||
                      ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ELSE))))) ||
                     ((equalsPS7720PS7720rB)((word), (&(KEYWORD_WHILE))))) ||
                    ((equalsPS7720PS7720rB)((word), (&(KEYWORD_SIZEOF))))) ||
                   ((equalsPS7720PS7720rB)((word), (&(KEYWORD_AS))))) ||
                  ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FOR))))) ||
                 ((equalsPS7720PS7720rB)((word), (&(KEYWORD_BREAK))))) ||
                ((equalsPS7720PS7720rB)((word), (&(KEYWORD_CONTINUE))))) ||
               ((equalsPS7720PS7720rB)((word), (&(KEYWORD_NULL))))) ||
              ((equalsPS7720PS7720rB)((word), (&(KEYWORD_BLANK))))) ||
             ((equalsPS7720PS7720rB)((word), (&(KEYWORD_TRUE))))) ||
            ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FALSE))))) ||
           ((equalsPS7720PS7720rB)((word), (&(KEYWORD_CONFIG))))) ||
          ((equalsPS7720PS7720rB)((word), (&(KEYWORD_MATCH))))) ||
         ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ASM))))) ||
        ((equalsPS7720PS7720rB)((word), (&(KEYWORD_TYPEINFO)))));
}
char escapeCharSequencePS3493PS7720PS0540Puszrc(Lexer_s *this, SubStr_s *tmp, String_s *s, usize *len) {
    bool escaped = (false);
    usize extraOffset = ((usize)(0llu));
    char c = ((((tmp)->start))[((usize)(0llu))]);
    if ((c) == ('\\')) {
        ((c) = ((((tmp)->start))[((usize)(1llu))]));
        if ((c) == ('n')) {
            ((pushCharPS0540crN)((s), ('\n')));
        }

        else if ((c) == ('r')) {
            ((pushCharPS0540crN)((s), ('\r')));
        }

        else if ((c) == ('t')) {
            ((pushCharPS0540crN)((s), ('\t')));
        }

        else if ((c) == ('0')) {
            ((pushCharPS0540crN)((s), ('\0')));
        }

        else if ((c) == ('\\')) {
            ((pushCharPS0540crN)((s), ('\\')));
        }

        else if ((c) == ('\'')) {
            ((pushCharPS0540crN)((s), ('\'')));
        }

        else if ((c) == ('\"')) {
            ((pushCharPS0540crN)((s), ('\"')));
        }

        else if ((c) == ('x')) {
            char lower = ((((tmp)->start))[((usize)(2llu))]);
            char upper = ((((tmp)->start))[((usize)(3llu))]);
            ((assertBPcrN)(((isHexDigitcrB)((lower))), ("Expected hex digits for \\x")));
            ((assertBPcrN)(((isHexDigitcrB)((upper))), ("Expected hex digits for \\x")));
            char byte = ((char)(((((asHexcru8)((lower))) * ((u8)(16))) + ((asHexcru8)((upper))))));
            ((pushCharPS0540crN)((s), (byte)));
            ((extraOffset) = ((usize)(2llu)));
        }

        else {
            SubStr_s tmp_6709 = ((newSubStrPcuszuszrS7720)((&(c)), ((usize)(0llu)), ((usize)(1llu))));

            Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_6709), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
            String_s loc = ((toStringPS8951rS0540)((&((t).span))));
            (((fprintf))((stderr_), ("%s: %s: Can\'t escape character `%c`.\n"), ((loc).buffer), (ERR_STR), (c)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((escaped) = (true));
    }

    else {
        ((pushCharPS0540crN)((s), (c)));
    }

    usize step = ((usize)(1llu));
    if (escaped) {
        ((step) = ((usize)(2llu)));
    }

    ((step) = ((step) + (extraOffset)));
    ((*(len)) = ((*(len)) + (step)));
    ((*(tmp)) = ((substringPS7720uszuszrS7720)((tmp), (step), ((tmp)->len))));
    return ((((tmp)->start))[((usize)(0llu))]);
}
bool advancePS3493rB(Lexer_s *this) {
    (((this)->ptr) = (((this)->ptr) + ((usize)(1llu))));
    (((this)->content) = ((substringPS7720uszuszrS7720)((&((this)->content)), ((usize)(1llu)), (((this)->content).len))));
    return (((this)->ptr) >= ((this)->len));
}
Token_s peekPS3493rS6070(Lexer_s *this) {
    usize ptr = ((this)->ptr);
    SubStr_s content = ((this)->content);
    usize len = ((this)->len);
    Token_s tkn = ((__nextPS3493BrS6070)((this), (true)));
    (((this)->ptr) = (ptr));
    (((this)->content) = (content));
    (((this)->len) = (len));
    return (tkn);
}
Token_s nextPS3493rS6070(Lexer_s *this) { return ((__nextPS3493BrS6070)((this), (false))); }
Token_s __nextPS3493BrS6070(Lexer_s *this, bool peek) {
    if (((this)->ptr) == ((this)->len)) {
        return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
    }

    char currChar = (((((this)->content).start))[((usize)(0llu))]);
    while ((isWhitespacecrB)((currChar))) {
        if ((advancePS3493rB)((this))) {
            return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
        }

        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
    }

    if (((isAlphabeticcrB)((currChar))) || ((currChar) == ('_'))) {
        usize len = ((usize)(0llu));
        SubStr_s tmp = ((this)->content);
        char c = ((((tmp).start))[((usize)(0llu))]);
        while ((((isNumericcrB)((c))) || ((isAlphabeticcrB)((c)))) || ((c) == ('_'))) {
            ((len) = ((len) + ((usize)(1llu))));
            ((tmp) = ((substringPS7720uszuszrS7720)((&(tmp)), ((usize)(1llu)), ((tmp).len))));
            ((c) = ((((tmp).start))[((usize)(0llu))]));
        }

        SubStr_s word = ((substringPS7720uszuszrS7720)((&((this)->content)), ((usize)(0llu)), (len)));
        (((this)->ptr) = (((this)->ptr) + (len)));
        (((this)->content) = (tmp));
        SubStr_s tmp_6970 = (((BUILD_A_KEYWORDPcrS7720)(("_"))));

        if ((equalsPS7720PS7720rB)((&(word)), (&tmp_6970))) {
            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_WILDCARD)));
        }

        if ((isKeywordPS3493PS7720rB)((this), (&(word)))) {
            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_KEYWORD)));
        }

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_IDENT)));
    }

    else if ((isNumericcrB)((currChar))) {
        usize len = ((usize)(0llu));
        SubStr_s tmp = ((this)->content);
        usize val = ((usize)(0llu));
        bool prefixed = (false);
        if ((currChar) == ('0')) {
            ((len) = ((len) + ((usize)(1llu))));
            ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
            ((currChar) = ((((tmp).start))[((usize)(0llu))]));
            if ((currChar) == ('x')) {
                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                ((prefixed) = (true));
                while (true) {
                    char c = ((((tmp).start))[((usize)(0llu))]);
                    if ((isHexDigitcrB)((c))) {
                        ((val) = ((((usize)(16llu)) * (val)) + ((usize)(((asHexcru8)((c)))))));
                    }

                    else if ((c) == ('_')) {
                    }

                    else {
                        break;
                    }

                    ((len) = ((len) + ((usize)(1llu))));
                    ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                }

            }

            else if ((currChar) == ('b')) {
                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                ((prefixed) = (true));
                while (true) {
                    char c = ((((tmp).start))[((usize)(0llu))]);
                    if (((c) == ('0')) || ((c) == ('1'))) {
                        ((val) = (((usize)(2llu)) * (val)));
                        if ((c) == ('1'))
                            ((val) = ((val) + ((usize)(1llu))));
                    }

                    else if ((c) == ('_')) {
                    }

                    else {
                        break;
                    }

                    ((len) = ((len) + ((usize)(1llu))));
                    ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                }

            }

            else if ((isAlphabeticcrB)((currChar))) {
                SubStr_s tmp_7191 = ((newSubStrPcuszuszrS7720)((&(currChar)), ((usize)(0llu)), ((usize)(1llu))));

                Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7191), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
                String_s loc = ((toStringPS8951rS0540)((&((t).span))));
                (((fprintf))((stderr_), ("%s: %s: Invalid number prefix `%c`.\n"), ((loc).buffer), (ERR_STR), (currChar)));
                (((C_exiti32rN))(((i32)(1))));
            }
        }

        if (!(prefixed)) {
            ((assertBrN)(((val) == ((usize)(0llu)))));
            while (true) {
                char c = ((((tmp).start))[((usize)(0llu))]);
                if ((isNumericcrB)((c))) {
                    ((val) = ((((usize)(10llu)) * (val)) + (((usize)((c))) - ((usize)(48llu)))));
                }

                else if ((c) == ('_')) {
                }

                else {
                    break;
                }

                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
            }
        }

        String_s _word = ((newStringrS0540)());
        ((pushNumberPS0540uszrN)((&(_word)), (val)));
        SubStr_s word = ((asSubStrPS0540rS7720)((&(_word))));
        (((this)->ptr) = (((this)->ptr) + (len)));
        (((this)->content) = (tmp));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_INT_LITERAL)));
    }

    else if ((currChar) == ('\"')) {
        ((advancePS3493rB)((this)));
        if ((((this)->content).len) == ((usize)(0llu))) {
            ((todo_with_msgPcrN)(("unbalanced \"")));
        }

        if (peek) {
            SubStr_s tmp_7330 = ((newSubStrPcuszuszrS7720)(("\""), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7330), (((this)->ptr) - ((usize)(1llu))), (TOKEN_STRING_LITERAL)));
        }

        usize len = ((usize)(0llu));
        String_s s = ((newStringrS0540)());
        char c = (((((this)->content).start))[((usize)(0llu))]);
        while ((c) != ('\"')) {
            usize l = ((usize)(0llu));
            ((c) = ((escapeCharSequencePS3493PS7720PS0540Puszrc)((this), (&((this)->content)), (&(s)), (&(l)))));
            (((this)->ptr) = (((this)->ptr) + (l)));
            ((len) = ((len) + (l)));
        }

        SubStr_s word = ((substringPS0540uszuszrS7720)((&(s)), ((usize)(0llu)), ((s).length)));
        ((advancePS3493rB)((this)));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_STRING_LITERAL)));
    }

    else if ((currChar) == ('\'')) {
        ((advancePS3493rB)((this)));
        if ((((this)->content).len) == ((usize)(0llu))) {
            ((todo_with_msgPcrN)(("unbalanced \'")));
        }

        usize len = ((usize)(0llu));
        String_s s = ((newStringrS0540)());
        char c = (((((this)->content).start))[((usize)(0llu))]);
        while ((c) != ('\'')) {
            usize l = ((usize)(0llu));
            ((c) = ((escapeCharSequencePS3493PS7720PS0540Puszrc)((this), (&((this)->content)), (&(s)), (&(l)))));
            (((this)->ptr) = (((this)->ptr) + (l)));
            ((len) = ((len) + (l)));
        }

        SubStr_s word = ((substringPS0540uszuszrS7720)((&(s)), ((usize)(0llu)), ((s).length)));
        if (((word).len) != ((usize)(1llu))) {
            Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_IDENT)));
            String_s loc = ((toStringPS8951rS0540)((&((t).span))));
            (((fprintf))((stderr_), ("%s: %s: Invalid character literal `%.*s`.\n"), ((loc).buffer), (ERR_STR), ((word).len), ((word).start)));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((advancePS3493rB)((this)));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_CHAR_LITERAL)));
    }

    else if ((currChar) == ('(')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7544 = ((newSubStrPcuszuszrS7720)(("("), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7544), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PAREN_OPEN)));
    }

    else if ((currChar) == (')')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7567 = ((newSubStrPcuszuszrS7720)((")"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7567), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PAREN_CLOSE)));
    }

    else if ((currChar) == ('{')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7590 = ((newSubStrPcuszuszrS7720)(("{"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7590), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CURLY_OPEN)));
    }

    else if ((currChar) == ('}')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7613 = ((newSubStrPcuszuszrS7720)(("}"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7613), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CURLY_CLOSE)));
    }

    else if ((currChar) == ('[')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7636 = ((newSubStrPcuszuszrS7720)(("["), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7636), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SQUARE_OPEN)));
    }

    else if ((currChar) == (']')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7659 = ((newSubStrPcuszuszrS7720)(("]"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7659), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SQUARE_CLOSE)));
    }

    else if ((currChar) == ('<')) {
        ((advancePS3493rB)((this)));
        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
        if ((currChar) == ('=')) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7697 = ((newSubStrPcuszuszrS7720)(("<="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7697), (((this)->ptr) - ((usize)(2llu))), (TOKEN_LESS_THAN_EQUAL)));
        }

        else {
            SubStr_s tmp_7714 = ((newSubStrPcuszuszrS7720)(("<"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7714), (((this)->ptr) - ((usize)(1llu))), (TOKEN_LESS_THAN)));
        }

    }

    else if ((currChar) == ('>')) {
        ((advancePS3493rB)((this)));
        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
        if ((currChar) == ('=')) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7752 = ((newSubStrPcuszuszrS7720)((">="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7752), (((this)->ptr) - ((usize)(2llu))), (TOKEN_GREATER_THAN_EQUAL)));
        }

        else {
            SubStr_s tmp_7769 = ((newSubStrPcuszuszrS7720)((">"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7769), (((this)->ptr) - ((usize)(1llu))), (TOKEN_GREATER_THAN)));
        }

    }

    else if ((currChar) == (';')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7792 = ((newSubStrPcuszuszrS7720)((";"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7792), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SEMI_COLON)));
    }

    else if ((currChar) == (':')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == (':'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7835 = ((newSubStrPcuszuszrS7720)(("::"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7835), (((this)->ptr) - ((usize)(2llu))), (TOKEN_COLON_DOUBLE)));
        }

        else {
            SubStr_s tmp_7852 = ((newSubStrPcuszuszrS7720)((":"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7852), (((this)->ptr) - ((usize)(1llu))), (TOKEN_COLON_SINGLE)));
        }

    }

    else if ((currChar) == ('=')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('='))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7895 = ((newSubStrPcuszuszrS7720)(("=="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7895), (((this)->ptr) - ((usize)(2llu))), (TOKEN_EQUAL_DOUBLE)));
        }

        else if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('>'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7932 = ((newSubStrPcuszuszrS7720)(("=>"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7932), (((this)->ptr) - ((usize)(2llu))), (TOKEN_ARROW_THICK)));
        }

        else {
            SubStr_s tmp_7949 = ((newSubStrPcuszuszrS7720)(("="), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7949), (((this)->ptr) - ((usize)(1llu))), (TOKEN_EQUAL_SINGLE)));
        }

    }

    else if ((currChar) == ('&')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('&'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7992 = ((newSubStrPcuszuszrS7720)(("&&"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7992), (((this)->ptr) - ((usize)(2llu))), (TOKEN_AMPERSAND_DOUBLE)));
        }

        else {
            SubStr_s tmp_8009 = ((newSubStrPcuszuszrS7720)(("&"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8009), (((this)->ptr) - ((usize)(1llu))), (TOKEN_AMPERSAND_SINGLE)));
        }

    }

    else if ((currChar) == ('_')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8032 = ((newSubStrPcuszuszrS7720)(("_"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8032), (((this)->ptr) - ((usize)(1llu))), (TOKEN_UNDERSCORE)));
    }

    else if ((currChar) == ('.')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('.'))) {
            ((advancePS3493rB)((this)));
            if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('.'))) {
                ((advancePS3493rB)((this)));
                SubStr_s tmp_8095 = ((newSubStrPcuszuszrS7720)(("..."), ((usize)(0llu)), ((usize)(3llu))));

                return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8095), (((this)->ptr) - ((usize)(3llu))), (TOKEN_DOTDOTDOT)));
            }

            SubStr_s tmp_8112 = ((newSubStrPcuszuszrS7720)((".."), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8112), (((this)->ptr) - ((usize)(2llu))), (TOKEN_DOTDOT)));
        }

        SubStr_s tmp_8129 = ((newSubStrPcuszuszrS7720)(("."), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8129), (((this)->ptr) - ((usize)(1llu))), (TOKEN_DOT)));
    }

    else if ((currChar) == (',')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8152 = ((newSubStrPcuszuszrS7720)((","), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8152), (((this)->ptr) - ((usize)(1llu))), (TOKEN_COMMA)));
    }

    else if ((currChar) == ('+')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8175 = ((newSubStrPcuszuszrS7720)(("+"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8175), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PLUS_SINGLE)));
    }

    else if ((currChar) == ('*')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8198 = ((newSubStrPcuszuszrS7720)(("*"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8198), (((this)->ptr) - ((usize)(1llu))), (TOKEN_ASTERISK_SINGLE)));
    }

    else if ((currChar) == ('@')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8221 = ((newSubStrPcuszuszrS7720)(("@"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8221), (((this)->ptr) - ((usize)(1llu))), (TOKEN_AT)));
    }

    else if ((currChar) == ('%')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8244 = ((newSubStrPcuszuszrS7720)(("%"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8244), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PERCENT)));
    }

    else if ((currChar) == ('^')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8267 = ((newSubStrPcuszuszrS7720)(("^"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8267), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CARET)));
    }

    else if ((currChar) == ('|')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('|'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8310 = ((newSubStrPcuszuszrS7720)(("||"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8310), (((this)->ptr) - ((usize)(2llu))), (TOKEN_PIPE_DOUBLE)));
        }

        else {
            SubStr_s tmp_8327 = ((newSubStrPcuszuszrS7720)(("|"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8327), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PIPE_SINGLE)));
        }

    }

    else if ((currChar) == ('-')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('>'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8370 = ((newSubStrPcuszuszrS7720)(("->"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8370), (((this)->ptr) - ((usize)(2llu))), (TOKEN_ARROW_THIN)));
        }

        else {
            SubStr_s tmp_8387 = ((newSubStrPcuszuszrS7720)(("-"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8387), (((this)->ptr) - ((usize)(1llu))), (TOKEN_MINUS_SINGLE)));
        }

    }

    else if ((currChar) == ('!')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('='))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8430 = ((newSubStrPcuszuszrS7720)(("!="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8430), (((this)->ptr) - ((usize)(2llu))), (TOKEN_NOT_EQUAL)));
        }

        else {
            SubStr_s tmp_8447 = ((newSubStrPcuszuszrS7720)(("!"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8447), (((this)->ptr) - ((usize)(1llu))), (TOKEN_BANG)));
        }

    }

    else if (((currChar) == ('/')) && ((((((this)->content).start))[((usize)(1llu))]) == ('*'))) {
        while (true) {
            if ((advancePS3493rB)((this))) {
                return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
            }

            ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
            char next = (((((this)->content).start))[((usize)(1llu))]);
            if (((currChar) == ('*')) && ((next) == ('/'))) {
                break;
            }
        }

        ((advancePS3493rB)((this)));
        ((advancePS3493rB)((this)));
        return ((nextPS3493rS6070)((this)));
    }

    else if ((currChar) == ('/')) {
        if ((((((this)->content).start))[((usize)(1llu))]) == ('/')) {
            while ((currChar) != ('\n')) {
                if ((advancePS3493rB)((this))) {
                    return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
                }

                ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
            }

            return ((nextPS3493rS6070)((this)));
        }

        else {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8562 = ((newSubStrPcuszuszrS7720)(("/"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8562), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SLASH_SINGLE)));
        }

    }

    else {
        SubStr_s tmp_8580 = ((newSubStrPcuszuszrS7720)((&(currChar)), ((usize)(0llu)), ((usize)(1llu))));

        Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8580), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
        String_s loc = ((toStringPS8951rS0540)((&((t).span))));
        (((fprintf))((stderr_), ("%s: %s: Unknown character `%c`.\n"), ((loc).buffer), (ERR_STR), (currChar)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
Lexer_s newLexeruszS7720rS3493(usize fileID, SubStr_s content) { return ((Lexer_s){.content = (content), .fileID = (fileID), .ptr = ((usize)(0llu)), .len = ((content).len)}); }
IRFuncList_s asListPS2612rS8040(String_IRFuncHashMap_s *this) {
    IRFuncList_s l = ((IRFuncList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (i)));
        if ((elem)->set) {
            ((pushPS8040S7132rN)((&(l)), ((elem)->value)));
        }
    }

    return (l);
}
bool needsResizePS2612rB(String_IRFuncHashMap_s *this) {
    if (((this)->capacity) == ((usize)(0llu))) {
        return (true);
    }

    else {
        f64 loadFactor = (((f64)(((this)->length))) / ((f64)(((this)->capacity))));
        ((assertBrN)(((loadFactor) <= ((f64)(1)))));
        return ((((f64)(10)) * (loadFactor)) > ((f64)(6)));
    }
}
usize indexOfPS2612PS0540rusz(String_IRFuncHashMap_s *this, String_s *key) {
    (((this)->locked) = (true));
    String_IRFuncEntry_s *elem = ((getEntryPS2612PS0540rPS0516)((this), (key)));
    ((assertBPcrN)(((elem) != (NULL)), ("String_IRFuncHashMap.indexOf() does not contain key")));
    return (((usize)((unsigned char *)(elem) - (unsigned char *)((this)->elements))) / (sizeof(String_IRFuncEntry_s)));
}
IRFunc_s *atPS2612uszrPS7132(String_IRFuncHashMap_s *this, usize index) {
    ((assertBPcrN)(((this)->locked), ("Can only get elements at an index if the HashMap is locked")));
    String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (index)));
    ((assertBPcrN)(((elem) != (NULL)), ("Expected to find element at the given index")));
    ((assertBPcrN)(((elem)->set), ("Expected set element at the given index")));
    return (&((elem)->value));
}
none resizeIfNecessaryPS2612rN(String_IRFuncHashMap_s *this) {
    if ((needsResizePS2612rB)((this))) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(256llu)));
        String_IRFuncEntry_s *newElements = (((calloc))((newCap), (sizeof(String_IRFuncEntry_s))));
        ((assertBPcrN)(((newElements) != (NULL)), ("Could not allocate memory in String_IRFuncHashMap.resizeIfNecessary")));
        String_IRFuncHashMap_s newThis = ((String_IRFuncHashMap_s){.elements = (newElements), .length = ((usize)(0llu)), .capacity = (newCap), .locked = ((this)->locked)});
        for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
            String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (i)));
            if ((elem)->set)
                ((addPS2612S0540S7132rN)((&(newThis)), ((elem)->key), ((elem)->value)));
        }

        (((free))(((this)->elements)));
        ((*(this)) = (newThis));
    }
}
none addPS2612S0540S7132rN(String_IRFuncHashMap_s *this, String_s key, IRFunc_s value) {
    if ((this)->locked) {
        ((todo_with_msgPcrN)(("HashMap is locked, can\'t add elements")));
    }

    ((resizeIfNecessaryPS2612rN)((this)));
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize hash = (((hashPS0540rusz)((&(key)))) % ((this)->capacity));
    usize index = (hash);
    usize stop = ((hash) - ((usize)(1llu)));
    if ((hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((index) != (stop)) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (index)));
        if (!((elem)->set)) {
            ((*(elem)) = ((String_IRFuncEntry_s){.set = (true), .key = (key), .value = (value)}));
            (((this)->length) = (((this)->length) + ((usize)(1llu))));
            return;
        }

        ((index) = (((index) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Could not insert element into HashMap")));
}
IRFunc_s *getPS2612PS0540rPS7132(String_IRFuncHashMap_s *this, String_s *key) {
    String_IRFuncEntry_s *entry = ((getEntryPS2612PS0540rPS0516)((this), (key)));
    if ((entry) == (NULL))
        return (NULL);
    return (&((entry)->value));
}
String_IRFuncEntry_s *getEntryPS2612PS0540rPS0516(String_IRFuncHashMap_s *this, String_s *key) {
    if (((this)->length) == ((usize)(0llu)))
        return (NULL);
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize hash = (((hashPS0540rusz)((key))) % ((this)->capacity));
    usize stop = ((hash) - ((usize)(1llu)));
    if ((hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((hash) != (stop)) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (hash)));
        if (!((elem)->set))
            return (NULL);
        if ((equalsPS0540PS0540rB)((&((elem)->key)), (key)))
            return (elem);
        ((hash) = (((hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Load Factor guarantees that there\'s always at least one unset Entry in the HashMap.")));
}
String_IRFuncEntry_s *getAtIndexPS2612uszrPS0516(String_IRFuncHashMap_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->capacity)), ("Out of bounds access in String_IRFuncHashMap.getAtIndex")));
    return ((String_IRFuncEntry_s *)((unsigned char *)((this)->elements) + ((index) * (sizeof(String_IRFuncEntry_s)))));
}
bool containsKeyPS2612PS0540rB(String_IRFuncHashMap_s *this, String_s *key) { return (((getPS2612PS0540rPS7132)((this), (key))) != (NULL)); }
none freeS1803rN(Function_s fn) {
    if ((failedS1457rB)((((VirtualFree))(((Any)(usize)(((fn).run))), ((fn).size), ((u32)(16384)))))) {
        (((printf))(("warning: Could not free function at %p\n"), ((fn).run)));
    }
}
none pushPS5123ccccccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8) {
    ((pushPS5123u8u8u8u8u8u8u8u8rN)((buf), ((u8)((b1))), ((u8)((b2))), ((u8)((b3))), ((u8)((b4))), ((u8)((b5))), ((u8)((b6))), ((u8)((b7))), ((u8)((b8)))));
}
none pushPS5123ccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4) {
    ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2)))));
    ((pushPS5123u8u8rN)((buf), ((u8)((b3))), ((u8)((b4)))));
}
none pushPS5123cccrN(ByteBuffer_s *buf, char b1, char b2, char b3) {
    ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2)))));
    ((pushPS5123u8rN)((buf), ((u8)((b3)))));
}
none pushPS5123ccrN(ByteBuffer_s *buf, char b1, char b2) { ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2))))); }
none pushPS5123crN(ByteBuffer_s *buf, char b1) { ((pushPS5123u8rN)((buf), ((u8)((b1))))); }
none pushPS5123u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2) {
    ((pushPS5123u8rN)((buf), (b1)));
    ((pushPS5123u8rN)((buf), (b2)));
}
none pushPS5123u8u8u8u8u8u8u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2, u8 b3, u8 b4, u8 b5, u8 b6, u8 b7, u8 b8) {
    ((pushPS5123u8rN)((buf), (b1)));
    ((pushPS5123u8rN)((buf), (b2)));
    ((pushPS5123u8rN)((buf), (b3)));
    ((pushPS5123u8rN)((buf), (b4)));
    ((pushPS5123u8rN)((buf), (b5)));
    ((pushPS5123u8rN)((buf), (b6)));
    ((pushPS5123u8rN)((buf), (b7)));
    ((pushPS5123u8rN)((buf), (b8)));
}
none pushPS5123u8rN(ByteBuffer_s *buf, u8 element) {
    if (((buf)->length) >= ((buf)->capacity)) {
        usize newCap = (((buf)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((buf)->elements) = (((realloc))(((buf)->elements), ((newCap) * (sizeof(u8))))));
        ((assertBPcrN)((((buf)->elements) != (NULL)), ("Could not allocate memory in ByteBuffer.push")));
        (((buf)->capacity) = (newCap));
    }

    (((((buf)->elements))[((buf)->length)]) = (element));
    (((buf)->length) = (((buf)->length) + ((usize)(1llu))));
}
none extendPS5123PS5123rN(ByteBuffer_s *buf, ByteBuffer_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5123u8rN)((buf), ((((other)->elements))[(i)])));
    }

    (((free))(((other)->elements)));
    ((*(other)) = ((ByteBuffer_s){0}));
}
none pushImmPS5123S8630rN(ByteBuffer_s *bytes, ImmI32_s imm) {
    u8 *p = ((u8 *)((&((imm).b))));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(0llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(1llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(2llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(3llu))])));
}
none pushImmPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm) {
    u8 *p = ((u8 *)((&((imm).b))));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(0llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(1llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(2llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(3llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(4llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(5llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(6llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(7llu))])));
}
none modRMPS5123u8u8S7038rN(ByteBuffer_s *bytes, u8 addr, u8 opext, GPR_s reg) {
    u8 byte = ((u8)(((shiftLeftuszuszrusz)(((usize)((addr))), ((usize)(6llu))))));
    ((byte) = ((byte) | ((u8)(((shiftLeftuszuszrusz)(((usize)((opext))), ((usize)(3llu))))))));
    ((byte) = ((byte) | (((reg).r) % ((u8)(8)))));
    ((pushPS5123u8rN)((bytes), (byte)));
}
none modPrefixPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r) {
    u8 rex = ((u8)(('H')));
    if (((tagAnyru8)((&(r)))) >= ((u8)(8)))
        ((rex) = ((rex) | ((u8)(1))));
    ((pushPS5123u8rN)((bytes), (rex)));
}
none movPS5123S7038S7038rN(ByteBuffer_s *bytes, GPR_s to, GPR_s from) {
    ((modPrefixPS5123S7038rN)((bytes), (from)));
    ((pushPS5123crN)((bytes), ('\x89')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((tagAnyru8)((&(from)))), (to)));
}
none movPS5123S5949S5363rN(ByteBuffer_s *bytes, FPR_s r, ImmF32_s imm) {
    u32 v = (*((u32 *)((&((imm).b)))));
    ((movPS5123S7038S8630rN)((bytes), (RAX), ((ImmI32_s){.b = (v)})));
    ((pushPS5123cccrN)((bytes), ('f'), ('\xF'), ('n')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((r).r), (RAX)));
}
none movPS5123S5949S5464rN(ByteBuffer_s *bytes, FPR_s r, ImmF64_s imm) {
    u64 v = (*((u64 *)((&((imm).b)))));
    ((movPS5123S7038S8731rN)((bytes), (RAX), ((ImmI64_s){.b = (v)})));
    ((pushPS5123ccccrN)((bytes), ('f'), ('H'), ('\xF'), ('n')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((r).r), (RAX)));
}
none movPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    char opcode = ((char)((((u8)(('\xB8'))) + (((r).r) % ((u8)(8))))));
    ((pushPS5123crN)((bytes), (opcode)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none movPS5123S7038S8731rN(ByteBuffer_s *bytes, GPR_s r, ImmI64_s imm) {
    char opcode = ((char)((((u8)(('\xB8'))) + (((r).r) % ((u8)(8))))));
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), (opcode)));
    ((pushImmPS5123S8731rN)((bytes), (imm)));
}
none pushPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg) {
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(6)), (reg)));
}
none popPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg) {
    ((pushPS5123crN)((bytes), ('\x8F')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(0)), (reg)));
}
none movPS5123S7038u32S8731rN(ByteBuffer_s *bytes, GPR_s r, u32 offset, ImmI64_s imm) {
    ((movPS5123S7038S8731rN)((bytes), (RBX), (imm)));
    ((assertBPcrN)(((offset) < ((u32)(256))), ("only single byte offset for now")));
    ((pushPS5123ccccrN)((bytes), ('H'), ('\x89'), ('\\'), ('$')));
    ((pushPS5123crN)((bytes), ((char)((offset)))));
}
none addPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), ('\x81')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(0)), (r)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none subPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), ('\x81')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(5)), (r)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none callPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r) {
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(2)), (r)));
}
none pushPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm) {
    ((movPS5123S7038S8731rN)((bytes), (RAX), (imm)));
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(6)), (RAX)));
}
none pushPS2247S6579rN(CallStack_s *this, CallStackInfo_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(CallStackInfo_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in CallStack.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
CallStackInfo_s *atPS2247uszrPS6579(CallStack_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in CallStack.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in CallStack.at")));
    return (&((((this)->elements))[(index)]));
}
CallStackInfo_s *popPS2247rPS6579(CallStack_s *this) {
    CallStackInfo_s *l = ((lastPS2247rPS6579)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
CallStackInfo_s *lastPS2247rPS6579(CallStack_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty CallStack")));
    return ((atPS2247uszrPS6579)((this), (((this)->length) - ((usize)(1llu)))));
}
none dumpRegisterStackPS3154uszrN(IRInterp_s *this, usize bytes) {
    usize cols = ((usize)(4llu));
    for (usize i = ((usize)(0llu)); ((i) < (bytes)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((i) > ((usize)(0llu))) && (((i) % (((usize)(8llu)) * (cols))) == ((usize)(0llu))))
            (((printf))(("\n")));
        (((printf))(("%2hhX"), (*((u8 *)((unsigned char *)((this)->regStackStart) + (i))))));
    }

    (((printf))(("\n")));
}
u8 *getGlobalPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg) { return ((u8 *)((unsigned char *)((u8 *)((unsigned char *)((this)->globalRegBase) - ((reg)->offset))) - ((reg)->size))); }
u8 *getRegStackPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg) {
    u8 *ptr = ((u8 *)((unsigned char *)((u8 *)((unsigned char *)((this)->regStackBase) - ((reg)->offset))) - ((reg)->size)));
    ((assertBPcrN)(((ptr) < ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))), ("Stack Overflow in IRInterp.getRegStackPointer")));
    ((assertBPcrN)(((ptr) >= ((this)->regStackStart)), ("Stack Underflow in IRInterp.getRegStackPointer")));
    return (ptr);
}
u8 *advanceRealStackPS3154S8951uszrPu8(IRInterp_s *this, Span_s span, usize size) {
    u8 *_p = ((this)->realStackPointer);
    u8 *new = ((u8 *)((unsigned char *)((this)->realStackPointer) + (size)));
    if ((new) >= ((u8 *)((unsigned char *)((this)->realStackStart) + (STACK_SIZE)))) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last allocation tried to allocate %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->realStackPointer) = (new));
    return (_p);
}
none pushArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size) {
    usize new = (((this)->argStackLength) + (size));
    if ((new) >= ((this)->argStackCapacity)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Argument Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last function call tried to push %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((memcpy))(((u8 *)((unsigned char *)((this)->argStack) + ((this)->argStackLength))), (start), (size)));
    (((this)->argStackLength) = (new));
}
none popArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size) {
    usize new = (((this)->argStackLength) - (size));
    if (((this)->argStackLength) < (size)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Argument Stack Underflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last function call tried to pop %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->argStackLength) = (new));
    (((memcpy))((start), ((u8 *)((unsigned char *)((this)->argStack) + ((this)->argStackLength))), (size)));
}
InterpReg_s evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((dumpInstructionsPS7132rN)((irFunc)));
    String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
    (((printf))(("%s: "), ((loc).buffer)));
    ((dumpPS7680rN)((instr)));
    ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
    ((unreachablePcrN)(("Not implemented")));
}
InterpReg_s evaluateAllocaPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("Alloca got non-pointer")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    ((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))))))) = ((usize)(((advanceRealStackPS3154S8951uszrPu8)((this), ((instr)->span), (((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateGetParamPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    usize size = (((instr)->op1).i);
    ((assertBPcrN)(((size) <= ((usize)(8llu))), ("Interp: Expected small size for GetParam")));
    InterpReg_s dst = ((InterpReg_s){.offset = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->offset), .size = (size)});
    ((popArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), (size)));
    return (dst);
}
InterpReg_s evaluateStorePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    ((assertBPcrN)(((isPointerPU5175rB)(((dst)->typ))), ("Store expected Ptr Dst")));
    usize size = ((getSizeInBytesPU5175rusz)(((dst)->typ)));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = (size)});
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Store src")));
    u8 *srcLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg))));
    u8 *dstLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg)))))))));
    (((memcpy))((dstLoc), (srcLoc), ((srcReg).size)));
    return (dstReg);
}
InterpReg_s evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10229 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchGlobalPtr")));

    u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10229)));
    Type_u *t = ((fReg)->typ);
    usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
    (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), (ptr), (size)));
    return (reg);
}
InterpReg_s evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10277 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchGlobalValue")));

    u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10277)));
    usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
    (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), ((Any)((*((usize *)((ptr)))))), (size)));
    return (reg);
}
InterpReg_s evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    if ((((instr)->op1).i) == ((usize)(1llu))) {
        IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        InterpReg_s tmp_10332 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchComptimeValue")));

        u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10332)));
        usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
        InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
        (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), (ptr), (size)));
        return (reg);
    }

    else {
        return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp FetchComptimeValue")));
    }
}
InterpReg_s evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFunctionPU5175rB)(((fReg)->typ))), ("LoadFunctionPtr got non-function")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Load src")));
    ((assertBPcrN)((((srcReg).size) == ((usize)(8llu))), ("Load expected Ptr Src")));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = ((getSizeInBytesPU5175rusz)(((dst)->typ)))});
    u8 *srcLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg)))))))));
    u8 *dstLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    (((memcpy))((dstLoc), (srcLoc), ((dstReg).size)));
    return (dstReg);
}
InterpReg_s evaluateMovePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Interp Move src")));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = ((getSizeInBytesPU5175rusz)(((dst)->typ)))});
    u8 *srcLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg))));
    u8 *dstLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    (((memcpy))((dstLoc), (srcLoc), ((dstReg).size)));
    return (dstReg);
}
InterpReg_s evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10525 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Call")));

    usize id = (*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&tmp_10525))))));
    IRFunc_s *calledFunc = ((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (id)));
    ParsedFuncDecl_s *f = ((atPS4111uszrPS4904)((&(funcDecls)), ((calledFunc)->originalID)));
    if ((isExternPS4904rB)((f))) {
        if (!((isNullPS3633rB)(((f)->dllHandle)))) {
            if (*((flags).disableExternalComptime)) {
                String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
                (((fprintf))((stderr_), ("%s: %s: Cannot call external function `%s` at compile time.\n"), ((loc).buffer), (ERR_STR), (((calledFunc)->name).buffer)));
                (((fprintf))((stderr_), ("%s: %s: Flag `--no-extern-comptime` was provided.\n"), ((loc).buffer), (NOTE_STR)));
                ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
                (((C_exiti32rN))(((i32)(1))));
            }

            Function_s fun = ((compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803)((this), (irFunc), (calledFunc), (instr), ((((f)->dllHandle)->handle).ptr), (regs)));
            Type_u *retType = (NULL);
            bool succ_1316_ = true;

            Type_u *tmp_2279_ = ((getTypePU9661rPU5175)((&((f)->typeState))));
            {
                succ_1316_ &= (tmp_2279_->tag == 6);
                succ_1316_ &= true;
                Type_u **_ret = &tmp_2279_->payload.variant6._1;
                succ_1316_ &= true;
                succ_1316_ &= true;
                if (succ_1316_) {
                    {
                        ((retType) = (*_ret));
                    }
                    goto after_2279;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("IRGen.evaluateInstrCall: Expected function type")));
                    }
                    goto after_2279;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_2279:
            (void)0; // error: label at end of compound statement is a C23 extension
            u64 val = (((fun).run)());
            usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
            InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
            if (((getSizeInBytesPU5175rusz)((retType))) == ((usize)(0llu))) {
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(1llu))) {
                ((*((u8 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u8 *)((&(val))))));
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(2llu))) {
                ((*((u16 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u16 *)((&(val))))));
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(4llu))) {
                if ((isFloatPU5175rB)((retType))) {
                    ((*((f32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((f32 *)((&(val))))));
                }

                else {
                    ((*((u32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u32 *)((&(val))))));
                }

            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(8llu))) {
                if ((isFloatPU5175rB)((retType))) {
                    ((*((f64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((f64 *)((&(val))))));
                }

                else {
                    ((*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u64 *)((&(val))))));
                }

            }

            else {
            }

            ((freeS1803rN)((fun)));
            return (dst);
        }

        else {
            String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
            (((fprintf))((stderr_), ("%s: %s: Can not call external function `%s` at compile time.\n"), ((loc).buffer), (ERR_STR), (((calledFunc)->name).buffer)));
            if (((f)->dllHandle) == ((dllNotFoundrPS3633)())) {
                ParsedModule_s *m = ((getParentModulePS4904rPS1882)((f)));
                String_s _loc = ((toStringPS8951rS0540)((&((m)->span))));
                UsizeList_s cfg = ((getConfigsPS1882rS4113)((m)));
                if (((cfg).length) == ((usize)(0llu))) {
                    (((fprintf))((stderr_), ("%s: %s: No configuration found!\n"), ((_loc).buffer), (NOTE_STR)));
                }

                else {
                    (((fprintf))((stderr_), ("%s: %s: Could not load any of the libraries specified in the module configuration.\n"), ((loc).buffer), (NOTE_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    for (usize i = ((usize)(0llu)); ((i) < ((cfg).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(cfg)), (i))))));
                        ((assertBrN)((((tli)->kind) == (TLI_CONFIG))));
                        ((dropPS0540rN)((&(_loc))));
                        ((_loc) = ((toStringPS8951rS0540)((&((tli)->span)))));
                        (((fprintf))((stderr_), ("%s: %s: Module configuration declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    }
                }

                ((dropPS0540rN)((&(_loc))));
            }

            else if (((f)->dllHandle) == ((dllNoSuchFunctionrPS3633)())) {
                ParsedModule_s *m = ((getParentModulePS4904rPS1882)((f)));
                String_s _loc = ((toStringPS8951rS0540)((&((m)->span))));
                UsizeList_s cfg = ((getConfigsPS1882rS4113)((m)));
                if (((cfg).length) == ((usize)(0llu))) {
                    (((fprintf))((stderr_), ("%s: %s: No configuration found!\n"), ((_loc).buffer), (NOTE_STR)));
                }

                else {
                    String_s _fnLoc = ((toStringPS8951rS0540)((&((f)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Could not find the function in any of the specified libraries.\n"), ((loc).buffer), (ERR_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Function declared here.\n"), ((_fnLoc).buffer), (NOTE_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    for (usize i = ((usize)(0llu)); ((i) < ((cfg).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(cfg)), (i))))));
                        ((assertBrN)((((tli)->kind) == (TLI_CONFIG))));
                        ((dropPS0540rN)((&(_loc))));
                        ((_loc) = ((toStringPS8951rS0540)((&((tli)->span)))));
                        (((fprintf))((stderr_), ("%s: %s: Module configuration declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    }

                    ((dropPS0540rN)((&(_fnLoc))));
                }

                ((dropPS0540rN)((&(_loc))));
            }

            else if (((f)->dllHandle) == (NULL)) {
            }

            else {
                ((unreachablePcrN)(("actually null-ptr")));
            }

            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

    }

    else {
        usize argSize = ((this)->argStackLength);
        u8 *stackStart = ((this)->realStackStart);
        u8 *regStackStart = ((this)->regStackStart);
        for (usize _i = ((usize)(0llu)); ((_i) < (((instr)->args).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
            usize i = (((((instr)->args).length) - (_i)) - ((usize)(1llu)));
            RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((atPS9911uszrPS6939)((&((instr)->args)), (i)))->i)));
            InterpReg_s arg = ((asInterpPU5952PcrS9925)((reg), ("call arg")));
            ((pushArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))), ((arg).size)));
        }

        RegValueList_s callRegs = ((RegValueList_s){0});
        ((initBlankPS5884uszrN)((&(callRegs)), (((calledFunc)->registers).length)));
        ((evaluateCallPS3154S8951PS7132PS5884rN)((this), ((instr)->span), (calledFunc), (&(callRegs))));
        usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
        InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
        ((popArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), (size)));
        ((assertBPcrN)(((argSize) == ((this)->argStackLength)), ("Imbalanced argument stack after calling IRInterp.evaluateCall")));
        ((assertBPcrN)(((stackStart) == ((this)->realStackStart)), ("Imbalanced real stack after calling IRInterp.evaluateCall")));
        ((assertBPcrN)(((regStackStart) == ((this)->regStackStart)), ("Imbalanced reg stack after calling IRInterp.evaluateCall")));
        return (dst);
    }
}
InterpReg_s evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *expr = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rExpr = ((asInterpPU5952PcrS9925)((expr), ("ReturnExpr")));
    ((pushArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rExpr)))), ((rExpr).size)));
    return ((InterpReg_s){0});
}
InterpReg_s evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) { return ((InterpReg_s){0}); }
InterpReg_s evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("LoadString expected Ptr")));
    ((assertBPcrN)(((isCharPU5175rB)(((getUnderlyingTypePU5175BrPU5175)(((fReg)->typ), (false))))), ("LoadString expected Ptr to Char")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    u8 isTrue = ((u8)((((instr)->src).i)));
    ((assertBPcrN)((((isTrue) == ((u8)(0))) || ((isTrue) == ((u8)(1)))), ("LoadBool expected 0 or 1")));
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u8 *)((regStackLoc)))) = (isTrue));
    return (reg);
}
InterpReg_s evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI8 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i8 *)((regStackLoc)))) = ((i8)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)((((isIntegerPU5175rB)(((fReg)->typ))) || ((isCharPU5175rB)(((fReg)->typ)))), ("LoadU8 got non-int non-char")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u8 *)((regStackLoc)))) = ((u8)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI16 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(2llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i16 *)((regStackLoc)))) = ((i16)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU16 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(2llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u16 *)((regStackLoc)))) = ((u16)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI32 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i32 *)((regStackLoc)))) = ((i32)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU32 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u32 *)((regStackLoc)))) = ((u32)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU64 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("LoadNull got non-ptr")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = ((usize)(0llu)));
    return (reg);
}
InterpReg_s evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFloatPU5175rB)(((fReg)->typ))), ("LoadF32 got non-float")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((f32 *)((regStackLoc)))) = (*((f32 *)((&(((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFloatPU5175rB)(((fReg)->typ))), ("LoadF64 got non-float")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((f64 *)((regStackLoc)))) = (*((f64 *)((&(((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCondBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *cond = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rCond = ((asInterpPU5952PcrS9925)((cond), ("CondBr")));
    ((assertBPcrN)((((rCond).size) == ((usize)(1llu))), ("comptime CondBr expected single byte Cond")));
    u8 *condLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rCond))));
    u8 v = (*(condLoc));
    ((assertBPcrN)((((v) == ((u8)(0))) || ((v) == ((u8)(1)))), ("condition is not 0 or 1")));
    usize id = ((usize)(0llu));
    if ((v) == ((u8)(1))) {
        ((id) = (((instr)->dst).i));
    }

    else {
        ((id) = (((instr)->op1).i));
    }

    return ((InterpReg_s){.offset = (id), .size = ((usize)(1llu))});
}
InterpReg_s evaluateBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((InterpReg_s){.offset = (((instr)->dst).i), .size = ((usize)(1llu))});
}
InterpReg_s evaluateIntAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("AddInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("AddInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("AddInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) + (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) + (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) + (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) + (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) + (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) + (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) + (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) + (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("SubInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("SubInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("SubInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) - (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) - (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) - (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) - (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) - (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) - (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) - (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) - (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("MulInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("MulInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("MulInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) * (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) * (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) * (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) * (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) * (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) * (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) * (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) * (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int mul with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ModInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ModInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("ModInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) % (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) % (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) % (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) % (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) % (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) % (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) % (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) % (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int mod with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpNeq/ICmpEq LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpNeq/ICmpEq RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpNeq/ICmpEq got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((((isIntegerPU5175rB)((t1))) || ((isPointerPU5175rB)((t1)))) || ((isCharPU5175rB)((t1)))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((eq) = ((*((i8 *)((lhsStart)))) == (*((i8 *)((rhsStart))))));
            else
                ((eq) = ((*((u8 *)((lhsStart)))) == (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((eq) = ((*((i16 *)((lhsStart)))) == (*((i16 *)((rhsStart))))));
            else
                ((eq) = ((*((u16 *)((lhsStart)))) == (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((eq) = ((*((i32 *)((lhsStart)))) == (*((i32 *)((rhsStart))))));
            else
                ((eq) = ((*((u32 *)((lhsStart)))) == (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((eq) = ((*((i64 *)((lhsStart)))) == (*((i64 *)((rhsStart))))));
            else
                ((eq) = ((*((u64 *)((lhsStart)))) == (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpEq/ICmpNeq on non-int")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_NEQ))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpGt/ICmpLte LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpGt/ICmpLte RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpGt/ICmpLte got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool gt = (false);
    if ((isIntegerPU5175rB)((t1))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((gt) = ((*((i8 *)((lhsStart)))) > (*((i8 *)((rhsStart))))));
            else
                ((gt) = ((*((u8 *)((lhsStart)))) > (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((gt) = ((*((i16 *)((lhsStart)))) > (*((i16 *)((rhsStart))))));
            else
                ((gt) = ((*((u16 *)((lhsStart)))) > (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((gt) = ((*((i32 *)((lhsStart)))) > (*((i32 *)((rhsStart))))));
            else
                ((gt) = ((*((u32 *)((lhsStart)))) > (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((gt) = ((*((i64 *)((lhsStart)))) > (*((i64 *)((rhsStart))))));
            else
                ((gt) = ((*((u64 *)((lhsStart)))) > (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmpgt with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpGt/ICmpLte on non-int")));
    }

    u8 r = ((u8)(0));
    if (gt)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_LTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpLt/ICmpGte LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpLt/ICmpGte RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpLt/ICmpGte got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool gt = (false);
    if ((isIntegerPU5175rB)((t1))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((gt) = ((*((i8 *)((lhsStart)))) < (*((i8 *)((rhsStart))))));
            else
                ((gt) = ((*((u8 *)((lhsStart)))) < (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((gt) = ((*((i16 *)((lhsStart)))) < (*((i16 *)((rhsStart))))));
            else
                ((gt) = ((*((u16 *)((lhsStart)))) < (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((gt) = ((*((i32 *)((lhsStart)))) < (*((i32 *)((rhsStart))))));
            else
                ((gt) = ((*((u32 *)((lhsStart)))) < (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((gt) = ((*((i64 *)((lhsStart)))) < (*((i64 *)((rhsStart))))));
            else
                ((gt) = ((*((u64 *)((lhsStart)))) < (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmpgt with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpGt/ICmpLte on non-int")));
    }

    u8 r = ((u8)(0));
    if (gt)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_GTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatAdd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatAdd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatAdd expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) + (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) + (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatSub LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatSub RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatSub expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) - (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) - (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float sub with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatMul LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatMul RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatMul expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) * (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) * (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float mul with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatDiv LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatDiv RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatDiv expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) / (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) / (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float div with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatMod LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatMod RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatMod expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = (fmodf((*((f32 *)((lhsStart)))), (*((f32 *)((rhsStart)))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = (fmod((*((f64 *)((lhsStart)))), (*((f64 *)((rhsStart)))))));
    }

    else {
        ((unreachablePcrN)(("float mod with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpNeq/FCmpEq LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpNeq/FCmpEq RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpNeq/FCmpEq got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) == (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) == (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpEq/FCmpNeq on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_NEQ))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpLte/FCmpGt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpLte/FCmpGt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpLte/FCmpGt got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) > (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) > (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpGt/FCmpLte on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_LTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpGte/FCmpLt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpGte/FCmpLt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpGte/FCmpLt got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) < (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) < (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpLt/FCmpGte on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_GTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("LNot SRC")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 val = (*(srcStart));
    ((assertBPcrN)((((val) == ((u8)(0))) || ((val) == ((u8)(1)))), ("Logical Not got non-zero non-one")));
    ((*(dstStart)) = (((u8)(1)) - (val)));
    return (dst);
}
InterpReg_s evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("LAnd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("LAnd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("LAnd got differently sized operands")));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 l = (*(lhsStart));
    u8 r = (*(rhsStart));
    ((*(dstStart)) = ((u8)(0)));
    if (((l) == ((u8)(1))) && ((r) == ((u8)(1)))) {
        ((*(dstStart)) = ((u8)(1)));
    }

    return (dst);
}
InterpReg_s evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("LOr LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("LOr RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("LOr got differently sized operands")));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 l = (*(lhsStart));
    u8 r = (*(rhsStart));
    ((*(dstStart)) = ((u8)(0)));
    if (((l) == ((u8)(1))) || ((r) == ((u8)(1)))) {
        ((*(dstStart)) = ((u8)(1)));
    }

    return (dst);
}
InterpReg_s evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BAnd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BAnd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BAnd got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) & (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) & (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) & (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) & (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BAnd")));
    return (dst);
}
InterpReg_s evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BOr LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BOr RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BOr got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) | (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) | (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) | (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) | (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BOr")));
    return (dst);
}
InterpReg_s evaluateBitwiseXorPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BXor LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BXor RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BXor got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) ^ (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) ^ (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) ^ (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) ^ (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BXOr")));
    return (dst);
}
InterpReg_s evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    Type_u *t = ((dstReg)->typ);
    bool succ_2023_ = true;
    bool succ_2031_ = true;

    Type_u *tmp_3148_ = (t);
    {
        succ_2023_ &= (tmp_3148_->tag == 5);
        Type_u **under = &tmp_3148_->payload.variant5._0;
        succ_2023_ &= true;
        usize *_size = &tmp_3148_->payload.variant5._1;
        succ_2023_ &= true;
        if (succ_2023_) {
            {
                InterpReg_s valReg = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("Interp InsertValue Array")));
                usize size = ((getSizeInBytesPU5175rusz)((*under)));
                usize offset = ((((instr)->src).i) * (size));
                (((memcpy))(((u8 *)((unsigned char *)(dstStart) + (offset))), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(valReg)))), (size)));
            }
            goto after_3148;
        }
    }
    {
        succ_2031_ &= (tmp_3148_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_3148_->payload.variant7._0;
        succ_2031_ &= true;
        if (succ_2031_) {
            {
                usize offset = ((usize)(0llu));
                usize fieldSize = ((usize)(0llu));
                ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (((instr)->src).i), (&(offset)), (&(fieldSize)), (false)));
                InterpReg_s valReg = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("Interp InsertValue Struct")));
                ((assertBPcrN)((((valReg).size) == (fieldSize)), ("field size mismatch in Interp InsertValue")));
                (((memcpy))(((u8 *)((unsigned char *)(dstStart) + (offset))), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(valReg)))), (fieldSize)));
            }
            goto after_3148;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Interp InsertValue expected Array or Struct")));
            }
            goto after_3148;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_3148:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
InterpReg_s evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("SExt src")));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    ((assertBPcrN)(((isSignedIntegerPU5175rB)((t))), ("SExt expected Signed Integer")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((rSrc).size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    ((todo_with_msgPcrN)(("sext")));
}
InterpReg_s evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("ZExt src")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s2) > (s1)), ("Zero Extend expected dst to be greater than src")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s2)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    (((memset))((dstStart), ((i32)(0)), (s2)));
    if ((s1) == ((usize)(1llu)))
        ((*(dstStart)) = (*(srcStart)));
    else if ((s1) == ((usize)(2llu)))
        ((*((u16 *)((dstStart)))) = (*((u16 *)((srcStart)))));
    else if ((s1) == ((usize)(4llu)))
        ((*((u32 *)((dstStart)))) = (*((u32 *)((srcStart)))));
    else
        ((unreachablePcrN)(("ZExt 8 byte to what?")));
    return (dst);
}
InterpReg_s evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("Trunc src")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) > (s2)), ("Int Truncate expected src to be greater than dst")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s2)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    (((memset))((dstStart), ((i32)(0)), (s2)));
    if ((s1) == ((usize)(8llu)))
        ((*((u64 *)((dstStart)))) = (*((u64 *)((srcStart)))));
    else if ((s1) == ((usize)(4llu)))
        ((*((u32 *)((dstStart)))) = (*((u32 *)((srcStart)))));
    else if ((s1) == ((usize)(2llu)))
        ((*((u16 *)((dstStart)))) = (*((u16 *)((srcStart)))));
    else
        ((unreachablePcrN)(("Truncate 1 byte to what?")));
    return (dst);
}
InterpReg_s evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F32ToF64")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(8llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f32 v = (*((f32 *)((srcStart))));
    ((*((f64 *)((dstStart)))) = ((f64)((v))));
    return (dst);
}
InterpReg_s evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F64ToF32")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(4llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f64 v = (*((f64 *)((srcStart))));
    ((*((f32 *)((dstStart)))) = ((f32)((v))));
    return (dst);
}
InterpReg_s evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp IntToF32")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(4llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t)));
    usize s = ((getSizeInBytesPU5175rusz)((t)));
    f32 v = ((f32)(0));
    if ((s) == ((usize)(1llu))) {
        if (signed_)
            ((v) = ((f32)((*((i8 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u8 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(2llu))) {
        if (signed_)
            ((v) = ((f32)((*((i16 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u16 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(4llu))) {
        if (signed_)
            ((v) = ((f32)((*((i32 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u32 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(8llu))) {
        if (signed_)
            ((v) = ((f32)((*((i64 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u64 *)((srcStart)))))));
    }

    else {
        ((unreachablePcrN)(("Interp unexpected size in IntToF32")));
    }

    ((*((f32 *)((dstStart)))) = (v));
    return (dst);
}
InterpReg_s evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F32ToInt")));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    bool signed_ = ((isSignedIntegerPU5175rB)(((dstReg)->typ)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f32 v = (*((f32 *)((srcStart))));
    if ((size) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((dstStart)))) = ((i8)((v))));
        else
            ((*((u8 *)((dstStart)))) = ((u8)((v))));
    }

    else if ((size) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((dstStart)))) = ((i16)((v))));
        else
            ((*((u16 *)((dstStart)))) = ((u16)((v))));
    }

    else if ((size) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((dstStart)))) = ((i32)((v))));
        else
            ((*((u32 *)((dstStart)))) = ((u32)((v))));
    }

    else if ((size) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((dstStart)))) = ((i64)((v))));
        else
            ((*((u64 *)((dstStart)))) = ((u64)((v))));
    }

    else {
        ((unreachablePcrN)(("Interp F32ToInt: Exhaustive handling of destinations")));
    }

    return (dst);
}
InterpReg_s evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F64ToInt")));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    bool signed_ = ((isSignedIntegerPU5175rB)(((dstReg)->typ)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f64 v = (*((f64 *)((srcStart))));
    if ((size) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((dstStart)))) = ((i8)((v))));
        else
            ((*((u8 *)((dstStart)))) = ((u8)((v))));
    }

    else if ((size) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((dstStart)))) = ((i16)((v))));
        else
            ((*((u16 *)((dstStart)))) = ((u16)((v))));
    }

    else if ((size) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((dstStart)))) = ((i32)((v))));
        else
            ((*((u32 *)((dstStart)))) = ((u32)((v))));
    }

    else if ((size) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((dstStart)))) = ((i64)((v))));
        else
            ((*((u64 *)((dstStart)))) = ((u64)((v))));
    }

    else {
        ((unreachablePcrN)(("Interp F64ToInt: Exhaustive handling of destinations")));
    }

    return (dst);
}
InterpReg_s evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp PtrToInt")));
}
InterpReg_s evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp IntToPtr")));
}
InterpReg_s evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s fAggr = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("IRInterp: GetFieldPtr")));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    ((assertBPcrN)(((isStructPointerPU5175rB)((t))), ("IRInterp: GetFieldPtr got non-struct pointer")));
    Type_u *u = ((getUnderlyingTypePU5175BrPU5175)((t), (false)));
    ParsedStructDecl_s *decl = (NULL);
    bool succ_2184_ = true;

    Type_u *tmp_3334_ = (u);
    {
        succ_2184_ &= (tmp_3334_->tag == 7);
        ParsedStructDecl_s **_decl = &tmp_3334_->payload.variant7._0;
        succ_2184_ &= true;
        if (succ_2184_) {
            {
                ((decl) = (*_decl));
            }
            goto after_3334;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected Struct in evaluateGetFieldPtr")));
            }
            goto after_3334;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_3334:
    (void)0; // error: label at end of compound statement is a C23 extension
    usize offset = ((usize)(0llu));
    usize size = ((usize)(0llu));
    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((decl), (((instr)->op1).i), (&(offset)), (&(size)), (false)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    u8 *ptr = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(fAggr))));
    ((*((usize *)((regStackLoc)))) = ((*((usize *)((ptr)))) + (offset)));
    return (reg);
}
InterpReg_s evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *elemReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s aggr = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("IRInterp: GetElementPtr")));
    u8 *ptr = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(aggr))));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((elemReg)->offset), .size = ((usize)(8llu))});
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        RegIndex_s *arg = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), ((arg)->i)));
        InterpReg_s tmp_15684 = ((asInterpPU5952PcrS9925)((reg), ("IRInterp: GetElementPtr index")));

        usize elems = (*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&tmp_15684))))));
        bool succ_2216_ = true;
        bool succ_2221_ = true;
        bool succ_2228_ = true;
        bool succ_2225_ = true;

        Type_u *tmp_3365_ = (t);
        {
            succ_2216_ &= (tmp_3365_->tag == 4);
            Type_u **underlying = &tmp_3365_->payload.variant4._0;
            succ_2216_ &= true;
            if (succ_2216_) {
                {
                    ((offset) = ((offset) + ((elems) * ((getSizeInBytesPU5175rusz)((*underlying))))));
                    ((t) = (*underlying));
                }
                goto after_3365;
            }
        }
        {
            succ_2221_ &= (tmp_3365_->tag == 5);
            Type_u **underlying = &tmp_3365_->payload.variant5._0;
            succ_2221_ &= true;
            succ_2221_ &= true;
            if (succ_2221_) {
                {
                    ((offset) = ((offset) + ((elems) * ((getSizeInBytesPU5175rusz)((*underlying))))));
                    ((t) = (*underlying));
                }
                goto after_3365;
            }
        }
        {
            succ_2228_ &= (tmp_3365_->tag == 4);
            succ_2225_ &= (tmp_3365_->payload.variant4._0->tag == 7);
            ParsedStructDecl_s **decl = &tmp_3365_->payload.variant4._0->payload.variant7._0;
            succ_2225_ &= true;
            succ_2228_ &= succ_2225_;
            if (succ_2228_) {
                {
                    ((todo_with_msgPcrN)(("IRInterp: evaluateGetElementPtr on Struct")));
                }
                goto after_3365;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s IRInterp: evaluateGetElementPtr source has unexpected type!\n"), (FATAL_STR)));
                    (((fprintf))((stderr_), ("%s IRInterp: The type: %s\n"), (FATAL_STR), (((toStringPU5175rS0540)((t))).buffer)));
                    (((C_exiti32rN))(((i32)(2))));
                }
                goto after_3365;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_3365:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    ((*((usize *)((regStackLoc)))) = ((*((usize *)((ptr)))) + (offset)));
    return (dstReg);
}
InterpReg_s evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((unreachablePcrN)(("IRInterp: Hit INSTR_UNREACHABLE")));
}
InterpReg_s evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((unreachablePcrN)(("IRInterp: Hit INSTR_UNTERMINATED")));
}
InterpReg_s evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *dst = ((atPS5884uszrPU5952)((regs), (((instr)->dst).i)));
    RegValue_u *size = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("Memcpy src")));
    InterpReg_s rDst = ((asInterpPU5952PcrS9925)((dst), ("Memcpy dst")));
    InterpReg_s rSize = ((asInterpPU5952PcrS9925)((size), ("Memcpy size")));
    u8 *srcLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc)))))))));
    u8 *dstLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(rDst)))))))));
    u8 *sizeStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSize))));
    usize sizeValue = (*((usize *)((sizeStart))));
    (((memcpy))((dstLoc), (srcLoc), (sizeValue)));
    return (rDst);
}
InterpReg_s evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Inline Assembly can\'t be used in a comptime context.\n"), ((loc).buffer), (ERR_STR)));
    ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
    ((dropPS0540rN)((&(loc))));
    (((C_exiti32rN))(((i32)(1))));
}
InterpReg_s evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    ((assertBPcrN)(((size) == (sizeof(RegValue_u))), ("IntoIRValue: size mismatch with llvm")));
    ((assertBPcrN)(((size) == (sizeof(IRValue_u))), ("IntoIRValue: size mismatch with asm")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    ((*((RegValue_u *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*(src)));
    return (dst);
}
InterpReg_s evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    return ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
}
InterpReg_s evaluateSinglePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    if (!(forcedComptime)) {
        ((assertBPcrN)(((instr)->isComptime), ("Expected comptime instr in IRInterp.evaluateSingle")));
    }

    ((assertBPcrN)((((this)->regStackBase) < ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))), ("Stack Cursor Overflow in IRInterp.evaluateSingle")));
    if ((*((flags).debug)) && (*((flags).verbose)))
        ((dumpPS7680rN)((instr)));
    return ((((instrFns).arr)[((instr)->kind)])((this), (irFunc), (instr), (regs), (forcedComptime)));
}
bool evaluateBlockPS3154PS7192PS7132PS5884BrB(IRInterp_s *this, IRBlockID_s *blockID, IRFunc_s *irFunc, RegValueList_s *regs, bool forcedComptime) {
    IRBlock_s *block = ((getBlockByIDPS7132S7192rPS9435)((irFunc), (*(blockID))));
    ((assertBPcrN)(((((block)->instructions).length) > ((usize)(0llu))), ("Interp: Encountered empty block")));
    for (usize ip = ((usize)(0llu)); ((ip) < (((block)->instructions).length)); ((ip) = ((ip) + ((usize)(1llu))))) {
        IRInstr_s *instr = ((atPS0124uszrPS7680)((&((block)->instructions)), (ip)));
        InterpReg_s result = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)((this), (irFunc), (instr), (regs), (forcedComptime)));
        if ((ip) == ((((block)->instructions).length) - ((usize)(1llu)))) {
            ((assertBPcrN)(((isTerminatorPS7680rB)((instr))), ("Interp: Unexpected non-terminator at the end of a block")));
            bool ret = (((result).size) == ((usize)(1llu)));
            if (ret) {
                ((*(blockID)) = ((IRBlockID_s){.i = ((result).offset)}));
            }

            return (ret);
        }

        else {
            ((assertBPcrN)((!((isTerminatorPS7680rB)((instr)))), ("Interp: Unexpected terminator in the middle of a block")));
            ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (result)));
        }
    }

    return (false);
}
Function_s compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803(IRInterp_s *this, IRFunc_s *currFunc, IRFunc_s *calledFunc, IRInstr_s *instr, usize fn, RegValueList_s *regs) {
    ParsedFuncDecl_s *f = ((atPS4111uszrPS4904)((&(funcDecls)), ((calledFunc)->originalID)));
    bool isVariadic = (false);
    Type_u *retType = (NULL);
    bool succ_2269_ = true;

    Type_u *tmp_3435_ = ((getTypePU9661rPU5175)((&((f)->typeState))));
    {
        succ_2269_ &= (tmp_3435_->tag == 6);
        succ_2269_ &= true;
        Type_u **_ret = &tmp_3435_->payload.variant6._1;
        succ_2269_ &= true;
        FuncAttr_s *attr = &tmp_3435_->payload.variant6._2;
        succ_2269_ &= true;
        if (succ_2269_) {
            {
                ((isVariadic) = ((*attr).isVariadic));
                ((retType) = (*_ret));
            }
            goto after_3435;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("IRGen.evaluateInstrCall: Expected function type")));
            }
            goto after_3435;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_3435:
    (void)0; // error: label at end of compound statement is a C23 extension
    ByteBuffer_s buf = ((ByteBuffer_s){0});
    ((pushPS5123S7038rN)((&(buf)), (RBP)));
    ((movPS5123S7038S7038rN)((&(buf)), (RBP), (RSP)));
    usize ARG_LEN = ((usize)(4llu));
    u32 stack_offset = ((u32)(32));
    array_30032 GPR_ARGS = ((array_30032){(RCX), (RDX), (R8), (R9)});
    array_30033 FPR_ARGS = ((array_30033){(XMM0), (XMM1), (XMM2), (XMM3)});
    for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        RegIndex_s *index = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), ((index)->i)));
        InterpReg_s arg = ((asInterpPU5952PcrS9925)((reg), ("call arg")));
        IRReg_s *origReg = ((getRegisterPS7132S6939rPS1534)((currFunc), (*(index))));
        Type_u *argType = ((origReg)->typ);
        if (isVariadic) {
            if ((i) >= (ARG_LEN)) {
                if (((getSizeInBytesPU5175rusz)((argType))) <= ((usize)(8llu))) {
                    u64 v = (*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                    ((movPS5123S7038u32S8731rN)((&(buf)), (RSP), (stack_offset), ((ImmI64_s){.b = (v)})));
                }

                else {
                    ((todo_with_msgPcrN)((">8byte stack")));
                }

                ((stack_offset) = ((stack_offset) + ((u32)(8))));
            }

            else {
                if ((isFloatPU5175rB)((argType))) {
                    if (((getSizeInBytesPU5175rusz)((argType))) == ((usize)(4llu))) {
                        u32 v1 = (*((u32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                        f32 v2 = (*((f32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                        ((movPS5123S7038S8630rN)((&(buf)), (((GPR_ARGS).arr)[(i)]), ((ImmI32_s){.b = (v1)})));
                        ((movPS5123S5949S5363rN)((&(buf)), (((FPR_ARGS).arr)[(i)]), ((ImmF32_s){.b = (v2)})));
                    }

                    else {
                        u64 v1 = (*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                        f64 v2 = (*((f64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                        ((movPS5123S7038S8731rN)((&(buf)), (((GPR_ARGS).arr)[(i)]), ((ImmI64_s){.b = (v1)})));
                        ((movPS5123S5949S5464rN)((&(buf)), (((FPR_ARGS).arr)[(i)]), ((ImmF64_s){.b = (v2)})));
                    }

                }

                else if (((getSizeInBytesPU5175rusz)((argType))) <= ((usize)(8llu))) {
                    u64 v = (*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                    ((movPS5123S7038S8731rN)((&(buf)), (((GPR_ARGS).arr)[(i)]), ((ImmI64_s){.b = (v)})));
                }

                else {
                    ((todo_with_msgPcrN)(("non-int non-float >8 byte reg")));
                }
            }

        }

        else if ((i) >= (ARG_LEN)) {
            if (((getSizeInBytesPU5175rusz)((argType))) <= ((usize)(8llu))) {
                u64 v = (*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                ((movPS5123S7038u32S8731rN)((&(buf)), (RSP), (stack_offset), ((ImmI64_s){.b = (v)})));
            }

            else {
                ((todo_with_msgPcrN)((">8byte stack")));
            }

            ((stack_offset) = ((stack_offset) + ((u32)(((getSizeInBytesPU5175rusz)((argType)))))));
        }

        else {
            if ((isFloatPU5175rB)((argType))) {
                if (((getSizeInBytesPU5175rusz)((argType))) == ((usize)(4llu))) {
                    f32 v = (*((f32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                    ((movPS5123S5949S5363rN)((&(buf)), (((FPR_ARGS).arr)[(i)]), ((ImmF32_s){.b = (v)})));
                }

                else {
                    f64 v = (*((f64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                    ((movPS5123S5949S5464rN)((&(buf)), (((FPR_ARGS).arr)[(i)]), ((ImmF64_s){.b = (v)})));
                }

            }

            else if (((getSizeInBytesPU5175rusz)((argType))) <= ((usize)(8llu))) {
                u64 v = (*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))))));
                ((movPS5123S7038S8731rN)((&(buf)), (((GPR_ARGS).arr)[(i)]), ((ImmI64_s){.b = (v)})));
            }

            else {
                ((todo_with_msgPcrN)(("non-int non-float >8 byte reg")));
            }
        }
    }

    if ((((instr)->args).length) < ((usize)(4llu)))
        ((subPS5123S7038S8630rN)((&(buf)), (RSP), ((ImmI32_s){.b = ((u32)(32))})));
    ((movPS5123S7038S8731rN)((&(buf)), (RAX), ((ImmI64_s){.b = ((u64)((fn)))})));
    ((callPS5123S7038rN)((&(buf)), (RAX)));
    if ((((instr)->args).length) < ((usize)(4llu)))
        ((addPS5123S7038S8630rN)((&(buf)), (RSP), ((ImmI32_s){.b = ((u32)(32))})));
    ((popPS5123S7038rN)((&(buf)), (RBP)));
    if ((isFloatPU5175rB)((retType))) {
        ((pushPS5123ccccrN)((&(buf)), ('f'), ('H'), ('\xF'), ('~')));
        ((modRMPS5123u8u8S7038rN)((&(buf)), (ADDR_REG), ((XMM0).r), (RAX)));
    }

    else if ((isNonePU5175rB)((retType))) {
        ((movPS5123S7038S8630rN)((&(buf)), (RAX), ((ImmI32_s){.b = ((u32)(420691337))})));
    }

    else if (((((isIntegerPU5175rB)((retType))) || ((isBooleanPU5175rB)((retType)))) || ((isStructPU5175rB)((retType)))) || ((isPointerPU5175rB)((retType)))) {
    }

    else {
        (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((retType))).buffer)));
        ((todo_with_msgPcrN)(("non-float ret")));
    }

    ((pushPS5123crN)((&(buf)), ('\xC3')));
    Any code = (((VirtualAlloc))((NULL), ((buf).length), ((u32)(4096)), ((u32)(64))));
    ((assertBPcrN)(((code) != (NULL)), ("Could not alloc some bytes sadge thx Windows")));
    (((memcpy))((code), ((buf).elements), ((buf).length)));
    (((free))(((buf).elements)));
    return ((Function_s){.run = ((u64 (*)(none))((code))), .size = ((buf).length)});
}
none evaluateCallPS3154S8951PS7132PS5884rN(IRInterp_s *this, Span_s span, IRFunc_s *irFunc, RegValueList_s *regs) {
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((irFunc)));
    ParsedFuncDecl_s *fn = ((atPS4111uszrPS4904)((&(funcDecls)), ((irFunc)->originalID)));
    ((pushCallStackPS3154S8951S0540rN)((this), (span), ((toStringPS7720rS0540)((&(((fn)->name).content))))));
    ((pushRegisterStackPS3154S8951uszrN)((this), (span), (funcSize)));
    IRBlockID_s blockID = ((IRBlockID_s){.i = ((usize)(0llu))});
    while ((evaluateBlockPS3154PS7192PS7132PS5884BrB)((this), (&(blockID)), (irFunc), (regs), (true))) {
    }

    ((popRegisterStackPS3154S8951uszrN)((this), (span), (funcSize)));
    ((popCallStackPS3154rN)((this)));
    return;
}
none pushRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size) {
    u8 *new = ((u8 *)((unsigned char *)((this)->regStackBase) + (size)));
    if ((new) > ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s Register Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: %s Tried to reserve %llu byte(s).\n"), ((loc).buffer), (FATAL_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->regStackBase) = (new));
}
none popRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size) {
    u8 *new = ((u8 *)((unsigned char *)((this)->regStackBase) - (size)));
    if ((new) < ((this)->regStackStart)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s Register Stack Underflow in the comptime interpreter.\n"), ((loc).buffer), (FATAL_STR)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->regStackBase) = (new));
    ((assertBPcrN)((((this)->regStackBase) >= ((this)->globalRegBase)), ("Register Stack overwrote global stack")));
}
none pushCallStackPS3154S8951S0540rN(IRInterp_s *this, Span_s span, String_s name) { ((pushPS2247S6579rN)((&((this)->callStack)), ((CallStackInfo_s){.span = (span), .name = (name)}))); }
none popCallStackPS3154rN(IRInterp_s *this) {
    ((assertBPcrN)(((((this)->callStack).length) > ((usize)(0llu))), ("IRInterp.popCallStack() called on empty stack!")));
    ((popPS2247rPS6579)((&((this)->callStack))));
}
none dumpCallStackPS3154PS0540rN(IRInterp_s *this, String_s *loc) {
    (((fprintf))((stderr_), ("%s: %s: The current call stack:\n"), ((loc)->buffer), (NOTE_STR)));
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->callStack).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->callStack).length) - (_i)) - ((usize)(1llu)));
        CallStackInfo_s *e = ((atPS2247uszrPS6579)((&((this)->callStack)), (i)));
        String_s l = ((toStringPS8951rS0540)((&((e)->span))));
        (((fprintf))((stderr_), ("%s: %s: Entered function `%s` here.\n"), ((l).buffer), (NOTE_STR), (((e)->name).buffer)));
        ((dropPS0540rN)((&(l))));
    }
}
IRInterp_s newIRInterpreterPS9562rS3154(IRGen_s *irGen) {
    u8 *regStack = (((malloc))((REG_STACK_SIZE)));
    ((assertBPcrN)(((regStack) != (NULL)), ("Could not prepare IRInterp.regStack")));
    u8 *realStack = (((malloc))((STACK_SIZE)));
    ((assertBPcrN)(((realStack) != (NULL)), ("Could not prepare IRInterp.realStack")));
    u8 *argStack = (((malloc))(((usize)(640000llu))));
    ((assertBPcrN)(((argStack) != (NULL)), ("Could not prepare IRInterp.argStack")));
    return ((IRInterp_s){.irGen = (irGen),
                         .globalRegisters = (NULL),
                         .regStackStart = (regStack),
                         .globalRegBase = (regStack),
                         .regStackBase = (regStack),
                         .realStackStart = (realStack),
                         .realStackPointer = (realStack),
                         .realStackBase = (realStack),
                         .argStack = (argStack),
                         .argStackLength = ((usize)(0llu)),
                         .argStackCapacity = ((usize)(640000llu))});
}
bool equalsPS7469PS7469rB(LLVMBasicBlock_s *this, LLVMBasicBlock_s *other) { return ((((this)->ref).ptr) == (((other)->ref).ptr)); }
none guardReferencePS7469rN(LLVMBasicBlock_s *this) { ((assertBPcrN)((!(((LLVM_isNullS6239rB))(((this)->ref)))), ("LLVM Basic Block is null"))); }
LLVMValue_s getParentPS7469rS8925(LLVMBasicBlock_s *this) {
    ((guardReferencePS7469rN)((this)));
    LLVM_ValueRef_s parent = (((LLVMGetBasicBlockParent))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((parent)))), ("Could not get parent from basic block")));
    return ((newLLVMValueFromRefS1407rS8925)((parent)));
}
bool getLastInstructionPS7469PS8925rB(LLVMBasicBlock_s *this, LLVMValue_s *out) {
    ((guardReferencePS7469rN)((this)));
    LLVM_ValueRef_s instr = (((LLVMGetLastInstruction))(((this)->ref)));
    if (((LLVM_isNullS1407rB))((instr)))
        return (false);
    ((*(out)) = ((newLLVMValueFromRefS1407rS8925)((instr))));
    return (true);
}
LLVMBasicBlock_s newLLVMBasicBlockFromRefS6239rS7469(LLVM_BasicBlockRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((ref)))), ("Passed invalid reference to newLLVMBasicBlockFromRef")));
    return ((LLVMBasicBlock_s){.ref = (ref)});
}
LLVMAttribute_s newLLVMAttributeFromRefS8710rS6660(LLVM_AttributeRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS8710rB))((ref)))), ("newLLVMAttributeFromRef called with invalid reference")));
    return ((LLVMAttribute_s){.ref = (ref)});
}
bool equalsPS8925PS8925rB(LLVMValue_s *this, LLVMValue_s *other) { ((todo_with_msgPcrN)(("LLVMValue.equals"))); }
none guardReferencePS8925rN(LLVMValue_s *this) { ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((this)->ref)))), ("LLVM Value is null"))); }
bool isStructValuePS8925rB(LLVMValue_s *this) {
    LLVMType_s t = ((getTypePS8925rS0706)((this)));
    return ((isStructPS0706rB)((&(t))));
}
none dumpPS8925rN(LLVMValue_s *this) { (((LLVMDumpValue))(((this)->ref))); }
LLVMType_s getGlobalTypePS8925rS0706(LLVMValue_s *this) {
    LLVM_TypeRef_s t = (((LLVMGlobalGetValueType))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get global type of LLVMValue")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
LLVMValue_s getNthParamPS8925uszrS8925(LLVMValue_s *this, usize index) {
    LLVM_ValueRef_s param = (((LLVMGetParam))(((this)->ref), ((u32)((index)))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((param)))), ("Could not get parameter of LLVMValue")));
    return ((newLLVMValueFromRefS1407rS8925)((param)));
}
LLVMBasicBlock_s getFirstBasicBlockPS8925rS7469(LLVMValue_s *this) {
    LLVM_BasicBlockRef_s block = (((LLVMGetFirstBasicBlock))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not get first basic block from LLVMValue")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMType_s getTypePS8925rS0706(LLVMValue_s *this) {
    LLVM_TypeRef_s t = (((LLVMTypeOf))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get type of LLVMValue")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
none setNamePS8925S7720rN(LLVMValue_s *this, SubStr_s name) { (((LLVMSetValueName2))(((this)->ref), ((name).start), ((name).len))); }
SubStr_s getNamePS8925rS7720(LLVMValue_s *this) {
    usize len = ((usize)(0llu));
    char *name = (((LLVMGetValueName2))(((this)->ref), (&(len))));
    return ((newSubStrPcuszuszrS7720)((name), ((usize)(0llu)), (len)));
}
none setInitializerPS8925S8925rN(LLVMValue_s *this, LLVMValue_s val) {
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((val).ref)))), ("Expected valid LLVMValue in LLVMValue.setInitializer")));
    (((LLVMSetInitializer))(((this)->ref), ((val).ref)));
}
LLVMValue_s getInitializerPS8925rS8925(LLVMValue_s *this) {
    LLVM_ValueRef_s val = (((LLVMGetInitializer))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get initializer of LLVMValue")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
none addAttributePS8925u32S6660rN(LLVMValue_s *this, u32 index, LLVMAttribute_s attr) { (((LLVMAddAttributeAtIndex))(((this)->ref), (index), ((attr).ref))); }
LLVMValue_s newLLVMValueFromRefS1407rS8925(LLVM_ValueRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((ref)))), ("Passed invalid reference to newLLVMValueFromRef")));
    return ((LLVMValue_s){.ref = (ref)});
}
bool equalsPS0706PS0706rB(LLVMType_s *this, LLVMType_s *other) { return ((((this)->ref).ptr) == (((other)->ref).ptr)); }
bool isFunctionPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMFunctionTypeKind)); }
LLVMType_s getReturnTypePS0706rS0706(LLVMType_s *this) {
    ((assertBPcrN)(((isFunctionPS0706rB)((this))), ("LLVM::getReturnType() called on non-function")));
    LLVM_TypeRef_s t = (((LLVMGetReturnType))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get return type")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
bool isVoidPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMVoidTypeKind)); }
bool isStructPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMStructTypeKind)); }
bool isPointerPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMPointerTypeKind)); }
char *toCharsPS0706rPc(LLVMType_s *this) { return (((LLVMPrintTypeToString))(((this)->ref))); }
LLVMType_s intoFunctionTypePS0706S4318BrS0706(LLVMType_s *this, LLVMTypeList_s params, bool varArg) {
    ((assertBrN)(((sizeof(LLVMType_s)) == ((usize)(8llu)))));
    LLVM_TypeRef_s fn = (((LLVMFunctionType))(((this)->ref), ((LLVM_TypeRef_s *)(((params).elements))), ((u32)(((params).length))), ((newLLVMBoolBrS2924)((varArg)))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((fn)))), ("Could not turn LLVMType into a FunctionType")));
    return ((newLLVMTypeFromRefS6708rS0706)((fn)));
}
LLVMType_s intoPointerTypePS0706rS0706(LLVMType_s *this) {
    LLVM_TypeRef_s ptr = (((LLVMPointerType))(((this)->ref), ((u32)(0))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((ptr)))), ("Could not turn LLVMType into a PointerType")));
    return ((newLLVMTypeFromRefS6708rS0706)((ptr)));
}
LLVMType_s intoArrayTypePS0706u32rS0706(LLVMType_s *this, u32 size) {
    LLVM_TypeRef_s arr = (((LLVMArrayType))(((this)->ref), (size)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((arr)))), ("Could not turn LLVMType into a ArrayType")));
    return ((newLLVMTypeFromRefS6708rS0706)((arr)));
}
LLVMValue_s constIntPS0706uszBrS8925(LLVMType_s *this, usize value, bool signExtend) {
    LLVMBool_s s = ((newLLVMBoolBrS2924)((signExtend)));
    LLVM_ValueRef_s val = (((LLVMConstInt))(((this)->ref), (value), (s)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant integer")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s constZeroPS0706rS8925(LLVMType_s *this) {
    LLVM_ValueRef_s val = (((LLVMConstNull))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant zero")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s constFloatPS0706f64rS8925(LLVMType_s *this, f64 value) {
    LLVM_ValueRef_s val = (((LLVMConstReal))(((this)->ref), (value)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant float")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s getInlineAsmPS0706PS6859rS8925(LLVMType_s *this, ASMContext_s *context) {
    String_s constraints = ((collectPS6859rS0540)((context)));
    LLVM_ValueRef_s val =
        (((LLVMGetInlineAsm))(((this)->ref), (((context)->code).buffer), (((context)->code).length), ((constraints).buffer), ((constraints).length), ((newLLVMBoolBrS2924)(((context)->sideEffects))),
                              ((newLLVMBoolBrS2924)(((context)->alignedStack))), ((u32)(((tagAnyru8)((&((context)->dialect)))))), ((newLLVMBoolBrS2924)(((context)->canThrow)))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not generate inline assembly")));
    ((dropPS0540rN)((&(constraints))));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMType_s newLLVMTypeFromRefS6708rS0706(LLVM_TypeRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((ref)))), ("Passed invalid reference to newLLVMTypeFromRef")));
    return ((LLVMType_s){.ref = (ref)});
}
LLVMPassBuilderOptions_s createPassBuilderOptionsrS4890(none) {
    LLVM_PassBuilderOptionsRef_s v = (((LLVMCreatePassBuilderOptions))());
    ((assertBPcrN)((!(((LLVM_isNullS7356rB))((v)))), ("Could not create Pass Builder Options")));
    return ((LLVMPassBuilderOptions_s){.ref = (v)});
}
none disposePassBuilderOptionsS4890rN(LLVMPassBuilderOptions_s opt) { (((LLVMDisposePassBuilderOptions))(((opt).ref))); }
none setVerifyEachS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s verify) { (((LLVMPassBuilderOptionsSetVerifyEach))(((opt).ref), (verify))); }
none setDebugLoggingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s debug) { (((LLVMPassBuilderOptionsSetDebugLogging))(((opt).ref), (debug))); }
none setAAPipelineS4890PcrN(LLVMPassBuilderOptions_s opt, char *pipeline) { (((LLVMPassBuilderOptionsSetAAPipeline))(((opt).ref), (pipeline))); }
none setLoopInterleavingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s interleave) { (((LLVMPassBuilderOptionsSetLoopInterleaving))(((opt).ref), (interleave))); }
none setLoopVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize) { (((LLVMPassBuilderOptionsSetLoopVectorization))(((opt).ref), (vectorize))); }
none setSLPVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize) { (((LLVMPassBuilderOptionsSetSLPVectorization))(((opt).ref), (vectorize))); }
none setLoopUnrollingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s unroll) { (((LLVMPassBuilderOptionsSetLoopUnrolling))(((opt).ref), (unroll))); }
none setForgetAllSCEVInLoopUnrollS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s forget) { (((LLVMPassBuilderOptionsSetForgetAllSCEVInLoopUnroll))(((opt).ref), (forget))); }
none setLicmMssaOptCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap) { (((LLVMPassBuilderOptionsSetLicmMssaOptCap))(((opt).ref), (cap))); }
none setLicmMssaNoAccForPromotionCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap) { (((LLVMPassBuilderOptionsSetLicmMssaNoAccForPromotionCap))(((opt).ref), (cap))); }
none setCallGraphProfileS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s profile) { (((LLVMPassBuilderOptionsSetCallGraphProfile))(((opt).ref), (profile))); }
none setMergeFunctionsS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s merge) { (((LLVMPassBuilderOptionsSetMergeFunctions))(((opt).ref), (merge))); }
none setInlinerThresholdS4890i32rN(LLVMPassBuilderOptions_s opt, i32 threshold) { (((LLVMPassBuilderOptionsSetInlinerThreshold))(((opt).ref), (threshold))); }
usize getBitSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMSizeOfTypeInBits))(((this)->ref), ((typ)->ref))); }
usize getABISizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMABISizeOfType))(((this)->ref), ((typ)->ref))); }
usize getStoreSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMStoreSizeOfType))(((this)->ref), ((typ)->ref))); }
LLVMDataLayout_s getDataLayoutPS8369rS7896(LLVMTargetData_s *this) {
    char *c = (((LLVMCopyStringRepOfTargetData))(((this)->ref)));
    if (*((flags).debug)) {
        (((printf))(("[INFO] LLVM Data Layout: %s\n"), (c)));
    }

    return ((LLVMDataLayout_s){.ref = (c)});
}
LLVMTargetData_s newLLVMTargetDataFromRefS6307rS8369(LLVM_TargetDataRef_s ref) { return ((LLVMTargetData_s){.ref = (ref)}); }
LLVMTargetMachine_s createTargetMachinePS4231PcPcPcrS7964(LLVMTarget_s *this, char *triple, char *cpu, char *features) {
    LLVM_TargetMachineRef_s target = (((LLVMCreateTargetMachine))(((this)->ref), (triple), (cpu), (features), ((i32)(0)), ((i32)(0)), ((i32)(0))));
    ((assertBPcrN)((!(((LLVM_isNullS5038rB))((target)))), ("Could not create target machine")));
    return ((newLLVMTargetMachineFromRefS5038rS7964)((target)));
}
LLVMTargetMachine_s createTargetMachineWithOptionsS4231PcS6312rS7964(LLVMTarget_s this, char *triple, LLVMTargetMachineOptions_s options) {
    LLVM_TargetMachineRef_s target = (((LLVMCreateTargetMachineWithOptions))(((this).ref), (triple), ((options).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5038rB))((target)))), ("Could not create target machine")));
    return ((newLLVMTargetMachineFromRefS5038rS7964)((target)));
}
LLVMTarget_s newLLVMTargetFromRefS3497rS4231(LLVM_TargetRef_s ref) { return ((LLVMTarget_s){.ref = (ref)}); }
none writeToFilePS7964S1718i32PcrN(LLVMTargetMachine_s *this, LLVMModule_s mod, i32 mode, char *filepath) {
    LLVMString_s err = ((LLVMString_s){0});
    if ((((LLVMTargetMachineEmitToFile))(((this)->ref), ((mod).ref), (filepath), (mode), (&(err)))) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s Could not write LLVM module to file!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s %s\n"), (FATAL_STR), ((err).chars)));
        (((C_exiti32rN))(((i32)(1))));
    }
}
LLVMTargetData_s getTargetDataPS7964rS8369(LLVMTargetMachine_s *this) {
    LLVM_TargetDataRef_s data = (((LLVMCreateTargetDataLayout))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6307rB))((data)))), ("Could not get TargetData")));
    return ((newLLVMTargetDataFromRefS6307rS8369)((data)));
}
LLVMTargetMachine_s newLLVMTargetMachineFromRefS5038rS7964(LLVM_TargetMachineRef_s ref) { return ((LLVMTargetMachine_s){.ref = (ref)}); }
LLVMTargetMachineOptions_s createTargetMachineOptionsrS6312(none) {
    LLVM_TargetMachineOptionsRef_s opt = (((LLVMCreateTargetMachineOptions))());
    ((assertBPcrN)((!(((LLVM_isNullS3482rB))((opt)))), ("Could not create target machine options")));
    return ((LLVMTargetMachineOptions_s){.ref = (opt)});
}
none disposeTargetMachineOptionsS6312rN(LLVMTargetMachineOptions_s opt) { (((LLVMDisposeTargetMachineOptions))(((opt).ref))); }
none setCPUS6312PcrN(LLVMTargetMachineOptions_s opt, char *cpu) { (((LLVMTargetMachineOptionsSetCPU))(((opt).ref), (cpu))); }
none setFeaturesS6312PcrN(LLVMTargetMachineOptions_s opt, char *features) { (((LLVMTargetMachineOptionsSetFeatures))(((opt).ref), (features))); }
none setABIS6312PcrN(LLVMTargetMachineOptions_s opt, char *ABI) { (((LLVMTargetMachineOptionsSetABI))(((opt).ref), (ABI))); }
none setCodeGenOptLevelS6312U5589rN(LLVMTargetMachineOptions_s opt, LLVM_CodeGenOptLevel_u level) {
    (((LLVMTargetMachineOptionsSetCodeGenOptLevel))(((opt).ref), (((LLVM_asI32Anyri32))((&(level))))));
}
none setRelocModeS6312U2415rN(LLVMTargetMachineOptions_s opt, LLVM_RelocMode_u reloc) { (((LLVMTargetMachineOptionsSetRelocMode))(((opt).ref), (((LLVM_asI32Anyri32))((&(reloc)))))); }
none setCodeModelS6312U0545rN(LLVMTargetMachineOptions_s opt, LLVM_CodeModel_u model) { (((LLVMTargetMachineOptionsSetCodeModel))(((opt).ref), (((LLVM_asI32Anyri32))((&(model)))))); }
none printPS1718rN(LLVMModule_s *this) {
    char *s = (((LLVMPrintModuleToString))(((this)->ref)));
    (((printf))(("%s\n"), (s)));
}
none setTriplePS1718PcrN(LLVMModule_s *this, char *triple) { (((LLVMSetTarget))(((this)->ref), (triple))); }
none setDataLayoutPS1718S7896rN(LLVMModule_s *this, LLVMDataLayout_s layout) { (((LLVMSetDataLayout))(((this)->ref), ((layout).ref))); }
bool writeToFilePS1718S7720rB(LLVMModule_s *this, SubStr_s path) {
    LLVMString_s err = ((LLVMString_s){0});
    String_s _n = ((toStringPS7720rS0540)((&(path))));
    LLVMBool_s code = (((LLVMPrintModuleToFile))(((this)->ref), ((_n).buffer), (&(err))));
    if (((code).val) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s Could not write LLVM Module to file!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s\n"), ((err).chars)));
        ((dropPS0540rN)((&(_n))));
        return (false);
    }

    ((dropPS0540rN)((&(_n))));
    return (true);
}
bool verifyPS1718rB(LLVMModule_s *this) {
    LLVMString_s err = ((LLVMString_s){0});
    LLVMBool_s code = (((LLVMVerifyModule))(((this)->ref), (LLVMReturnStatusAction), (&(err))));
    if (((code).val) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s LLVM Module verification failed!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s\n"), ((err).chars)));
        return (false);
    }

    return (true);
}
LLVMValue_s addFunctionPS1718S7720S0706rS8925(LLVMModule_s *this, SubStr_s name, LLVMType_s function) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))(((function).ref)))), ("Expected valid LLVMType in LLVMModule.addFunction")));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMAddFunction))(((this)->ref), ((_n).buffer), ((function).ref)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((f)))), ("Could not add function to module")));
    return ((newLLVMValueFromRefS1407rS8925)((f)));
}
bool hasFunctionPS1718S7720rB(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMGetNamedFunction))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    return (!(((LLVM_isNullS1407rB))((f))));
}
LLVMValue_s getFunctionPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMGetNamedFunction))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((f)))), ("Could not get function from module")));
    return ((newLLVMValueFromRefS1407rS8925)((f)));
}
LLVMValue_s addGlobalPS1718S0706u32S7720rS8925(LLVMModule_s *this, LLVMType_s typ, u32 space, SubStr_s name) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))(((typ).ref)))), ("Expected valid LLVMType in LLVMModule.addGlobal")));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s g = (((LLVMAddGlobalInAddressSpace))(((this)->ref), ((typ).ref), ((_n).buffer), (space)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((g)))), ("Could not add global in module")));
    return ((newLLVMValueFromRefS1407rS8925)((g)));
}
LLVMValue_s getGlobalPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s g = (((LLVMGetNamedGlobal))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((g)))), ("Could not get global in module")));
    return ((newLLVMValueFromRefS1407rS8925)((g)));
}
bool runPassesS1718PcS7964S4890rB(LLVMModule_s this, char *passes, LLVMTargetMachine_s target, LLVMPassBuilderOptions_s options) {
    ((assertBrN)((!(((LLVM_isNullS3816rB))(((this).ref))))));
    return (((((LLVMRunPasses))(((this).ref), (passes), ((target).ref), ((options).ref))).ptr) == (NULL));
}
none addModuleFlagS1718i32S7720S8925rN(LLVMModule_s this, i32 behavior, SubStr_s flag, LLVMValue_s value) {
    LLVM_MetadataRef_s meta = (((LLVMValueAsMetadata))(((value).ref)));
    (((LLVMAddModuleFlag))(((this).ref), (behavior), ((flag).start), ((flag).len), (meta)));
}
LLVMModule_s newLLVMModuleFromRefS3816rS1718(LLVM_ModuleRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS3816rB))((ref)))), ("Passed invalid reference to newLLVMModuleFromRef")));
    return ((LLVMModule_s){.ref = (ref)});
}
none guardReferencePS6343rN(LLVMBuilder_s *this) { ((assertBPcrN)((!(((LLVM_isNullS3273rB))(((this)->ref)))), ("LLVM Builder is null"))); }
none positionAtEndPS6343S7469rN(LLVMBuilder_s *this, LLVMBasicBlock_s block) {
    ((guardReferencePS6343rN)((this)));
    (((LLVMPositionBuilderAtEnd))(((this)->ref), ((block).ref)));
}
none positionBeforePS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s instr) {
    ((guardReferencePS6343rN)((this)));
    (((LLVMPositionBuilderBefore))(((this)->ref), ((instr).ref)));
}
LLVMBasicBlock_s getInsertBlockPS6343rS7469(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_BasicBlockRef_s block = (((LLVMGetInsertBlock))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not get insert block from builder")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMValue_s buildInsertValuePS6343S8925S8925u32PcrS8925(LLVMBuilder_s *this, LLVMValue_s aggregate, LLVMValue_s element, u32 offset, char *name) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s val = (((LLVMBuildInsertValue))(((this)->ref), ((aggregate).ref), ((element).ref), (offset), (name)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not build insert value in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s buildAllocaPS6343S0706S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s alloced = (((LLVMBuildAlloca))(((this)->ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((alloced)))), ("Could not build alloca in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((alloced)));
}
LLVMValue_s buildStorePS6343S8925S8925rS8925(LLVMBuilder_s *this, LLVMValue_s ptr, LLVMValue_s value) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s store = (((LLVMBuildStore))(((this)->ref), ((value).ref), ((ptr).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((store)))), ("Could not build store in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((store)));
}
LLVMValue_s buildLoadPS6343S0706S8925S7720rS8925(LLVMBuilder_s *this, LLVMType_s pType, LLVMValue_s ptr, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildLoad2))(((this)->ref), ((pType).ref), ((ptr).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build load in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
none buildReturnPS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s value) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s ret = (((LLVMBuildRet))(((this)->ref), ((value).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((ret)))), ("Could not build return in builder")));
}
none buildReturnVoidPS6343rN(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s value = (((LLVMBuildRetVoid))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build return void in builder")));
}
LLVMValue_s buildBrPS6343S7469rS8925(LLVMBuilder_s *this, LLVMBasicBlock_s dest) {
    ((guardReferencePS6343rN)((this)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))(((dest).ref)))), ("Destination for Br is null!")));
    LLVM_ValueRef_s value = (((LLVMBuildBr))(((this)->ref), ((dest).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build Br")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildCondBrPS6343S8925S7469S7469rS8925(LLVMBuilder_s *this, LLVMValue_s cond, LLVMBasicBlock_s tru, LLVMBasicBlock_s fals) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s value = (((LLVMBuildCondBr))(((this)->ref), ((cond).ref), ((tru).ref), ((fals).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build CondBr")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntAddPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildAdd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int add")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntSubPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildSub))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int sub")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntMulPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildMul))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int mul")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntDivPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildUDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int div")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntModPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSRem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildURem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int mod")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatAddPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFAdd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float add")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatSubPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFSub))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float sub")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatMulPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFMul))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float mul")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatDivPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float div")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatModPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFRem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float mod")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildICmp))(((this)->ref), (predicate), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int compare")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFCmp))(((this)->ref), (predicate), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float compare")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildNotPS6343S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildNot))(((this)->ref), ((val).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical not")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildOrPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildOr))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical or")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildAndPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildAnd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical and")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildXorPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildXor))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical xor")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildPtrToIntPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildPtrToInt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build ptr to int")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntToPtrPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildIntToPtr))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int to ptr")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntToFloatPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSIToFP))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildUIToFP))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int to float")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatToIntPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildFPToSI))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildFPToUI))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float to int")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntSignExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildSExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int sign extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntZeroExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildZExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int zero extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFPExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFPTrunc))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float truncate")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildTrunc))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int truncate")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildCallPS6343S8925S0706S8201S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s fn, LLVMType_s fnType, LLVMValueList_s args, LLVMType_s retType, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    ((assertBrN)(((sizeof(LLVMValue_s)) == ((usize)(8llu)))));
    String_s _n = ((String_s){0});
    if ((isVoidPS0706rB)((&(retType)))) {
        ((_n) = ((newStringFromStrLitPcrS0540)((""))));
    }

    else {
        ((_n) = ((toStringPS7720rS0540)((&(name)))));
    }

    LLVM_ValueRef_s value = (((LLVMBuildCall2))(((this)->ref), ((fnType).ref), ((fn).ref), ((LLVM_ValueRef_s *)(((args).elements))), ((u32)(((args).length))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((clearPS8201rN)((&(args))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build call")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildGlobalStringPtrPS6343PcS7720rS8925(LLVMBuilder_s *this, char *start, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s s = (((LLVMBuildGlobalStringPtr))(((this)->ref), (start), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build global string")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
LLVMValue_s buildStructGEPPS6343S0706S8925uszS7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, usize index, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s s = (((LLVMBuildStructGEP2))(((this)->ref), ((typ).ref), ((aggr).ref), ((u32)((index))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build struct GEP")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
LLVMValue_s buildGEPPS6343S0706S8925S8201S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, LLVMValueList_s indices, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    ((assertBrN)(((sizeof(LLVMValue_s)) == ((usize)(8llu)))));
    LLVM_ValueRef_s s = (((LLVMBuildGEP2))(((this)->ref), ((typ).ref), ((aggr).ref), ((LLVM_ValueRef_s *)(((indices).elements))), ((u32)(((indices).length))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((clearPS8201rN)((&(indices))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build GEP")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
none buildUnreachablePS6343rN(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s v = (((LLVMBuildUnreachable))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((v)))), ("Could not build unreachable")));
}
LLVMValue_s buildMemcpyPS6343S8925u32S8925u32S8925rS8925(LLVMBuilder_s *this, LLVMValue_s dst, u32 dstAlign, LLVMValue_s src, u32 srcAlign, LLVMValue_s size) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s v = (((LLVMBuildMemCpy))(((this)->ref), ((dst).ref), (dstAlign), ((src).ref), (srcAlign), ((size).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((v)))), ("Could not build memcpy")));
    return ((newLLVMValueFromRefS1407rS8925)((v)));
}
LLVMBuilder_s newLLVMBuilderFromRefS3273rS6343(LLVM_BuilderRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS3273rB))((ref)))), ("Passed invalid reference to newLLVMBuilderFromRef")));
    return ((LLVMBuilder_s){.ref = (ref)});
}
none dropPS0773rN(LLVMContext_s *this) { (((LLVMContextDispose))(((this)->ref))); }
none guardReferencePS0773rN(LLVMContext_s *this) { ((assertBPcrN)((!(((LLVM_isNullS4183rB))(((this)->ref)))), ("LLVM Context is null"))); }
none initializeTargetsPS0773rN(LLVMContext_s *this) {
    ((assertBPcrN)(((((LLVM_InitializeNativeAsmParser))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeAsmPrinter))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeDisassembler))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeTarget))()) == ((i32)(0))), ("Could not initialize Targets")));
}
LLVMTarget_s createTargetPS0773PcrS4231(LLVMContext_s *this, char *name) {
    LLVM_TargetRef_s target = (((LLVMGetTargetFromName))((name)));
    ((assertBPcrN)((!(((LLVM_isNullS3497rB))((target)))), ("Could not create target triple")));
    return ((newLLVMTargetFromRefS3497rS4231)((target)));
}
char *createTargetTriplePS0773PcrPc(LLVMContext_s *this, char *name) {
    String_s tmp_19798 = ((newStringFromStrLitPcrS0540)(("WINDOWS")));
    String_s tmp_19808 = ((newStringFromStrLitPcrS0540)(("LINUX")));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_19798))) {
        return ("x86_64-pc-windows-msvc");
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_19808))) {
        return ("x86_64-unknown-linux-gnu");
    }

    else {
        ((unreachablePcrN)(("createTargetTriple: Unknown target!")));
    }
}
LLVMModule_s createModuleWithNamePS0773S7720rS1718(LLVMContext_s *this, SubStr_s name) {
    ((guardReferencePS0773rN)((this)));
    String_s _name = ((toStringPS7720rS0540)((&(name))));
    LLVM_ModuleRef_s mod = (((LLVMModuleCreateWithNameInContext))(((_name).buffer), ((this)->ref)));
    ((dropPS0540rN)((&(_name))));
    ((assertBPcrN)((!(((LLVM_isNullS3816rB))((mod)))), ("Could not create module in context")));
    return ((newLLVMModuleFromRefS3816rS1718)((mod)));
}
LLVMBuilder_s createBuilderPS0773rS6343(LLVMContext_s *this) {
    ((guardReferencePS0773rN)((this)));
    LLVM_BuilderRef_s builder = (((LLVMCreateBuilderInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS3273rB))((builder)))), ("Could not create builder in context")));
    return ((newLLVMBuilderFromRefS3273rS6343)((builder)));
}
LLVMType_s createIntegerTypePS0773i64rS0706(LLVMContext_s *this, i64 bitsize) {
    ((assertBPcrN)(((bitsize) > ((i64)(0ll))), ("Got invalid bitsize in createIntegerType")));
    ((assertBPcrN)(((bitsize) <= ((i64)(8388607ll))), ("Got invalid bitsize in createIntegerType")));
    LLVM_TypeRef_s int_ = (((LLVMIntTypeInContext))(((this)->ref), ((u32)((bitsize)))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((int_)))), ("Could not create integer type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((int_)));
}
LLVMType_s createFloatTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s float_ = (((LLVMFloatTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((float_)))), ("Could not create float type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((float_)));
}
LLVMType_s createDoubleTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s double_ = (((LLVMDoubleTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((double_)))), ("Could not create double type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((double_)));
}
LLVMType_s createStructTypePS0773PS0706u32BrS0706(LLVMContext_s *this, LLVMType_s *elements, u32 count, bool packed) {
    LLVMBool_s b = ((newLLVMBoolBrS2924)((packed)));
    LLVM_TypeRef_s strukt = (((LLVMStructTypeInContext))(((this)->ref), ((LLVM_TypeRef_s *)((elements))), (count), (b)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((strukt)))), ("Could not create struct type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((strukt)));
}
LLVMType_s createVoidTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s void_ = (((LLVMVoidTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((void_)))), ("Could not create void type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((void_)));
}
LLVMBasicBlock_s appendBasicBlockPS0773S8925S7720rS7469(LLVMContext_s *this, LLVMValue_s fn, SubStr_s name) {
    String_s _name = ((toStringPS7720rS0540)((&(name))));
    LLVM_BasicBlockRef_s block = (((LLVMAppendBasicBlockInContext))(((this)->ref), ((fn).ref), ((_name).buffer)));
    ((dropPS0540rN)((&(_name))));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not append basic block in context")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMAttribute_s createEnumAttributePS0773u32u64rS6660(LLVMContext_s *this, u32 id, u64 val) {
    LLVM_AttributeRef_s attr = (((LLVMCreateEnumAttribute))(((this)->ref), (id), (val)));
    ((assertBPcrN)((!(((LLVM_isNullS8710rB))((attr)))), ("Could not create enum attribute in context")));
    return ((newLLVMAttributeFromRefS8710rS6660)((attr)));
}
LLVMContext_s newLLVMContextrS0773(none) {
    LLVM_ContextRef_s ref = (((LLVMContextCreate))());
    ((assertBPcrN)((!(((LLVM_isNullS4183rB))((ref)))), ("Could not create LLVM Context")));
    return ((LLVMContext_s){.ref = (ref)});
}
LLVMDIBuilder_s createDIBuilderS1718rS1476(LLVMModule_s mod) {
    LLVM_DIBuilderRef_s di = (((LLVMCreateDIBuilder))(((mod).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1302rB))((di)))), ("Could not create DIBuilder")));
    return ((LLVMDIBuilder_s){.ref = (di)});
}
none disposeDIBuilderS1476rN(LLVMDIBuilder_s builder) { (((LLVMDisposeDIBuilder))(((builder).ref))); }
none finalizeDIBuilderS1476rN(LLVMDIBuilder_s builder) { (((LLVMDIBuilderFinalize))(((builder).ref))); }
LLVMMetadata_s createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777(LLVMDIBuilder_s builder, i32 lang, LLVMMetadata_s file, SubStr_s producer, LLVMBool_s isOptimized,
                                                                                                     SubStr_s flags, u32 runtimeVer, SubStr_s splitName, i32 kind, u32 dwoid,
                                                                                                     LLVMBool_s splitDebugInlining, LLVMBool_s debugInfoForProfiling, SubStr_s sysRoot, SubStr_s sdk) {
    LLVM_MetadataRef_s unit = (((LLVMDIBuilderCreateCompileUnit))(((builder).ref), (lang), ((file).ref), ((producer).start), ((producer).len), (isOptimized), ((flags).start), ((flags).len),
                                                                  (runtimeVer), ((splitName).start), ((splitName).len), (kind), (dwoid), (splitDebugInlining), (debugInfoForProfiling),
                                                                  ((sysRoot).start), ((sysRoot).len), ((sdk).start), ((sdk).len)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((unit)))), ("Could not create debug compile unit")));
    return ((LLVMMetadata_s){.ref = (unit)});
}
LLVMMetadata_s createFileS1476PcuszPcuszrS5777(LLVMDIBuilder_s builder, char *filename, usize fileLen, char *dir, usize dirLen) {
    LLVM_MetadataRef_s file = (((LLVMDIBuilderCreateFile))(((builder).ref), (filename), (fileLen), (dir), (dirLen)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((file)))), ("Could not create debug file")));
    return ((LLVMMetadata_s){.ref = (file)});
}
LLVMMetadata_s createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, SubStr_s linkage, LLVMMetadata_s file, u32 line,
                                                                                          LLVMMetadata_s type, LLVMBool_s localToUnit, LLVMBool_s isDefinition, u32 scopeLine, i32 flags,
                                                                                          LLVMBool_s isOptimized) {
    LLVM_MetadataRef_s fn = (((LLVMDIBuilderCreateFunction))(((builder).ref), ((scope).ref), ((name).start), ((name).len), ((linkage).start), ((linkage).len), ((file).ref), (line), ((type).ref),
                                                             (localToUnit), (isDefinition), (scopeLine), (flags), (isOptimized)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((fn)))), ("Could not create debug function")));
    return ((LLVMMetadata_s){.ref = (fn)});
}
LLVMMetadata_s createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, u32 arg, LLVMMetadata_s file, u32 line,
                                                                                    LLVMMetadata_s ty, LLVMBool_s alwaysPreserve, i32 flags) {
    LLVM_MetadataRef_s p = (((LLVMDIBuilderCreateParameterVariable))(((builder).ref), ((scope).ref), ((name).start), ((name).len), (arg), ((file).ref), (line), ((ty).ref), (alwaysPreserve), (flags)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((p)))), ("Could not create debug parameter")));
    return ((LLVMMetadata_s){.ref = (p)});
}
LLVMMetadata_s createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, LLVMMetadata_s file, u32 line, LLVMMetadata_s ty,
                                                                               LLVMBool_s alwaysPreserve, i32 flags, u32 align) {
    LLVM_MetadataRef_s v = (((LLVMDIBuilderCreateAutoVariable))(((builder).ref), ((scope).ref), ((name).start), ((name).len), ((file).ref), (line), ((ty).ref), (alwaysPreserve), (flags), (align)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((v)))), ("Could not create debug variable")));
    return ((LLVMMetadata_s){.ref = (v)});
}
u32 getEncodingU7375ru32(PrimType_u p) {
    bool succ_2617_ = true;
    bool succ_2619_ = true;
    bool succ_2621_ = true;
    bool succ_2623_ = true;
    bool succ_2625_ = true;
    bool succ_2627_ = true;
    bool succ_2629_ = true;
    bool succ_2631_ = true;
    bool succ_2633_ = true;
    bool succ_2635_ = true;
    bool succ_2637_ = true;
    bool succ_2639_ = true;
    bool succ_2641_ = true;
    bool succ_2643_ = true;
    bool succ_2645_ = true;

    PrimType_u tmp_4153_ = (p);
    {
        succ_2617_ &= (tmp_4153_.tag == 0);
        if (succ_2617_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4153;
        }
    }
    {
        succ_2619_ &= (tmp_4153_.tag == 1);
        if (succ_2619_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4153;
        }
    }
    {
        succ_2621_ &= (tmp_4153_.tag == 2);
        if (succ_2621_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4153;
        }
    }
    {
        succ_2623_ &= (tmp_4153_.tag == 3);
        if (succ_2623_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4153;
        }
    }
    {
        succ_2625_ &= (tmp_4153_.tag == 4);
        if (succ_2625_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4153;
        }
    }
    {
        succ_2627_ &= (tmp_4153_.tag == 5);
        if (succ_2627_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4153;
        }
    }
    {
        succ_2629_ &= (tmp_4153_.tag == 6);
        if (succ_2629_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4153;
        }
    }
    {
        succ_2631_ &= (tmp_4153_.tag == 7);
        if (succ_2631_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4153;
        }
    }
    {
        succ_2633_ &= (tmp_4153_.tag == 8);
        if (succ_2633_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4153;
        }
    }
    {
        succ_2635_ &= (tmp_4153_.tag == 9);
        if (succ_2635_) {
            {
                return (DW_ATE_address);
            }
            goto after_4153;
        }
    }
    {
        succ_2637_ &= (tmp_4153_.tag == 10);
        if (succ_2637_) {
            {
                return (DW_ATE_boolean);
            }
            goto after_4153;
        }
    }
    {
        succ_2639_ &= (tmp_4153_.tag == 11);
        if (succ_2639_) {
            {
                ((unreachablePcrN)(("getEncoding(None)")));
            }
            goto after_4153;
        }
    }
    {
        succ_2641_ &= (tmp_4153_.tag == 12);
        if (succ_2641_) {
            {
                return (DW_ATE_unsigned_char);
            }
            goto after_4153;
        }
    }
    {
        succ_2643_ &= (tmp_4153_.tag == 13);
        if (succ_2643_) {
            {
                return (DW_ATE_float);
            }
            goto after_4153;
        }
    }
    {
        succ_2645_ &= (tmp_4153_.tag == 14);
        if (succ_2645_) {
            {
                return (DW_ATE_float);
            }
            goto after_4153;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4153;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4153:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of primitive types in getEncoding")));
}
SubStr_s getFullNameU7375rS7720(PrimType_u p) {
    bool succ_2648_ = true;
    bool succ_2650_ = true;
    bool succ_2652_ = true;
    bool succ_2654_ = true;
    bool succ_2656_ = true;
    bool succ_2658_ = true;
    bool succ_2660_ = true;
    bool succ_2662_ = true;
    bool succ_2664_ = true;
    bool succ_2666_ = true;
    bool succ_2668_ = true;
    bool succ_2670_ = true;
    bool succ_2672_ = true;
    bool succ_2674_ = true;
    bool succ_2676_ = true;

    PrimType_u tmp_4186_ = (p);
    {
        succ_2648_ &= (tmp_4186_.tag == 0);
        if (succ_2648_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u8"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2650_ &= (tmp_4186_.tag == 1);
        if (succ_2650_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u16"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2652_ &= (tmp_4186_.tag == 2);
        if (succ_2652_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u32"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2654_ &= (tmp_4186_.tag == 3);
        if (succ_2654_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u64"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2656_ &= (tmp_4186_.tag == 4);
        if (succ_2656_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i8"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2658_ &= (tmp_4186_.tag == 5);
        if (succ_2658_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i16"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2660_ &= (tmp_4186_.tag == 6);
        if (succ_2660_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i32"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2662_ &= (tmp_4186_.tag == 7);
        if (succ_2662_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i64"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2664_ &= (tmp_4186_.tag == 8);
        if (succ_2664_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("usize"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2666_ &= (tmp_4186_.tag == 9);
        if (succ_2666_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("Any"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2668_ &= (tmp_4186_.tag == 10);
        if (succ_2668_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("bool"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2670_ &= (tmp_4186_.tag == 11);
        if (succ_2670_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("none"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2672_ &= (tmp_4186_.tag == 12);
        if (succ_2672_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("char"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2674_ &= (tmp_4186_.tag == 13);
        if (succ_2674_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("f32"))));
            }
            goto after_4186;
        }
    }
    {
        succ_2676_ &= (tmp_4186_.tag == 14);
        if (succ_2676_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("f64"))));
            }
            goto after_4186;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4186;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4186:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of primitive types in getFullName")));
}
LLVMMetadata_s createSubroutineTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    bool succ_2682_ = true;

    Type_u *tmp_4201_ = (type);
    {
        succ_2682_ &= (tmp_4201_->tag == 6);
        TypeList_s *args = &tmp_4201_->payload.variant6._0;
        succ_2682_ &= true;
        Type_u **ret = &tmp_4201_->payload.variant6._1;
        succ_2682_ &= true;
        succ_2682_ &= true;
        if (succ_2682_) {
            {
                LLVM_MetadataRef_s *types = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*args).length) + ((usize)(1llu))))));
                ((assertBrN)(((types) != (NULL))));
                ((((types))[((usize)(0llu))]) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*ret))).ref));
                for (usize i = ((usize)(0llu)); ((i) < ((*args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((((types))[((i) + ((usize)(1llu)))]) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((((*args).elements))[(i)]))).ref));
                }

                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateSubroutineType))(((builder).ref), ((diFile).ref), (types), ((u32)((((*args).length) + ((usize)(1llu))))), (LLVMDIFlagZero)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for function type")));
                (((free))((types)));
                return ((LLVMMetadata_s){.ref = (meta)});
            }
            goto after_4201;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4201;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4201:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("createSubroutineType: Expected function type")));
}
LLVMMetadata_s createDebugInfoForPrimitiveTypeS1476PU5175rS5777(LLVMDIBuilder_s builder, Type_u *type) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2694_ = true;
    bool succ_2692_ = true;
    bool succ_2705_ = true;
    bool succ_2703_ = true;
    bool succ_2711_ = true;

    Type_u *tmp_4226_ = (type);
    {
        succ_2694_ &= (tmp_4226_->tag == 3);
        succ_2692_ &= (tmp_4226_->payload.variant3._0.tag == 9);
        succ_2694_ &= succ_2692_;
        if (succ_2694_) {
            {
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName = ((newSubStrOfStrLitPcrS7720)(("any")));
                LLVM_MetadataRef_s meta =
                    (((LLVMDIBuilderCreatePointerType))(((builder).ref), ((LLVM_MetadataRef_s){0}), ((u64)((size))), ((u32)((align))), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for Any type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4226;
        }
    }
    {
        succ_2705_ &= (tmp_4226_->tag == 3);
        succ_2703_ &= (tmp_4226_->payload.variant3._0.tag == 11);
        succ_2705_ &= succ_2703_;
        if (succ_2705_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for primitive type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4226;
        }
    }
    {
        succ_2711_ &= (tmp_4226_->tag == 3);
        PrimType_u *prim = &tmp_4226_->payload.variant3._0;
        succ_2711_ &= true;
        if (succ_2711_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((*prim)));
                usize size = ((getSizeInBitsPU5175rusz)((type)));
                u32 encoding = ((getEncodingU7375ru32)((*prim)));
                i32 flags = (LLVMDIFlagZero);
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateBasicType))(((builder).ref), ((fullName).start), ((fullName).len), ((u64)((size))), (encoding), (flags)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for primitive type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4226;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForPrimitiveType: Expected primitive type")));
            }
            goto after_4226;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4226:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createDebugInfoForStructTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2722_ = true;

    Type_u *tmp_4267_ = (type);
    {
        succ_2722_ &= (tmp_4267_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_4267_->payload.variant7._0;
        succ_2722_ &= true;
        if (succ_2722_) {
            {
                ParsedFile_s *file = ((getParentFilePS5521rPS1892)((*decl)));
                usize line = ((usize)(0llu));
                usize col = ((usize)(0llu));
                ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(line)), (&(col))));
                String_s unique = ((getFullNamePS5521rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                i32 _flags = (LLVMDIFlagPublic);
                LLVM_MetadataRef_s *elements = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*decl)->context).fieldLength))));
                ((assertBrN)(((elements) != (NULL))));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (i)));
                    TCState_u fts = (((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)))->typeState);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&(fts))));
                    LLVM_MetadataRef_s fieldDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (fieldType))).ref);
                    usize fieldLine = ((usize)(0llu));
                    usize fieldColumn = ((usize)(0llu));
                    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(fieldLine)), (&(fieldColumn))));
                    usize fieldOffset = ((usize)(0llu));
                    usize fieldSize = ((usize)(0llu));
                    usize fieldAlign = ((getAlignmentInBitsPU5175rusz)((fieldType)));
                    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (i), (&(fieldOffset)), (&(fieldSize)), (true)));
                    ((((elements))[(i)]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), (((name).content).start), (((name).content).len), ((diDecl).ref), ((u32)((fieldLine))),
                                                                              ((u64)((fieldSize))), ((u32)((fieldAlign))), ((u64)((fieldOffset))), (LLVMDIFlagZero), (fieldDebugType))));
                }

                char *start = ((((*decl)->name).content).start);
                usize len = ((((*decl)->name).content).len);
                usize size = ((getSizeInBitsPU5175rusz)(((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                usize align = ((getAlignmentInBitsPU5175rusz)(((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), (start), (len), ((diDecl).ref), ((u32)((line))), ((u64)((size))), ((u32)((align))),
                                                                             (_flags), ((LLVM_MetadataRef_s){0}), (elements), ((u32)((((*decl)->context).fieldLength))), ((u32)(0)),
                                                                             ((LLVM_MetadataRef_s){0}), ((unique).buffer), ((unique).length)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for struct type")));
                (((free))((elements)));
                ((dropPS0540rN)((&(unique))));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
                (((LLVMMetadataReplaceAllUsesWith))(((((*decl)->debugInfo).diType).ref), (meta)));
                ((((*decl)->debugInfo).diType) = (data));
            }
            goto after_4267;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForStructType: Expected struct type")));
            }
            goto after_4267;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4267:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, LLVMContext_s llvmContext) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2760_ = true;

    Type_u *tmp_4334_ = (type);
    {
        succ_2760_ &= (tmp_4334_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4334_->payload.variant8._0;
        succ_2760_ &= true;
        succ_2760_ &= true;
        if (succ_2760_) {
            {
                ParsedFile_s *file = ((getParentFilePS0997rPS1892)((*decl)));
                String_s unique = ((getFullNamePS0997rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                usize line = ((usize)(0llu));
                usize col = ((usize)(0llu));
                ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(line)), (&(col))));
                i32 flags = (LLVMDIFlagZero);
                u64 tagSize = ((u64)(8llu));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((tagSize) = ((tagSize) * ((u64)(2llu))));
                LLVMMetadata_s tag = ((createTagTypeS1476S5777PU5175uszrS5777)((builder), (diFile), (type), (line)));
                LLVM_MetadataRef_s *elems = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*decl)->variants).length))));
                ((assertBrN)(((elems) != (NULL))));
                u64 maxSize = ((u64)(0llu));
                u32 maxAlign = ((u32)(8));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((maxAlign) = ((maxAlign) * ((u32)(2))));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (i))));
                    SubStr_s name = (((variant)->name).content);
                    Type_u *variantType = ((toTypePS3506rPU5175)((variant)));
                    u64 variantSize = ((u64)(((getSizeInBitsPU5175rusz)((variantType)))));
                    u32 variantAlign = ((u32)(((getAlignmentInBitsPU5175rusz)((variantType)))));
                    if ((variantSize) > (maxSize))
                        ((maxSize) = (variantSize));
                    if ((variantAlign) > (maxAlign))
                        ((maxAlign) = (variantAlign));
                    LLVM_MetadataRef_s variantDebugType = (((createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777)((builder), (diFile), (*decl), (variant), (line), (flags))).ref);
                    LLVM_MetadataRef_s variantMember = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((name).start), ((name).len), ((diFile).ref), ((u32)((line))), (variantSize),
                                                                                          (variantAlign), ((u64)(0llu)), (flags), (variantDebugType)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((variantMember)))), ("Could not create debug info for union variant")));
                    ((((elems))[(i)]) = (variantMember));
                }

                u64 size = ((u64)(((getSizeInBitsPU5175rusz)((type)))));
                u32 align = ((u32)(((getAlignmentInBitsPU5175rusz)((type)))));
                ((assertBPcrN)(((maxAlign) == (align)), ("Alignment mismatch")));
                ((assertBPcrN)(((maxSize) <= (size)), ("Size mismatch")));
                u64 payloadOffset = (tagSize);
                LLVM_MetadataRef_s meta = ((LLVM_MetadataRef_s){0});
                if ((((*decl)->variants).length) > ((usize)(0llu))) {
                    String_s _payloadStr = ((copyPS0540rS0540)((&(unique))));
                    ((pushStrPS0540PcrN)((&(_payloadStr)), ("._payload")));
                    String_s payloadStr = ((copyPS0540rS0540)((&(unique))));
                    ((pushStrPS0540PcrN)((&(payloadStr)), (".payload")));
                    LLVM_MetadataRef_s _payload =
                        (((LLVMDIBuilderCreateUnionType))(((builder).ref), ((diDecl).ref), ((_payloadStr).buffer), ((_payloadStr).length), ((diFile).ref), ((u32)((line))), (maxSize), (maxAlign),
                                                          (flags), (elems), ((u32)((((*decl)->variants).length))), ((u32)(0)), ((_payloadStr).buffer), ((_payloadStr).length)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((_payload)))), ("Could not create debug info for payload")));
                    LLVM_MetadataRef_s payload = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((payloadStr).buffer), ((payloadStr).length), ((diFile).ref), ((u32)((line))),
                                                                                    (maxSize), (maxAlign), (payloadOffset), (flags), (_payload)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((payload)))), ("Could not create debug info for payload")));
                    array_32406 comb = ((array_32406){((tag).ref), (payload)});
                    ((meta) = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), ((unique).buffer), ((unique).length), ((diFile).ref), ((u32)((line))), (size), (align), (flags),
                                                                 ((LLVM_MetadataRef_s){0}), (&(((comb).arr)[((usize)(0llu))])), ((u32)(2)), ((u32)(0)), ((LLVM_MetadataRef_s){0}), ((unique).buffer),
                                                                 ((unique).length))));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for union")));
                    ((dropPS0540rN)((&(payloadStr))));
                    ((dropPS0540rN)((&(_payloadStr))));
                }

                else {
                    ((meta) = ((tag).ref));
                }

                ((dropPS0540rN)((&(unique))));
                (((free))((elems)));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
                (((LLVMMetadataReplaceAllUsesWith))(((((*decl)->debugInfo).diType).ref), (meta)));
                ((((*decl)->debugInfo).diType) = (data));
            }
            goto after_4334;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForUnionType: Expected union type")));
            }
            goto after_4334;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4334:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createTagTypeS1476S5777PU5175uszrS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, usize line) {
    bool succ_2802_ = true;

    Type_u *tmp_4353_ = (type);
    {
        succ_2802_ &= (tmp_4353_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4353_->payload.variant8._0;
        succ_2802_ &= true;
        succ_2802_ &= true;
        if (succ_2802_) {
            {
                ParsedFile_s *file = ((getParentFilePS0997rPS1892)((*decl)));
                String_s unique = ((getFullNamePS0997rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                LLVMMetadata_s _tag =
                    ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))));
                u64 tagSize = ((u64)(8llu));
                u32 tagAlign = ((u32)(8));
                if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                    ((_tag) = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))))));
                    ((tagSize) = ((u64)(16llu)));
                    ((tagAlign) = ((u32)(16)));
                }

                LLVM_MetadataRef_s tag = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ("tag"), ((usize)(3llu)), ((diDecl).ref), ((u32)((line))), (tagSize), (tagAlign),
                                                                            ((u64)(0llu)), (LLVMDIFlagZero), ((_tag).ref)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((tag)))), ("Could not create debug info for union tag")));
                return ((LLVMMetadata_s){.ref = (tag)});
            }
            goto after_4353;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createTagType: Expected union type")));
            }
            goto after_4353;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4353:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("createTagType")));
}
LLVMMetadata_s createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, usize line, i32 flags) {
    ParsedFile_s *file = ((getParentFilePS0997rPS1892)((decl)));
    LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
    String_s pl = ((getFullNamePS0997rS0540)((decl)));
    ((pushCharPS0540crN)((&(pl)), ('.')));
    {
        String_s _v = ((toStringPS7720rS0540)((&(((variant)->name).content))));
        ((pushStringPS0540PS0540rN)((&(pl)), (&(_v))));
        ((dropPS0540rN)((&(_v))));
    }

    LLVM_MetadataRef_s meta = ((LLVM_MetadataRef_s){0});
    bool succ_2823_ = true;
    bool succ_2821_ = true;

    tuple_1017 tmp_4365_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
    succ_2821_ = tmp_4365_._0 == true;
    succ_2823_ &= succ_2821_;
    ParsedTypeNodeList_s **fields = &tmp_4365_._1;
    succ_2823_ &= true;
    if (!succ_2823_) {
        ((unreachablePcrN)(("createUnionVariantType")));
    };
    if (((*fields)->length) > ((usize)(0llu))) {
        LLVM_MetadataRef_s *inner = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * ((*fields)->length))));
        ((assertBrN)(((inner) != (NULL))));
        for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
            String_s name = ((String_s){0});
            ((pushNumberPS0540uszrN)((&(name)), (i)));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
            LLVM_MetadataRef_s fieldDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (fieldType))).ref);
            usize fieldLine = ((usize)(0llu));
            usize fieldColumn = ((usize)(0llu));
            ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((fieldNode)->span)), (&(fieldLine)), (&(fieldColumn))));
            usize fieldOffset = ((usize)(0llu));
            usize fieldSize = ((usize)(0llu));
            usize fieldAlign = ((getAlignmentInBitsPU5175rusz)((fieldType)));
            ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (i), (&(fieldOffset)), (&(fieldSize)), (true)));
            ((((inner))[(i)]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((name).buffer), ((name).length), ((diFile).ref), ((u32)((fieldLine))), ((u64)((fieldSize))),
                                                                   ((u32)((fieldAlign))), ((u64)((fieldOffset))), (flags), (fieldDebugType))));
        }

        Type_u *variantType = ((toTypePS3506rPU5175)((variant)));
        u64 size = ((u64)(((getSizeInBitsPU5175rusz)((variantType)))));
        u32 align = ((u32)(((getAlignmentInBitsPU5175rusz)((variantType)))));
        ((meta) = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), ((pl).buffer), ((pl).length), ((diFile).ref), ((u32)((line))), (size), (align), (flags),
                                                     ((LLVM_MetadataRef_s){0}), (inner), ((u32)(((*fields)->length))), ((u32)(0)), ((LLVM_MetadataRef_s){0}), ((pl).buffer), ((pl).length))));
        (((free))((inner)));
    }

    else {
        ((meta) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))))).ref));
    }

    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for union variant")));
    ((dropPS0540rN)((&(pl))));
    return ((LLVMMetadata_s){.ref = (meta)});
}
LLVMMetadata_s createTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    LLVMMetadata_s *dt = ((atPS7368uszrPS5777)((&(debugTypes)), ((getIDPU5175rusz)((type)))));
    if (!(((LLVM_isNullS9683rB))(((dt)->ref))))
        return (*(dt));
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2850_ = true;
    bool succ_2853_ = true;
    bool succ_2859_ = true;
    bool succ_2875_ = true;
    bool succ_2887_ = true;
    bool succ_2895_ = true;
    bool succ_2907_ = true;
    bool succ_2912_ = true;
    bool succ_2916_ = true;

    Type_u *tmp_4458_ = (type);
    {
        succ_2850_ &= (tmp_4458_->tag == 3);
        PrimType_u *p = &tmp_4458_->payload.variant3._0;
        succ_2850_ &= true;
        if (succ_2850_) {
            {
                return (*((atPS7368uszrPS5777)((&(debugTypes)), ((usize)(((tagAnyru8)((&(*p)))))))));
            }
            goto after_4458;
        }
    }
    {
        succ_2853_ &= (tmp_4458_->tag == 1);
        if (succ_2853_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for unknown type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4458;
        }
    }
    {
        succ_2859_ &= (tmp_4458_->tag == 2);
        Type_u **under = &tmp_4458_->payload.variant2._0;
        succ_2859_ &= true;
        if (succ_2859_) {
            {
                i32 _flags = (LLVMDIFlagPublic);
                LLVM_MetadataRef_s *elements = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * ((usize)(2llu)))));
                ((assertBrN)(((elements) != (NULL))));
                SubStr_s ptrName = ((newSubStrOfStrLitPcrS7720)(("ptr")));
                SubStr_s sizeName = ((newSubStrOfStrLitPcrS7720)(("length")));
                LLVM_MetadataRef_s ptrDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((intoPointerPU5175rPU5175)((*under))))).ref);
                LLVM_MetadataRef_s sizeDebugType =
                    (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}}))))).ref);
                ((((elements))[((usize)(0llu))]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diFile).ref), ((ptrName).start), ((ptrName).len), ((diFile).ref), ((u32)(0)), ((u64)(64llu)),
                                                                                      ((u32)(64)), ((u64)(0llu)), (LLVMDIFlagZero), (ptrDebugType))));
                ((((elements))[((usize)(1llu))]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diFile).ref), ((sizeName).start), ((sizeName).len), ((diFile).ref), ((u32)(0)), ((u64)(64llu)),
                                                                                      ((u32)(64)), ((u64)(64llu)), (LLVMDIFlagZero), (sizeDebugType))));
                String_s varName = ((newStringFromStrLitPcrS0540)(("var<")));
                String_s _s = ((toStringPU5175rS0540)((*under)));
                ((pushStringPS0540PS0540rN)((&(varName)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                ((pushCharPS0540crN)((&(varName)), ('>')));
                char *start = ((varName).buffer);
                usize len = ((varName).length);
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diFile).ref), (start), (len), ((diFile).ref), ((u32)(0)), ((u64)(128llu)), ((u32)(64)), (_flags),
                                                                             ((LLVM_MetadataRef_s){0}), (elements), ((u32)(2)), ((u32)(0)), ((LLVM_MetadataRef_s){0}), (start), (len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for variadic type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4458;
        }
    }
    {
        succ_2875_ &= (tmp_4458_->tag == 4);
        Type_u **under = &tmp_4458_->payload.variant4._0;
        succ_2875_ &= true;
        if (succ_2875_) {
            {
                LLVMMetadata_s pointee = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*under)));
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName = (((newSubStrOfStrLitPcrS7720)(("ptr"))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreatePointerType))(((builder).ref), ((pointee).ref), (size), (align), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for pointer type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4458;
        }
    }
    {
        succ_2887_ &= (tmp_4458_->tag == 5);
        Type_u **under = &tmp_4458_->payload.variant5._0;
        succ_2887_ &= true;
        usize *size = &tmp_4458_->payload.variant5._1;
        succ_2887_ &= true;
        if (succ_2887_) {
            {
                LLVMMetadata_s element = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*under)));
                LLVM_MetadataRef_s meta =
                    (((LLVMDIBuilderCreateArrayType))(((builder).ref), ((u64)((*size))), ((u32)(((getAlignmentInBitsPU5175rusz)((*under))))), ((element).ref), (&((element).ref)), ((u32)(1))));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for array type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4458;
        }
    }
    {
        succ_2895_ &= (tmp_4458_->tag == 6);
        succ_2895_ &= true;
        succ_2895_ &= true;
        succ_2895_ &= true;
        if (succ_2895_) {
            {
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName1 = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s pointee = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName1).start), ((fullName1).len)));
                SubStr_s fullName = ((newSubStrOfStrLitPcrS7720)(("fnPtr")));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreatePointerType))(((builder).ref), (pointee), (size), (align), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for function type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4458;
        }
    }
    {
        succ_2907_ &= (tmp_4458_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_4458_->payload.variant7._0;
        succ_2907_ &= true;
        if (succ_2907_) {
            {
                return (((*decl)->debugInfo).diType);
            }
            goto after_4458;
        }
    }
    {
        succ_2912_ &= (tmp_4458_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4458_->payload.variant8._0;
        succ_2912_ &= true;
        succ_2912_ &= true;
        if (succ_2912_) {
            {
                return (((*decl)->debugInfo).diType);
            }
            goto after_4458;
        }
    }
    {
        succ_2916_ &= (tmp_4458_->tag == 9);
        succ_2916_ &= true;
        if (succ_2916_) {
            {
                ((todo_with_msgPcrN)(("createType(LLVMDIBuilder: Type::Module")));
            }
            goto after_4458;
        }
    }
    {
        Type_u **unknown = &tmp_4458_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s createType(LLVMDIBuilder): Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_4458;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4458:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((*(dt)) = (data));
    return (data);
}
none setSubprogramS8925S5777rN(LLVMValue_s fn, LLVMMetadata_s sp) { (((LLVMSetSubprogram))(((fn).ref), ((sp).ref))); }
LLVMMetadata_s getSubprogramS8925rS5777(LLVMValue_s fn) {
    LLVM_MetadataRef_s s = (((LLVMGetSubprogram))(((fn).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((s)))), ("Could not get Subprogram")));
    return ((LLVMMetadata_s){.ref = (s)});
}
LLVMMetadata_s createExpressionS1476PuszuszrS5777(LLVMDIBuilder_s diBuilder, usize *addr, usize length) {
    LLVM_MetadataRef_s e = (((LLVMDIBuilderCreateExpression))(((diBuilder).ref), (addr), (length)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((e)))), ("Could not create debug expression")));
    return ((LLVMMetadata_s){.ref = (e)});
}
LLVMMetadata_s createDebugLocationS0773u32u32S5777rS5777(LLVMContext_s ctx, u32 line, u32 col, LLVMMetadata_s scope) {
    LLVM_MetadataRef_s loc = (((LLVMDIBuilderCreateDebugLocation))(((ctx).ref), (line), (col), ((scope).ref), ((LLVM_MetadataRef_s){0})));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((loc)))), ("Could not create debug location")));
    return ((LLVMMetadata_s){.ref = (loc)});
}
none setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder, LLVMContext_s ctx, LLVMValue_s fn, IRFunc_s *irFunc, Span_s span) {
    ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), ((span).file)));
    usize line = ((usize)(0llu));
    usize col = ((usize)(0llu));
    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&(span)), (&(line)), (&(col))));
    LLVMMetadata_s sub = ((getSubprogramS8925rS5777)((fn)));
    LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)((ctx), ((u32)((line))), ((u32)((col))), (sub)));
    (((LLVMSetCurrentDebugLocation2))(((builder).ref), ((loc).ref)));
}
none resetCurrentDebugLocationS1476S6343rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder) { (((LLVMSetCurrentDebugLocation2))(((builder).ref), ((LLVM_MetadataRef_s){0}))); }
LLVMDbgRecord_s insertDeclareRecordBeforeS1476S8925S5777S5777S5777S8925rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                              LLVMValue_s instr) {
    LLVM_DbgRecordRef_s record = (((LLVMDIBuilderInsertDeclareRecordBefore))(((diBuilder).ref), ((storage).ref), ((info).ref), ((expr).ref), ((loc).ref), ((instr).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5902rB))((record)))), ("Could not insert record")));
    return ((LLVMDbgRecord_s){.ref = (record)});
}
LLVMDbgRecord_s insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                             LLVMBasicBlock_s block) {
    LLVM_DbgRecordRef_s record = (((LLVMDIBuilderInsertDeclareRecordAtEnd))(((diBuilder).ref), ((storage).ref), ((info).ref), ((expr).ref), ((loc).ref), ((block).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5902rB))((record)))), ("Could not insert record")));
    return ((LLVMDbgRecord_s){.ref = (record)});
}
bool equalsPU5952PU5952rB(RegValue_u *this, RegValue_u *other) { ((todo_with_msgPcrN)(("RegValue.equals"))); }
none addInterpValuePU5952S9925rN(RegValue_u *this, InterpReg_s val) {
    bool succ_2933_ = true;
    bool succ_2937_ = true;
    bool succ_2940_ = true;
    bool succ_2945_ = true;

    RegValue_u *tmp_4496_ = (this);
    {
        succ_2933_ &= (tmp_4496_->tag == 1);
        LLVMValue_s *llvm = &tmp_4496_->payload.variant1._0;
        succ_2933_ &= true;
        if (succ_2933_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (*llvm), ._1 = (val)}}}));
            }
            goto after_4496;
        }
    }
    {
        succ_2937_ &= (tmp_4496_->tag == 2);
        succ_2937_ &= true;
        if (succ_2937_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 2, .payload = {.variant2 = {._0 = (val)}}}));
            }
            goto after_4496;
        }
    }
    {
        succ_2940_ &= (tmp_4496_->tag == 0);
        if (succ_2940_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 2, .payload = {.variant2 = {._0 = (val)}}}));
            }
            goto after_4496;
        }
    }
    {
        succ_2945_ &= (tmp_4496_->tag == 3);
        LLVMValue_s *llvm = &tmp_4496_->payload.variant3._0;
        succ_2945_ &= true;
        succ_2945_ &= true;
        if (succ_2945_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (*llvm), ._1 = (val)}}}));
            }
            goto after_4496;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_4496;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4496:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none addLLVMValuePU5952S8925rN(RegValue_u *this, LLVMValue_s val) {
    bool succ_2950_ = true;
    bool succ_2954_ = true;
    bool succ_2957_ = true;
    bool succ_2962_ = true;

    RegValue_u *tmp_4507_ = (this);
    {
        succ_2950_ &= (tmp_4507_->tag == 1);
        succ_2950_ &= true;
        if (succ_2950_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 1, .payload = {.variant1 = {._0 = (val)}}}));
            }
            goto after_4507;
        }
    }
    {
        succ_2954_ &= (tmp_4507_->tag == 2);
        InterpReg_s *interp = &tmp_4507_->payload.variant2._0;
        succ_2954_ &= true;
        if (succ_2954_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (val), ._1 = (*interp)}}}));
            }
            goto after_4507;
        }
    }
    {
        succ_2957_ &= (tmp_4507_->tag == 0);
        if (succ_2957_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 1, .payload = {.variant1 = {._0 = (val)}}}));
            }
            goto after_4507;
        }
    }
    {
        succ_2962_ &= (tmp_4507_->tag == 3);
        succ_2962_ &= true;
        InterpReg_s *interp = &tmp_4507_->payload.variant3._1;
        succ_2962_ &= true;
        if (succ_2962_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (val), ._1 = (*interp)}}}));
            }
            goto after_4507;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_4507;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4507:
    (void)0; // error: label at end of compound statement is a C23 extension
}
InterpReg_s asInterpPU5952PcrS9925(RegValue_u *this, char *err) {
    bool succ_2967_ = true;
    bool succ_2972_ = true;

    RegValue_u *tmp_4513_ = (this);
    {
        succ_2967_ &= (tmp_4513_->tag == 2);
        InterpReg_s *interp = &tmp_4513_->payload.variant2._0;
        succ_2967_ &= true;
        if (succ_2967_) {
            {
                return (*interp);
            }
            goto after_4513;
        }
    }
    {
        succ_2972_ &= (tmp_4513_->tag == 3);
        succ_2972_ &= true;
        InterpReg_s *interp = &tmp_4513_->payload.variant3._1;
        succ_2972_ &= true;
        if (succ_2972_) {
            {
                return (*interp);
            }
            goto after_4513;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4513;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4513:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
LLVMValue_s asLLVMPU5952PcrS8925(RegValue_u *this, char *err) {
    bool succ_2977_ = true;
    bool succ_2982_ = true;

    RegValue_u *tmp_4520_ = (this);
    {
        succ_2977_ &= (tmp_4520_->tag == 1);
        LLVMValue_s *llvm = &tmp_4520_->payload.variant1._0;
        succ_2977_ &= true;
        if (succ_2977_) {
            {
                return (*llvm);
            }
            goto after_4520;
        }
    }
    {
        succ_2982_ &= (tmp_4520_->tag == 3);
        LLVMValue_s *llvm = &tmp_4520_->payload.variant3._0;
        succ_2982_ &= true;
        succ_2982_ &= true;
        if (succ_2982_) {
            {
                return (*llvm);
            }
            goto after_4520;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4520;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4520:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
bool isLLVMPU5952rB(RegValue_u *this) {
    bool succ_2987_ = true;
    bool succ_2992_ = true;

    RegValue_u *tmp_4527_ = (this);
    {
        succ_2987_ &= (tmp_4527_->tag == 1);
        succ_2987_ &= true;
        if (succ_2987_) {
            {
                return (true);
            }
            goto after_4527;
        }
    }
    {
        succ_2992_ &= (tmp_4527_->tag == 3);
        succ_2992_ &= true;
        succ_2992_ &= true;
        if (succ_2992_) {
            {
                return (true);
            }
            goto after_4527;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4527;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4527:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isInterpPU5952rB(RegValue_u *this) {
    bool succ_2997_ = true;
    bool succ_3002_ = true;

    RegValue_u *tmp_4534_ = (this);
    {
        succ_2997_ &= (tmp_4534_->tag == 2);
        succ_2997_ &= true;
        if (succ_2997_) {
            {
                return (true);
            }
            goto after_4534;
        }
    }
    {
        succ_3002_ &= (tmp_4534_->tag == 3);
        succ_3002_ &= true;
        succ_3002_ &= true;
        if (succ_3002_) {
            {
                return (true);
            }
            goto after_4534;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4534;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4534:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool generateDebugInfoPS4053i32PPcrB(LLVMCodegen_s *this, i32 argc, char **argv) {
    ((assertBPcrN)((!(((LLVM_isNullS1302rB))((((this)->llvmDIBuilder).ref)))), ("Can\'t generate debug info because DIBuilder is null!")));
    ((assertBPcrN)((((types).length) == ((debugTypes).length)), ("Expected to have as many debug types as normal types")));
    SubStr_s producer = ((newSubStrOfStrLitPcrS7720)(("Bufo Programming Language")));
    String_s cli = ((newStringFromStrLitPcrS0540)((((argv))[((usize)(0llu))])));
    for (i32 i = ((i32)(1)); ((i) < (argc)); ((i) = ((i) + ((i32)(1))))) {
        ((pushCharPS0540crN)((&(cli)), (' ')));
        ((pushStrPS0540PcrN)((&(cli)), (((argv))[((usize)((i)))])));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *f = ((atPS9483uszrPS1892)((&(files)), (i)));
        String_s path = ((toStringPS7720rS0540)((&((f)->origin))));
        String_s root = ((getRootPS0540rS0540)((&(path))));
        String_s file = ((getFileNamePS0540rS0540)((&(path))));
        LLVMMetadata_s diFile = ((createFileS1476PcuszPcuszrS5777)(((this)->llvmDIBuilder), ((file).buffer), ((file).length), ((root).buffer), ((root).length)));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("Could not create debug file")));
        LLVMMetadata_s diUnit =
            ((createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777)(((this)->llvmDIBuilder), (LLVMDWARFSourceLanguageC), (diFile), (producer),
                                                                                                     ((newLLVMBoolBrS2924)((*((flags).opt)))), ((asSubStrPS0540rS7720)((&(cli)))), ((u32)(0)),
                                                                                                     ((SubStr_s){0}), (LLVMDWARFEmissionKindFull), ((u32)(0)), ((newLLVMBoolBrS2924)((true))),
                                                                                                     ((newLLVMBoolBrS2924)((true))), ((SubStr_s){0}), ((SubStr_s){0})));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("Could not create Compile Unit")));
        (((f)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diUnit = (diUnit)}));
        ((dropPS0540rN)((&(file))));
        ((dropPS0540rN)((&(root))));
        ((dropPS0540rN)((&(path))));
    }

    ((assertBPcrN)((((types).length) >= (PRIM_TYPE_COUNT)), ("Expected to find at least all primitive types")));
    for (usize i = ((usize)(0llu)); ((i) < (PRIM_TYPE_COUNT)); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS7368uszrPS5777)((&(debugTypes)), (i)))) = ((createDebugInfoForPrimitiveTypeS1476PU5175rS5777)(((this)->llvmDIBuilder), ((atPS4174uszrPU5175)((&(types)), (i))))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diType = ((LLVMMetadata_s){.ref = (((LLVMTemporaryMDNode))((((this)->llvmContext).ref), (NULL), ((usize)(0llu))))})}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diType = ((LLVMMetadata_s){.ref = (((LLVMTemporaryMDNode))((((this)->llvmContext).ref), (NULL), ((usize)(0llu))))})}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((decl)->ignored)
            continue;
        Type_u *fts = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ParsedFile_s *file = ((getParentFilePS5521rPS1892)((decl)));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diType = ((createDebugInfoForStructTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), (fts)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diType = (diType)}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((decl)->ignored)
            continue;
        Type_u *fts = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ParsedFile_s *file = ((getParentFilePS0997rPS1892)((decl)));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diType = ((createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777)(((this)->llvmDIBuilder), (diFile), (fts), ((this)->llvmContext)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diType = (diType)}));
    }

    ((dropPS0540rN)((&(cli))));
    return (true);
}
bool generateExecutablePS4053S7720i32PPcrB(LLVMCodegen_s *this, SubStr_s outPath, i32 argc, char **argv) {
    IRFuncList_s fns = ((asListPS2612rS8040)((&(((this)->irGen)->functions))));
    if (*((flags).debug)) {
        if (!((generateDebugInfoPS4053i32PPcrB)((this), (argc), (argv))))
            return (false);
        if (*((flags).verbose)) {
            ((dumpInstructionsPS7132rN)((&(((this)->irGen)->globalScope))));
            for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
                IRFunc_s *f = ((atPS8040uszrPS7132)((&(fns)), (i)));
                ((dumpInstructionsPS7132rN)((f)));
            }
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((generateLLVMFunctionHeaderPS4053PS7132rN)((this), ((atPS8040uszrPS7132)((&(fns)), (i)))));
    }

    if (!((generateRuntimeInitializationPS4053PS7132rB)((this), (&(((this)->irGen)->initRuntime)))))
        return (false);
    if (!((generateEntryPointPS4053rB)((this))))
        return (false);
    if (!((generateGlobalPS4053PS7132rB)((this), (&(((this)->irGen)->globalScope)))))
        return (false);
    if (!((_generateFunctionPS4053PS7132rB)((this), (&(((this)->irGen)->initRuntime)))))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRFunc_s *f = ((atPS8040uszrPS7132)((&(fns)), (i)));
        if (!((generateFunctionPS4053PS7132rB)((this), (f))))
            return (false);
    }

    if (*((flags).debug)) {
        ((finalizeDIBuilderS1476rN)(((this)->llvmDIBuilder)));
    }

    if ((*((flags).debug)) && (*((flags).emitLLVM)))
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("debug_before.ll")))));
    if (!((verifyPS1718rB)((&((this)->llvmModule)))))
        return (false);
    if (*((flags).opt)) {
        LLVMPassBuilderOptions_s passOptions = ((createPassBuilderOptionsrS4890)());
        ((setLoopInterleavingS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLoopVectorizationS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setSLPVectorizationS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLoopUnrollingS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setForgetAllSCEVInLoopUnrollS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLicmMssaOptCapS4890u32rN)((passOptions), ((u32)(100))));
        ((setLicmMssaNoAccForPromotionCapS4890u32rN)((passOptions), ((u32)(8))));
        ((setCallGraphProfileS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setMergeFunctionsS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setInlinerThresholdS4890i32rN)((passOptions), ((i32)(250))));
        if (!((runPassesS1718PcS7964S4890rB)(((this)->llvmModule), ("default<O3>"), ((this)->llvmTargetMachine), (passOptions)))) {
            return (false);
        }

        ((disposePassBuilderOptionsS4890rN)((passOptions)));
    }

    if ((*((flags).debug)) && (*((flags).emitLLVM)))
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("debug_after.ll")))));
    String_s objPath = ((toStringPS7720rS0540)((&(outPath))));
    ((pushStrPS0540PcrN)((&(objPath)), (".obj")));
    if (*((flags).verbose)) {
        (((printf))(("[INFO] Saving object file at %s\n"), ((objPath).buffer)));
    }

    ((writeToFilePS7964S1718i32PcrN)((&((this)->llvmTargetMachine)), ((this)->llvmModule), (LLVMObjectFile), ((objPath).buffer)));
    if (*((flags).emitASM)) {
        String_s asmPath = ((toStringPS7720rS0540)((&(outPath))));
        ((pushStrPS0540PcrN)((&(asmPath)), (".s")));
        (((printf))(("[INFO] Saving assembly code in %s\n"), ((asmPath).buffer)));
        ((writeToFilePS7964S1718i32PcrN)((&((this)->llvmTargetMachine)), ((this)->llvmModule), (LLVMAssemblyFile), ((asmPath).buffer)));
        ((dropPS0540rN)((&(asmPath))));
    }

    if (*((flags).emitLLVM)) {
        String_s llvmPath = ((toStringPS7720rS0540)((&(outPath))));
        ((pushStrPS0540PcrN)((&(llvmPath)), (".ll")));
        (((printf))(("[INFO] Saving LLVM IR in %s\n"), ((llvmPath).buffer)));
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&(llvmPath))))));
        ((dropPS0540rN)((&(llvmPath))));
    }

    return (true);
}
bool generateRuntimeInitializationPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *initRuntime) {
    Type_u *rt_type = ((wrapU5175rPU5175)(((Type_u){
        .tag = 6,
        .payload = {.variant6 = {._0 = ((TypeList_s){0}), ._1 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), ._2 = ((FuncAttr_s){0})}}})));
    LLVMType_s llvmFuncType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), (rt_type)));
    LLVMValue_s llvmFuncValue = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&((initRuntime)->name)))), (llvmFuncType)));
    if (*((flags).debug)) {
        ParsedFile_s *file = (NULL);
        for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedFile_s *f = ((atPS9483uszrPS1892)((&(files)), (i)));
            SubStr_s tmp_23083 = ((asSubStrPS0540rS7720)(((flags).file)));

            if ((endsWithPS7720PS7720rB)((&((f)->origin)), (&tmp_23083))) {
                ((file) = (f));
                break;
            }
        }

        ((assertBrN)(((file) != (NULL))));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((initRuntime)->span)), (&(line)), (&(col))));
        SubStr_s linkage = ((asSubStrPS0540rS7720)((&((initRuntime)->name))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diUnit = (((file)->debugInfo).diUnit);
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("DebugInfo File is null")));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("DebugInfo Unit is null")));
        LLVMMetadata_s sp =
            ((createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777)(((this)->llvmDIBuilder), (diUnit), ((asSubStrPS0540rS7720)((&((initRuntime)->name)))), (linkage), (diFile),
                                                                                          ((u32)((line))), ((createSubroutineTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), (rt_type))),
                                                                                          ((newLLVMBoolBrS2924)((false))), ((newLLVMBoolBrS2924)((true))), ((u32)((line))), (LLVMDIFlagPrototyped),
                                                                                          ((newLLVMBoolBrS2924)((*((flags).opt))))));
        ((setSubprogramS8925S5777rN)((llvmFuncValue), (sp)));
    }

    (((initRuntime)->llvmFunc) = (llvmFuncValue));
    return (true);
}
bool generateEntryPointPS4053rB(LLVMCodegen_s *this) {
    if (*((flags).noEntry))
        return (true);
    SubStr_s realMainName = ((newSubStrOfStrLitPcrS7720)(("__real_main")));
    if (!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (realMainName)))) {
        (((fprintf))((stderr_), ("%s Could not find entry point!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: Expected to find `std/runtime.bufo` in the list of imports, but failed!\n"), (NOTE_STR)));
        return (false);
    }

    LLVMValue_s realMainFunc = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (realMainName)));
    SubStr_s mainName = ((newSubStrOfStrLitPcrS7720)(("maini32PPcri32")));
    if (!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (mainName)))) {
        (((fprintf))((stderr_), ("%s Could not find main function!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: The compiler currently requires that the input file also defines a main function.\n"), (NOTE_STR)));
        (((fprintf))((stderr_), ("%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n"), (NOTE_STR)));
        return (false);
    }

    LLVMValue_s mainFunc = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (mainName)));
    LLVMType_s retType = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
    LLVMTypeList_s params = ((LLVMTypeList_s){0});
    ((pushPS4318S0706rN)((&(params)), ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))))));
    LLVMType_s _p = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
    ((pushPS4318S0706rN)((&(params)), ((intoPointerTypePS0706rS0706)((&(_p))))));
    LLVMType_s tmp_23315 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

    ((pushPS4318S0706rN)((&(params)), ((intoPointerTypePS0706rS0706)((&tmp_23315)))));
    LLVMType_s retFnType = ((intoFunctionTypePS0706S4318BrS0706)((&(retType)), (params), (false)));
    ((assertBrN)((!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("main"))))))));
    LLVMValue_s main = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("main"))), (retFnType)));
    LLVMBasicBlock_s entry = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (main), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    ((positionAtEndPS6343S7469rN)((&((this)->llvmBuilder)), (entry)));
    LLVMValueList_s args = ((LLVMValueList_s){0});
    {
        SubStr_s rt_name = ((newSubStrOfStrLitPcrS7720)((".init_runtime")));
        ((assertBPcrN)(((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (rt_name))), ("Could not find .init_runtime")));
        LLVMValue_s runtime_func = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (rt_name)));
        LLVMType_s _retType = ((createVoidTypePS0773rS0706)((&((this)->llvmContext))));
        LLVMTypeList_s _params = ((LLVMTypeList_s){0});
        LLVMType_s _retFnType = ((intoFunctionTypePS0706S4318BrS0706)((&(_retType)), (_params), (false)));
        ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (runtime_func), (_retFnType), ((LLVMValueList_s){0}), (_retType), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    }

    ((pushPS8201S8925rN)((&(args)), ((getNthParamPS8925uszrS8925)((&(main)), ((usize)(0llu))))));
    ((pushPS8201S8925rN)((&(args)), ((getNthParamPS8925uszrS8925)((&(main)), ((usize)(1llu))))));
    ((pushPS8201S8925rN)((&(args)), (mainFunc)));
    LLVMValue_s v = ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (realMainFunc), (retFnType), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    ((buildReturnPS6343S8925rN)((&((this)->llvmBuilder)), (v)));
    return (true);
}
bool generateGlobalPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *global) {
    (((this)->global) = ((RegValueList_s){0}));
    ((initBlankPS5884uszrN)((&((this)->global)), (((global)->registers).length)));
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((global)));
    LLVMValue_s llvmFunc = ((LLVMValue_s){0});
    LLVMBasicBlockList_s blocks = ((LLVMBasicBlockList_s){0});
    ((pushRegisterStackPS3154S8951uszrN)(((this)->interp), ((defaultSpanrS8951)()), (funcSize)));
    ((((this)->interp)->globalRegisters) = (&((this)->global)));
    ((((this)->interp)->globalRegBase) = (((this)->interp)->regStackBase));
    ((assertBPcrN)(((((global)->blocks).length) == ((usize)(1llu))), ("Expected to only find one IRBlock in global scope")));
    ((generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN)((this), (&(llvmFunc)), (global), (&(blocks)), ((atPS1479uszrPS9435)((&((global)->blocks)), ((usize)(0llu)))), (&((this)->global))));
    return (true);
}
none generateLLVMFunctionHeaderPS4053PS7132rN(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    LLVMValue_s llvmFunc = ((LLVMValue_s){0});
    ParsedFuncDecl_s *function = ((getFuncNodePS7132rPS4904)((irFunc)));
    LLVMType_s llvmFuncType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), ((getTypePU9661rPU5175)((&((function)->typeState))))));
    LLVMValue_s llvmFuncValue = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&((irFunc)->name)))), (llvmFuncType)));
    if ((hasAttributePS7132U4360rB)((irFunc), (((ParsedAttribute_u){.tag = 3, .payload = {0}})))) {
        u32 id = (((LLVMGetEnumAttributeKindForName))(("noreturn"), ((usize)(8llu))));
        ((assertBPcrN)(((id) != ((u32)(0))), ("Could not get noreturn attribute from LLVM")));
        ((addAttributePS8925u32S6660rN)((&(llvmFuncValue)), (U32_MAX), ((createEnumAttributePS0773u32u64rS6660)((&((this)->llvmContext)), (id), ((u64)(1llu))))));
    }

    if ((hasAttributePS7132U4360rB)((irFunc), (((ParsedAttribute_u){.tag = 4, .payload = {0}})))) {
        u32 id = (((LLVMGetEnumAttributeKindForName))(("naked"), ((usize)(5llu))));
        ((assertBPcrN)(((id) != ((u32)(0))), ("Could not get naked attribute from LLVM")));
        ((addAttributePS8925u32S6660rN)((&(llvmFuncValue)), (U32_MAX), ((createEnumAttributePS0773u32u64rS6660)((&((this)->llvmContext)), (id), ((u64)(1llu))))));
    }

    if (*((flags).debug)) {
        ParsedFile_s *file = ((getParentFilePS4904rPS1892)((function)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((function)->span)), (&(line)), (&(col))));
        SubStr_s linkage = ((asSubStrPS0540rS7720)((&((irFunc)->name))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diUnit = (((file)->debugInfo).diUnit);
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("DebugInfo File is null")));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("DebugInfo Unit is null")));
        LLVMMetadata_s sp =
            ((createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777)(((this)->llvmDIBuilder), (diUnit), (((function)->name).content), (linkage), (diFile), ((u32)((line))),
                                                                                          ((createSubroutineTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile),
                                                                                                                                        ((getTypePU9661rPU5175)((&((function)->typeState)))))),
                                                                                          ((newLLVMBoolBrS2924)((false))), ((newLLVMBoolBrS2924)((!((isExternPS4904rB)((function)))))), ((u32)((line))),
                                                                                          (LLVMDIFlagPrototyped), ((newLLVMBoolBrS2924)((*((flags).opt))))));
        ((setSubprogramS8925S5777rN)((llvmFuncValue), (sp)));
    }

    (((irFunc)->llvmFunc) = (llvmFuncValue));
    IRFunc_s *origFunc = ((getPS2612PS0540rPS7132)((&(((this)->irGen)->functions)), (&((irFunc)->name))));
    (((origFunc)->llvmFunc) = (llvmFuncValue));
}
LLVMType_s prepareReturnTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        return ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
    }

    else {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
    }
}
LLVMType_s prepareParameterPS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        return ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
    }

    else if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), ((intoPointerPU5175rPU5175)((typ)))));
    }

    else {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
    }
}
usize getLLVMTypeSizePS4053PS0706rusz(LLVMCodegen_s *this, LLVMType_s *typ) {
    LLVMTargetData_s data = ((getTargetDataPS7964rS8369)((&((this)->llvmTargetMachine))));
    usize s1 = ((getStoreSizePS8369PS0706rusz)((&(data)), (typ)));
    usize s2 = ((getABISizePS8369PS0706rusz)((&(data)), (typ)));
    usize s3 = (((getBitSizePS8369PS0706rusz)((&(data)), (typ))) / ((usize)(8llu)));
    ((assertBPcrN)(((((s1) == (s2)) && ((s1) == (s3))) && ((s2) == (s3))), ("LLVMTargetData returned different type sizes")));
    return (s1);
}
bool _generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    LLVMValue_s llvmFuncValue = ((irFunc)->llvmFunc);
    ((assertBrN)((!(((LLVM_isNullS1407rB))(((llvmFuncValue).ref))))));
    LLVMBasicBlockList_s blocks = ((LLVMBasicBlockList_s){0});
    ((initBlankPS0409uszrN)((&(blocks)), (((irFunc)->blocks).length)));
    ((assertBPcrN)((((blocks).length) != ((usize)(0llu))), ("Every IRFunc has at least one instruction")));
    ((*((atPS0409uszrPS7469)((&(blocks)), ((usize)(0llu))))) = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (llvmFuncValue), ((newSubStrOfStrLitPcrS7720)(("entry"))))));
    for (usize i = ((usize)(1llu)); ((i) < (((irFunc)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS0409uszrPS7469)((&(blocks)), (i)))) = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (llvmFuncValue), ((newSubStrOfStrLitPcrS7720)(("b"))))));
    }

    RegValueList_s regs = ((RegValueList_s){0});
    ((initBlankPS5884uszrN)((&(regs)), (((irFunc)->registers).length)));
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((irFunc)));
    ((pushRegisterStackPS3154S8951uszrN)(((this)->interp), ((irFunc)->span), (funcSize)));
    if (*((flags).debug))
        ((resetCurrentDebugLocationS1476S6343rN)(((this)->llvmDIBuilder), ((this)->llvmBuilder)));
    for (usize i = ((usize)(0llu)); ((i) < (((irFunc)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRBlock_s *block = ((getBlockByIDPS7132S7192rPS9435)((irFunc), ((IRBlockID_s){.i = (i)})));
        ((positionAtEndPS6343S7469rN)((&((this)->llvmBuilder)), (*((atPS0409uszrPS7469)((&(blocks)), (i))))));
        ((generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN)((this), (&(llvmFuncValue)), (irFunc), (&(blocks)), (block), (&(regs))));
    }

    ((popRegisterStackPS3154S8951uszrN)(((this)->interp), ((irFunc)->span), (funcSize)));
    return (true);
}
bool generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    if ((isExternPS7132rB)((irFunc)))
        return (true);
    return ((_generateFunctionPS4053PS7132rB)((this), (irFunc)));
}
none generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *llvmBlocks, IRBlock_s *block, RegValueList_s *regs) {
    for (usize i = ((usize)(0llu)); ((i) < (((block)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRInstr_s *instr = ((atPS0124uszrPS7680)((&((block)->instructions)), (i)));
        if (*((flags).debug)) {
            bool isGlobal = (((LLVM_isNullS1407rB))(((llvmFunc)->ref)));
            if (!(isGlobal)) {
                ((setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN)(((this)->llvmDIBuilder), ((this)->llvmBuilder), ((this)->llvmContext), (*(llvmFunc)), (irFunc), ((instr)->span)));
            }
        }

        if (((instr)->kind) == (INSTR_ALLOCA)) {
            if (!((instr)->isComptime)) {
                LLVMValue_s llvm = ((generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925)((this), (llvmFunc), (irFunc), (llvmBlocks), (instr), (regs)));
                ((addLLVMValuePU5952S8925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (llvm)));
            }

            InterpReg_s interp = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)(((this)->interp), (irFunc), (instr), (regs), (true)));
            ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (interp)));
        }

        else if ((instr)->isComptime) {
            InterpReg_s val = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)(((this)->interp), (irFunc), (instr), (regs), (false)));
            if (!((isTerminatorPS7680rB)((instr))))
                ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (val)));
        }

        else {
            LLVMValue_s val = ((generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925)((this), (llvmFunc), (irFunc), (llvmBlocks), (instr), (regs)));
            if (!((isTerminatorPS7680rB)((instr))))
                ((addLLVMValuePU5952S8925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (val)));
        }
    }
}
LLVMValue_s generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *blocks, IRInstr_s *instr,
                                                                        RegValueList_s *regs) {
    bool isGlobal = (((LLVM_isNullS1407rB))(((llvmFunc)->ref)));
    if (((instr)->kind) == (INSTR_DEBUG_INFO_PARAM)) {
        ((assertBrN)((*((flags).debug))));
        ((assertBrN)((!(isGlobal))));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMValue_s dstLLVM = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM DebugInfo Param")));
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (((instr)->span).file)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((instr)->span)), (&(line)), (&(col))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM DebugInfo Param non-ptr")));
        LLVMMetadata_s mt = ((createTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)))));
        char *start = ((char *)(((shiftRightuszuszrusz)((((instr)->src).i), (PARAM_SHIFT)))));
        usize index = ((((instr)->src).i) % ((shiftLeftuszuszrusz)(((usize)(1llu)), (PARAM_SHIFT))));
        LLVMMetadata_s scope = ((getSubprogramS8925rS5777)((*(llvmFunc))));
        LLVMMetadata_s meta = ((
            createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777)(((this)->llvmDIBuilder), (scope), ((newSubStrPcuszuszrS7720)((start), ((usize)(0llu)), (((instr)->op1).i))),
                                                                                  (((u32)((index))) + ((u32)(1))), (diFile), ((u32)((line))), (mt), ((newLLVMBoolBrS2924)((true))), (LLVMDIFlagZero)));
        LLVMMetadata_s expr = ((createExpressionS1476PuszuszrS5777)(((this)->llvmDIBuilder), (NULL), ((usize)(0llu))));
        LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)(((this)->llvmContext), ((u32)((line))), ((u32)((col))), (scope)));
        ((insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276)(((this)->llvmDIBuilder), (dstLLVM), (meta), (expr), (loc), ((getInsertBlockPS6343rS7469)((&((this)->llvmBuilder))))));
        return (dstLLVM);
    }

    else if (((instr)->kind) == (INSTR_DEBUG_INFO_ALLOCA)) {
        ((assertBrN)((*((flags).debug))));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMValue_s dstLLVM = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM DebugInfo Alloca")));
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (((instr)->span).file)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((instr)->span)), (&(line)), (&(col))));
        LLVMMetadata_s expr = ((createExpressionS1476PuszuszrS5777)(((this)->llvmDIBuilder), (NULL), ((usize)(0llu))));
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM DebugInfo Alloca non-ptr")));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s mt = ((createTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)))));
        if (isGlobal) {
            LLVMMetadata_s meta = ((LLVMMetadata_s){
                .ref = (((LLVMDIBuilderCreateGlobalVariableExpression))((((this)->llvmDIBuilder).ref), ((((file)->debugInfo).diUnit).ref), ((char *)((((instr)->src).i))), (((instr)->op1).i),
                                                                        ((char *)((((instr)->src).i))), (((instr)->op1).i), ((diFile).ref), ((u32)((line))), ((mt).ref), ((newLLVMBoolBrS2924)((true))),
                                                                        ((expr).ref), ((LLVM_MetadataRef_s){0}), ((u32)(((getAlignmentInBitsPU5175rusz)(((reg)->typ)))))))});
            ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((meta).ref)))), ("Could not create global variable expression")));
            (((LLVMGlobalSetMetadata))(((dstLLVM).ref), ((u32)(0)), ((meta).ref)));
            return (dstLLVM);
        }

        LLVMMetadata_s scope = ((getSubprogramS8925rS5777)((*(llvmFunc))));
        LLVMMetadata_s meta =
            ((createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777)(((this)->llvmDIBuilder), (scope), ((SubStr_s){.start = ((char *)((((instr)->src).i))), .len = (((instr)->op1).i)}),
                                                                               (diFile), ((u32)((line))), (mt), ((newLLVMBoolBrS2924)((true))), (LLVMDIFlagZero),
                                                                               ((u32)(((getAlignmentInBitsPU5175rusz)(((reg)->typ)))))));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((meta).ref)))), ("Could not get scope for DebugInfo-Alloca")));
        LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)(((this)->llvmContext), ((u32)((line))), ((u32)((col))), (scope)));
        ((insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276)(((this)->llvmDIBuilder), (dstLLVM), (meta), (expr), (loc), ((getInsertBlockPS6343rS7469)((&((this)->llvmBuilder))))));
        return (dstLLVM);
    }

    else if (((instr)->kind) == (INSTR_ALLOCA)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM Alloca expected ptr dst")));
        Type_u *t = ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
        if (isGlobal) {
            return ((addGlobalPS1718S0706u32S7720rS8925)((&((this)->llvmModule)), (typ), ((u32)(0)), ((newSubStrOfStrLitPcrS7720)(("g")))));
        }

        else {
            return ((buildAllocaPS6343S0706S7720rS8925)((&((this)->llvmBuilder)), (typ), ((newSubStrOfStrLitPcrS7720)(("v")))));
        }

    }

    else if (((instr)->kind) == (INSTR_GET_PARAM)) {
        ((assertBrN)((!(isGlobal))));
        LLVMValue_s param = ((getNthParamPS8925uszrS8925)((llvmFunc), (((instr)->src).i)));
        ((setNamePS8925S7720rN)((&(param)), ((newSubStrOfStrLitPcrS7720)(("p")))));
        return (param);
    }

    else if (((instr)->kind) == (INSTR_STORE)) {
        LLVMValue_s dstVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM Store dst")));
        LLVMValue_s srcVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Store src")));
        if (isGlobal) {
            ((setInitializerPS8925S8925rN)((&(dstVal)), (srcVal)));
        }

        else {
            ((buildStorePS6343S8925S8925rS8925)((&((this)->llvmBuilder)), (dstVal), (srcVal)));
        }

        return (dstVal);
    }

    else if (((instr)->kind) == (INSTR_LOAD_FUNCTION_PTR)) {
        IRFunc_s *called = ((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (((instr)->src).i)));
        return ((called)->llvmFunc);
    }

    else if (((instr)->kind) == (INSTR_LOAD)) {
        Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
        LLVMType_s dstTyp = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
        if ((isLLVMPU5952rB)((reg))) {
            LLVMValue_s srcVal = ((asLLVMPU5952PcrS8925)((reg), ("LLVM Load")));
            if (isGlobal) {
                return ((getInitializerPS8925rS8925)((&(srcVal))));
            }

            else {
                return ((buildLoadPS6343S0706S8925S7720rS8925)((&((this)->llvmBuilder)), (dstTyp), (srcVal), ((newSubStrOfStrLitPcrS7720)(("load")))));
            }

        }

        else {
            InterpReg_s tmp_24898 = ((asInterpPU5952PcrS9925)((reg), ("LLVM Load from comptime")));

            u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (&tmp_24898)));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), ((u8 *)((*((usize *)((start))))))));
        }

    }

    else if (((instr)->kind) == (INSTR_MOVE)) {
        return ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Move")));
    }

    else if (((instr)->kind) == (INSTR_FETCH_GLOBAL_PTR)) {
        RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
        if ((isLLVMPU5952rB)((val))) {
            return ((asLLVMPU5952PcrS8925)((val), ("We just checked if it is LLVM")));
        }

        else {
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            return ((generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925)((this), (typ), (reg)));
        }

    }

    else if (((instr)->kind) == (INSTR_FETCH_GLOBAL_VALUE)) {
        RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
        Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
        ((assertBPcrN)(((isLLVMPU5952rB)((val))), ("FetchGlobalValue got non-LLVM src")));
        LLVMType_s dstTyp = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
        LLVMValue_s reg = ((asLLVMPU5952PcrS8925)((val), ("We just checked if it is LLVM")));
        return ((buildLoadPS6343S0706S8925S7720rS8925)((&((this)->llvmBuilder)), (dstTyp), (reg), ((newSubStrOfStrLitPcrS7720)(("fetchglobalval")))));
    }

    else if (((instr)->kind) == (INSTR_FETCH_COMPTIME_VALUE)) {
        if ((((instr)->op1).i) == ((usize)(1llu))) {
            RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            ((assertBPcrN)((!((isLLVMPU5952rB)((val)))), ("FetchComptimeValue global=1 got non-Interp src")));
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            u8 *start = ((getGlobalPointerPS3154PS9925rPu8)(((this)->interp), (&(reg))));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), (start)));
        }

        else {
            RegValue_u *val = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            ((assertBPcrN)((!((isLLVMPU5952rB)((val)))), ("FetchComptimeValue global=0 got non-Interp src")));
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            u8 *start = ((getComptimePointerPS4053PS9925rPu8)((this), (&(reg))));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), (start)));
        }

    }

    else if (((instr)->kind) == (INSTR_INT_ADD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM AddInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM AddInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntAddPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("iadd")))));
    }

    else if (((instr)->kind) == (INSTR_INT_SUB)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM SubInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM SubInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntSubPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("isub")))));
    }

    else if (((instr)->kind) == (INSTR_INT_MUL)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM MulInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM MulInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntMulPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("imul")))));
    }

    else if (((instr)->kind) == (INSTR_INT_DIV)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM DivInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM DivInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntDivPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("idiv")))));
    }

    else if (((instr)->kind) == (INSTR_INT_MOD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ModInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ModInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntModPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("imod")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_ADD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM AddFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM AddFloat")));
        return ((buildFloatAddPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fadd")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_SUB)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM SubFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM SubFloat")));
        return ((buildFloatSubPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fsub")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_MUL)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM MulFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM MulFloat")));
        return ((buildFloatMulPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fmul")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_DIV)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM DivFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM DivFloat")));
        return ((buildFloatDivPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fdiv")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_MOD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ModFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ModFloat")));
        return ((buildFloatModPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fmod")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_NEQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpNeq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpNeq")));
        return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntNE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpne")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_EQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpEq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpEq")));
        return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntEQ), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpeq")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_LT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpLt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpLt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSLT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpslt")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntULT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpult")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_LTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpLte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpLte")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSLE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsle")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntULE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpule")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_GT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpGt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpGt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsgt")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntUGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpugt")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_GTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpGte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpGte")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsge")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntUGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpuge")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_NEQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpNeq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpNeq")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUNE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpne")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_EQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpEq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpEq")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUEQ), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpeq")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_LT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpLt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpLt")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealULT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpult")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_LTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpLte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpLte")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealULE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpule")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_GT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpGt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpGt")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpugt")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_GTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpGte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpGte")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpuge")))));
    }

    else if (((instr)->kind) == (INSTR_LOGICAL_NOT)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical Not")));
        return ((buildNotPS6343S8925S7720rS8925)((&((this)->llvmBuilder)), (val), ((newSubStrOfStrLitPcrS7720)(("lnot")))));
    }

    else if ((((instr)->kind) == (INSTR_LOGICAL_OR)) || (((instr)->kind) == (INSTR_BITWISE_OR))) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical Or")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Logical Or")));
        return ((buildOrPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("lor")))));
    }

    else if ((((instr)->kind) == (INSTR_LOGICAL_AND)) || (((instr)->kind) == (INSTR_BITWISE_AND))) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical And")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Logical And")));
        return ((buildAndPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("land")))));
    }

    else if (((instr)->kind) == (INSTR_BITWISE_XOR)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Bitwise Xor")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Bitwise Xor")));
        return ((buildXorPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("bxor")))));
    }

    else if (((instr)->kind) == (INSTR_CALL)) {
        LLVMValue_s calledFunc = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Call")));
        ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((calledFunc).ref)))), ("Call tried to call invalid LLVMValue")));
        LLVMValueList_s args = ((LLVMValueList_s){0});
        ((initBlankPS8201uszrN)((&(args)), (((instr)->args).length)));
        for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            RegIndex_s *_a = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
            IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), (*(_a))));
            RegValue_u *argReg = ((atPS5884uszrPU5952)((regs), ((_a)->i)));
            ((*((atPS8201uszrPS8925)((&(args)), (i)))) = ((asLLVMPU5952PcrS8925)((argReg), ("LLVM Call Arg"))));
        }

        IRReg_s *base = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *bt = ((base)->typ);
        if ((isPointerPU5175rB)((bt)))
            ((bt) = ((getUnderlyingTypePU5175BrPU5175)((bt), (true))));
        ((assertBPcrN)(((isFunctionPU5175rB)((bt))), ("Call tried to call non-function base")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s retType = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        LLVMType_s fnType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), (bt)));
        return ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (calledFunc), (fnType), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("call")))));
    }

    else if (((instr)->kind) == (INSTR_COND_BR)) {
        LLVMValue_s cond = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM CondBr")));
        ((buildCondBrPS6343S8925S7469S7469rS8925)((&((this)->llvmBuilder)), (cond), (*((atPS0409uszrPS7469)((blocks), (((instr)->dst).i)))), (*((atPS0409uszrPS7469)((blocks), (((instr)->op1).i))))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_UNREACHABLE)) {
        ((buildUnreachablePS6343rN)((&((this)->llvmBuilder))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_UNTERMINATED)) {
        (((fprintf))((stderr_), ("%s %s: UNTERMINATED BLOCK FOUND!!!\n"), (((toStringPS8951rS0540)((&((instr)->span)))).buffer), (FATAL_STR)));
        ((unreachablePcrN)(("LLVM: Received INSTR_UNTERMINATED, Control Flow Analysis should\'ve caught this!")));
    }

    else if (((instr)->kind) == (INSTR_BR)) {
        ((buildBrPS6343S7469rS8925)((&((this)->llvmBuilder)), (*((atPS0409uszrPS7469)((blocks), (((instr)->dst).i))))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_RETURN_EXPR)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM RetExpr")));
        ((buildReturnPS6343S8925rN)((&((this)->llvmBuilder)), (val)));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_RETURN_VOID)) {
        ((buildReturnVoidPS6343rN)((&((this)->llvmBuilder))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_LOAD_I8)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U8)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I16)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U16)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I32)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U32)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I64)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U64)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_F32)) {
        LLVMType_s t = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        return ((constFloatPS0706f64rS8925)((&(t)), ((f64)((*((f32 *)((&(((instr)->src).i)))))))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_F64)) {
        LLVMType_s t = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
        return ((constFloatPS0706f64rS8925)((&(t)), (*((f64 *)((&(((instr)->src).i)))))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_BOOL)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_NULL)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        LLVMType_s pt = ((intoPointerTypePS0706rS0706)((&(t))));
        return ((constZeroPS0706rS8925)((&(pt))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_BLANK)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_ARRAY)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        ((assertBPcrN)(((isArrayPU5175rB)(((reg)->typ))), ("LLVM Expected Array in INSTR_CREATE_ARRAY")));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_STRUCT)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_UNION)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_INSERT_VALUE)) {
        LLVMValue_s dstVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM InsertValue")));
        usize index = (((instr)->src).i);
        LLVMValue_s elemVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM InsertValue")));
        LLVMValue_s newVal = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (dstVal), (elemVal), ((u32)((index))), ("arr_elem")));
        return (newVal);
    }

    else if (((instr)->kind) == (INSTR_PTR_TO_INT)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM PtrToInt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((buildPtrToIntPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("p2i")))));
    }

    else if (((instr)->kind) == (INSTR_INT_TO_PTR)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntToPtr")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        LLVMType_s ptr = ((intoPointerTypePS0706rS0706)((&(typ))));
        return ((buildIntToPtrPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (ptr), ((newSubStrOfStrLitPcrS7720)(("i2p")))));
    }

    else if ((((instr)->kind) == (INSTR_INT_TO_F32)) || (((instr)->kind) == (INSTR_INT_TO_F64))) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntToF32 / IntToF64")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        bool signed_ = ((isSignedIntegerPU5175rB)(((reg)->typ)));
        LLVMType_s typ = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        if (((instr)->kind) == (INSTR_INT_TO_F64))
            ((typ) = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext)))));
        return ((buildIntToFloatPS6343S8925S0706BS7720rS8925)((&((this)->llvmBuilder)), (val), (typ), (signed_), ((newSubStrOfStrLitPcrS7720)(("i2f")))));
    }

    else if ((((instr)->kind) == (INSTR_F32_TO_INT)) || (((instr)->kind) == (INSTR_F64_TO_INT))) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F32ToInt / F64ToInt")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        bool signed_ = ((isSignedIntegerPU5175rB)(((reg)->typ)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((buildFloatToIntPS6343S8925S0706BS7720rS8925)((&((this)->llvmBuilder)), (val), (typ), (signed_), ((newSubStrOfStrLitPcrS7720)(("f2i")))));
    }

    else if (((instr)->kind) == (INSTR_F32_TO_F64)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F32ToF64")));
        LLVMType_s typ = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
        return ((buildFloatExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("f32tof64")))));
    }

    else if (((instr)->kind) == (INSTR_F64_TO_F32)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F64ToF32")));
        LLVMType_s typ = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        return ((buildFloatTruncatePS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("f64tof32")))));
    }

    else if (((instr)->kind) == (INSTR_INT_SIGN_EXTEND)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntSignExt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntSignExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("sext")))));
    }

    else if (((instr)->kind) == (INSTR_INT_ZERO_EXTEND)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntZeroExt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntZeroExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("zext")))));
    }

    else if (((instr)->kind) == (INSTR_INT_TRUNCATE)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntTrunc")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntTruncatePS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("trunc")))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_STRING)) {
        return ((buildGlobalStringPtrPS6343PcS7720rS8925)((&((this)->llvmBuilder)), ((char *)((((instr)->src).i))), ((newSubStrOfStrLitPcrS7720)(("str")))));
    }

    else if (((instr)->kind) == (INSTR_GET_ELEMENT_PTR)) {
        LLVMValueList_s indices = ((LLVMValueList_s){0});
        ((initBlankPS8201uszrN)((&(indices)), (((instr)->args).length)));
        for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            RegIndex_s *_a = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
            IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), (*(_a))));
            RegValue_u *argReg = ((atPS5884uszrPU5952)((regs), ((_a)->i)));
            ((*((atPS8201uszrPS8925)((&(indices)), (i)))) = ((asLLVMPU5952PcrS8925)((argReg), ("LLVM GEP Index"))));
        }

        LLVMValue_s aggr = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM GetElementPtr")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *ptr = ((reg)->typ);
        Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((ptr), (false)));
        return ((buildGEPPS6343S0706S8925S8201S7720rS8925)((&((this)->llvmBuilder)), ((generateLLVMTypePS4053PU5175rS0706)((this), (underlying))), (aggr), (indices),
                                                           ((newSubStrOfStrLitPcrS7720)(("gep")))));
    }

    else if (((instr)->kind) == (INSTR_GET_FIELD_PTR)) {
        LLVMValue_s aggr = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM GetFieldPtr")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *ptr = ((reg)->typ);
        ((assertBPcrN)(((isPointerPU5175rB)((ptr))), ("LLVM GetFieldPtr wants ptr reg")));
        LLVMType_s aggrType = ((getTypePS8925rS0706)((&(aggr))));
        ((assertBPcrN)(((isPointerPS0706rB)((&(aggrType)))), ("Expected Pointer to Struct in GetFieldPtr")));
        Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((ptr), (false)));
        ((assertBPcrN)(((((isVariadicTypePU5175rB)((underlying))) || ((isStructPU5175rB)((underlying)))) || ((isTuplePU5175rB)((underlying)))), ("LLVM GetFieldPtr wants ptr to struct")));
        return ((buildStructGEPPS6343S0706S8925uszS7720rS8925)((&((this)->llvmBuilder)), ((generateLLVMTypePS4053PU5175rS0706)((this), (underlying))), (aggr), (((instr)->op1).i),
                                                               ((newSubStrOfStrLitPcrS7720)(("field_ptr")))));
    }

    else if (((instr)->kind) == (INSTR_MEMCPY)) {
        LLVMValue_s src = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Memcpy src")));
        LLVMValue_s dst = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM Memcpy dst")));
        LLVMValue_s size = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Memcpy op1")));
        ((buildMemcpyPS6343S8925u32S8925u32S8925rS8925)((&((this)->llvmBuilder)), (dst), ((u32)(1)), (src), ((u32)(1)), (size)));
        return (dst);
    }

    else if (((instr)->kind) == (INSTR_EMIT_ASSEMBLY)) {
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
        InterpReg_s tmp_27554 = ((asInterpPU5952PcrS9925)((reg), ("LLVM EmitAsm src")));

        u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (&tmp_27554)));
        Type_u *fnType = ((Type_u *)((((instr)->op1).i)));
        ASMContext_s *context = ((ASMContext_s *)((start)));
        LLVMType_s retType = ((generateTypeFromASMPS4053PS6859rS0706)((this), (context)));
        LLVMValueList_s args = ((collectValuesFromASMPS4053PS6859rS8201)((this), (context)));
        LLVMTypeList_s params = ((LLVMTypeList_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushPS4318S0706rN)((&(params)), ((getTypePS8925rS0706)((&((((args).elements))[(i)]))))));
        }

        LLVMType_s asmFn = ((intoFunctionTypePS0706S4318BrS0706)((&(retType)), (params), (false)));
        LLVMValue_s asmCall = ((getInlineAsmPS0706PS6859rS8925)((&(asmFn)), (context)));
        return ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (asmCall), (asmFn), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("asm")))));
    }

    else {
        (((printf))(("LLVM %llu\n"), ((instr)->kind)));
        ((todo_with_msgPcrN)(("unknown llvm kind")));
    }
}
LLVMValueList_s collectValuesFromASMPS4053PS6859rS8201(LLVMCodegen_s *this, ASMContext_s *context) {
    LLVMValueList_s list = ((LLVMValueList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((context)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8201S8925rN)((&(list)), ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), (i)))))));
    }

    return (list);
}
LLVMType_s generateTypeFromASMPS4053PS6859rS0706(LLVMCodegen_s *this, ASMContext_s *context) {
    if ((((context)->out).length) == ((usize)(0llu)))
        return ((createVoidTypePS0773rS0706)((&((this)->llvmContext))));
    if ((((context)->out).length) == ((usize)(1llu))) {
        LLVMValue_s arg = ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), ((usize)(0llu))))));
        return ((getTypePS8925rS0706)((&(arg))));
    }

    LLVMType_s *fields = (((calloc))((((context)->out).length), (sizeof(LLVMType_s))));
    ((assertBrN)(((fields) != (NULL))));
    for (usize i = ((usize)(0llu)); ((i) < (((context)->out).length)); ((i) = ((i) + ((usize)(1llu))))) {
        LLVMValue_s arg = ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), (i)))));
        ((((fields))[(i)]) = ((getTypePS8925rS0706)((&(arg)))));
    }

    LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)((((context)->out).length))), (false)));
    (((free))((fields)));
    return (t);
}
u8 *getComptimePointerPS4053PS9925rPu8(LLVMCodegen_s *this, InterpReg_s *reg) {
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (reg)));
    ((assertBPcrN)(((start) >= (((this)->interp)->regStackStart)), ("Expected comptime value to be allocated on Interp Reg Stack")));
    ((assertBPcrN)(((start) < ((u8 *)((unsigned char *)(((this)->interp)->regStackStart) + (REG_STACK_SIZE)))), ("Expected comptime value to be allocated on Interp Reg Stack")));
    return (start);
}
LLVMValue_s generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925(LLVMCodegen_s *this, Type_u *typ, InterpReg_s reg) {
    ((assertBPcrN)(((isPointerPU5175rB)((typ))), ("generateLLVMValueFromComptimePtr expected Pointer")));
    ((assertBPcrN)((((reg).size) == ((usize)(8llu))), ("generateLLVMValueFromComptimePtr expected Pointer sized register")));
    Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((typ), (false)));
    u8 *start = ((getComptimePointerPS4053PS9925rPu8)((this), (&(reg))));
    LLVMValue_s val = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (underlying), (start)));
    LLVMType_s _underlying = ((generateLLVMTypePS4053PU5175rS0706)((this), ((getUnderlyingTypePU5175BrPU5175)((typ), (false)))));
    LLVMValue_s alloc = ((buildAllocaPS6343S0706S7720rS8925)((&((this)->llvmBuilder)), (_underlying), ((newSubStrOfStrLitPcrS7720)(("comptimeToLLVM")))));
    ((buildStorePS6343S8925S8925rS8925)((&((this)->llvmBuilder)), (alloc), (val)));
    return (alloc);
}
LLVMValue_s generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925(LLVMCodegen_s *this, Type_u *typ, u8 *start) {
    ((assertBPcrN)(((start) != (NULL)), ("generateLLVMValueFromComptimeValue got nullptr")));
    usize size = ((getSizeInBytesPU5175rusz)((typ)));
    bool succ_3570_ = true;
    bool succ_3600_ = true;
    bool succ_3621_ = true;
    bool succ_3637_ = true;
    bool succ_3650_ = true;
    bool succ_3660_ = true;
    bool succ_3657_ = true;
    bool succ_3655_ = true;

    Type_u *tmp_5551_ = (typ);
    {
        succ_3570_ &= (tmp_5551_->tag == 3);
        PrimType_u *prim = &tmp_5551_->payload.variant3._0;
        succ_3570_ &= true;
        if (succ_3570_) {
            {
                if ((isIntegerPU5175rB)((typ))) {
                    if ((size) == ((usize)(1llu))) {
                        u8 val = (*((u8 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(2llu))) {
                        u16 val = (*((u16 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(4llu))) {
                        u32 val = (*((u32 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(8llu))) {
                        u64 val = (*((u64 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else {
                        ((unreachablePcrN)(("unexpected int size")));
                    }

                }

                else if ((isFloatPU5175rB)((typ))) {
                    if ((size) == ((usize)(4llu))) {
                        f32 val = (*((f32 *)((start))));
                        LLVMType_s t = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
                        return ((constFloatPS0706f64rS8925)((&(t)), ((f64)((val)))));
                    }

                    else if ((size) == ((usize)(8llu))) {
                        f64 val = (*((f64 *)((start))));
                        LLVMType_s t = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
                        return ((constFloatPS0706f64rS8925)((&(t)), (val)));
                    }

                    else {
                        ((unreachablePcrN)(("unexpected float size")));
                    }

                }

                else if ((isBooleanPU5175rB)((typ))) {
                    u8 val = (*((u8 *)((start))));
                    ((assertBPcrN)((((val) == ((u8)(0))) || ((val) == ((u8)(1)))), ("comptime bool is not 0 or 1")));
                    LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
                    return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                }

                else if ((isNonePU5175rB)((typ))) {
                    LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
                    return ((constIntPS0706uszBrS8925)((&(t)), ((usize)(1llu)), (false)));
                }

                else {
                    ((todo_with_msgPcrN)(("prim")));
                }
            }
            goto after_5551;
        }
    }
    {
        succ_3600_ &= (tmp_5551_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_5551_->payload.variant7._0;
        succ_3600_ &= true;
        if (succ_3600_) {
            {
                LLVMType_s lType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                ((assertBPcrN)(((isStructPS0706rB)((&(lType)))), ("Expected LLVMType to be struct for comptime struct")));
                LLVMValue_s strukt = ((constZeroPS0706rS8925)((&(lType))));
                usize offset = ((usize)(0llu));
                usize _size = ((usize)(0llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *tDecl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    Type_u *fType = ((getTypePU9661rPU5175)((&((tDecl)->typeState))));
                    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (i), (&(offset)), (&(_size)), (false)));
                    LLVMValue_s elemVal = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (fType), ((u8 *)((unsigned char *)(start) + (offset)))));
                    ((strukt) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (strukt), (elemVal), ((u32)((i))), ("comptime_struct_field"))));
                }

                return (strukt);
            }
            goto after_5551;
        }
    }
    {
        succ_3621_ &= (tmp_5551_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_5551_->payload.variant8._0;
        succ_3621_ &= true;
        usize *variant = &tmp_5551_->payload.variant8._1;
        succ_3621_ &= true;
        if (succ_3621_) {
            {
                LLVMType_s lType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                ((assertBPcrN)(((isStructPS0706rB)((&(lType)))), ("Expected LLVMType to be struct for comptime union")));
                LLVMValue_s union_ = ((constZeroPS0706rS8925)((&(lType))));
                if ((size) == ((usize)(0llu))) {
                    return (union_);
                }

                PrimType_u smol = (((PrimType_u){.tag = 0}));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((smol) = (((PrimType_u){.tag = 1})));
                Type_u *byte = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
                {
                    LLVMValue_s tag = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (byte), (start)));
                    ((union_) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (union_), (tag), ((u32)(0)), ("comptime_union_tag"))));
                }

                {
                    usize dataSize = ((size) - ((usize)(1llu)));
                    u8 *offset = ((u8 *)((unsigned char *)(start) + ((usize)(1llu))));
                    if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                        ((dataSize) = ((size) - ((usize)(2llu))));
                        ((offset) = ((u8 *)((unsigned char *)(start) + ((usize)(2llu)))));
                    }

                    Type_u *byt = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})));
                    LLVMValue_s data =
                        ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (byt), ._1 = (dataSize)}}}))),
                                                                                   (offset)));
                    ((union_) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (union_), (data), ((u32)(1)), ("comptime_union_tag"))));
                }

                return (union_);
            }
            goto after_5551;
        }
    }
    {
        succ_3637_ &= (tmp_5551_->tag == 5);
        Type_u **elemType = &tmp_5551_->payload.variant5._0;
        succ_3637_ &= true;
        usize *size = &tmp_5551_->payload.variant5._1;
        succ_3637_ &= true;
        if (succ_3637_) {
            {
                LLVMType_s llvmType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                usize elemSize = ((getSizeInBytesPU5175rusz)((*elemType)));
                LLVMValue_s array = ((constZeroPS0706rS8925)((&(llvmType))));
                for (usize i = ((usize)(0llu)); ((i) < (*size)); ((i) = ((i) + ((usize)(1llu))))) {
                    usize offset = ((elemSize) * (i));
                    LLVMValue_s elem = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (*elemType), ((u8 *)((unsigned char *)(start) + (offset)))));
                    ((array) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (array), (elem), ((u32)((i))), ("comptime_array_elem"))));
                }

                return (array);
            }
            goto after_5551;
        }
    }
    {
        succ_3650_ &= (tmp_5551_->tag == 6);
        succ_3650_ &= true;
        succ_3650_ &= true;
        succ_3650_ &= true;
        if (succ_3650_) {
            {
                usize id = (*((usize *)((start))));
                return (((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (id)))->llvmFunc);
            }
            goto after_5551;
        }
    }
    {
        succ_3660_ &= (tmp_5551_->tag == 4);
        succ_3657_ &= (tmp_5551_->payload.variant4._0->tag == 3);
        succ_3655_ &= (tmp_5551_->payload.variant4._0->payload.variant3._0.tag == 12);
        succ_3657_ &= succ_3655_;
        succ_3660_ &= succ_3657_;
        if (succ_3660_) {
            {
                return ((buildGlobalStringPtrPS6343PcS7720rS8925)((&((this)->llvmBuilder)), ((char *)((*((usize *)((start)))))), ((newSubStrOfStrLitPcrS7720)(("comptime_str")))));
            }
            goto after_5551;
        }
    }
    {
        Type_u **typ = &tmp_5551_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((*typ))).buffer)));
                ((todo_with_msgPcrN)(("generateLLVMValueFromComptime")));
            }
            goto after_5551;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5551:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling in generateLLVMValueFromComptime")));
}
LLVMType_s generateLLVMFunctionTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    TypeList_s fnParams = ((TypeList_s){0});
    Type_u *retType = (NULL);
    bool isVarArg = (false);
    bool succ_3672_ = true;

    Type_u *tmp_5562_ = (typ);
    {
        succ_3672_ &= (tmp_5562_->tag == 6);
        TypeList_s *_params = &tmp_5562_->payload.variant6._0;
        succ_3672_ &= true;
        Type_u **_ret = &tmp_5562_->payload.variant6._1;
        succ_3672_ &= true;
        FuncAttr_s *attr = &tmp_5562_->payload.variant6._2;
        succ_3672_ &= true;
        if (succ_3672_) {
            {
                ((fnParams) = (*_params));
                ((retType) = (*_ret));
                ((isVarArg) = ((*attr).isVariadic));
            }
            goto after_5562;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("generateLLVMFunctionType called on non function")));
            }
            goto after_5562;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5562:
    (void)0; // error: label at end of compound statement is a C23 extension
    LLVMTypeList_s params = ((LLVMTypeList_s){0});
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        ((retType) = ((intoPointerPU5175rPU5175)((retType))));
        ((pushPS4318S0706rN)((&(params)), ((prepareParameterPS4053PU5175rS0706)((this), (retType)))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = (*((atPS0643uszrPPU5175)((&(fnParams)), (i))));
        ((pushPS4318S0706rN)((&(params)), ((prepareParameterPS4053PU5175rS0706)((this), (t)))));
    }

    LLVMType_s llvmType = ((prepareReturnTypePS4053PU5175rS0706)((this), (retType)));
    LLVMType_s llvmFuncType = ((intoFunctionTypePS0706S4318BrS0706)((&(llvmType)), (params), (isVarArg)));
    return (llvmFuncType);
}
LLVMType_s generateLLVMTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *type) {
    LLVMType_s typ = ((LLVMType_s){0});
    bool succ_3689_ = true;
    bool succ_3704_ = true;
    bool succ_3710_ = true;
    bool succ_3715_ = true;
    bool succ_3719_ = true;
    bool succ_3732_ = true;
    bool succ_3744_ = true;
    bool succ_3750_ = true;

    Type_u *tmp_5657_ = (type);
    {
        succ_3689_ &= (tmp_5657_->tag == 3);
        succ_3689_ &= true;
        if (succ_3689_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(((getSizeInBitsPU5175rusz)((type))))))));
                }

                else if ((isCharPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll)))));
                }

                else if ((isBooleanPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll)))));
                }

                else if ((isFloatPU5175rB)((type))) {
                    bool succ_3694_ = true;
                    bool succ_3692_ = true;
                    bool succ_3699_ = true;
                    bool succ_3697_ = true;

                    Type_u *tmp_5589_ = (type);
                    {
                        succ_3694_ &= (tmp_5589_->tag == 3);
                        succ_3692_ &= (tmp_5589_->payload.variant3._0.tag == 13);
                        succ_3694_ &= succ_3692_;
                        if (succ_3694_) {
                            {
                                ((typ) = ((createFloatTypePS0773rS0706)((&((this)->llvmContext)))));
                            }
                            goto after_5589;
                        }
                    }
                    {
                        succ_3699_ &= (tmp_5589_->tag == 3);
                        succ_3697_ &= (tmp_5589_->payload.variant3._0.tag == 14);
                        succ_3699_ &= succ_3697_;
                        if (succ_3699_) {
                            {
                                ((typ) = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext)))));
                            }
                            goto after_5589;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablePcrN)(("Expected TYPE_F32 or TYPE_F64")));
                            }
                            goto after_5589;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_5589:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }

                else if ((isNonePU5175rB)((type))) {
                    ((typ) = ((createVoidTypePS0773rS0706)((&((this)->llvmContext)))));
                }

                else if ((isAnyPU5175rB)((type))) {
                    LLVMType_s tmp_28453 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                    ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28453))));
                }

                else {
                    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((type))).buffer)));
                    ((todo_with_msgPcrN)(("generate primitive type")));
                }
            }
            goto after_5657;
        }
    }
    {
        succ_3704_ &= (tmp_5657_->tag == 4);
        succ_3704_ &= true;
        if (succ_3704_) {
            {
                LLVMType_s tmp_28479 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28479))));
            }
            goto after_5657;
        }
    }
    {
        succ_3710_ &= (tmp_5657_->tag == 6);
        succ_3710_ &= true;
        succ_3710_ &= true;
        succ_3710_ &= true;
        if (succ_3710_) {
            {
                LLVMType_s tmp_28491 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28491))));
            }
            goto after_5657;
        }
    }
    {
        succ_3715_ &= (tmp_5657_->tag == 5);
        Type_u **under = &tmp_5657_->payload.variant5._0;
        succ_3715_ &= true;
        usize *size = &tmp_5657_->payload.variant5._1;
        succ_3715_ &= true;
        if (succ_3715_) {
            {
                LLVMType_s tmp_28500 = ((generateLLVMTypePS4053PU5175rS0706)((this), (*under)));

                ((typ) = ((intoArrayTypePS0706u32rS0706)((&tmp_28500), ((u32)((*size))))));
            }
            goto after_5657;
        }
    }
    {
        succ_3719_ &= (tmp_5657_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_5657_->payload.variant7._0;
        succ_3719_ &= true;
        if (succ_3719_) {
            {
                LLVMType_s *fields = (((malloc))(((((*decl)->context).fieldLength) * (sizeof(LLVMType_s)))));
                ((assertBPcrN)(((fields) != (NULL)), ("Could not allocate memory in LLVMCodegen.generateLLVMType")));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *tDecl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((((fields))[(i)]) = ((generateLLVMTypePS4053PU5175rS0706)((this), ((getTypePU9661rPU5175)((&((tDecl)->typeState)))))));
                }

                LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)((((*decl)->context).fieldLength))), (false)));
                (((free))((fields)));
                ((typ) = (t));
            }
            goto after_5657;
        }
    }
    {
        succ_3732_ &= (tmp_5657_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_5657_->payload.variant8._0;
        succ_3732_ &= true;
        succ_3732_ &= true;
        if (succ_3732_) {
            {
                u32 size = ((u32)(((getSizeInBytesPU5175rusz)((type)))));
                if ((size) == ((u32)(0))) {
                    ((assertBPcrN)(((((*decl)->variants).length) == ((usize)(0llu))), ("LLVM: Union has size 0, but contains variants")));
                    ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (NULL), ((u32)(0)), (false))));
                }

                else {
                    PrimType_u smol = (((PrimType_u){.tag = 0}));
                    u32 offset = ((u32)(1));
                    if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                        ((smol) = (((PrimType_u){.tag = 1})));
                        ((offset) = ((u32)(2)));
                    }

                    LLVMType_s tag = ((generateLLVMTypePS4053PU5175rS0706)((this), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})))));
                    LLVMType_s data = ((intoArrayTypePS0706u32rS0706)((&(tag)), ((size) - (offset))));
                    array_27633 fields = ((array_27633){(tag), (data)});
                    ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (&(((fields).arr)[((usize)(0llu))])), ((u32)(2)), (false))));
                }
            }
            goto after_5657;
        }
    }
    {
        succ_3744_ &= (tmp_5657_->tag == 2);
        succ_3744_ &= true;
        if (succ_3744_) {
            {
                LLVMType_s *fields = (((calloc))(((usize)(2llu)), (sizeof(LLVMType_s))));
                ((assertBrN)(((fields) != (NULL))));
                LLVMType_s tmp_28680 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((((fields))[((usize)(0llu))]) = ((intoPointerTypePS0706rS0706)((&tmp_28680))));
                ((((fields))[((usize)(1llu))]) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll)))));
                ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)(2)), (false))));
            }
            goto after_5657;
        }
    }
    {
        succ_3750_ &= (tmp_5657_->tag == 10);
        TypeList_s *elems = &tmp_5657_->payload.variant10._0;
        succ_3750_ &= true;
        if (succ_3750_) {
            {
                LLVMType_s *fields = (((malloc))((((*elems).length) * (sizeof(LLVMType_s)))));
                ((assertBPcrN)(((fields) != (NULL)), ("Could not allocate memory in LLVMCodegen.generateLLVMType")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((((fields))[(i)]) = ((generateLLVMTypePS4053PU5175rS0706)((this), ((((*elems).elements))[(i)]))));
                }

                LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)(((*elems).length))), (false)));
                (((free))((fields)));
                ((typ) = (t));
            }
            goto after_5657;
        }
    }
    {
        if (true) {
            {
                ((todo_with_msgPcrN)(("generate llvm type")));
            }
            goto after_5657;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5657:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (typ);
}
LLVMCodegen_s newLLVMCodegenS7720PS9562PS3154rS4053(SubStr_s name, IRGen_s *irGen, IRInterp_s *interp) {
    LLVMContext_s llvmContext = ((newLLVMContextrS0773)());
    LLVMModule_s llvmModule = ((createModuleWithNamePS0773S7720rS1718)((&(llvmContext)), (name)));
    LLVMBuilder_s llvmBuilder = ((createBuilderPS0773rS6343)((&(llvmContext))));
    LLVMDIBuilder_s llvmDIBuilder = ((createDIBuilderS1718rS1476)((llvmModule)));
    ((initializeTargetsPS0773rN)((&(llvmContext))));
    LLVMTarget_s target = ((createTargetPS0773PcrS4231)((&(llvmContext)), ("x86-64")));
    char *triple = ((createTargetTriplePS0773PcrPc)((&(llvmContext)), ("x86-64")));
    LLVMTargetMachineOptions_s options = ((createTargetMachineOptionsrS6312)());
    ((setCPUS6312PcrN)((options), ("x86-64")));
    ((setCodeGenOptLevelS6312U5589rN)((options), (((LLVM_CodeGenOptLevel_u){.tag = 0}))));
    ((setRelocModeS6312U2415rN)((options), (((LLVM_RelocMode_u){.tag = 0}))));
    ((setCodeModelS6312U0545rN)((options), (((LLVM_CodeModel_u){.tag = 0}))));
    LLVMTargetMachine_s targetMachine = ((createTargetMachineWithOptionsS4231PcS6312rS7964)((target), (triple), (options)));
    ((disposeTargetMachineOptionsS6312rN)((options)));
    ((setTriplePS1718PcrN)((&(llvmModule)), (triple)));
    LLVMTargetData_s l = ((getTargetDataPS7964rS8369)((&(targetMachine))));
    ((setDataLayoutPS1718S7896rN)((&(llvmModule)), ((getDataLayoutPS8369rS7896)((&(l))))));
    {
        LLVMType_s u32 = ((createIntegerTypePS0773i64rS0706)((&(llvmContext)), ((i64)(32ll))));
        ((addModuleFlagS1718i32S7720S8925rN)((llvmModule), (LLVMModuleFlagBehaviorError), ((newSubStrOfStrLitPcrS7720)(("CodeView"))),
                                             ((constIntPS0706uszBrS8925)((&(u32)), ((usize)(1llu)), (false)))));
        ((addModuleFlagS1718i32S7720S8925rN)((llvmModule), (LLVMModuleFlagBehaviorWarning), ((newSubStrOfStrLitPcrS7720)(("Debug Info Version"))),
                                             ((constIntPS0706uszBrS8925)((&(u32)), ((usize)(3llu)), (false)))));
    }

    return ((LLVMCodegen_s){.llvmContext = (llvmContext),
                            .llvmModule = (llvmModule),
                            .llvmBuilder = (llvmBuilder),
                            .llvmTargetMachine = (targetMachine),
                            .llvmDIBuilder = (llvmDIBuilder),
                            .irGen = (irGen),
                            .interp = (interp),
                            .global = ((RegValueList_s){0})});
}
bool equalsPS6939PS6939rB(RegIndex_s *this, RegIndex_s *other) { return (((this)->i) == ((other)->i)); }
bool equalsPS1534PS1534rB(IRReg_s *this, IRReg_s *other) { ((unreachablePcrN)(("IRReg.equals is not implemented yet"))); }
bool equalsPS7680PS7680rB(IRInstr_s *this, IRInstr_s *other) { ((unreachablePcrN)(("IRInstr.equals is not implemented yet"))); }
bool isTerminatorPS7680rB(IRInstr_s *this) {
    return ((((((((this)->kind) == (INSTR_RETURN_EXPR)) || (((this)->kind) == (INSTR_RETURN_VOID))) || (((this)->kind) == (INSTR_COND_BR))) || (((this)->kind) == (INSTR_BR))) ||
             (((this)->kind) == (INSTR_UNREACHABLE))) ||
            (((this)->kind) == (INSTR_UNTERMINATED)));
}
none dumpPS7680rN(IRInstr_s *this) {
    if ((!(*((flags).emitBIR))) && ((this)->isComptime))
        (((printf))(("\x1B[92m")));
    if (*((flags).debug)) {
        String_s s = ((toStringPS8951rS0540)((&((this)->span))));
        (((printf))(("%s "), ((s).buffer)));
        ((dropPS0540rN)((&(s))));
    }

    if (((this)->kind) == (INSTR_ALLOCA))
        (((printf))(("r%llu = Alloca %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_GET_PARAM))
        (((printf))(("r%llu = GetParam %llu (%llu bytes)"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_STORE))
        (((printf))(("Store r%llu, r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_GLOBAL_PTR))
        (((printf))(("r%llu = FetchGlobalPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_GLOBAL_VALUE))
        (((printf))(("r%llu = FetchGlobalValue r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_COMPTIME_VALUE))
        (((printf))(("r%llu = FetchComptimeValue r%llu, global=%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOAD))
        (((printf))(("r%llu = Load r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_FUNCTION_PTR))
        (((printf))(("r%llu = LoadFunctionPtr %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_MOVE))
        (((printf))(("r%llu = Move r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_CALL)) {
        (((printf))(("r%llu = Call r%llu"), (((this)->dst).i), (((this)->src).i)));
        for (usize i = ((usize)(0llu)); ((i) < (((this)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            (((printf))((", r%llu"), (((atPS9911uszrPS6939)((&((this)->args)), (i)))->i)));
        }

    }

    else if (((this)->kind) == (INSTR_RETURN_EXPR))
        (((printf))(("RetExpr r%llu"), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_RETURN_VOID))
        (((printf))(("RetVoid")));
    else if (((this)->kind) == (INSTR_LOAD_STRING))
        (((printf))(("r%llu = LoadString %p, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOAD_BOOL))
        (((printf))(("r%llu = Load Bool %hhu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I8))
        (((printf))(("r%llu = Load I8 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U8))
        (((printf))(("r%llu = Load U8 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I16))
        (((printf))(("r%llu = Load I16 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U16))
        (((printf))(("r%llu = Load U16 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I32))
        (((printf))(("r%llu = Load I32 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U32))
        (((printf))(("r%llu = Load U32 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I64))
        (((printf))(("r%llu = Load I64 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U64))
        (((printf))(("r%llu = Load U64 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_NULL))
        (((printf))(("r%llu = Load Null"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_LOAD_F32))
        (((printf))(("r%llu = Load F32 %f"), (((this)->dst).i), ((f64)((*((f32 *)((&(((this)->src).i)))))))));
    else if (((this)->kind) == (INSTR_LOAD_F64))
        (((printf))(("r%llu = Load F64 %f"), (((this)->dst).i), (*((f64 *)((&(((this)->src).i)))))));
    else if (((this)->kind) == (INSTR_LOAD_BLANK))
        (((printf))(("r%llu = Load Blank"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_COND_BR))
        (((printf))(("CondBr r%llu, true=%llu, false=%llu"), (((this)->src).i), (((this)->dst).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BR))
        (((printf))(("Br %llu"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_INT_ADD))
        (((printf))(("r%llu = AddInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_SUB))
        (((printf))(("r%llu = SubInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_MUL))
        (((printf))(("r%llu = MulInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_DIV))
        (((printf))(("r%llu = DivInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_MOD))
        (((printf))(("r%llu = ModInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_EQ))
        (((printf))(("r%llu = ICmpEq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_NEQ))
        (((printf))(("r%llu = ICmpNeq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_GT))
        (((printf))(("r%llu = ICmpGt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_GTE))
        (((printf))(("r%llu = ICmpGte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_LT))
        (((printf))(("r%llu = ICmpLt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_LTE))
        (((printf))(("r%llu = ICmpLte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_ADD))
        (((printf))(("r%llu = AddFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_SUB))
        (((printf))(("r%llu = SubFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_MUL))
        (((printf))(("r%llu = MulFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_DIV))
        (((printf))(("r%llu = DivFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_MOD))
        (((printf))(("r%llu = ModFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_EQ))
        (((printf))(("r%llu = FCmpEq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_NEQ))
        (((printf))(("r%llu = FCmpNeq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_GT))
        (((printf))(("r%llu = FCmpGt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_GTE))
        (((printf))(("r%llu = FCmpGte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_LT))
        (((printf))(("r%llu = FCmpLt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_LTE))
        (((printf))(("r%llu = FCmpLte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_NOT))
        (((printf))(("r%llu = LNot r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_AND))
        (((printf))(("r%llu = LAnd r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_OR))
        (((printf))(("r%llu = LOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_AND))
        (((printf))(("r%llu = BAnd r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_OR))
        (((printf))(("r%llu = BOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_XOR))
        (((printf))(("r%llu = BXOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INSERT_VALUE))
        (((printf))(("r%llu = InsertValue r%llu, %llu, r%llu"), (((this)->dst).i), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_SIGN_EXTEND))
        (((printf))(("r%llu = IntSExt r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_ZERO_EXTEND))
        (((printf))(("r%llu = IntZExt r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_TRUNCATE))
        (((printf))(("r%llu = IntTrunc r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F32))
        (((printf))(("r%llu = IntToF32 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F64))
        (((printf))(("r%llu = IntToF64 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F32_TO_INT))
        (((printf))(("r%llu = F32ToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F64_TO_INT))
        (((printf))(("r%llu = F64ToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F64))
        (((printf))(("r%llu = IntToF64 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F32_TO_F64))
        (((printf))(("r%llu = FloatExt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F64_TO_F32))
        (((printf))(("r%llu = FloatTrunc r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_CREATE_ARRAY))
        (((printf))(("r%llu = CreateArray"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_CREATE_STRUCT))
        (((printf))(("r%llu = CreateStruct"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_CREATE_UNION))
        (((printf))(("r%llu = CreateUnion"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_PTR_TO_INT))
        (((printf))(("r%llu = PtrToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_PTR))
        (((printf))(("r%llu = IntToPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_GET_FIELD_PTR))
        (((printf))(("r%llu = GetFieldPtr r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_UNREACHABLE))
        (((printf))(("unreachable")));
    else if (((this)->kind) == (INSTR_UNTERMINATED))
        (((printf))(("<unterminated block>")));
    else if (((this)->kind) == (INSTR_MEMCPY))
        (((printf))(("Memcpy r%llu, r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_EMIT_ASSEMBLY))
        (((printf))(("EmitAsm r%llu (%s)"), (((this)->src).i), (((toStringPU5175rS0540)(((Type_u *)((((this)->op1).i))))).buffer)));
    else if (((this)->kind) == (INSTR_INTO_IR_VALUE))
        (((printf))(("r%llu = IntoIRValue r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_DEBUG_INFO_ALLOCA))
        (((printf))(("<Debug Info Alloca>")));
    else if (((this)->kind) == (INSTR_DEBUG_INFO_PARAM))
        (((printf))(("<Debug Info Param>")));
    else if (((this)->kind) == (INSTR_GET_ELEMENT_PTR)) {
        (((printf))(("r%llu = GetElementPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
        for (usize i = ((usize)(0llu)); ((i) < (((this)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            (((printf))((", r%llu"), (((atPS9911uszrPS6939)((&((this)->args)), (i)))->i)));
        }

    }

    else {
        (((fprintf))((stderr_), ("kind: %llu\n"), ((this)->kind)));
        ((unreachablePcrN)(("Exhaustive handling in IRInstr.dump()")));
    }

    if ((!(*((flags).emitBIR))) && ((this)->isComptime))
        (((printf))(("\x1B[0m\n")));
    else
        (((printf))(("\n")));
}
bool equalsPS0666PS0666rB(LoopBlock_s *this, LoopBlock_s *other) { return (((((this)->before).i) == (((other)->before).i)) && ((((this)->after).i) == (((other)->after).i))); }
bool equalsPS9435PS9435rB(IRBlock_s *this, IRBlock_s *other) { return (((equalsPS0540PS0540rB)((&((this)->parent)), (&((other)->parent)))) && ((((this)->id).i) == (((other)->id).i))); }
bool isTerminatedPS9435rB(IRBlock_s *this) {
    if ((((this)->instructions).length) == ((usize)(0llu)))
        return (false);
    return ((isTerminatorPS7680rB)(((lastPS0124rPS7680)((&((this)->instructions))))));
}
none dumpPS9435rN(IRBlock_s *this) {
    (((printf))(("b%llu:\n"), ((this)->id)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        (((printf))(("  %4d: "), (i)));
        ((dumpPS7680rN)(((atPS0124uszrPS7680)((&((this)->instructions)), (i)))));
    }
}
none pushInstructionPS9435S7680rN(IRBlock_s *this, IRInstr_s instr) { ((pushPS0124S7680rN)((&((this)->instructions)), (instr))); }
none insertInstructionPS9435uszS7680rN(IRBlock_s *this, usize index, IRInstr_s instr) {
    ((assertBPcrN)(((index) <= (((this)->instructions).length)), ("Out of bounds in insertInstruction")));
    IRInstrList_s instructions = ((IRInstrList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (index)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((&(instructions)), (*((atPS0124uszrPS7680)((&((this)->instructions)), (i))))));
    }

    ((pushPS0124S7680rN)((&(instructions)), (instr)));
    for (usize i = (index); ((i) < (((this)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((&(instructions)), (*((atPS0124uszrPS7680)((&((this)->instructions)), (i))))));
    }

    ((dropPS0124rN)((&((this)->instructions))));
    (((this)->instructions) = (instructions));
}
bool hasAttributePS7132U4360rB(IRFunc_s *this, ParsedAttribute_u attr) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == ((tagAnyru8)((&(attr)))))
            return (true);
    }

    return (false);
}
bool isExternPS7132rB(IRFunc_s *this) { return ((isExternPS4904rB)(((getFuncNodePS7132rPS4904)((this))))); }
IRBlockID_s appendBlockPS7132rS7192(IRFunc_s *this) {
    IRBlockID_s id = ((IRBlockID_s){.i = (((this)->blocks).length)});
    ((pushPS1479S9435rN)((&((this)->blocks)), ((IRBlock_s){.parent = ((this)->name), .id = (id)})));
    return (id);
}
none setCurrentBlockPS7132S7192rN(IRFunc_s *this, IRBlockID_s id) {
    ((assertBPcrN)((((id).i) < (((this)->blocks).length)), ("setCurrentBlock called with invalid ID")));
    (((this)->currentBlock) = (id));
}
IRBlockID_s getCurrentBlockPS7132rS7192(IRFunc_s *this) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getCurrentBlock called on empty IRFunc")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("getCurrentBlock points to invalid block")));
    return ((this)->currentBlock);
}
IRBlock_s *getCurrentBlockAsRefPS7132rPS9435(IRFunc_s *this) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getCurrentBlockAsRef called on empty IRFunc")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("getCurrentBlockAsRef points to invalid block")));
    return ((atPS1479uszrPS9435)((&((this)->blocks)), (((this)->currentBlock).i)));
}
IRBlock_s *getBlockByIDPS7132S7192rPS9435(IRFunc_s *this, IRBlockID_s id) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getBlockByID called on empty IRFunc")));
    ((assertBPcrN)((((id).i) < (((this)->blocks).length)), ("getBlockByID called with invalid ID")));
    return ((atPS1479uszrPS9435)((&((this)->blocks)), ((id).i)));
}
none pushLoopBlocksPS7132S7192S7192rN(IRFunc_s *this, IRBlockID_s before, IRBlockID_s after) { ((pushPS6662S0666rN)((&((this)->loopBlocks)), ((LoopBlock_s){.before = (before), .after = (after)}))); }
none popLoopBlocksPS7132rN(IRFunc_s *this) { ((popPS6662rPS0666)((&((this)->loopBlocks)))); }
ParsedFuncDecl_s *getFuncNodePS7132rPS4904(IRFunc_s *this) { return ((atPS4111uszrPS4904)((&(funcDecls)), ((this)->originalID))); }
none dumpInstructionsPS7132rN(IRFunc_s *this) {
    (((printf))(("%s:\n"), (((this)->name).buffer)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((dumpPS9435rN)(((atPS1479uszrPS9435)((&((this)->blocks)), (i)))));
    }
}
bool equalsPS7132PS7132rB(IRFunc_s *this, IRFunc_s *other) { ((unreachablePcrN)(("IRFunc.equals is not implemented yet"))); }
usize enterScopePS7132rusz(IRFunc_s *this) {
    ((pushPS9366S7082rN)((&((this)->scopes)), ((IRScope_s){0})));
    return (((this)->scopes).length);
}
usize leaveScopePS7132rusz(IRFunc_s *this) {
    usize s = (((this)->scopes).length);
    ((popPS9366rPS7082)((&((this)->scopes))));
    return (s);
}
none startComptimePS7132rN(IRFunc_s *this) { (((this)->comptimeLevel) = (((this)->comptimeLevel) + ((usize)(1llu)))); }
none endComptimePS7132rN(IRFunc_s *this) {
    ((assertBrN)((((this)->comptimeLevel) > ((usize)(0llu)))));
    (((this)->comptimeLevel) = (((this)->comptimeLevel) - ((usize)(1llu))));
}
usize getRegisterSizeInBytesPS7132rusz(IRFunc_s *this) {
    usize size = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->registers).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((this), ((RegIndex_s){.i = (i)})));
        ((size) = ((size) + ((getSizeInBytesPU5175rusz)(((reg)->typ)))));
    }

    return (size);
}
RegIndex_s allocateRegisterPS7132PU5175rS6939(IRFunc_s *this, Type_u *typ) {
    usize size = (((this)->registers).length);
    usize offset = ((usize)(0llu));
    if ((size) > ((usize)(0llu))) {
        IRReg_s *last = ((lastPS2282rPS1534)((&((this)->registers))));
        ((offset) = (((last)->offset) + ((getSizeInBytesPU5175rusz)(((last)->typ)))));
    }

    ((pushPS2282S1534rN)((&((this)->registers)), ((IRReg_s){.isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .offset = (offset), .typ = (typ)})));
    return ((RegIndex_s){.i = (size)});
}
IRReg_s *getRegisterPS7132S6939rPS1534(IRFunc_s *this, RegIndex_s index) {
    ((assertBPcrN)((((index).i) < (((this)->registers).length)), ("Out of bounds access in IRFunc.getRegister")));
    return ((atPS2282uszrPS1534)((&((this)->registers)), ((index).i)));
}
IRScopeEntry_s *getIdentifierByNamePS7132S7720rPS9676(IRFunc_s *this, SubStr_s name) {
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->scopes).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->scopes).length) - (_i)) - ((usize)(1llu)));
        IRScopeEntry_s *entry = ((getIdentifierByNamePS7082S7720rPS9676)(((atPS9366uszrPS7082)((&((this)->scopes)), (i))), (name)));
        if ((entry) != (NULL)) {
            return (entry);
        }
    }

    return (NULL);
}
none pushInstructionPS7132S7680rN(IRFunc_s *this, IRInstr_s instr) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("IRFunc.pushInstruction called on empty block list")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("IRFunc.pushInstruction: Current block was invalid")));
    ((pushInstructionPS9435S7680rN)(((atPS1479uszrPS9435)((&((this)->blocks)), (((this)->currentBlock).i))), (instr)));
}
none buildDebugInfoParamPS7132S8951S6939uszS7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, SubStr_s name) {
    usize val = (((shiftLeftuszuszrusz)(((usize)(((name).start))), (PARAM_SHIFT))) + (index));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_DEBUG_INFO_PARAM),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (val)}),
                                                         .op1 = ((RegIndex_s){.i = ((name).len)})})));
}
none buildDebugInfoAllocaPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s name) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_DEBUG_INFO_ALLOCA),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = ((usize)(((name).start)))}),
                                                         .op1 = ((RegIndex_s){.i = ((name).len)})})));
}
none buildAllocaPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size) {
    IRInstr_s alloca = ((IRInstr_s){.kind = (INSTR_ALLOCA), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (size)})});
    IRBlock_s *entry = ((getBlockByIDPS7132S7192rPS9435)((this), ((IRBlockID_s){.i = ((usize)(0llu))})));
    ((insertInstructionPS9435uszS7680rN)((entry), ((this)->allocaCounter), (alloca)));
    (((this)->allocaCounter) = (((this)->allocaCounter) + ((usize)(1llu))));
}
none buildFetchGlobalPointerPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_FETCH_GLOBAL_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (globalIndex)})));
}
none buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_FETCH_GLOBAL_VALUE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (globalIndex)})));
}
none buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_FETCH_COMPTIME_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (globalIndex),
                                                         .op1 = ((RegIndex_s){.i = ((usize)(1llu))})})));
}
none buildFetchLocalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_FETCH_COMPTIME_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (globalIndex),
                                                         .op1 = ((RegIndex_s){.i = ((usize)(0llu))})})));
}
none buildLoadFunctionPtrPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize funcID) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_FUNCTION_PTR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (funcID)})})));
}
none buildLoadPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildMovePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_MOVE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildGetParamPS7132S8951S6939uszuszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, usize size) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_GET_PARAM),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (index)}),
                                                         .op1 = ((RegIndex_s){.i = (size)})})));
}
none buildStorePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_STORE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildCallPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s funcID, RegIndexList_s args) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_CALL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (funcID), .args = (args)})));
}
none buildReturnExprPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_RETURN_EXPR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .src = (val)})));
}
none buildReturnEmptyPS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_RETURN_VOID), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildLoadStringPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s str) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_STRING),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = ((usize)(((str).start)))}),
                                                         .op1 = ((RegIndex_s){.i = ((str).len)})})));
}
none buildLoadBoolPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize val) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_LOAD_BOOL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (val)})})));
}
none buildLoadIntegerPS7132S8951S6939PU5175uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, Type_u *t, usize val) {
    usize kind = (INSTR_LOAD_I8);
    if ((isCharPU5175rB)((t))) {
        ((kind) = (INSTR_LOAD_U8));
    }

    else {
        ((assertBPcrN)(((isIntegerPU5175rB)((t))), ("IRFunc.buildLoadInteger got non-int type")));
        usize size = ((getSizeInBytesPU5175rusz)((t)));
        if ((size) == ((usize)(2llu)))
            ((kind) = (INSTR_LOAD_I16));
        if ((size) == ((usize)(4llu)))
            ((kind) = (INSTR_LOAD_I32));
        if ((size) == ((usize)(8llu)))
            ((kind) = (INSTR_LOAD_I64));
        if (!((isSignedIntegerPU5175rB)((t))))
            ((kind) = ((kind) + ((usize)(1llu))));
    }

    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (kind), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (val)})})));
}
none buildLoadNullPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_NULL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildLoadF32PS7132S8951S6939f32rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f32 val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_F32),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (*((usize *)((&(val)))))})})));
}
none buildLoadF64PS7132S8951S6939f64rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f64 val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_F64),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (*((usize *)((&(val)))))})})));
}
none buildLoadBlankPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_LOAD_BLANK), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (size)})})));
}
none buildLogicalNotPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOGICAL_NOT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildBinaryOpPS7132S8951uszS6939S6939S6939rN(IRFunc_s *this, Span_s span, usize kind, RegIndex_s dst, RegIndex_s lhs, RegIndex_s rhs) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (kind), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (lhs), .op1 = (rhs)})));
}
none buildInsertValuePS7132S8951S6939uszS6939rN(IRFunc_s *this, Span_s span, RegIndex_s aggr, usize index, RegIndex_s val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INSERT_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (aggr),
                                                         .src = ((RegIndex_s){.i = (index)}),
                                                         .op1 = (val)})));
}
none buildUnreachablePS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_UNREACHABLE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildUnterminatedPS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_UNTERMINATED), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildBrPS7132S8951S7192rN(IRFunc_s *this, Span_s span, IRBlockID_s block) {
    ((assertBPcrN)((((block).i) < (((this)->blocks).length)), ("buildBr called with invalid ID")));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_BR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = ((RegIndex_s){.i = ((block).i)})})));
}
none buildCondBrPS7132S8951S6939S7192S7192rN(IRFunc_s *this, Span_s span, RegIndex_s cond, IRBlockID_s drue, IRBlockID_s falze) {
    ((assertBPcrN)((((drue).i) < (((this)->blocks).length)), ("buildCondBr called with invalid ID")));
    ((assertBPcrN)((((falze).i) < (((this)->blocks).length)), ("buildCondBr called with invalid ID")));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_COND_BR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = ((RegIndex_s){.i = ((drue).i)}),
                                                         .src = (cond),
                                                         .op1 = ((RegIndex_s){.i = ((falze).i)})})));
}
bool buildBreakPS7132S8951rB(IRFunc_s *this, Span_s span) {
    if ((((this)->loopBlocks).length) == ((usize)(0llu)))
        return (false);
    LoopBlock_s *block = ((lastPS6662rPS0666)((&((this)->loopBlocks))));
    ((buildBrPS7132S8951S7192rN)((this), (span), ((block)->after)));
    return (true);
}
bool buildContinuePS7132S8951rB(IRFunc_s *this, Span_s span) {
    if ((((this)->loopBlocks).length) == ((usize)(0llu)))
        return (false);
    LoopBlock_s *block = ((lastPS6662rPS0666)((&((this)->loopBlocks))));
    ((buildBrPS7132S8951S7192rN)((this), (span), ((block)->before)));
    return (true);
}
none buildIntSignExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_SIGN_EXTEND),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildIntZeroExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_ZERO_EXTEND),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildIntTruncatePS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TRUNCATE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildF32ToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F32_TO_F64), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF64ToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F64_TO_F32), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_F32), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_F64), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF32ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F32_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF64ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F64_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildCreateArrayPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_ARRAY), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildCreateStructPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_STRUCT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildCreateUnionPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_UNION), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildPtrToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_PTR_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToPtrPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildGetFieldPtrPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, usize index) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_GET_FIELD_PTR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (elem),
                                                         .src = (aggr),
                                                         .op1 = ((RegIndex_s){.i = (index)})})));
}
none buildGetElementPtrPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, RegIndexList_s indices) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_GET_ELEMENT_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (elem), .src = (aggr), .args = (indices)})));
}
none buildMemcpyPS7132S8951S6939S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s src, RegIndex_s dst, RegIndex_s size) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_MEMCPY), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src), .op1 = (size)})));
}
none buildEmitAssemblyPS7132S8951S6939PU5175rN(IRFunc_s *this, Span_s span, RegIndex_s context, Type_u *fnType) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_EMIT_ASSEMBLY),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .src = (context),
                                                         .op1 = ((RegIndex_s){.i = ((usize)((fnType)))})})));
}
none buildIntoIRValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INTO_IR_VALUE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
bool equalsPS9676PS9676rB(IRScopeEntry_s *this, IRScopeEntry_s *other) { ((unreachablePcrN)(("IRScopeEntry.equals is not implemented yet"))); }
bool equalsPS7082PS7082rB(IRScope_s *this, IRScope_s *other) { ((unreachablePcrN)(("IRScope.equals is not implemented yet"))); }
none addEntryPS7082S7720S6939BrN(IRScope_s *this, SubStr_s name, RegIndex_s ptr, bool isComptime) {
    ((pushPS5960S9676rN)((&((this)->entries)), ((IRScopeEntry_s){.name = (name), .ptr = (ptr), .isComptime = (isComptime)})));
}
IRScopeEntry_s *getIdentifierByNamePS7082S7720rPS9676(IRScope_s *this, SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->entries).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRScopeEntry_s *entry = ((atPS5960uszrPS9676)((&((this)->entries)), (i)));
        if ((equalsPS7720PS7720rB)((&(name)), (&((entry)->name)))) {
            return (entry);
        }
    }

    return (NULL);
}
IRScopeEntry_s *getIdentifierByNamePS9562PS7132S7720PBrPS9676(IRGen_s *this, IRFunc_s *function, SubStr_s name, bool *isGlobal) {
    IRScopeEntry_s *entry = ((getIdentifierByNamePS7132S7720rPS9676)((function), (name)));
    if ((entry) != (NULL)) {
        ((*(isGlobal)) = (false));
        return (entry);
    }

    ((entry) = ((getIdentifierByNamePS7132S7720rPS9676)((&((this)->globalScope)), (name))));
    if ((entry) != (NULL)) {
        ((*(isGlobal)) = (true));
        return (entry);
    }

    return (NULL);
}
usize getFunctionByNamePS9562PS0540rusz(IRGen_s *this, String_s *name) { return ((indexOfPS2612PS0540rusz)((&((this)->functions)), (name))); }
usize getFunctionByMangledNamePS9562PcPcrusz(IRGen_s *this, char *name, char *imp) {
    String_s fn = ((newStringFromStrLitPcrS0540)((name)));
    if (!((containsKeyPS2612PS0540rB)((&((this)->functions)), (&(fn))))) {
        (((fprintf))((stderr_), ("%s Could not insert implicit function call! Reason: Could not find function `%s`!\n"), (FATAL_STR), (name)));
        (((fprintf))((stderr_), ("%s: Certain features in the language require extra support from the standard library. "), (NOTE_STR)));
        (((fprintf))((stderr_), ("Normally the compiler automatically imports the required files, however it seems like it failed this time.\n")));
        (((fprintf))((stderr_), ("%s: Please import `%s` and try again.\n"), (NOTE_STR), (imp)));
        (((fprintf))((stderr_), ("%s: Please create a bug report on https://github.com/pfhaupt/bufo/issues/new.\n"), (NOTE_STR)));
        (((C_exiti32rN))(((i32)(2))));
    }

    usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(fn))));
    ((dropPS0540rN)((&(fn))));
    return (funcID);
}
bool fillLookupPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFuncDecl_s *function = ((atPS4111uszrPS4904)((&(funcDecls)), (i)));
        if ((function)->ignored)
            continue;
        String_s name = ((getMangledNamePS4904rS0540)((function)));
        if ((containsKeyPS2612PS0540rB)((&((this)->functions)), (&(name)))) {
            IRFunc_s *fn = ((getPS2612PS0540rPS7132)((&((this)->functions)), (&(name))));
            String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
            String_s loc1 = ((toStringPS8951rS0540)((&((fn)->span))));
            (((fprintf))((stderr_), ("%s: %s Hash collision - Function Lookup already contains function!\n"), ((loc).buffer), (FATAL_STR)));
            (((fprintf))((stderr_), ("%s: %s Function with mangled name %s already defined here!\n"), ((loc1).buffer), (FATAL_STR), ((name).buffer)));
            ((dropPS0540rN)((&(loc1))));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(2))));
        }

        IRFunc_s irfunc = ((IRFunc_s){.name = (name), .span = ((function)->span), .originalID = ((getIDPS4904rusz)((function))), .comptimeLevel = ((usize)(0llu)), .attrs = ((function)->attrs)});
        ((addPS2612S0540S7132rN)((&((this)->functions)), (name), (irfunc)));
    }

    return (true);
}
bool _anon_26_0PS3131uszrB(TypeInfoTable_s *table, usize index) {
    bool succ_4280_ = true;

    {
        TypeInfo_u tmp_6415_ = ((((table)->elements))[(index)]);
        succ_4280_ &= (tmp_6415_.tag == 0);

        if (succ_4280_) {
            return (true);
        }
    }

    return (false);
}
usize _anon_26_1PS4113uszrusz(UsizeList_s *removed, usize index) {
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((removed)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        usize removed_index = ((((removed)->elements))[(i)]);
        if ((removed_index) > (index))
            break;
        ((offset) = ((offset) + ((usize)(1llu))));
    }

    return (offset);
}
TypeInfoTable_s generateTypeInfoTablerS3131(none) {
    TypeInfoTable_s table = ((TypeInfoTable_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = ((atPS4174uszrPU5175)((&(types)), (i)));
        bool succ_4018_ = true;
        bool succ_4023_ = true;
        bool succ_4028_ = true;
        bool succ_4034_ = true;
        bool succ_4041_ = true;
        bool succ_4049_ = true;
        bool succ_4055_ = true;
        bool succ_4062_ = true;
        bool succ_4068_ = true;
        bool succ_4074_ = true;

        Type_u *tmp_6228_ = (t);
        {
            succ_4018_ &= (tmp_6228_->tag == 1);
            if (succ_4018_) {
                {
                    TypeInfo_u u = (((TypeInfo_u){.tag = 0, .payload = {0}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(u)))))
                        ((push_entryPS3131U7843rN)((&(table)), (u)));
                }
                goto after_6228;
            }
        }
        {
            succ_4023_ &= (tmp_6228_->tag == 3);
            PrimType_u *prim = &tmp_6228_->payload.variant3._0;
            succ_4023_ &= true;
            if (succ_4023_) {
                {
                    ((assertBPcrN)(((i) < (PRIM_TYPE_COUNT)), ("nope")));
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    ((push_entryPS3131U7843rN)((&(table)), (((TypeInfo_u){.tag = 1,
                                                                          .payload = {.variant1 = {._0 = ((asSubStrPS0540rS7720)((&(name)))),
                                                                                                   ._1 = ((getSizeInBytesPU5175rusz)((t))),
                                                                                                   ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}))));
                }
                goto after_6228;
            }
        }
        {
            succ_4028_ &= (tmp_6228_->tag == 4);
            Type_u **underlying = &tmp_6228_->payload.variant4._0;
            succ_4028_ &= true;
            if (succ_4028_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u p = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(p)))))
                        ((push_entryPS3131U7843rN)((&(table)), (p)));
                }
                goto after_6228;
            }
        }
        {
            succ_4034_ &= (tmp_6228_->tag == 2);
            succ_4034_ &= true;
            if (succ_4034_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u v = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(v)))))
                        ((push_entryPS3131U7843rN)((&(table)), (v)));
                }
                goto after_6228;
            }
        }
        {
            succ_4041_ &= (tmp_6228_->tag == 5);
            Type_u **elem = &tmp_6228_->payload.variant5._0;
            succ_4041_ &= true;
            usize *len = &tmp_6228_->payload.variant5._1;
            succ_4041_ &= true;
            if (succ_4041_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u a = (((TypeInfo_u){
                        .tag = 4,
                        .payload = {.variant4 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t))), ._4 = (*len)}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(a)))))
                        ((push_entryPS3131U7843rN)((&(table)), (a)));
                }
                goto after_6228;
            }
        }
        {
            succ_4049_ &= (tmp_6228_->tag == 6);
            TypeList_s *args = &tmp_6228_->payload.variant6._0;
            succ_4049_ &= true;
            Type_u **ret = &tmp_6228_->payload.variant6._1;
            succ_4049_ &= true;
            succ_4049_ &= true;
            if (succ_4049_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u f = (((TypeInfo_u){.tag = 7, .payload = {.variant7 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(f)))))
                        ((push_entryPS3131U7843rN)((&(table)), (f)));
                }
                goto after_6228;
            }
        }
        {
            succ_4055_ &= (tmp_6228_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_6228_->payload.variant7._0;
            succ_4055_ &= true;
            if (succ_4055_) {
                {
                    String_s name = ((getFullNamePS5521rS0540)((*decl)));
                    TypeInfo_u s = (((TypeInfo_u){
                        .tag = 5, .payload = {.variant5 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(s)))))
                        ((push_entryPS3131U7843rN)((&(table)), (s)));
                }
                goto after_6228;
            }
        }
        {
            succ_4062_ &= (tmp_6228_->tag == 8);
            ParsedUnionDecl_s **decl = &tmp_6228_->payload.variant8._0;
            succ_4062_ &= true;
            succ_4062_ &= true;
            if (succ_4062_) {
                {
                    String_s name = ((getFullNamePS0997rS0540)((*decl)));
                    TypeInfo_u u = (((TypeInfo_u){
                        .tag = 6, .payload = {.variant6 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(u)))))
                        ((push_entryPS3131U7843rN)((&(table)), (u)));
                }
                goto after_6228;
            }
        }
        {
            succ_4068_ &= (tmp_6228_->tag == 10);
            TypeList_s *_elems = &tmp_6228_->payload.variant10._0;
            succ_4068_ &= true;
            if (succ_4068_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u a = (((TypeInfo_u){
                        .tag = 8, .payload = {.variant8 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(a)))))
                        ((push_entryPS3131U7843rN)((&(table)), (a)));
                }
                goto after_6228;
            }
        }
        {
            succ_4074_ &= (tmp_6228_->tag == 9);
            succ_4074_ &= true;
            if (succ_4074_) {
                {
                }
                goto after_6228;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when filling")));
                }
                goto after_6228;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6228:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = ((atPS4174uszrPU5175)((&(types)), (i)));
        bool succ_4082_ = true;
        bool succ_4086_ = true;
        bool succ_4095_ = true;
        bool succ_4105_ = true;
        bool succ_4124_ = true;
        bool succ_4146_ = true;
        bool succ_4171_ = true;
        bool succ_4222_ = true;
        bool succ_4225_ = true;
        bool succ_4229_ = true;

        Type_u *tmp_6401_ = (t);
        {
            succ_4082_ &= (tmp_6401_->tag == 3);
            PrimType_u *prim = &tmp_6401_->payload.variant3._0;
            succ_4082_ &= true;
            if (succ_4082_) {
                {
                }
                goto after_6401;
            }
        }
        {
            succ_4086_ &= (tmp_6401_->tag == 4);
            Type_u **underlying = &tmp_6401_->payload.variant4._0;
            succ_4086_ &= true;
            if (succ_4086_) {
                {
                    String_s tmp_32863 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_32863)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = (name)}}}));
                    usize ptr_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((ptr_index) != ((table).length))));
                    TypeInfo_u *ptr_info = (&((((table).elements))[(ptr_index)]));
                    TypeInfo_u tmp_32896 = (((TypeInfo_u){.tag = 3, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((ptr_info))) == (((tagAnyru8)((&tmp_32896)))))));
                    SubStr_s tmp_32908 = ((get_namePU7843rS7720)((ptr_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_32908)))));
                    usize underlying_index = ((index_of_typePS3131PU5175rusz)((&(table)), (*underlying)));
                    ((assertBPcrN)(((underlying_index) != ((table).length)), ("Underlying type info does not exist")));
                    ((*(ptr_info)) = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = (name), ._1 = (underlying_index)}}})));
                }
                goto after_6401;
            }
        }
        {
            succ_4095_ &= (tmp_6401_->tag == 2);
            Type_u **underlying = &tmp_6401_->payload.variant2._0;
            succ_4095_ &= true;
            if (succ_4095_) {
                {
                    String_s tmp_32940 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_32940)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = (name)}}}));
                    usize var_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((var_index) != ((table).length))));
                    TypeInfo_u *var_info = (&((((table).elements))[(var_index)]));
                    TypeInfo_u tmp_32973 = (((TypeInfo_u){.tag = 2, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((var_info))) == (((tagAnyru8)((&tmp_32973)))))));
                    SubStr_s tmp_32985 = ((get_namePU7843rS7720)((var_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_32985)))));
                    usize underlying_index = ((index_of_typePS3131PU5175rusz)((&(table)), (*underlying)));
                    ((assertBPcrN)(((underlying_index) != ((table).length)), ("Underlying type info does not exist")));
                    ((*(var_info)) = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = (name), ._1 = (underlying_index)}}})));
                }
                goto after_6401;
            }
        }
        {
            succ_4105_ &= (tmp_6401_->tag == 5);
            Type_u **elem = &tmp_6401_->payload.variant5._0;
            succ_4105_ &= true;
            usize *len = &tmp_6401_->payload.variant5._1;
            succ_4105_ &= true;
            if (succ_4105_) {
                {
                    String_s tmp_33017 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33017)));
                    TypeInfo_u a = (((TypeInfo_u){.tag = 4, .payload = {.variant4 = {._0 = (name)}}}));
                    usize array_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(a))));
                    ((assertBrN)(((array_index) != ((table).length))));
                    TypeInfo_u *array_info = (&((((table).elements))[(array_index)]));
                    TypeInfo_u tmp_33050 = (((TypeInfo_u){.tag = 4, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((array_info))) == (((tagAnyru8)((&tmp_33050)))))));
                    SubStr_s tmp_33062 = ((get_namePU7843rS7720)((array_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33062)))));
                    bool succ_4117_ = true;

                    TypeInfo_u *tmp_6268_ = (array_info);
                    {
                        succ_4117_ &= (tmp_6268_->tag == 4);
                        succ_4117_ &= true;
                        succ_4117_ &= true;
                        succ_4117_ &= true;
                        usize *elem_index = &tmp_6268_->payload.variant4._3;
                        succ_4117_ &= true;
                        usize *l = &tmp_6268_->payload.variant4._4;
                        succ_4117_ &= true;
                        if (succ_4117_) {
                            {
                                ((*elem_index) = ((index_of_typePS3131PU5175rusz)((&(table)), (*elem))));
                                ((assertBrN)(((*len) == (*l))));
                            }
                            goto after_6268;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6268;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6268:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }
                goto after_6401;
            }
        }
        {
            succ_4124_ &= (tmp_6401_->tag == 6);
            TypeList_s *args = &tmp_6401_->payload.variant6._0;
            succ_4124_ &= true;
            Type_u **ret = &tmp_6401_->payload.variant6._1;
            succ_4124_ &= true;
            FuncAttr_s *attr = &tmp_6401_->payload.variant6._2;
            succ_4124_ &= true;
            if (succ_4124_) {
                {
                    String_s tmp_33088 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33088)));
                    TypeInfo_u f = (((TypeInfo_u){.tag = 7, .payload = {.variant7 = {._0 = (name)}}}));
                    usize function_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(f))));
                    ((assertBrN)(((function_index) != ((table).length))));
                    TypeInfo_u *function_info = (&((((table).elements))[(function_index)]));
                    TypeInfo_u tmp_33121 = (((TypeInfo_u){.tag = 7, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((function_info))) == (((tagAnyru8)((&tmp_33121)))))));
                    SubStr_s tmp_33133 = ((get_namePU7843rS7720)((function_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33133)))));
                    TypeInfoList_s *arg_list = (NULL);
                    usize *ret_index = (NULL);
                    bool succ_4138_ = true;

                    TypeInfo_u *tmp_6284_ = (function_info);
                    {
                        succ_4138_ &= (tmp_6284_->tag == 7);
                        succ_4138_ &= true;
                        TypeInfoList_s *args = &tmp_6284_->payload.variant7._1;
                        succ_4138_ &= true;
                        usize *ret = &tmp_6284_->payload.variant7._2;
                        succ_4138_ &= true;
                        if (succ_4138_) {
                            {
                                ((arg_list) = (&(*args)));
                                ((ret_index) = (&(*ret)));
                            }
                            goto after_6284;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6284;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6284:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((arg_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (*((atPS0643uszrPPU5175)((&(*args)), (j))))));
                        ((assertBPcrN)(((index) != ((table).length)), ("Argument type info does not exist")));
                        ((pushPS2495uszrN)((arg_list), (index)));
                    }

                    ((*(ret_index)) = ((index_of_typePS3131PU5175rusz)((&(table)), (*ret))));
                    ((assertBPcrN)(((*(ret_index)) != ((table).length)), ("Return type info does not exist")));
                }
                goto after_6401;
            }
        }
        {
            succ_4146_ &= (tmp_6401_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_6401_->payload.variant7._0;
            succ_4146_ &= true;
            if (succ_4146_) {
                {
                    String_s tmp_33208 = ((getFullNamePS5521rS0540)((*decl)));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33208)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 5, .payload = {.variant5 = {._0 = (name)}}}));
                    usize struct_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((struct_index) != ((table).length))));
                    TypeInfo_u *struct_info = (&((((table).elements))[(struct_index)]));
                    TypeInfo_u tmp_33241 = (((TypeInfo_u){.tag = 5, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((struct_info))) == (((tagAnyru8)((&tmp_33241)))))));
                    SubStr_s tmp_33253 = ((get_namePU7843rS7720)((struct_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33253)))));
                    FieldTypeInfoList_s *struct_fields = (NULL);
                    bool succ_4159_ = true;

                    TypeInfo_u *tmp_6308_ = (struct_info);
                    {
                        succ_4159_ &= (tmp_6308_->tag == 5);
                        SubStr_s *name = &tmp_6308_->payload.variant5._0;
                        succ_4159_ &= true;
                        succ_4159_ &= true;
                        succ_4159_ &= true;
                        FieldTypeInfoList_s *fields = &tmp_6308_->payload.variant5._3;
                        succ_4159_ &= true;
                        if (succ_4159_) {
                            {
                                ((struct_fields) = (&(*fields)));
                            }
                            goto after_6308;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6308;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6308:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((struct_fields)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < (((*decl)->context).fieldLength)); ((j) = ((j) + ((usize)(1llu))))) {
                        Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (j)));
                        ParsedTypeNode_s *type_decl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (j)));
                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                        ((assertBPcrN)(((index) != ((table).length)), ("Struct field type info does not exist")));
                        String_s tmp_33324 = ((toStringPS7720rS0540)((&((name).content))));

                        ((pushPS0131S3911rN)((struct_fields), ((FieldTypeInfo_s){.name = ((asSubStrPS0540rS7720)((&tmp_33324))),
                                                                                 .type = (index),
                                                                                 .offset_in_bytes = ((getFieldOffsetPS5521PS7720Brusz)((*decl), (&((name).content)), (false)))})));
                    }
                }
                goto after_6401;
            }
        }
        {
            succ_4171_ &= (tmp_6401_->tag == 8);
            ParsedUnionDecl_s **decl = &tmp_6401_->payload.variant8._0;
            succ_4171_ &= true;
            succ_4171_ &= true;
            if (succ_4171_) {
                {
                    String_s tmp_33341 = ((getFullNamePS0997rS0540)((*decl)));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33341)));
                    TypeInfo_u u = (((TypeInfo_u){.tag = 6, .payload = {.variant6 = {._0 = (name)}}}));
                    usize union_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(u))));
                    ((assertBrN)(((union_index) != ((table).length))));
                    TypeInfo_u *union_info = (&((((table).elements))[(union_index)]));
                    TypeInfo_u tmp_33374 = (((TypeInfo_u){.tag = 6, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((union_info))) == (((tagAnyru8)((&tmp_33374)))))));
                    SubStr_s tmp_33386 = ((get_namePU7843rS7720)((union_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33386)))));
                    UnionVariantTypeInfoList_s *variant_list = (NULL);
                    bool succ_4184_ = true;

                    TypeInfo_u *tmp_6333_ = (union_info);
                    {
                        succ_4184_ &= (tmp_6333_->tag == 6);
                        SubStr_s *name = &tmp_6333_->payload.variant6._0;
                        succ_4184_ &= true;
                        succ_4184_ &= true;
                        succ_4184_ &= true;
                        UnionVariantTypeInfoList_s *variants = &tmp_6333_->payload.variant6._3;
                        succ_4184_ &= true;
                        if (succ_4184_) {
                            {
                                ((variant_list) = (&(*variants)));
                            }
                            goto after_6333;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6333;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6333:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((variant_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < (((*decl)->variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedUnionVariant_s *variant = (((((*decl)->variants).elements))[(j)]);
                        UnionVariantTypeInfo_u variant_info = (((UnionVariantTypeInfo_u){.tag = 0, .payload = {.variant0 = {0}}}));
                        bool succ_4192_ = true;
                        bool succ_4195_ = true;
                        bool succ_4206_ = true;

                        ParsedUnionVariantData_u tmp_6370_ = ((variant)->data);
                        {
                            succ_4192_ &= (tmp_6370_.tag == 0);
                            if (succ_4192_) {
                                {
                                    String_s tmp_33439 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 0, .payload = {.variant0 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33439)))}}})));
                                }
                                goto after_6370;
                            }
                        }
                        {
                            succ_4195_ &= (tmp_6370_.tag == 1);
                            ParsedTypeNodeList_s *fields = &tmp_6370_.payload.variant1._0;
                            succ_4195_ &= true;
                            if (succ_4195_) {
                                {
                                    TypeInfoList_s tuple_fields = ((TypeInfoList_s){0});
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ParsedTypeNode_s *type_decl = ((((*fields).elements))[(k)]);
                                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                                        ((assertBPcrN)(((index) != ((table).length)), ("Union variant field type info does not exist")));
                                        ((pushPS2495uszrN)((&(tuple_fields)), (index)));
                                    }

                                    String_s tmp_33496 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 1, .payload = {.variant1 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33496))), ._1 = (tuple_fields)}}})));
                                }
                                goto after_6370;
                            }
                        }
                        {
                            succ_4206_ &= (tmp_6370_.tag == 2);
                            ParsedTypeNodeList_s *fields = &tmp_6370_.payload.variant2._0;
                            succ_4206_ &= true;
                            TokenList_s *names = &tmp_6370_.payload.variant2._1;
                            succ_4206_ &= true;
                            if (succ_4206_) {
                                {
                                    FieldTypeInfoList_s struct_fields = ((FieldTypeInfoList_s){0});
                                    ((assertBrN)((((*fields).length) == ((*names).length))));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        Token_s name = ((((*names).elements))[(k)]);
                                        ParsedTypeNode_s *type_decl = ((((*fields).elements))[(k)]);
                                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                                        ((assertBPcrN)(((index) != ((table).length)), ("Union variant field type info does not exist")));
                                        usize _size = ((usize)(0llu));
                                        usize offset = ((usize)(0llu));
                                        ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (k), (&(offset)), (&(_size)), (false)));
                                        String_s tmp_33573 = ((toStringPS7720rS0540)((&((name).content))));

                                        ((pushPS0131S3911rN)((&(struct_fields)), ((FieldTypeInfo_s){.name = ((asSubStrPS0540rS7720)((&tmp_33573))), .type = (index), .offset_in_bytes = (offset)})));
                                    }

                                    String_s tmp_33590 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33590))), ._1 = (struct_fields)}}})));
                                }
                                goto after_6370;
                            }
                        }
                        {
                            if (true) {
                                {
                                    ((unreachablerN)());
                                }
                                goto after_6370;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_6370:
                        (void)0; // error: label at end of compound statement is a C23 extension
                        ((pushPS3117U0081rN)((variant_list), (variant_info)));
                    }
                }
                goto after_6401;
            }
        }
        {
            succ_4222_ &= (tmp_6401_->tag == 9);
            succ_4222_ &= true;
            if (succ_4222_) {
                {
                }
                goto after_6401;
            }
        }
        {
            succ_4225_ &= (tmp_6401_->tag == 1);
            if (succ_4225_) {
                {
                }
                goto after_6401;
            }
        }
        {
            succ_4229_ &= (tmp_6401_->tag == 10);
            TypeList_s *elems = &tmp_6401_->payload.variant10._0;
            succ_4229_ &= true;
            if (succ_4229_) {
                {
                    String_s tmp_33610 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33610)));
                    TypeInfo_u a = (((TypeInfo_u){.tag = 8, .payload = {.variant8 = {._0 = (name)}}}));
                    usize tuple_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(a))));
                    ((assertBrN)(((tuple_index) != ((table).length))));
                    TypeInfo_u *tuple_info = (&((((table).elements))[(tuple_index)]));
                    TypeInfo_u tmp_33643 = (((TypeInfo_u){.tag = 8, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((tuple_info))) == (((tagAnyru8)((&tmp_33643)))))));
                    SubStr_s tmp_33655 = ((get_namePU7843rS7720)((tuple_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33655)))));
                    TypeInfoList_s *elem_list = (NULL);
                    bool succ_4242_ = true;

                    TypeInfo_u *tmp_6389_ = (tuple_info);
                    {
                        succ_4242_ &= (tmp_6389_->tag == 8);
                        succ_4242_ &= true;
                        succ_4242_ &= true;
                        succ_4242_ &= true;
                        TypeInfoList_s *elems = &tmp_6389_->payload.variant8._3;
                        succ_4242_ &= true;
                        if (succ_4242_) {
                            {
                                ((elem_list) = (&(*elems)));
                            }
                            goto after_6389;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6389;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6389:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((elem_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < ((*elems).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), ((((*elems).elements))[(j)])));
                        ((assertBPcrN)(((index) != ((table).length)), ("Argument type info does not exist")));
                        ((pushPS2495uszrN)((elem_list), (index)));
                    }
                }
                goto after_6401;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when patching")));
                }
                goto after_6401;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6401:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    usize length = ((table).length);
    while (true) {
        UsizeList_s count = ((UsizeList_s){0});
        ((initBlankPS4113uszrN)((&(count)), ((table).length)));
        for (usize i = ((usize)(0llu)); ((i) < ((table).length)); ((i) = ((i) + ((usize)(1llu))))) {
            bool succ_4260_ = true;
            bool succ_4265_ = true;
            bool succ_4270_ = true;
            bool succ_4276_ = true;
            bool succ_4292_ = true;
            bool succ_4302_ = true;
            bool succ_4330_ = true;
            bool succ_4337_ = true;
            bool succ_4343_ = true;

            TypeInfo_u *tmp_6476_ = (&((((table).elements))[(i)]));
            {
                succ_4260_ &= (tmp_6476_->tag == 4);
                succ_4260_ &= true;
                succ_4260_ &= true;
                succ_4260_ &= true;
                usize *elem = &tmp_6476_->payload.variant4._3;
                succ_4260_ &= true;
                succ_4260_ &= true;
                if (succ_4260_) {
                    {
                        (((((count).elements))[(*elem)]) = (((((count).elements))[(*elem)]) + ((usize)(1llu))));
                    }
                    goto after_6476;
                }
            }
            {
                succ_4265_ &= (tmp_6476_->tag == 3);
                succ_4265_ &= true;
                usize *under = &tmp_6476_->payload.variant3._1;
                succ_4265_ &= true;
                if (succ_4265_) {
                    {
                        (((((count).elements))[(*under)]) = (((((count).elements))[(*under)]) + ((usize)(1llu))));
                    }
                    goto after_6476;
                }
            }
            {
                succ_4270_ &= (tmp_6476_->tag == 2);
                succ_4270_ &= true;
                usize *under = &tmp_6476_->payload.variant2._1;
                succ_4270_ &= true;
                if (succ_4270_) {
                    {
                        (((((count).elements))[(*under)]) = (((((count).elements))[(*under)]) + ((usize)(1llu))));
                    }
                    goto after_6476;
                }
            }
            {
                succ_4276_ &= (tmp_6476_->tag == 7);
                succ_4276_ &= true;
                TypeInfoList_s *args = &tmp_6476_->payload.variant7._1;
                succ_4276_ &= true;
                usize *ret = &tmp_6476_->payload.variant7._2;
                succ_4276_ &= true;
                if (succ_4276_) {
                    {
                        bool (*is_unknown)(TypeInfoTable_s *, usize) = (_anon_26_0PS3131uszrB);
                        bool needed = (true);
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            if ((is_unknown)((&(table)), ((((*args).elements))[(j)]))) {
                                ((needed) = (false));
                            }
                        }

                        ((needed) = ((needed) && (!((is_unknown)((&(table)), (*ret))))));
                        if (needed)
                            (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = ((((*args).elements))[(j)]);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }

                        (((((count).elements))[(*ret)]) = (((((count).elements))[(*ret)]) + ((usize)(1llu))));
                    }
                    goto after_6476;
                }
            }
            {
                succ_4292_ &= (tmp_6476_->tag == 5);
                succ_4292_ &= true;
                succ_4292_ &= true;
                succ_4292_ &= true;
                FieldTypeInfoList_s *fields = &tmp_6476_->payload.variant5._3;
                succ_4292_ &= true;
                if (succ_4292_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = (((((*fields).elements))[(j)]).type);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }
                    }
                    goto after_6476;
                }
            }
            {
                succ_4302_ &= (tmp_6476_->tag == 6);
                succ_4302_ &= true;
                succ_4302_ &= true;
                succ_4302_ &= true;
                UnionVariantTypeInfoList_s *variants = &tmp_6476_->payload.variant6._3;
                succ_4302_ &= true;
                if (succ_4302_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                            bool succ_4309_ = true;
                            bool succ_4314_ = true;
                            bool succ_4322_ = true;

                            UnionVariantTypeInfo_u *tmp_6460_ = (var);
                            {
                                succ_4309_ &= (tmp_6460_->tag == 0);
                                succ_4309_ &= true;
                                if (succ_4309_) {
                                    {
                                    }
                                    goto after_6460;
                                }
                            }
                            {
                                succ_4314_ &= (tmp_6460_->tag == 1);
                                succ_4314_ &= true;
                                TypeInfoList_s *fields = &tmp_6460_->payload.variant1._1;
                                succ_4314_ &= true;
                                if (succ_4314_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            usize elem = ((((*fields).elements))[(k)]);
                                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                                        }
                                    }
                                    goto after_6460;
                                }
                            }
                            {
                                succ_4322_ &= (tmp_6460_->tag == 2);
                                succ_4322_ &= true;
                                FieldTypeInfoList_s *fields = &tmp_6460_->payload.variant2._1;
                                succ_4322_ &= true;
                                if (succ_4322_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            usize elem = (((((*fields).elements))[(k)]).type);
                                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                                        }
                                    }
                                    goto after_6460;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablerN)());
                                    }
                                    goto after_6460;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_6460:
                            (void)0; // error: label at end of compound statement is a C23 extension
                        }
                    }
                    goto after_6476;
                }
            }
            {
                succ_4330_ &= (tmp_6476_->tag == 1);
                succ_4330_ &= true;
                if (succ_4330_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                    }
                    goto after_6476;
                }
            }
            {
                succ_4337_ &= (tmp_6476_->tag == 8);
                succ_4337_ &= true;
                succ_4337_ &= true;
                succ_4337_ &= true;
                TypeInfoList_s *elements = &tmp_6476_->payload.variant8._3;
                succ_4337_ &= true;
                if (succ_4337_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = ((((*elements).elements))[(j)]);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }
                    }
                    goto after_6476;
                }
            }
            {
                succ_4343_ &= (tmp_6476_->tag == 0);
                if (succ_4343_) {
                    {
                    }
                    goto after_6476;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when counting")));
                    }
                    goto after_6476;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_6476:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        UsizeList_s remove = ((UsizeList_s){0});
        TypeInfoTable_s new_table = ((TypeInfoTable_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((count).length)); ((i) = ((i) + ((usize)(1llu))))) {
            if (((((count).elements))[(i)]) != ((usize)(0llu))) {
                ((push_entryPS3131U7843rN)((&(new_table)), ((((table).elements))[(i)])));
            }

            else {
                ((pushPS4113uszrN)((&(remove)), (i)));
            }
        }

        usize (*count_offset)(UsizeList_s *, usize) = (_anon_26_1PS4113uszrusz);
        for (usize i = ((usize)(0llu)); ((i) < ((new_table).length)); ((i) = ((i) + ((usize)(1llu))))) {
            bool succ_4366_ = true;
            bool succ_4371_ = true;
            bool succ_4376_ = true;
            bool succ_4382_ = true;
            bool succ_4391_ = true;
            bool succ_4400_ = true;
            bool succ_4426_ = true;
            bool succ_4429_ = true;
            bool succ_4436_ = true;

            TypeInfo_u *tmp_6545_ = (&((((new_table).elements))[(i)]));
            {
                succ_4366_ &= (tmp_6545_->tag == 4);
                succ_4366_ &= true;
                succ_4366_ &= true;
                succ_4366_ &= true;
                usize *elem = &tmp_6545_->payload.variant4._3;
                succ_4366_ &= true;
                succ_4366_ &= true;
                if (succ_4366_) {
                    {
                        ((*elem) = ((*elem) - ((count_offset)((&(remove)), (*elem)))));
                    }
                    goto after_6545;
                }
            }
            {
                succ_4371_ &= (tmp_6545_->tag == 3);
                succ_4371_ &= true;
                usize *under = &tmp_6545_->payload.variant3._1;
                succ_4371_ &= true;
                if (succ_4371_) {
                    {
                        ((*under) = ((*under) - ((count_offset)((&(remove)), (*under)))));
                    }
                    goto after_6545;
                }
            }
            {
                succ_4376_ &= (tmp_6545_->tag == 2);
                succ_4376_ &= true;
                usize *under = &tmp_6545_->payload.variant2._1;
                succ_4376_ &= true;
                if (succ_4376_) {
                    {
                        ((*under) = ((*under) - ((count_offset)((&(remove)), (*under)))));
                    }
                    goto after_6545;
                }
            }
            {
                succ_4382_ &= (tmp_6545_->tag == 7);
                succ_4382_ &= true;
                TypeInfoList_s *args = &tmp_6545_->payload.variant7._1;
                succ_4382_ &= true;
                usize *ret = &tmp_6545_->payload.variant7._2;
                succ_4382_ &= true;
                if (succ_4382_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            (((((*args).elements))[(j)]) = (((((*args).elements))[(j)]) - ((count_offset)((&(remove)), ((((*args).elements))[(j)])))));
                        }

                        ((*ret) = ((*ret) - ((count_offset)((&(remove)), (*ret)))));
                    }
                    goto after_6545;
                }
            }
            {
                succ_4391_ &= (tmp_6545_->tag == 5);
                succ_4391_ &= true;
                succ_4391_ &= true;
                succ_4391_ &= true;
                FieldTypeInfoList_s *fields = &tmp_6545_->payload.variant5._3;
                succ_4391_ &= true;
                if (succ_4391_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            ((((((*fields).elements))[(j)]).type) = ((((((*fields).elements))[(j)]).type) - ((count_offset)((&(remove)), (((((*fields).elements))[(j)]).type)))));
                        }
                    }
                    goto after_6545;
                }
            }
            {
                succ_4400_ &= (tmp_6545_->tag == 6);
                succ_4400_ &= true;
                succ_4400_ &= true;
                succ_4400_ &= true;
                UnionVariantTypeInfoList_s *variants = &tmp_6545_->payload.variant6._3;
                succ_4400_ &= true;
                if (succ_4400_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                            bool succ_4407_ = true;
                            bool succ_4412_ = true;
                            bool succ_4419_ = true;

                            UnionVariantTypeInfo_u *tmp_6532_ = (var);
                            {
                                succ_4407_ &= (tmp_6532_->tag == 0);
                                succ_4407_ &= true;
                                if (succ_4407_) {
                                    {
                                    }
                                    goto after_6532;
                                }
                            }
                            {
                                succ_4412_ &= (tmp_6532_->tag == 1);
                                succ_4412_ &= true;
                                TypeInfoList_s *fields = &tmp_6532_->payload.variant1._1;
                                succ_4412_ &= true;
                                if (succ_4412_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            (((((*fields).elements))[(k)]) = (((((*fields).elements))[(k)]) - ((count_offset)((&(remove)), ((((*fields).elements))[(k)])))));
                                        }
                                    }
                                    goto after_6532;
                                }
                            }
                            {
                                succ_4419_ &= (tmp_6532_->tag == 2);
                                succ_4419_ &= true;
                                FieldTypeInfoList_s *fields = &tmp_6532_->payload.variant2._1;
                                succ_4419_ &= true;
                                if (succ_4419_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            ((((((*fields).elements))[(k)]).type) = ((((((*fields).elements))[(k)]).type) - ((count_offset)((&(remove)), (((((*fields).elements))[(k)]).type)))));
                                        }
                                    }
                                    goto after_6532;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablerN)());
                                    }
                                    goto after_6532;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_6532:
                            (void)0; // error: label at end of compound statement is a C23 extension
                        }
                    }
                    goto after_6545;
                }
            }
            {
                succ_4426_ &= (tmp_6545_->tag == 1);
                succ_4426_ &= true;
                if (succ_4426_) {
                    {
                    }
                    goto after_6545;
                }
            }
            {
                succ_4429_ &= (tmp_6545_->tag == 0);
                if (succ_4429_) {
                    {
                    }
                    goto after_6545;
                }
            }
            {
                succ_4436_ &= (tmp_6545_->tag == 8);
                succ_4436_ &= true;
                succ_4436_ &= true;
                succ_4436_ &= true;
                TypeInfoList_s *elements = &tmp_6545_->payload.variant8._3;
                succ_4436_ &= true;
                if (succ_4436_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            (((((*elements).elements))[(j)]) = (((((*elements).elements))[(j)]) - ((count_offset)((&(remove)), ((((*elements).elements))[(j)])))));
                        }
                    }
                    goto after_6545;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when removing")));
                    }
                    goto after_6545;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_6545:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        ((table) = (new_table));
        if (((table).length) == (length))
            break;
        ((length) = ((table).length));
    }

    return (table);
}
bool generateTypeInfoTablePS9562PS7132PS1892rB(IRGen_s *this, IRFunc_s *function, ParsedFile_s *project) {
    SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    ParsedFile_s *ti_file = ((getFileByFileNameS7720rPS1892)((FILE)));
    if ((ti_file) == (NULL)) {
        return (true);
    }

    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(NAME))));
    ((assertBPcrN)(((context) != (NULL)), ("generateTypeInfoTable: Could not find union context for TypeInfo")));
    ParsedFile_s *file = ((getParentFilePS0997rPS1892)(((context)->global)));
    for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
        if ((tli)->ignored)
            continue;
        if (((tli)->kind) == (TLI_VAR_DECL)) {
            ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)))));
            (((tli)->ignored) = (true));
        }
    }

    TypeInfoTable_s table = ((generateTypeInfoTablerS3131)());
    Type_u *t = ((intoArrayTypePU5175uszrPU5175)(((context)->type), ((table).length)));
    ((assertBPcrN)((((getSizeInBytesPU5175rusz)((t))) == ((sizeof(TypeInfo_u)) * ((table).length))), ("Size mismatch")));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
    ((buildCreateArrayPS7132S8951S6939rN)((function), (((context)->global)->span), (reg)));
    RegIndex_s global_table = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
    ((buildAllocaPS7132S8951S6939uszrN)((function), (((context)->global)->span), (global_table), ((getSizeInBytesPU5175rusz)((t)))));
    ((buildStorePS7132S8951S6939S6939rN)((function), (((context)->global)->span), (global_table), (reg)));
    bool isGlobal = (false);
    IRScopeEntry_s *global_type_info_table = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((newSubStrOfStrLitPcrS7720)(("type_info_table")))), (&(isGlobal))));
    ((assertBPcrN)(((global_type_info_table) != (NULL)), ("Could not find global type info table variable")));
    ((buildStorePS7132S8951S6939S6939rN)((function), (((context)->global)->span), ((global_type_info_table)->ptr), (global_table)));
    (((this)->type_info_table) = (table));
    (((this)->type_info_array_register) = (global_table));
    return (true);
}
none _anon_26_2PS7132S8951S6939S6939uszS6939rN(IRFunc_s *function, Span_s span, RegIndex_s ptr, RegIndex_s tmp, usize byte_offset, RegIndex_s val) {
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tmp), (usizeType), (byte_offset)));
    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (ptr), (ptr)));
    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (ptr)));
    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tmp), (val)));
}
RegIndex_s _anon_26_3PS9562PS7132S8951PU5175uszrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *ti, usize len) {
    Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (ti), ._1 = (len)}}})));
    Type_u *arrTypPtr = ((intoPointerPU5175rPU5175)((typ)));
    Type_u *pt = ((intoPointerPU5175rPU5175)((ti)));
    RegIndex_s local = ((allocateRegisterPS7132PU5175rS6939)((function), (pt)));
    usize s = ((getSizeInBytesPU5175rusz)((ti)));
    RegIndex_s arrAlloc = ((allocateRegisterPS7132PU5175rS6939)((&((this)->globalScope)), (arrTypPtr)));
    ((buildAllocaPS7132S8951S6939uszrN)((&((this)->globalScope)), (span), (arrAlloc), ((s) * (len))));
    RegIndex_s arrReg = ((allocateRegisterPS7132PU5175rS6939)((&((this)->globalScope)), (typ)));
    ((buildLoadBlankPS7132S8951S6939uszrN)((&((this)->globalScope)), (span), (arrReg), ((s) * (len))));
    ((buildStorePS7132S8951S6939S6939rN)((&((this)->globalScope)), (span), (arrAlloc), (arrReg)));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (local), (arrAlloc)));
    ((arrReg) = ((allocateRegisterPS7132PU5175rS6939)((function), (typ))));
    ((buildLoadBlankPS7132S8951S6939uszrN)((function), (span), (arrReg), ((s) * (len))));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (local), (arrReg)));
    return (local);
}
bool generateRuntimeTypeInfoPS9562rB(IRGen_s *this) {
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    SubStr_s TI = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FTI = ((BUILD_A_KEYWORDPcrS7720)(("FieldTypeInfo")));
    SubStr_s UVTI = ((BUILD_A_KEYWORDPcrS7720)(("UnionVariantTypeInfo")));
    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(TI))));
    ((assertBPcrN)(((context) != (NULL)), ("generateRuntimeInitialization: Could not find union context for TypeInfo")));
    StructLookup_s *_fieldTypeInfo = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)(((this)->lookup), (&(FILE)), (&(FTI))));
    ((assertBPcrN)(((_fieldTypeInfo) != (NULL)), ("generateRuntimeInitialization: Could not find context for FieldTypeInfo")));
    UnionLookup_s *_unionVariantTypeInfo = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(UVTI))));
    ((assertBPcrN)(((_unionVariantTypeInfo) != (NULL)), ("generateRuntimeInitialization: Could not find context for UnionVariantTypeInfo")));
    Type_u *fieldTypeInfo = ((_fieldTypeInfo)->type);
    Type_u *unionVariantTypeInfo = ((_unionVariantTypeInfo)->type);
    Span_s span = (((context)->global)->span);
    IRFunc_s *function = (&((this)->initRuntime));
    Type_u *typeInfoPtr = ((intoPointerPU5175rPU5175)(((context)->type)));
    Type_u *u8Type = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    Type_u *charPtrType =
        ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})));
    Type_u *fieldTypeInfoPtr = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (fieldTypeInfo)}}})));
    RegIndex_s global_table = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfoPtr)));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (global_table), ((this)->type_info_array_register)));
    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfoPtr)));
    RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (u8Type)));
    RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(indices)), (index)));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (charPtrType)));
    RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s ftiReg = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldTypeInfo)));
    RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldTypeInfo)))));
    RegIndex_s variantPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((unionVariantTypeInfo)))));
    RegIndex_s field_index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s field_indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(field_indices)), (field_index)));
    RegIndex_s variant_index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s variant_indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(variant_indices)), (variant_index)));
    none (*write_at_offset)(IRFunc_s *, Span_s, RegIndex_s, RegIndex_s, usize, RegIndex_s) = (_anon_26_2PS7132S8951S6939S6939uszS6939rN);
    RegIndex_s (*alloc_list)(IRGen_s *, IRFunc_s *, Span_s, Type_u *, usize) = (_anon_26_3PS9562PS7132S8951PU5175uszrS6939);
    for (usize i = ((usize)(0llu)); ((i) < (((this)->type_info_table).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (i)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (elemPtr), (global_table), (indices)));
        TypeInfo_u *info = (&(((((this)->type_info_table).elements))[(i)]));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (u8Type), ((usize)(((tagAnyru8)((info)))))));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(0llu)), (tagReg)));
        SubStr_s name = ((get_namePU7843rS7720)((info)));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (name)));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(1llu)), (reg)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((name).len)));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(9llu)), (index)));
        bool succ_4515_ = true;
        bool succ_4520_ = true;
        bool succ_4525_ = true;
        bool succ_4531_ = true;
        bool succ_4541_ = true;
        bool succ_4552_ = true;
        bool succ_4585_ = true;
        bool succ_4592_ = true;
        bool succ_4598_ = true;

        TypeInfo_u *tmp_6799_ = (info);
        {
            succ_4515_ &= (tmp_6799_->tag == 4);
            succ_4515_ &= true;
            usize *size_in_bytes = &tmp_6799_->payload.variant4._1;
            succ_4515_ &= true;
            usize *align_in_bytes = &tmp_6799_->payload.variant4._2;
            succ_4515_ &= true;
            usize *elem = &tmp_6799_->payload.variant4._3;
            succ_4515_ &= true;
            usize *elem_count = &tmp_6799_->payload.variant4._4;
            succ_4515_ &= true;
            if (succ_4515_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*elem)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*elem_count)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4520_ &= (tmp_6799_->tag == 3);
            succ_4520_ &= true;
            usize *underlying = &tmp_6799_->payload.variant3._1;
            succ_4520_ &= true;
            if (succ_4520_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*underlying)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4525_ &= (tmp_6799_->tag == 2);
            succ_4525_ &= true;
            usize *underlying = &tmp_6799_->payload.variant2._1;
            succ_4525_ &= true;
            if (succ_4525_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*underlying)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4531_ &= (tmp_6799_->tag == 7);
            succ_4531_ &= true;
            TypeInfoList_s *args = &tmp_6799_->payload.variant7._1;
            succ_4531_ &= true;
            usize *ret = &tmp_6799_->payload.variant7._2;
            succ_4531_ &= true;
            if (succ_4531_) {
                {
                    RegIndex_s local_args = ((alloc_list)((this), (function), (span), (usizeType), ((*args).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_args), (field_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*args).elements))[(j)])));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                    }

                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (local_args)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*args).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (field_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*ret)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4541_ &= (tmp_6799_->tag == 5);
            succ_4541_ &= true;
            usize *size_in_bytes = &tmp_6799_->payload.variant5._1;
            succ_4541_ &= true;
            usize *align_in_bytes = &tmp_6799_->payload.variant5._2;
            succ_4541_ &= true;
            FieldTypeInfoList_s *fields = &tmp_6799_->payload.variant5._3;
            succ_4541_ &= true;
            if (succ_4541_) {
                {
                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (fieldTypeInfo), ((*fields).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                        SubStr_s fieldName = (((((*fields).elements))[(j)]).name);
                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (fieldName)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (reg)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((fieldName).len)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(8llu)), (index)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(j)]).type)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(16llu)), (index)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(j)]).offset_in_bytes)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(24llu)), (index)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (field_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_fields)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*fields).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (field_index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4552_ &= (tmp_6799_->tag == 6);
            succ_4552_ &= true;
            usize *size_in_bytes = &tmp_6799_->payload.variant6._1;
            succ_4552_ &= true;
            usize *align_in_bytes = &tmp_6799_->payload.variant6._2;
            succ_4552_ &= true;
            UnionVariantTypeInfoList_s *variants = &tmp_6799_->payload.variant6._3;
            succ_4552_ &= true;
            if (succ_4552_) {
                {
                    RegIndex_s local_variants = ((alloc_list)((this), (function), (span), (unionVariantTypeInfo), ((*variants).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (variantPtr), (local_variants), (variant_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (u8Type), ((usize)(((tagAnyru8)((var)))))));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(0llu)), (tagReg)));
                        SubStr_s variantName = ((get_namePU0081rS7720)((var)));
                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (variantName)));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(1llu)), (reg)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((variantName).len)));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(9llu)), (index)));
                        bool succ_4561_ = true;
                        bool succ_4566_ = true;
                        bool succ_4574_ = true;

                        UnionVariantTypeInfo_u *tmp_6762_ = (var);
                        {
                            succ_4561_ &= (tmp_6762_->tag == 0);
                            succ_4561_ &= true;
                            if (succ_4561_) {
                                {
                                }
                                goto after_6762;
                            }
                        }
                        {
                            succ_4566_ &= (tmp_6762_->tag == 1);
                            succ_4566_ &= true;
                            TypeInfoList_s *fields = &tmp_6762_->payload.variant1._1;
                            succ_4566_ &= true;
                            if (succ_4566_) {
                                {
                                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (usizeType), ((*fields).length)));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (k)));
                                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*fields).elements))[(k)])));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                                    }

                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(17llu)), (local_fields)));
                                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*fields).length)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(25llu)), (variant_index)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(33llu)), (variant_index)));
                                }
                                goto after_6762;
                            }
                        }
                        {
                            succ_4574_ &= (tmp_6762_->tag == 2);
                            succ_4574_ &= true;
                            FieldTypeInfoList_s *fields = &tmp_6762_->payload.variant2._1;
                            succ_4574_ &= true;
                            if (succ_4574_) {
                                {
                                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (fieldTypeInfo), ((*fields).length)));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (k)));
                                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                                        SubStr_s fieldName = (((((*fields).elements))[(k)]).name);
                                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (fieldName)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (reg)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((fieldName).len)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(8llu)), (index)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(k)]).type)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(16llu)), (index)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(k)]).offset_in_bytes)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(24llu)), (index)));
                                    }

                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(17llu)), (local_fields)));
                                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*fields).length)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(25llu)), (variant_index)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(33llu)), (variant_index)));
                                }
                                goto after_6762;
                            }
                        }
                        {
                            if (true) {
                                {
                                    ((unreachablerN)());
                                }
                                goto after_6762;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_6762:
                        (void)0; // error: label at end of compound statement is a C23 extension
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (variant_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (variant_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_variants)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*variants).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (variant_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (variant_index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4585_ &= (tmp_6799_->tag == 1);
            succ_4585_ &= true;
            usize *size_in_bytes = &tmp_6799_->payload.variant1._1;
            succ_4585_ &= true;
            usize *align_in_bytes = &tmp_6799_->payload.variant1._2;
            succ_4585_ &= true;
            if (succ_4585_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4592_ &= (tmp_6799_->tag == 8);
            succ_4592_ &= true;
            usize *size_in_bytes = &tmp_6799_->payload.variant8._1;
            succ_4592_ &= true;
            usize *align_in_bytes = &tmp_6799_->payload.variant8._2;
            succ_4592_ &= true;
            TypeInfoList_s *elements = &tmp_6799_->payload.variant8._3;
            succ_4592_ &= true;
            if (succ_4592_) {
                {
                    RegIndex_s local_elements = ((alloc_list)((this), (function), (span), (usizeType), ((*elements).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_elements), (field_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*elements).elements))[(j)])));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_elements)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*elements).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (field_index)));
                }
                goto after_6799;
            }
        }
        {
            succ_4598_ &= (tmp_6799_->tag == 0);
            if (succ_4598_) {
                {
                }
                goto after_6799;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateRuntimeTypeInfo: Exhaustive handling of Type kinds")));
                }
                goto after_6799;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6799:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    return (true);
}
bool generateRuntimeInitializationPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    (((this)->initRuntime) = ((IRFunc_s){.name = (((newReadonlyStringPcrS0540)((".init_runtime"))))}));
    usize scope = ((enterScopePS7132rusz)((&((this)->initRuntime))));
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((&((this)->initRuntime))));
    ((setCurrentBlockPS7132S7192rN)((&((this)->initRuntime)), (entry)));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    ParsedFile_s *ti_file = ((getFileByFileNameS7720rPS1892)((FILE)));
    if ((ti_file) != (NULL)) {
        if (!((generateRuntimeTypeInfoPS9562rB)((this))))
            return (false);
    }

    ((buildReturnEmptyPS7132S8951rN)((&((this)->initRuntime)), (((project)->mod)->span)));
    return (true);
}
bool generateBytecodePS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    if (!((fillLookupPS9562PS1892rB)((this), (project))))
        return (false);
    usize scope = ((enterScopePS7132rusz)((&((this)->globalScope))));
    ((assertBPcrN)((((((this)->globalScope).scopes).length) == ((usize)(1llu))), ("Expected only one valid scope")));
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((&((this)->globalScope))));
    ((setCurrentBlockPS7132S7192rN)((&((this)->globalScope)), (entry)));
    if (!((generateTypeInfoTablePS9562PS7132PS1892rB)((this), (&((this)->globalScope)), (project))))
        return (false);
    if (!((generateRuntimeInitializationPS9562PS1892rB)((this), (project))))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (&((this)->globalScope)), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)))));
            }
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFuncDecl_s *fn = ((atPS4111uszrPS4904)((&(funcDecls)), (i)));
        ((generateFunctionPS9562PS4904rN)((this), (fn)));
    }

    if (*((flags).emitBIR)) {
        ((dumpInstructionsPS7132rN)((&((this)->globalScope))));
        ((dumpInstructionsPS7132rN)((&((this)->initRuntime))));
        IRFuncList_s fns = ((asListPS2612rS8040)((&((this)->functions))));
        for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ((dumpInstructionsPS7132rN)(((atPS8040uszrPS7132)((&(fns)), (i)))));
        }

        ((dropPS8040rN)((&(fns))));
    }

    return (!((this)->error));
}
none generateFunctionHeaderPS9562PS7132PU5175PS9803rN(IRGen_s *this, IRFunc_s *function, Type_u *retType, ParamContext_s *params) {
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((function)));
    ((setCurrentBlockPS7132S7192rN)((function), (entry)));
    if ((hasAttributePS4904U4360rB)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->originalID))), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))))
        return;
    usize offset = ((usize)(0llu));
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        ((offset) = ((usize)(1llu)));
        ((prepareParameterPS9562PS7132uszS8951S7720PU5175BrN)((this), (function), ((usize)(0llu)), ((Span_s){0}), ((newSubStrOfStrLitPcrS7720)(("ret"))), ((intoPointerPU5175rPU5175)((retType))),
                                                              (true)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((params)->paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((params), (i)));
        ParsedTypeNode_s *typDecl = ((getTypeAtIndexPS9803uszrPS1372)((params), (i)));
        Type_u *pType = ((getTypePU9661rPU5175)((&((typDecl)->typeState))));
        ((prepareParameterPS9562PS7132uszS8951S7720PU5175BrN)((this), (function), ((i) + (offset)), ((name).span), ((name).content), (pType), (false)));
    }
}
RegIndexList_s _anon_26_4PS7132PS4904rS9911(IRFunc_s *function, ParsedFuncDecl_s *fn) {
    RegIndexList_s args = ((RegIndexList_s){0});
    RegIndex_s reg =
        ((allocateRegisterPS7132PU5175rS6939)((function),
                                              ((wrapU5175rPU5175)(((Type_u){
                                                  .tag = 4,
                                                  .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})))));
    String_s name = ((toStringPS7720rS0540)((&(((fn)->name).content))));
    ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((function)->span), (reg), ((asSubStrPS0540rS7720)((&(name))))));
    ((pushPS9911S6939rN)((&(args)), (reg)));
    return (args);
}
none generateFunctionBodyPS9562PS7132PS7247PS1372rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *body, ParsedTypeNode_s *retTypeNode) {
    Type_u *retType = ((getTypePU9661rPU5175)((&((retTypeNode)->typeState))));
    bool isNakedFn = ((hasAttributePS4904U4360rB)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->originalID))), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))));
    if ((((function)->returnBlockID).i) == ((usize)(0llu))) {
        IRBlockID_s curr = ((getCurrentBlockPS7132rS7192)((function)));
        (((function)->returnBlockID) = ((appendBlockPS7132rS7192)((function))));
        if ((isNonePU5175rB)((retType))) {
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            ((buildReturnEmptyPS7132S8951rN)((function), ((retTypeNode)->span)));
            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else if (isNakedFn) {
            ((assertBPcrN)((((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(8llu))), ("Naked functions can only return types that fit into a register")));
            RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            ((buildLoadBlankPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), (reg), ((getSizeInBytesPU5175rusz)((retType)))));
            ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (reg)));
            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else {
            (((function)->returnAlloc) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType))))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), ((function)->returnAlloc), ((getSizeInBytesPU5175rusz)((retType)))));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            RegIndex_s result = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (result), ((function)->returnAlloc)));
            if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
                ((buildStorePS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), ((function)->retPtr), (result)));
                ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), ((function)->retPtr)));
            }

            else {
                if ((isStructPU5175rB)((retType))) {
                    RegIndex_s v = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), ((getSizeInBytesPU5175rusz)((retType)))));
                    Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (v)))->typ);
                    RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    usize s = ((getSizeInBytesPU5175rusz)((t)));
                    ((assertBrN)(((s) <= ((usize)(8llu)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), (r), (s)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (r), (result)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (v), (r)));
                    ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (v)));
                }

                else {
                    ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (result)));
                }
            }

            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }
    }

    if (*((flags).trace)) {
        ParsedFuncDecl_s *fn = ((getFuncNodePS7132rPS4904)((function)));
        SubStr_s tmp_36476 = ((newSubStrOfStrLitPcrS7720)(("traceEnter")));

        bool isEnter = ((equalsPS7720PS7720rB)((&(((fn)->name).content)), (&tmp_36476)));
        SubStr_s tmp_36488 = ((newSubStrOfStrLitPcrS7720)(("traceLeave")));

        bool isLeave = ((equalsPS7720PS7720rB)((&(((fn)->name).content)), (&tmp_36488)));
        RegIndexList_s (*init)(IRFunc_s *, ParsedFuncDecl_s *) = (_anon_26_4PS7132PS4904rS9911);
        if ((!(isEnter)) && (!(isLeave))) {
            usize funcID = ((usize)(0llu));
            RegIndexList_s args = ((RegIndexList_s){0});
            ((funcID) = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("traceEnterPcrN"), ("trace.bufo"))));
            ((args) = ((init)((function), (fn))));
            ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                         ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
            ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
            ((funcID) = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("traceLeavePcrN"), ("trace.bufo"))));
            IRBlockID_s curr = ((getCurrentBlockPS7132rS7192)((function)));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            IRBlock_s *block = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
            if ((isTerminatedPS9435rB)((block))) {
                IRInstr_s term = (*((popPS0124rPS7680)((&((block)->instructions)))));
                ((args) = ((init)((function), (fn))));
                ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                             ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
                ((pushPS0124S7680rN)((&((block)->instructions)), (term)));
            }

            else {
                ((args) = ((init)((function), (fn))));
                ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                             ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
            }

            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else {
            ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
        }

    }

    else {
        ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
    }

    IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
    if (!((isTerminatedPS9435rB)((curr)))) {
        if (((isNonePU5175rB)((retType))) || (isNakedFn)) {
            ((buildBrPS7132S8951S7192rN)((function), ((body)->span), ((function)->returnBlockID)));
        }

        else {
            ((buildUnterminatedPS7132S8951rN)((function), ((body)->span)));
        }
    }

    usize after = ((leaveScopePS7132rusz)((function)));
    ((assertBPcrN)(((after) == ((usize)(1llu))), ("Scope imbalance detected")));
}
none generateFunctionPS9562PS4904rN(IRGen_s *this, ParsedFuncDecl_s *funcDecl) {
    if ((funcDecl)->ignored)
        return;
    ((assertBPcrN)(((isSuccessPU9661rB)((&((funcDecl)->typeState)))), ("Expected valid FuncDecl type in IRGen")));
    String_s name = ((getMangledNamePS4904rS0540)((funcDecl)));
    IRFunc_s *function = ((getPS2612PS0540rPS7132)((&((this)->functions)), (&(name))));
    ((assertBPcrN)(((function) != (NULL)), ("Expected to find function in lookup")));
    ((assertBPcrN)(((equalsPS0540PS0540rB)((&((function)->name)), (&(name)))), ("functions.get() retrieved wrong IRFunc")));
    ((dropPS0540rN)((&(name))));
    if ((isExternPS4904rB)((funcDecl))) {
        return;
    }

    usize scope = ((enterScopePS7132rusz)((function)));
    ((assertBPcrN)(((scope) == ((usize)(1llu))), ("Expected function to enter first scope")));
    ParsedTypeNode_s *retDecl = ((funcDecl)->retType);
    ((generateFunctionHeaderPS9562PS7132PU5175PS9803rN)((this), (function), ((getTypePU9661rPU5175)((&((retDecl)->typeState)))), (&((funcDecl)->params))));
    ((generateFunctionBodyPS9562PS7132PS7247PS1372rN)((this), (function), ((funcDecl)->body), ((funcDecl)->retType)));
}
none generateBytecodeBlockPS9562PS7132PS7247rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *block) {
    if ((block)->ignored)
        return;
    ((assertBPcrN)(((isSuccessPU9661rB)((&((block)->typeState)))), ("Expected valid Block type in IRGen")));
    usize scope = ((enterScopePS7132rusz)((function)));
    ParsedFuncDecl_s *f = ((getFuncNodePS7132rPS4904)((function)));
    for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStmt_s *stmt = ((getStmtAtIndexPS7247uszrPS1100)((block), (i)));
        ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
        IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
        if ((isTerminatedPS9435rB)((curr))) {
            if ((i) != (((block)->stmtLength) - ((usize)(1llu)))) {
                Span_s tmp_36855 = (((getStmtAtIndexPS7247uszrPS1100)((block), ((i) + ((usize)(1llu)))))->span);

                String_s loc = ((toStringPS8951rS0540)((&tmp_36855)));
                (((fprintf))((stderr_), ("%s: %s: Unreachable code.\n"), ((loc).buffer), (WARN_STR)));
                ((dropPS0540rN)((&(loc))));
            }

            break;
        }
    }

    usize after = ((leaveScopePS7132rusz)((function)));
    ((assertBPcrN)(((scope) == (after)), ("Scope imbalance detected")));
}
none generateBytecodeStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *stmt) {
    bool succ_4694_ = true;
    bool succ_4706_ = true;
    bool succ_4710_ = true;
    bool succ_4718_ = true;
    bool succ_4722_ = true;
    bool succ_4727_ = true;
    bool succ_4738_ = true;
    bool succ_4760_ = true;
    bool succ_4776_ = true;
    bool succ_4792_ = true;
    bool succ_4819_ = true;
    bool succ_4836_ = true;
    bool succ_4847_ = true;
    bool succ_4850_ = true;
    bool succ_4856_ = true;
    bool succ_4861_ = true;

    StmtData_u *tmp_7266_ = (&((stmt)->data));
    {
        succ_4694_ &= (tmp_7266_->tag == 0);
        VarDecl_s *decl = &tmp_7266_->payload.variant0._0;
        succ_4694_ &= true;
        if (succ_4694_) {
            {
                ParsedExpr_s *expr = ((*decl).expr);
                if ((*decl).isComptime)
                    ((startComptimePS7132rN)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (result), ((*decl).pat), (false), ((*decl).isComptime)));
                if (((*decl).trampoline) != (NULL)) {
                    IRBlockID_s trampoline = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), (((*decl).trampoline)->span), (patReg), (after), (trampoline)));
                    ((setCurrentBlockPS7132S7192rN)((function), (trampoline)));
                    ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), ((*decl).trampoline)));
                    IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                    if (!((isTerminatedPS9435rB)((curr)))) {
                        String_s loc = ((toStringPS8951rS0540)((&(((*decl).trampoline)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Trampolines must always terminate.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        (((this)->error) = (true));
                    }

                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                if ((*decl).isComptime)
                    ((endComptimePS7132rN)((function)));
            }
            goto after_7266;
        }
    }
    {
        succ_4706_ &= (tmp_7266_->tag == 1);
        if (succ_4706_) {
            {
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), ((function)->returnBlockID)));
            }
            goto after_7266;
        }
    }
    {
        succ_4710_ &= (tmp_7266_->tag == 2);
        ParsedExpr_s **expr = &tmp_7266_->payload.variant2._0;
        succ_4710_ &= true;
        if (succ_4710_) {
            {
                Type_u *typ = ((getTypePU9661rPU5175)((&((*expr)->typeState))));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((stmt)->span), ((function)->returnAlloc), (result)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), ((function)->returnBlockID)));
            }
            goto after_7266;
        }
    }
    {
        succ_4718_ &= (tmp_7266_->tag == 3);
        ParsedExpr_s **expr = &tmp_7266_->payload.variant3._0;
        succ_4718_ &= true;
        if (succ_4718_) {
            {
                ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
            }
            goto after_7266;
        }
    }
    {
        succ_4722_ &= (tmp_7266_->tag == 4);
        ParsedBlock_s **block = &tmp_7266_->payload.variant4._0;
        succ_4722_ &= true;
        if (succ_4722_) {
            {
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
            }
            goto after_7266;
        }
    }
    {
        succ_4727_ &= (tmp_7266_->tag == 5);
        ParsedExpr_s **cond = &tmp_7266_->payload.variant5._0;
        succ_4727_ &= true;
        ParsedStmt_s **then = &tmp_7266_->payload.variant5._1;
        succ_4727_ &= true;
        if (succ_4727_) {
            {
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                IRBlockID_s thenBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s contBlock = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (thenBlock), (contBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (thenBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*then)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (contBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (contBlock)));
            }
            goto after_7266;
        }
    }
    {
        succ_4738_ &= (tmp_7266_->tag == 6);
        ParsedExpr_s **cond = &tmp_7266_->payload.variant6._0;
        succ_4738_ &= true;
        ParsedStmt_s **then = &tmp_7266_->payload.variant6._1;
        succ_4738_ &= true;
        ParsedStmt_s **elze = &tmp_7266_->payload.variant6._2;
        succ_4738_ &= true;
        if (succ_4738_) {
            {
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                IRBlockID_s thenBlockID = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s elzeBlockID = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (thenBlockID), (elzeBlockID)));
                ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*then)));
                ((thenBlockID) = ((getCurrentBlockPS7132rS7192)((function))));
                ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*elze)));
                ((elzeBlockID) = ((getCurrentBlockPS7132rS7192)((function))));
                IRBlock_s *thenBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (thenBlockID)));
                IRBlock_s *elzeBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (elzeBlockID)));
                bool thenTerm = ((isTerminatedPS9435rB)((thenBlock)));
                bool elseTerm = ((isTerminatedPS9435rB)((elzeBlock)));
                if ((thenTerm) && (elseTerm)) {
                }

                else if ((thenTerm) && (!(elseTerm))) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else if ((!(thenTerm)) && (elseTerm)) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }
            }
            goto after_7266;
        }
    }
    {
        succ_4760_ &= (tmp_7266_->tag == 7);
        ParsedExpr_s **cond = &tmp_7266_->payload.variant7._0;
        succ_4760_ &= true;
        ParsedStmt_s **body = &tmp_7266_->payload.variant7._1;
        succ_4760_ &= true;
        if (succ_4760_) {
            {
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (condBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*body)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
            }
            goto after_7266;
        }
    }
    {
        succ_4776_ &= (tmp_7266_->tag == 13);
        ParsedPattern_s **pat = &tmp_7266_->payload.variant13._0;
        succ_4776_ &= true;
        ParsedExpr_s **expr = &tmp_7266_->payload.variant13._1;
        succ_4776_ &= true;
        ParsedBlock_s **block = &tmp_7266_->payload.variant13._2;
        succ_4776_ &= true;
        if (succ_4776_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                IRBlockID_s jump = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (jump), (after)));
                ((setCurrentBlockPS7132S7192rN)((function), (jump)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (after)));
                ((leaveScopePS7132rusz)((function)));
            }
            goto after_7266;
        }
    }
    {
        succ_4792_ &= (tmp_7266_->tag == 14);
        ParsedPattern_s **pat = &tmp_7266_->payload.variant14._0;
        succ_4792_ &= true;
        ParsedExpr_s **expr = &tmp_7266_->payload.variant14._1;
        succ_4792_ &= true;
        ParsedBlock_s **block = &tmp_7266_->payload.variant14._2;
        succ_4792_ &= true;
        ParsedBlock_s **elze = &tmp_7266_->payload.variant14._3;
        succ_4792_ &= true;
        if (succ_4792_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                IRBlockID_s jumpTrue = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s jumpFalse = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (jumpTrue), (jumpFalse)));
                ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                ((jumpTrue) = ((getCurrentBlockPS7132rS7192)((function))));
                ((leaveScopePS7132rusz)((function)));
                ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*elze)));
                ((jumpFalse) = ((getCurrentBlockPS7132rS7192)((function))));
                IRBlock_s *jumpTrueBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (jumpTrue)));
                IRBlock_s *jumpFalseBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (jumpFalse)));
                bool jumpTrueTerm = ((isTerminatedPS9435rB)((jumpTrueBlock)));
                bool jumpFalseTerm = ((isTerminatedPS9435rB)((jumpFalseBlock)));
                if ((jumpTrueTerm) && (jumpFalseTerm)) {
                }

                else if ((jumpTrueTerm) && (!(jumpFalseTerm))) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else if ((!(jumpTrueTerm)) && (jumpFalseTerm)) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }
            }
            goto after_7266;
        }
    }
    {
        succ_4819_ &= (tmp_7266_->tag == 15);
        ParsedPattern_s **pat = &tmp_7266_->payload.variant15._0;
        succ_4819_ &= true;
        ParsedExpr_s **expr = &tmp_7266_->payload.variant15._1;
        succ_4819_ &= true;
        ParsedBlock_s **block = &tmp_7266_->payload.variant15._2;
        succ_4819_ &= true;
        if (succ_4819_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (condBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
                ((leaveScopePS7132rusz)((function)));
            }
            goto after_7266;
        }
    }
    {
        succ_4836_ &= (tmp_7266_->tag == 8);
        ParsedStmt_s **init = &tmp_7266_->payload.variant8._0;
        succ_4836_ &= true;
        ParsedExpr_s **cond = &tmp_7266_->payload.variant8._1;
        succ_4836_ &= true;
        ParsedExpr_s **step = &tmp_7266_->payload.variant8._2;
        succ_4836_ &= true;
        ParsedStmt_s **body = &tmp_7266_->payload.variant8._3;
        succ_4836_ &= true;
        if (succ_4836_) {
            {
                IRBlockID_s initBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s stepBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (stepBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (initBlock)));
                usize scope = ((enterScopePS7132rusz)((function)));
                ((setCurrentBlockPS7132S7192rN)((function), (initBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*init)));
                if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((*init)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((*cond)->span), (condReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (stepBlock)));
                ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*step), (false)));
                ((buildBrPS7132S8951S7192rN)((function), ((*step)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*body)));
                if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((*body)->span), (stepBlock)));
                }

                usize after = ((leaveScopePS7132rusz)((function)));
                ((assertBPcrN)(((scope) == (after)), ("Scope imbalance in for-loop")));
                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
            }
            goto after_7266;
        }
    }
    {
        succ_4847_ &= (tmp_7266_->tag == 9);
        if (succ_4847_) {
            {
                if (!((buildBreakPS7132S8951rB)((function), ((stmt)->span)))) {
                    ((todo_with_msgPcrN)(("break outside of loop")));
                }
            }
            goto after_7266;
        }
    }
    {
        succ_4850_ &= (tmp_7266_->tag == 10);
        if (succ_4850_) {
            {
                if (!((buildContinuePS7132S8951rB)((function), ((stmt)->span)))) {
                    ((todo_with_msgPcrN)(("continue outside of loop")));
                }
            }
            goto after_7266;
        }
    }
    {
        succ_4856_ &= (tmp_7266_->tag == 11);
        succ_4856_ &= true;
        succ_4856_ &= true;
        succ_4856_ &= true;
        if (succ_4856_) {
            {
                ((generateBytecodeMatchStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
            }
            goto after_7266;
        }
    }
    {
        succ_4861_ &= (tmp_7266_->tag == 12);
        ParsedExpr_s **fn = &tmp_7266_->payload.variant12._0;
        succ_4861_ &= true;
        ParsedExprList_s *args = &tmp_7266_->payload.variant12._1;
        succ_4861_ &= true;
        if (succ_4861_) {
            {
                Type_u *retType = ((getReturnTypePU5175rPU5175)(((getTypePU9661rPU5175)((&((*fn)->typeState))))));
                ((assertBPcrN)((((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))), ("Expected Inline Assembly function to return ASMContext")));
                RegIndexList_s irArgs = ((RegIndexList_s){0});
                RegIndex_s retPtr = ((RegIndex_s){0});
                {
                    ((retPtr) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType))))));
                    ((startComptimePS7132rN)((function)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((stmt)->span), (retPtr), ((getSizeInBytesPU5175rusz)((retType)))));
                    ((endComptimePS7132rN)((function)));
                    ((pushPS9911S6939rN)((&(irArgs)), (retPtr)));
                }

                SubStr_s IR_VALUE = ((BUILD_A_KEYWORDPcrS7720)(("IRValue")));
                SubStr_s ASM_FILE = ((BUILD_A_KEYWORDPcrS7720)(("asm.bufo")));
                TypeLookup_s lookup = ((TypeLookup_s){0});
                TypeLookupList_s unions = ((searchAllFilesForTypeNamePS7791PS7720rS1581)(((this)->lookup), (&(IR_VALUE))));
                UnionLookup_s *context = (NULL);
                for (usize i = ((usize)(0llu)); ((i) < ((unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    TypeLookup_s *l = ((atPS1581uszrPS6177)((&(unions)), (i)));
                    if (((l)->kind) == (TYPE_LOOKUP_UNION)) {
                        UnionLookup_s *u = ((UnionLookup_s *)(((l)->actual)));
                        ParsedUnionDecl_s *decl = ((u)->global);
                        if (!(((decl)->parent).isFile))
                            continue;
                        ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
                        String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
                        String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
                        ((dropPS0540rN)((&(filePath))));
                        SubStr_s tmp_37868 = ((asSubStrPS0540rS7720)((&(fileName))));

                        if ((equalsPS7720PS7720rB)((&tmp_37868), (&(ASM_FILE)))) {
                            ((assertBPcrN)(((context) == (NULL)), ("How did we find another asm.bufo?")));
                            ((context) = (u));
                        }

                        ((dropPS0540rN)((&(fileName))));
                    }
                }

                ((assertBPcrN)(((context) != (NULL)), ("Could not find IRValue!")));
                Type_u *regValueType = ((context)->type);
                for (usize i = ((usize)(0llu)); ((i) < ((*args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&(*args)), (i))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (arg), (false)));
                    ((startComptimePS7132rN)((function)));
                    RegIndex_s regValue = ((allocateRegisterPS7132PU5175rS6939)((function), (regValueType)));
                    ((buildIntoIRValuePS7132S8951S6939S6939rN)((function), ((arg)->span), (regValue), (result)));
                    ((pushPS9911S6939rN)((&(irArgs)), ((prepareArgumentPS9562PS7132S8951S6939PU5175rS6939)((this), (function), ((arg)->span), (regValue), (regValueType)))));
                    ((endComptimePS7132rN)((function)));
                }

                ((startComptimePS7132rN)((function)));
                RegIndex_s base = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*fn), (false)));
                RegIndex_s reg = ((prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939)((this), ((stmt)->span), (function), (base), (irArgs), (retType), (retPtr), (false)));
                ((endComptimePS7132rN)((function)));
                ((buildEmitAssemblyPS7132S8951S6939PU5175rN)((function), ((stmt)->span), (reg), ((getTypePU9661rPU5175)((&((*fn)->typeState))))));
            }
            goto after_7266;
        }
    }
    {
        StmtData_u **unknown = &tmp_7266_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeStmt: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7266;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7266:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none generateBytecodeMatchStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *match) {
    ParsedExpr_s *expr = (NULL);
    ParsedPatternList_s *patterns = (NULL);
    ParsedStmtList_s *stmts = (NULL);
    bool succ_4902_ = true;

    StmtData_u *tmp_7276_ = (&((match)->data));
    {
        succ_4902_ &= (tmp_7276_->tag == 11);
        ParsedExpr_s **_expr = &tmp_7276_->payload.variant11._0;
        succ_4902_ &= true;
        ParsedPatternList_s *_patterns = &tmp_7276_->payload.variant11._1;
        succ_4902_ &= true;
        ParsedStmtList_s *_stmts = &tmp_7276_->payload.variant11._2;
        succ_4902_ &= true;
        if (succ_4902_) {
            {
                ((expr) = (*_expr));
                ((patterns) = (&(*_patterns)));
                ((stmts) = (&(*_stmts)));
            }
            goto after_7276;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7276;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7276:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBrN)((((patterns)->length) == ((stmts)->length))));
    TCState_u state = ((match)->typeState);
    ((assertBrN)(((isPatternPU9661rB)((&(state))))));
    PatState_s patState = ((getPatStatePU9661rS1259)((&(state))));
    ((assertBPcrN)(((patState).complete), ("generateBytecodeMatchStmt: Non-exhaustive pattern")));
    RegIndex_s exprReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (expr), (false)));
    IRBlockID_s end = ((appendBlockPS7132rS7192)((function)));
    for (usize i = ((usize)(0llu)); ((i) < ((patterns)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *pat = (*((atPS1982uszrPPS1826)((patterns), (i))));
        ParsedStmt_s *stmt = (*((atPS3288uszrPPS1100)((stmts), (i))));
        usize scope = ((enterScopePS7132rusz)((function)));
        RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (exprReg), (pat), (false)));
        IRBlockID_s matchBlock = ((appendBlockPS7132rS7192)((function)));
        IRBlockID_s nextBlock = ((appendBlockPS7132rS7192)((function)));
        ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((match)->span), (patReg), (matchBlock), (nextBlock)));
        ((setCurrentBlockPS7132S7192rN)((function), (matchBlock)));
        ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
        if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
            ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (end)));
        }

        ((setCurrentBlockPS7132S7192rN)((function), (nextBlock)));
        usize after = ((leaveScopePS7132rusz)((function)));
        ((assertBPcrN)(((scope) == (after)), ("Scope imbalance in match")));
    }

    usize funcID = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("unreachablePcrN"), ("prelude.bufo")));
    RegIndexList_s args = ((RegIndexList_s){0});
    {
        RegIndex_s err = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))));
        String_s s = ((copyPS0540rS0540)((&((function)->name))));
        String_s _s = ((toStringPS8951rS0540)((&((match)->span))));
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": FATAL COMPILER ERROR: match-statement reached guard block!\n")));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": This should never happen, as all match-patterns eventually lead to the real block.\n")));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": Please submit a bug report.\n")));
        ((dropPS0540rN)((&(_s))));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((match)->span), (err), ((asSubStrPS0540rS7720)((&(s))))));
        ((pushPS9911S6939rN)((&(args)), (err)));
    }

    ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((match)->span), (funcID),
                                                                 ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
    ((buildUnreachablePS7132S8951rN)((function), ((match)->span)));
    ((setCurrentBlockPS7132S7192rN)((function), (end)));
}
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory) {
    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (pat), (inOrigMemory), (false)));
}
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory, bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    RegIndex_s success = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))));
    bool succ_4932_ = true;
    bool succ_4937_ = true;
    bool succ_4944_ = true;
    bool succ_4947_ = true;
    bool succ_4952_ = true;
    bool succ_4950_ = true;
    bool succ_4957_ = true;
    bool succ_4955_ = true;
    bool succ_4963_ = true;
    bool succ_4968_ = true;
    bool succ_4973_ = true;
    bool succ_4980_ = true;
    bool succ_4983_ = true;
    bool succ_4987_ = true;

    Pattern_u *tmp_7419_ = (&((pat)->data));
    {
        succ_4932_ &= (tmp_7419_->tag == 2);
        Token_s *name = &tmp_7419_->payload.variant2._0;
        succ_4932_ &= true;
        if (succ_4932_) {
            {
                if (isComptimeVariable) {
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (expr), (true)));
                }

                else if (inOrigMemory) {
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (expr), (false)));
                }

                else {
                    RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (allocReg), (false)));
                }

                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7419;
        }
    }
    {
        succ_4937_ &= (tmp_7419_->tag == 4);
        ParsedPattern_s **sub = &tmp_7419_->payload.variant4._0;
        succ_4937_ &= true;
        if (succ_4937_) {
            {
                ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Reference Pattern expected pointer type")));
                Type_u *under = ((getUnderlyingTypePU5175BrPU5175)((type), (false)));
                if ((isPointerPU5175rB)((under))) {
                    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (under)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (reg), (expr)));
                    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (reg), (*sub), (true), (isComptimeVariable)));
                }

                else {
                    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (*sub), (true), (isComptimeVariable)));
                }
            }
            goto after_7419;
        }
    }
    {
        succ_4944_ &= (tmp_7419_->tag == 3);
        ParsedPattern_s **sub = &tmp_7419_->payload.variant3._0;
        succ_4944_ &= true;
        succ_4944_ &= true;
        if (succ_4944_) {
            {
                return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (*sub), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7419;
        }
    }
    {
        succ_4947_ &= (tmp_7419_->tag == 10);
        if (succ_4947_) {
            {
                ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Null Pattern expected pointer type")));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((buildLoadNullPS7132S8951S6939rN)((function), ((pat)->span), (reg)));
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_INT_CMP_EQ), (success), (expr), (reg)));
            }
            goto after_7419;
        }
    }
    {
        succ_4952_ &= (tmp_7419_->tag == 9);
        succ_4950_ = tmp_7419_->payload.variant9._0 == true;
        succ_4952_ &= succ_4950_;
        if (succ_4952_) {
            {
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Boolean Pattern inOrigMemory expected pointer")));
                    ((assertBPcrN)(((isPointerToPU5175PU5175rB)((type), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}}))))),
                                   ("Boolean Pattern inOrigMemory expected pointer to bool")));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), ((getUnderlyingTypePU5175BrPU5175)((type), (false)))));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (_expr)));
                }

                else {
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (expr)));
                }
            }
            goto after_7419;
        }
    }
    {
        succ_4957_ &= (tmp_7419_->tag == 9);
        succ_4955_ = tmp_7419_->payload.variant9._0 == false;
        succ_4957_ &= succ_4955_;
        if (succ_4957_) {
            {
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Boolean Pattern inOrigMemory expected pointer")));
                    ((assertBPcrN)(((isPointerToPU5175PU5175rB)((type), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}}))))),
                                   ("Boolean Pattern inOrigMemory expected pointer to bool")));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), ((getUnderlyingTypePU5175BrPU5175)((type), (false)))));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((buildLogicalNotPS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (_expr)));
                }

                else {
                    ((buildLogicalNotPS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (expr)));
                }
            }
            goto after_7419;
        }
    }
    {
        succ_4963_ &= (tmp_7419_->tag == 5);
        succ_4963_ &= true;
        succ_4963_ &= true;
        if (succ_4963_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                ((generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7419;
        }
    }
    {
        succ_4968_ &= (tmp_7419_->tag == 6);
        succ_4968_ &= true;
        ParsedPattern_s **sub = &tmp_7419_->payload.variant6._1;
        succ_4968_ &= true;
        if (succ_4968_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                bool ptr = ((isPointerPU5175rB)((type)));
                if (ptr)
                    ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
                if ((isUnionPU5175rB)((type))) {
                    ((generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), ((ptr) || (inOrigMemory)), (isComptimeVariable)));
                }

                else if ((isStructPU5175rB)((type))) {
                    ((generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (*sub), (success), ((ptr) || (inOrigMemory)), (isComptimeVariable)));
                }

                else {
                    ((unreachablePcrN)(("generateBytecodePattern(PATTERN_PATH): Exhaustive handling of variations")));
                }
            }
            goto after_7419;
        }
    }
    {
        succ_4973_ &= (tmp_7419_->tag == 1);
        Token_s *ident = &tmp_7419_->payload.variant1._0;
        succ_4973_ &= true;
        if (succ_4973_) {
            {
                RegIndex_s number = ((RegIndex_s){0});
                Type_u *real = (type);
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((real))), ("generateBytecodePattern: Number inOrigMemory")));
                    ((real) = ((getUnderlyingTypePU5175BrPU5175)((real), (false))));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), (real)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((expr) = (_expr));
                }

                ((number) = ((allocateRegisterPS7132PU5175rS6939)((function), (real))));
                ((loadLiteralPS9562PS7132S6939PS6070rS6939)((this), (function), (number), (&(*ident))));
                if ((isIntegerPU5175rB)((real))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_INT_CMP_EQ), (success), (expr), (number)));
                }

                else if ((isFloatPU5175rB)((real))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_FLOAT_CMP_EQ), (success), (expr), (number)));
                }

                else {
                    ((unreachablePcrN)(("Exhaustive handling of number types in IRGen.generateBytecodePattern")));
                }
            }
            goto after_7419;
        }
    }
    {
        succ_4980_ &= (tmp_7419_->tag == 0);
        if (succ_4980_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7419;
        }
    }
    {
        succ_4983_ &= (tmp_7419_->tag == 8);
        if (succ_4983_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7419;
        }
    }
    {
        succ_4987_ &= (tmp_7419_->tag == 7);
        succ_4987_ &= true;
        if (succ_4987_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                ((generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7419;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of patterns in IRGen.generateBytecodePattern")));
            }
            goto after_7419;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7419:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (success);
}
none generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    bool succ_4993_ = true;

    Pattern_u tmp_7423_ = ((pat)->data);
    succ_4993_ &= (tmp_7423_.tag == 7);
    ParsedPatternList_s *subPatterns = &tmp_7423_.payload.variant7._0;
    succ_4993_ &= true;
    if (!succ_4993_) {
        ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple pattern")));
    };
    if (inOrigMemory) {
        bool succ_4999_ = true;
        bool succ_4996_ = true;

        Type_u *tmp_7425_ = (type);
        succ_4999_ &= (tmp_7425_->tag == 4);
        succ_4996_ &= (tmp_7425_->payload.variant4._0->tag == 10);
        TypeList_s *elems = &tmp_7425_->payload.variant4._0->payload.variant10._0;
        succ_4996_ &= true;
        succ_4999_ &= succ_4996_;
        if (!succ_4999_) {
            ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple ptr")));
        };
        for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
            Type_u *fieldType = ((intoPointerPU5175rPU5175)(((((*elems).elements))[(i)])));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (subExpr), (expr), (i)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (true), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_38811 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_38811)))))
                break;
        }

    }

    else {
        bool succ_5009_ = true;

        Type_u *tmp_7439_ = (type);
        succ_5009_ &= (tmp_7439_->tag == 10);
        TypeList_s *elems = &tmp_7439_->payload.variant10._0;
        succ_5009_ &= true;
        if (!succ_5009_) {
            ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple type")));
        };
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        ((expr) = (allocReg));
        for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
            Type_u *fieldType = ((((*elems).elements))[(i)]);
            RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (fieldPtr), (expr), (i)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (subExpr), (fieldPtr)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (false), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_38923 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_38923)))))
                break;
        }
    }
}
none generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                   bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    ParsedPatternList_s *subPatterns = (NULL);
    bool succ_5025_ = true;

    Pattern_u *tmp_7465_ = (&((pat)->data));
    {
        succ_5025_ &= (tmp_7465_->tag == 5);
        succ_5025_ &= true;
        ParsedPatternList_s *patterns = &tmp_7465_->payload.variant5._1;
        succ_5025_ &= true;
        if (succ_5025_) {
            {
                ((subPatterns) = (&(*patterns)));
            }
            goto after_7465;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7465;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7465:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (inOrigMemory) {
        ParsedStructDecl_s *decl = (NULL);
        bool succ_5035_ = true;
        bool succ_5032_ = true;

        Type_u *tmp_7471_ = (type);
        {
            succ_5035_ &= (tmp_7471_->tag == 4);
            succ_5032_ &= (tmp_7471_->payload.variant4._0->tag == 7);
            ParsedStructDecl_s **_decl = &tmp_7471_->payload.variant4._0->payload.variant7._0;
            succ_5032_ &= true;
            succ_5035_ &= succ_5032_;
            if (succ_5035_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7471;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("In Memory Struct Pattern expected pointer to struct type")));
                }
                goto after_7471;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7471:
        (void)0; // error: label at end of compound statement is a C23 extension
        for (usize i = ((usize)(0llu)); ((i) < (((decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((subPatterns), (i))));
            ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (i)));
            Type_u *fieldType = ((intoPointerPU5175rPU5175)(((getTypePU9661rPU5175)((&((fieldNode)->typeState))))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (subExpr), (expr), (i)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (true), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_39027 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_39027)))))
                break;
        }

    }

    else {
        ParsedStructDecl_s *decl = (NULL);
        bool succ_5049_ = true;

        Type_u *tmp_7490_ = (type);
        {
            succ_5049_ &= (tmp_7490_->tag == 7);
            ParsedStructDecl_s **_decl = &tmp_7490_->payload.variant7._0;
            succ_5049_ &= true;
            if (succ_5049_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7490;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Struct Pattern expected struct type")));
                }
                goto after_7490;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7490:
        (void)0; // error: label at end of compound statement is a C23 extension
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        ((expr) = (allocReg));
        for (usize i = ((usize)(0llu)); ((i) < (((decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((subPatterns), (i))));
            ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (i)));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
            RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (fieldPtr), (expr), (i)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (subExpr), (fieldPtr)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (false), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_39152 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_39152)))))
                break;
        }
    }
}
none generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    Token_s *name = (NULL);
    ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
    bool succ_5075_ = true;
    bool succ_5072_ = true;
    bool succ_5071_ = true;
    bool succ_5087_ = true;
    bool succ_5084_ = true;
    bool succ_5083_ = true;

    Pattern_u *tmp_7521_ = (&((pat)->data));
    {
        succ_5075_ &= (tmp_7521_->tag == 6);
        succ_5075_ &= true;
        succ_5072_ &= true;
        succ_5072_ &= true;
        succ_5071_ &= (tmp_7521_->payload.variant6._1->data.tag == 2);
        Token_s *ident = &tmp_7521_->payload.variant6._1->data.payload.variant2._0;
        succ_5071_ &= true;
        succ_5072_ &= succ_5071_;
        succ_5075_ &= succ_5072_;
        if (succ_5075_) {
            {
                ((name) = (&(*ident)));
            }
            goto after_7521;
        }
    }
    {
        succ_5087_ &= (tmp_7521_->tag == 6);
        succ_5087_ &= true;
        succ_5084_ &= true;
        succ_5084_ &= true;
        succ_5083_ &= (tmp_7521_->payload.variant6._1->data.tag == 5);
        Token_s *ident = &tmp_7521_->payload.variant6._1->data.payload.variant5._0;
        succ_5083_ &= true;
        ParsedPatternList_s *pats = &tmp_7521_->payload.variant6._1->data.payload.variant5._1;
        succ_5083_ &= true;
        succ_5084_ &= succ_5083_;
        succ_5087_ &= succ_5084_;
        if (succ_5087_) {
            {
                ((name) = (&(*ident)));
                ((subPatterns) = (*pats));
            }
            goto after_7521;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7521;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7521:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s tagMatch = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))));
    if (inOrigMemory) {
        ParsedUnionDecl_s *decl = (NULL);
        bool succ_5101_ = true;
        bool succ_5098_ = true;

        Type_u *tmp_7530_ = (type);
        {
            succ_5101_ &= (tmp_7530_->tag == 4);
            succ_5098_ &= (tmp_7530_->payload.variant4._0->tag == 8);
            ParsedUnionDecl_s **_decl = &tmp_7530_->payload.variant4._0->payload.variant8._0;
            succ_5098_ &= true;
            succ_5098_ &= true;
            succ_5101_ &= succ_5098_;
            if (succ_5101_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7530;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("In Memory Union Pattern expected pointer type")));
                }
                goto after_7530;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7530:
        (void)0; // error: label at end of compound statement is a C23 extension
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        RegIndex_s tagPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tagType)))));
        RegIndex_s tagVal = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ParsedUnionVariant_s *variant = (NULL);
        bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((decl), (name), (&(variant))));
        ((assertBrN)((found)));
        RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (tmp), (expr)));
        {
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (tagReg), (tagType), ((getVariantTagPS0997PS3506rusz)((decl), (variant)))));
            ((buildMovePS7132S8951S6939S6939rN)((function), ((name)->span), (tagPtr), (tmp)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((name)->span), (tagVal), (tagPtr)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_CMP_EQ), (tagMatch), (tagReg), (tagVal)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_LOGICAL_AND), (success), (success), (tagMatch)));
            usize offset = ((usize)(1llu));
            if ((((decl)->variants).length) >= ((usize)(256llu)))
                ((offset) = ((usize)(2llu)));
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (sizeReg), (usizeType), (offset)));
            ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
            ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
        }

        bool succ_5117_ = true;
        bool succ_5115_ = true;

        {
            tuple_1017 tmp_7575_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_5115_ = tmp_7575_._0 == true;
            succ_5117_ &= succ_5115_;
            ParsedTypeNodeList_s **fields = &tmp_7575_._1;
            succ_5117_ &= true;

            if (succ_5117_) {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subSubPat = ((((subPatterns).elements))[(i)]);
                    ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                    usize fieldSize = ((getSizeInBytesPU5175rusz)((fieldType)));
                    RegIndex_s subPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (subPtr), (tmp)));
                    RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subPtr), (subSubPat), (true), (isComptimeVariable)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
                    Pattern_u tmp_39444 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_39444)))))
                        break;
                    if ((i) != (((subPatterns).length) - ((usize)(1llu)))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((subSubPat)->span), (sizeReg), (usizeType), (fieldSize)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                    }
                }
            }
        }

    }

    else {
        ParsedUnionDecl_s *decl = (NULL);
        bool succ_5131_ = true;

        Type_u *tmp_7582_ = (type);
        {
            succ_5131_ &= (tmp_7582_->tag == 8);
            ParsedUnionDecl_s **_decl = &tmp_7582_->payload.variant8._0;
            succ_5131_ &= true;
            succ_5131_ &= true;
            if (succ_5131_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7582;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Union Pattern expected union type")));
                }
                goto after_7582;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7582:
        (void)0; // error: label at end of compound statement is a C23 extension
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        RegIndex_s tagPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tagType)))));
        RegIndex_s tagVal = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ParsedUnionVariant_s *variant = (NULL);
        bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((decl), (name), (&(variant))));
        ((assertBrN)((found)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (tmp), (allocReg)));
        {
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (tagReg), (tagType), ((getVariantTagPS0997PS3506rusz)((decl), (variant)))));
            ((buildMovePS7132S8951S6939S6939rN)((function), ((name)->span), (tagPtr), (allocReg)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((name)->span), (tagVal), (tagPtr)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_CMP_EQ), (tagMatch), (tagReg), (tagVal)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_LOGICAL_AND), (success), (success), (tagMatch)));
            usize offset = ((usize)(1llu));
            if ((((decl)->variants).length) >= ((usize)(256llu)))
                ((offset) = ((usize)(2llu)));
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (sizeReg), (usizeType), (offset)));
            ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
            ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
        }

        ((expr) = (allocReg));
        bool succ_5148_ = true;
        bool succ_5146_ = true;

        {
            tuple_1017 tmp_7634_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_5146_ = tmp_7634_._0 == true;
            succ_5148_ &= succ_5146_;
            ParsedTypeNodeList_s **fields = &tmp_7634_._1;
            succ_5148_ &= true;

            if (succ_5148_) {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subSubPat = ((((subPatterns).elements))[(i)]);
                    ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                    usize fieldSize = ((getSizeInBytesPU5175rusz)((fieldType)));
                    RegIndex_s subAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
                    RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((subSubPat)->span), (subAlloc), (fieldSize)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((subSubPat)->span), (sizeReg), (usizeType), (fieldSize)));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((subSubPat)->span), (tmp), (subAlloc), (sizeReg)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (subExpr), (subAlloc)));
                    RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subSubPat), (false), (isComptimeVariable)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
                    Pattern_u tmp_39784 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_39784)))))
                        break;
                    if ((i) != (((subPatterns).length) - ((usize)(1llu)))) {
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                    }
                }
            }
        }
    }
}
RegIndex_s generateBytecodeExprPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    if ((expr)->ignored)
        return ((RegIndex_s){0});
    ((assertBPcrN)(((isSuccessPU9661rB)((&((expr)->typeState)))), ("Expected valid Expr type in IRGen")));
    bool succ_5160_ = true;
    bool succ_5164_ = true;
    bool succ_5168_ = true;
    bool succ_5172_ = true;
    bool succ_5176_ = true;
    bool succ_5180_ = true;
    bool succ_5184_ = true;
    bool succ_5188_ = true;
    bool succ_5192_ = true;
    bool succ_5206_ = true;
    bool succ_5233_ = true;
    bool succ_5238_ = true;
    bool succ_5241_ = true;
    bool succ_5244_ = true;
    bool succ_5255_ = true;
    bool succ_5258_ = true;
    bool succ_5262_ = true;
    bool succ_5271_ = true;
    bool succ_5284_ = true;
    bool succ_5299_ = true;
    bool succ_5316_ = true;

    ExprData_u *tmp_7797_ = (&((expr)->data));
    {
        succ_5160_ &= (tmp_7797_->tag == 0);
        succ_5160_ &= true;
        if (succ_5160_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5164_ &= (tmp_7797_->tag == 1);
        succ_5164_ &= true;
        if (succ_5164_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5168_ &= (tmp_7797_->tag == 2);
        succ_5168_ &= true;
        if (succ_5168_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5172_ &= (tmp_7797_->tag == 3);
        succ_5172_ &= true;
        if (succ_5172_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5176_ &= (tmp_7797_->tag == 4);
        IdentExpr_s *ident = &tmp_7797_->payload.variant4._0;
        succ_5176_ &= true;
        if (succ_5176_) {
            {
                return ((generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939)((this), (function), (&(*ident)), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5180_ &= (tmp_7797_->tag == 5);
        UnaryExpr_u *unary = &tmp_7797_->payload.variant5._0;
        succ_5180_ &= true;
        if (succ_5180_) {
            {
                return ((generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939)((this), (function), ((expr)->span), (&(*unary)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5184_ &= (tmp_7797_->tag == 6);
        BinaryExpr_u *binary = &tmp_7797_->payload.variant6._0;
        succ_5184_ &= true;
        if (succ_5184_) {
            {
                return ((generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939)((this), (function), (&(*binary)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5188_ &= (tmp_7797_->tag == 7);
        CallExpr_s *call = &tmp_7797_->payload.variant7._0;
        succ_5188_ &= true;
        if (succ_5188_) {
            {
                return ((generateBytecodeExprCallPS9562PS7132PS3328BrS6939)((this), (function), (&(*call)), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5192_ &= (tmp_7797_->tag == 8);
        ParsedTypeNode_s **typeNode = &tmp_7797_->payload.variant8._0;
        succ_5192_ &= true;
        if (succ_5192_) {
            {
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                Type_u *target = ((getTypePU9661rPU5175)((&((*typeNode)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
                usize size = ((getSizeInBytesPU5175rusz)((target)));
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (reg), (t), (size)));
                if (needsPtr) {
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5206_ &= (tmp_7797_->tag == 9);
        StructExpr_s *init = &tmp_7797_->payload.variant9._0;
        succ_5206_ &= true;
        if (succ_5206_) {
            {
                Type_u *strukt = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                ParsedStructDecl_s *structDecl = (NULL);
                bool succ_5214_ = true;

                Type_u *tmp_7675_ = (strukt);
                {
                    succ_5214_ &= (tmp_7675_->tag == 7);
                    ParsedStructDecl_s **_decl = &tmp_7675_->payload.variant7._0;
                    succ_5214_ &= true;
                    if (succ_5214_) {
                        {
                            ((structDecl) = (*_decl));
                        }
                        goto after_7675;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected Struct Type in EXPR_STRUCT_INIT")));
                        }
                        goto after_7675;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_7675:
                (void)0; // error: label at end of compound statement is a C23 extension
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (strukt)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < (((*init).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*init).context)), (i)));
                    ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*init).context)), (i)));
                    usize index = ((getFieldIndexPS5521PS7720rusz)((structDecl), (&((name).content))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((field)->span), (reg), (index), (result)));
                }

                if (needsPtr) {
                    RegIndex_s structAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((strukt)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (structAlloc), ((getSizeInBytesPU5175rusz)((strukt)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (structAlloc), (reg)));
                    return (structAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5233_ &= (tmp_7797_->tag == 10);
        UnionExpr_u *init = &tmp_7797_->payload.variant10._0;
        succ_5233_ &= true;
        if (succ_5233_) {
            {
                return (
                    (generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939)((this), (function), ((expr)->span), (&(*init)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5238_ &= (tmp_7797_->tag == 11);
        succ_5238_ &= true;
        succ_5238_ &= true;
        if (succ_5238_) {
            {
                return ((generateBytecodeExprAsPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5241_ &= (tmp_7797_->tag == 12);
        if (succ_5241_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5244_ &= (tmp_7797_->tag == 13);
        if (succ_5244_) {
            {
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                usize size = ((getSizeInBytesPU5175rusz)((t)));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
                ((buildLoadBlankPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), (size)));
                if (needsPtr) {
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5255_ &= (tmp_7797_->tag == 14);
        if (succ_5255_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5258_ &= (tmp_7797_->tag == 15);
        if (succ_5258_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7797;
        }
    }
    {
        succ_5262_ &= (tmp_7797_->tag == 16);
        ParsedFuncDecl_s **decl = &tmp_7797_->payload.variant16._0;
        succ_5262_ &= true;
        if (succ_5262_) {
            {
                String_s name = ((getMangledNamePS4904rS0540)((*decl)));
                usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(name))));
                RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), ((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), ((expr)->span), (dst), (funcID)));
                return (dst);
            }
            goto after_7797;
        }
    }
    {
        succ_5271_ &= (tmp_7797_->tag == 17);
        ParsedTypeNode_s **typeNode = &tmp_7797_->payload.variant17._0;
        succ_5271_ &= true;
        if (succ_5271_) {
            {
                Type_u *target = ((getTypePU9661rPU5175)((&((*typeNode)->typeState))));
                Type_u *typeInfo = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((generateTypeInfoPS9562PS7132S8951PU5175rS6939)((this), (function), ((expr)->span), (target)));
                if (needsPtr) {
                    usize size = ((getSizeInBytesPU5175rusz)((typeInfo)));
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typeInfo)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5284_ &= (tmp_7797_->tag == 18);
        ParsedExpr_s **exprNode = &tmp_7797_->payload.variant18._0;
        succ_5284_ &= true;
        if (succ_5284_) {
            {
                RegIndex_s subExpr = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*exprNode), (true)));
                Type_u *target = ((getTypePU9661rPU5175)((&((*exprNode)->typeState))));
                Type_u *data = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (data)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(0llu)), (subExpr)));
                {
                    RegIndex_s ti = ((generateTypeInfoPS9562PS7132S8951PU5175rS6939)((this), (function), ((expr)->span), (target)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(1llu)), (ti)));
                }

                if (needsPtr) {
                    usize size = ((getSizeInBytesPU5175rusz)((data)));
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((data)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5299_ &= (tmp_7797_->tag == 19);
        ParsedExprList_s *vals = &tmp_7797_->payload.variant19._0;
        succ_5299_ &= true;
        if (succ_5299_) {
            {
                Type_u *varType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                ((assertBPcrN)(((isVariadicTypePU5175rB)((varType))), ("ExprData::Variadic() is not variadic?")));
                Type_u *subType = ((getUnderlyingTypePU5175BrPU5175)((varType), (false)));
                usize count = ((*vals).length);
                Type_u *newType = ((intoArrayTypePU5175uszrPU5175)((subType), (count)));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (newType)));
                ((buildCreateArrayPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < ((*vals).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*((atPS7823uszrPPS2435)((&(*vals)), (i)))), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), (i), (result)));
                }

                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((newType)))));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (alloca), ((getSizeInBytesPU5175rusz)((newType)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (alloca), (reg)));
                Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (sizeReg), (usizeType), ((*vals).length)));
                ((reg) = ((allocateRegisterPS7132PU5175rS6939)((function), (varType))));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(0llu)), (alloca)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(1llu)), (sizeReg)));
                ((assertBPcrN)((!(needsPtr)), ("needsPtr for ExprData::Variadic?")));
                return (reg);
            }
            goto after_7797;
        }
    }
    {
        succ_5316_ &= (tmp_7797_->tag == 20);
        ParsedExprList_s *elems = &tmp_7797_->payload.variant20._0;
        succ_5316_ &= true;
        if (succ_5316_) {
            {
                Type_u *tuple = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (tuple)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *e = ((((*elems).elements))[(i)]);
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (e), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((e)->span), (reg), (i), (result)));
                }

                if (needsPtr) {
                    RegIndex_s structAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tuple)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (structAlloc), ((getSizeInBytesPU5175rusz)((tuple)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (structAlloc), (reg)));
                    return (structAlloc);
                }

                return (reg);
            }
            goto after_7797;
        }
    }
    {
        ExprData_u **unknown = &tmp_7797_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeExpr: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7797;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7797:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExpr")));
}
RegIndex_s generateTypeInfoPS9562PS7132S8951PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *type) {
    usize index = ((index_of_typePS3131PU5175rusz)((&((this)->type_info_table)), (type)));
    if ((index) >= (((this)->type_info_table).length)) {
        String_s l = ((toStringPS8951rS0540)((&(span))));
        String_s t = ((toStringPU5175rS0540)((type)));
        (((fprintf))((stderr_), ("%s: %s: WEEWOO!!! Type Info for Type %s doesn\'t exist!!!\n"), ((l).buffer), (FATAL_STR), ((t).buffer)));
        (((C_exiti32rN))(((i32)(2))));
    }

    bool isGlobal = (false);
    IRScopeEntry_s *global_type_info_table = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((newSubStrOfStrLitPcrS7720)(("type_info_table")))), (&(isGlobal))));
    ((assertBPcrN)(((global_type_info_table) != (NULL)), ("generateTypeInfo: Could not find global type info table variable")));
    ((assertBPcrN)((isGlobal), ("generateTypeInfo: Global type info table is not global")));
    SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(NAME))));
    ((assertBPcrN)(((context) != (NULL)), ("generateTypeInfo: Could not find union context for TypeInfo")));
    Type_u *typeInfo = ((context)->type);
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s indexReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s indices = ((RegIndexList_s){0});
    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (indexReg), (usizeType), (index)));
    ((pushPS9911S6939rN)((&(indices)), (indexReg)));
    RegIndex_s info = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfo)));
    RegIndex_s info_ptr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typeInfo)))));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (info_ptr), ((global_type_info_table)->ptr)));
    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (info_ptr), (info_ptr)));
    ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (info_ptr), (info_ptr), (indices)));
    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (info), (info_ptr)));
    return (info);
}
RegIndex_s generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    bool succ_5350_ = true;
    bool succ_5354_ = true;
    bool succ_5358_ = true;
    bool succ_5362_ = true;
    bool succ_5366_ = true;
    bool succ_5370_ = true;
    bool succ_5374_ = true;
    bool succ_5378_ = true;
    bool succ_5382_ = true;
    bool succ_5386_ = true;
    bool succ_5390_ = true;
    bool succ_5394_ = true;
    bool succ_5398_ = true;
    bool succ_5402_ = true;
    bool succ_5406_ = true;
    bool succ_5410_ = true;
    bool succ_5414_ = true;
    bool succ_5418_ = true;
    bool succ_5422_ = true;
    bool succ_5426_ = true;

    BinaryExpr_u *tmp_7870_ = (expr);
    {
        succ_5350_ &= (tmp_7870_->tag == 0);
        succ_5350_ &= true;
        if (succ_5350_) {
            {
                return ((generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5354_ &= (tmp_7870_->tag == 1);
        succ_5354_ &= true;
        if (succ_5354_) {
            {
                return ((generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5358_ &= (tmp_7870_->tag == 2);
        succ_5358_ &= true;
        if (succ_5358_) {
            {
                return ((generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939)((this), (function), (expr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5362_ &= (tmp_7870_->tag == 3);
        succ_5362_ &= true;
        if (succ_5362_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5366_ &= (tmp_7870_->tag == 4);
        succ_5366_ &= true;
        if (succ_5366_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5370_ &= (tmp_7870_->tag == 5);
        succ_5370_ &= true;
        if (succ_5370_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5374_ &= (tmp_7870_->tag == 6);
        succ_5374_ &= true;
        if (succ_5374_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5378_ &= (tmp_7870_->tag == 7);
        succ_5378_ &= true;
        if (succ_5378_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        succ_5382_ &= (tmp_7870_->tag == 8);
        succ_5382_ &= true;
        if (succ_5382_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5386_ &= (tmp_7870_->tag == 9);
        succ_5386_ &= true;
        if (succ_5386_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5390_ &= (tmp_7870_->tag == 10);
        succ_5390_ &= true;
        if (succ_5390_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5394_ &= (tmp_7870_->tag == 11);
        succ_5394_ &= true;
        if (succ_5394_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5398_ &= (tmp_7870_->tag == 12);
        succ_5398_ &= true;
        if (succ_5398_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5402_ &= (tmp_7870_->tag == 13);
        succ_5402_ &= true;
        if (succ_5402_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5406_ &= (tmp_7870_->tag == 14);
        succ_5406_ &= true;
        if (succ_5406_) {
            {
                return ((generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5410_ &= (tmp_7870_->tag == 15);
        succ_5410_ &= true;
        if (succ_5410_) {
            {
                return ((generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5414_ &= (tmp_7870_->tag == 16);
        succ_5414_ &= true;
        if (succ_5414_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5418_ &= (tmp_7870_->tag == 17);
        succ_5418_ &= true;
        if (succ_5418_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5422_ &= (tmp_7870_->tag == 18);
        succ_5422_ &= true;
        if (succ_5422_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7870;
        }
    }
    {
        succ_5426_ &= (tmp_7870_->tag == 19);
        succ_5426_ &= true;
        if (succ_5426_) {
            {
                return ((generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7870;
        }
    }
    {
        BinaryExpr_u **unknown = &tmp_7870_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeExprBinary: Unhandled tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7870;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7870:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generateBytecodeExprBinary: Exhaustive handling of binary ops")));
}
RegIndex_s generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnionExpr_u *expr, Type_u *type, bool needsPtr) {
    ParsedUnionDecl_s *decl = (NULL);
    ParsedUnionVariant_s *variant = (NULL);
    usize _tag = ((usize)(0llu));
    bool succ_5438_ = true;

    Type_u *tmp_7881_ = (type);
    {
        succ_5438_ &= (tmp_7881_->tag == 8);
        ParsedUnionDecl_s **_decl = &tmp_7881_->payload.variant8._0;
        succ_5438_ &= true;
        usize *_variant = &tmp_7881_->payload.variant8._1;
        succ_5438_ &= true;
        if (succ_5438_) {
            {
                ((decl) = (*_decl));
                ((variant) = (*((atPS0030uszrPPS3506)((&((decl)->variants)), (*_variant)))));
                ((_tag) = (*_variant));
            }
            goto after_7881;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected Union Type in EXPR_UNION_INIT")));
            }
            goto after_7881;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7881:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((((decl)->variants).length) < ((usize)(65536llu))), ("IRGen assumes that the tag of an union fits in at most two bytes")));
    usize size = ((getSizeInBytesPU5175rusz)((type)));
    ((assertBPcrN)(((size) >= ((usize)(1llu))), ("Expected union instance to be at least one byte")));
    RegIndex_s start = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (start), (size)));
    RegIndex_s empty = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    ((buildCreateUnionPS7132S8951S6939rN)((function), (span), (empty)));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (start), (empty)));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s offsetReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    RegIndex_s base = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    ((buildMovePS7132S8951S6939S6939rN)((function), (span), (tmp), (start)));
    {
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (tagType), (_tag)));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (start), (tagReg)));
        usize offset = ((usize)(1llu));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((offset) = ((usize)(2llu)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (sizeReg), (usizeType), (offset)));
        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
    }

    ((buildMovePS7132S8951S6939S6939rN)((function), (span), (base), (tmp)));
    bool succ_5455_ = true;
    bool succ_5459_ = true;
    bool succ_5469_ = true;

    UnionExpr_u *tmp_7958_ = (expr);
    {
        succ_5455_ &= (tmp_7958_->tag == 2);
        if (succ_5455_) {
            {
            }
            goto after_7958;
        }
    }
    {
        succ_5459_ &= (tmp_7958_->tag == 0);
        CallExpr_s *tuple = &tmp_7958_->payload.variant0._0;
        succ_5459_ &= true;
        if (succ_5459_) {
            {
                ParsedUnionVariantData_u tmp_41036 = (((ParsedUnionVariantData_u){.tag = 1, .payload = {0}}));

                ((assertBPcrN)((((tagAnyru8)((&((variant)->data)))) == (((tagAnyru8)((&tmp_41036))))), ("UnionExpr::Tuple did not get Tuple variant")));
                for (usize i = ((usize)(0llu)); ((i) < (((*tuple).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *field = (*((atPS7823uszrPPS2435)((&((*tuple).args)), (i))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (true)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (sizeReg), (usizeType),
                                                                   ((getSizeInBytesPU5175rusz)(((getTypePU9661rPU5175)((&((field)->typeState))))))));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((field)->span), (result), (tmp), (sizeReg)));
                    if ((i) != ((((*tuple).args).length) - ((usize)(1llu)))) {
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                    }
                }
            }
            goto after_7958;
        }
    }
    {
        succ_5469_ &= (tmp_7958_->tag == 1);
        StructExpr_s *context = &tmp_7958_->payload.variant1._0;
        succ_5469_ &= true;
        if (succ_5469_) {
            {
                ParsedUnionVariantData_u tmp_41134 = (((ParsedUnionVariantData_u){.tag = 2, .payload = {0}}));

                ((assertBPcrN)((((tagAnyru8)((&((variant)->data)))) == (((tagAnyru8)((&tmp_41134))))), ("UnionExpr::Struct did not get Struct variant")));
                for (usize i = ((usize)(0llu)); ((i) < (((*context).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*context).context)), (i)));
                    ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*context).context)), (i)));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (true)));
                    usize size = ((usize)(0llu));
                    usize offset = ((usize)(0llu));
                    {
                        usize index = ((getFieldIndexPS3506PS7720rusz)((variant), (&((name).content))));
                        ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (index), (&(offset)), (&(size)), (false)));
                        usize real_offset = ((usize)(0llu));
                        for (usize j = ((usize)(0llu)); ((j) < (index)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize _offset = ((usize)(0llu));
                            usize _size = ((usize)(0llu));
                            ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (j), (&(_offset)), (&(_size)), (false)));
                            ((real_offset) = ((real_offset) + (_size)));
                        }

                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (offsetReg), (usizeType), (real_offset)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (base), (base)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (base), (offsetReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (base), (base)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (sizeReg), (usizeType), (size)));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((field)->span), (result), (tmp), (sizeReg)));
                }
            }
            goto after_7958;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7958;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7958:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        return (start);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (dst), (start)));
        return (dst);
    }
}
RegIndex_s generateBytecodeExprAsPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    ParsedExpr_s *orig = (NULL);
    ParsedTypeNode_s *typeNode = (NULL);
    bool succ_5502_ = true;

    ExprData_u tmp_7973_ = ((expr)->data);
    {
        succ_5502_ &= (tmp_7973_.tag == 11);
        ParsedExpr_s **_orig = &tmp_7973_.payload.variant11._0;
        succ_5502_ &= true;
        ParsedTypeNode_s **_type = &tmp_7973_.payload.variant11._1;
        succ_5502_ &= true;
        if (succ_5502_) {
            {
                ((orig) = (*_orig));
                ((typeNode) = (*_type));
            }
            goto after_7973;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7973;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7973:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *current = ((getTypePU9661rPU5175)((&((orig)->typeState))));
    Type_u *target = ((getTypePU9661rPU5175)((&((typeNode)->typeState))));
    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (orig), ((isDataPU5175rB)((current)))));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (target)));
    if ((isDataPU5175rB)((current))) {
        RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)(((intoPointerPU5175rPU5175)((target)))))));
        ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (fieldPtr), (result), ((usize)(0llu))));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (fieldPtr), (fieldPtr)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (fieldPtr)));
    }

    else if ((isDataPU5175rB)((target))) {
        ((unreachablePcrN)(("generateBytecodeExprAs: <something> as Data should\'ve been handled by the Type Checker")));
    }

    else if (((isIntegerPU5175rB)((current))) && ((isPointerPU5175rB)((target)))) {
        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isPointerPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isPointerPU5175rB)((current))) && ((isPointerPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isFunctionPU5175rB)((current))) && ((isFunctionPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isAnyPU5175rB)((current))) && ((isFunctionPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isFunctionPU5175rB)((current))) && ((isAnyPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if ((((isCharPU5175rB)((current))) || ((isIntegerPU5175rB)((current)))) && (((isCharPU5175rB)((target))) || ((isIntegerPU5175rB)((target))))) {
        if (((getSizeInBitsPU5175rusz)((current))) < ((getSizeInBitsPU5175rusz)((target)))) {
            if ((isSignedIntegerPU5175rB)((current))) {
                ((buildIntSignExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
            }

            else {
                ((buildIntZeroExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
            }

        }

        else if (((getSizeInBitsPU5175rusz)((current))) > ((getSizeInBitsPU5175rusz)((target)))) {
            ((buildIntTruncatePS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

        else {
            ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

    }

    else if (((isIntegerPU5175rB)((current))) && ((isFloatPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((target))) == ((usize)(4llu)))
            ((buildIntToF32PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else if (((getSizeInBytesPU5175rusz)((target))) == ((usize)(8llu)))
            ((buildIntToF64PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else
            ((unreachablePcrN)(("int to float")));
    }

    else if (((isFloatPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((current))) == ((usize)(4llu)))
            ((buildF32ToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else if (((getSizeInBytesPU5175rusz)((current))) == ((usize)(8llu)))
            ((buildF64ToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else
            ((unreachablePcrN)(("float to int")));
    }

    else if (((isBooleanPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        if ((isSignedIntegerPU5175rB)((current))) {
            ((buildIntSignExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

        else {
            ((buildIntZeroExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

    }

    else if (((isIntegerPU5175rB)((current))) && ((isBooleanPU5175rB)((target)))) {
        RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (current)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (zero), (current), ((usize)(0llu))));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_CMP_NEQ), (dst), (result), (zero)));
    }

    else if (((isFloatPU5175rB)((current))) && ((isFloatPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((current))) < ((getSizeInBytesPU5175rusz)((target)))) {
            ((assertBrN)((((getSizeInBytesPU5175rusz)((current))) == ((usize)(4llu)))));
            ((assertBrN)((((getSizeInBytesPU5175rusz)((target))) == ((usize)(8llu)))));
            ((buildF32ToF64PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

        else if (((getSizeInBytesPU5175rusz)((current))) > ((getSizeInBytesPU5175rusz)((target)))) {
            ((assertBrN)((((getSizeInBytesPU5175rusz)((current))) == ((usize)(8llu)))));
            ((assertBrN)((((getSizeInBytesPU5175rusz)((target))) == ((usize)(4llu)))));
            ((buildF64ToF32PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

        else {
            ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of variations in generateBytecodeExprAs")));
    }

    if (needsPtr) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((target)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((target)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (dst)));
        ((dst) = (tempAlloc));
    }

    return (dst);
}
RegIndex_s generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *instance = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    if ((isModulePU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    else if ((isUnionPU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    else {
        ((unreachablePcrN)(("generateBytecodeExprModuleAccess: Unexpected type of LHS")));
    }
}
RegIndex_s generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *instance = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    if ((isModulePU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    if (((isArrayPU5175rB)((instance))) || ((isArrayPointerPU5175rB)((instance)))) {
        if ((isArrayPointerPU5175rB)((instance))) {
            bool succ_5531_ = true;

            while (true) {
                Type_u *tmp_8088_ = ((getUnderlyingTypePU5175BrPU5175)((instance), (false)));
                succ_5531_ &= (tmp_8088_->tag == 4);
                Type_u **under = &tmp_8088_->payload.variant4._0;
                succ_5531_ &= true;

                if (!succ_5531_)
                    break;
                {
                    ((instance) = (*under));
                }
            }
        }

        bool succ_5536_ = true;

        Type_u *tmp_8094_ = (instance);
        succ_5536_ &= (tmp_8094_->tag == 5);
        succ_5536_ &= true;
        usize *arraySize = &tmp_8094_->payload.variant5._1;
        succ_5536_ &= true;
        if (!succ_5536_) {
            String_s s = ((toStringPU5175rS0540)((instance)));
            (((fprintf))((stderr_), ("%s %.*s\n"), (FATAL_STR), ((s).length), ((s).buffer)));
            ((unreachablePcrN)(("Expected array in MemberAccess")));
        };
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((rhs)->span), (size), (usizeType), (*arraySize)));
        if (needsPtr) {
            RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((usizeType)))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), ((rhs)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((usizeType)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), ((rhs)->span), (tempAlloc), (size)));
            return (tempAlloc);
        }

        else {
            return (size);
        }
    }

    ((assertBPcrN)(((((((isVariadicTypePU5175rB)((instance))) || ((isStructPU5175rB)((instance)))) || ((isStructPointerPU5175rB)((instance)))) || ((isTuplePU5175rB)((instance)))) ||
                    ((isTuplePointerPU5175rB)((instance)))),
                   ("Expected (ptr to) struct or tuple in MemberAccess")));
    bool _needsPtr = ((!((isStructPointerPU5175rB)((instance)))) && (!((isTuplePointerPU5175rB)((instance)))));
    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (_needsPtr)));
    usize index = ((usize)(1llu));
    Type_u *fieldType = (NULL);
    if ((isVariadicTypePU5175rB)((instance))) {
        Token_s name = ((Token_s){0});
        bool succ_5556_ = true;

        ExprData_u tmp_8118_ = ((rhs)->data);
        {
            succ_5556_ &= (tmp_8118_.tag == 4);
            IdentExpr_s *ident = &tmp_8118_.payload.variant4._0;
            succ_5556_ &= true;
            if (succ_5556_) {
                {
                    ((name) = ((*ident).name));
                }
                goto after_8118;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected Identifier as RHS of member access")));
                }
                goto after_8118;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_8118:
        (void)0; // error: label at end of compound statement is a C23 extension
        SubStr_s tmp_41982 = (((newSubStrOfStrLitPcrS7720)(("length"))));

        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((name).content)), (&tmp_41982))), ("not length")));
        ((fieldType) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}}))));
        ((index) = ((usize)(1llu)));
    }

    else {
        Type_u *_t = (((getRegisterPS7132S6939rPS1534)((function), (result)))->typ);
        if (((isStructPU5175rB)((_t))) || ((isStructPointerPU5175rB)((_t)))) {
            if (!((isStructPointerPU5175rB)((_t)))) {
                Type_u *t1 = ((intoPointerPU5175rPU5175)((_t)));
                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), (t1)));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (alloca), ((getSizeInBytesPU5175rusz)((_t)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (alloca), (result)));
                ((result) = (alloca));
                ((_t) = (t1));
            }

            ParsedStructDecl_s *decl = (NULL);
            bool succ_5571_ = true;
            bool succ_5568_ = true;

            Type_u *tmp_8137_ = (_t);
            {
                succ_5571_ &= (tmp_8137_->tag == 4);
                succ_5568_ &= (tmp_8137_->payload.variant4._0->tag == 7);
                ParsedStructDecl_s **_decl = &tmp_8137_->payload.variant4._0->payload.variant7._0;
                succ_5568_ &= true;
                succ_5571_ &= succ_5568_;
                if (succ_5571_) {
                    {
                        ((decl) = (*_decl));
                    }
                    goto after_8137;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("Expected ptr to struct in Field Access")));
                    }
                    goto after_8137;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_8137:
            (void)0; // error: label at end of compound statement is a C23 extension
            Token_s name = ((Token_s){0});
            bool succ_5578_ = true;

            ExprData_u tmp_8143_ = ((rhs)->data);
            {
                succ_5578_ &= (tmp_8143_.tag == 4);
                IdentExpr_s *ident = &tmp_8143_.payload.variant4._0;
                succ_5578_ &= true;
                if (succ_5578_) {
                    {
                        ((name) = ((*ident).name));
                    }
                    goto after_8143;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("Expected Identifier as RHS of member access")));
                    }
                    goto after_8143;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_8143:
            (void)0; // error: label at end of compound statement is a C23 extension
            ((index) = ((getFieldIndexPS5521PS7720rusz)((decl), (&((name).content)))));
            ParsedTypeNode_s *_f = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (index)));
            ((fieldType) = ((getTypePU9661rPU5175)((&((_f)->typeState)))));
        }

        else if (((isTuplePU5175rB)((_t))) || ((isTuplePointerPU5175rB)((_t)))) {
            if (!((isTuplePointerPU5175rB)((_t)))) {
                Type_u *t1 = ((intoPointerPU5175rPU5175)((_t)));
                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), (t1)));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (alloca), ((getSizeInBytesPU5175rusz)((_t)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (alloca), (result)));
                ((result) = (alloca));
                ((_t) = (t1));
            }

            bool succ_5588_ = true;

            ExprData_u tmp_8157_ = ((rhs)->data);
            succ_5588_ &= (tmp_8157_.tag == 0);
            Token_s *tkn = &tmp_8157_.payload.variant0._0;
            succ_5588_ &= true;
            if (!succ_5588_) {
                ((unreachablePcrN)(("Expected Number as RHS of member access")));
            };
            ((index) = ((usize)(((toU64PS7720ru64)((&((*tkn).content)))))));
            bool succ_5594_ = true;
            bool succ_5591_ = true;

            Type_u *tmp_8160_ = (_t);
            succ_5594_ &= (tmp_8160_->tag == 4);
            succ_5591_ &= (tmp_8160_->payload.variant4._0->tag == 10);
            TypeList_s *tElems = &tmp_8160_->payload.variant4._0->payload.variant10._0;
            succ_5591_ &= true;
            succ_5594_ &= succ_5591_;
            if (!succ_5594_) {
                ((unreachablePcrN)(("Not tuple")));
            };
            ((fieldType) = ((((*tElems).elements))[(index)]));
        }
    }

    RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
    ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((lhs)->span), (fieldPtr), (result), (index)));
    if (needsPtr) {
        return (fieldPtr);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (fieldPtr)));
        return (dst);
    }
}
RegIndex_s prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939(IRGen_s *this, Span_s span, IRFunc_s *function, RegIndex_s base, RegIndexList_s args, Type_u *retType, RegIndex_s retPtr,
                                                                           bool needsPtr) {
    RegIndex_s retVal = ((RegIndex_s){0});
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
        ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (retPtr), (base), (args)));
        if (needsPtr) {
            ((retVal) = (retPtr));
        }

        else {
            ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (reg), (retPtr)));
            ((retVal) = (reg));
        }

    }

    else {
        if ((isStructPU5175rB)((retType))) {
            RegIndex_s reg = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), ((getSizeInBytesPU5175rusz)((retType)))));
            ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (base), (args)));
            RegIndex_s v = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (v)))->typ);
            RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
            usize s = ((getSizeInBytesPU5175rusz)((t)));
            ((assertBrN)(((s) <= ((usize)(8llu)))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (r), (s)));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (r), (reg)));
            if (needsPtr) {
                ((retVal) = (r));
            }

            else {
                ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (v), (r)));
                ((retVal) = (v));
            }

        }

        else {
            RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (base), (args)));
            if (needsPtr) {
                RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType)))));
                ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (tempAlloc), ((getSizeInBytesPU5175rusz)((retType)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tempAlloc), (reg)));
                ((retVal) = (tempAlloc));
            }

            else {
                ((retVal) = (reg));
            }
        }
    }

    Type_u *ft = (((getRegisterPS7132S6939rPS1534)((function), (base)))->typ);
    if ((isPointerPU5175rB)((ft)))
        ((ft) = ((getUnderlyingTypePU5175BrPU5175)((ft), (true))));
    ((assertBPcrN)(((isFunctionPU5175rB)((ft))), ("IRGen: Base is not a function")));
    if ((isNoreturnPU5175rB)((ft))) {
        ((buildUnreachablePS7132S8951rN)((function), (span)));
    }

    return (retVal);
}
RegIndex_s generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, usize funcID, Type_u *retType, RegIndexList_s args) {
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
    {
        Type_u *ft = ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = ((TypeList_s){0}), ._1 = (retType), ._2 = ((FuncAttr_s){.isVariadic = (true)})}}})));
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (ft)));
        ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), (span), (dst), (funcID)));
        ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (dst), (args)));
    }

    return (reg);
}
RegIndex_s generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    ((assertBPcrN)(((((isVariadicTypePU5175rB)((lhsType))) || ((isArrayPU5175rB)((lhsType)))) || ((isPointerPU5175rB)((lhsType)))), ("Expected Array, Ptr or VarArg as LHS in IndexedAccess")));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (!((isPointerPU5175rB)((lhsType))))));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isPointerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ))), ("Expected Ptr as LHS in IndexedAccess")));
    ((assertBPcrN)(((isIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (rhsReg)))->typ))), ("Expected Int as RHS in IndexedAccess")));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
    if (((isArrayPU5175rB)((lhsType))) && (!(*((flags).opt)))) {
        Type_u *arrType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
        usize elemCount = (((getSizeInBytesPU5175rusz)((arrType))) / ((getSizeInBytesPU5175rusz)((type))));
        RegIndex_s cond = ((allocateRegisterPS7132PU5175rS6939)((function), (boolType)));
        RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        IRBlockID_s panic = ((appendBlockPS7132rS7192)((function)));
        IRBlockID_s normal = ((appendBlockPS7132rS7192)((function)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((lhs)->span), (size), (usizeType), (elemCount)));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GTE), (cond), (rhsReg), (size)));
        ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((lhs)->span), (cond), (panic), (normal)));
        ((setCurrentBlockPS7132S7192rN)((function), (panic)));
        RegIndex_s err =
            ((allocateRegisterPS7132PU5175rS6939)((function),
                                                  ((wrapU5175rPU5175)(((Type_u){
                                                      .tag = 4,
                                                      .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})))));
        String_s s = ((copyPS0540rS0540)((&((function)->name))));
        String_s _s = ((toStringPS8951rS0540)((&((lhs)->span))));
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": RUNTIME ERROR: Index out of bounds: Array of size ")));
        ((pushNumberPS0540uszrN)((&(s)), (elemCount)));
        ((pushStrPS0540PcrN)((&(s)), (" has no index %d\n")));
        ((dropPS0540rN)((&(_s))));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((lhs)->span), (err), ((asSubStrPS0540rS7720)((&(s))))));
        usize funcID = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("index_oobPci64rN"), ("prelude.bufo")));
        RegIndexList_s args = ((RegIndexList_s){0});
        ((pushPS9911S6939rN)((&(args)), (err)));
        ((pushPS9911S6939rN)((&(args)), (rhsReg)));
        ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((lhs)->span), (funcID),
                                                                     ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
        ((buildUnreachablePS7132S8951rN)((function), ((lhs)->span)));
        ((setCurrentBlockPS7132S7192rN)((function), (normal)));
    }

    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    RegIndexList_s indices = ((RegIndexList_s){0});
    if ((isArrayPU5175rB)((lhsType))) {
        RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((lhs)->span), (index), (usizeType), ((usize)(0llu))));
        ((pushPS9911S6939rN)((&(indices)), (index)));
    }

    if ((isVariadicTypePU5175rB)((lhsType))) {
        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)(((getUnderlyingTypePU5175BrPU5175)((lhsType), (false)))))));
        ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((lhs)->span), (ptr), (lhsReg), ((usize)(0llu))));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (ptr), (ptr)));
        ((pushPS9911S6939rN)((&(indices)), (rhsReg)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((lhs)->span), (elemPtr), (ptr), (indices)));
    }

    else {
        ((pushPS9911S6939rN)((&(indices)), (rhsReg)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((lhs)->span), (elemPtr), (lhsReg), (indices)));
    }

    if (needsPtr) {
        return (elemPtr);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (elemPtr)));
        return (dst);
    }
}
none addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, usize index, bool isComptime) {
    ((addEntryPS7082S7720S6939BrN)((scope), (name), (reg), (isComptime)));
    if (*((flags).debug)) {
        ((buildDebugInfoParamPS7132S8951S6939uszS7720rN)((function), (span), (reg), (index), (name)));
    }
}
none addVariablePS9562PS7132S8951PS7082S7720S6939BrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, bool isComptime) {
    ((addEntryPS7082S7720S6939BrN)((scope), (name), (reg), (isComptime)));
    if (*((flags).debug)) {
        ((buildDebugInfoAllocaPS7132S8951S6939S7720rN)((function), (span), (reg), (name)));
    }
}
RegIndex_s generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939(IRGen_s *this, IRFunc_s *function, IdentExpr_s *expr, bool needsPtr) {
    bool isGlobal = (false);
    Type_u *type = ((expr)->type);
    ((assertBPcrN)(((type) != (NULL)), ("IRGen: IdentExpr has unset type!")));
    IRScopeEntry_s *entry = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((expr)->name).content), (&(isGlobal))));
    if ((entry) != (NULL)) {
        if ((((function)->comptimeLevel) > ((usize)(0llu))) && (!((entry)->isComptime))) {
            ((unreachablePcrN)(("Crossing the boundary: comptime IR needs runtime value - The Checker should\'ve caught this")));
        }

        if (needsPtr) {
            if (isGlobal) {
                Type_u *ptrType = ((intoPointerPU5175rPU5175)((type)));
                RegIndex_s global = ((allocateRegisterPS7132PU5175rS6939)((function), (ptrType)));
                if ((entry)->isComptime) {
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (((expr)->name).span), (global), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), (val)));
                }

                else {
                    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), ((entry)->ptr)));
                }

                return (global);
            }

            else {
                if ((entry)->isComptime) {
                    Type_u *ptrType = ((intoPointerPU5175rPU5175)((type)));
                    RegIndex_s global = ((allocateRegisterPS7132PU5175rS6939)((function), (ptrType)));
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (((expr)->name).span), (global), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), (val)));
                    return (global);
                }

                else {
                    return ((entry)->ptr);
                }
            }

        }

        else {
            RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
            if (isGlobal) {
                if ((entry)->isComptime) {
                    ((buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

                else {
                    ((buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

            }

            else {
                if ((entry)->isComptime) {
                    ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

                else {
                    ((buildLoadPS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }
            }

            return (val);
        }

    }

    else {
        if ((isModulePU5175rB)((type))) {
            return ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        }

        else if ((isFunctionPU5175rB)((type))) {
            String_s name = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((expr)->origID)))));
            if (*((flags).opt)) {
                String_s tmp_43027 = (((newReadonlyStringPcrS0540)(("assertBPcrN"))));
                String_s tmp_43041 = (((newReadonlyStringPcrS0540)(("assertBrN"))));

                if ((equalsPS0540PS0540rB)((&(name)), (&tmp_43027))) {
                    ((name) = ((newStringFromStrLitPcrS0540)(("_empty_assertBPcrN"))));
                }

                else if ((equalsPS0540PS0540rB)((&(name)), (&tmp_43041))) {
                    ((name) = ((newStringFromStrLitPcrS0540)(("_empty_assertBrN"))));
                }
            }

            usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(name))));
            RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
            ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), (((expr)->name).span), (dst), (funcID)));
            return (dst);
        }

        else {
            ((unreachablePcrN)(("Exhaustive handling of types in generateBytecodeExprIdentifier")));
        }
    }
}
RegIndex_s generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    ((assertBrN)(((isArithmeticPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&((rhs)->typeState))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5709_ = true;
    bool succ_5714_ = true;
    bool succ_5733_ = true;
    bool succ_5738_ = true;
    bool succ_5743_ = true;

    BinaryExpr_u *tmp_8469_ = (expr);
    {
        succ_5709_ &= (tmp_8469_->tag == 3);
        succ_5709_ &= true;
        succ_5709_ &= true;
        if (succ_5709_) {
            {
                if ((((isIntegerPU5175rB)((lhsType))) || ((isCharPU5175rB)((lhsType)))) && (((isIntegerPU5175rB)((rhsType))) || ((isCharPU5175rB)((rhsType))))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("PTR + INT expected to be PTR")));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (lhsReg), (lhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (dst)));
                }

                else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("INT + PTR expected to be PTR")));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (rhsReg), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (dst)));
                }

                else if (((isFloatPU5175rB)((lhsType))) && ((isFloatPU5175rB)((rhsType)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_ADD), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_PLUS")));
                }
            }
            goto after_8469;
        }
    }
    {
        succ_5714_ &= (tmp_8469_->tag == 4);
        succ_5714_ &= true;
        succ_5714_ &= true;
        if (succ_5714_) {
            {
                Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                if ((((isIntegerPU5175rB)((lhsType))) || ((isCharPU5175rB)((lhsType)))) && (((isIntegerPU5175rB)((rhsType))) || ((isCharPU5175rB)((rhsType))))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (dst), (lhsReg), (rhsReg)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("PTR - INT expected to be PTR")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (lhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (tmp2), (tmp1), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (tmp2)));
                }

                else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("INT - PTR expected to be PTR")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (tmp2), (lhsReg), (tmp1)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (tmp2)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isIntegerPU5175rB)((type))), ("PTR - PTR expected to be INT")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (lhsReg)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp2), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (dst), (tmp1), (tmp2)));
                }

                else if (((isFloatPU5175rB)((lhsType))) && ((isFloatPU5175rB)((rhsType)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_SUB), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_SUB")));
                }
            }
            goto after_8469;
        }
    }
    {
        succ_5733_ &= (tmp_8469_->tag == 5);
        succ_5733_ &= true;
        succ_5733_ &= true;
        if (succ_5733_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_MUL), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_MUL), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_MULT")));
                }
            }
            goto after_8469;
        }
    }
    {
        succ_5738_ &= (tmp_8469_->tag == 6);
        succ_5738_ &= true;
        succ_5738_ &= true;
        if (succ_5738_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_DIV), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_DIV), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_DIV")));
                }
            }
            goto after_8469;
        }
    }
    {
        succ_5743_ &= (tmp_8469_->tag == 7);
        succ_5743_ &= true;
        succ_5743_ &= true;
        if (succ_5743_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_MOD), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_MOD), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_MOD")));
                }
            }
            goto after_8469;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprArithmetic")));
            }
            goto after_8469;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8469:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        Type_u *subType = ((intoPointerPU5175rPU5175)((type)));
        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (ptr), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (ptr), (dst)));
        return (ptr);
    }

    else {
        return (dst);
    }
}
RegIndex_s generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isComparisonPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isBooleanPU5175rB)((type))), ("Comparison expected to evaluate to Bool")));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ);
    bool succ_5765_ = true;
    bool succ_5770_ = true;
    bool succ_5775_ = true;
    bool succ_5780_ = true;
    bool succ_5785_ = true;
    bool succ_5790_ = true;

    BinaryExpr_u *tmp_8544_ = (expr);
    {
        succ_5765_ &= (tmp_8544_->tag == 8);
        succ_5765_ &= true;
        succ_5765_ &= true;
        if (succ_5765_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_EQ), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_EQ), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_EQ")));
                }
            }
            goto after_8544;
        }
    }
    {
        succ_5770_ &= (tmp_8544_->tag == 9);
        succ_5770_ &= true;
        succ_5770_ &= true;
        if (succ_5770_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_NEQ), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_NEQ), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_NEQ")));
                }
            }
            goto after_8544;
        }
    }
    {
        succ_5775_ &= (tmp_8544_->tag == 10);
        succ_5775_ &= true;
        succ_5775_ &= true;
        if (succ_5775_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GT), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_GT), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_GT")));
                }
            }
            goto after_8544;
        }
    }
    {
        succ_5780_ &= (tmp_8544_->tag == 11);
        succ_5780_ &= true;
        succ_5780_ &= true;
        if (succ_5780_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GTE), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_GTE), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_GTE")));
                }
            }
            goto after_8544;
        }
    }
    {
        succ_5785_ &= (tmp_8544_->tag == 12);
        succ_5785_ &= true;
        succ_5785_ &= true;
        if (succ_5785_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_LT), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_LT), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_LT")));
                }
            }
            goto after_8544;
        }
    }
    {
        succ_5790_ &= (tmp_8544_->tag == 13);
        succ_5790_ &= true;
        succ_5790_ &= true;
        if (succ_5790_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_LTE), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_LTE), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_LTE")));
                }
            }
            goto after_8544;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprComparison")));
            }
            goto after_8544;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8544:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isLogicalPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5806_ = true;
    bool succ_5811_ = true;

    BinaryExpr_u *tmp_8559_ = (expr);
    {
        succ_5806_ &= (tmp_8559_->tag == 14);
        succ_5806_ &= true;
        succ_5806_ &= true;
        if (succ_5806_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_LOGICAL_AND), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8559;
        }
    }
    {
        succ_5811_ &= (tmp_8559_->tag == 15);
        succ_5811_ &= true;
        succ_5811_ &= true;
        if (succ_5811_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_LOGICAL_OR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8559;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprLogical")));
            }
            goto after_8559;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8559:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isBitwisePU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5827_ = true;
    bool succ_5832_ = true;
    bool succ_5837_ = true;

    BinaryExpr_u *tmp_8576_ = (expr);
    {
        succ_5827_ &= (tmp_8576_->tag == 16);
        succ_5827_ &= true;
        succ_5827_ &= true;
        if (succ_5827_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_AND), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8576;
        }
    }
    {
        succ_5832_ &= (tmp_8576_->tag == 17);
        succ_5832_ &= true;
        succ_5832_ &= true;
        if (succ_5832_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_OR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8576;
        }
    }
    {
        succ_5837_ &= (tmp_8576_->tag == 18);
        succ_5837_ &= true;
        succ_5837_ &= true;
        if (succ_5837_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_XOR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8576;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprBitwise")));
            }
            goto after_8576;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8576:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s loadLiteralPS9562PS7132S6939PS6070rS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s reg, Token_s *tkn) {
    Type_u *typ = (((getRegisterPS7132S6939rPS1534)((function), (reg)))->typ);
    if (((isIntegerPU5175rB)((typ))) || ((isCharPU5175rB)((typ)))) {
        u64 _value = ((toU64PS7720ru64)((&((tkn)->content))));
        usize value = ((usize)((_value)));
        usize size = ((bitCountuszrusz)((value)));
        usize typsize = ((getSizeInBitsPU5175rusz)((typ)));
        if ((isSignedIntegerPU5175rB)((typ)))
            ((size) = ((size) + ((usize)(1llu))));
        if ((size) > (typsize)) {
            String_s loc = ((toStringPS8951rS0540)((&((tkn)->span))));
            String_s ts = ((toStringPU5175rS0540)((typ)));
            (((fprintf))((stderr_), ("%s: %s: Integer literal (value=%llu) is too big for target type %s.\n"), ((loc).buffer), (ERR_STR), (_value), ((ts).buffer)));
            ((dropPS0540rN)((&(ts))));
            ((dropPS0540rN)((&(loc))));
            (((this)->error) = (true));
        }

        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((tkn)->span), (reg), (typ), (value)));
    }

    else if ((isFloatPU5175rB)((typ))) {
        f64 value = ((toF64PS7720rf64)((&((tkn)->content))));
        ((assertBPcrN)(((value) >= ((f64)(0))), ("Expected FloatLit value to be positive")));
        f64 typmax = ((getMaxFloatValuePU5175rf64)((typ)));
        if ((value) >= (typmax)) {
            String_s loc = ((toStringPS8951rS0540)((&((tkn)->span))));
            String_s ts = ((toStringPU5175rS0540)((typ)));
            (((fprintf))((stderr_), ("%s: %s: Float literal (value=%f) is too big for target type %s.\n"), ((loc).buffer), (ERR_STR), (value), ((ts).buffer)));
            ((dropPS0540rN)((&(ts))));
            ((dropPS0540rN)((&(loc))));
            (((this)->error) = (true));
        }

        if (((getSizeInBytesPU5175rusz)((typ))) == ((usize)(4llu)))
            ((buildLoadF32PS7132S8951S6939f32rN)((function), ((tkn)->span), (reg), ((f32)((value)))));
        else if (((getSizeInBytesPU5175rusz)((typ))) == ((usize)(8llu)))
            ((buildLoadF64PS7132S8951S6939f64rN)((function), ((tkn)->span), (reg), (value)));
        else
            ((unreachablePcrN)(("load float")));
    }

    else {
        ((unreachablePcrN)(("loadLiteral: Expected Integer, Char or Float")));
    }

    return (reg);
}
RegIndex_s generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    ((assertBrN)(((isLiteralPS2435rB)((expr)))));
    Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
    bool succ_5863_ = true;
    bool succ_5867_ = true;
    bool succ_5870_ = true;
    bool succ_5873_ = true;
    bool succ_5876_ = true;
    bool succ_5880_ = true;
    bool succ_5884_ = true;

    ExprData_u *tmp_8706_ = (&((expr)->data));
    {
        succ_5863_ &= (tmp_8706_->tag == 0);
        Token_s *value = &tmp_8706_->payload.variant0._0;
        succ_5863_ &= true;
        if (succ_5863_) {
            {
                ((loadLiteralPS9562PS7132S6939PS6070rS6939)((this), (function), (reg), (&(*value))));
            }
            goto after_8706;
        }
    }
    {
        succ_5867_ &= (tmp_8706_->tag == 1);
        Token_s *value = &tmp_8706_->payload.variant1._0;
        succ_5867_ &= true;
        if (succ_5867_) {
            {
                ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((expr)->span), (reg), ((*value).content)));
            }
            goto after_8706;
        }
    }
    {
        succ_5870_ &= (tmp_8706_->tag == 14);
        if (succ_5870_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), ((usize)(1llu))));
            }
            goto after_8706;
        }
    }
    {
        succ_5873_ &= (tmp_8706_->tag == 15);
        if (succ_5873_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), ((usize)(0llu))));
            }
            goto after_8706;
        }
    }
    {
        succ_5876_ &= (tmp_8706_->tag == 12);
        if (succ_5876_) {
            {
                ((buildLoadNullPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
            }
            goto after_8706;
        }
    }
    {
        succ_5880_ &= (tmp_8706_->tag == 2);
        Token_s *value = &tmp_8706_->payload.variant2._0;
        succ_5880_ &= true;
        if (succ_5880_) {
            {
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (reg), (t), ((usize)((((((*value).content).start))[((usize)(0llu))])))));
            }
            goto after_8706;
        }
    }
    {
        succ_5884_ &= (tmp_8706_->tag == 3);
        ArrayContext_s *context = &tmp_8706_->payload.variant3._0;
        succ_5884_ &= true;
        if (succ_5884_) {
            {
                ((assertBPcrN)(((isArrayPU5175rB)((t))), ("ArrayLit expected to be array")));
                if (((getSizeInBytesPU5175rusz)((t))) > ((usize)(4096llu)))
                    ((warningPcrN)(("Array Literal is big and slows down the IR")));
                if (((*context).size) == ((usize)(0llu))) {
                    if ((((getSizeInBytesPU5175rusz)((t))) == ((usize)(0llu))) && (*((flags).warnSimple))) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Array is zero-sized and can never be indexed into.\n"), ((loc).buffer), (WARN_STR)));
                        ((dropPS0540rN)((&(loc))));
                    }

                    ((buildCreateArrayPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                    for (usize i = ((usize)(0llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedExpr_s *elem = ((atPS7882uszrPS2435)((&(exprs)), ((getElementAtIndexPS8905uszrusz)((&(*context)), (i)))));
                        RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (elem), (false)));
                        ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), (i), (result)));
                    }

                    if (needsPtr) {
                        Type_u *subType = ((intoPointerPU5175rPU5175)((t)));
                        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (ptr), ((getSizeInBytesPU5175rusz)((t)))));
                        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (ptr), (reg)));
                        return (ptr);
                    }

                    else {
                        return (reg);
                    }

                }

                else {
                    ParsedExpr_s *elem = ((atPS7882uszrPS2435)((&(exprs)), ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu))))));
                    RegIndex_s value = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (elem), (false)));
                    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                    Type_u *elemType = ((getTypePU9661rPU5175)((&((elem)->typeState))));
                    RegIndex_s arrayPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s one = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s indexPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((usizeType)))));
                    RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s cond = ((allocateRegisterPS7132PU5175rS6939)((function), (boolType)));
                    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((elemType)))));
                    IRBlockID_s start = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s body = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s end = ((appendBlockPS7132rS7192)((function)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (arrayPtr), ((getSizeInBytesPU5175rusz)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (indexPtr), ((getSizeInBytesPU5175rusz)((usizeType)))));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (zero), (usizeType), ((usize)(0llu))));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (one), (usizeType), ((usize)(1llu))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (indexPtr), (zero)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (size), (usizeType), ((*context).size)));
                    ((buildBrPS7132S8951S7192rN)((function), ((expr)->span), (start)));
                    ((setCurrentBlockPS7132S7192rN)((function), (start)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (index), (indexPtr)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_CMP_LT), (cond), (index), (size)));
                    ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((expr)->span), (cond), (body), (end)));
                    ((setCurrentBlockPS7132S7192rN)((function), (body)));
                    RegIndexList_s indices = ((RegIndexList_s){0});
                    ((pushPS9911S6939rN)((&(indices)), (zero)));
                    ((pushPS9911S6939rN)((&(indices)), (index)));
                    ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((expr)->span), (elemPtr), (arrayPtr), (indices)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (elemPtr), (value)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (index), (indexPtr)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_ADD), (index), (index), (one)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (indexPtr), (index)));
                    ((buildBrPS7132S8951S7192rN)((function), ((expr)->span), (start)));
                    ((setCurrentBlockPS7132S7192rN)((function), (end)));
                    if (needsPtr) {
                        return (arrayPtr);
                    }

                    else {
                        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (reg), (arrayPtr)));
                        return (reg);
                    }
                }
            }
            goto after_8706;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprLiteral")));
            }
            goto after_8706;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8706:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((t)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
        return (tempAlloc);
    }

    return (reg);
}
RegIndex_s generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr) {
    ((assertBrN)(((isAssignmentPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (true)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isPointerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ))), ("Assignment expected Ptr as LHS")));
    ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (lhsReg), (rhsReg)));
    return (rhsReg);
}
RegIndex_s generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnaryExpr_u *expr, Type_u *type, bool needsPtr) {
    bool succ_5944_ = true;
    bool succ_5956_ = true;
    bool succ_5966_ = true;
    bool succ_5978_ = true;
    bool succ_5986_ = true;

    UnaryExpr_u *tmp_8786_ = (expr);
    {
        succ_5944_ &= (tmp_8786_->tag == 0);
        ParsedExpr_s **subExpr = &tmp_8786_->payload.variant0._0;
        succ_5944_ &= true;
        if (succ_5944_) {
            {
                ((startComptimePS7132rN)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((endComptimePS7132rN)((function)));
                ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (span), (r), (result)));
                if (needsPtr) {
                    Type_u *subType = ((intoPointerPU5175rPU5175)((type)));
                    RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (ptr), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (ptr), (r)));
                    return (ptr);
                }

                else {
                    return (r);
                }
            }
            goto after_8786;
        }
    }
    {
        succ_5956_ &= (tmp_8786_->tag == 2);
        ParsedExpr_s **subExpr = &tmp_8786_->payload.variant2._0;
        succ_5956_ &= true;
        if (succ_5956_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                IRReg_s *ptr = ((getRegisterPS7132S6939rPS1534)((function), (result)));
                ((assertBPcrN)(((isPointerPU5175rB)(((ptr)->typ))), ("Expected Ptr SubExpr in Unary Deref")));
                if (needsPtr) {
                    return (result);
                }

                else {
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (val), (result)));
                    return (val);
                }
            }
            goto after_8786;
        }
    }
    {
        succ_5966_ &= (tmp_8786_->tag == 1);
        ParsedExpr_s **subExpr = &tmp_8786_->payload.variant1._0;
        succ_5966_ &= true;
        if (succ_5966_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (true)));
                IRReg_s *ptrReg = ((getRegisterPS7132S6939rPS1534)((function), (result)));
                if ((needsPtr) || (!((isPointerPU5175rB)(((ptrReg)->typ))))) {
                    Type_u *subType = ((intoPointerPU5175rPU5175)(((ptrReg)->typ)));
                    RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (ptr), ((getSizeInBytesPU5175rusz)(((ptrReg)->typ)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (ptr), (result)));
                    return (ptr);
                }

                else {
                    return (result);
                }
            }
            goto after_8786;
        }
    }
    {
        succ_5978_ &= (tmp_8786_->tag == 4);
        ParsedExpr_s **subExpr = &tmp_8786_->payload.variant4._0;
        succ_5978_ &= true;
        if (succ_5978_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((buildLogicalNotPS7132S8951S6939S6939rN)((function), (span), (r), (result)));
                return (r);
            }
            goto after_8786;
        }
    }
    {
        succ_5986_ &= (tmp_8786_->tag == 3);
        ParsedExpr_s **subExpr = &tmp_8786_->payload.variant3._0;
        succ_5986_ &= true;
        if (succ_5986_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                if ((isIntegerPU5175rB)((type))) {
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (zero), (type), ((usize)(0llu))));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_SUB), (result), (zero), (result)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    if (((getSizeInBytesPU5175rusz)((type))) == ((usize)(4llu)))
                        ((buildLoadF32PS7132S8951S6939f32rN)((function), (span), (zero), ((f32)(0))));
                    else if (((getSizeInBytesPU5175rusz)((type))) == ((usize)(8llu)))
                        ((buildLoadF64PS7132S8951S6939f64rN)((function), (span), (zero), ((f64)(0))));
                    else
                        ((unreachablePcrN)(("negation float")));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_FLOAT_SUB), (result), (zero), (result)));
                }

                else {
                    ((unreachablePcrN)(("Exhaustive handling of negation variants in generateBytecodeExprUnary")));
                }

                return (result);
            }
            goto after_8786;
        }
    }
    {
        if (true) {
            {
            }
            goto after_8786;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8786:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprUnary")));
}
none prepareParameterPS9562PS7132uszS8951S7720PU5175BrN(IRGen_s *this, IRFunc_s *function, usize index, Span_s span, SubStr_s name, Type_u *typ, bool retValue) {
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        Type_u *t =
            ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}})));
        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((t)))));
        RegIndex_s instance = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (instance), (value)));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (instance)));
        ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
    }

    else if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((t)))));
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        if ((isPointerPU5175rB)((t))) {
            RegIndex_s instance = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (instance), (value)));
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (instance)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }

        else {
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (value)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }

    }

    else {
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((typ)))));
        if (retValue) {
            ((assertBrN)(((index) == ((usize)(0llu)))));
            (((*(function)).retPtr) = (value));
        }

        else {
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (value)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }
    }
}
RegIndex_s getRegisterForSizePS9562PS7132uszrS6939(IRGen_s *this, IRFunc_s *function, usize size) {
    RegIndex_s v = ((RegIndex_s){0});
    if ((size) <= ((usize)(1llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))))));
    }

    else if ((size) <= ((usize)(2llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))))));
    }

    else if ((size) <= ((usize)(4llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))))));
    }

    else if ((size) <= ((usize)(8llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))))));
    }

    else {
        ((unreachablePcrN)(("getRegisterForSize called with size > 8")));
    }

    return (v);
}
RegIndex_s prepareArgumentPS9562PS7132S8951S6939PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, RegIndex_s value, Type_u *typ) {
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (tempAlloc), ((getSizeInBytesPU5175rusz)((typ)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tempAlloc), (value)));
        return (tempAlloc);
    }

    else if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        RegIndex_s alloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (alloc), (size)));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (alloc), (value)));
        if ((size) > ((usize)(8llu)))
            return (alloc);
        RegIndex_s v = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), (size)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (v), (alloc)));
        return (v);
    }

    else {
        return (value);
    }
}
RegIndex_s generateBytecodeExprCallPS9562PS7132PS3328BrS6939(IRGen_s *this, IRFunc_s *function, CallExpr_s *expr, bool needsPtr) {
    RegIndex_s base = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), ((expr)->base), (false)));
    Type_u *typ = ((expr)->retType);
    ((assertBPcrN)(((typ) != (NULL)), ("IRGen: CallExpr has invalid return type")));
    RegIndexList_s args = ((RegIndexList_s){0});
    RegIndex_s retPtr = ((RegIndex_s){0});
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        ((retPtr) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ))))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (retPtr), ((getSizeInBytesPU5175rusz)((typ)))));
        ((pushPS9911S6939rN)((&(args)), (retPtr)));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&((expr)->args)), (i))));
        Type_u *argType = ((getTypePU9661rPU5175)((&((arg)->typeState))));
        RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (arg), (false)));
        ((pushPS9911S6939rN)((&(args)), ((prepareArgumentPS9562PS7132S8951S6939PU5175rS6939)((this), (function), ((arg)->span), (result), (argType)))));
    }

    return ((prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939)((this), ((expr)->span), (function), (base), (args), (typ), (retPtr), (needsPtr)));
}
IRGen_s newIRGeneratorPS7791rS9562(Lookup_s *lookup) {
    return ((IRGen_s){.globalScope = ((IRFunc_s){.name = ((newStringFromStrLitPcrS0540)(("__global__"))), .originalID = (((funcDecls).length) + ((usize)(1llu))), .comptimeLevel = ((usize)(0llu))}),
                      .lookup = (lookup)});
}
none addImportRootPS2466S7720rN(Parser_s *this, SubStr_s filePath) {
    String_s root = ((getPathParentPS7720rS0540)((&(filePath))));
    if (((this)->importRootLength) >= ((this)->importRootCapacity)) {
        usize newCap = (((this)->importRootCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->importRoots) = (((realloc))(((this)->importRoots), ((newCap) * (sizeof(String_s))))));
        ((assertBPcrN)((((this)->importRoots) != (NULL)), ("Could not resize import roots")));
        (((this)->importRootCapacity) = (newCap));
    }

    (((((this)->importRoots))[((this)->importRootLength)]) = (root));
    (((this)->importRootLength) = (((this)->importRootLength) + ((usize)(1llu))));
}
String_s getImportRootAtIndexPS2466uszrS0540(Parser_s *this, usize index) { return ((copyPS0540rS0540)((&((((this)->importRoots))[(index)])))); }
none inheritImportRootsPS2466PS2466rN(Parser_s *this, Parser_s *parent) {
    for (usize i = ((usize)(0llu)); ((i) < ((parent)->importRootLength)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s root = ((getImportRootAtIndexPS2466uszrS0540)((parent), (i)));
        ((addImportRootPS2466S7720rN)((this), ((asSubStrPS0540rS7720)((&(root))))));
        ((dropPS0540rN)((&(root))));
    }
}
Token_s expectSoftIdentifierPS2466rS6070(Parser_s *this) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if ((((tkn).kind) != (TOKEN_KEYWORD)) && (((tkn).kind) != (TOKEN_IDENT))) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Identifier, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    if ((((((((((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_NULL)))) || ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TRUE))))) ||
              ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FALSE))))) ||
             ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_BLANK))))) ||
            ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_SIZEOF))))) ||
           ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_ASM))))) ||
          ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC))))) ||
         ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))))) ||
        ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TYPEINFO))))) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Identifier, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    return (tkn);
}
Token_s expectPS2466uszrS6070(Parser_s *this, usize tknKind) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) != (tknKind)) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        char *exp = ((tokenKindToStringuszrPc)((tknKind)));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected %s, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), (exp), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    return (tkn);
}
bool eatPS2466uszrB(Parser_s *this, usize tknKind) {
    if ((atPS2466uszrB)((this), (tknKind))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return (true);
    }

    return (false);
}
bool atPS2466uszrB(Parser_s *this, usize tknKind) {
    if ((((peekPS3493rS6070)((&((this)->lexer)))).kind) == (tknKind)) {
        return (true);
    }

    return (false);
}
bool parsedEOFPS2466rB(Parser_s *this) { return ((((peekPS3493rS6070)((&((this)->lexer)))).kind) == (TOKEN_EOF)); }
bool _anon_25_1PS2466PS1892S7720rB(Parser_s *this, ParsedFile_s *root, SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < ((((root)->mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *_imp = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((root)->mod)->tlis)), (i))))));
        if (((_imp)->kind) == (TLI_IMPORT)) {
            ParsedFile_s *imp = ((atPS9483uszrPS1892)((&(files)), ((_imp)->nodeID)));
            String_s impPath = ((toStringPS7720rS0540)((&((imp)->origin))));
            String_s impFile = ((getFileNamePS0540rS0540)((&(impPath))));
            ((dropPS0540rN)((&(impPath))));
            SubStr_s tmp_45905 = ((asSubStrPS0540rS7720)((&(impFile))));

            if ((equalsPS7720PS7720rB)((&tmp_45905), (&(name)))) {
                ((dropPS0540rN)((&(impFile))));
                return (true);
            }

            ((dropPS0540rN)((&(impFile))));
        }
    }

    return (false);
}
none _anon_25_0PS2466PS1892BPcrN(Parser_s *this, ParsedFile_s *root, bool cond, char *name) {
    if (!(cond))
        return;
    bool (*checkIfImported)(Parser_s *, ParsedFile_s *, SubStr_s) = (_anon_25_1PS2466PS1892S7720rB);
    if (!((checkIfImported)((this), (root), ((newSubStrOfStrLitPcrS7720)((name)))))) {
        Span_s loc = (((root)->mod)->span);
        ParsedTopLevelItem_s *imp = ((parseImportByNamePS2466S8951S0540BrPS1038)((this), (loc), ((newStringFromStrLitPcrS0540)((name))), (false)));
        ((assertBPcrN)(((imp) != (NULL)), ("Could not import file!")));
        ((pushPS4113uszrN)((&(((root)->mod)->tlis)), ((getIDPS1038rusz)((imp)))));
    }
}
ParsedFile_s parseProjectPS2466S7720rS1892(Parser_s *this, SubStr_s root) {
    ((assertBPcrN)(((((this)->lexer).fileID) == ((usize)(0llu))), ("Expected Parser.parseProject to be the root")));
    ParsedFile_s *rootFile = ((newParsedFileS7720S7720rPS1892)((root), (((this)->lexer).content)));
    ((assertBPcrN)((((getIDPS1892rusz)((rootFile))) == ((usize)(0llu))), ("Expected Parser.parseProject result to be the root")));
    ((parseFilePS2466S7720PS1892rN)((this), (root), (rootFile)));
    none (*importIf)(Parser_s *, ParsedFile_s *, bool, char *) = (_anon_25_0PS2466PS1892BPcrN);
    ((importIf)((this), (rootFile), (*((flags).trace)), ("trace.bufo")));
    ((importIf)((this), (rootFile), (needsPrelude), ("prelude.bufo")));
    ((importIf)((this), (rootFile), (needsAssembly), ("asm.bufo")));
    ((importIf)((this), (rootFile), (needsTypeInfo), ("type_info.bufo")));
    ((importIf)((this), (rootFile), (true), ("runtime.bufo")));
    if (syntaxError) {
        (((C_exiti32rN))(((i32)(1))));
    }

    return (*(rootFile));
}
none parseFilePS2466S7720PS1892rN(Parser_s *this, SubStr_s root, ParsedFile_s *file) {
    (((file)->mod) = ((newParsedModuleS5656S8951S6070S4113rPS1882)(((TLIParent_s){0}), ((Span_s){0}), ((Token_s){0}), ((UsizeList_s){0}))));
    ((addImportRootPS2466S7720rN)((this), (root)));
    while (!((parsedEOFPS2466rB)((this)))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (false)));
        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S4756BrPS1038)((this), (attributes), (skip)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S4756BrPS1038)((this), (attributes), (skip)));
            ((pushPS4113uszrN)((&(((file)->mod)->tlis)), ((getIDPS1038rusz)((item)))));
        }
    }
}
bool parseAttributesPS2466PS4756BrB(Parser_s *this, ParsedAttributeList_s *attrs, bool inModule) {
    bool skip = (false);
    while ((eatPS2466uszrB)((this), (TOKEN_AT))) {
        Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
        if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_EXTERN)))) {
            if ((!(inModule)) && (*((flags).warnExtra))) {
                String_s loc = ((toStringPS8951rS0540)((&((name).span))));
                (((fprintf))((stderr_), ("%s: %s: `@extern()` used outside of a module.\n"), ((loc).buffer), (WARN_STR)));
                ((dropPS0540rN)((&(loc))));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            Token_s v = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            ((pushPS4756U4360rN)((attrs), ((ParsedAttribute_u){.tag = 1, .payload = {.variant1 = {._0 = (v)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_OS)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            Token_s os = ((expectPS2466uszrS6070)((this), (TOKEN_IDENT)));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            if ((!((equalsPS7720PS7720rB)((&((os).content)), (&(OS_WINDOWS))))) && (!((equalsPS7720PS7720rB)((&((os).content)), (&(OS_LINUX)))))) {
                (((fprintf))((stderr_), ("%s\n"), (((toStringPS7720rS0540)((&((os).content)))).buffer)));
                ((todo_with_msgPcrN)(("Unknown os")));
            }

            SubStr_s tmp_46181 = ((asSubStrPS0540rS7720)(((flags).target)));

            ((skip) = (!((equalsPS7720PS7720rB)((&((os).content)), (&tmp_46181)))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NORETURN)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 3, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NAKED)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NO_MANGLE)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 5, .payload = {0}}))));
        }

        else {
            String_s loc = ((toStringPS8951rS0540)((&((name).span))));
            String_s n = ((toStringPS7720rS0540)((&((name).content))));
            (((fprintf))((stderr_), ("%s: %s: Use of unknown attribute `%s`.\n"), ((loc).buffer), (ERR_STR), ((n).buffer)));
            ((dropPS0540rN)((&(n))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }
    }

    return (skip);
}
ParsedTopLevelItem_s *parseTopLevelItemPS2466S4756BrPS1038(Parser_s *this, ParsedAttributeList_s attributes, bool skip) {
    return ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), ((TLIParent_s){.isFile = (true), .id = ((u32)((((this)->lexer).fileID)))}), (attributes), (skip)));
}
ParsedTopLevelItem_s *parseTopLevelItemPS2466S5656S4756BrPS1038(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes, bool skip) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_IMPORT)))) {
        return ((parseImportPS2466BrPS1038)((this), (skip)));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_CONFIG)))) {
        return ((asTLIPS0890rPS1038)(((parseConfigPS2466S5656S4756rPS0890)((this), (parent), (attributes)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_MODULE)))) {
        return ((asTLIPS1882rPS1038)(((parseModulePS2466S5656S4756rPS1882)((this), (parent), (attributes)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET)))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return ((asTLIPS1100rPS1038)(((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (true)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME)))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return ((asTLIPS1100rPS1038)(((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (true)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_STRUCT)))) {
        return ((asTLIPS5521rPS1038)(((parseStructDeclPS2466S5656rPS5521)((this), (parent)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_UNION)))) {
        return ((asTLIPS0997rPS1038)(((parseUnionDeclPS2466S5656rPS0997)((this), (parent)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC)))) {
        bool isExtern = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((attributes).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedAttribute_u tmp_46427 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

            if (((tagAnyru8)((&((((attributes).elements))[(i)])))) == (((tagAnyru8)((&tmp_46427))))) {
                ((isExtern) = (true));
                break;
            }
        }

        ParsedFuncDecl_s *decl = ((parseFuncDeclPS2466S5656BrPS4904)((this), (parent), (isExtern)));
        (((decl)->attrs) = (attributes));
        return ((asTLIPS4904rPS1038)((decl)));
    }

    else {
        String_s loc = ((toStringPS8951rS0540)((&((tkn).span))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Top Level Keyword, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        (((fprintf))((stderr_), ("%s: %s: A non-exhaustive list of TLK: `import`, `let`, `comptime`, `struct`, `union`, `func`.\n"), ((loc).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedModule_s *parseModulePS2466S5656S4756rPS1882(Parser_s *this, TLIParent_s _parent, ParsedAttributeList_s modAttr) {
    Token_s modTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((modTkn).content)), (&(KEYWORD_MODULE))))));
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    UsizeList_s tlis = ((UsizeList_s){0});
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedModule_s *mod = ((newParsedModuleS5656S8951S6070S4113rPS1882)((_parent), ((Span_s){0}), (name), ((UsizeList_s){0})));
    TLIParent_s parent = ((TLIParent_s){.isFile = (false), .id = ((u32)(((getIDPS1882rusz)((mod)))))});
    bool anyExtern = (false);
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (true)));
        for (usize i = ((usize)(0llu)); ((!(anyExtern)) && ((i) < ((attributes).length))); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedAttribute_u tmp_46568 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

            if (((tagAnyru8)((&((((attributes).elements))[(i)])))) == (((tagAnyru8)((&tmp_46568))))) {
                ((anyExtern) = (true));
                break;
            }
        }

        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), (parent), (attributes), (skip)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), (parent), (attributes), (skip)));
            ((pushPS4113uszrN)((&(tlis)), ((getIDPS1038rusz)((item)))));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((modTkn).span)), (&((end).span))));
    (((mod)->span) = (span));
    (((mod)->tlis) = (tlis));
    if (anyExtern) {
        UsizeList_s modConfigs = ((UsizeList_s){0});
        bool anyLibrary = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *t = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(tlis)), (i))))));
            if (((t)->kind) == (TLI_CONFIG)) {
                ((pushPS4113uszrN)((&(modConfigs)), (*((atPS4113uszrPusz)((&(tlis)), (i))))));
                ParsedConfig_s *cfg = ((atPS9153uszrPS0890)((&(configs)), ((t)->nodeID)));
                TokenList_s paths = ((TokenList_s){0});
                SubStr_s tmp_46683 = ((newSubStrOfStrLitPcrS7720)((".")));

                ((pushPS9938S6070rN)((&(paths)), ((newTokenuszPS7720uszuszrS6070)(((usize)((((mod)->parent).id))), (&tmp_46683), ((usize)(0llu)), (TOKEN_DOT)))));
                for (usize j = ((usize)(0llu)); ((j) < (((cfg)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
                    Config_u *_cfg = ((atPS1575uszrPU7467)((&((cfg)->configs)), (j)));
                    bool succ_6148_ = true;

                    Config_u *tmp_9150_ = (_cfg);
                    {
                        succ_6148_ &= (tmp_9150_->tag == 3);
                        Token_s *p = &tmp_9150_->payload.variant3._0;
                        succ_6148_ &= true;
                        if (succ_6148_) {
                            {
                                String_s _p = ((toStringPS7720rS0540)((&((*p).content))));
                                if ((dirExistsPcrB)(((_p).buffer))) {
                                    ((pushPS9938S6070rN)((&(paths)), (*p)));
                                }

                                ((dropPS0540rN)((&(_p))));
                            }
                            goto after_9150;
                        }
                    }
                    {
                        if (true) {
                            {
                            }
                            goto after_9150;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_9150:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }

                for (usize k = ((usize)(0llu)); ((k) < ((paths).length)); ((k) = ((k) + ((usize)(1llu))))) {
                    SubStr_s tmp_46748 = (((atPS9938uszrPS6070)((&(paths)), (k)))->content);

                    String_s _path = ((toStringPS7720rS0540)((&tmp_46748)));
                    String_s path = ((toAbsolutePathPS0540rS0540)((&(_path))));
                    ((pushCharPS0540crN)((&(path)), ('\\')));
                    for (usize j = ((usize)(0llu)); ((j) < (((cfg)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        Config_u *_cfg = ((atPS1575uszrPU7467)((&((cfg)->configs)), (j)));
                        bool succ_6161_ = true;
                        bool succ_6165_ = true;

                        Config_u *tmp_9192_ = (_cfg);
                        {
                            succ_6161_ &= (tmp_9192_->tag == 1);
                            Token_s *name = &tmp_9192_->payload.variant1._0;
                            succ_6161_ &= true;
                            if (succ_6161_) {
                                {
                                    ((anyLibrary) = (true));
                                }
                                goto after_9192;
                            }
                        }
                        {
                            succ_6165_ &= (tmp_9192_->tag == 2);
                            Token_s *name = &tmp_9192_->payload.variant2._0;
                            succ_6165_ &= true;
                            if (succ_6165_) {
                                {
                                    ((anyLibrary) = (true));
                                    String_s libPath = ((copyPS0540rS0540)((&(path))));
                                    ((pushSubStrPS0540PS7720rN)((&(libPath)), (&((*name).content))));
                                    if (*((flags).verbose))
                                        (((printf))(("[INFO] Trying to load %s: "), ((libPath).buffer)));
                                    Any file = (((fopen))(((libPath).buffer), ("r")));
                                    if ((file) == (NULL)) {
                                        if (*((flags).verbose)) {
                                            (((printf))(("No such file or directory\n")));
                                        }

                                        ((dropPS0540rN)((&(libPath))));
                                        continue;
                                    }

                                    (((fclose))((file)));
                                    Handle_s handle = (((LoadLibraryA))(((libPath).buffer)));
                                    if ((isNullS9457rB)((handle))) {
                                        if (*((flags).verbose)) {
                                            (((printf))(("Could not load DLL\n")));
                                        }

                                        ((dropPS0540rN)((&(libPath))));
                                        continue;
                                    }

                                    if (*((flags).verbose))
                                        (((printf))(("Success. Handle = %p\n"), ((handle).ptr)));
                                    ((pushPS4113uszrN)((&((mod)->dlls)), ((getIDPS3633rusz)(((newDLLS0540S9457rPS3633)((libPath), (handle)))))));
                                }
                                goto after_9192;
                            }
                        }
                        {
                            if (true) {
                                {
                                }
                                goto after_9192;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_9192:
                        (void)0; // error: label at end of compound statement is a C23 extension
                    }

                    ((dropPS0540rN)((&(_path))));
                    ((dropPS0540rN)((&(path))));
                }
            }
        }

        if (((modConfigs).length) == ((usize)(0llu))) {
            String_s loc = ((toStringPS8951rS0540)((&((mod)->span))));
            (((fprintf))((stderr_), ("%s: %s: Module contains @extern() functions, but no config was specified.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: The config contains important information such as linker flags and library paths.\n"), ((loc).buffer), (NOTE_STR)));
            (((fprintf))((stderr_), ("%s: %s: The config can be declared using the top level keyword `config` within the module.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else if (!(anyLibrary)) {
            String_s loc = ((toStringPS8951rS0540)((&((mod)->span))));
            (((fprintf))((stderr_), ("%s: %s: Module contains @extern() functions, but no library was provided in the config.\n"), ((loc).buffer), (ERR_STR)));
            for (usize i = ((usize)(0llu)); ((i) < ((modConfigs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                ParsedTopLevelItem_s *t = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(modConfigs)), (i))))));
                ((assertBrN)((((t)->kind) == (TLI_CONFIG))));
                ((dropPS0540rN)((&(loc))));
                ((loc) = ((toStringPS8951rS0540)((&((t)->span)))));
                (((fprintf))((stderr_), ("%s: %s: Module configuration specified here.\n"), ((loc).buffer), (NOTE_STR)));
            }

            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }
    }

    return (mod);
}
ParsedConfig_s *parseConfigPS2466S5656S4756rPS0890(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes) {
    Token_s cfgTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((cfgTkn).content)), (&(KEYWORD_CONFIG))))));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ConfigList_s flags = ((ConfigList_s){0});
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        Token_s _cfg = ((expectPS2466uszrS6070)((this), (TOKEN_IDENT)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        Token_s value = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
        Config_u cfg = ((newConfigS6070S6070rU7467)((_cfg), (value)));
        Config_u tmp_47094 = (((Config_u){.tag = 0, .payload = {0}}));

        if (((tagAnyru8)((&(cfg)))) == (((tagAnyru8)((&tmp_47094))))) {
            String_s loc = ((toStringPS8951rS0540)((&((_cfg).span))));
            String_s name = ((toStringPS7720rS0540)((&((_cfg).content))));
            (((fprintf))((stderr_), ("%s: %s: Unknown config option `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            (((fprintf))((stderr_), ("%s: %s: A non-exhaustive list of config options: `static`, `dynamic`, `libpath`, `linker`.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else if ((((value).content).len) == ((usize)(0llu))) {
            String_s loc = ((toStringPS8951rS0540)((&((value).span))));
            String_s name = ((toStringPS7720rS0540)((&((_cfg).content))));
            (((fprintf))((stderr_), ("%s: %s: Value for config option `%s` can\'t be empty.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else {
            ((pushPS1575U7467rN)((&(flags)), (cfg)));
        }

        if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
            break;
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    return ((newParsedConfigS8951S1575rPS0890)(((newSpanBetweenPS8951PS8951rS8951)((&((cfgTkn).span)), (&((end).span)))), (flags)));
}
ParsedTopLevelItem_s *parseImportPS2466BrPS1038(Parser_s *this, bool skip) {
    Token_s impTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((impTkn).content)), (&(KEYWORD_IMPORT))))));
    Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
    String_s file = ((toStringPS7720rS0540)((&((tkn).content))));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    return ((parseImportByNamePS2466S8951S0540BrPS1038)((this), ((newSpanBetweenPS8951PS8951rS8951)((&((impTkn).span)), (&((end).span)))), (file), (skip)));
}
ParsedTopLevelItem_s *parseImportByNamePS2466S8951S0540BrPS1038(Parser_s *this, Span_s loc, String_s file, bool skip) {
    String_s src = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->importRootLength)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s path = ((getImportRootAtIndexPS2466uszrS0540)((this), (i)));
        ((pushStringPS0540PS0540rN)((&(path)), (&(file))));
        ((path) = ((toAbsolutePathPS0540rS0540)((&(path)))));
        if ((canReadFileToStringPcPS0540rB)(((path).buffer), (&(src)))) {
            if (skip) {
                ((dropPS0540rN)((&(src))));
                ((dropPS0540rN)((&(path))));
                return (NULL);
            }

            usize fileID = ((usize)(0llu));
            ParsedFile_s *importedFile = (NULL);
            if ((getFileByFilePathS7720PuszrB)(((asSubStrPS0540rS7720)((&(path)))), (&(fileID)))) {
                ((importedFile) = ((atPS9483uszrPS1892)((&(files)), (fileID))));
            }

            else {
                ((importedFile) = ((newParsedFileS7720S7720rPS1892)(((asSubStrPS0540rS7720)((&(path)))), ((asSubStrPS0540rS7720)((&(src)))))));
                ((fileID) = ((getIDPS1892rusz)((importedFile))));
                Parser_s parser = ((newParserFromSourceuszS7720rS2466)((fileID), ((asSubStrPS0540rS7720)((&(src))))));
                ((inheritImportRootsPS2466PS2466rN)((&(parser)), (this)));
                ((parseFilePS2466S7720PS1892rN)((&(parser)), ((asSubStrPS0540rS7720)((&(path)))), (importedFile)));
            }

            ParsedTopLevelItem_s *item = ((newParsedTopLevelItemS8951uszuszrPS1038)((loc), (TLI_IMPORT), (fileID)));
            return (item);
        }

        ((dropPS0540rN)((&(path))));
    }

    String_s _loc = ((toStringPS8951rS0540)((&(loc))));
    (((fprintf))((stderr_), ("%s: %s: Could not import file %s.\n"), ((_loc).buffer), (ERR_STR), ((file).buffer)));
    (((C_exiti32rN))(((i32)(1))));
}
ParsedUnionDecl_s *parseUnionDeclPS2466S5656rPS0997(Parser_s *this, TLIParent_s parent) {
    Token_s kw = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedUnionDecl_s *decl = ((newParsedUnionDeclS5656S8951S6070rPS0997)((parent), ((defaultSpanrS8951)()), (nameTkn)));
    TLIParent_s unionParent = ((TLIParent_s){.id = ((u32)(((getIDPS0997rusz)((decl)))))});
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        ParsedUnionVariant_s *variant = ((parseUnionVariantPS2466S5656rPS3506)((this), (unionParent)));
        ((pushPS0030PS3506rN)((&((decl)->variants)), (variant)));
        if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    (((decl)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span)))));
    return (decl);
}
ParsedUnionVariant_s *parseUnionVariantPS2466S5656rPS3506(Parser_s *this, TLIParent_s parent) {
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    if ((eatPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
        ParsedUnionVariant_s *variant = ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 2, .payload = {.variant2 = {0}}}))));
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
            Token_s fieldName = ((expectSoftIdentifierPS2466rS6070)((this)));
            ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((addNamedFieldPS3506S6070PS1372rN)((variant), (fieldName), (typ)));
            if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
            }
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
        (((variant)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((name).span)), (&((end).span)))));
        return (variant);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedUnionVariant_s *variant = ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 1, .payload = {.variant1 = {0}}}))));
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((addFieldPS3506PS1372rN)((variant), (typ)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
            }
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        (((variant)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((name).span)), (&((end).span)))));
        return (variant);
    }

    else {
        return ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}}))));
    }
}
ParsedStructDecl_s *parseStructDeclPS2466S5656rPS5521(Parser_s *this, TLIParent_s parent) {
    Token_s kw = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedStructDecl_s *decl = ((newParsedStructDeclS5656S8951S6070rPS5521)((parent), ((defaultSpanrS8951)()), (nameTkn)));
    StructContext_s structContext = ((StructContext_s){0});
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        Token_s tkn = ((expectSoftIdentifierPS2466rS6070)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        ((addFieldPS7871S6070PS1372rN)((&(structContext)), (tkn), (typ)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    (((decl)->span) = (span));
    (((decl)->context) = (structContext));
    SubStr_s tmp_47682 = (((newSubStrOfStrLitPcrS7720)(("Data"))));

    if ((equalsPS7720PS7720rB)((&(((decl)->name).content)), (&tmp_47682))) {
        ParsedFile_s *parent = ((getParentFilePS5521rPS1892)((decl)));
        SubStr_s tmp_47696 = (((newSubStrOfStrLitPcrS7720)(("type_info.bufo"))));

        if ((endsWithPS7720PS7720rB)((&((parent)->origin)), (&tmp_47696))) {
            (((decl)->isDataDefinition) = (true));
        }
    }

    return (decl);
}
ParsedFuncDecl_s *parseFuncDeclPS2466S5656BrPS4904(Parser_s *this, TLIParent_s parent, bool isExtern) {
    Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    if (!(isExtern))
        ((assertBrN)(((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC))))));
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    ParamContext_s params = ((parseParametersPS2466rS9803)((this)));
    ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
    if (isExtern) {
        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
        return ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)((parent), (span), (name), (params), (retType), (NULL)));
    }

    else {
        ParsedBlock_s *body = ((parseBlockPS2466rPS7247)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((body)->span))));
        return ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)((parent), (span), (name), (params), (retType), (body)));
    }
}
ParsedTypeNode_s *parseReturnTypePS2466rPS1372(Parser_s *this) {
    if ((eatPS2466uszrB)((this), (TOKEN_ARROW_THIN))) {
        return ((parseTypeNodePS2466rPS1372)((this)));
    }

    else {
        return ((newBuiltinTypeDeclS8951uszrPS1372)((((peekPS3493rS6070)((&((this)->lexer)))).span), (PARSED_TYPE_NONE)));
    }
}
ParamContext_s parseParametersPS2466rS9803(Parser_s *this) {
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    ParamContext_s context = ((ParamContext_s){0});
    bool isVariadic = (false);
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
        if ((eatPS2466uszrB)((this), (TOKEN_DOTDOTDOT))) {
            ((isVariadic) = (true));
            break;
        }

        Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466BrPS1372)((this), (true)));
        ((addParameterPS9803S6070PS1372rN)((&(context)), (name), (typ)));
        if (isVariadic) {
            (((fprintf))((stderr_), ("%s: %s: Cannot specify parameters after variadics.\n"), (((toStringPS8951rS0540)((&((name).span)))).buffer), (ERR_STR)));
            ((syntaxError) = (true));
        }

        else {
            ((isVariadic) = (((typ)->kind) == (PARSED_TYPE_VARIADIC)));
        }

        if (!((eatPS2466uszrB)((this), (TOKEN_COMMA)))) {
            break;
        }
    }

    (((context).isVarArg) = (isVariadic));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    return (context);
}
ParsedBlock_s *parseBlockPS2466rPS7247(Parser_s *this) {
    ParsedBlock_s *block = ((newParsedBlockrPS7247)());
    Token_s start = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (false)));
        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedStmt_s *stmt = ((parseStmtPS2466rPS1100)((this)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedStmt_s *stmt = ((parseStmtPS2466rPS1100)((this)));
            ((addStmtPS7247PS1100rN)((block), (stmt)));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    (((*(block)).span) = ((newSpanBetweenPS8951PS8951rS8951)((&((start).span)), (&((end).span)))));
    return (block);
}
ParsedStmt_s *parseStmtPS2466rPS1100(Parser_s *this) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) == (TOKEN_KEYWORD)) {
        if (((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET)))) || ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (false)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_IF)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseIfStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_RETURN)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseReturnStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_WHILE)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseWhileStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FOR)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseForStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_BREAK)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 9, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_CONTINUE)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 10, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_MATCH)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseMatchStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_ASM)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            ParsedExprList_s args = ((ParsedExprList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ParsedExpr_s *arg = ((parseExprPS2466rPS2435)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                    ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                }

                ((pushPS7823PS2435rN)((&(args)), (arg)));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((needsAssembly) = (true));
            if (((args).length) == ((usize)(0llu))) {
                (((fprintf))((stderr_), ("%s: %s: `asm` expects at least one argument.\n"), (((toStringPS8951rS0540)((&((tkn).span)))).buffer), (ERR_STR)));
                ((syntaxError) = (true));
                return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 12, .payload = {.variant12 = {._0 = (NULL), ._1 = (args)}}})));
            }

            else {
                ParsedExpr_s *fn = ((popPS7823uszrPS2435)((&(args)), ((usize)(0llu))));
                return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 12, .payload = {.variant12 = {._0 = (fn), ._1 = (args)}}})));
            }
        }

    }

    else if (((tkn).kind) == (TOKEN_CURLY_OPEN)) {
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        return ((newParsedStmtS8951U4263rPS1100)(((block)->span), ((StmtData_u){.tag = 4, .payload = {.variant4 = {._0 = (block)}}})));
    }

    ParsedExpr_s *value = ((parseExprPS2466rPS2435)((this)));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((value)->span)), (&((end).span))));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 3, .payload = {.variant3 = {._0 = (value)}}})));
}
ParsedStmt_s *parseMatchStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedPatternList_s patterns = ((ParsedPatternList_s){0});
    ParsedStmtList_s stmts = ((ParsedStmtList_s){0});
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        ParsedPattern_s *pt = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_ARROW_THICK)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        ParsedStmt_s *stmt = ((into_stmtPS7247rPS1100)((block)));
        if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
            ((eatPS2466uszrB)((this), (TOKEN_COMMA)));
        }

        ((pushPS1982PS1826rN)((&(patterns)), (pt)));
        ((pushPS3288PS1100rN)((&(stmts)), (stmt)));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    if (((patterns).length) == ((usize)(0llu))) {
        ((todo_with_msgPcrN)(("parser: 0 arms in match")));
    }

    ((needsPrelude) = (true));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 11, .payload = {.variant11 = {._0 = (expr), ._1 = (patterns), ._2 = (stmts)}}})));
}
ParsedPattern_s *parsePatternPS2466rPS1826(Parser_s *this) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    ParsedPattern_s *retPat = (NULL);
    if ((((tkn).kind) == (TOKEN_IDENT)) || (((tkn).kind) == (TOKEN_KEYWORD))) {
        if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TRUE)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 9, .payload = {.variant9 = {._0 = (true)}}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FALSE)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 9, .payload = {.variant9 = {._0 = (false)}}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_NULL)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 10, .payload = {0}})))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
            ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
            bool succ_6328_ = true;
            bool succ_6332_ = true;

            Pattern_u *tmp_9538_ = (&((subpat)->data));
            {
                succ_6328_ &= (tmp_9538_->tag == 5);
                succ_6328_ &= true;
                succ_6328_ &= true;
                if (succ_6328_) {
                    {
                    }
                    goto after_9538;
                }
            }
            {
                succ_6332_ &= (tmp_9538_->tag == 2);
                succ_6332_ &= true;
                if (succ_6332_) {
                    {
                    }
                    goto after_9538;
                }
            }
            {
                if (true) {
                    {
                        ((todo_with_msgPcrN)(("parser: Path Pattern has non-struct non-ident as RHS")));
                    }
                    goto after_9538;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_9538:
            (void)0; // error: label at end of compound statement is a C23 extension
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 6, .payload = {.variant6 = {._0 = (tkn), ._1 = (subpat)}}}))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
            ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                    Pattern_u tmp_48505 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_48505))))) {
                        Span_s tmp_48518 = (((nextPS3493rS6070)((&((this)->lexer)))).span);

                        String_s loc = ((toStringPS8951rS0540)((&tmp_48518)));
                        (((fprintf))((stderr_), ("%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        ((syntaxError) = (true));
                    }

                    else {
                        ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                    }
                }

                ((pushPS1982PS1826rN)((&(subPatterns)), (subpat)));
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 5, .payload = {.variant5 = {._0 = (tkn), ._1 = (subPatterns)}}}))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
            ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                    Pattern_u tmp_48599 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_48599))))) {
                        Span_s tmp_48612 = (((nextPS3493rS6070)((&((this)->lexer)))).span);

                        String_s loc = ((toStringPS8951rS0540)((&tmp_48612)));
                        (((fprintf))((stderr_), ("%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        ((syntaxError) = (true));
                    }

                    else {
                        ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                    }
                }

                ((pushPS1982PS1826rN)((&(subPatterns)), (subpat)));
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 5, .payload = {.variant5 = {._0 = (tkn), ._1 = (subPatterns)}}}))));
        }

        else {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 2, .payload = {.variant2 = {._0 = (tkn)}}}))));
        }

    }

    else if (((tkn).kind) == (TOKEN_DOTDOT)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 8, .payload = {0}})))));
    }

    else if (((tkn).kind) == (TOKEN_WILDCARD)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 0, .payload = {0}})))));
    }

    else if (((tkn).kind) == (TOKEN_AMPERSAND_SINGLE)) {
        ParsedPattern_s *underlying = ((parsePatternPS2466rPS1826)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((underlying)->span))));
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 4, .payload = {.variant4 = {._0 = (underlying)}}}))));
    }

    else if (((tkn).kind) == (TOKEN_INT_LITERAL)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 1, .payload = {.variant1 = {._0 = (tkn)}}}))));
    }

    else if (((tkn).kind) == (TOKEN_PAREN_OPEN)) {
        ParsedPatternList_s elems = ((ParsedPatternList_s){0});
        while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
            ((pushPS1982PS1826rN)((&(elems)), (pat)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        if (((elems).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Empty tuple patterns are not supported.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if (((elems).length) == ((usize)(1llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: A tuple pattern with one element will never match anything.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 7, .payload = {.variant7 = {._0 = (elems)}}}))));
    }

    if ((retPat) == (NULL)) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Pattern, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    if ((eatPS2466uszrB)((this), (TOKEN_COLON_SINGLE))) {
        ParsedTypeNode_s *type = ((parseTypeNodePS2466rPS1372)((this)));
        return ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 3, .payload = {.variant3 = {._0 = (retPat), ._1 = (type)}}})));
    }

    else {
        return (retPat);
    }
}
ParsedStmt_s *parseForStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if (!((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN)))) {
        ((todo_with_msgPcrN)(("for in loop")));
    }

    else {
        ParsedBlock_s *block = ((newParsedBlockrPS7247)());
        ParsedStmt_s *init = ((parseStmtPS2466rPS1100)((this)));
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        ParsedExpr_s *step = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *body = ((parseStmtPS2466rPS1100)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((body)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 8, .payload = {.variant8 = {._0 = (init), ._1 = (cond), ._2 = (step), ._3 = (body)}}}))));
    }
}
ParsedStmt_s *parseWhileStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *body = ((parseStmtPS2466rPS1100)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((body)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 7, .payload = {.variant7 = {._0 = (cond), ._1 = (body)}}})));
    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
        ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (false)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((block)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 15, .payload = {.variant15 = {._0 = (pat), ._1 = (expr), ._2 = (block)}}})));
    }

    else {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedStmt_s *parseReturnStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    ParsedExpr_s *value = (NULL);
    if (!((atPS2466uszrB)((this), (TOKEN_SEMI_COLON))))
        ((value) = ((parseExprPS2466rPS2435)((this))));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    if ((value) != (NULL)) {
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 2, .payload = {.variant2 = {._0 = (value)}}})));
    }

    else {
        return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 1, .payload = {0}}))));
    }
}
ParsedStmt_s *parseIfStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *ifBody = ((parseStmtPS2466rPS1100)((this)));
        ParsedStmt_s *elseBody = (NULL);
        Span_s end = ((ifBody)->span);
        Token_s maybeElse = ((peekPS3493rS6070)((&((this)->lexer))));
        if (((maybeElse).kind) == (TOKEN_KEYWORD)) {
            if ((equalsPS7720PS7720rB)((&((maybeElse).content)), (&(KEYWORD_ELSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
                ((elseBody) = ((parseStmtPS2466rPS1100)((this))));
                ((end) = ((elseBody)->span));
            }
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&(end))));
        if ((elseBody) != (NULL)) {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 6, .payload = {.variant6 = {._0 = (cond), ._1 = (ifBody), ._2 = (elseBody)}}})));
        }

        else {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 5, .payload = {.variant5 = {._0 = (cond), ._1 = (ifBody)}}})));
        }

    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
        ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (false)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        Span_s end = ((block)->span);
        Token_s maybeElse = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedBlock_s *elseBody = (NULL);
        if (((maybeElse).kind) == (TOKEN_KEYWORD)) {
            if ((equalsPS7720PS7720rB)((&((maybeElse).content)), (&(KEYWORD_ELSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
                ((elseBody) = ((parseBlockPS2466rPS7247)((this))));
                ((end) = ((elseBody)->span));
            }
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&(end))));
        if ((elseBody) != (NULL)) {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 14, .payload = {.variant14 = {._0 = (pat), ._1 = (expr), ._2 = (block), ._3 = (elseBody)}}})));
        }

        else {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 13, .payload = {.variant13 = {._0 = (pat), ._1 = (expr), ._2 = (block)}}})));
        }

    }

    else {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedStmt_s *parseVarDeclStmtPS2466S6070BrPS1100(Parser_s *this, Token_s kw, bool isGlobal) {
    bool isComptime = ((equalsPS7720PS7720rB)((&((kw).content)), (&(KEYWORD_COMPTIME))));
    ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
    ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
    VarDecl_s decl = ((VarDecl_s){.pat = (pat), .expr = (expr), .trampoline = (NULL), .isComptime = (isComptime), .isGlobal = (isGlobal), .origin = (((this)->lexer).fileID)});
    if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s elze = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((elze).content)), (&(KEYWORD_ELSE))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(elze))));
            (((fprintf))((stderr_), ("%s: %s: Expected `else`, got `%.*s`.\n"), ((loc).buffer), (ERR_STR), (((elze).content).len), (((elze).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        (((decl).trampoline) = ((parseBlockPS2466rPS7247)((this))));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 0, .payload = {.variant0 = {._0 = (decl)}}})));
}
ParsedTypeNode_s *parseTypeNodePS2466rPS1372(Parser_s *this) { return ((parseTypeNodePS2466BrPS1372)((this), (false))); }
ParsedTypeNodeList_s _anon_25_2PS2466BrS6760(Parser_s *this, bool allowedVariadic) {
    ParsedTypeNodeList_s tuple = ((ParsedTypeNodeList_s){0});
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
        ParsedTypeNode_s *pt = ((parseTypeNodePS2466BrPS1372)((this), (allowedVariadic)));
        if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        ((pushPS6760PS1372rN)((&(tuple)), (pt)));
    }

    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    return (tuple);
}
ParsedTypeNode_s *parseTypeNodePS2466BrPS1372(Parser_s *this, bool allowedVariadic) {
    Token_s curr = ((peekPS3493rS6070)((&((this)->lexer))));
    ParsedTypeNodeList_s (*parse_tuple)(Parser_s *, bool) = (_anon_25_2PS2466BrS6760);
    if ((atPS2466uszrB)((this), (TOKEN_DOTDOTDOT))) {
        if (!(allowedVariadic)) {
            String_s loc = ((getLocationPS6070rS0540)((&(curr))));
            (((fprintf))((stderr_), ("%s: %s: Cannot use variadics in this context.\n"), ((loc).buffer), (ERR_STR)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((nextPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *varNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_VARIADIC)));
        (((varNode)->underlyingID) = (typ));
        return (varNode);
    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        if (!((equalsPS7720PS7720rB)((&((kw).content)), (&(KEYWORD_FUNC))))) {
            ((expectSoftIdentifierPS2466rS6070)((this)));
        }

        ((nextPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNodeList_s params = ((parse_tuple)((this), (true)));
        ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((retType)->span))));
        ParsedTypeNode_s *funcNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_FUNC)));
        (((funcNode)->underlyingID) = (retType));
        (((funcNode)->fnParams) = (params));
        return (funcNode);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_AMPERSAND_DOUBLE))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *ptr1 = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr1)).underlyingID) = (typ));
        ParsedTypeNode_s *ptr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr)).underlyingID) = (ptr1));
        return (ptr);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_AMPERSAND_SINGLE))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *ptr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr)).underlyingID) = (typ));
        return (ptr);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_SQUARE_OPEN))) {
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        Token_s size = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
        String_s _size = ((toStringPS7720rS0540)((&((size).content))));
        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((end).span))));
        ParsedTypeNode_s *arr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_ARRAY)));
        (((*(arr)).underlyingID) = (typ));
        (((*(arr)).arraySize) = ((usize)(((toU64PS0540ru64)((&(_size)))))));
        ((dropPS0540rN)((&(_size))));
        return (arr);
    }

    else if ((atPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        Token_s t = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNodeList_s tuple = ((parse_tuple)((this), (false)));
        if (((tuple).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(t))));
            (((fprintf))((stderr_), ("%s: %s: Expected tuple type to have at least one element.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedTypeNode_s *last = (*((atPS6760uszrPPS1372)((&(tuple)), (((tuple).length) - ((usize)(1llu))))));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((t).span)), (&((last)->span))));
        ParsedTypeNode_s *tupleNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_TUPLE)));
        (((tupleNode)->fnParams) = (tuple));
        return (tupleNode);
    }

    else {
        Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
        if ((atPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
            ParsedTypeNode_s *node = ((newParsedTypeNodeS8951uszrPS1372)(((nameTkn).span), (PARSED_TYPE_MODULE)));
            ParsedTypeNode_s *orig = (node);
            (((node)->nameTkn) = (nameTkn));
            while ((eatPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
                Token_s typeTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
                Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((node)->span)), (&((typeTkn).span))));
                ParsedTypeNode_s *newNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_MODULE)));
                (((newNode)->nameTkn) = (typeTkn));
                (((node)->underlyingID) = (newNode));
                ((node) = (newNode));
            }

            return (orig);
        }

        else {
            usize maybeBuiltin = ((getBuiltinTypeKindS6070rusz)((nameTkn)));
            if ((maybeBuiltin) == ((usize)(0llu))) {
                ParsedTypeNode_s *typ = ((newParsedTypeNodeS8951uszrPS1372)(((nameTkn).span), (PARSED_TYPE_IDENT)));
                (((*(typ)).nameTkn) = (nameTkn));
                return (typ);
            }

            else {
                return ((newBuiltinTypeDeclS8951uszrPS1372)(((nameTkn).span), (maybeBuiltin)));
            }
        }
    }
}
ParsedExpr_s *parseExprPS2466rPS2435(Parser_s *this) { return ((parseExprPS2466BrPS2435)((this), (true))); }
ParsedExpr_s *parseExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    return ((__parseExprPS2466uszU6350BrPS2435)((this), ((usize)(0llu)), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
}
ParsedExpr_s *__parseExprPS2466uszU6350rPS2435(Parser_s *this, usize precedence, Assoc_u associativity) { return ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (associativity), (true))); }
ParsedExpr_s *__parseExprPS2466uszU6350BrPS2435(Parser_s *this, usize precedence, Assoc_u associativity, bool struct_init_allowed) {
    ParsedExpr_s *expr = ((parsePrimaryExprPS2466BrPS2435)((this), (struct_init_allowed)));
    while ((matchesBinaryExprPS2466rB)((this))) {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        usize newPrec = ((getBinaryPrecedencePS2466PS6070rusz)((this), (&(tkn))));
        if ((newPrec) < (precedence))
            break;
        Assoc_u tmp_50044 = (((Assoc_u){.tag = 0}));

        if (((newPrec) == (precedence)) && (((tagAnyru8)((&(associativity)))) == (((tagAnyru8)((&tmp_50044))))))
            break;
        Assoc_u newAssoc = ((getBinaryAssociativityPS2466PS6070rU6350)((this), (&(tkn))));
        ((expr) = ((parseSecondaryExprPS2466PS2435uszU6350BrPS2435)((this), (expr), (newPrec), (newAssoc), (struct_init_allowed))));
    }

    return (expr);
}
ParsedExpr_s *parsePrimaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    if ((matchesUnaryExprPS2466rB)((this)))
        return ((parseUnaryExprPS2466BrPS2435)((this), (struct_init_allowed)));
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    if ((tknKind) == (TOKEN_INT_LITERAL)) {
        Token_s number = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((number).span), ((ExprData_u){.tag = 0, .payload = {.variant0 = {._0 = (number)}}})));
    }

    else if ((tknKind) == (TOKEN_STRING_LITERAL)) {
        Token_s str = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((str).span), ((ExprData_u){.tag = 1, .payload = {.variant1 = {._0 = (str)}}})));
    }

    else if ((tknKind) == (TOKEN_CHAR_LITERAL)) {
        Token_s ch = ((expectPS2466uszrS6070)((this), (TOKEN_CHAR_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((ch).span), ((ExprData_u){.tag = 2, .payload = {.variant2 = {._0 = (ch)}}})));
    }

    else if ((tknKind) == (TOKEN_PAREN_OPEN)) {
        Token_s t = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
        ParsedExprList_s elems = ((ParsedExprList_s){0});
        while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
            ((pushPS7823PS2435rN)((&(elems)), (expr)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        if (((elems).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(t))));
            (((fprintf))((stderr_), ("%s: %s: Empty tuples are not supported.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if (((elems).length) == ((usize)(1llu))) {
            ParsedExpr_s *expr = ((((elems).elements))[((usize)(0llu))]);
            (((free))(((elems).elements)));
            return (expr);
        }

        else {
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((t).span)), (&((end).span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 20, .payload = {.variant20 = {._0 = (elems)}}})));
        }

    }

    else if ((tknKind) == (TOKEN_SQUARE_OPEN)) {
        Token_s start = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_OPEN)));
        ArrayContext_s arrayContext = ((ArrayContext_s){0});
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_SQUARE_CLOSE))))) {
            ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
            ((addElementPS8905PS2435rN)((&(arrayContext)), (expr)));
            if ((eatPS2466uszrB)((this), (TOKEN_SEMI_COLON))) {
                if (((arrayContext).elemLength) != ((usize)(1llu)))
                    ((todo_with_msgPcrN)(("array lit with given size too many elements")));
                Token_s size = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
                String_s _size = ((toStringPS7720rS0540)((&((size).content))));
                (((arrayContext).size) = ((usize)(((toU64PS0540ru64)((&(_size)))))));
                ((dropPS0540rN)((&(_size))));
                break;
            }

            if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                break;
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((start).span)), (&((end).span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 3, .payload = {.variant3 = {._0 = (arrayContext)}}})));
    }

    else if (((tknKind) == (TOKEN_KEYWORD)) || ((tknKind) == (TOKEN_IDENT))) {
        Token_s ident = ((expectPS2466uszrS6070)((this), (tknKind)));
        if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_NULL)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 12, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_TRUE)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 14, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_FALSE)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 15, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_BLANK)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 13, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_ASM)))) {
            String_s loc = ((getLocationPS6070rS0540)((&(ident))));
            String_s name = ((toStringPS7720rS0540)((&((ident).content))));
            (((fprintf))((stderr_), ("%s: %s: Expected Expression, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            (((fprintf))((stderr_), ("%s: %s: Inline Assembly can only be used as a statement.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_SIZEOF)))) {
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((typ)->span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 8, .payload = {.variant8 = {._0 = (typ)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_TYPEINFO)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((typ)->span))));
            ((needsTypeInfo) = (true));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 17, .payload = {.variant17 = {._0 = (typ)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_FUNC)))) {
            String_s _name = ((newStringFromStrLitPcrS0540)((".anon_")));
            ((pushNumberPS0540uszrN)((&(_name)), (((this)->lexer).fileID)));
            ((pushCharPS0540crN)((&(_name)), ('_')));
            ((pushNumberPS0540uszrN)((&(_name)), ((this)->anonFnCount)));
            (((this)->anonFnCount) = (((this)->anonFnCount) + ((usize)(1llu))));
            usize fileID = (((this)->lexer).fileID);
            SubStr_s tmp_50562 = ((asSubStrPS0540rS7720)((&(_name))));

            Token_s name = ((newTokenuszPS7720uszuszrS6070)((fileID), (&tmp_50562), ((usize)(0llu)), (TOKEN_IDENT)));
            ParamContext_s params = ((parseParametersPS2466rS9803)((this)));
            ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
            ParsedBlock_s *body = ((parseBlockPS2466rPS7247)((this)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((body)->span))));
            ParsedFuncDecl_s *decl =
                ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)(((TLIParent_s){.isFile = (true), .id = ((u32)((fileID)))}), (span), (name), (params), (retType), (body)));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 16, .payload = {.variant16 = {._0 = (decl)}}})));
        }

        else if ((atPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
            if (!(struct_init_allowed)) {
                return ((newParsedExprS8951U8798rPS2435)(((ident).span), ((ExprData_u){.tag = 4, .payload = {.variant4 = {._0 = ((IdentExpr_s){.name = (ident)})}}})));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
            StructInitContext_s context = ((StructInitContext_s){0});
            while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
                Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
                ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
                ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
                ((addFieldPS6291S6070PS2435rN)((&(context)), (name), (expr)));
                if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                    break;
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((end).span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 9, .payload = {.variant9 = {._0 = ((StructExpr_s){.name = (ident), .context = (context)})}}})));
        }

        else {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), ((ExprData_u){.tag = 4, .payload = {.variant4 = {._0 = ((IdentExpr_s){.name = (ident)})}}})));
        }
    }

    Token_s t = ((peekPS3493rS6070)((&((this)->lexer))));
    String_s loc = ((getLocationPS6070rS0540)((&(t))));
    String_s name = ((toStringPS7720rS0540)((&((t).content))));
    (((fprintf))((stderr_), ("%s: %s: Expected Expression, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((C_exiti32rN))(((i32)(1))));
}
ParsedExpr_s *parseSecondaryExprPS2466PS2435uszU6350BrPS2435(Parser_s *this, ParsedExpr_s *lhs, usize precedence, Assoc_u associativity, bool struct_init_allowed) {
    ((assertBrN)(((matchesBinaryExprPS2466rB)((this)))));
    Token_s opTkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if ((equalsPS7720PS7720rB)((&((opTkn).content)), (&(KEYWORD_AS)))) {
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((typ)->span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 11, .payload = {.variant11 = {._0 = (lhs), ._1 = (typ)}}})));
    }

    ParsedExpr_s *rhs = (NULL);
    if (((opTkn).kind) == (TOKEN_SQUARE_OPEN)) {
        ((needsPrelude) = (true));
        ((rhs) = ((__parseExprPS2466uszU6350rPS2435)((this), ((usize)(0llu)), (associativity))));
        ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
    }

    else if (((opTkn).kind) == (TOKEN_PAREN_OPEN)) {
        ParsedExprList_s args = ((ParsedExprList_s){0});
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
            ((pushPS7823PS2435rN)((&(args)), ((parseExprPS2466rPS2435)((this)))));
            if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                break;
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((end).span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 7, .payload = {.variant7 = {._0 = ((CallExpr_s){.span = (span), .base = (lhs), .args = (args)})}}})));
    }

    else {
        ((rhs) = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (associativity), (struct_init_allowed))));
    }

    if (((opTkn).kind) == (TOKEN_DOT)) {
        bool succ_6587_ = true;
        bool succ_6591_ = true;

        ExprData_u *tmp_10066_ = (&((rhs)->data));
        {
            succ_6587_ &= (tmp_10066_->tag == 4);
            succ_6587_ &= true;
            if (succ_6587_) {
                {
                }
                goto after_10066;
            }
        }
        {
            succ_6591_ &= (tmp_10066_->tag == 0);
            succ_6591_ &= true;
            if (succ_6591_) {
                {
                }
                goto after_10066;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s: %s: The right side of `.` must be an identifier or number.\n"), (((toStringPS8951rS0540)((&((lhs)->span)))).buffer), (ERR_STR)));
                    ((syntaxError) = (true));
                }
                goto after_10066;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10066:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else if (((opTkn).kind) == (TOKEN_COLON_DOUBLE)) {
        bool succ_6599_ = true;
        bool succ_6597_ = true;
        bool succ_6603_ = true;

        ExprData_u *tmp_10073_ = (&((lhs)->data));
        {
            succ_6599_ &= (tmp_10073_->tag == 6);
            succ_6597_ &= (tmp_10073_->payload.variant6._0.tag == 0);
            succ_6597_ &= true;
            succ_6597_ &= true;
            succ_6599_ &= succ_6597_;
            if (succ_6599_) {
                {
                }
                goto after_10073;
            }
        }
        {
            succ_6603_ &= (tmp_10073_->tag == 4);
            succ_6603_ &= true;
            if (succ_6603_) {
                {
                }
                goto after_10073;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s: %s: The left side of `::` must be an identifier or other module specifier.\n"), (((toStringPS8951rS0540)((&((lhs)->span)))).buffer), (ERR_STR)));
                    ((syntaxError) = (true));
                }
                goto after_10073;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10073:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((rhs)->span))));
    return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 6, .payload = {.variant6 = {._0 = ((fromTknuszPS2435PS2435rU0121)(((opTkn).kind), (lhs), (rhs)))}}})));
}
ParsedExpr_s *parseUnaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) == (TOKEN_KEYWORD)) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME)))) {
            ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (struct_init_allowed)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (expr)}}})}}})));
        }

        else {
            ((unreachablePcrN)(("parseUnaryExpr: Unexpected keyword")));
        }

    }

    else if (((tkn).kind) == (TOKEN_AMPERSAND_DOUBLE)) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        usize precedence = ((getUnaryPrecedencePS2466uszrusz)((this), (TOKEN_AMPERSAND_SINGLE)));
        ParsedExpr_s *expr = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
        ParsedExpr_s *inner = ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (expr)}}})}}})));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (inner)}}})}}})));
    }

    else if ((((((tkn).kind) == (TOKEN_ASTERISK_SINGLE)) || (((tkn).kind) == (TOKEN_AMPERSAND_SINGLE))) || (((tkn).kind) == (TOKEN_MINUS_SINGLE))) || (((tkn).kind) == (TOKEN_BANG))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        usize precedence = ((getUnaryPrecedencePS2466uszrusz)((this), ((tkn).kind)));
        ParsedExpr_s *expr = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((fromTknuszPS2435rU5427)(((tkn).kind), (expr)))}}})));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of unary operations in parseUnaryExpr")));
    }
}
bool matchesBinaryExprPS2466rB(Parser_s *this) {
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    SubStr_s tmp_51134 = (((peekPS3493rS6070)((&((this)->lexer)))).content);

    if ((tknKind) == (TOKEN_KEYWORD))
        return ((equalsPS7720PS7720rB)((&tmp_51134), (&(KEYWORD_AS))));
    return ((((((((((((((((((((((tknKind) == (TOKEN_EQUAL_DOUBLE)) || ((tknKind) == (TOKEN_EQUAL_SINGLE))) || ((tknKind) == (TOKEN_NOT_EQUAL))) || ((tknKind) == (TOKEN_MINUS_SINGLE))) ||
                            ((tknKind) == (TOKEN_PLUS_SINGLE))) ||
                           ((tknKind) == (TOKEN_ASTERISK_SINGLE))) ||
                          ((tknKind) == (TOKEN_SLASH_SINGLE))) ||
                         ((tknKind) == (TOKEN_LESS_THAN_EQUAL))) ||
                        ((tknKind) == (TOKEN_LESS_THAN))) ||
                       ((tknKind) == (TOKEN_GREATER_THAN_EQUAL))) ||
                      ((tknKind) == (TOKEN_GREATER_THAN))) ||
                     ((tknKind) == (TOKEN_AMPERSAND_SINGLE))) ||
                    ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))) ||
                   ((tknKind) == (TOKEN_PIPE_DOUBLE))) ||
                  ((tknKind) == (TOKEN_PIPE_SINGLE))) ||
                 ((tknKind) == (TOKEN_CARET))) ||
                ((tknKind) == (TOKEN_COLON_DOUBLE))) ||
               ((tknKind) == (TOKEN_DOT))) ||
              ((tknKind) == (TOKEN_PAREN_OPEN))) ||
             ((tknKind) == (TOKEN_SQUARE_OPEN))) ||
            ((tknKind) == (TOKEN_PERCENT)));
}
bool matchesUnaryExprPS2466rB(Parser_s *this) {
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    if ((tknKind) == (TOKEN_KEYWORD)) {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        return ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))));
    }

    return ((((((tknKind) == (TOKEN_MINUS_SINGLE)) || ((tknKind) == (TOKEN_AMPERSAND_SINGLE))) || ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))) || ((tknKind) == (TOKEN_ASTERISK_SINGLE))) ||
            ((tknKind) == (TOKEN_BANG)));
}
usize getBinaryPrecedencePS2466PS6070rusz(Parser_s *this, Token_s *tkn) {
    usize tknKind = ((tkn)->kind);
    if ((tknKind) == (TOKEN_COLON_DOUBLE))
        return ((usize)(18llu));
    else if ((tknKind) == (TOKEN_DOT))
        return ((usize)(17llu));
    else if ((tknKind) == (TOKEN_PAREN_OPEN))
        return ((usize)(16llu));
    else if ((tknKind) == (TOKEN_SQUARE_OPEN))
        return ((usize)(16llu));
    else if ((tknKind) == (TOKEN_KEYWORD)) {
        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((tkn)->content)), (&(KEYWORD_AS)))), ("unsupported keyword in getBinaryPrecedence")));
        return ((usize)(13llu));
    }

    else if ((tknKind) == (TOKEN_SLASH_SINGLE))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_ASTERISK_SINGLE))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_PERCENT))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_PLUS_SINGLE))
        return ((usize)(11llu));
    else if ((tknKind) == (TOKEN_MINUS_SINGLE))
        return ((usize)(11llu));
    else if ((tknKind) == (TOKEN_LESS_THAN))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_LESS_THAN_EQUAL))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_GREATER_THAN))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_GREATER_THAN_EQUAL))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_EQUAL_DOUBLE))
        return ((usize)(8llu));
    else if ((tknKind) == (TOKEN_NOT_EQUAL))
        return ((usize)(8llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_SINGLE))
        return ((usize)(7llu));
    else if ((tknKind) == (TOKEN_CARET))
        return ((usize)(6llu));
    else if ((tknKind) == (TOKEN_PIPE_SINGLE))
        return ((usize)(5llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))
        return ((usize)(4llu));
    else if ((tknKind) == (TOKEN_PIPE_DOUBLE))
        return ((usize)(3llu));
    else if ((tknKind) == (TOKEN_EQUAL_SINGLE))
        return ((usize)(2llu));
    ((unreachablePcrN)(("Exhaustive handling of binary operators in Parser.getBinaryPrecedence")));
}
Assoc_u getBinaryAssociativityPS2466PS6070rU6350(Parser_s *this, Token_s *tkn) {
    usize tknKind = ((tkn)->kind);
    if ((tknKind) == (TOKEN_EQUAL_SINGLE))
        return (((Assoc_u){.tag = 1}));
    return (((Assoc_u){.tag = 0}));
}
usize getUnaryPrecedencePS2466uszrusz(Parser_s *this, usize tknKind) {
    if ((tknKind) == (TOKEN_MINUS_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_ASTERISK_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_BANG))
        return ((usize)(14llu));
    ((unreachablePcrN)(("Exhaustive handling of unary operators in Parser.getUnaryPrecedence")));
}
Parser_s newParserFromSourceuszS7720rS2466(usize fileID, SubStr_s src) {
    return ((Parser_s){
        .lexer = ((newLexeruszS7720rS3493)((fileID), (src))), .anonFnCount = ((usize)(0llu)), .importRoots = (NULL), .importRootLength = ((usize)(0llu)), .importRootCapacity = ((usize)(0llu))});
}
ModuleLookup_s *insertFilePS7791PS1892rPS0997(Lookup_s *this, ParsedFile_s *file) {
    SubStr_s tmp_51415 = ((newSubStrOfStrLitPcrS7720)(("<file module>")));

    ModuleLookup_s lookup = ((ModuleLookup_s){
        .name = ((newTokenuszPS7720uszuszrS6070)(((usize)(0llu)), (&tmp_51415), ((usize)(0llu)), (TOKEN_IDENT))), .globalID = ((getIDPS1882rusz)(((file)->mod))), .globalLookup = (this)});
    ((pushPS5541S1913rN)((&((lookup).variables)), ((ScopeLookup_s){0})));
    ((pushPS5121S0997rN)((&((this)->files)), (lookup)));
    return ((lastPS5121rPS0997)((&((this)->files))));
}
FunctionLookup_s *getFunctionByGlobalIDPS7791uszrPS0677(Lookup_s *this, usize funcID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((getFunctionByGlobalIDPS0997uszrPS0677)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (funcID)));
        if ((f) != (NULL))
            return (f);
    }

    ((unreachablePcrN)(("Lookup failed to find function based on global ID!")));
}
ModuleLookup_s *getModuleByGlobalIDPS7791uszrPS0997(Lookup_s *this, usize modID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((getModuleByGlobalIDPS0997uszrPS0997)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (modID)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find module based on global ID!")));
}
StructLookup_s *getStructByGlobalIDPS7791uszrPS4228(Lookup_s *this, usize structID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *m = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (structID)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find struct based on global ID!")));
}
UnionLookup_s *getUnionByGlobalDeclPS7791PS0997rPS1592(Lookup_s *this, ParsedUnionDecl_s *decl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *m = ((getUnionByGlobalDeclPS0997PS0997rPS1592)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (decl)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find union based on global declaration!")));
}
TypeLookup_s getTypeLookupForTypePS7791PU5175rS6177(Lookup_s *this, Type_u *typ) {
    bool succ_6651_ = true;

    Type_u *tmp_10221_ = (typ);
    {
        succ_6651_ &= (tmp_10221_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_10221_->payload.variant7._0;
        succ_6651_ &= true;
        if (succ_6651_) {
            {
                if (((*decl)->parent).isFile) {
                    usize fileID = ((usize)((((*decl)->parent).id)));
                    StructLookup_s *s = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->files)), (fileID))), ((getIDPS5521rusz)((*decl)))));
                    return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s)));
                }

                else {
                    StructLookup_s *s = ((getStructByGlobalIDPS7791uszrPS4228)((this), ((getIDPS5521rusz)((*decl)))));
                    return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s)));
                }
            }
            goto after_10221;
        }
    }
    {
        if (true) {
            {
            }
            goto after_10221;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10221:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Lookup.getTypeLookupForType got non-struct type")));
}
StructLookup_s *findStructByNameInFilePS7791PS7720PS7720rPS4228(Lookup_s *this, SubStr_s *file, SubStr_s *name) {
    TypeLookupList_s structs = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((this), (name)));
    StructLookup_s *context = (NULL);
    for (usize i = ((usize)(0llu)); ((i) < ((structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s *l = ((atPS1581uszrPS6177)((&(structs)), (i)));
        if (((l)->kind) == (TYPE_LOOKUP_STRUCT)) {
            StructLookup_s *s = ((StructLookup_s *)(((l)->actual)));
            ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), ((s)->globalID)));
            if (!(((decl)->parent).isFile))
                continue;
            ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
            String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
            String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
            ((dropPS0540rN)((&(filePath))));
            SubStr_s tmp_51679 = ((asSubStrPS0540rS7720)((&(fileName))));

            if ((equalsPS7720PS7720rB)((&tmp_51679), (file))) {
                ((assertBPcrN)(((context) == (NULL)), ("How did we find another file?")));
                ((context) = (s));
            }

            ((dropPS0540rN)((&(fileName))));
        }
    }

    ((dropPS1581rN)((&(structs))));
    return (context);
}
UnionLookup_s *findUnionByNameInFilePS7791PS7720PS7720rPS1592(Lookup_s *this, SubStr_s *file, SubStr_s *name) {
    TypeLookupList_s unions = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((this), (name)));
    UnionLookup_s *context = (NULL);
    for (usize i = ((usize)(0llu)); ((i) < ((unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s *l = ((atPS1581uszrPS6177)((&(unions)), (i)));
        if (((l)->kind) == (TYPE_LOOKUP_UNION)) {
            UnionLookup_s *s = ((UnionLookup_s *)(((l)->actual)));
            ParsedUnionDecl_s *decl = ((s)->global);
            if (!(((decl)->parent).isFile))
                continue;
            ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
            String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
            String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
            ((dropPS0540rN)((&(filePath))));
            SubStr_s tmp_51768 = ((asSubStrPS0540rS7720)((&(fileName))));

            if ((equalsPS7720PS7720rB)((&tmp_51768), (file))) {
                ((assertBPcrN)(((context) == (NULL)), ("How did we find another file?")));
                ((context) = (s));
            }

            ((dropPS0540rN)((&(fileName))));
        }
    }

    ((dropPS1581rN)((&(unions))));
    return (context);
}
TypeLookupList_s searchAllFilesForTypeNamePS7791PS7720rS1581(Lookup_s *this, SubStr_s *name) {
    TypeLookupList_s list = ((TypeLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s t = ((TypeLookup_s){0});
        if ((resolveTypeByNamePS0997PS7720PS6177BrB)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (name), (&(t)), (false))) {
            ((pushPS1581S6177rN)((&(list)), (t)));
        }
    }

    return (list);
}
FunctionLookupList_s searchAllFilesForFunctionNamePS7791PS6070rS8385(Lookup_s *this, Token_s *name) {
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookupList_s t = ((resolveFunctionByNamePS0997PS6070rS8385)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (name)));
        ((extendPS8385PS8385rN)((&(list)), (&(t))));
    }

    return (list);
}
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070rS3313(Lookup_s *this, Token_s *name) { return ((searchAllFilesForIdentifierPS7791PS6070BrS3313)((this), (name), (false))); }
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070BrS3313(Lookup_s *this, Token_s *name, bool globalOnly) {
    VariableLookupList_s list = ((VariableLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((atPS5121uszrPS0997)((&((this)->files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < (((m)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ScopeLookup_s *s = ((atPS5541uszrPS1913)((&((m)->variables)), (j)));
            VariableLookup_s v = ((VariableLookup_s){0});
            if ((getVariableByNamePS1913S7720PS6661rB)((s), ((name)->content), (&(v)))) {
                ((pushPS3313S6661rN)((&(list)), (v)));
            }

            if (globalOnly)
                break;
        }
    }

    return (list);
}
bool equalsPS5071PS5071rB(FileLookup_s *this, FileLookup_s *other) { return ((equalsPS7720PS7720rB)((&((this)->origin)), (&((other)->origin)))); }
bool insertTLIPS0997PS1038rB(ModuleLookup_s *this, ParsedTopLevelItem_s *tli) {
    ((assertBPcrN)((((this)->globalLookup) != (NULL)), ("insertTLI called on ModuleLookup without Global Lookup")));
    if (((tli)->kind) == (TLI_FUNC_DECL)) {
        ParsedFuncDecl_s *fun = ((atPS4111uszrPS4904)((&(funcDecls)), ((tli)->nodeID)));
        FunctionLookup_s lookup = ((FunctionLookup_s){.globalID = ((tli)->nodeID),
                                                      .parent = ((tli)->parent),
                                                      .name = ((fun)->name),
                                                      .params = ((VariableLookupList_s){0}),
                                                      .fnType = (((TCState_u){.tag = 0, .payload = {0}})),
                                                      .isVarArg = (((fun)->params).isVarArg)});
        ((pushPS8385S0677rN)((&((this)->functions)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_IMPORT)) {
        usize fileID = ((tli)->nodeID);
        ((assertBrN)(((fileID) < ((files).length))));
        ImportLookup_s lookup = ((ImportLookup_s){.span = ((tli)->span), .fileID = (fileID)});
        if ((containsPS3606PS6218rB)((&((this)->imports)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52017 = (((getPS3606PS6218rPS6218)((&((this)->imports)), (&(lookup))))->span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52017)));
            (((fprintf))((stderr_), ("%s: %s: Can not import the same file twice.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: File already imported here.\n"), ((_loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS3606S6218rN)((&((this)->imports)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_MOD_DECL)) {
        usize modID = ((tli)->nodeID);
        ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), (modID)));
        ModuleLookup_s lookup =
            ((ModuleLookup_s){.globalLookup = ((this)->globalLookup), .parent = ((atPS7393uszrPS1882)((&(modules)), ((this)->globalID))), .name = ((mod)->name), .globalID = (modID)});
        if ((containsPS5121PS0997rB)((&((this)->modules)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52110 = ((((getPS5121PS0997rPS0997)((&((this)->modules)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52110)));
            String_s name = ((toStringPS6070rS0540)((&((mod)->name))));
            (((fprintf))((stderr_), ("%s: %s: Module redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Module `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS5541S1913rN)((&((lookup).variables)), ((ScopeLookup_s){0})));
        for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu)))))
            ((insertTLIPS0997PS1038rB)((&(lookup)), ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))))));
        ((pushPS5121S0997rN)((&((this)->modules)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_STRUCT_DECL)) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), ((tli)->nodeID)));
        StructLookup_s lookup = ((StructLookup_s){.globalID = ((tli)->nodeID),
                                                  .parent = ((tli)->parent),
                                                  .name = ((strukt)->name),
                                                  .fields = ((VariableLookupList_s){0}),
                                                  .type = ((wrapU5175rPU5175)(((Type_u){.tag = 7, .payload = {.variant7 = {._0 = (strukt)}}})))});
        if ((containsPS7392PS4228rB)((&((this)->structs)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52254 = ((((getPS7392PS4228rPS4228)((&((this)->structs)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52254)));
            String_s name = ((toStringPS6070rS0540)((&((strukt)->name))));
            (((fprintf))((stderr_), ("%s: %s: Struct redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Struct `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS7392S4228rN)((&((this)->structs)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_UNION_DECL)) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), ((tli)->nodeID)));
        UnionLookup_s lookup = ((UnionLookup_s){.global = (onion),
                                                .parent = ((tli)->parent),
                                                .name = ((onion)->name),
                                                .variants = ((UnionVariantLookupList_s){0}),
                                                .type = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (onion), ._1 = ((usize)(0llu))}}})))});
        if ((containsPS4836PS1592rB)((&((this)->unions)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52361 = ((((getPS4836PS1592rPS1592)((&((this)->unions)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52361)));
            String_s name = ((toStringPS6070rS0540)((&((onion)->name))));
            (((fprintf))((stderr_), ("%s: %s: Union redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Union `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS4836S1592rN)((&((this)->unions)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_VAR_DECL)) {
        ParsedStmt_s *varDecl = ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)));
        ((assertBPcrN)(((((this)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope")));
        ScopeLookup_s *globalScope = ((lastPS5541rPS1913)((&((this)->variables))));
        ParsedPattern_s *pat = (NULL);
        bool isComptime = (false);
        bool succ_6749_ = true;

        StmtData_u *tmp_10382_ = (&((varDecl)->data));
        {
            succ_6749_ &= (tmp_10382_->tag == 0);
            VarDecl_s *decl = &tmp_10382_->payload.variant0._0;
            succ_6749_ &= true;
            if (succ_6749_) {
                {
                    ((pat) = ((*decl).pat));
                    ((isComptime) = ((*decl).isComptime));
                }
                goto after_10382;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_10382;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10382:
        (void)0; // error: label at end of compound statement is a C23 extension
        return ((insertVariablesPS0997PS1826PS1913BrB)((this), (pat), (globalScope), (isComptime)));
    }

    else if (((tli)->kind) == (TLI_CONFIG)) {
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of TLI kinds in insertTLI")));
    }

    return (true);
}
bool _anon_24_0PS1913PS6661PS1826PS6070rB(ScopeLookup_s *globalScope, VariableLookup_s *lookup, ParsedPattern_s *pat, Token_s *name) {
    Token_s duplVar = ((Token_s){0});
    if ((isKnownVariablePS1913S7720PS6070rB)((globalScope), (((lookup)->name).content), (&(duplVar)))) {
        String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s _name = ((toStringPS6070rS0540)((name)));
        String_s _loc = ((toStringPS8951rS0540)((&((duplVar).span))));
        (((fprintf))((stderr_), ("%s: %s: Variable redeclaration.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Variable `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((_name).buffer)));
        ((dropPS0540rN)((&(_name))));
        ((dropPS0540rN)((&(_loc))));
        ((dropPS0540rN)((&(loc))));
        return (true);
    }

    return (false);
}
bool insertVariablesPS0997PS1826PS1913BrB(ModuleLookup_s *this, ParsedPattern_s *pat, ScopeLookup_s *globalScope, bool isComptime) {
    bool (*check_known)(ScopeLookup_s *, VariableLookup_s *, ParsedPattern_s *, Token_s *) = (_anon_24_0PS1913PS6661PS1826PS6070rB);
    bool succ_6759_ = true;
    bool succ_6762_ = true;
    bool succ_6764_ = true;
    bool succ_6767_ = true;
    bool succ_6769_ = true;
    bool succ_6773_ = true;
    bool succ_6776_ = true;
    bool succ_6781_ = true;
    bool succ_6785_ = true;
    bool succ_6791_ = true;

    Pattern_u tmp_10440_ = ((pat)->data);
    {
        succ_6759_ &= (tmp_10440_.tag == 0);
        if (succ_6759_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10440;
        }
    }
    {
        succ_6762_ &= (tmp_10440_.tag == 1);
        succ_6762_ &= true;
        if (succ_6762_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10440;
        }
    }
    {
        succ_6764_ &= (tmp_10440_.tag == 8);
        if (succ_6764_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10440;
        }
    }
    {
        succ_6767_ &= (tmp_10440_.tag == 9);
        succ_6767_ &= true;
        if (succ_6767_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10440;
        }
    }
    {
        succ_6769_ &= (tmp_10440_.tag == 10);
        if (succ_6769_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10440;
        }
    }
    {
        succ_6773_ &= (tmp_10440_.tag == 3);
        ParsedPattern_s **subpat = &tmp_10440_.payload.variant3._0;
        succ_6773_ &= true;
        succ_6773_ &= true;
        if (succ_6773_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10440;
        }
    }
    {
        succ_6776_ &= (tmp_10440_.tag == 2);
        Token_s *name = &tmp_10440_.payload.variant2._0;
        succ_6776_ &= true;
        if (succ_6776_) {
            {
                VariableLookup_s lookup =
                    ((VariableLookup_s){.globalID = ((getIDPS1826rusz)((pat))), .name = (*name), .typeState = (((TCState_u){.tag = 0, .payload = {0}})), .isComptime = (isComptime)});
                if ((check_known)((globalScope), (&(lookup)), (pat), (&(*name))))
                    return (false);
                ((addVariablePS1913S6661rN)((globalScope), (lookup)));
                return (true);
            }
            goto after_10440;
        }
    }
    {
        succ_6781_ &= (tmp_10440_.tag == 4);
        ParsedPattern_s **subpat = &tmp_10440_.payload.variant4._0;
        succ_6781_ &= true;
        if (succ_6781_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10440;
        }
    }
    {
        succ_6785_ &= (tmp_10440_.tag == 5);
        Token_s *name = &tmp_10440_.payload.variant5._0;
        succ_6785_ &= true;
        ParsedPatternList_s *subpats = &tmp_10440_.payload.variant5._1;
        succ_6785_ &= true;
        if (succ_6785_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*subpats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if (!((insertVariablesPS0997PS1826PS1913BrB)((this), ((((*subpats).elements))[(i)]), (globalScope), (isComptime))))
                        return (false);
                }

                return (true);
            }
            goto after_10440;
        }
    }
    {
        succ_6791_ &= (tmp_10440_.tag == 6);
        succ_6791_ &= true;
        ParsedPattern_s **subpat = &tmp_10440_.payload.variant6._1;
        succ_6791_ &= true;
        if (succ_6791_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10440;
        }
    }
    {
        if (true) {
            {
            }
            goto after_10440;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10440:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("insertVariables: Exhaustive handling of patterns")));
}
bool containsDuplicateFunctionPS0997PS0677PPS0677rB(ModuleLookup_s *this, FunctionLookup_s *function, FunctionLookup_s **dupl) {
    ((assertBPcrN)(((this) != (NULL)), ("containsDuplicateFunction called with null-Lookup")));
    String_s name = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->globalID)))));
    bool duplicate = (false);
    for (usize i = ((usize)(0llu)); ((!(duplicate)) && ((i) < (((this)->functions).length))); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((f) == (function))
            continue;
        String_s n = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((f)->globalID)))));
        if ((equalsPS0540PS0540rB)((&(name)), (&(n)))) {
            ((*(dupl)) = (f));
            ((duplicate) = (true));
        }

        ((dropPS0540rN)((&(n))));
    }

    return (duplicate);
}
bool equalsPS6218PS6218rB(ImportLookup_s *this, ImportLookup_s *other) { return (((this)->fileID) == ((other)->fileID)); }
bool equalsPS0997PS0997rB(ModuleLookup_s *this, ModuleLookup_s *other) {
    if (!((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))))
        return (false);
    return ((equalsPS1882PS1882rB)(((this)->parent), ((other)->parent)));
}
FunctionLookup_s *getFunctionByGlobalIDPS0997uszrPS0677(ModuleLookup_s *this, usize funcID) { return ((getFunctionByGlobalIDPS0997uszBrPS0677)((this), (funcID), (true))); }
FunctionLookup_s *getFunctionByGlobalIDPS0997uszBrPS0677(ModuleLookup_s *this, usize funcID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getFunctionByGlobalID called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if (((f)->globalID) == (funcID)) {
            return (f);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *mod = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
        FunctionLookup_s *fn = ((getFunctionByGlobalIDPS0997uszBrPS0677)((mod), (funcID), (false)));
        if ((fn) != (NULL))
            return (fn);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookup_s *fn = ((getFunctionByGlobalIDPS0997uszBrPS0677)((imp), (funcID), (false)));
            if ((fn) != (NULL))
                return (fn);
        }
    }

    return (NULL);
}
ModuleLookup_s *getModuleByGlobalIDPS0997uszrPS0997(ModuleLookup_s *this, usize modID) { return ((getModuleByGlobalIDPS0997uszBrPS0997)((this), (modID), (true))); }
ModuleLookup_s *getModuleByGlobalIDPS0997uszBrPS0997(ModuleLookup_s *this, usize modID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getModuleByGlobalID called with null-Lookup")));
    if (((this)->globalID) == (modID))
        return (this);
    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
        ModuleLookup_s *lookup = ((getModuleByGlobalIDPS0997uszrPS0997)((m), (modID)));
        if ((lookup) != (NULL))
            return (lookup);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            ModuleLookup_s *mod = ((getModuleByGlobalIDPS0997uszBrPS0997)((imp), (modID), (false)));
            if ((mod) != (NULL))
                return (mod);
        }
    }

    return (NULL);
}
StructLookup_s *getStructByGlobalIDPS0997uszrPS4228(ModuleLookup_s *this, usize structID) { return ((getStructByGlobalIDPS0997uszBrPS4228)((this), (structID), (true))); }
StructLookup_s *getStructByGlobalIDPS0997uszBrPS4228(ModuleLookup_s *this, usize structID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getStructByGlobalID called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if (((s)->globalID) == (structID)) {
            return (s);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->modules)), (i))), (structID)));
        if ((s) != (NULL))
            return (s);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            StructLookup_s *str = ((getStructByGlobalIDPS0997uszBrPS4228)((imp), (structID), (false)));
            if ((str) != (NULL))
                return (str);
        }
    }

    return (NULL);
}
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997rPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl) { return ((getUnionByGlobalDeclPS0997PS0997BrPS1592)((this), (decl), (true))); }
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997BrPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl, bool checkImport) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if (((e)->global) == (decl)) {
            return (e);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *m = ((getUnionByGlobalDeclPS0997PS0997rPS1592)(((atPS5121uszrPS0997)((&((this)->modules)), (i))), (decl)));
        if ((m) != (NULL))
            return (m);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            UnionLookup_s *e = ((getUnionByGlobalDeclPS0997PS0997BrPS1592)((imp), (decl), (false)));
            if ((e) != (NULL))
                return (e);
        }
    }

    return (NULL);
}
u32 resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32(ModuleLookup_s *this, Token_s *name, VariableLookup_s **var, TypeLookup_s *typ, FunctionLookupList_s *fun) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveIdentifierByName called with null-Lookup")));
    ((assertBPcrN)(((((this)->variables).length) > ((usize)(0llu))), ("Unexpected length of global variable lookup")));
    ScopeLookup_s *global = ((lastPS5541rPS1913)((&((this)->variables))));
    for (usize i = ((usize)(0llu)); ((i) < (((global)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((global)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
            ((*(var)) = (v));
            return (IDENT_VAR);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if ((equalsPS7720PS7720rB)((&(((s)->name).content)), (&((name)->content)))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s))));
            return (IDENT_TYPE);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *u = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((u)->name).content)), (&((name)->content)))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (u))));
            return (IDENT_TYPE);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((pushPS8385S0677rN)((fun), (*(f))));
        }
    }

    if (((fun)->length) > ((usize)(0llu)))
        return (IDENT_FUNC);
    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32)((parentMod), (name), (var), (typ), (fun)));
    }

    return (IDENT_NONE);
}
bool resolveModuleByNamePS0997PS6070PPS0997rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod) {
    return ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((this), (name), (mod), ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (true), .checkParent = (true)})));
}
bool resolveModuleByNamePS0997PS6070PPS0997S5972rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod, MLConfig_s c) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveModuleByName called with null-Lookup")));
    if (((c).checkSelf) && ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&((name)->content))))) {
        ((*(mod)) = (this));
        return (true);
    }

    if ((c).checkModule) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *submodule = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((submodule), (name), (mod), ((MLConfig_s){.checkSelf = (true)})))
                return (true);
        }
    }

    if ((c).checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((imp), (name), (mod), ((MLConfig_s){.checkSelf = (true), .checkModule = ((c).checkModule)})))
                return (true);
        }
    }

    if (((c).checkParent) && (((this)->parent) != (NULL))) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((parentMod), (name), (mod),
                                                                ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = ((c).checkModule), .checkParent = (true)})));
    }

    return (false);
}
bool resolveVariableByNamePS0997PS6070PS5541PS6661rB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var) {
    return ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((this), (name), (scopes), (var), (true)));
}
bool resolveVariableByNamePS0997PS6070PS5541PS6661BrB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveVariableByName called with null-Lookup")));
    for (usize _i = ((usize)(0llu)); ((_i) < ((scopes)->length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = ((((scopes)->length) - (_i)) - ((usize)(1llu)));
        ScopeLookup_s *s = ((atPS5541uszrPS1913)((scopes), (i)));
        for (usize j = ((usize)(0llu)); ((j) < (((s)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
            VariableLookup_s *v = ((atPS3313uszrPS6661)((&((s)->variables)), (j)));
            if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
                ((*(var)) = (*(v)));
                return (true);
            }
        }
    }

    ScopeLookup_s *globalScope = ((atPS5541uszrPS1913)((&((this)->variables)), ((usize)(0llu))));
    for (usize j = ((usize)(0llu)); ((j) < (((globalScope)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((globalScope)->variables)), (j)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
            ((*(var)) = (*(v)));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((imp), (name), (scopes), (var), (false)))
                return (true);
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((parentMod), (name), (scopes), (var), (true)));
    }

    return (false);
}
StructLookupList_s resolveAllStructsWithFieldPS0997PS6070PU5175rS7392(ModuleLookup_s *this, Token_s *name, Type_u *typ) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveAllStructsWithField called with null-Lookup")));
    StructLookupList_s list = ((StructLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        VariableLookup_s v = ((VariableLookup_s){0});
        if ((resolveFieldByNamePS4228PS6070PS6661rB)((s), (name), (&(v)))) {
            ((assertBrN)(((isTypePU9661rB)((&((v).typeState))))));
            Type_u *t = ((getTypePU9661rPU5175)((&((v).typeState))));
            if ((equalsPU5175PU5175rB)((t), (typ))) {
                ((pushPS7392S4228rN)((&(list)), (*(s))));
            }
        }
    }

    return (list);
}
bool resolveTypeByNamePS0997PS7720PS6177rB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ) { return ((resolveTypeByNamePS0997PS7720PS6177BrB)((this), (name), (typ), (true))); }
bool resolveTypeByNamePS0997PS7720PS6177BrB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveTypeByName called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if ((equalsPS7720PS7720rB)((&(((s)->name).content)), (name))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s))));
            return (true);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((e)->name).content)), (name))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (e))));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveTypeByNamePS0997PS7720PS6177BrB)((imp), (name), (typ), (false)))
                return (true);
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveTypeByNamePS0997PS7720PS6177BrB)((parentMod), (name), (typ), (true)));
    }

    return (false);
}
FunctionLookupList_s resolveFunctionByNamePS0997PS6070rS8385(ModuleLookup_s *this, Token_s *name) { return ((resolveFunctionByNamePS0997PS6070BrS8385)((this), (name), (true))); }
FunctionLookupList_s resolveFunctionByNamePS0997PS6070BrS8385(ModuleLookup_s *this, Token_s *name, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveFunctionByName called with null-Lookup")));
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((pushPS8385S0677rN)((&(list)), (*(f))));
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookupList_s _list = ((resolveFunctionByNamePS0997PS6070BrS8385)((imp), (name), (false)));
            ((extendPS8385PS8385rN)((&(list)), (&(_list))));
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        FunctionLookupList_s _list = ((resolveFunctionByNamePS0997PS6070BrS8385)((parentMod), (name), (true)));
        ((extendPS8385PS8385rN)((&(list)), (&(_list))));
    }

    return (list);
}
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ) {
    return ((
        resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((this), (name), (typ),
                                                                       ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (false), .checkParent = (true), .allowData = (true)})));
}
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ, MLConfig_s config) {
    TypeList_s params1 = ((TypeList_s){0});
    Type_u *ret1 = (NULL);
    bool succ_6935_ = true;

    Type_u *tmp_10745_ = (typ);
    {
        succ_6935_ &= (tmp_10745_->tag == 6);
        TypeList_s *params = &tmp_10745_->payload.variant6._0;
        succ_6935_ &= true;
        Type_u **ret = &tmp_10745_->payload.variant6._1;
        succ_6935_ &= true;
        succ_6935_ &= true;
        if (succ_6935_) {
            {
                ((params1) = (*params));
                ((ret1) = (*ret));
            }
            goto after_10745;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_10745;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10745:
    (void)0; // error: label at end of compound statement is a C23 extension
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if (!((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content))))) {
            continue;
        }

        Type_u *_rt = ((getTypePU9661rPU5175)((&((f)->fnType))));
        bool succ_6949_ = true;

        Type_u *tmp_10774_ = (_rt);
        {
            succ_6949_ &= (tmp_10774_->tag == 6);
            TypeList_s *params2 = &tmp_10774_->payload.variant6._0;
            succ_6949_ &= true;
            Type_u **ret2 = &tmp_10774_->payload.variant6._1;
            succ_6949_ &= true;
            succ_6949_ &= true;
            if (succ_6949_) {
                {
                    if (((params1).length) != ((*params2).length))
                        continue;
                    if (!((isUnknownPU5175rB)((ret1))))
                        if (!((_equalsPU5175PU5175BrB)((ret1), (*ret2), ((config).allowData))))
                            continue;
                    bool succ = (true);
                    for (usize j = ((usize)(0llu)); ((j) < ((params1).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        Type_u *t1 = (*((atPS0643uszrPPU5175)((&(params1)), (j))));
                        Type_u *t2 = (*((atPS0643uszrPPU5175)((&(*params2)), (j))));
                        if (!((isUnknownPU5175rB)((t1))))
                            if (!((_equalsPU5175PU5175BrB)((t1), (t2), ((config).allowData)))) {
                                ((succ) = (false));
                                break;
                            }
                    }

                    if (succ)
                        ((pushPS8385S0677rN)((&(list)), (*(f))));
                }
                goto after_10774;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_10774;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10774:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    if ((config).checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookupList_s _list =
                ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((imp), (name), (typ), ((MLConfig_s){.checkSelf = (true), .allowData = ((config).allowData)})));
            ((extendPS8385PS8385rN)((&(list)), (&(_list))));
        }
    }

    if (((config).checkParent) && (((this)->parent) != (NULL))) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        FunctionLookupList_s fns = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((parentMod), (name), (typ),
                                                                                                    ((MLConfig_s){.checkSelf = (true),
                                                                                                                  .checkImport = (true),
                                                                                                                  .checkModule = (false),
                                                                                                                  .checkParent = (true),
                                                                                                                  .allowData = ((config).allowData)})));
        ((extendPS8385PS8385rN)((&(list)), (&(fns))));
    }

    return (list);
}
bool resolveUnionByNamePS0997PS6070PPS1592rB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion) { return ((resolveUnionByNamePS0997PS6070PPS1592BrB)((this), (name), (onion), (true))); }
bool resolveUnionByNamePS0997PS6070PPS1592BrB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion, bool checkImport) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((e)->name).content)), (&((name)->content)))) {
            ((*(onion)) = (e));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveUnionByNamePS0997PS6070PPS1592BrB)((imp), (name), (onion), (false)))
                return (true);
        }
    }

    return (false);
}
none addParameterPS0677uszS6070U9661rN(FunctionLookup_s *this, usize globalID, Token_s name, TCState_u typeState) {
    ((pushPS3313S6661rN)((&((this)->params)), ((VariableLookup_s){.globalID = (globalID), .name = (name), .typeState = (typeState), .isComptime = (false)})));
}
bool checkForDuplicateParamPS0677PS6070PS6661rB(FunctionLookup_s *this, Token_s *name, VariableLookup_s *dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->params).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *param = ((atPS3313uszrPS6661)((&((this)->params)), (i)));
        if ((equalsPS7720PS7720rB)((&(((param)->name).content)), (&((name)->content)))) {
            ((*(dupl)) = (*(param)));
            return (true);
        }
    }

    return (false);
}
bool equalsPS0677PS0677rB(FunctionLookup_s *this, FunctionLookup_s *other) {
    ((warningPcrN)(("When are two functions equal")));
    return ((equalsPS6070PS6070rB)((&((this)->name)), (&((other)->name))));
}
String_s getNamePS6177rS0540(TypeLookup_s *this) {
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        SubStr_s tmp_54356 = ((((asStructPS6177rPS4228)((this)))->name).content);

        return ((toStringPS7720rS0540)((&tmp_54356)));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        SubStr_s tmp_54371 = ((((asUnionPS6177rPS1592)((this)))->name).content);

        return ((toStringPS7720rS0540)((&tmp_54371)));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling in TypeLookup.getName")));
    }
}
String_s getLocationPS6177rS0540(TypeLookup_s *this) {
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        Span_s tmp_54389 = ((((asStructPS6177rPS4228)((this)))->name).span);

        return ((toStringPS8951rS0540)((&tmp_54389)));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        Span_s tmp_54404 = ((((asUnionPS6177rPS1592)((this)))->name).span);

        return ((toStringPS8951rS0540)((&tmp_54404)));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling in TypeLookup.getLocation")));
    }
}
bool equalsPS6177PS6177rB(TypeLookup_s *this, TypeLookup_s *other) {
    if (((this)->kind) != ((other)->kind))
        return (false);
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        return ((equalsPS4228PS4228rB)(((asStructPS6177rPS4228)((this))), ((asStructPS6177rPS4228)((other)))));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        return ((equalsPS1592PS1592rB)(((asUnionPS6177rPS1592)((this))), ((asUnionPS6177rPS1592)((other)))));
    }

    ((unreachablePcrN)(("Exhaustive handling in TypeLookup.equals")));
}
bool isStructPS6177rB(TypeLookup_s *this) { return (((this)->kind) == (TYPE_LOOKUP_STRUCT)); }
bool isUnionPS6177rB(TypeLookup_s *this) { return (((this)->kind) == (TYPE_LOOKUP_UNION)); }
StructLookup_s *asStructPS6177rPS4228(TypeLookup_s *this) {
    ((assertBPcrN)(((isStructPS6177rB)((this))), ("Attempted to convert non-struct TypeLookup into StructLookup")));
    return ((StructLookup_s *)(((this)->actual)));
}
UnionLookup_s *asUnionPS6177rPS1592(TypeLookup_s *this) {
    ((assertBPcrN)(((isUnionPS6177rB)((this))), ("Attempted to convert non-union TypeLookup into UnionLookup")));
    return ((UnionLookup_s *)(((this)->actual)));
}
TypeLookup_s newTypeLookupuszAnyrS6177(usize kind, Any actual) { return ((TypeLookup_s){.kind = (kind), .actual = (actual)}); }
TypeLookup_s asTypeLookupPS4228rS6177(StructLookup_s *this) { return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (this))); }
bool equalsPS4228PS4228rB(StructLookup_s *this, StructLookup_s *other) {
    if (!((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent)))))
        return (false);
    return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content))));
}
bool resolveFieldByNamePS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((*(out)) = (*(f)));
            return (true);
        }
    }

    return (false);
}
bool hasFieldPS4228PS7720rB(StructLookup_s *this, SubStr_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (name))) {
            return (true);
        }
    }

    return (false);
}
usize getIndexByNamePS4228PS6070rusz(StructLookup_s *this, Token_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            return (i);
        }
    }

    ((assertBPcrN)(((hasFieldPS4228PS7720rB)((this), (&((name)->content)))), ("StructLookup.getIndexByName() called when StructLookup.hasField() == false")));
    ((unreachablePcrN)(("StructLookup.getIndexByName does not have a field with the given name")));
}
bool checkForDuplicateFieldPS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((*(dupl)) = (*(f)));
            return (true);
        }
    }

    return (false);
}
none addFieldPS4228uszS6070U9661rN(StructLookup_s *this, usize globalID, Token_s name, TCState_u typeState) {
    ((pushPS3313S6661rN)((&((this)->fields)), ((VariableLookup_s){.globalID = (globalID), .name = (name), .typeState = (typeState), .isComptime = (false)})));
}
TypeLookup_s asTypeLookupPS1592rS6177(UnionLookup_s *this) { return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (this))); }
bool equalsPS1592PS1592rB(UnionLookup_s *this, UnionLookup_s *other) {
    if (!((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent)))))
        return (false);
    return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content))));
}
bool resolveVariantByNamePS1592PS6070PPS2365rB(UnionLookup_s *this, Token_s *name, UnionVariantLookup_s **variant) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionVariantLookup_s *v = ((atPS4601uszrPS2365)((&((this)->variants)), (i)));
        if ((equalsPS7720PS7720rB)((&((((v)->global)->name).content)), (&((name)->content)))) {
            ((*(variant)) = (v));
            return (true);
        }
    }

    return (false);
}
bool checkForDuplicateVariantPS1592PS3506PPS2365rB(UnionLookup_s *this, ParsedUnionVariant_s *curr, UnionVariantLookup_s **dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionVariantLookup_s *v = ((atPS4601uszrPS2365)((&((this)->variants)), (i)));
        if ((equalsPS7720PS7720rB)((&((((v)->global)->name).content)), (&(((curr)->name).content)))) {
            ((*(dupl)) = (v));
            return (true);
        }
    }

    return (false);
}
none addVariantPS1592PS3506U9661rN(UnionLookup_s *this, ParsedUnionVariant_s *variant, TCState_u typeState) {
    usize tag = (((this)->variants).length);
    ((pushPS4601S2365rN)((&((this)->variants)), ((UnionVariantLookup_s){.global = (variant), .tag = (tag), .typeState = (typeState)})));
}
bool equalsPS2365PS2365rB(UnionVariantLookup_s *this, UnionVariantLookup_s *other) { ((unreachablePcrN)(("UnionVariantLookup.equals"))); }
bool checkForDuplicateNamePS2365PS6070PPS6070rB(UnionVariantLookup_s *this, Token_s *name, Token_s **dupl) { return ((checkForDuplicateNamePS3506PS6070PPS6070rB)(((this)->global), (name), (dupl))); }
StructLookup_s intoStructLookupPS2365rS4228(UnionVariantLookup_s *this) {
    bool succ_7008_ = true;

    ParsedUnionVariantData_u *tmp_10923_ = (&(((this)->global)->data));
    succ_7008_ &= (tmp_10923_->tag == 2);
    ParsedTypeNodeList_s *fields = &tmp_10923_->payload.variant2._0;
    succ_7008_ &= true;
    TokenList_s *names = &tmp_10923_->payload.variant2._1;
    succ_7008_ &= true;
    if (!succ_7008_) {
        ((unreachablePcrN)(("intoStructLookup() called on non-struct variant")));
    };
    StructLookup_s lookup = ((StructLookup_s){.globalID = ((getIDPS3506rusz)(((this)->global))), .parent = (((this)->global)->parent), .name = (((this)->global)->name)});
    for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *field = ((((*fields).elements))[(i)]);
        Token_s *name = (&((((*names).elements))[(i)]));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid variant field type at this point")));
        ((pushPS3313S6661rN)((&((lookup).fields)), ((VariableLookup_s){.globalID = ((getIDPS1372rusz)((field))), .name = (*(name)), .typeState = ((field)->typeState), .isComptime = (false)})));
    }

    return (lookup);
}
bool isParameterPS6661rB(VariableLookup_s *this) { return (((this)->globalID) >= (NODE_ID_OFFSET)); }
bool equalsPS6661PS6661rB(VariableLookup_s *this, VariableLookup_s *other) { return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))); }
bool equalsPS1913PS1913rB(ScopeLookup_s *this, ScopeLookup_s *other) { ((todo_with_msgPcrN)(("when are two scopes equal"))); }
none addVariablePS1913S6661rN(ScopeLookup_s *this, VariableLookup_s variable) { ((pushPS3313S6661rN)((&((this)->variables)), (variable))); }
bool isKnownVariablePS1913S7720PS6070rB(ScopeLookup_s *this, SubStr_s name, Token_s *existing) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(existing)) = ((v)->name));
            return (true);
        }
    }

    return (false);
}
bool getVarIndexByNamePS1913S7720PuszrB(ScopeLookup_s *this, SubStr_s name, usize *index) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(index)) = (i));
            return (true);
        }
    }

    return (false);
}
bool getVariableByNamePS1913S7720PS6661rB(ScopeLookup_s *this, SubStr_s name, VariableLookup_s *var) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(var)) = (*(v)));
            return (true);
        }
    }

    return (false);
}
VariableLookup_s *getVariableAtIndexPS1913uszrPS6661(ScopeLookup_s *this, usize index) { return ((atPS3313uszrPS6661)((&((this)->variables)), (index))); }
none clearPS1913rN(ScopeLookup_s *this) { ((clearPS3313rN)((&((this)->variables)))); }
bool equalsPU9661PU9661rB(TCState_u *this, TCState_u *other) { ((todo_with_msgPcrN)(("TCState.equals"))); }
bool isInvalidPU9661rB(TCState_u *this) {
    TCState_u tmp_55094 = (((TCState_u){.tag = 0, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55094)))));
}
bool wantsInferPU9661rB(TCState_u *this) {
    TCState_u tmp_55105 = (((TCState_u){.tag = 4, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55105)))));
}
bool isCriticalErrorPU9661rB(TCState_u *this) {
    if (!((isErrorPU9661rB)((this))))
        return (false);
    usize err = ((getErrorPU9661rusz)((this)));
    return (((((((err) == (ERROR_NO_SUCH_IDENTIFIER)) || ((err) == (ERROR_NO_SUCH_FUNCTION))) || ((err) == (ERROR_NO_SUCH_METHOD))) || ((err) == (ERROR_DUPLICATE_FUNCTION))) ||
             ((err) == (ERROR_DUPLICATE_METHOD))) ||
            ((err) == (ERROR_DUPLICATE_FIELD)));
}
bool isErrorPU9661rB(TCState_u *this) {
    TCState_u tmp_55147 = (((TCState_u){.tag = 2, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55147)))));
}
bool isSuccessPU9661rB(TCState_u *this) {
    TCState_u tmp_55158 = (((TCState_u){.tag = 1, .payload = {0}}));

    return (((((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55158))))) || ((isTypePU9661rB)((this)))) || ((isPatternPU9661rB)((this))));
}
bool isTypePU9661rB(TCState_u *this) {
    TCState_u tmp_55177 = (((TCState_u){.tag = 3, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55177)))));
}
bool isPatternPU9661rB(TCState_u *this) {
    TCState_u tmp_55188 = (((TCState_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55188)))));
}
Type_u *getTypePU9661rPU5175(TCState_u *this) {
    bool succ_7123_ = true;

    TCState_u *tmp_11025_ = (this);
    succ_7123_ &= (tmp_11025_->tag == 3);
    Type_u **type = &tmp_11025_->payload.variant3._0;
    succ_7123_ &= true;
    if (!succ_7123_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*type);
}
usize getErrorPU9661rusz(TCState_u *this) {
    bool succ_7127_ = true;

    TCState_u *tmp_11029_ = (this);
    succ_7127_ &= (tmp_11029_->tag == 2);
    usize *error = &tmp_11029_->payload.variant2._0;
    succ_7127_ &= true;
    if (!succ_7127_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-error TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*error);
}
PatState_s getPatStatePU9661rS1259(TCState_u *this) {
    bool succ_7131_ = true;

    TCState_u *tmp_11033_ = (this);
    succ_7131_ &= (tmp_11033_->tag == 5);
    PatState_s *pat = &tmp_11033_->payload.variant5._0;
    succ_7131_ &= true;
    if (!succ_7131_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-pattern TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*pat);
}
none enterAnonFuncPS3900rN(TypeChecker_s *this) { (((this)->anonFuncDepth) = (((this)->anonFuncDepth) + ((usize)(1llu)))); }
none leaveAnonFuncPS3900rN(TypeChecker_s *this) { (((this)->anonFuncDepth) = (((this)->anonFuncDepth) - ((usize)(1llu)))); }
none enterComptimePS3900rN(TypeChecker_s *this) { (((this)->comptimeDepth) = (((this)->comptimeDepth) + ((usize)(1llu)))); }
none leaveComptimePS3900rN(TypeChecker_s *this) { (((this)->comptimeDepth) = (((this)->comptimeDepth) - ((usize)(1llu)))); }
char *pluszPcPcrPc(usize count, char *s1, char *s2) {
    if ((count) == ((usize)(1llu)))
        return (s1);
    return (s2);
}
TCState_u reportUnknownIdentifierPS3900PS6070rU9661(TypeChecker_s *this, Token_s *name) {
    String_s loc = ((getLocationPS6070rS0540)((name)));
    String_s _name = ((toStringPS7720rS0540)((&((name)->content))));
    (((fprintf))((stderr_), ("%s: %s: Use of undeclared identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    VariableLookupList_s alternatives = ((searchAllFilesForIdentifierPS7791PS6070BrS3313)((&((this)->lookup)), (name), (((this)->anonFuncDepth) > ((usize)(0llu)))));
    if (*((flags).verbose)) {
        for (usize i = ((usize)(0llu)); ((i) < ((alternatives).length)); ((i) = ((i) + ((usize)(1llu))))) {
            VariableLookup_s *t = ((atPS3313uszrPS6661)((&(alternatives)), (i)));
            ((dropPS0540rN)((&(loc))));
            ((loc) = ((getLocationPS6070rS0540)((&((t)->name)))));
            (((fprintf))((stderr_), ("%s: %s: A variable with that name is located here. Import the file to use it.\n"), ((loc).buffer), (NOTE_STR)));
        }

    }

    else if (((alternatives).length) > ((usize)(0llu))) {
        ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((alternatives).length), ("global variable with that name"), ("global variables with that name")));
    }

    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_IDENTIFIER)}}});
}
none reportVerboseNotePS3900S0540uszPcPcrN(TypeChecker_s *this, String_s loc, usize count, char *s1, char *s2) {
    char *is = ((pluszPcPcrPc)((count), ("is"), ("are")));
    char *ol = ((pluszPcPcrPc)((count), (s1), (s2)));
    char *it = ((pluszPcPcrPc)((count), ("it"), ("them")));
    (((fprintf))((stderr_), ("%s: %s: There %s %llu %s. Re-run with the --verbose flag to see %s.\n"), ((loc).buffer), (NOTE_STR), (is), (count), (ol), (it)));
}
TCState_u reportTypeMismatchPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *expected, Type_u *got) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ1 = ((toStringPU5175rS0540)((expected)));
    String_s typ2 = ((toStringPU5175rS0540)((got)));
    (((fprintf))((stderr_), ("%s: %s: Type mismatch! Expected type %s, found type %s.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Type_u *lhsType, Span_s rhsSpan, Type_u *rhsType) {
    Span_s tmp_55464 = ((newSpanBetweenPS8951PS8951rS8951)((&(lhsSpan)), (&(rhsSpan))));

    String_s loc = ((toStringPS8951rS0540)((&tmp_55464)));
    String_s loc1 = ((toStringPS8951rS0540)((&(lhsSpan))));
    String_s loc2 = ((toStringPS8951rS0540)((&(rhsSpan))));
    String_s typ1 = ((toStringPU5175rS0540)((lhsType)));
    String_s typ2 = ((toStringPU5175rS0540)((rhsType)));
    (((fprintf))((stderr_), ("%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), (op), ((typ2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: LHS has type %s.\n"), ((loc1).buffer), (NOTE_STR), ((typ1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: RHS has type %s.\n"), ((loc2).buffer), (NOTE_STR), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Span_s rhsSpan) {
    Span_s tmp_55560 = ((newSpanBetweenPS8951PS8951rS8951)((&(lhsSpan)), (&(rhsSpan))));

    String_s loc = ((toStringPS8951rS0540)((&tmp_55560)));
    (((fprintf))((stderr_), ("%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n"), ((loc).buffer), (ERR_STR), (op)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INVALID_POINTER_ARITHMETIC)}}});
}
TCState_u reportDuplicateFieldPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s fieldToken, Span_s declSpan) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((fieldToken).span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(declSpan))));
    String_s name = ((toStringPS7720rS0540)((&((fieldToken).content))));
    (((fprintf))((stderr_), ("%s: %s: Field redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Field `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_FIELD)}}});
}
TCState_u reportDuplicateParameterPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s paramToken, Span_s declSpan) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((paramToken).span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(declSpan))));
    String_s name = ((toStringPS7720rS0540)((&((paramToken).content))));
    (((fprintf))((stderr_), ("%s: %s: Parameter redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Parameter `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_PARAMETER)}}});
}
TCState_u reportUnknownFieldPS3900S6070PS4228BrU9661(TypeChecker_s *this, Token_s name, StructLookup_s *decl, bool isUnion) {
    String_s errLoc = ((toStringPS8951rS0540)((&((name).span))));
    String_s declLoc = ((toStringPS8951rS0540)((&(((decl)->name).span))));
    String_s strukt = ((toStringPS7720rS0540)((&(((decl)->name).content))));
    String_s field = ((toStringPS7720rS0540)((&((name).content))));
    char *s1 = ("struct");
    char *s2 = ("Struct");
    if (isUnion) {
        ((s1) = ("union variant"));
        ((s2) = ("Union variant"));
    }

    (((fprintf))((stderr_), ("%s: %s: Attempted to access unknown field `%s` of instance of %s %s.\n"), ((errLoc).buffer), (ERR_STR), ((field).buffer), (s1), ((strukt).buffer)));
    (((fprintf))((stderr_), ("%s: %s: %s %s is declared here.\n"), ((declLoc).buffer), (NOTE_STR), (s2), ((strukt).buffer)));
    ((dropPS0540rN)((&(field))));
    ((dropPS0540rN)((&(strukt))));
    ((dropPS0540rN)((&(declLoc))));
    ((dropPS0540rN)((&(errLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_FIELD)}}});
}
TCState_u reportUnknownTypePS3900PS0997S6070S1581rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name, TypeLookupList_s alternatives) {
    String_s loc = ((getLocationPS6070rS0540)((&(name))));
    String_s _n = ((toStringPS7720rS0540)((&((name).content))));
    if ((mod) != (NULL)) {
        ParsedModule_s *modNode = ((atPS7393uszrPS1882)((&(modules)), ((mod)->globalID)));
        String_s _n1 = ((toStringPS7720rS0540)((&(((modNode)->name).content))));
        String_s loc1 = ((toStringPS8951rS0540)((&((modNode)->span))));
        (((fprintf))((stderr_), ("%s: %s: Module `%s` does not contain any types named `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n1).buffer), ((_n).buffer)));
        (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((loc1).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(loc1))));
        ((dropPS0540rN)((&(_n1))));
    }

    else {
        (((fprintf))((stderr_), ("%s: %s: Use of undeclared type identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n).buffer)));
        if (*((flags).verbose)) {
            for (usize i = ((usize)(0llu)); ((i) < ((alternatives).length)); ((i) = ((i) + ((usize)(1llu))))) {
                TypeLookup_s *t = ((atPS1581uszrPS6177)((&(alternatives)), (i)));
                if ((isStructPS6177rB)((t))) {
                    StructLookup_s *s = ((asStructPS6177rPS4228)((t)));
                    ((dropPS0540rN)((&(loc))));
                    ((loc) = ((getLocationPS6070rS0540)((&((s)->name)))));
                    (((fprintf))((stderr_), ("%s: %s: A struct with that name is located here. Import the file to use it.\n"), ((loc).buffer), (NOTE_STR)));
                }
            }

        }

        else if (((alternatives).length) > ((usize)(0llu))) {
            ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((alternatives).length), ("struct with that name"), ("structs with that name")));
        }
    }

    ((dropPS0540rN)((&(_n))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_TYPE)}}});
}
TCState_u reportDuplicateFunctionPS3900PS0677PS0677rU9661(TypeChecker_s *this, FunctionLookup_s *f1, FunctionLookup_s *f2) {
    String_s errLoc = ((toStringPS8951rS0540)((&(((f1)->name).span))));
    String_s duplLoc = ((toStringPS8951rS0540)((&(((f2)->name).span))));
    String_s name = ((toStringPS7720rS0540)((&(((f1)->name).content))));
    String_s typ = ((toStringPU5175rS0540)(((getTypePU9661rPU5175)((&((f1)->fnType))))));
    (((fprintf))((stderr_), ("%s: %s: Function redeclaration.\n"), ((errLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: A function named `%s` with the signature %s is already declared here.\n"), ((duplLoc).buffer), (ERR_STR), ((name).buffer), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(duplLoc))));
    ((dropPS0540rN)((&(errLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_FUNCTION)}}});
}
TCState_u reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661(TypeChecker_s *this, Token_s ident, Type_u *fnType, FunctionLookupList_s *functions) {
    String_s loc = ((toStringPS8951rS0540)((&((ident).span))));
    String_s name = ((toStringPS7720rS0540)((&((ident).content))));
    String_s typ = ((toStringPU5175rS0540)((fnType)));
    (((fprintf))((stderr_), ("%s: %s: No function overload fits the provided context for call to function `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Context requires an overload of the form %s.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((assertBPcrN)((((functions)->length) != ((usize)(0llu))), ("reportNoFunctionCallCandidate: Expected at least one declaration")));
    if (*((flags).verbose)) {
        for (usize i = ((usize)(0llu)); ((i) < ((functions)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            FunctionLookup_s *f = ((atPS8385uszrPS0677)((functions), (i)));
            ((dropPS0540rN)((&(typ))));
            ((dropPS0540rN)((&(loc))));
            ((loc) = ((toStringPS8951rS0540)((&(((f)->name).span)))));
            ((typ) = ((toStringPU5175rS0540)(((getTypePU9661rPU5175)((&((f)->fnType)))))));
            (((fprintf))((stderr_), ("%s: %s: Overload %s declared here.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
        }

    }

    else {
        ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((functions)->length), ("possible overload"), ("possible overloads")));
    }

    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_CALL_CANDIDATE)}}});
}
TCState_u reportVariableRedeclarationPS3900S6070S6070rU9661(TypeChecker_s *this, Token_s newDecl, Token_s oldDecl) {
    String_s newLoc = ((toStringPS8951rS0540)((&((newDecl).span))));
    String_s oldLoc = ((toStringPS8951rS0540)((&((oldDecl).span))));
    String_s name = ((toStringPS7720rS0540)((&((newDecl).content))));
    (((fprintf))((stderr_), ("%s: %s: Variable redeclaration.\n"), ((newLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variable `%s` already declared here.\n"), ((oldLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(oldLoc))));
    ((dropPS0540rN)((&(newLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_VARIABLE_REDECLARATION)}}});
}
TCState_u reportRecursiveTypePS3900PS6177PS1581rU9661(TypeChecker_s *this, TypeLookup_s *checked, TypeLookupList_s *cycle) {
    String_s loc = ((getLocationPS6177rS0540)((checked)));
    String_s name = ((getNamePS6177rS0540)((checked)));
    (((fprintf))((stderr_), ("%s: %s: Recursive type %s.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    ((assertBPcrN)((((cycle)->length) >= ((usize)(1llu))), ("Cycle is empty")));
    for (usize i = ((usize)(1llu)); ((i) < ((cycle)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((loc) = ((getLocationPS6177rS0540)(((atPS1581uszrPS6177)((cycle), (i))))));
        ((name) = ((getNamePS6177rS0540)(((atPS1581uszrPS6177)((cycle), (i))))));
        (((fprintf))((stderr_), ("%s: %s: Chain of recursion also includes type %s.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer)));
    }

    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_RECURSIVE_TYPE)}}});
}
TCState_u reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *from, Type_u *to) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ1 = ((toStringPU5175rS0540)((from)));
    String_s typ2 = ((toStringPU5175rS0540)((to)));
    (((fprintf))((stderr_), ("%s: %s: Non primitive cast from type %s to %s.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NON_PRIMITIVE_CAST)}}});
}
TCState_u reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *typ) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s name = ((toStringPU5175rS0540)((typ)));
    (((fprintf))((stderr_), ("%s: %s: Indexed Access is only supported for arrays, pointers and variadic types.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Expression has type %s.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_ACCESS_ON_NON_ARRAY)}}});
}
TCState_u reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661(TypeChecker_s *this, Token_s ident, VariableLookup_s *var) {
    String_s loc = ((toStringPS8951rS0540)((&((ident).span))));
    String_s otherLoc = ((toStringPS8951rS0540)((&(((var)->name).span))));
    String_s name = ((toStringPS7720rS0540)((&((ident).content))));
    (((fprintf))((stderr_), ("%s: %s: Variables declared with `let` can\'t be used in a comptime context.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variable `%s` is declared here.\n"), ((otherLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(otherLoc))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT)}}});
}
TCState_u reportAnyDereferencePS3900PS2435rU9661(TypeChecker_s *this, ParsedExpr_s *expr) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Can\'t dereference expression of type Any.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ANY_DEREF)}}});
}
TCState_u reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator is not defined for values of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator expected an identifier for a value of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator expected a number for a value of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *tuple, usize index) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((tuple)));
    (((fprintf))((stderr_), ("%s: %s: Index %llu is not valid for value of type %s.\n"), ((loc).buffer), (ERR_STR), (index), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportCouldNotInferTypePS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer type of expression.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INFER_FAILED)}}});
}
TCState_u reportMemberAccessNoOptionsPS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which type to use for expression.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NO_OPTIONS)}}});
}
TCState_u reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661(TypeChecker_s *this, Span_s span, StructLookupList_s *structs) {
    ((assertBrN)((((structs)->length) > ((usize)(0llu)))));
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which type to use for expression.\n"), ((loc).buffer), (ERR_STR)));
    for (usize i = ((usize)(0llu)); ((i) < ((structs)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((structs), (i)));
        String_s l = ((toStringPS8951rS0540)((&(((s)->name).span))));
        String_s n = ((toStringPS7720rS0540)((&(((s)->name).content))));
        (((fprintf))((stderr_), ("%s: %s: Context allows struct %s to be used.\n"), ((l).buffer), (NOTE_STR), ((n).buffer)));
        ((dropPS0540rN)((&(n))));
        ((dropPS0540rN)((&(l))));
    }

    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS)}}});
}
TCState_u reportFunctionCallTooManyOptionsPS3900PS3328rU9661(TypeChecker_s *this, CallExpr_s *expr) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which function to call.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS)}}});
}
TCState_u reportCallToNonFunctionPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *base) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ = ((toStringPU5175rS0540)((base)));
    (((fprintf))((stderr_), ("%s: %s: Can\'t call expression of type %s.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Currently, all variables (including global variables) shadow functions.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: This is a known limitation and will be fixed soon.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_CALL_TO_NON_FUNCTION)}}});
}
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args) {
    return ((reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661)((this), (span), (base), (args), (false)));
}
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args, bool atLeast) {
    usize c = ((usize)(0llu));
    bool succ_7266_ = true;

    Type_u *tmp_11330_ = (base);
    {
        succ_7266_ &= (tmp_11330_->tag == 6);
        TypeList_s *params = &tmp_11330_->payload.variant6._0;
        succ_7266_ &= true;
        succ_7266_ &= true;
        succ_7266_ &= true;
        if (succ_7266_) {
            {
                ((c) = ((*params).length));
            }
            goto after_11330;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_11330;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11330:
    (void)0; // error: label at end of compound statement is a C23 extension
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ = ((toStringPU5175rS0540)((base)));
    char *s = ("arguments");
    if ((c) == ((usize)(1llu)))
        ((s) = ("argument"));
    char *w = ("were");
    if ((args) == ((usize)(1llu)))
        ((w) = ("was"));
    char *min = ("");
    if (atLeast)
        ((min) = ("at least "));
    (((fprintf))((stderr_), ("%s: %s: Call expects %s%llu %s, but %llu %s provided.\n"), ((loc).buffer), (ERR_STR), (min), (c), (s), (args), (w)));
    (((fprintf))((stderr_), ("%s: %s: Call expression has type %s.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_CALL_TO_NON_FUNCTION)}}});
}
TCState_u reportUnknownSubmodulePS3900PS0997S6070rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name) {
    String_s loc = ((toStringPS8951rS0540)((&((name).span))));
    ParsedModule_s *_mod = ((atPS7393uszrPS1882)((&(modules)), ((mod)->globalID)));
    String_s orig = ((toStringPS8951rS0540)((&((_mod)->span))));
    String_s _origName = ((toStringPS7720rS0540)((&(((_mod)->name).content))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: Module `%s` does not contain any submodules named `%s`.\n"), ((loc).buffer), (ERR_STR), ((_origName).buffer), ((_name).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((orig).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(_origName))));
    ((dropPS0540rN)((&(orig))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_SUBMODULE)}}});
}
TCState_u reportUnknownModulePS3900S6070rU9661(TypeChecker_s *this, Token_s name) {
    String_s loc = ((toStringPS8951rS0540)((&((name).span))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: Use of undeclared module `%s`.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_MODULE)}}});
}
TCState_u reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661(TypeChecker_s *this, Span_s span, Token_s name, TypeLookup_s typ) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: `%s` is not a module, so the `::` operator cannot be applied.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    if (((typ).kind) != (TYPE_LOOKUP_INVALID)) {
        String_s _loc = ((getLocationPS6177rS0540)((&(typ))));
        (((fprintf))((stderr_), ("%s: %s: Struct declared here.\n"), ((_loc).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(_loc))));
    }

    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MODULE_ACCESS_NON_MODULE)}}});
}
TCState_u reportDuplicateVariantPS3900PS3506PS2365rU9661(TypeChecker_s *this, ParsedUnionVariant_s *orig, UnionVariantLookup_s *dupl) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((orig)->span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(((dupl)->global)->span))));
    String_s name = ((toStringPS7720rS0540)((&(((orig)->name).content))));
    (((fprintf))((stderr_), ("%s: %s: Union Variant redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variant `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_UNION_VARIANT)}}});
}
TCState_u reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661(TypeChecker_s *this, ParsedUnionVariant_s *variant, Token_s *first, Token_s *dupl) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((first)->span))));
    String_s origLoc = ((toStringPS8951rS0540)((&((dupl)->span))));
    String_s name = ((toStringPS7720rS0540)((&((first)->content))));
    (((fprintf))((stderr_), ("%s: %s: Union Variant already contains a field with that name.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Field `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_UNION_NAME)}}});
}
TCState_u reportImpossiblePatternPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
TCState_u reportNotEnoughPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    TCState_u err = ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    (((fprintf))((stderr_), ("%s: %s: Not enough patterns were provided to match the type.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: If you only care about certain fields, you can use `_` or `..` to ignore the rest.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return (err);
}
char *_anon_23_0U3836rPc(ParsedUnionVariantData_u data) {
    bool succ_7308_ = true;
    bool succ_7312_ = true;
    bool succ_7315_ = true;

    ParsedUnionVariantData_u tmp_11427_ = (data);
    {
        succ_7308_ &= (tmp_11427_.tag == 0);
        if (succ_7308_) {
            {
                return ("an Empty");
            }
            goto after_11427;
        }
    }
    {
        succ_7312_ &= (tmp_11427_.tag == 2);
        succ_7312_ &= true;
        succ_7312_ &= true;
        if (succ_7312_) {
            {
                return ("a Struct");
            }
            goto after_11427;
        }
    }
    {
        succ_7315_ &= (tmp_11427_.tag == 1);
        succ_7315_ &= true;
        if (succ_7315_) {
            {
                return ("a Tuple");
            }
            goto after_11427;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11427;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11427:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661(TypeChecker_s *this, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, Span_s span, ParsedUnionVariantData_u gotVar) {
    String_s loc1 = ((toStringPS8951rS0540)((&(span))));
    String_s loc2 = ((toStringPS8951rS0540)((&(((decl)->name).span))));
    String_s loc3 = ((toStringPS8951rS0540)((&((variant)->span))));
    String_s name1 = ((toStringPS7720rS0540)((&(((variant)->name).content))));
    String_s name2 = ((toStringPS7720rS0540)((&(((decl)->name).content))));
    char *(*f)(ParsedUnionVariantData_u) = (_anon_23_0U3836rPc);
    char *exp = ((f)(((variant)->data)));
    char *got = ((f)((gotVar)));
    (((fprintf))((stderr_), ("%s: %s: Invalid initialization of variant `%s` of type %s.\n"), ((loc1).buffer), (ERR_STR), ((name1).buffer), ((name2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: `%s` is %s variant, but an initializer for %s variant was provided.\n"), ((loc3).buffer), (NOTE_STR), ((name1).buffer), (exp), (got)));
    (((fprintf))((stderr_), ("%s: %s: Type declared here.\n"), ((loc2).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(loc3))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(name2))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INVALID_VARIANT_INIT)}}});
}
TCState_u reportInvalidVariantPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Type %s has no such variant.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
char *_anon_23_1U3836rPc(ParsedUnionVariantData_u data) {
    bool succ_7327_ = true;
    bool succ_7331_ = true;
    bool succ_7334_ = true;

    ParsedUnionVariantData_u tmp_11462_ = (data);
    {
        succ_7327_ &= (tmp_11462_.tag == 0);
        if (succ_7327_) {
            {
                return ("an Empty");
            }
            goto after_11462;
        }
    }
    {
        succ_7331_ &= (tmp_11462_.tag == 2);
        succ_7331_ &= true;
        succ_7331_ &= true;
        if (succ_7331_) {
            {
                return ("a Struct");
            }
            goto after_11462;
        }
    }
    {
        succ_7334_ &= (tmp_11462_.tag == 1);
        succ_7334_ &= true;
        if (succ_7334_) {
            {
                return ("a Tuple");
            }
            goto after_11462;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11462;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11462:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type, ParsedUnionVariantData_u expVar, ParsedUnionVariantData_u gotVar) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    char *(*f)(ParsedUnionVariantData_u) = (_anon_23_1U3836rPc);
    char *exp = ((f)((expVar)));
    char *got = ((f)((gotVar)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    (((fprintf))((stderr_), ("%s: %s: %s pattern can\'t be used to match against %s variant.\n"), ((loc).buffer), (NOTE_STR), (got), (exp)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
TCState_u reportNoSuchVariantPS3900PS1592S6070rU9661(TypeChecker_s *this, UnionLookup_s *lookup, Token_s tkn) {
    String_s loc1 = ((toStringPS8951rS0540)((&((tkn).span))));
    String_s name1 = ((toStringPS7720rS0540)((&((tkn).content))));
    String_s loc2 = ((toStringPS8951rS0540)((&(((lookup)->name).span))));
    String_s name2 = ((toStringPS7720rS0540)((&(((lookup)->name).content))));
    (((fprintf))((stderr_), ("%s: %s: Type %s has no variant named `%s`.\n"), ((loc1).buffer), (ERR_STR), ((name2).buffer), ((name1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Type declared here.\n"), ((loc2).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(name2))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_VARIANT)}}});
}
TCState_u reportTooManyPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    TCState_u err = ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    (((fprintf))((stderr_), ("%s: %s: Too many patterns were provided to match the type.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return (err);
}
TCState_u reportStatementInNakedFunctionPS3900PS1100rU9661(TypeChecker_s *this, ParsedStmt_s *stmt) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    (((fprintf))((stderr_), ("%s: %s: Only `asm` statements are allowed in functions marked `@naked`.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NAKED_STATEMENT)}}});
}
TCState_u reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    String_s name1 = ((toStringPU5175rS0540)((got)));
    String_s name2 = ((toStringPU5175rS0540)((wanted)));
    (((fprintf))((stderr_), ("%s: %s: The function passed as the first argument to `asm` must return an %s.\n"), ((loc).buffer), (ERR_STR), ((name2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: The function currently returns a value of type `%s`.\n"), ((loc).buffer), (NOTE_STR), ((name1).buffer)));
    ((dropPS0540rN)((&(name2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    String_s name1 = ((toStringPU5175rS0540)((got)));
    String_s name2 = ((toStringPU5175rS0540)((wanted)));
    (((fprintf))((stderr_), ("%s: %s: Expected first argument of `asm` to be a function, but found expression of type `%s`.\n"), ((loc).buffer), (ERR_STR), ((name1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Inline assembly uses compile-time evaluation and requires the function to return an %s.\n"), ((loc).buffer), (NOTE_STR), ((name2).buffer)));
    ((dropPS0540rN)((&(name2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661(TypeChecker_s *this, ParsedStmt_s *stmt, usize argCount, usize paramCount) {
    char *args = ((pluszPcPcrPc)((argCount), ("argument"), ("arguments")));
    char *params = ((pluszPcPcrPc)((paramCount), ("parameter"), ("parameters")));
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    (((fprintf))((stderr_), ("%s: %s: The function passed to `asm` expected %llu %s, but got %llu %s.\n"), ((loc).buffer), (ERR_STR), (paramCount), (params), (argCount), (args)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportMissingTrampolinePS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Pattern in variable declaration is not exhaustive.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Provide a trampoline to handle the case where the pattern does not match.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: A trampoline is an `else`-block after the declaration, for example `let a = 10 else { /* trampoline */ };`\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MISSING_TRAMPOLINE)}}});
}
none reportUnnecessaryTrampolinePS3900S8951rN(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Pattern in variable declaration is exhaustive, the trampoline is unreachable.\n"), ((loc).buffer), (WARN_STR)));
    ((dropPS0540rN)((&(loc))));
}
none emergencyPrintPS3900S8951rN(TypeChecker_s *this, Span_s where) {
    Token_s t = ((Token_s){.span = (where), .content = ((newSubStrOfStrLitPcrS7720)((""))), .kind = (TOKEN_EOF)});
    (((printf))(("%s\n"), (((getLocationPS6070rS0540)((&(t)))).buffer)));
}
bool typeCheckProjectPS3900PS1892rB(TypeChecker_s *this, ParsedFile_s *project) {
    if (!((fillLookupPS3900rB)((this))))
        return (false);
    if (!((typeCheckFilesPS3900rB)((this))))
        return (false);
    if ((findRecursiveTypesPS3900rB)((this)))
        return (false);
    return (!((this)->typeError));
}
bool dfsPS3900PU5175PS1581PS1581rB(TypeChecker_s *this, Type_u *type, TypeLookupList_s *visited, TypeLookupList_s *finished) {
    bool succ_7361_ = true;
    bool succ_7365_ = true;
    bool succ_7370_ = true;

    Type_u *tmp_11544_ = (type);
    {
        succ_7361_ &= (tmp_11544_->tag == 5);
        Type_u **under = &tmp_11544_->payload.variant5._0;
        succ_7361_ &= true;
        succ_7361_ &= true;
        if (succ_7361_) {
            {
                return ((dfsPS3900PU5175PS1581PS1581rB)((this), (*under), (visited), (finished)));
            }
            goto after_11544;
        }
    }
    {
        succ_7365_ &= (tmp_11544_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_11544_->payload.variant7._0;
        succ_7365_ &= true;
        if (succ_7365_) {
            {
                return ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS4228rS6177)(((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), ((getIDPS5521rusz)((*decl))))))), (visited),
                                                       (finished)));
            }
            goto after_11544;
        }
    }
    {
        succ_7370_ &= (tmp_11544_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_11544_->payload.variant8._0;
        succ_7370_ &= true;
        succ_7370_ &= true;
        if (succ_7370_) {
            {
                return ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS1592rS6177)(((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (*decl))))), (visited), (finished)));
            }
            goto after_11544;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11544;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11544:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool dfsPS3900S6177PS1581PS1581rB(TypeChecker_s *this, TypeLookup_s typeLookup, TypeLookupList_s *visited, TypeLookupList_s *finished) {
    if ((containsPS1581PS6177rB)((finished), (&(typeLookup))))
        return (false);
    if ((containsPS1581PS6177rB)((visited), (&(typeLookup))))
        return (true);
    ((pushPS1581S6177rN)((visited), (typeLookup)));
    bool done = (false);
    if ((isStructPS6177rB)((&(typeLookup)))) {
        StructLookup_s *strukt = ((asStructPS6177rPS4228)((&(typeLookup))));
        for (usize i = ((usize)(0llu)); ((i) < (((strukt)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
            VariableLookup_s *field = ((atPS3313uszrPS6661)((&((strukt)->fields)), (i)));
            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type in DFS")));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
            if ((dfsPS3900PU5175PS1581PS1581rB)((this), (fieldType), (visited), (finished))) {
                ((done) = (true));
            }
        }

    }

    else if ((isUnionPS6177rB)((&(typeLookup)))) {
        UnionLookup_s *onion = ((asUnionPS6177rPS1592)((&(typeLookup))));
        for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
            UnionVariantLookup_s *_variant = ((atPS4601uszrPS2365)((&((onion)->variants)), (i)));
            ParsedUnionVariant_s *variant = ((_variant)->global);
            bool succ_7391_ = true;
            bool succ_7389_ = true;

            tuple_1017 tmp_11568_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_7389_ = tmp_11568_._0 == true;
            succ_7391_ &= succ_7389_;
            ParsedTypeNodeList_s **fields = &tmp_11568_._1;
            succ_7391_ &= true;
            if (!succ_7391_) {
                continue;
            };
            for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
                ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type in DFS")));
                Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                if ((dfsPS3900PU5175PS1581PS1581rB)((this), (fieldType), (visited), (finished))) {
                    ((done) = (true));
                }
            }
        }

    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of TypeLookup kinds in dfs")));
    }

    ((pushPS1581S6177rN)((finished), (typeLookup)));
    return (done);
}
bool findRecursiveTypesPS3900rB(TypeChecker_s *this) {
    bool recursive = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((decl)->ignored)
            continue;
        StructLookup_s *strukt = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), (i)));
        TypeLookupList_s visited = ((TypeLookupList_s){0});
        TypeLookupList_s finished = ((TypeLookupList_s){0});
        if ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS4228rS6177)((strukt))), (&(visited)), (&(finished)))) {
            TypeLookup_s tmp_58282 = ((asTypeLookupPS4228rS6177)((strukt)));

            ((reportRecursiveTypePS3900PS6177PS1581rU9661)((this), (&tmp_58282), (&(visited))));
            ((recursive) = (true));
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((decl)->ignored)
            continue;
        UnionLookup_s *onion = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (decl)));
        TypeLookupList_s visited = ((TypeLookupList_s){0});
        TypeLookupList_s finished = ((TypeLookupList_s){0});
        if ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS1592rS6177)((onion))), (&(visited)), (&(finished)))) {
            TypeLookup_s tmp_58332 = ((asTypeLookupPS1592rS6177)((onion)));

            ((reportRecursiveTypePS3900PS6177PS1581rU9661)((this), (&tmp_58332), (&(visited))));
            ((recursive) = (true));
        }
    }

    return (recursive);
}
bool fillLookupPS3900rB(TypeChecker_s *this) {
    bool success = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((insertFilePS7791PS1892rPS0997)((&((this)->lookup)), (file))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if ((tli)->ignored)
                continue;
            if (!((insertTLIPS0997PS1038rB)(((this)->currentModule), (tli))))
                ((success) = (false));
        }
    }

    return (success);
}
bool typeCheckFilesPS3900rB(TypeChecker_s *this) {
    bool success = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_STRUCT_DECL)) {
                TCState_u state = ((typeCheckStructDeclPS3900uszrU9661)((this), ((tli)->nodeID)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_UNION_DECL)) {
                TCState_u state = ((typeCheckUnionDeclPS3900PS0997rU9661)((this), ((asUnionPS1038rPS0997)((tli)))));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_FUNC_DECL)) {
                TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (true)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_MOD_DECL)) {
                TCState_u state = ((typeCheckModulePS3900uszPS5541rU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables))));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                TCState_u state = ((typeCheckVarDeclPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (true)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_FUNC_DECL)) {
                TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (false)));
                FunctionLookup_s *_dupl = (NULL);
                FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS0997uszrPS0677)(((this)->currentModule), ((tli)->nodeID)));
                if ((containsDuplicateFunctionPS0997PS0677PPS0677rB)(((this)->currentModule), (funcLookup), (&(_dupl)))) {
                    ((assertBPcrN)(((_dupl) != (NULL)), ("Duplicate FunctionLookup is null")));
                    ((reportDuplicateFunctionPS3900PS0677PS0677rU9661)((this), (funcLookup), (_dupl)));
                    ((success) = (false));
                }

                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    return (success);
}
TCState_u typeCheckModulePS3900uszPS5541rU9661(TypeChecker_s *this, usize modID, ScopeLookupList_s *scopes) {
    ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), (modID)));
    ModuleLookup_s *prev = ((this)->currentModule);
    (((this)->currentModule) = ((getModuleByGlobalIDPS7791uszrPS0997)((&((this)->lookup)), (modID))));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_STRUCT_DECL)) {
            TCState_u state = ((typeCheckStructDeclPS3900uszrU9661)((this), ((tli)->nodeID)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_UNION_DECL)) {
            TCState_u state = ((typeCheckUnionDeclPS3900PS0997rU9661)((this), ((asUnionPS1038rPS0997)((tli)))));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_FUNC_DECL)) {
            TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (true)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_MOD_DECL)) {
            TCState_u state = ((typeCheckModulePS3900uszPS5541rU9661)((this), ((tli)->nodeID), (scopes)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_VAR_DECL)) {
            TCState_u state = ((typeCheckVarDeclPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (true)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_FUNC_DECL)) {
            TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (false)));
            FunctionLookup_s *_dupl = (NULL);
            FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS0997uszrPS0677)(((this)->currentModule), ((tli)->nodeID)));
            if ((containsDuplicateFunctionPS0997PS0677PPS0677rB)(((this)->currentModule), (funcLookup), (&(_dupl)))) {
                ((assertBPcrN)(((_dupl) != (NULL)), ("Duplicate FunctionLookup is null")));
                ((result) = ((reportDuplicateFunctionPS3900PS0677PS0677rU9661)((this), (funcLookup), (_dupl))));
            }

            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    (((this)->currentModule) = (prev));
    return (result);
}
TCState_u typeCheckUnionDeclPS3900PS0997rU9661(TypeChecker_s *this, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    UnionLookup_s *unionLookup = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (onion)));
    ((assertBPcrN)(((isUnionPU5175rB)(((unionLookup)->type))), ("typeCheckUnionDecl: Union Lookup doesn\'t contain Union Type")));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((unionLookup)->type)}}});
    for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
        TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (onion), ._1 = ((usize)(0llu))}}})))}}});
        UnionVariantLookup_s *dupl = (NULL);
        if ((checkForDuplicateVariantPS1592PS3506PPS2365rB)((unionLookup), (variant), (&(dupl)))) {
            ((result) = ((reportDuplicateVariantPS3900PS3506PS2365rU9661)((this), (variant), (dupl))));
        }

        bool succ_7545_ = true;
        bool succ_7549_ = true;
        bool succ_7557_ = true;

        ParsedUnionVariantData_u *tmp_11876_ = (&((variant)->data));
        {
            succ_7545_ &= (tmp_11876_->tag == 0);
            if (succ_7545_) {
                {
                }
                goto after_11876;
            }
        }
        {
            succ_7549_ &= (tmp_11876_->tag == 1);
            ParsedTypeNodeList_s *fields = &tmp_11876_->payload.variant1._0;
            succ_7549_ &= true;
            if (succ_7549_) {
                {
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        TCState_u fieldState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((((*fields).elements))[(j)])));
                        if (!((isSuccessPU9661rB)((&(fieldState))))) {
                            ((result) = (fieldState));
                        }
                    }
                }
                goto after_11876;
            }
        }
        {
            succ_7557_ &= (tmp_11876_->tag == 2);
            ParsedTypeNodeList_s *fields = &tmp_11876_->payload.variant2._0;
            succ_7557_ &= true;
            TokenList_s *names = &tmp_11876_->payload.variant2._1;
            succ_7557_ &= true;
            if (succ_7557_) {
                {
                    ((assertBPcrN)((((*fields).length) == ((*names).length)), ("typeCheckUnionDecl: fields.length != names.length")));
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedTypeNode_s *field = ((((*fields).elements))[(j)]);
                        Token_s *name = (&((((*names).elements))[(j)]));
                        Token_s *duplName = (NULL);
                        if ((checkForDuplicateNamePS3506PS6070PPS6070rB)((variant), (name), (&(duplName)))) {
                            ((result) = ((reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661)((this), (variant), (name), (duplName))));
                            break;
                        }

                        TCState_u fieldState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (field)));
                        if (!((isSuccessPU9661rB)((&(fieldState))))) {
                            ((result) = (fieldState));
                        }
                    }
                }
                goto after_11876;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_11876;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_11876:
        (void)0; // error: label at end of compound statement is a C23 extension
        ((addVariantPS1592PS3506U9661rN)((unionLookup), (variant), (state)));
    }

    if ((isSuccessPU9661rB)((&(result)))) {
        (((onion)->typeState) = (result));
    }

    return (result);
}
TCState_u typeCheckStructDeclPS3900uszrU9661(TypeChecker_s *this, usize structID) {
    ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (structID)));
    if ((strukt)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    StructLookup_s *structLookup = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), (structID)));
    ((assertBPcrN)(((isStructPU5175rB)(((structLookup)->type))), ("typeCheckStructDecl: Struct Lookup doesn\'t contain Struct Type")));
    StructContext_s *context = (&((strukt)->context));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    TCState_u failure = (((TCState_u){.tag = 0, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < ((context)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((context), (i)));
        ParsedTypeNode_s *typ = ((getFieldTypeAtIndexPS7871uszrPS1372)((context), (i)));
        VariableLookup_s dupl = ((VariableLookup_s){0});
        if ((checkForDuplicateFieldPS4228PS6070PS6661rB)((structLookup), (&(name)), (&(dupl)))) {
            ((failure) = ((reportDuplicateFieldPS3900S6070S8951rU9661)((this), (name), (((dupl).name).span))));
            continue;
        }

        TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (typ)));
        if ((isErrorPU9661rB)((&(state)))) {
            ((failure) = (state));
            continue;
        }

        ((addFieldPS4228uszS6070U9661rN)((structLookup), ((NODE_ID_OFFSET) + (i)), (name), (state)));
    }

    if (!((isInvalidPU9661rB)((&(failure)))))
        return (failure);
    (((strukt)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((structLookup)->type)}}}));
    return (result);
}
TCState_u typeCheckFunctionPS3900uszPS5541BrU9661(TypeChecker_s *this, usize funcID, ScopeLookupList_s *scopes, bool signatureOnly) {
    return ((typeCheckFunctionPS3900PS4904PS5541BrU9661)((this), ((atPS4111uszrPS4904)((&(funcDecls)), (funcID))), (scopes), (signatureOnly)));
}
TCState_u typeCheckFunctionPS3900PS4904PS5541BrU9661(TypeChecker_s *this, ParsedFuncDecl_s *function, ScopeLookupList_s *scopes, bool signatureOnly) {
    if ((function)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS7791uszrPS0677)((&((this)->lookup)), ((getIDPS4904rusz)((function)))));
    (((this)->currentFunction) = (funcLookup));
    TCState_u failure = (((TCState_u){.tag = 0, .payload = {0}}));
    ((clearPS3313rN)((&((funcLookup)->params))));
    TypeList_s params = ((TypeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *typ = ((getTypeAtIndexPS9803uszrPS1372)((&((function)->params)), (i)));
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
        VariableLookup_s dupl = ((VariableLookup_s){0});
        if ((checkForDuplicateParamPS0677PS6070PS6661rB)((funcLookup), (&(name)), (&(dupl)))) {
            ((failure) = ((reportDuplicateParameterPS3900S6070S8951rU9661)((this), (name), (((dupl).name).span))));
            continue;
        }

        TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (typ)));
        if ((isErrorPU9661rB)((&(state)))) {
            ((failure) = (state));
            continue;
        }

        ((pushPS0643PU5175rN)((&(params)), ((getTypePU9661rPU5175)((&(state))))));
        ((addParameterPS0677uszS6070U9661rN)((funcLookup), ((NODE_ID_OFFSET) + (i)), (name), (state)));
    }

    if (!((isInvalidPU9661rB)((&(failure)))))
        return (failure);
    TCState_u retState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((function)->retType)));
    if ((isErrorPU9661rB)((&(retState))))
        return (retState);
    Type_u *fnType =
        ((wrapU5175rPU5175)(((Type_u){.tag = 6,
                                      .payload = {.variant6 = {._0 = (params),
                                                               ._1 = ((getTypePU9661rPU5175)((&(retState)))),
                                                               ._2 = ((FuncAttr_s){.isVariadic = (((function)->params).isVarArg),
                                                                                   .isNoreturn = ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 3, .payload = {0}}))))})}}})));
    TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (fnType)}}});
    (((funcLookup)->fnType) = (state));
    (((function)->typeState) = (state));
    if ((isExternPS4904rB)((function))) {
        if (!(((function)->parent).isFile)) {
            ParsedModule_s *mod = ((getParentModulePS4904rPS1882)((function)));
            String_s _name = ((getMangledNamePS4904rS0540)((function)));
            if ((((mod)->dlls).length) == ((usize)(0llu))) {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
                    (((fprintf))((stderr_), ("%s: %s: No dynamic library was found for external function %s. You will not be able to call it at compile time.\n"), ((loc).buffer), (WARN_STR),
                                 ((_name).buffer)));
                    ((dropPS0540rN)((&(loc))));
                }

                (((function)->dllHandle) = ((dllNotFoundrPS3633)()));
            }

            bool addrFound = (false);
            for (usize i = ((usize)(0llu)); ((i) < (((mod)->dlls).length)); ((i) = ((i) + ((usize)(1llu))))) {
                DLL_s *dll = ((atPS8168uszrPS3633)((&(dlls)), (*((atPS4113uszrPusz)((&((mod)->dlls)), (i))))));
                Handle_s handle = (((GetProcAddress))(((dll)->handle), ((_name).buffer)));
                if (!((isNullS9457rB)((handle)))) {
                    (((function)->dllHandle) = ((newDLLS0540S9457rPS3633)(((dll)->path), (handle))));
                    ((addrFound) = (true));
                    break;
                }
            }

            if ((!(addrFound)) && (((function)->dllHandle) != ((dllNotFoundrPS3633)()))) {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Could not find external function %s in any DLL. You will not be able to call it at compile time.\n"), ((loc).buffer), (WARN_STR),
                                 ((_name).buffer)));
                    ((dropPS0540rN)((&(loc))));
                }

                (((function)->dllHandle) = ((dllNoSuchFunctionrPS3633)()));
            }

            ((dropPS0540rN)((&(_name))));
        }

        else {
        }

        return ((function)->typeState);
    }

    if (signatureOnly) {
        return (((TCState_u){.tag = 1, .payload = {0}}));
    }

    ScopeLookup_s scope = ((ScopeLookup_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((funcLookup)->params).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((addVariablePS1913S6661rN)((&(scope)), (*((atPS3313uszrPS6661)((&((funcLookup)->params)), (i))))));
    }

    ((pushPS5541S1913rN)((scopes), (scope)));
    TCState_u blockState =
        ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), ((function)->body), (scopes), ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))))));
    ((popPS5541rPS1913)((scopes)));
    if ((isErrorPU9661rB)((&(blockState)))) {
        return (blockState);
    }

    return ((function)->typeState);
}
TCState_u typeCheckBlockPS3900PS7247PS5541BrU9661(TypeChecker_s *this, ParsedBlock_s *block, ScopeLookupList_s *scopes, bool nakedFunc) {
    if ((block)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((block)->typeState)))) {
        return ((block)->typeState);
    }

    ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){.variables = ((VariableLookupList_s){0})})));
    usize curr = ((scopes)->length);
    TCState_u blockState = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStmt_s *stmt = ((getStmtAtIndexPS7247uszrPS1100)((block), (i)));
        if (nakedFunc) {
            bool succ_7627_ = true;
            bool succ_7631_ = true;

            StmtData_u *tmp_12015_ = (&((stmt)->data));
            {
                succ_7627_ &= (tmp_12015_->tag == 12);
                succ_7627_ &= true;
                succ_7627_ &= true;
                if (succ_7627_) {
                    {
                    }
                    goto after_12015;
                }
            }
            {
                succ_7631_ &= (tmp_12015_->tag == 4);
                ParsedBlock_s **_block = &tmp_12015_->payload.variant4._0;
                succ_7631_ &= true;
                if (succ_7631_) {
                    {
                        ((blockState) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*_block), (scopes), (nakedFunc))));
                        continue;
                    }
                    goto after_12015;
                }
            }
            {
                if (true) {
                    {
                        ((blockState) = ((reportStatementInNakedFunctionPS3900PS1100rU9661)((this), (stmt))));
                        continue;
                    }
                    goto after_12015;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_12015:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        TCState_u stmtState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
        if ((isErrorPU9661rB)((&(stmtState)))) {
            ((blockState) = (stmtState));
        }
    }

    usize after = ((scopes)->length);
    ((popPS5541rPS1913)((scopes)));
    ((assertBPcrN)(((after) == (curr)), ("Stack imbalance")));
    if ((isErrorPU9661rB)((&(blockState))))
        return (blockState);
    (((*(block)).typeState) = (((TCState_u){.tag = 1, .payload = {0}})));
    return ((block)->typeState);
}
TCState_u typeCheckStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, ScopeLookupList_s *scopes) {
    if ((stmt)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((stmt)->typeState))))
        return ((stmt)->typeState);
    TCState_u state = (((TCState_u){.tag = 1, .payload = {0}}));
    bool succ_7641_ = true;
    bool succ_7644_ = true;
    bool succ_7652_ = true;
    bool succ_7664_ = true;
    bool succ_7676_ = true;
    bool succ_7681_ = true;
    bool succ_7695_ = true;
    bool succ_7710_ = true;
    bool succ_7724_ = true;
    bool succ_7732_ = true;
    bool succ_7740_ = true;
    bool succ_7748_ = true;
    bool succ_7763_ = true;
    bool succ_7766_ = true;
    bool succ_7772_ = true;
    bool succ_7777_ = true;

    StmtData_u *tmp_12243_ = (&((stmt)->data));
    {
        succ_7641_ &= (tmp_12243_->tag == 0);
        succ_7641_ &= true;
        if (succ_7641_) {
            {
                return ((typeCheckVarDeclPS3900PS1100PS5541BrU9661)((this), (stmt), (scopes), (false)));
            }
            goto after_12243;
        }
    }
    {
        succ_7644_ &= (tmp_12243_->tag == 1);
        if (succ_7644_) {
            {
                ((assertBrN)((((this)->currentFunction) != (NULL))));
                TCState_u *retState = (&(((this)->currentFunction)->fnType));
                Type_u *_rt = ((getTypePU9661rPU5175)((retState)));
                Type_u *retType = ((getReturnTypePU5175rPU5175)((_rt)));
                if (!((isNonePU5175rB)((retType)))) {
                    (((printf))(("%s\n"), (((toStringPS8951rS0540)((&((stmt)->span)))).buffer)));
                    (((printf))(("%s\n"), (((toStringPU5175rS0540)((retType))).buffer)));
                    ((todo_with_msgPcrN)(("function returns something, but we wrote return;")));
                }
            }
            goto after_12243;
        }
    }
    {
        succ_7652_ &= (tmp_12243_->tag == 2);
        ParsedExpr_s **expr = &tmp_12243_->payload.variant2._0;
        succ_7652_ &= true;
        if (succ_7652_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                ((assertBrN)((((this)->currentFunction) != (NULL))));
                TCState_u *retState = (&(((this)->currentFunction)->fnType));
                ((assertBPcrN)(((isSuccessPU9661rB)((retState))), ("ready to use function has invalid return type")));
                ((assertBPcrN)(((isTypePU9661rB)((retState))), ("ready to use function has non-type as return type")));
                Type_u *_rt = ((getTypePU9661rPU5175)((retState)));
                Type_u *retType = ((getReturnTypePU5175rPU5175)((_rt)));
                if ((isNonePU5175rB)((retType)))
                    ((todo_with_msgPcrN)(("unexpected ret expr where empty function")));
                if ((wantsInferPU9661rB)((&(exprState)))) {
                    ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*expr), (retType), (scopes))));
                    if ((isErrorPU9661rB)((&(exprState))))
                        return (exprState);
                    ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("Failed to infer type of return expression")));
                }

                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (!((equalsPU5175PU5175rB)((exprType), (retType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((stmt)->span), (retType), (exprType)));
                }

                ((state) = (*(retState)));
            }
            goto after_12243;
        }
    }
    {
        succ_7664_ &= (tmp_12243_->tag == 3);
        ParsedExpr_s **expr = &tmp_12243_->payload.variant3._0;
        succ_7664_ &= true;
        if (succ_7664_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState)))) {
                    Type_u *noneType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}})));
                    ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*expr), (noneType), (scopes))));
                }

                if (!((isTypePU9661rB)((&(exprState))))) {
                    (((printf))(("%s\n"), (((toStringPS8951rS0540)((&((stmt)->span)))).buffer)));
                    (((printf))(("%llu\n"), ((tagAnyru8)((&(exprState))))));
                    ((todo_with_msgPcrN)(("what is it then")));
                }

                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (((!((isNonePU5175rB)((exprType)))) && (!((isAssignmentPS2435rB)((*expr))))) && (*((flags).warnUnused))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Unused expression value.\n"), ((loc).buffer), (WARN_STR)));
                    ((dropPS0540rN)((&(loc))));
                }

                ((state) = (exprState));
            }
            goto after_12243;
        }
    }
    {
        succ_7676_ &= (tmp_12243_->tag == 4);
        ParsedBlock_s **block = &tmp_12243_->payload.variant4._0;
        succ_7676_ &= true;
        if (succ_7676_) {
            {
                ((state) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false))));
            }
            goto after_12243;
        }
    }
    {
        succ_7681_ &= (tmp_12243_->tag == 5);
        ParsedExpr_s **cond = &tmp_12243_->payload.variant5._0;
        succ_7681_ &= true;
        ParsedStmt_s **then = &tmp_12243_->payload.variant5._1;
        succ_7681_ &= true;
        if (succ_7681_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u thenState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*then), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(thenState))))
                    return (thenState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto if-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12243;
        }
    }
    {
        succ_7695_ &= (tmp_12243_->tag == 6);
        ParsedExpr_s **cond = &tmp_12243_->payload.variant6._0;
        succ_7695_ &= true;
        ParsedStmt_s **then = &tmp_12243_->payload.variant6._1;
        succ_7695_ &= true;
        ParsedStmt_s **elze = &tmp_12243_->payload.variant6._2;
        succ_7695_ &= true;
        if (succ_7695_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u thenState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*then), (scopes)));
                TCState_u elseState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*elze), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(thenState))))
                    return (thenState);
                if ((isErrorPU9661rB)((&(elseState))))
                    return (elseState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto if-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12243;
        }
    }
    {
        succ_7710_ &= (tmp_12243_->tag == 7);
        ParsedExpr_s **cond = &tmp_12243_->payload.variant7._0;
        succ_7710_ &= true;
        ParsedStmt_s **body = &tmp_12243_->payload.variant7._1;
        succ_7710_ &= true;
        if (succ_7710_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u bodyState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*body), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(bodyState))))
                    return (bodyState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto while-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12243;
        }
    }
    {
        succ_7724_ &= (tmp_12243_->tag == 13);
        ParsedPattern_s **pat = &tmp_12243_->payload.variant13._0;
        succ_7724_ &= true;
        ParsedExpr_s **expr = &tmp_12243_->payload.variant13._1;
        succ_7724_ &= true;
        ParsedBlock_s **block = &tmp_12243_->payload.variant13._2;
        succ_7724_ &= true;
        if (succ_7724_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
            }
            goto after_12243;
        }
    }
    {
        succ_7732_ &= (tmp_12243_->tag == 14);
        ParsedPattern_s **pat = &tmp_12243_->payload.variant14._0;
        succ_7732_ &= true;
        ParsedExpr_s **expr = &tmp_12243_->payload.variant14._1;
        succ_7732_ &= true;
        ParsedBlock_s **block = &tmp_12243_->payload.variant14._2;
        succ_7732_ &= true;
        ParsedBlock_s **elze = &tmp_12243_->payload.variant14._3;
        succ_7732_ &= true;
        if (succ_7732_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
                TCState_u elseState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*elze), (scopes), (false)));
                if ((isErrorPU9661rB)((&(elseState))))
                    return (elseState);
            }
            goto after_12243;
        }
    }
    {
        succ_7740_ &= (tmp_12243_->tag == 15);
        ParsedPattern_s **pat = &tmp_12243_->payload.variant15._0;
        succ_7740_ &= true;
        ParsedExpr_s **expr = &tmp_12243_->payload.variant15._1;
        succ_7740_ &= true;
        ParsedBlock_s **block = &tmp_12243_->payload.variant15._2;
        succ_7740_ &= true;
        if (succ_7740_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
            }
            goto after_12243;
        }
    }
    {
        succ_7748_ &= (tmp_12243_->tag == 8);
        ParsedStmt_s **init = &tmp_12243_->payload.variant8._0;
        succ_7748_ &= true;
        ParsedExpr_s **cond = &tmp_12243_->payload.variant8._1;
        succ_7748_ &= true;
        ParsedExpr_s **step = &tmp_12243_->payload.variant8._2;
        succ_7748_ &= true;
        ParsedStmt_s **body = &tmp_12243_->payload.variant8._3;
        succ_7748_ &= true;
        if (succ_7748_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                TCState_u initState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*init), (scopes)));
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u stepState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*step), (scopes)));
                TCState_u bodyState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*body), (scopes)));
                ((popPS5541rPS1913)((scopes)));
                if ((isErrorPU9661rB)((&(initState))))
                    return (initState);
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(stepState))))
                    return (stepState);
                if ((isErrorPU9661rB)((&(bodyState))))
                    return (bodyState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto for-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12243;
        }
    }
    {
        succ_7763_ &= (tmp_12243_->tag == 9);
        if (succ_7763_) {
            {
            }
            goto after_12243;
        }
    }
    {
        succ_7766_ &= (tmp_12243_->tag == 10);
        if (succ_7766_) {
            {
            }
            goto after_12243;
        }
    }
    {
        succ_7772_ &= (tmp_12243_->tag == 11);
        succ_7772_ &= true;
        succ_7772_ &= true;
        succ_7772_ &= true;
        if (succ_7772_) {
            {
                return ((typeCheckMatchStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
            }
            goto after_12243;
        }
    }
    {
        succ_7777_ &= (tmp_12243_->tag == 12);
        ParsedExpr_s **fn = &tmp_12243_->payload.variant12._0;
        succ_7777_ &= true;
        ParsedExprList_s *args = &tmp_12243_->payload.variant12._1;
        succ_7777_ &= true;
        if (succ_7777_) {
            {
                if (*((flags).disableInlineAssembly)) {
                    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Cannot use inline assembly.\n"), ((loc).buffer), (ERR_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Flag `--no-inline-assembly` was provided.\n"), ((loc).buffer), (NOTE_STR)));
                }

                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*fn), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                SubStr_s ASM_CONTEXT = ((BUILD_A_KEYWORDPcrS7720)(("ASMContext")));
                SubStr_s ASM_FILE = ((BUILD_A_KEYWORDPcrS7720)(("asm.bufo")));
                StructLookup_s *context = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)((&((this)->lookup)), (&(ASM_FILE)), (&(ASM_CONTEXT))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckStmt: Could not find struct context for ASMContext")));
                bool succ_7789_ = true;

                Type_u *tmp_12238_ = (exprType);
                {
                    succ_7789_ &= (tmp_12238_->tag == 6);
                    TypeList_s *params = &tmp_12238_->payload.variant6._0;
                    succ_7789_ &= true;
                    Type_u **ret = &tmp_12238_->payload.variant6._1;
                    succ_7789_ &= true;
                    succ_7789_ &= true;
                    if (succ_7789_) {
                        {
                            if (!((equalsPU5175PU5175rB)((*ret), ((context)->type)))) {
                                return ((reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661)((this), (stmt), (*ret), ((context)->type)));
                            }

                            if (((*args).length) != ((*params).length)) {
                                return ((reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661)((this), (stmt), ((*args).length), ((*params).length)));
                            }

                            for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&(*args)), (i))));
                                Type_u *par = (*((atPS0643uszrPPU5175)((&(*params)), (i))));
                                TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (arg), (scopes)));
                                if ((isErrorPU9661rB)((&(argState))))
                                    return (argState);
                                if ((wantsInferPU9661rB)((&(argState)))) {
                                    ((todo_with_msgPcrN)(("infer type onto asm arg")));
                                }

                                ((assertBPcrN)(((isTypePU9661rB)((&(argState)))), ("Expected asm-arg to be valid by now")));
                            }
                        }
                        goto after_12238;
                    }
                }
                {
                    Type_u **type = &tmp_12238_;
                    if (true) {
                        {
                            return ((reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661)((this), (stmt), (*type), ((context)->type)));
                        }
                        goto after_12238;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12238:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12243;
        }
    }
    {
        StmtData_u **unknown = &tmp_12243_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckStmt: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_12243;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12243:
    (void)0; // error: label at end of compound statement is a C23 extension
    if ((isErrorPU9661rB)((&(state))))
        return (state);
    (((stmt)->typeState) = (state));
    return (state);
}
TCState_u typeCheckMatchStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *match, ScopeLookupList_s *scopes) {
    ParsedExpr_s *expr = (NULL);
    ParsedPatternList_s *patterns = (NULL);
    ParsedStmtList_s *stmts = (NULL);
    bool succ_7808_ = true;

    StmtData_u *tmp_12257_ = (&((match)->data));
    {
        succ_7808_ &= (tmp_12257_->tag == 11);
        ParsedExpr_s **_expr = &tmp_12257_->payload.variant11._0;
        succ_7808_ &= true;
        ParsedPatternList_s *_patterns = &tmp_12257_->payload.variant11._1;
        succ_7808_ &= true;
        ParsedStmtList_s *_stmts = &tmp_12257_->payload.variant11._2;
        succ_7808_ &= true;
        if (succ_7808_) {
            {
                ((expr) = (*_expr));
                ((patterns) = (&(*_patterns)));
                ((stmts) = (&(*_stmts)));
            }
            goto after_12257;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_12257;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12257:
    (void)0; // error: label at end of compound statement is a C23 extension
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (expr), (scopes)));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    if ((wantsInferPU9661rB)((&(exprState))))
        ((todo_with_msgPcrN)(("match expr wants infer")));
    Type_u *type = ((getTypePU9661rPU5175)((&(exprState))));
    ((assertBrN)((((patterns)->length) == ((stmts)->length))));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    bool complete = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((patterns)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ScopeLookup_s scope = ((ScopeLookup_s){0});
        ParsedPattern_s *pat = (*((atPS1982uszrPPS1826)((patterns), (i))));
        TCState_u patState = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (type), (pat), (scopes), (&(scope))));
        if ((isErrorPU9661rB)((&(patState)))) {
            ((result) = (patState));
            continue;
        }

        ((assertBrN)(((isPatternPU9661rB)((&(patState))))));
        PatState_s _patState = ((getPatStatePU9661rS1259)((&(patState))));
        ((pushPS5541S1913rN)((scopes), (scope)));
        ParsedStmt_s *stmt = (*((atPS3288uszrPPS1100)((stmts), (i))));
        TCState_u stmtState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
        ((popPS5541rPS1913)((scopes)));
        ((complete) = ((_patState).complete));
        if ((complete) && ((i) != (((patterns)->length) - ((usize)(1llu))))) {
            ParsedPattern_s *next = (*((atPS1982uszrPPS1826)((patterns), ((i) + ((usize)(1llu))))));
            String_s loc = ((toStringPS8951rS0540)((&((next)->span))));
            (((fprintf))((stderr_), ("%s: %s: Unreachable pattern.\n"), ((loc).buffer), (WARN_STR)));
            ((dropPS0540rN)((&(loc))));
            (((patterns)->length) = ((i) + ((usize)(1llu))));
            (((stmts)->length) = ((i) + ((usize)(1llu))));
        }
    }

    if ((isErrorPU9661rB)((&(result))))
        return (result);
    if (!(complete)) {
        String_s loc = ((toStringPS8951rS0540)((&((match)->span))));
        (((fprintf))((stderr_), ("%s: %s: Patterns of a match statement must be exhaustive.\n"), ((loc).buffer), (ERR_STR)));
        char *wildcard = ((tokenKindToStringuszrPc)((TOKEN_WILDCARD)));
        (((fprintf))((stderr_), ("%s: %s: You can use the wildcard pattern %s to catch all other cases.\n"), ((loc).buffer), (NOTE_STR), (wildcard)));
        ((dropPS0540rN)((&(loc))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NON_EXHAUSTIVE_MATCH)}}});
    }

    (((match)->typeState) = ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}}));
    return (result);
}
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope) {
    return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (type), (pat), (scopes), (scope), (false)));
}
TCState_u _anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, Token_s ident, ScopeLookupList_s *scopes, ScopeLookup_s *scope,
                                                               bool globalScope) {
    Token_s loc = ((Token_s){0});
    if (globalScope) {
        usize index = ((usize)(0llu));
        ((assertBPcrN)(((getVarIndexByNamePS1913S7720PuszrB)((scope), ((ident).content), (&(index)))), ("Could not find variable in global scope")));
        VariableLookup_s *var = ((getVariableAtIndexPS1913uszrPS6661)((scope), (index)));
        (((var)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if ((isKnownVariablePS1913S7720PS6070rB)((scope), ((ident).content), (&(loc)))) {
        return ((reportVariableRedeclarationPS3900S6070S6070rU9661)((this), (ident), (loc)));
    }

    else {
        if (*((flags).warnSimple)) {
            for (usize i = ((usize)(0llu)); ((i) < (((scopes)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
                ScopeLookup_s *s = ((atPS5541uszrPS1913)((scopes), (i)));
                Token_s _loc = ((Token_s){0});
                if ((isKnownVariablePS1913S7720PS6070rB)((s), ((ident).content), (&(_loc)))) {
                    String_s loc1 = ((toStringPS8951rS0540)((&((ident).span))));
                    String_s loc2 = ((toStringPS8951rS0540)((&((_loc).span))));
                    String_s name1 = ((toStringPS7720rS0540)((&((ident).content))));
                    (((fprintf))((stderr_), ("%s: %s: Shadowing variable `%s` from an outer scope.\n"), ((loc1).buffer), (WARN_STR), ((name1).buffer)));
                    (((fprintf))((stderr_), ("%s: %s: Variable with the same name already declared here.\n"), ((loc2).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(name1))));
                    ((dropPS0540rN)((&(loc2))));
                    ((dropPS0540rN)((&(loc1))));
                }
            }
        }

        ((addVariablePS1913S6661rN)((scope), ((VariableLookup_s){.globalID = ((getIDPS1826rusz)((pat))),
                                                                 .name = (ident),
                                                                 .typeState = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}),
                                                                 .isComptime = (((this)->comptimeDepth) > ((usize)(0llu)))})));
    }

    return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
}
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope, bool globalScope) {
    TCState_u (*check_ident)(TypeChecker_s *, Type_u *, ParsedPattern_s *, Token_s, ScopeLookupList_s *, ScopeLookup_s *, bool) = (_anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661);
    bool succ_7846_ = true;
    bool succ_7854_ = true;
    bool succ_7858_ = true;
    bool succ_7867_ = true;
    bool succ_7870_ = true;
    bool succ_7875_ = true;
    bool succ_7928_ = true;
    bool succ_7947_ = true;
    bool succ_7950_ = true;
    bool succ_7953_ = true;
    bool succ_7957_ = true;

    Pattern_u *tmp_12524_ = (&((pat)->data));
    {
        succ_7846_ &= (tmp_12524_->tag == 3);
        ParsedPattern_s **subpat = &tmp_12524_->payload.variant3._0;
        succ_7846_ &= true;
        ParsedTypeNode_s **typeNode = &tmp_12524_->payload.variant3._1;
        succ_7846_ &= true;
        if (succ_7846_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*typeNode)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                Type_u *typ = ((getTypePU9661rPU5175)((&(typeState))));
                TCState_u err = (((TCState_u){.tag = 0, .payload = {0}}));
                if (!((equalsPU5175PU5175rB)((typ), (type)))) {
                    ((err) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((pat)->span), (typ), (type))));
                }

                TCState_u res = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (typ), (*subpat), (scopes), (scope), (globalScope)));
                if ((isErrorPU9661rB)((&(err))))
                    return (err);
                return (res);
            }
            goto after_12524;
        }
    }
    {
        succ_7854_ &= (tmp_12524_->tag == 2);
        Token_s *ident = &tmp_12524_->payload.variant2._0;
        succ_7854_ &= true;
        if (succ_7854_) {
            {
                return ((check_ident)((this), (type), (pat), (*ident), (scopes), (scope), (globalScope)));
            }
            goto after_12524;
        }
    }
    {
        succ_7858_ &= (tmp_12524_->tag == 4);
        ParsedPattern_s **sub = &tmp_12524_->payload.variant4._0;
        succ_7858_ &= true;
        if (succ_7858_) {
            {
                bool succ_7862_ = true;

                Type_u *tmp_12355_ = (type);
                {
                    succ_7862_ &= (tmp_12355_->tag == 4);
                    Type_u **under = &tmp_12355_->payload.variant4._0;
                    succ_7862_ &= true;
                    if (succ_7862_) {
                        {
                            return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (*under), (*sub), (scopes), (scope)));
                        }
                        goto after_12355;
                    }
                }
                {
                    if (true) {
                        {
                            return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                        }
                        goto after_12355;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12355:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12524;
        }
    }
    {
        succ_7867_ &= (tmp_12524_->tag == 9);
        succ_7867_ &= true;
        if (succ_7867_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12524;
        }
    }
    {
        succ_7870_ &= (tmp_12524_->tag == 10);
        if (succ_7870_) {
            {
                if (!((isPointerPU5175rB)((type)))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12524;
        }
    }
    {
        succ_7875_ &= (tmp_12524_->tag == 6);
        Token_s *name = &tmp_12524_->payload.variant6._0;
        succ_7875_ &= true;
        ParsedPattern_s **subPat = &tmp_12524_->payload.variant6._1;
        succ_7875_ &= true;
        if (succ_7875_) {
            {
                Token_s ident = ((Token_s){0});
                bool succ_7881_ = true;
                bool succ_7886_ = true;

                Pattern_u *tmp_12374_ = (&((*subPat)->data));
                {
                    succ_7881_ &= (tmp_12374_->tag == 2);
                    Token_s *_ident = &tmp_12374_->payload.variant2._0;
                    succ_7881_ &= true;
                    if (succ_7881_) {
                        {
                            ((ident) = (*_ident));
                        }
                        goto after_12374;
                    }
                }
                {
                    succ_7886_ &= (tmp_12374_->tag == 5);
                    Token_s *_ident = &tmp_12374_->payload.variant5._0;
                    succ_7886_ &= true;
                    succ_7886_ &= true;
                    if (succ_7886_) {
                        {
                            ((ident) = (*_ident));
                        }
                        goto after_12374;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Path Pattern expected Ident or Struct as RHS")));
                        }
                        goto after_12374;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12374:
                (void)0; // error: label at end of compound statement is a C23 extension
                bool succ_7892_ = true;

                Type_u *tmp_12438_ = (type);
                {
                    succ_7892_ &= (tmp_12438_->tag == 8);
                    ParsedUnionDecl_s **decl = &tmp_12438_->payload.variant8._0;
                    succ_7892_ &= true;
                    succ_7892_ &= true;
                    if (succ_7892_) {
                        {
                            if (!((equalsPS7720PS7720rB)((&((*name).content)), (&(((*decl)->name).content))))) {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            ParsedUnionVariant_s *variant = (NULL);
                            if (!((resolveVariantByNamePS0997PS6070PPS3506rB)((*decl), (&(ident)), (&(variant))))) {
                                return ((reportInvalidVariantPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            bool succ_7898_ = true;
                            bool succ_7905_ = true;

                            Pattern_u *tmp_12428_ = (&((*subPat)->data));
                            {
                                succ_7898_ &= (tmp_12428_->tag == 2);
                                Token_s *ident = &tmp_12428_->payload.variant2._0;
                                succ_7898_ &= true;
                                if (succ_7898_) {
                                    {
                                        bool succ_7901_ = true;

                                        ParsedUnionVariantData_u tmp_12383_ = ((variant)->data);
                                        succ_7901_ &= (tmp_12383_.tag == 0);
                                        if (!succ_7901_) {
                                            return ((reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661)((this), (pat), (type), ((variant)->data),
                                                                                                             (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}}))));
                                        };
                                    }
                                    goto after_12428;
                                }
                            }
                            {
                                succ_7905_ &= (tmp_12428_->tag == 5);
                                Token_s *ident = &tmp_12428_->payload.variant5._0;
                                succ_7905_ &= true;
                                ParsedPatternList_s *subPatterns = &tmp_12428_->payload.variant5._1;
                                succ_7905_ &= true;
                                if (succ_7905_) {
                                    {
                                        bool succ_7908_ = true;

                                        {
                                            ParsedUnionVariantData_u tmp_12386_ = ((variant)->data);
                                            succ_7908_ &= (tmp_12386_.tag == 0);

                                            if (succ_7908_) {
                                                return ((reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661)((this), (pat), (type), (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}})),
                                                                                                                 ((variant)->data)));
                                            }
                                        }

                                        bool succ_7911_ = true;
                                        bool succ_7909_ = true;

                                        tuple_1017 tmp_12388_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
                                        succ_7909_ = tmp_12388_._0 == true;
                                        succ_7911_ &= succ_7909_;
                                        ParsedTypeNodeList_s **fields = &tmp_12388_._1;
                                        succ_7911_ &= true;
                                        if (!succ_7911_) {
                                            ((unreachablePcrN)(("Pattern::Struct got no variant fields")));
                                        };
                                        if (((*subPatterns).length) > ((*fields)->length)) {
                                            if (((*subPatterns).length) == (((*fields)->length) + ((usize)(1llu)))) {
                                                ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                                Pattern_u tmp_61701 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                                if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61701))))) {
                                                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                                }

                                            }

                                            else {
                                                return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                            }
                                        }

                                        if (((*subPatterns).length) < ((*fields)->length)) {
                                            if (((*subPatterns).length) > ((usize)(0llu))) {
                                                ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                                Pattern_u tmp_61747 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                                if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61747))))) {
                                                    return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                                }

                                            }

                                            else {
                                                return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                            }
                                        }

                                        bool complete = (true);
                                        for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                                            ParsedPattern_s *subSubPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
                                            ParsedTypeNode_s *field = ((((*fields)->elements))[(i)]);
                                            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("checkAndBindPattern: Invalid field type")));
                                            Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                                            TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (fieldType), (subSubPat), (scopes), (scope)));
                                            if ((isErrorPU9661rB)((&(subComplete))))
                                                return (subComplete);
                                            if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                                                ((complete) = (false));
                                            }

                                            Pattern_u tmp_61831 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                            if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_61831)))))
                                                break;
                                        }
                                    }
                                    goto after_12428;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablePcrN)(("Expected Ident Pattern or Struct Pattern as RHS of Path Pattern")));
                                    }
                                    goto after_12428;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_12428:
                            (void)0; // error: label at end of compound statement is a C23 extension
                            return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
                        }
                        goto after_12438;
                    }
                }
                {
                    Type_u **type = &tmp_12438_;
                    if (true) {
                        {
                            ModuleLookup_s *moduleLookup = (NULL);
                            if ((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (&(*name)), (&(moduleLookup)))) {
                                return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (*type), (*subPat), (scopes), (scope)));
                            }

                            else {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (*type)));
                            }
                        }
                        goto after_12438;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12438:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12524;
        }
    }
    {
        succ_7928_ &= (tmp_12524_->tag == 5);
        Token_s *name = &tmp_12524_->payload.variant5._0;
        succ_7928_ &= true;
        ParsedPatternList_s *subPatterns = &tmp_12524_->payload.variant5._1;
        succ_7928_ &= true;
        if (succ_7928_) {
            {
                bool succ_7932_ = true;

                Type_u *tmp_12484_ = (type);
                {
                    succ_7932_ &= (tmp_12484_->tag == 7);
                    ParsedStructDecl_s **decl = &tmp_12484_->payload.variant7._0;
                    succ_7932_ &= true;
                    if (succ_7932_) {
                        {
                            StructLookup_s *lookup = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), ((getIDPS5521rusz)((*decl)))));
                            if (!((equalsPS7720PS7720rB)((&((*name).content)), (&(((lookup)->name).content))))) {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            if (((*subPatterns).length) > (((lookup)->fields).length)) {
                                if (((*subPatterns).length) == ((((lookup)->fields).length) + ((usize)(1llu)))) {
                                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                    Pattern_u tmp_61934 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61934))))) {
                                        return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                    }

                                }

                                else {
                                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                }
                            }

                            if (((*subPatterns).length) < (((lookup)->fields).length)) {
                                if (((*subPatterns).length) > ((usize)(0llu))) {
                                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                    Pattern_u tmp_61982 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61982))))) {
                                        return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                    }

                                }

                                else {
                                    return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                }
                            }

                            bool complete = (true);
                            for (usize i = ((usize)(0llu)); ((i) < (((lookup)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                ParsedPattern_s *subpat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
                                VariableLookup_s *field = ((atPS3313uszrPS6661)((&((lookup)->fields)), (i)));
                                ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("checkAndBindPattern: Invalid field type")));
                                Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                                TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (fieldType), (subpat), (scopes), (scope)));
                                if ((isErrorPU9661rB)((&(subComplete))))
                                    return (subComplete);
                                if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                                    ((complete) = (false));
                                }

                                Pattern_u tmp_62070 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_62070)))))
                                    break;
                            }

                            return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (complete)})}}});
                        }
                        goto after_12484;
                    }
                }
                {
                    if (true) {
                        {
                            return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                        }
                        goto after_12484;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12484:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12524;
        }
    }
    {
        succ_7947_ &= (tmp_12524_->tag == 1);
        succ_7947_ &= true;
        if (succ_7947_) {
            {
                if ((!((isIntegerPU5175rB)((type)))) && (!((isFloatPU5175rB)((type))))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12524;
        }
    }
    {
        succ_7950_ &= (tmp_12524_->tag == 0);
        if (succ_7950_) {
            {
                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
            }
            goto after_12524;
        }
    }
    {
        succ_7953_ &= (tmp_12524_->tag == 8);
        if (succ_7953_) {
            {
                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
            }
            goto after_12524;
        }
    }
    {
        succ_7957_ &= (tmp_12524_->tag == 7);
        ParsedPatternList_s *patElems = &tmp_12524_->payload.variant7._0;
        succ_7957_ &= true;
        if (succ_7957_) {
            {
                bool succ_7961_ = true;

                Type_u *tmp_12496_ = (type);
                succ_7961_ &= (tmp_12496_->tag == 10);
                TypeList_s *typElems = &tmp_12496_->payload.variant10._0;
                succ_7961_ &= true;
                if (!succ_7961_) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                };
                if (((*patElems).length) < ((*typElems).length)) {
                    ((assertBPcrN)((((*patElems).length) > ((usize)(0llu))), ("Pattern::Tuple is empty?")));
                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*patElems)), (((*patElems).length) - ((usize)(1llu))))));
                    Pattern_u tmp_62158 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_62158))))) {
                        return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                    }

                }

                else if (((*patElems).length) > ((*typElems).length)) {
                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                bool complete = (true);
                for (usize i = ((usize)(0llu)); ((i) < ((*typElems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subpat = ((((*patElems).elements))[(i)]);
                    Type_u *elemType = ((((*typElems).elements))[(i)]);
                    TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (elemType), (subpat), (scopes), (scope)));
                    if ((isErrorPU9661rB)((&(subComplete))))
                        return (subComplete);
                    if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                        ((complete) = (false));
                    }

                    Pattern_u tmp_62233 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_62233)))))
                        break;
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (complete)})}}});
            }
            goto after_12524;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12524;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12524:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of patterns in checkAndBindPattern")));
}
TCState_u typeCheckVarDeclPS3900uszPS5541BrU9661(TypeChecker_s *this, usize varDeclID, ScopeLookupList_s *scopes, bool globalScope) {
    return ((typeCheckVarDeclPS3900PS1100PS5541BrU9661)((this), ((atPS8227uszrPS1100)((&(stmts)), (varDeclID))), (scopes), (globalScope)));
}
TCState_u handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661(TypeChecker_s *this, Span_s span, ParsedPattern_s *pat, ParsedExpr_s *expr, ScopeLookupList_s *scopes, bool globalScope) {
    TCState_u declState = (((TCState_u){.tag = 1, .payload = {0}}));
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (expr), (scopes)));
    if ((isErrorPU9661rB)((&(exprState)))) {
        ((declState) = (exprState));
        ((exprState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)((((Type_u){.tag = 0, .payload = {0}}))))}}}));
    }

    if ((wantsInferPU9661rB)((&(exprState)))) {
        ((exprState) = ((inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661)((this), (expr), (pat), (scopes))));
        if ((isErrorPU9661rB)((&(exprState)))) {
            ((declState) = (exprState));
            ((exprState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)((((Type_u){.tag = 0, .payload = {0}}))))}}}));
        }

        if ((wantsInferPU9661rB)((&(exprState)))) {
            return ((reportCouldNotInferTypePS3900S8951rU9661)((this), (span)));
        }

        ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("typeCheckVarDecl: infer failed")));
    }

    Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
    ScopeLookup_s *last = ((lastPS5541rPS1913)((scopes)));
    TCState_u state = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (exprType), (pat), (scopes), (last), (globalScope)));
    if ((isErrorPU9661rB)((&(declState))))
        return (declState);
    return (state);
}
TCState_u typeCheckVarDeclPS3900PS1100PS5541BrU9661(TypeChecker_s *this, ParsedStmt_s *varDecl, ScopeLookupList_s *scopes, bool globalScope) {
    if ((varDecl)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    bool succ_7984_ = true;
    bool succ_7982_ = true;

    StmtData_u *tmp_12578_ = (&((varDecl)->data));
    {
        succ_7984_ &= (tmp_12578_->tag == 0);
        ParsedPattern_s **pat = &tmp_12578_->payload.variant0._0.pat;
        succ_7982_ &= true;
        ParsedExpr_s **expr = &tmp_12578_->payload.variant0._0.expr;
        succ_7982_ &= true;
        ParsedBlock_s **trampoline = &tmp_12578_->payload.variant0._0.trampoline;
        succ_7982_ &= true;
        bool *isComptime = &tmp_12578_->payload.variant0._0.isComptime;
        succ_7982_ &= true;
        succ_7982_ &= true;
        succ_7984_ &= succ_7982_;
        if (succ_7984_) {
            {
                if (*isComptime)
                    ((enterComptimePS3900rN)((this)));
                ScopeLookup_s *last = ((lastPS5541rPS1913)((scopes)));
                usize hack1 = (((last)->variables).length);
                TCState_u state = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((varDecl)->span), (*pat), (*expr), (scopes), (globalScope)));
                usize hack2 = (((last)->variables).length);
                if (*isComptime)
                    ((leaveComptimePS3900rN)((this)));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                PatState_s _patState = ((getPatStatePU9661rS1259)((&(state))));
                if ((*trampoline) != (NULL)) {
                    ((((last)->variables).length) = (hack1));
                    ((state) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*trampoline), (scopes), (false))));
                    ((((last)->variables).length) = (hack2));
                    if ((_patState).complete) {
                        ((reportUnnecessaryTrampolinePS3900S8951rN)((this), ((*trampoline)->span)));
                    }

                }

                else if (!((_patState).complete)) {
                    return ((reportMissingTrampolinePS3900S8951rU9661)((this), ((varDecl)->span)));
                }

                (((varDecl)->typeState) = (state));
                return (state);
            }
            goto after_12578;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12578;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12578:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("typeCheckVarDecl: Expected VarDecl")));
}
TCState_u typeCheckExprPS3900uszPS5541rU9661(TypeChecker_s *this, usize exprID, ScopeLookupList_s *scopes) {
    return ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (scopes)));
}
TCState_u typeCheckExprPS3900PS2435PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ScopeLookupList_s *scopes) {
    if ((expr)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((expr)->typeState))))
        return ((expr)->typeState);
    TCState_u state = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_7996_ = true;
    bool succ_8000_ = true;
    bool succ_8006_ = true;
    bool succ_8011_ = true;
    bool succ_8036_ = true;
    bool succ_8040_ = true;
    bool succ_8044_ = true;
    bool succ_8048_ = true;
    bool succ_8052_ = true;
    bool succ_8058_ = true;
    bool succ_8063_ = true;
    bool succ_8066_ = true;
    bool succ_8069_ = true;
    bool succ_8072_ = true;
    bool succ_8075_ = true;
    bool succ_8079_ = true;
    bool succ_8087_ = true;
    bool succ_8096_ = true;
    bool succ_8105_ = true;

    ExprData_u *tmp_12713_ = (&((expr)->data));
    {
        succ_7996_ &= (tmp_12713_->tag == 0);
        succ_7996_ &= true;
        if (succ_7996_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12713;
        }
    }
    {
        succ_8000_ &= (tmp_12713_->tag == 1);
        succ_8000_ &= true;
        if (succ_8000_) {
            {
                Type_u *ct = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})));
                Type_u *st = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (ct)}}})));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (st)}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8006_ &= (tmp_12713_->tag == 2);
        succ_8006_ &= true;
        if (succ_8006_) {
            {
                Type_u *ct = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (ct)}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8011_ &= (tmp_12713_->tag == 3);
        ArrayContext_s *context = &tmp_12713_->payload.variant3._0;
        succ_8011_ &= true;
        if (succ_8011_) {
            {
                if (((*context).elemLength) == ((usize)(0llu)))
                    return (((TCState_u){.tag = 4, .payload = {0}}));
                usize elemIndex = ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu))));
                TCState_u elemState = ((typeCheckExprPS3900uszPS5541rU9661)((this), (elemIndex), (scopes)));
                if ((isErrorPU9661rB)((&(elemState))))
                    return (elemState);
                if ((wantsInferPU9661rB)((&(elemState))))
                    return (elemState);
                Type_u *elemType = ((getTypePU9661rPU5175)((&(elemState))));
                if (((*context).size) == ((usize)(0llu))) {
                    TCState_u lastErrState = (((TCState_u){.tag = 0, .payload = {0}}));
                    for (usize i = ((usize)(1llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        usize nextIndex = ((getElementAtIndexPS8905uszrusz)((&(*context)), (i)));
                        TCState_u nextState = ((typeCheckExprPS3900uszPS5541rU9661)((this), (nextIndex), (scopes)));
                        if ((isErrorPU9661rB)((&(nextState)))) {
                            ((lastErrState) = (nextState));
                            continue;
                        }

                        Type_u *nextType = ((getTypePU9661rPU5175)((&(nextState))));
                        if (!((equalsPU5175PU5175rB)((nextType), (elemType)))) {
                            Span_s tmp_62611 = (((atPS7882uszrPS2435)((&(exprs)), (elemIndex)))->span);

                            String_s loc = ((toStringPS8951rS0540)((&tmp_62611)));
                            String_s t = ((toStringPU5175rS0540)((elemType)));
                            ((lastErrState) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), (((atPS7882uszrPS2435)((&(exprs)), (nextIndex)))->span), (elemType), (nextType))));
                            (((fprintf))((stderr_), ("%s: %s: Array elements inferred to be type %s here.\n"), ((loc).buffer), (NOTE_STR), ((t).buffer)));
                            ((dropPS0540rN)((&(t))));
                            ((dropPS0540rN)((&(loc))));
                        }
                    }

                    if (!((isInvalidPU9661rB)((&(lastErrState)))))
                        return (lastErrState);
                    Type_u *t = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (elemType), ._1 = ((*context).elemLength)}}})));
                    ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                }

                else {
                    Type_u *t = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (elemType), ._1 = ((*context).size)}}})));
                    ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                }
            }
            goto after_12713;
        }
    }
    {
        succ_8036_ &= (tmp_12713_->tag == 4);
        IdentExpr_s *ident = &tmp_12713_->payload.variant4._0;
        succ_8036_ &= true;
        if (succ_8036_) {
            {
                ((state) = ((typeCheckIdentifierPS3900PS7464PS5541rU9661)((this), (&(*ident)), (scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8040_ &= (tmp_12713_->tag == 5);
        UnaryExpr_u *unary = &tmp_12713_->payload.variant5._0;
        succ_8040_ &= true;
        if (succ_8040_) {
            {
                ((state) = ((typeCheckExprUnaryPS3900PU5427PS5541rU9661)((this), (&(*unary)), (scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8044_ &= (tmp_12713_->tag == 6);
        BinaryExpr_u *binary = &tmp_12713_->payload.variant6._0;
        succ_8044_ &= true;
        if (succ_8044_) {
            {
                ((state) = ((typeCheckExprBinaryPS3900PU0121PS5541rU9661)((this), (&(*binary)), (scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8048_ &= (tmp_12713_->tag == 7);
        CallExpr_s *call = &tmp_12713_->payload.variant7._0;
        succ_8048_ &= true;
        if (succ_8048_) {
            {
                ((state) = ((typeCheckExprCallPS3900PS3328PS5541rU9661)((this), (&(*call)), (scopes))));
                if ((*call).isUnion) {
                    (((expr)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = ((UnionExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (*call)}}})}}}));
                }
            }
            goto after_12713;
        }
    }
    {
        succ_8052_ &= (tmp_12713_->tag == 8);
        ParsedTypeNode_s **type = &tmp_12713_->payload.variant8._0;
        succ_8052_ &= true;
        if (succ_8052_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*type)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8058_ &= (tmp_12713_->tag == 9);
        StructExpr_s *init = &tmp_12713_->payload.variant9._0;
        succ_8058_ &= true;
        if (succ_8058_) {
            {
                ((state) = ((typeCheckExprStructInitPS3900PS4761PS5541rU9661)((this), (&(*init)), (scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8063_ &= (tmp_12713_->tag == 11);
        ParsedExpr_s **curr = &tmp_12713_->payload.variant11._0;
        succ_8063_ &= true;
        ParsedTypeNode_s **type = &tmp_12713_->payload.variant11._1;
        succ_8063_ &= true;
        if (succ_8063_) {
            {
                ((state) = ((typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661)((this), (expr), (*curr), (*type), (scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8066_ &= (tmp_12713_->tag == 12);
        if (succ_8066_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12713;
        }
    }
    {
        succ_8069_ &= (tmp_12713_->tag == 13);
        if (succ_8069_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12713;
        }
    }
    {
        succ_8072_ &= (tmp_12713_->tag == 14);
        if (succ_8072_) {
            {
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8075_ &= (tmp_12713_->tag == 15);
        if (succ_8075_) {
            {
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8079_ &= (tmp_12713_->tag == 16);
        ParsedFuncDecl_s **decl = &tmp_12713_->payload.variant16._0;
        succ_8079_ &= true;
        if (succ_8079_) {
            {
                bool added = ((insertTLIPS0997PS1038rB)(((this)->currentModule), ((asTLIPS4904rPS1038)((*decl)))));
                ((assertBPcrN)((added), ("Func Expr was already contained in lookup!")));
                ((assertBPcrN)((((scopes)->length) > ((usize)(0llu))), ("Expected to at least find global scope in func expr")));
                ScopeLookupList_s _scopes = ((ScopeLookupList_s){0});
                ((pushPS5541S1913rN)((&(_scopes)), (*((atPS5541uszrPS1913)((scopes), ((usize)(0llu)))))));
                ((enterAnonFuncPS3900rN)((this)));
                FunctionLookup_s *fn = ((this)->currentFunction);
                ((state) = ((typeCheckFunctionPS3900PS4904PS5541BrU9661)((this), (*decl), (&(_scopes)), (false))));
                (((this)->currentFunction) = (fn));
                ((leaveAnonFuncPS3900rN)((this)));
                ((dropPS5541rN)((&(_scopes))));
            }
            goto after_12713;
        }
    }
    {
        succ_8087_ &= (tmp_12713_->tag == 17);
        ParsedTypeNode_s **type = &tmp_12713_->payload.variant17._0;
        succ_8087_ &= true;
        if (succ_8087_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*type)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
                SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
                UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)((&((this)->lookup)), (&(FILE)), (&(NAME))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckExpr: Could not find union context for TypeInfo")));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((context)->type)}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8096_ &= (tmp_12713_->tag == 18);
        ParsedExpr_s **subExpr = &tmp_12713_->payload.variant18._0;
        succ_8096_ &= true;
        if (succ_8096_) {
            {
                TCState_u typeState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*subExpr), (scopes)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                if ((wantsInferPU9661rB)((&(typeState))))
                    ((todo_with_msgPcrN)(("as_data infer")));
                SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("Data")));
                SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
                StructLookup_s *context = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)((&((this)->lookup)), (&(FILE)), (&(NAME))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckExpr: Could not find struct context for Data")));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((context)->type)}}}));
            }
            goto after_12713;
        }
    }
    {
        succ_8105_ &= (tmp_12713_->tag == 20);
        ParsedExprList_s *elems = &tmp_12713_->payload.variant20._0;
        succ_8105_ &= true;
        if (succ_8105_) {
            {
                TypeList_s tElems = ((TypeList_s){0});
                TCState_u infer = (((TCState_u){.tag = 0, .payload = {0}}));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    TCState_u e = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((((*elems).elements))[(i)]), (scopes)));
                    if ((isErrorPU9661rB)((&(e))))
                        return (e);
                    if ((wantsInferPU9661rB)((&(e)))) {
                        ((infer) = (e));
                        continue;
                    }

                    ((pushPS0643PU5175rN)((&(tElems)), ((getTypePU9661rPU5175)((&(e))))));
                }

                if ((wantsInferPU9661rB)((&(infer))))
                    return (infer);
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 10, .payload = {.variant10 = {._0 = (tElems)}}})))}}}));
            }
            goto after_12713;
        }
    }
    {
        ExprData_u **unknown = &tmp_12713_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckExpr: Unhandled Expression with tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_12713;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12713:
    (void)0; // error: label at end of compound statement is a C23 extension
    if ((isErrorPU9661rB)((&(state))))
        return (state);
    (((expr)->typeState) = (state));
    return (state);
}
TCState_u typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedExpr_s *curr, ParsedTypeNode_s *type, ScopeLookupList_s *scopes) {
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (curr), (scopes)));
    TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (type)));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    if ((isErrorPU9661rB)((&(typeState))))
        return (typeState);
    ((assertBPcrN)(((isTypePU9661rB)((&(typeState)))), ("typeCheckExprAs Type is not a Type")));
    Type_u *typeType = ((getTypePU9661rPU5175)((&(typeState))));
    if ((wantsInferPU9661rB)((&(exprState))))
        ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (curr), (typeType), (scopes))));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("Expected <expr> in `<expr> as <type>` to have a valid type after infer")));
    Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
    if (((isDataPU5175rB)((exprType))) && ((isDataPU5175rB)((typeType)))) {
        ((todo_with_msgPcrN)(("Data as Data???")));
    }

    else if ((isDataPU5175rB)((exprType))) {
    }

    else if ((isDataPU5175rB)((typeType))) {
        (((expr)->data) = ((ExprData_u){.tag = 18, .payload = {.variant18 = {._0 = (curr)}}}));
    }

    else if (((isPointerPU5175rB)((exprType))) && ((isPointerPU5175rB)((typeType)))) {
    }

    else if (((isFunctionPU5175rB)((exprType))) && ((isFunctionPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from type %s to type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isFunctionPU5175rB)((exprType))) && ((isAnyPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from type %s to Any.\n"), ((loc).buffer), (WARN_STR), ((from).buffer)));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isAnyPU5175rB)((exprType))) && ((isFunctionPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from Any to type %s.\n"), ((loc).buffer), (WARN_STR), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isPointerPU5175rB)((exprType))) && ((isIntegerPU5175rB)((typeType)))) {
        if (((getSizeInBytesPU5175rusz)((typeType))) != ((getSizeInBytesPU5175rusz)((exprType)))) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting pointer of type %s to integer of type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isIntegerPU5175rB)((exprType))) && ((isPointerPU5175rB)((typeType)))) {
        if (((getSizeInBytesPU5175rusz)((typeType))) != ((getSizeInBytesPU5175rusz)((exprType)))) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting integer of type %s to pointer of type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (!((isPrimitivePU5175rB)((typeType)))) {
        return ((reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661)((this), ((curr)->span), (exprType), (typeType)));
    }

    else if (!((isPrimitivePU5175rB)((exprType)))) {
        return ((reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661)((this), ((curr)->span), (exprType), (typeType)));
    }

    if ((((getSizeInBytesPU5175rusz)((typeType))) < ((getSizeInBytesPU5175rusz)((exprType)))) && (*((flags).warnExtra))) {
        String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
        String_s tName = ((toStringPU5175rS0540)((typeType)));
        String_s oName = ((toStringPU5175rS0540)((exprType)));
        (((fprintf))((stderr_), ("%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n"), ((loc).buffer), (WARN_STR), ((tName).buffer), ((oName).buffer)));
        ((dropPS0540rN)((&(oName))));
        ((dropPS0540rN)((&(tName))));
        ((dropPS0540rN)((&(loc))));
    }

    return (typeState);
}
TCState_u typeCheckExprUnaryPS3900PU5427PS5541rU9661(TypeChecker_s *this, UnaryExpr_u *unary, ScopeLookupList_s *scopes) {
    bool succ_8144_ = true;
    bool succ_8149_ = true;
    bool succ_8169_ = true;
    bool succ_8175_ = true;
    bool succ_8185_ = true;

    UnaryExpr_u *tmp_12876_ = (unary);
    {
        succ_8144_ &= (tmp_12876_->tag == 0);
        ParsedExpr_s **expr = &tmp_12876_->payload.variant0._0;
        succ_8144_ &= true;
        if (succ_8144_) {
            {
                ((enterComptimePS3900rN)((this)));
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                ((leaveComptimePS3900rN)((this)));
                return (exprState);
            }
            goto after_12876;
        }
    }
    {
        succ_8149_ &= (tmp_12876_->tag == 2);
        ParsedExpr_s **expr = &tmp_12876_->payload.variant2._0;
        succ_8149_ &= true;
        if (succ_8149_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                bool succ_8156_ = true;
                bool succ_8154_ = true;
                bool succ_8160_ = true;

                Type_u *tmp_12831_ = (exprType);
                {
                    succ_8156_ &= (tmp_12831_->tag == 3);
                    succ_8154_ &= (tmp_12831_->payload.variant3._0.tag == 9);
                    succ_8156_ &= succ_8154_;
                    if (succ_8156_) {
                        {
                            return ((reportAnyDereferencePS3900PS2435rU9661)((this), (*expr)));
                        }
                        goto after_12831;
                    }
                }
                {
                    succ_8160_ &= (tmp_12831_->tag == 4);
                    Type_u **under = &tmp_12831_->payload.variant4._0;
                    succ_8160_ &= true;
                    if (succ_8160_) {
                        {
                            return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (*under)}}});
                        }
                        goto after_12831;
                    }
                }
                {
                    if (true) {
                        {
                            String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                            String_s t = ((toStringPU5175rS0540)((exprType)));
                            (((fprintf))((stderr_), ("%s: %s: Attempted to dereference expression of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                            ((dropPS0540rN)((&(t))));
                            ((dropPS0540rN)((&(loc))));
                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DEREF_NON_POINTER)}}});
                        }
                        goto after_12831;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12831:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12876;
        }
    }
    {
        succ_8169_ &= (tmp_12876_->tag == 1);
        ParsedExpr_s **expr = &tmp_12876_->payload.variant1._0;
        succ_8169_ &= true;
        if (succ_8169_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (exprType)}}})))}}});
            }
            goto after_12876;
        }
    }
    {
        succ_8175_ &= (tmp_12876_->tag == 3);
        ParsedExpr_s **expr = &tmp_12876_->payload.variant3._0;
        succ_8175_ &= true;
        if (succ_8175_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if ((!((isSignedIntegerPU5175rB)((exprType)))) && (!((isFloatPU5175rB)((exprType))))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    String_s t = ((toStringPU5175rS0540)((exprType)));
                    (((fprintf))((stderr_), ("%s: %s: Negation is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                    ((dropPS0540rN)((&(t))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                return (exprState);
            }
            goto after_12876;
        }
    }
    {
        succ_8185_ &= (tmp_12876_->tag == 4);
        ParsedExpr_s **expr = &tmp_12876_->payload.variant4._0;
        succ_8185_ &= true;
        if (succ_8185_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (!((isBooleanPU5175rB)((exprType)))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    String_s t = ((toStringPU5175rS0540)((exprType)));
                    (((fprintf))((stderr_), ("%s: %s: Logical Not is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                    ((dropPS0540rN)((&(t))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                return (exprState);
            }
            goto after_12876;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12876;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12876:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in typeCheckUnary")));
}
TCState_u _anon_23_3PS3900PS7823PS0643PS5541BrU9661(TypeChecker_s *this, ParsedExprList_s *args, TypeList_s *params, ScopeLookupList_s *scopes, bool variadic) {
    for (usize i = ((usize)(0llu)); ((i) < ((params)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedExpr_s **arg = ((atPS7823uszrPPS2435)((args), (i)));
        Type_u *paramType = (*((atPS0643uszrPPU5175)((params), (i))));
        TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*(arg)), (scopes)));
        if ((isErrorPU9661rB)((&(argState))))
            return (argState);
        if ((wantsInferPU9661rB)((&(argState)))) {
            ((argState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*(arg)), (paramType), (scopes))));
            if ((isErrorPU9661rB)((&(argState))))
                return (argState);
        }

        Type_u *argType = ((getTypePU9661rPU5175)((&(argState))));
        if (((isVariadicTypePU5175rB)((argType))) && (variadic)) {
            ((assertBPcrN)((((params)->length) == ((usize)(1llu))), ("check_params: Assumption wrong")));
        }

        else if ((!((isDataPU5175rB)((argType)))) && ((isDataPU5175rB)((paramType)))) {
            ((*(arg)) = ((newParsedExprS8951U8798rPS2435)(((*(arg))->span), ((ExprData_u){.tag = 18, .payload = {.variant18 = {._0 = (*(arg))}}}))));
            TCState_u newState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*(arg)), (scopes)));
            if ((isErrorPU9661rB)((&(newState))))
                return (newState);
            ((assertBPcrN)(((isTypePU9661rB)((&(newState)))), ("idk if this is always the case")));
        }

        else if (!((equalsPU5175PU5175rB)((argType), (paramType)))) {
            ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*(arg))->span), (paramType), (argType)));
        }
    }

    return (((TCState_u){.tag = 1, .payload = {0}}));
}
TCState_u typeCheckExprCallPS3900PS3328PS5541rU9661(TypeChecker_s *this, CallExpr_s *call, ScopeLookupList_s *scopes) {
    ParsedExprList_s *args = (&((call)->args));
    for (usize i = ((usize)(0llu)); ((i) < ((args)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        TCState_u arg = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*((atPS7823uszrPPS2435)((args), (i)))), (scopes)));
        if ((isErrorPU9661rB)((&(arg))))
            return (arg);
    }

    TCState_u callBase = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((call)->base), (scopes)));
    if ((isErrorPU9661rB)((&(callBase))))
        return (callBase);
    if ((wantsInferPU9661rB)((&(callBase)))) {
        TypeList_s params = ((TypeList_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((args)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            Type_u *typ = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}}))));
            TCState_u *state = (&((*((atPS7823uszrPPS2435)((args), (i))))->typeState));
            if ((isTypePU9661rB)((state)))
                ((typ) = ((getTypePU9661rPU5175)((state))));
            ((pushPS0643PU5175rN)((&(params)), (typ)));
        }

        Type_u *fnType =
            ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}})))), ._2 = ((FuncAttr_s){0})}}})));
        TCState_u baseState = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((call)->base), (fnType), (scopes), (false)));
        if ((isErrorPU9661rB)((&(baseState))))
            return (baseState);
        if ((wantsInferPU9661rB)((&(baseState))))
            return (baseState);
        ((callBase) = (baseState));
    }

    Type_u *baseType = ((getTypePU9661rPU5175)((&(callBase))));
    bool succ_8212_ = true;
    bool succ_8230_ = true;

    Type_u *tmp_13034_ = (baseType);
    {
        succ_8212_ &= (tmp_13034_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_13034_->payload.variant8._0;
        succ_8212_ &= true;
        usize *vID = &tmp_13034_->payload.variant8._1;
        succ_8212_ &= true;
        if (succ_8212_) {
            {
                ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (*vID))));
                bool succ_8217_ = true;

                ParsedUnionVariantData_u *tmp_12909_ = (&((variant)->data));
                succ_8217_ &= (tmp_12909_->tag == 1);
                ParsedTypeNodeList_s *fields = &tmp_12909_->payload.variant1._0;
                succ_8217_ &= true;
                if (!succ_8217_) {
                    return ((reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661)((this), (*decl), (variant), ((call)->span), (((ParsedUnionVariantData_u){.tag = 1, .payload = {0}}))));
                };
                if (((args)->length) != ((*fields).length))
                    ((todo_with_msgPcrN)(("report error: Tuple variant count mismatch")));
                Type_u *unionType = ((copyPU5175rPU5175)((baseType)));
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((args), (i))));
                    TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (arg), (scopes)));
                    if ((isErrorPU9661rB)((&(argState))))
                        return (argState);
                    Type_u *paramType = ((getTypeAtIndexPS3506uszrPU5175)((variant), (i)));
                    if ((wantsInferPU9661rB)((&(argState)))) {
                        ((argState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (arg), (paramType), (scopes))));
                        if ((isErrorPU9661rB)((&(argState))))
                            return (argState);
                    }

                    Type_u *argType = ((getTypePU9661rPU5175)((&(argState))));
                    if (!((equalsPU5175PU5175rB)((argType), (paramType)))) {
                        ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((arg)->span), (paramType), (argType)));
                    }
                }

                (((call)->isUnion) = (true));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}});
            }
            goto after_13034;
        }
    }
    {
        succ_8230_ &= (tmp_13034_->tag == 6);
        TypeList_s *params = &tmp_13034_->payload.variant6._0;
        succ_8230_ &= true;
        Type_u **ret = &tmp_13034_->payload.variant6._1;
        succ_8230_ &= true;
        FuncAttr_s *attr = &tmp_13034_->payload.variant6._2;
        succ_8230_ &= true;
        if (succ_8230_) {
            {
                TCState_u (*check_params)(TypeChecker_s *, ParsedExprList_s *, TypeList_s *, ScopeLookupList_s *, bool) = (_anon_23_3PS3900PS7823PS0643PS5541BrU9661);
                if ((*attr).isVariadic) {
                    ((assertBPcrN)((((*params).length) > ((usize)(0llu))), ("Variadic function with 0 parameters")));
                    Type_u *last = ((((*params).elements))[(((*params).length) - ((usize)(1llu)))]);
                    TCState_u state = (((TCState_u){.tag = 0, .payload = {0}}));
                    if ((isVariadicTypePU5175rB)((last))) {
                        (((*params).length) = (((*params).length) - ((usize)(1llu))));
                        if (((args)->length) < ((*params).length)) {
                            ((state) = ((reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661)((this), ((call)->span), (baseType), ((args)->length), (true))));
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        Type_u *varType = ((getUnderlyingTypePU5175BrPU5175)((last), (false)));
                        ((state) = ((check_params)((this), (args), (&(*params)), (scopes), (false))));
                        if (!((isSuccessPU9661rB)((&(state))))) {
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        usize varLen = (((args)->length) - ((*params).length));
                        ParsedExprList_s varArgs = ((ParsedExprList_s){0});
                        TypeList_s varParams = ((TypeList_s){0});
                        for (usize i = ((usize)(0llu)); ((i) < (varLen)); ((i) = ((i) + ((usize)(1llu))))) {
                            ((pushPS7823PS2435rN)((&(varArgs)), (*((atPS7823uszrPPS2435)((args), (((*params).length) + (i)))))));
                            ((pushPS0643PU5175rN)((&(varParams)), (varType)));
                        }

                        ((state) = ((check_params)((this), (&(varArgs)), (&(varParams)), (scopes), (true))));
                        if (!((isSuccessPU9661rB)((&(state))))) {
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        (((args)->length) = ((*params).length));
                        if (((varArgs).length) == ((usize)(1llu))) {
                            ParsedExpr_s *entry = ((((varArgs).elements))[((usize)(0llu))]);
                            ((assertBPcrN)(((isTypePU9661rB)((&((entry)->typeState)))), ("Single VarArg is not valid")));
                            Type_u *t = ((getTypePU9661rPU5175)((&((entry)->typeState))));
                            if ((isVariadicTypePU5175rB)((t))) {
                                if ((equalsPU5175PU5175rB)(((getUnderlyingTypePU5175BrPU5175)((t), (false))), (varType))) {
                                    ((pushPS7823PS2435rN)((args), (entry)));
                                }

                                else {
                                    ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                                    (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                                    ((pushPS7823PS2435rN)((args), (varArg)));
                                }

                            }

                            else {
                                ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                                (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                                ((pushPS7823PS2435rN)((args), (varArg)));
                            }

                        }

                        else {
                            ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                            (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                            ((pushPS7823PS2435rN)((args), (varArg)));
                        }

                        (((*params).length) = (((*params).length) + ((usize)(1llu))));
                    }

                    else {
                        ((state) = ((check_params)((this), (args), (&(*params)), (scopes), (false))));
                        if (!((isSuccessPU9661rB)((&(state)))))
                            return (state);
                    }

                }

                else {
                    if (((args)->length) != ((*params).length)) {
                        return ((reportArgumentCountMismatchPS3900S8951PU5175uszrU9661)((this), ((call)->span), (baseType), ((args)->length)));
                    }

                    TCState_u state = ((check_params)((this), (args), (&(*params)), (scopes), (false)));
                    if (!((isSuccessPU9661rB)((&(state)))))
                        return (state);
                }

                (((call)->retType) = (*ret));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (*ret)}}});
            }
            goto after_13034;
        }
    }
    {
        if (true) {
            {
                return ((reportCallToNonFunctionPS3900S8951PU5175rU9661)((this), ((call)->span), (baseType)));
            }
            goto after_13034;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13034:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u typeCheckExprStructInitPS3900PS4761PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, ScopeLookupList_s *scopes) {
    TypeLookup_s lookup = ((TypeLookup_s){0});
    if (!((resolveTypeByNamePS0997PS7720PS6177rB)(((this)->currentModule), (&(((expr)->name).content)), (&(lookup))))) {
        TypeLookupList_s alternatives = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((&((this)->lookup)), (&(((expr)->name).content))));
        return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (NULL), ((expr)->name), (alternatives)));
    }

    if ((isStructPS6177rB)((&(lookup)))) {
        return ((typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661)((this), (expr), (lookup), (scopes)));
    }

    else {
        ((unreachablePcrN)(("typeCheckExprStructInit got non-struct")));
    }
}
TCState_u typeCheckIdentifierPS3900PS7464PS5541rU9661(TypeChecker_s *this, IdentExpr_s *ident, ScopeLookupList_s *scopes) {
    VariableLookup_s var = ((VariableLookup_s){0});
    Token_s *name = (&((ident)->name));
    if ((resolveVariableByNamePS0997PS6070PS5541PS6661rB)(((this)->currentModule), (name), (scopes), (&(var)))) {
        if ((((this)->comptimeDepth) > ((usize)(0llu))) && (!((var).isComptime))) {
            return ((reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661)((this), (*(name)), (&(var))));
        }

        TCState_u state = ((var).typeState);
        ((assertBPcrN)((!((isInvalidPU9661rB)((&(state))))), ("Variable not ready")));
        if ((isErrorPU9661rB)((&(state))))
            return (state);
        Token_s _loc = ((Token_s){0});
        if ((isKnownVariablePS1913S7720PS6070rB)(((atPS5541uszrPS1913)((scopes), ((usize)(0llu)))), ((name)->content), (&(_loc)))) {
            (((ident)->isGlobal) = (true));
        }

        if ((isTypePU9661rB)((&(state)))) {
            (((ident)->type) = ((getTypePU9661rPU5175)((&(state)))));
        }

        (((ident)->origID) = ((var).globalID));
        return (state);
    }

    FunctionLookupList_s functions = ((resolveFunctionByNamePS0997PS6070rS8385)(((this)->currentModule), (name)));
    if (((functions).length) > ((usize)(1llu))) {
        ((dropPS8385rN)((&(functions))));
        return (((TCState_u){.tag = 4, .payload = {0}}));
    }

    if (((functions).length) == ((usize)(1llu))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
        (((ident)->type) = ((getTypePU9661rPU5175)((&((f)->fnType)))));
        (((ident)->origID) = ((f)->globalID));
        return ((f)->fnType);
    }

    UnionLookup_s *unionLookup = (NULL);
    if ((resolveUnionByNamePS0997PS6070PPS1592rB)(((this)->currentModule), (name), (&(unionLookup)))) {
        ((assertBPcrN)(((unionLookup) != (NULL)), ("resolveUnionByName returned true but lookup is null")));
        ParsedUnionDecl_s *decl = ((unionLookup)->global);
        ((assertBPcrN)(((isSuccessPU9661rB)((&((decl)->typeState)))), ("Expected valid union type at this point")));
        Type_u *t = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ((assertBPcrN)(((isUnionPU5175rB)((t))), ("Expected union declaration to have union type")));
        (((ident)->type) = (t));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((copyPU5175rPU5175)((t)))}}});
    }

    ModuleLookup_s *moduleLookup = (NULL);
    if ((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (name), (&(moduleLookup)))) {
        Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((moduleLookup)->globalID)))}}})));
        (((ident)->type) = (typ));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}});
    }

    return ((reportUnknownIdentifierPS3900PS6070rU9661)((this), (name)));
}
TCState_u typeCheckExprBinaryPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    bool succ_8279_ = true;
    bool succ_8283_ = true;
    bool succ_8287_ = true;
    bool succ_8291_ = true;
    bool succ_8295_ = true;
    bool succ_8299_ = true;
    bool succ_8303_ = true;
    bool succ_8307_ = true;
    bool succ_8311_ = true;
    bool succ_8315_ = true;
    bool succ_8319_ = true;
    bool succ_8323_ = true;
    bool succ_8327_ = true;
    bool succ_8331_ = true;
    bool succ_8335_ = true;
    bool succ_8339_ = true;
    bool succ_8343_ = true;
    bool succ_8347_ = true;
    bool succ_8351_ = true;
    bool succ_8355_ = true;

    BinaryExpr_u *tmp_13137_ = (expr);
    {
        succ_8279_ &= (tmp_13137_->tag == 0);
        succ_8279_ &= true;
        if (succ_8279_) {
            {
                return ((typeCheckExprPathAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8283_ &= (tmp_13137_->tag == 1);
        succ_8283_ &= true;
        if (succ_8283_) {
            {
                return ((typeCheckExprMemberAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8287_ &= (tmp_13137_->tag == 2);
        succ_8287_ &= true;
        if (succ_8287_) {
            {
                return ((typeCheckExprAssignPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8291_ &= (tmp_13137_->tag == 3);
        succ_8291_ &= true;
        if (succ_8291_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8295_ &= (tmp_13137_->tag == 4);
        succ_8295_ &= true;
        if (succ_8295_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8299_ &= (tmp_13137_->tag == 5);
        succ_8299_ &= true;
        if (succ_8299_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8303_ &= (tmp_13137_->tag == 6);
        succ_8303_ &= true;
        if (succ_8303_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8307_ &= (tmp_13137_->tag == 7);
        succ_8307_ &= true;
        if (succ_8307_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8311_ &= (tmp_13137_->tag == 8);
        succ_8311_ &= true;
        if (succ_8311_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8315_ &= (tmp_13137_->tag == 9);
        succ_8315_ &= true;
        if (succ_8315_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8319_ &= (tmp_13137_->tag == 10);
        succ_8319_ &= true;
        if (succ_8319_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8323_ &= (tmp_13137_->tag == 11);
        succ_8323_ &= true;
        if (succ_8323_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8327_ &= (tmp_13137_->tag == 12);
        succ_8327_ &= true;
        if (succ_8327_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8331_ &= (tmp_13137_->tag == 13);
        succ_8331_ &= true;
        if (succ_8331_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8335_ &= (tmp_13137_->tag == 14);
        succ_8335_ &= true;
        if (succ_8335_) {
            {
                return ((typeCheckExprLogicalPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8339_ &= (tmp_13137_->tag == 15);
        succ_8339_ &= true;
        if (succ_8339_) {
            {
                return ((typeCheckExprLogicalPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8343_ &= (tmp_13137_->tag == 16);
        succ_8343_ &= true;
        if (succ_8343_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8347_ &= (tmp_13137_->tag == 17);
        succ_8347_ &= true;
        if (succ_8347_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8351_ &= (tmp_13137_->tag == 18);
        succ_8351_ &= true;
        if (succ_8351_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        succ_8355_ &= (tmp_13137_->tag == 19);
        succ_8355_ &= true;
        if (succ_8355_) {
            {
                return ((typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13137;
        }
    }
    {
        BinaryExpr_u **unknown = &tmp_13137_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckExprBinary: Unhandled tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_13137;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13137:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of binary expressions in typeCheckExprBinary")));
}
TCState_u typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    if ((wantsInferPU9661rB)((&(lhsState)))) {
        String_s loc = ((toStringPS8951rS0540)((&((lhs)->span))));
        (((fprintf))((stderr_), ("%s: %s: Could not infer type of subexpression for indexed access.\n"), ((loc).buffer), (ERR_STR)));
        ((dropPS0540rN)((&(loc))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_ACCESS_ON_NON_ARRAY)}}});
    }

    ((assertBPcrN)(((isTypePU9661rB)((&(lhsState)))), ("IndexedAccess: Not error, not infer, what is it?")));
    if ((wantsInferPU9661rB)((&(rhsState)))) {
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        ((rhsState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (rhs), (usizeType), (scopes))));
    }

    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    ((assertBPcrN)(((isTypePU9661rB)((&(rhsState)))), ("IndexedAccess: Index is not valid after infer?")));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    if (((!((isArrayPU5175rB)((lhsType)))) && (!((isPointerPU5175rB)((lhsType))))) && (!((isVariadicTypePU5175rB)((lhsType))))) {
        return ((reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661)((this), ((lhs)->span), (lhsType)));
    }

    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    bool succ_8376_ = true;
    bool succ_8374_ = true;

    Type_u *tmp_13171_ = (rhsType);
    {
        succ_8376_ &= (tmp_13171_->tag == 3);
        succ_8374_ &= (tmp_13171_->payload.variant3._0.tag == 8);
        succ_8376_ &= succ_8374_;
        if (succ_8376_) {
            {
                Type_u *underlyingType = ((getUnderlyingTypePU5175BrPU5175)((lhsType), (false)));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (underlyingType)}}});
            }
            goto after_13171;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13171;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13171:
    (void)0; // error: label at end of compound statement is a C23 extension
    String_s loc = ((toStringPS8951rS0540)((&((rhs)->span))));
    String_s typ = ((toStringPU5175rS0540)((rhsType)));
    (((fprintf))((stderr_), ("%s: %s: Expected index of array access to be type usize, got %s.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_TYPE_MISMATCH)}}});
}
TCState_u typeCheckExprLogicalPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (boolType)}}});
    if (!((isBooleanPU5175rB)((lhsType)))) {
        ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((lhs)->span), (boolType), (lhsType))));
    }

    if (!((isBooleanPU5175rB)((rhsType)))) {
        ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((rhs)->span), (boolType), (rhsType))));
    }

    return (result);
}
TCState_u typeCheckExprBitwisePS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (((!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) || (!((isIntegerPU5175rB)((lhsType))))) || (!((isIntegerPU5175rB)((rhsType))))) {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    return (lhsState);
}
TCState_u typeCheckExprAssignPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    if (!((isLValuePS2435rB)((lhs)))) {
        ((emergencyPrintPS3900S8951rN)((this), ((lhs)->span)));
        ((todo_with_msgPcrN)(("invalid l-value")));
    }

    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if (!((isTypePU9661rB)((&(lhsState)))))
        return (lhsState);
    if (!((isTypePU9661rB)((&(rhsState)))))
        return (rhsState);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) {
        return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((rhs)->span), (lhsType), (rhsType)));
    }

    return (rhsState);
}
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes) {
    return ((typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661)((this), (expr), (lookup), (scopes), (false)));
}
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes, bool isUnion) {
    StructInitContext_s *context = (&((expr)->context));
    StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
    usize hits = ((usize)(0llu));
    ((assertBPcrN)(((((structLookup)->fields).length) < ((usize)(50llu))), ("Sorry, I need to hack this for now")));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((structLookup)->type)}}});
    for (usize i = ((usize)(0llu)); ((i) < ((context)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((context), (i)));
        ParsedExpr_s *fieldExpr = ((getFieldExprAtIndexPS6291uszrPS2435)((context), (i)));
        TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (fieldExpr), (scopes)));
        if ((isErrorPU9661rB)((&(exprState))))
            ((result) = (exprState));
        if (!((hasFieldPS4228PS7720rB)((structLookup), (&((name).content))))) {
            ((result) = ((reportUnknownFieldPS3900S6070PS4228BrU9661)((this), (name), (structLookup), (isUnion))));
            continue;
        }

        usize fieldIndex = ((getIndexByNamePS4228PS6070rusz)((structLookup), (&(name))));
        usize bit = ((shiftLeftuszuszrusz)(((usize)(1llu)), (fieldIndex)));
        if (((hits) & (bit)) != ((usize)(0llu))) {
            Token_s field = ((getFieldNameAtIndexPS6291uszrS6070)((context), (fieldIndex)));
            ((result) = ((reportDuplicateFieldPS3900S6070S8951rU9661)((this), (name), ((field).span))));
            continue;
        }

        else {
            ((hits) = ((hits) | (bit)));
        }

        VariableLookup_s *field = ((atPS3313uszrPS6661)((&((structLookup)->fields)), (fieldIndex)));
        TCState_u *fieldState = (&((field)->typeState));
        ((assertBPcrN)(((isSuccessPU9661rB)((fieldState))), ("Struct is ready to go, but field type is invalid?")));
        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((name).content)), (&(((field)->name).content)))), ("Seems like my hack doesn\'t work")));
        Type_u *fieldType = ((getTypePU9661rPU5175)((fieldState)));
        if ((wantsInferPU9661rB)((&(exprState))))
            ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (fieldExpr), (fieldType), (scopes))));
        if ((isErrorPU9661rB)((&(exprState)))) {
            ((result) = (exprState));
            continue;
        }

        Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
        if (!((equalsPU5175PU5175rB)((fieldType), (exprType)))) {
            ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((fieldExpr)->span), (fieldType), (exprType))));
        }
    }

    return (result);
}
TCState_u typeCheckExprPathAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u instance = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    if ((isErrorPU9661rB)((&(instance))))
        return (instance);
    Type_u *instanceType = ((getTypePU9661rPU5175)((&(instance))));
    bool succ_8467_ = true;
    bool succ_8498_ = true;

    Type_u *tmp_13371_ = (instanceType);
    {
        succ_8467_ &= (tmp_13371_->tag == 9);
        ParsedModule_s **decl = &tmp_13371_->payload.variant9._0;
        succ_8467_ &= true;
        if (succ_8467_) {
            {
                ModuleLookup_s *modLookup = ((getModuleByGlobalIDPS7791uszrPS0997)((&((this)->lookup)), ((getIDPS1882rusz)((*decl)))));
                bool succ_8472_ = true;
                bool succ_8490_ = true;

                ExprData_u *tmp_13359_ = (&((rhs)->data));
                {
                    succ_8472_ &= (tmp_13359_->tag == 4);
                    IdentExpr_s *ident = &tmp_13359_->payload.variant4._0;
                    succ_8472_ &= true;
                    if (succ_8472_) {
                        {
                            ModuleLookup_s *submodule = (NULL);
                            MLConfig_s config = ((MLConfig_s){.checkSelf = (false), .checkImport = (false), .checkModule = (true), .checkParent = (false)});
                            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((modLookup), (&((*ident).name)), (&(submodule)), (config))) {
                                Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((submodule)->globalID)))}}})));
                                (((rhs)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}}));
                                return ((rhs)->typeState);
                            }

                            VariableLookup_s *var = (NULL);
                            FunctionLookupList_s fun = ((FunctionLookupList_s){0});
                            TypeLookup_s typ = ((TypeLookup_s){0});
                            u32 res = ((resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32)((modLookup), (&((*ident).name)), (&(var)), (&(typ)), (&(fun))));
                            if ((res) == (IDENT_TYPE)) {
                                if ((isStructPS6177rB)((&(typ)))) {
                                    return ((reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661)((this), ((lhs)->span), ((*ident).name), (typ)));
                                }

                                else {
                                    Type_u *t = (((asUnionPS6177rPS1592)((&(typ))))->type);
                                    (((rhs)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                                    return ((rhs)->typeState);
                                }

                            }

                            else if ((res) == (IDENT_NONE)) {
                                return ((reportUnknownSubmodulePS3900PS0997S6070rU9661)((this), (modLookup), ((*ident).name)));
                            }

                            else if ((res) == (IDENT_FUNC)) {
                                ((assertBPcrN)((((fun).length) != ((usize)(0llu))), ("IDENT_FUNC but fun is empty")));
                                if (((fun).length) == ((usize)(1llu))) {
                                    FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(fun)), ((usize)(0llu))));
                                    ((assertBPcrN)(((isSuccessPU9661rB)((&((f)->fnType)))), ("Did not properly type check function of module")));
                                    TCState_u s = ((f)->fnType);
                                    (((rhs)->typeState) = (s));
                                    (((*ident).type) = ((getTypePU9661rPU5175)((&(s)))));
                                    (((*ident).origID) = ((f)->globalID));
                                    return (s);
                                }

                                else {
                                    ((dropPS8385rN)((&(fun))));
                                    return (((TCState_u){.tag = 4, .payload = {0}}));
                                }

                            }

                            else if ((res) == (IDENT_VAR)) {
                                ((assertBPcrN)(((var) != (NULL)), ("IDENT_VAR but var is null")));
                                ((todo_with_msgPcrN)(("module.var")));
                            }

                            else {
                                ((unreachablePcrN)(("Exhaustive handling of outcomes of resolveIdentifierByName")));
                            }
                        }
                        goto after_13359;
                    }
                }
                {
                    succ_8490_ &= (tmp_13359_->tag == 9);
                    StructExpr_s *init = &tmp_13359_->payload.variant9._0;
                    succ_8490_ &= true;
                    if (succ_8490_) {
                        {
                            TypeLookup_s lookup = ((TypeLookup_s){0});
                            if (!((resolveTypeByNamePS0997PS7720PS6177rB)((modLookup), (&(((*init).name).content)), (&(lookup))))) {
                                return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (modLookup), ((*init).name), ((TypeLookupList_s){0})));
                            }

                            if ((isStructPS6177rB)((&(lookup)))) {
                                (((rhs)->typeState) = ((typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661)((this), (&(*init)), (lookup), (scopes))));
                            }

                            else {
                                ((unreachablePcrN)(("typeCheckExprModuleAccess got non-struct")));
                            }

                            return ((rhs)->typeState);
                        }
                        goto after_13359;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected StructInit or Ident as RHS of module")));
                        }
                        goto after_13359;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13359:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13371;
        }
    }
    {
        succ_8498_ &= (tmp_13371_->tag == 8);
        succ_8498_ &= true;
        succ_8498_ &= true;
        if (succ_8498_) {
            {
                return ((typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661)((this), (expr), (instanceType), (scopes)));
            }
            goto after_13371;
        }
    }
    {
        Type_u **typ = &tmp_13371_;
        if (true) {
            {
                Token_s name = ((Token_s){0});
                bool succ_8505_ = true;

                ExprData_u tmp_13368_ = ((lhs)->data);
                {
                    succ_8505_ &= (tmp_13368_.tag == 4);
                    IdentExpr_s *ident = &tmp_13368_.payload.variant4._0;
                    succ_8505_ &= true;
                    if (succ_8505_) {
                        {
                            ((name) = ((*ident).name));
                        }
                        goto after_13368;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected identifier as LHS of Path access")));
                        }
                        goto after_13368;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13368:
                (void)0; // error: label at end of compound statement is a C23 extension
                return ((reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661)((this), ((lhs)->span), (name), ((TypeLookup_s){0})));
            }
            goto after_13371;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13371:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *unionType, ScopeLookupList_s *scopes) {
    ParsedUnionDecl_s *decl = (NULL);
    bool succ_8512_ = true;

    Type_u *tmp_13378_ = (unionType);
    {
        succ_8512_ &= (tmp_13378_->tag == 8);
        ParsedUnionDecl_s **_decl = &tmp_13378_->payload.variant8._0;
        succ_8512_ &= true;
        succ_8512_ &= true;
        if (succ_8512_) {
            {
                ((decl) = (*_decl));
            }
            goto after_13378;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_13378;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13378:
    (void)0; // error: label at end of compound statement is a C23 extension
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    ((assertBPcrN)(((isSuccessPU9661rB)((&((lhs)->typeState)))), ("UnionInit: Expected valid LHS type")));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    ((assertBPcrN)(((isUnionPU5175rB)((lhsType))), ("UnionInit: Expected LHS to be union")));
    ((assertBPcrN)(((equalsPU5175PU5175rB)((lhsType), (unionType))), ("UnionInit: Passed type is not the same union")));
    UnionLookup_s *lookup = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (decl)));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}});
    bool succ_8525_ = true;
    bool succ_8531_ = true;

    ExprData_u *tmp_13412_ = (&((rhs)->data));
    {
        succ_8525_ &= (tmp_13412_->tag == 4);
        IdentExpr_s *ident = &tmp_13412_->payload.variant4._0;
        succ_8525_ &= true;
        if (succ_8525_) {
            {
                UnionVariantLookup_s *variant = (NULL);
                if (!((resolveVariantByNamePS1592PS6070PPS2365rB)((lookup), (&((*ident).name)), (&(variant))))) {
                    return ((reportNoSuchVariantPS3900PS1592S6070rU9661)((this), (lookup), ((*ident).name)));
                }

                ((unionType) = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (decl), ._1 = ((variant)->tag)}}}))));
                ((result) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}}));
                (((rhs)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = (((UnionExpr_u){.tag = 2, .payload = {0}}))}}}));
            }
            goto after_13412;
        }
    }
    {
        succ_8531_ &= (tmp_13412_->tag == 9);
        StructExpr_s *init = &tmp_13412_->payload.variant9._0;
        succ_8531_ &= true;
        if (succ_8531_) {
            {
                UnionVariantLookup_s *variant = (NULL);
                if (!((resolveVariantByNamePS1592PS6070PPS2365rB)((lookup), (&((*init).name)), (&(variant))))) {
                    return ((reportNoSuchVariantPS3900PS1592S6070rU9661)((this), (lookup), ((*init).name)));
                }

                bool succ_8538_ = true;

                ParsedUnionVariantData_u tmp_13401_ = (((variant)->global)->data);
                succ_8538_ &= (tmp_13401_.tag == 2);
                ParsedTypeNodeList_s *_fields = &tmp_13401_.payload.variant2._0;
                succ_8538_ &= true;
                TokenList_s *_names = &tmp_13401_.payload.variant2._1;
                succ_8538_ &= true;
                if (!succ_8538_) {
                    return ((reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661)((this), (decl), ((variant)->global), ((rhs)->span),
                                                                                                (((ParsedUnionVariantData_u){.tag = 2, .payload = {0}}))));
                };
                ((unionType) = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (decl), ._1 = ((variant)->tag)}}}))));
                ((result) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}}));
                StructLookup_s structLookup = ((intoStructLookupPS2365rS4228)((variant)));
                TCState_u check = ((typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661)((this), (&(*init)), ((asTypeLookupPS4228rS6177)((&(structLookup)))), (scopes), (true)));
                if ((isErrorPU9661rB)((&(check))))
                    return (check);
                (((rhs)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = ((UnionExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (*init)}}})}}}));
            }
            goto after_13412;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected StructInit or Ident as RHS")));
            }
            goto after_13412;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13412:
    (void)0; // error: label at end of compound statement is a C23 extension
    (((rhs)->typeState) = (result));
    return (result);
}
TCState_u typeCheckExprMemberAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u instance = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    if ((isErrorPU9661rB)((&(instance))))
        return (instance);
    if ((wantsInferPU9661rB)((&(instance))))
        return (instance);
    Type_u *instanceType = ((getTypePU9661rPU5175)((&(instance))));
    if ((((isVariadicTypePU5175rB)((instanceType))) || ((isArrayPU5175rB)((instanceType)))) || ((isArrayPointerPU5175rB)((instanceType)))) {
        Token_s fieldName = ((Token_s){0});
        bool succ_8555_ = true;
        bool succ_8553_ = true;

        ExprData_u *tmp_13429_ = (&((rhs)->data));
        {
            succ_8555_ &= (tmp_13429_->tag == 4);
            Token_s *ident = &tmp_13429_->payload.variant4._0.name;
            succ_8553_ &= true;
            succ_8553_ &= true;
            succ_8555_ &= succ_8553_;
            if (succ_8555_) {
                {
                    ((fieldName) = (*ident));
                }
                goto after_13429;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier")));
                }
                goto after_13429;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13429:
        (void)0; // error: label at end of compound statement is a C23 extension
        SubStr_s tmp_65986 = (((newSubStrOfStrLitPcrS7720)(("length"))));

        if ((equalsPS7720PS7720rB)((&((fieldName).content)), (&tmp_65986))) {
            Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
            return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (usizeType)}}});
        }

        String_s l = ((toStringPS8951rS0540)((&((rhs)->span))));
        char *s = ("array");
        if ((isVariadicTypePU5175rB)((instanceType)))
            ((s) = ("variadic"));
        (((fprintf))((stderr_), ("%s: %s: Attempted to access unknown field `%.*s` of %s type.\n"), ((l).buffer), (ERR_STR), (((fieldName).content).len), (((fieldName).content).start), (s)));
        ((dropPS0540rN)((&(l))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_FIELD)}}});
    }

    if ((((!((isStructPU5175rB)((instanceType)))) && (!((isStructPointerPU5175rB)((instanceType))))) && (!((isTuplePU5175rB)((instanceType))))) && (!((isTuplePointerPU5175rB)((instanceType))))) {
        return ((reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
    }

    Type_u *underlying = (instanceType);
    if (!((isStructPU5175rB)((underlying))))
        ((underlying) = ((getUnderlyingTypePU5175BrPU5175)((instanceType), (true))));
    if ((isStructPU5175rB)((underlying))) {
        TypeLookup_s lookup = ((getTypeLookupForTypePS7791PU5175rS6177)((&((this)->lookup)), (underlying)));
        ((assertBrN)(((isStructPS6177rB)((&(lookup))))));
        StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
        Token_s fieldName = ((Token_s){0});
        bool succ_8574_ = true;
        bool succ_8572_ = true;
        bool succ_8578_ = true;

        ExprData_u *tmp_13459_ = (&((rhs)->data));
        {
            succ_8574_ &= (tmp_13459_->tag == 4);
            Token_s *ident = &tmp_13459_->payload.variant4._0.name;
            succ_8572_ &= true;
            succ_8572_ &= true;
            succ_8574_ &= succ_8572_;
            if (succ_8574_) {
                {
                    ((fieldName) = (*ident));
                }
                goto after_13459;
            }
        }
        {
            succ_8578_ &= (tmp_13459_->tag == 0);
            succ_8578_ &= true;
            if (succ_8578_) {
                {
                    return ((reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
                }
                goto after_13459;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier or number")));
                }
                goto after_13459;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13459:
        (void)0; // error: label at end of compound statement is a C23 extension
        VariableLookup_s field = ((VariableLookup_s){0});
        if (!((resolveFieldByNamePS4228PS6070PS6661rB)((structLookup), (&(fieldName)), (&(field))))) {
            return ((reportUnknownFieldPS3900S6070PS4228BrU9661)((this), (fieldName), (structLookup), (false)));
        }

        TCState_u fieldState = ((field).typeState);
        ((assertBPcrN)(((isSuccessPU9661rB)((&(fieldState)))), ("Expected valid field type")));
        return (fieldState);
    }

    else if ((isTuplePU5175rB)((underlying))) {
        Token_s tkn = ((Token_s){0});
        bool succ_8589_ = true;
        bool succ_8593_ = true;

        ExprData_u *tmp_13475_ = (&((rhs)->data));
        {
            succ_8589_ &= (tmp_13475_->tag == 4);
            succ_8589_ &= true;
            if (succ_8589_) {
                {
                    return ((reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
                }
                goto after_13475;
            }
        }
        {
            succ_8593_ &= (tmp_13475_->tag == 0);
            Token_s *_tkn = &tmp_13475_->payload.variant0._0;
            succ_8593_ &= true;
            if (succ_8593_) {
                {
                    ((tkn) = (*_tkn));
                }
                goto after_13475;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier or number")));
                }
                goto after_13475;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13475:
        (void)0; // error: label at end of compound statement is a C23 extension
        usize index = ((usize)(((toU64PS7720ru64)((&((tkn).content))))));
        bool succ_8599_ = true;

        Type_u *tmp_13478_ = (underlying);
        succ_8599_ &= (tmp_13478_->tag == 10);
        TypeList_s *elems = &tmp_13478_->payload.variant10._0;
        succ_8599_ &= true;
        if (!succ_8599_) {
            ((unreachablePcrN)(("underlying is tuple")));
        };
        if ((index) >= ((*elems).length)) {
            return ((reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661)((this), (lhs), (instanceType), (index)));
        }

        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((((*elems).elements))[(index)])}}});
    }

    else {
        ((unreachablePcrN)(("MemberAccess expected Struct or Tuple as LHS")));
    }
}
TCState_u checkIfInferIsNeededPS3900uszPU9661uszPU9661PS5541rU9661(TypeChecker_s *this, usize lhsID, TCState_u *lhsState, usize rhsID, TCState_u *rhsState, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhsExpr = ((atPS7882uszrPS2435)((&(exprs)), (lhsID)));
    ParsedExpr_s *rhsExpr = ((atPS7882uszrPS2435)((&(exprs)), (rhsID)));
    return ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhsExpr), (lhsState), (rhsExpr), (rhsState), (scopes)));
}
TCState_u checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *lhsExpr, TCState_u *lhsState, ParsedExpr_s *rhsExpr, TCState_u *rhsState,
                                                                         ScopeLookupList_s *scopes) {
    if (((isTypePU9661rB)((lhsState))) && ((isTypePU9661rB)((rhsState)))) {
        return (((TCState_u){.tag = 1, .payload = {0}}));
    }

    else if (((isTypePU9661rB)((lhsState))) && (!((isTypePU9661rB)((rhsState))))) {
        ((*(rhsState)) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (rhsExpr), ((getTypePU9661rPU5175)((lhsState))), (scopes))));
        return (*(rhsState));
    }

    else if ((!((isTypePU9661rB)((lhsState)))) && ((isTypePU9661rB)((rhsState)))) {
        ((*(lhsState)) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (lhsExpr), ((getTypePU9661rPU5175)((rhsState))), (scopes))));
        return (*(lhsState));
    }

    else {
        return (((TCState_u){.tag = 4, .payload = {0}}));
    }
}
TCState_u inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedPattern_s *pat, ScopeLookupList_s *scopes) {
    bool succ_8606_ = true;
    bool succ_8609_ = true;
    bool succ_8611_ = true;
    bool succ_8614_ = true;
    bool succ_8616_ = true;
    bool succ_8620_ = true;
    bool succ_8625_ = true;
    bool succ_8628_ = true;
    bool succ_8632_ = true;
    bool succ_8636_ = true;

    Pattern_u tmp_13526_ = ((pat)->data);
    {
        succ_8606_ &= (tmp_13526_.tag == 0);
        if (succ_8606_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13526;
        }
    }
    {
        succ_8609_ &= (tmp_13526_.tag == 1);
        succ_8609_ &= true;
        if (succ_8609_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13526;
        }
    }
    {
        succ_8611_ &= (tmp_13526_.tag == 8);
        if (succ_8611_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13526;
        }
    }
    {
        succ_8614_ &= (tmp_13526_.tag == 9);
        succ_8614_ &= true;
        if (succ_8614_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13526;
        }
    }
    {
        succ_8616_ &= (tmp_13526_.tag == 10);
        if (succ_8616_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13526;
        }
    }
    {
        succ_8620_ &= (tmp_13526_.tag == 3);
        ParsedPattern_s **subpat = &tmp_13526_.payload.variant3._0;
        succ_8620_ &= true;
        ParsedTypeNode_s **typeNode = &tmp_13526_.payload.variant3._1;
        succ_8620_ &= true;
        if (succ_8620_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*typeNode)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                Type_u *type = ((getTypePU9661rPU5175)((&(typeState))));
                return ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (expr), (type), (scopes)));
            }
            goto after_13526;
        }
    }
    {
        succ_8625_ &= (tmp_13526_.tag == 2);
        Token_s *name = &tmp_13526_.payload.variant2._0;
        succ_8625_ &= true;
        if (succ_8625_) {
            {
                return (((TCState_u){.tag = 4, .payload = {0}}));
            }
            goto after_13526;
        }
    }
    {
        succ_8628_ &= (tmp_13526_.tag == 4);
        ParsedPattern_s **subpat = &tmp_13526_.payload.variant4._0;
        succ_8628_ &= true;
        if (succ_8628_) {
            {
            }
            goto after_13526;
        }
    }
    {
        succ_8632_ &= (tmp_13526_.tag == 5);
        Token_s *name = &tmp_13526_.payload.variant5._0;
        succ_8632_ &= true;
        ParsedPatternList_s *subpats = &tmp_13526_.payload.variant5._1;
        succ_8632_ &= true;
        if (succ_8632_) {
            {
            }
            goto after_13526;
        }
    }
    {
        succ_8636_ &= (tmp_13526_.tag == 6);
        succ_8636_ &= true;
        ParsedPattern_s **subpat = &tmp_13526_.payload.variant6._1;
        succ_8636_ &= true;
        if (succ_8636_) {
            {
            }
            goto after_13526;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13526;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13526:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((emergencyPrintPS3900S8951rN)((this), ((pat)->span)));
    ((emergencyPrintPS3900S8951rN)((this), ((expr)->span)));
    ((unreachablePcrN)(("inferPatternOntoExpr: Exhaustive handling of patterns")));
}
TCState_u inferTypeOntoExprPS3900uszuszPS5541rU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900uszuszPS5541BrU9661)((this), (exprID), (typeID), (scopes), (false)));
}
TCState_u inferTypeOntoExprPS3900uszPU5175PS5541rU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (type), (scopes), (false)));
}
TCState_u inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (expr), (type), (scopes), (false)));
}
TCState_u tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (type), (scopes), (checkOnly)));
}
TCState_u tryInferTypeOntoExprPS3900uszuszPS5541BrU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes, bool checkOnly) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), ((atPS4174uszrPU5175)((&(types)), (typeID))), (scopes), (checkOnly)));
}
TCState_u tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    if ((isSuccessPU9661rB)((&((expr)->typeState)))) {
        Type_u *exprType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
        if (!((equalsPU5175PU5175rB)((exprType), (type))))
            ((todo_with_msgPcrN)(("infer failed")));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
    }

    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8643_ = true;
    bool succ_8662_ = true;
    bool succ_8681_ = true;
    bool succ_8685_ = true;
    bool succ_8689_ = true;
    bool succ_8693_ = true;
    bool succ_8696_ = true;
    bool succ_8703_ = true;
    bool succ_8718_ = true;
    bool succ_8723_ = true;
    bool succ_8729_ = true;

    ExprData_u *tmp_13736_ = (&((expr)->data));
    {
        succ_8643_ &= (tmp_13736_->tag == 0);
        Token_s *value = &tmp_13736_->payload.variant0._0;
        succ_8643_ &= true;
        if (succ_8643_) {
            {
                if ((isCharPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Using integer literal to initialize value of type char.\n"), ((l).buffer), (WARN_STR)));
                        ((dropPS0540rN)((&(l))));
                    }

                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                }

                else if (((isIntegerPU5175rB)((type))) || ((isFloatPU5175rB)((type)))) {
                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                }

                else if ((isPointerPU5175rB)((type))) {
                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
                }

                else if ((isBooleanPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n"), ((l).buffer), (ERR_STR), ((s).buffer)));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }

                else if ((isArrayPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected array, found `%s`.\n"), ((l).buffer), (ERR_STR), ((s).buffer)));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }

                else {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected value of type %s, found `%s`.\n"), ((l).buffer), (ERR_STR), ((t).buffer), ((s).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }
            }
            goto after_13736;
        }
    }
    {
        succ_8662_ &= (tmp_13736_->tag == 3);
        ArrayContext_s *context = &tmp_13736_->payload.variant3._0;
        succ_8662_ &= true;
        if (succ_8662_) {
            {
                bool succ_8667_ = true;

                Type_u *tmp_13635_ = (type);
                {
                    succ_8667_ &= (tmp_13635_->tag == 5);
                    Type_u **under = &tmp_13635_->payload.variant5._0;
                    succ_8667_ &= true;
                    usize *size = &tmp_13635_->payload.variant5._1;
                    succ_8667_ &= true;
                    if (succ_8667_) {
                        {
                            if (((*context).size) == ((usize)(0llu))) {
                                if ((*size) != ((*context).elemLength)) {
                                    if (!(checkOnly)) {
                                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                        (((fprintf))((stderr_), ("%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n"), ((loc).buffer), (ERR_STR), (*size),
                                                     ((*context).elemLength)));
                                        ((dropPS0540rN)((&(loc))));
                                        (((this)->typeError) = (true));
                                    }

                                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ARRAY_SIZE_MISMATCH)}}});
                                }

                                TCState_u lastErrState = (((TCState_u){.tag = 0, .payload = {0}}));
                                for (usize i = ((usize)(0llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                                    ((tid) = ((tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661)((this), ((getElementAtIndexPS8905uszrusz)((&(*context)), (i))), (*under), (scopes), (checkOnly))));
                                    if ((isErrorPU9661rB)((&(tid))))
                                        ((lastErrState) = (tid));
                                }

                                if (!((isInvalidPU9661rB)((&(lastErrState)))))
                                    return (lastErrState);
                            }

                            else {
                                if ((*size) != ((*context).size)) {
                                    if (!(checkOnly)) {
                                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                        (((fprintf))((stderr_), ("%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n"), ((loc).buffer), (ERR_STR), (*size),
                                                     ((*context).size)));
                                        ((dropPS0540rN)((&(loc))));
                                        (((this)->typeError) = (true));
                                    }

                                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ARRAY_SIZE_MISMATCH)}}});
                                }

                                ((tid) =
                                     ((tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661)((this), ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu)))), (*under), (scopes), (checkOnly))));
                                if ((isErrorPU9661rB)((&(tid))))
                                    return (tid);
                            }

                            ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                        }
                        goto after_13635;
                    }
                }
                {
                    if (true) {
                        {
                            if (!(checkOnly)) {
                                String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                String_s t = ((toStringPU5175rS0540)((type)));
                                (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found array literal.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                                ((dropPS0540rN)((&(t))));
                                ((dropPS0540rN)((&(loc))));
                            }

                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                        }
                        goto after_13635;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13635:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13736;
        }
    }
    {
        succ_8681_ &= (tmp_13736_->tag == 4);
        IdentExpr_s *ident = &tmp_13736_->payload.variant4._0;
        succ_8681_ &= true;
        if (succ_8681_) {
            {
                ((tid) = ((tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661)((this), (&(*ident)), (type), (scopes), (checkOnly))));
            }
            goto after_13736;
        }
    }
    {
        succ_8685_ &= (tmp_13736_->tag == 5);
        UnaryExpr_u *unary = &tmp_13736_->payload.variant5._0;
        succ_8685_ &= true;
        if (succ_8685_) {
            {
                ((tid) = ((tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661)((this), ((expr)->span), (&(*unary)), (type), (scopes), (checkOnly))));
            }
            goto after_13736;
        }
    }
    {
        succ_8689_ &= (tmp_13736_->tag == 6);
        BinaryExpr_u *binary = &tmp_13736_->payload.variant6._0;
        succ_8689_ &= true;
        if (succ_8689_) {
            {
                ((tid) = ((tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661)((this), (&(*binary)), (type), (scopes), (checkOnly))));
            }
            goto after_13736;
        }
    }
    {
        succ_8693_ &= (tmp_13736_->tag == 7);
        CallExpr_s *call = &tmp_13736_->payload.variant7._0;
        succ_8693_ &= true;
        if (succ_8693_) {
            {
                ((tid) = ((tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661)((this), (&(*call)), (type), (scopes), (checkOnly))));
            }
            goto after_13736;
        }
    }
    {
        succ_8696_ &= (tmp_13736_->tag == 12);
        if (succ_8696_) {
            {
                if (!((isPointerPU5175rB)((type)))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Can\'t use `null` to initialize value of type %s.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NULL_NON_PTR)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13736;
        }
    }
    {
        succ_8703_ &= (tmp_13736_->tag == 13);
        if (succ_8703_) {
            {
                if ((isPointerPU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_BLANK_FOR_NULL)}}});
                }

                else if ((isPrimitivePU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n"), ((loc).buffer), (WARN_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                }

                else if ((isUnionPU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Using `blank` to initialize value of type %s.\n"), ((loc).buffer), (WARN_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13736;
        }
    }
    {
        succ_8718_ &= (tmp_13736_->tag == 14);
        if (succ_8718_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found `true`.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13736;
        }
    }
    {
        succ_8723_ &= (tmp_13736_->tag == 15);
        if (succ_8723_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found `false`.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13736;
        }
    }
    {
        succ_8729_ &= (tmp_13736_->tag == 20);
        ParsedExprList_s *exprElems = &tmp_13736_->payload.variant20._0;
        succ_8729_ &= true;
        if (succ_8729_) {
            {
                bool succ_8733_ = true;

                Type_u *tmp_13713_ = (type);
                succ_8733_ &= (tmp_13713_->tag == 10);
                TypeList_s *typeElems = &tmp_13713_->payload.variant10._0;
                succ_8733_ &= true;
                if (!succ_8733_) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found tuple.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                };
                if (((*typeElems).length) != ((*exprElems).length)) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Expected tuple with %llu elements, found %llu.\n"), ((loc).buffer), (ERR_STR), ((*typeElems).length), ((*exprElems).length)));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                for (usize i = ((usize)(0llu)); ((i) < ((*typeElems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *_expr = ((((*exprElems).elements))[(i)]);
                    Type_u *_type = ((((*typeElems).elements))[(i)]);
                    TCState_u state = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (_expr), (_type), (scopes), (checkOnly)));
                    if ((isErrorPU9661rB)((&(state))))
                        return (state);
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13736;
        }
    }
    {
        ExprData_u **unknown = &tmp_13736_;
        if (true) {
            {
                String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                (((fprintf))((stderr_), ("%s %s: tryInferTypeOntoExpr: Unknown tag %hhu!\n"), (FATAL_STR), ((loc).buffer), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_13736;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13736:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (!(checkOnly)) {
        (((*(expr)).typeState) = (tid));
    }

    return (tid);
}
TCState_u tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661(TypeChecker_s *this, Span_s span, UnaryExpr_u *unary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8748_ = true;
    bool succ_8754_ = true;
    bool succ_8767_ = true;
    bool succ_8777_ = true;

    UnaryExpr_u *tmp_13792_ = (unary);
    {
        succ_8748_ &= (tmp_13792_->tag == 2);
        ParsedExpr_s **subExpr = &tmp_13792_->payload.variant2._0;
        succ_8748_ &= true;
        if (succ_8748_) {
            {
                Type_u *newType = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (type)}}})));
                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (newType), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13792;
        }
    }
    {
        succ_8754_ &= (tmp_13792_->tag == 1);
        ParsedExpr_s **subExpr = &tmp_13792_->payload.variant1._0;
        succ_8754_ &= true;
        if (succ_8754_) {
            {
                bool succ_8758_ = true;

                Type_u *tmp_13763_ = (type);
                {
                    succ_8758_ &= (tmp_13763_->tag == 4);
                    Type_u **under = &tmp_13763_->payload.variant4._0;
                    succ_8758_ &= true;
                    if (succ_8758_) {
                        {
                            ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (*under), (scopes), (checkOnly))));
                            if ((isErrorPU9661rB)((&(tid))))
                                return (tid);
                            ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                        }
                        goto after_13763;
                    }
                }
                {
                    if (true) {
                        {
                            if (!(checkOnly)) {
                                String_s loc = ((toStringPS8951rS0540)((&(span))));
                                String_s t = ((toStringPU5175rS0540)((type)));
                                (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found reference.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                                ((dropPS0540rN)((&(t))));
                                ((dropPS0540rN)((&(loc))));
                                (((this)->typeError) = (true));
                            }

                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                        }
                        goto after_13763;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13763:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13792;
        }
    }
    {
        succ_8767_ &= (tmp_13792_->tag == 3);
        ParsedExpr_s **subExpr = &tmp_13792_->payload.variant3._0;
        succ_8767_ &= true;
        if (succ_8767_) {
            {
                if ((!((isSignedIntegerPU5175rB)((type)))) && (!((isFloatPU5175rB)((type))))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&(span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Negation is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (type), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((assertBPcrN)(((isTypePU9661rB)((&(tid)))), ("infer non-error expected to be a type")));
                Type_u *subType = ((getTypePU9661rPU5175)((&(tid))));
                ((assertBPcrN)(((equalsPU5175PU5175rB)((subType), (type))), ("Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr")));
                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13792;
        }
    }
    {
        succ_8777_ &= (tmp_13792_->tag == 4);
        ParsedExpr_s **subExpr = &tmp_13792_->payload.variant4._0;
        succ_8777_ &= true;
        if (succ_8777_) {
            {
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (boolType), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((todo_with_msgPcrN)(("unary not infer")));
            }
            goto after_13792;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in tryInferTypeOntoUnary")));
            }
            goto after_13792;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13792:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (tid);
}
TCState_u tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *binary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((binary), (&(lhs)), (&(rhs))));
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    BinaryExpr_u tmp_67580 = (((BinaryExpr_u){.tag = 1, .payload = {0}}));
    BinaryExpr_u tmp_67600 = (((BinaryExpr_u){.tag = 0, .payload = {0}}));

    if (((isArithmeticPU0121rB)((binary))) || ((isBitwisePU0121rB)((binary)))) {
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), (type), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (rhs), (type), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if ((isComparisonPU0121rB)((binary))) {
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), (usizeType), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (rhs), (usizeType), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if (((tagAnyru8)((binary))) == (((tagAnyru8)((&tmp_67580))))) {
        ((tid) = ((tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661)((this), (binary), (type), (scopes), (checkOnly))));
    }

    else if (((tagAnyru8)((binary))) == (((tagAnyru8)((&tmp_67600))))) {
        ((tid) = ((tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661)((this), (binary), (type), (scopes), (checkOnly))));
    }

    else {
        ((todo_with_msgPcrN)(("inferTypeOntoExpr for non-arith non-comp binary")));
    }

    return (tid);
}
TCState_u tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661(TypeChecker_s *this, IdentExpr_s *ident, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    VariableLookup_s var = ((VariableLookup_s){0});
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    if ((resolveVariableByNamePS0997PS6070PS5541PS6661rB)(((this)->currentModule), (&((ident)->name)), (scopes), (&(var)))) {
        ((unreachablePcrN)(("tryInferTypeOntoIdent: New let-statements prevent variables from ever being unresolved")));
        ((assertBPcrN)(((wantsInferPU9661rB)((&((var).typeState)))), ("Ident has no type, but variable doesn\'t want infer")));
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
        (((var).typeState) = (tid));
        ParsedStmt_s *stmt = ((atPS8227uszrPS1100)((&(stmts)), ((var).globalID)));
        bool succ_8794_ = true;

        StmtData_u tmp_13837_ = ((stmt)->data);
        {
            succ_8794_ &= (tmp_13837_.tag == 0);
            VarDecl_s *decl = &tmp_13837_.payload.variant0._0;
            succ_8794_ &= true;
            if (succ_8794_) {
                {
                    ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((*decl).expr), (type), (scopes), (checkOnly))));
                }
                goto after_13837;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("VariableLookup points to non-VarDecl")));
                }
                goto after_13837;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13837:
        (void)0; // error: label at end of compound statement is a C23 extension
        if ((isErrorPU9661rB)((&(tid)))) {
            String_s loc = ((toStringPS8951rS0540)((&(((ident)->name).span))));
            String_s name = ((toStringPS7720rS0540)((&(((ident)->name).content))));
            String_s typeName = ((toStringPU5175rS0540)((type)));
            (((fprintf))((stderr_), ("%s: %s: Variable `%s` inferred to be of type %s here.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer), ((typeName).buffer)));
            ((dropPS0540rN)((&(typeName))));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
        }

        (((stmt)->typeState) = (tid));
    }

    else if ((isFunctionPU5175rB)((type))) {
        MLConfig_s config = ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (false), .checkParent = (true), .allowData = (false)});
        FunctionLookupList_s functions = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)(((this)->currentModule), (&((ident)->name)), (type), (config)));
        if (((functions).length) == ((usize)(0llu))) {
            (((config).allowData) = (true));
            ((functions) = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)(((this)->currentModule), (&((ident)->name)), (type), (config))));
            if (((functions).length) == ((usize)(0llu))) {
                if (checkOnly) {
                    ((tid) = ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_FUNCTION)}}}));
                }

                else {
                    FunctionLookupList_s all = ((resolveFunctionByNamePS0997PS6070rS8385)(((this)->currentModule), (&((ident)->name))));
                    ((tid) = ((reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661)((this), ((ident)->name), (type), (&(all)))));
                    ((dropPS8385rN)((&(all))));
                }

            }

            else if (((functions).length) == ((usize)(1llu))) {
                FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
                if (!(checkOnly)) {
                    (((ident)->origID) = ((f)->globalID));
                }

                ((tid) = ((f)->fnType));
            }

            else {
                ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
            }

        }

        else if (((functions).length) == ((usize)(1llu))) {
            FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
            if (!(checkOnly)) {
                (((ident)->origID) = ((f)->globalID));
            }

            ((tid) = ((f)->fnType));
        }

        else {
            ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
        }

        ((dropPS8385rN)((&(functions))));
    }

    else {
        return ((reportUnknownIdentifierPS3900PS6070rU9661)((this), (&((ident)->name))));
    }

    if ((isTypePU9661rB)((&(tid)))) {
        (((ident)->type) = ((getTypePU9661rPU5175)((&(tid)))));
    }

    return (tid);
}
TCState_u tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661(TypeChecker_s *this, CallExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    TypeList_s params = ((TypeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TCState_u *state = (&((*((atPS7823uszrPPS2435)((&((expr)->args)), (i))))->typeState));
        Type_u *typ = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}}))));
        if ((isTypePU9661rB)((state)))
            ((typ) = ((getTypePU9661rPU5175)((state))));
        ((pushPS0643PU5175rN)((&(params)), (typ)));
    }

    Type_u *fnType = ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = (type), ._2 = ((FuncAttr_s){0})}}})));
    TCState_u baseState = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((expr)->base), (fnType), (scopes), (checkOnly)));
    if ((isErrorPU9661rB)((&(baseState))))
        return (baseState);
    if ((wantsInferPU9661rB)((&(baseState)))) {
        return ((reportFunctionCallTooManyOptionsPS3900PS3328rU9661)((this), (expr)));
    }

    ((assertBPcrN)(((isTypePU9661rB)((&(baseState)))), ("tryInferOntoCall: Base is not a type")));
    Type_u *baseFunc = ((getTypePU9661rPU5175)((&(baseState))));
    ((assertBPcrN)(((isFunctionPU5175rB)((baseFunc))), ("tryInferTypeOntoCall: Base is not a function")));
    TCState_u state = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *p = ((getParamPU5175uszrPU5175)((baseFunc), (i)));
        TCState_u s1 = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*((atPS7823uszrPPS2435)((&((expr)->args)), (i)))), (p), (scopes), (checkOnly)));
        if ((isErrorPU9661rB)((&(s1)))) {
            ((state) = (s1));
        }
    }

    if (!((isSuccessPU9661rB)((&(state))))) {
        ((todo_with_msgPcrN)(("infer arg failed")));
    }

    if (checkOnly)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    (((expr)->retType) = (type));
    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
}
TCState_u tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    bool succ_8825_ = true;

    ExprData_u *tmp_13951_ = (&((rhs)->data));
    {
        succ_8825_ &= (tmp_13951_->tag == 4);
        IdentExpr_s *ident = &tmp_13951_->payload.variant4._0;
        succ_8825_ &= true;
        if (succ_8825_) {
            {
                Token_s name = ((*ident).name);
                StructLookupList_s structs = ((resolveAllStructsWithFieldPS0997PS6070PU5175rS7392)(((this)->currentModule), (&(name)), (type)));
                if (((structs).length) == ((usize)(0llu))) {
                    return ((reportMemberAccessNoOptionsPS3900S8951rU9661)((this), ((lhs)->span)));
                }

                else if (((structs).length) == ((usize)(1llu))) {
                    StructLookup_s *struct_ = ((atPS7392uszrPS4228)((&(structs)), ((usize)(0llu))));
                    TCState_u state = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), ((struct_)->type), (scopes), (checkOnly)));
                    if ((isErrorPU9661rB)((&(state))))
                        return (state);
                    if (checkOnly)
                        return (((TCState_u){.tag = 1, .payload = {0}}));
                    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
                }

                else {
                    if (!(checkOnly)) {
                        return ((reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661)((this), ((lhs)->span), (&(structs))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }
            }
            goto after_13951;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13951;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13951:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess")));
}
TCState_u tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((lhs)->typeState);
    if (!((isSuccessPU9661rB)((&(lhsState)))))
        return (lhsState);
    if (!((isTypePU9661rB)((&(lhsState)))))
        return (lhsState);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    ModuleLookup_s *lookup = (NULL);
    bool succ_8842_ = true;

    Type_u *tmp_13967_ = (lhsType);
    {
        succ_8842_ &= (tmp_13967_->tag == 9);
        ParsedModule_s **decl = &tmp_13967_->payload.variant9._0;
        succ_8842_ &= true;
        if (succ_8842_) {
            {
                ((lookup) = ((getModuleByGlobalIDPS0997uszrPS0997)(((this)->currentModule), ((getIDPS1882rusz)((*decl))))));
            }
            goto after_13967;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("LHS of BIN_MODULE is not of type module!")));
            }
            goto after_13967;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13967:
    (void)0; // error: label at end of compound statement is a C23 extension
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8848_ = true;

    ExprData_u *tmp_13997_ = (&((rhs)->data));
    {
        succ_8848_ &= (tmp_13997_->tag == 4);
        IdentExpr_s *ident = &tmp_13997_->payload.variant4._0;
        succ_8848_ &= true;
        if (succ_8848_) {
            {
                ((assertBPcrN)(((isFunctionPU5175rB)((type))), ("Can only try to infer functions onto module identifiers for now")));
                FunctionLookupList_s functions = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385)((lookup), (&((*ident).name)), (type)));
                if (((functions).length) == ((usize)(0llu))) {
                    if (checkOnly) {
                        ((tid) = ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_FUNCTION)}}}));
                    }

                    else {
                        FunctionLookupList_s all = ((resolveFunctionByNamePS0997PS6070rS8385)((lookup), (&((*ident).name))));
                        ((tid) = ((reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661)((this), ((*ident).name), (type), (&(all)))));
                        ((dropPS8385rN)((&(all))));
                    }

                }

                else if (((functions).length) == ((usize)(1llu))) {
                    FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
                    if (!(checkOnly)) {
                        (((*ident).origID) = ((f)->globalID));
                    }

                    ((tid) = ((f)->fnType));
                }

                else {
                    ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
                }

                (((rhs)->typeState) = (tid));
                if ((isTypePU9661rB)((&(tid)))) {
                    (((*ident).type) = ((getTypePU9661rPU5175)((&(tid)))));
                }

                ((dropPS8385rN)((&(functions))));
            }
            goto after_13997;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of possibilities in tryInferTypeOntoModuleAccess")));
            }
            goto after_13997;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13997:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (tid);
}
TCState_u typeCheckExprArithmeticPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ((assertBPcrN)(((isArithmeticPU0121rB)((expr))), ("Expr expected to be arithmetic")));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    bool lhsPointer = (false);
    bool rhsPointer = (false);
    if ((isTypePU9661rB)((&(lhsState))))
        if ((isPointerPU5175rB)(((getTypePU9661rPU5175)((&(lhsState))))))
            ((lhsPointer) = (true));
    if ((isTypePU9661rB)((&(rhsState))))
        if ((isPointerPU5175rB)(((getTypePU9661rPU5175)((&(rhsState))))))
            ((rhsPointer) = (true));
    if ((lhsPointer) || (rhsPointer)) {
        bool succ_8868_ = true;
        bool succ_8872_ = true;

        BinaryExpr_u *tmp_14021_ = (expr);
        {
            succ_8868_ &= (tmp_14021_->tag == 3);
            succ_8868_ &= true;
            if (succ_8868_) {
                {
                }
                goto after_14021;
            }
        }
        {
            succ_8872_ &= (tmp_14021_->tag == 4);
            succ_8872_ &= true;
            if (succ_8872_) {
                {
                }
                goto after_14021;
            }
        }
        {
            BinaryExpr_u **other = &tmp_14021_;
            if (true) {
                {
                    return ((reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661)((this), ((binOpAsStrPU0121rPc)((*other))), ((lhs)->span), ((rhs)->span)));
                }
                goto after_14021;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14021:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    TCState_u resultState = (((TCState_u){.tag = 0, .payload = {0}}));
    if ((equalsPU5175PU5175rB)((lhsType), (rhsType))) {
        BinaryExpr_u tmp_68410 = (((BinaryExpr_u){.tag = 3, .payload = {0}}));

        u8 p = ((tagAnyru8)((&tmp_68410)));
        BinaryExpr_u tmp_68416 = (((BinaryExpr_u){.tag = 4, .payload = {0}}));

        u8 s = ((tagAnyru8)((&tmp_68416)));
        if ((((isCharPU5175rB)((lhsType))) && (((tagAnyru8)((expr))) != (p))) && (((tagAnyru8)((expr))) != (s))) {
            return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
        }

        if (((isStructPU5175rB)((lhsType))) || ((isArrayPU5175rB)((lhsType)))) {
            return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
        }

        else if ((isPointerPU5175rB)((lhsType))) {
            ((resultState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
        }

        else {
            ((resultState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (lhsType)}}}));
        }

    }

    else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
        bool succ_8887_ = true;
        bool succ_8885_ = true;

        Type_u *tmp_14054_ = (rhsType);
        {
            succ_8887_ &= (tmp_14054_->tag == 3);
            succ_8885_ &= (tmp_14054_->payload.variant3._0.tag == 8);
            succ_8887_ &= succ_8885_;
            if (succ_8887_) {
                {
                    ((resultState) = (lhsState));
                }
                goto after_14054;
            }
        }
        {
            if (true) {
                {
                    TCState_u err = ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
                    String_s loc = ((toStringPS8951rS0540)((&((rhs)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Pointer offsets must be of type usize.\n"), ((loc).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(loc))));
                    return (err);
                }
                goto after_14054;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14054:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
        bool succ_8895_ = true;
        bool succ_8893_ = true;

        Type_u *tmp_14064_ = (lhsType);
        {
            succ_8895_ &= (tmp_14064_->tag == 3);
            succ_8893_ &= (tmp_14064_->payload.variant3._0.tag == 8);
            succ_8895_ &= succ_8893_;
            if (succ_8895_) {
                {
                    ((resultState) = (rhsState));
                }
                goto after_14064;
            }
        }
        {
            if (true) {
                {
                    TCState_u err = ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
                    String_s loc = ((toStringPS8951rS0540)((&((lhs)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Pointer offsets must be of type usize.\n"), ((loc).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(loc))));
                    return (err);
                }
                goto after_14064;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14064:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    return (resultState);
}
TCState_u typeCheckExprComparisonPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ((assertBPcrN)(((isComparisonPU0121rB)((expr))), ("Expr expected to be comparison")));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    if (((((isStructPU5175rB)((lhsType))) || ((isStructPU5175rB)((rhsType)))) || ((isArrayPU5175rB)((lhsType)))) || ((isArrayPU5175rB)((rhsType)))) {
        ((todo_with_msgPcrN)(("report error, can\'t compare structs or arrays using == or similar.")));
    }

    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}});
}
TCState_u typeCheckTypeNodePS3900PS1372rU9661(TypeChecker_s *this, ParsedTypeNode_s *typeNode) {
    if ((typeNode)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((typeNode)->typeState))))
        return ((typeNode)->typeState);
    Type_u *tid = (NULL);
    if (((typeNode)->kind) == (PARSED_TYPE_FUNC)) {
        TCState_u retState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(retState))))
            return (retState);
        TypeList_s params = ((TypeList_s){0});
        TCState_u error = (((TCState_u){.tag = 0, .payload = {0}}));
        bool is_variadic = (false);
        for (usize i = ((usize)(0llu)); ((i) < (((typeNode)->fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
            TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*((atPS6760uszrPPS1372)((&((typeNode)->fnParams)), (i))))));
            if ((isErrorPU9661rB)((&(state)))) {
                ((error) = (state));
            }

            else {
                Type_u *typ = ((getTypePU9661rPU5175)((&(state))));
                if ((isVariadicPU5175rB)((typ)))
                    ((is_variadic) = (true));
                ((pushPS0643PU5175rN)((&(params)), (typ)));
            }
        }

        if ((isErrorPU9661rB)((&(error))))
            return (error);
        ((tid) =
             ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = ((getTypePU9661rPU5175)((&(retState)))), ._2 = ((FuncAttr_s){.isVariadic = (is_variadic)})}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_REF)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((getTypePU9661rPU5175)((&(under))))}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_ARRAY)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = ((getTypePU9661rPU5175)((&(under)))), ._1 = ((typeNode)->arraySize)}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_IDENT)) {
        Token_s name = ((typeNode)->nameTkn);
        TypeLookup_s typeLookup = ((TypeLookup_s){0});
        if (!((resolveTypeByNamePS0997PS7720PS6177rB)(((this)->currentModule), (&((name).content)), (&(typeLookup))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(name))));
            String_s _n = ((toStringPS7720rS0540)((&((name).content))));
            (((fprintf))((stderr_), ("%s: %s: Use of undeclared type identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n).buffer)));
            TypeLookupList_s alternatives = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((&((this)->lookup)), (&((name).content))));
            return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (NULL), (name), (alternatives)));
        }

        if ((isStructPS6177rB)((&(typeLookup)))) {
            StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(typeLookup))));
            ((tid) = ((structLookup)->type));
            ((assertBPcrN)(((isStructPU5175rB)((tid))), ("Struct Lookup links to non-Struct typeNode")));
        }

        else if ((isUnionPS6177rB)((&(typeLookup)))) {
            UnionLookup_s *unionLookup = ((asUnionPS6177rPS1592)((&(typeLookup))));
            ((tid) = ((unionLookup)->type));
            ((assertBPcrN)(((isUnionPU5175rB)((tid))), ("Union Lookup links to non-Union typeNode")));
        }

        else {
            ((unreachablePcrN)(("Exhaustive handling of TypeLookup kinds in typeCheckTypeNode")));
        }

    }

    else if (((typeNode)->kind) == (PARSED_TYPE_MODULE)) {
        ParsedTypeNode_s *_orig = (typeNode);
        ModuleLookup_s *moduleLookup = (NULL);
        Token_s name = ((typeNode)->nameTkn);
        if (!((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (&(name)), (&(moduleLookup))))) {
            return ((reportUnknownModulePS3900S6070rU9661)((this), (name)));
        }

        while (true) {
            ParsedTypeNode_s *sub = ((typeNode)->underlyingID);
            if (((sub)->underlyingID) == (NULL)) {
                TypeLookup_s lookup = ((TypeLookup_s){0});
                if (!((resolveTypeByNamePS0997PS7720PS6177rB)((moduleLookup), (&(((sub)->nameTkn).content)), (&(lookup))))) {
                    return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (moduleLookup), ((sub)->nameTkn), ((TypeLookupList_s){0})));
                }

                if ((isStructPS6177rB)((&(lookup)))) {
                    StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
                    ((tid) = ((structLookup)->type));
                    ((assertBPcrN)(((isStructPU5175rB)((tid))), ("Struct Lookup links to non-Struct typeNode")));
                    break;
                }

                else if ((isUnionPS6177rB)((&(lookup)))) {
                    UnionLookup_s *unionLookup = ((asUnionPS6177rPS1592)((&(lookup))));
                    ((tid) = ((unionLookup)->type));
                    ((assertBPcrN)(((isUnionPU5175rB)((tid))), ("Union Lookup links to non-Union typeNode")));
                    break;
                }

                else {
                    ((todo_with_msgPcrN)(("module::<typeNode> with typeNode != struct && != union")));
                }

            }

            else {
                ((name) = ((sub)->nameTkn));
                ModuleLookup_s *newModule = (NULL);
                if (!((resolveModuleByNamePS0997PS6070PPS0997rB)((moduleLookup), (&(name)), (&(newModule))))) {
                    return ((reportUnknownSubmodulePS3900PS0997S6070rU9661)((this), (moduleLookup), (name)));
                }

                Type_u *modType = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((newModule)->globalID)))}}})));
                (((typeNode)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (modType)}}}));
                ((typeNode) = (sub));
                ((moduleLookup) = (newModule));
            }
        }

        ((typeNode) = (_orig));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_VARIADIC)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 2, .payload = {.variant2 = {._0 = ((getTypePU9661rPU5175)((&(under))))}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_TUPLE)) {
        TypeList_s elems = ((TypeList_s){0});
        TCState_u error = (((TCState_u){.tag = 0, .payload = {0}}));
        for (usize i = ((usize)(0llu)); ((i) < (((typeNode)->fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
            TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*((atPS6760uszrPPS1372)((&((typeNode)->fnParams)), (i))))));
            if ((isErrorPU9661rB)((&(state)))) {
                ((error) = (state));
            }

            else {
                ((pushPS0643PU5175rN)((&(elems)), ((getTypePU9661rPU5175)((&(state))))));
            }
        }

        if ((isErrorPU9661rB)((&(error))))
            return (error);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 10, .payload = {.variant10 = {._0 = (elems)}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_BUILTIN)) {
        usize id = ((getIDPS1372rusz)((typeNode)));
        PrimType_u prim = (((PrimType_u){.tag = 11}));
        if ((id) == (PARSED_TYPE_NONE))
            ((prim) = (((PrimType_u){.tag = 11})));
        else if ((id) == (PARSED_TYPE_ANY))
            ((prim) = (((PrimType_u){.tag = 9})));
        else if ((id) == (PARSED_TYPE_I8))
            ((prim) = (((PrimType_u){.tag = 4})));
        else if ((id) == (PARSED_TYPE_I16))
            ((prim) = (((PrimType_u){.tag = 5})));
        else if ((id) == (PARSED_TYPE_I32))
            ((prim) = (((PrimType_u){.tag = 6})));
        else if ((id) == (PARSED_TYPE_I64))
            ((prim) = (((PrimType_u){.tag = 7})));
        else if ((id) == (PARSED_TYPE_U8))
            ((prim) = (((PrimType_u){.tag = 0})));
        else if ((id) == (PARSED_TYPE_U16))
            ((prim) = (((PrimType_u){.tag = 1})));
        else if ((id) == (PARSED_TYPE_U32))
            ((prim) = (((PrimType_u){.tag = 2})));
        else if ((id) == (PARSED_TYPE_U64))
            ((prim) = (((PrimType_u){.tag = 3})));
        else if ((id) == (PARSED_TYPE_USIZE))
            ((prim) = (((PrimType_u){.tag = 8})));
        else if ((id) == (PARSED_TYPE_BOOL))
            ((prim) = (((PrimType_u){.tag = 10})));
        else if ((id) == (PARSED_TYPE_CHAR))
            ((prim) = (((PrimType_u){.tag = 12})));
        else if ((id) == (PARSED_TYPE_F32))
            ((prim) = (((PrimType_u){.tag = 13})));
        else if ((id) == (PARSED_TYPE_F64))
            ((prim) = (((PrimType_u){.tag = 14})));
        else {
            ((unreachablePcrN)(("Exhaustive handling of parsed types in typeCheckTypeNode")));
        }

        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (prim)}}}))));
    }

    else {
        ((todo_with_msgPcrN)(("unknown typeNode kind")));
    }

    TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (tid)}}});
    (((typeNode)->typeState) = (state));
    return (state);
}
TypeChecker_s newTypeCheckerrS3900(none) {
    return ((TypeChecker_s){.comptimeDepth = ((usize)(0llu)), .currentModule = (NULL), .currentFunction = (NULL), .lookup = ((Lookup_s){0}), .typeError = (false)});
}
none addElementPS8905PS2435rN(ArrayContext_s *this, ParsedExpr_s *elem) {
    if (((this)->elemLength) >= ((this)->elemCapacity)) {
        usize newCap = (((this)->elemCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->elemList) = (((realloc))(((this)->elemList), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elemList) != (NULL)), ("Could not resize elem list")));
        (((this)->elemCapacity) = (newCap));
    }

    (((((this)->elemList))[((this)->elemLength)]) = ((getIDPS2435rusz)((elem))));
    (((this)->elemLength) = (((this)->elemLength) + ((usize)(1llu))));
}
usize getElementAtIndexPS8905uszrusz(ArrayContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->elemLength)), ("Out of bounds access in ArrayContext.getElementAtIndex")));
    return ((((this)->elemList))[(index)]);
}
none addFieldPS7871S6070PS1372rN(StructContext_s *this, Token_s name, ParsedTypeNode_s *typ) {
    if (((this)->fieldLength) >= ((this)->fieldCapacity)) {
        usize newCap = (((this)->fieldCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->fieldNames) = (((realloc))(((this)->fieldNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->fieldTypes) = (((realloc))(((this)->fieldTypes), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->fieldNames) != (NULL)), ("Could not resize field list")));
        ((assertBPcrN)((((this)->fieldTypes) != (NULL)), ("Could not resize field list")));
        (((this)->fieldCapacity) = (newCap));
    }

    (((((this)->fieldNames))[((this)->fieldLength)]) = (name));
    (((((this)->fieldTypes))[((this)->fieldLength)]) = (typ));
    (((this)->fieldLength) = (((this)->fieldLength) + ((usize)(1llu))));
}
Token_s getFieldNameAtIndexPS7871uszrS6070(StructContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructContext.getFieldNameAtIndex")));
    return ((((this)->fieldNames))[(index)]);
}
ParsedTypeNode_s *getFieldTypeAtIndexPS7871uszrPS1372(StructContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructContext.getFieldTypeAtIndex")));
    return ((((this)->fieldTypes))[(index)]);
}
usize getFieldIndexPS7871PS7720rusz(StructContext_s *this, SubStr_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s f = ((getFieldNameAtIndexPS7871uszrS6070)((this), (i)));
        if ((equalsPS7720PS7720rB)((&((f).content)), (name))) {
            return (i);
        }
    }

    ((unreachablePcrN)(("Expected to find field index at this point")));
}
usize getFieldOffsetPS7871PS7720rusz(StructContext_s *this, SubStr_s *name) {
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s f = ((getFieldNameAtIndexPS7871uszrS6070)((this), (i)));
        ParsedTypeNode_s *_t = ((getFieldTypeAtIndexPS7871uszrPS1372)((this), (i)));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((_t)->typeState)))), ("Expected valid field type in getFieldOffset")));
        Type_u *t = ((getTypePU9661rPU5175)((&((_t)->typeState))));
        if ((equalsPS7720PS7720rB)((&((f).content)), (name))) {
            return (offset);
        }

        ((offset) = ((offset) + ((getSizeInBytesPU5175rusz)((t)))));
    }

    ((unreachablePcrN)(("Expected to find field offset at this point")));
}
none addFieldPS6291S6070PS2435rN(StructInitContext_s *this, Token_s name, ParsedExpr_s *expr) {
    if (((this)->fieldLength) >= ((this)->fieldCapacity)) {
        usize newCap = (((this)->fieldCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->fieldNames) = (((realloc))(((this)->fieldNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->fieldExprs) = (((realloc))(((this)->fieldExprs), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->fieldNames) != (NULL)), ("Could not resize field list")));
        ((assertBPcrN)((((this)->fieldExprs) != (NULL)), ("Could not resize field list")));
        (((this)->fieldCapacity) = (newCap));
    }

    (((((this)->fieldNames))[((this)->fieldLength)]) = (name));
    (((((this)->fieldExprs))[((this)->fieldLength)]) = (expr));
    (((this)->fieldLength) = (((this)->fieldLength) + ((usize)(1llu))));
}
Token_s getFieldNameAtIndexPS6291uszrS6070(StructInitContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructInitContext.getFieldNameAtIndex")));
    return ((((this)->fieldNames))[(index)]);
}
ParsedExpr_s *getFieldExprAtIndexPS6291uszrPS2435(StructInitContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructInitContext.getFieldExprAtIndex")));
    return ((((this)->fieldExprs))[(index)]);
}
none addParameterPS9803S6070PS1372rN(ParamContext_s *this, Token_s name, ParsedTypeNode_s *typ) {
    if (((this)->paramLength) >= ((this)->paramCapacity)) {
        usize newCap = (((this)->paramCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->paramNames) = (((realloc))(((this)->paramNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->paramTypes) = (((realloc))(((this)->paramTypes), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->paramNames) != (NULL)), ("Could not resize param list")));
        ((assertBPcrN)((((this)->paramTypes) != (NULL)), ("Could not resize param list")));
        (((this)->paramCapacity) = (newCap));
    }

    (((((this)->paramNames))[((this)->paramLength)]) = (name));
    (((((this)->paramTypes))[((this)->paramLength)]) = (typ));
    (((this)->paramLength) = (((this)->paramLength) + ((usize)(1llu))));
}
bool hasThisPS9803rB(ParamContext_s *this) {
    if (((this)->paramLength) == ((usize)(0llu)))
        return (false);
    SubStr_s tmp_69878 = (((getNameAtIndexPS9803uszrS6070)((this), ((usize)(0llu)))).content);
    SubStr_s tmp_69883 = (((BUILD_A_KEYWORDPcrS7720)(("this"))));

    return ((equalsPS7720PS7720rB)((&tmp_69878), (&tmp_69883)));
}
Token_s getNameAtIndexPS9803uszrS6070(ParamContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->paramLength)), ("Out of bounds access in ParamContext.getNameAtIndex")));
    return ((((this)->paramNames))[(index)]);
}
ParsedTypeNode_s *getTypeAtIndexPS9803uszrPS1372(ParamContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->paramLength)), ("Out of bounds access in ParamContext.getTypeAtIndex")));
    return ((((this)->paramTypes))[(index)]);
}
usize nextMultipleOfuszuszrusz(usize a, usize b) {
    ((assertBPcrN)(((b) != ((usize)(0llu))), ("nextMultipleOf: b is 0!")));
    if (((a) % (b)) == ((usize)(0llu)))
        return (a);
    return ((a) + ((b) - ((a) % (b))));
}
usize index_of_typePS3131PU5175rusz(TypeInfoTable_s *table, Type_u *type) {
    String_s n = ((toStringPU5175rS0540)((type)));
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_69957 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_69962 = ((asSubStrPS0540rS7720)((&(n))));

        bool b = ((equalsPS7720PS7720rB)((&tmp_69957), (&tmp_69962)));
        if (b) {
            ((dropPS0540rN)((&(n))));
            return (i);
        }
    }

    ((dropPS0540rN)((&(n))));
    return ((table)->length);
}
bool containsInvalidTypePU5175rB(Type_u *this) {
    bool succ_9007_ = true;
    bool succ_9010_ = true;
    bool succ_9014_ = true;
    bool succ_9018_ = true;
    bool succ_9022_ = true;
    bool succ_9027_ = true;
    bool succ_9033_ = true;
    bool succ_9039_ = true;
    bool succ_9044_ = true;
    bool succ_9048_ = true;
    bool succ_9052_ = true;

    Type_u *tmp_14405_ = (this);
    {
        succ_9007_ &= (tmp_14405_->tag == 0);
        if (succ_9007_) {
            {
                return (true);
            }
            goto after_14405;
        }
    }
    {
        succ_9010_ &= (tmp_14405_->tag == 1);
        if (succ_9010_) {
            {
                return (true);
            }
            goto after_14405;
        }
    }
    {
        succ_9014_ &= (tmp_14405_->tag == 2);
        Type_u **under = &tmp_14405_->payload.variant2._0;
        succ_9014_ &= true;
        if (succ_9014_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14405;
        }
    }
    {
        succ_9018_ &= (tmp_14405_->tag == 3);
        succ_9018_ &= true;
        if (succ_9018_) {
            {
                return (false);
            }
            goto after_14405;
        }
    }
    {
        succ_9022_ &= (tmp_14405_->tag == 4);
        Type_u **under = &tmp_14405_->payload.variant4._0;
        succ_9022_ &= true;
        if (succ_9022_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14405;
        }
    }
    {
        succ_9027_ &= (tmp_14405_->tag == 5);
        Type_u **under = &tmp_14405_->payload.variant5._0;
        succ_9027_ &= true;
        succ_9027_ &= true;
        if (succ_9027_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14405;
        }
    }
    {
        succ_9033_ &= (tmp_14405_->tag == 6);
        TypeList_s *params = &tmp_14405_->payload.variant6._0;
        succ_9033_ &= true;
        Type_u **ret = &tmp_14405_->payload.variant6._1;
        succ_9033_ &= true;
        succ_9033_ &= true;
        if (succ_9033_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((containsInvalidTypePU5175rB)(((((*params).elements))[(i)])))
                        return (true);
                }

                return ((containsInvalidTypePU5175rB)((*ret)));
            }
            goto after_14405;
        }
    }
    {
        succ_9039_ &= (tmp_14405_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14405_->payload.variant7._0;
        succ_9039_ &= true;
        if (succ_9039_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14405;
        }
    }
    {
        succ_9044_ &= (tmp_14405_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14405_->payload.variant8._0;
        succ_9044_ &= true;
        succ_9044_ &= true;
        if (succ_9044_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14405;
        }
    }
    {
        succ_9048_ &= (tmp_14405_->tag == 9);
        ParsedModule_s **decl = &tmp_14405_->payload.variant9._0;
        succ_9048_ &= true;
        if (succ_9048_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14405;
        }
    }
    {
        succ_9052_ &= (tmp_14405_->tag == 10);
        TypeList_s *elems = &tmp_14405_->payload.variant10._0;
        succ_9052_ &= true;
        if (succ_9052_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((containsInvalidTypePU5175rB)(((((*elems).elements))[(i)])))
                        return (true);
                }

                return (false);
            }
            goto after_14405;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14405;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14405:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("containsInvalidType")));
}
String_s getMangledNamePU5175rS0540(Type_u *this) {
    bool succ_9059_ = true;
    bool succ_9094_ = true;
    bool succ_9102_ = true;
    bool succ_9111_ = true;
    bool succ_9120_ = true;
    bool succ_9131_ = true;
    bool succ_9138_ = true;
    bool succ_9145_ = true;

    Type_u *tmp_14508_ = (this);
    {
        succ_9059_ &= (tmp_14508_->tag == 3);
        PrimType_u *typ = &tmp_14508_->payload.variant3._0;
        succ_9059_ &= true;
        if (succ_9059_) {
            {
                bool succ_9062_ = true;
                bool succ_9064_ = true;
                bool succ_9066_ = true;
                bool succ_9068_ = true;
                bool succ_9070_ = true;
                bool succ_9072_ = true;
                bool succ_9074_ = true;
                bool succ_9076_ = true;
                bool succ_9078_ = true;
                bool succ_9080_ = true;
                bool succ_9082_ = true;
                bool succ_9084_ = true;
                bool succ_9086_ = true;
                bool succ_9088_ = true;
                bool succ_9090_ = true;

                PrimType_u tmp_14439_ = (*typ);
                {
                    succ_9062_ &= (tmp_14439_.tag == 0);
                    if (succ_9062_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u8")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9064_ &= (tmp_14439_.tag == 1);
                    if (succ_9064_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u16")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9066_ &= (tmp_14439_.tag == 2);
                    if (succ_9066_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u32")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9068_ &= (tmp_14439_.tag == 3);
                    if (succ_9068_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u64")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9070_ &= (tmp_14439_.tag == 4);
                    if (succ_9070_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i8")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9072_ &= (tmp_14439_.tag == 5);
                    if (succ_9072_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i16")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9074_ &= (tmp_14439_.tag == 6);
                    if (succ_9074_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i32")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9076_ &= (tmp_14439_.tag == 7);
                    if (succ_9076_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i64")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9078_ &= (tmp_14439_.tag == 8);
                    if (succ_9078_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("usz")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9080_ &= (tmp_14439_.tag == 9);
                    if (succ_9080_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("Any")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9082_ &= (tmp_14439_.tag == 10);
                    if (succ_9082_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("B")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9084_ &= (tmp_14439_.tag == 11);
                    if (succ_9084_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("N")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9086_ &= (tmp_14439_.tag == 12);
                    if (succ_9086_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("c")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9088_ &= (tmp_14439_.tag == 13);
                    if (succ_9088_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f32")));
                        }
                        goto after_14439;
                    }
                }
                {
                    succ_9090_ &= (tmp_14439_.tag == 14);
                    if (succ_9090_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f64")));
                        }
                        goto after_14439;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in getMangledName")));
                        }
                        goto after_14439;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14439:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14508;
        }
    }
    {
        succ_9094_ &= (tmp_14508_->tag == 4);
        Type_u **typ = &tmp_14508_->payload.variant4._0;
        succ_9094_ &= true;
        if (succ_9094_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("P")));
                String_s _s = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9102_ &= (tmp_14508_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14508_->payload.variant7._0;
        succ_9102_ &= true;
        if (succ_9102_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("S")));
                usize hash = ((hashPS7720uszrusz)((&(((*decl)->name).content)), ((usize)(4llu))));
                if ((hash) < ((usize)(10llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(100llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(1000llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                ((pushNumberPS0540uszrN)((&(s)), (hash)));
                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9111_ &= (tmp_14508_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14508_->payload.variant8._0;
        succ_9111_ &= true;
        succ_9111_ &= true;
        if (succ_9111_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("U")));
                usize hash = ((hashPS7720uszrusz)((&(((*decl)->name).content)), ((usize)(4llu))));
                if ((hash) < ((usize)(10llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(100llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(1000llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                ((pushNumberPS0540uszrN)((&(s)), (hash)));
                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9120_ &= (tmp_14508_->tag == 6);
        TypeList_s *params = &tmp_14508_->payload.variant6._0;
        succ_9120_ &= true;
        Type_u **ret = &tmp_14508_->payload.variant6._1;
        succ_9120_ &= true;
        succ_9120_ &= true;
        if (succ_9120_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("F")));
                String_s r = ((getMangledNamePU5175rS0540)((*ret)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((i) != (((*params).length) - ((usize)(1llu))))
                        ((pushCharPS0540crN)((&(s)), ('.')));
                    String_s p = ((getMangledNamePU5175rS0540)((*((atPS0643uszrPPU5175)((&(*params)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(p))));
                    ((dropPS0540rN)((&(p))));
                }

                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9131_ &= (tmp_14508_->tag == 5);
        Type_u **typ = &tmp_14508_->payload.variant5._0;
        succ_9131_ &= true;
        usize *size = &tmp_14508_->payload.variant5._1;
        succ_9131_ &= true;
        if (succ_9131_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("A")));
                String_s r = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                ((pushNumberPS0540uszrN)((&(s)), (*size)));
                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9138_ &= (tmp_14508_->tag == 2);
        Type_u **typ = &tmp_14508_->payload.variant2._0;
        succ_9138_ &= true;
        if (succ_9138_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("V")));
                String_s r = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                return (s);
            }
            goto after_14508;
        }
    }
    {
        succ_9145_ &= (tmp_14508_->tag == 10);
        TypeList_s *elems = &tmp_14508_->payload.variant10._0;
        succ_9145_ &= true;
        if (succ_9145_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("T")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((i) != (((*elems).length) - ((usize)(1llu))))
                        ((pushCharPS0540crN)((&(s)), ('.')));
                    String_s e = ((getMangledNamePU5175rS0540)((*((atPS0643uszrPPU5175)((&(*elems)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(e))));
                    ((dropPS0540rN)((&(e))));
                }

                return (s);
            }
            goto after_14508;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14508;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14508:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of types in Type.getMangledName")));
}
usize getIDPU5175rusz(Type_u *this) { return ((indexOfPS4174PU5175rusz)((&(types)), (this))); }
bool equalsPU5175PU5175rB(Type_u *this, Type_u *other) { return ((_equalsPU5175PU5175BrB)((this), (other), (true))); }
bool _equalsPU5175PU5175BrB(Type_u *this, Type_u *other, bool allowData) {
    if (allowData) {
        bool succ_9155_ = true;

        Type_u *tmp_14516_ = (this);
        {
            succ_9155_ &= (tmp_14516_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_14516_->payload.variant7._0;
            succ_9155_ &= true;
            if (succ_9155_) {
                {
                    if ((*decl)->isDataDefinition)
                        return (true);
                }
                goto after_14516;
            }
        }
        {
            if (true) {
                {
                }
                goto after_14516;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14516:
        (void)0; // error: label at end of compound statement is a C23 extension
        bool succ_9160_ = true;

        Type_u *tmp_14521_ = (other);
        {
            succ_9160_ &= (tmp_14521_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_14521_->payload.variant7._0;
            succ_9160_ &= true;
            if (succ_9160_) {
                {
                    if ((*decl)->isDataDefinition)
                        return (true);
                }
                goto after_14521;
            }
        }
        {
            if (true) {
                {
                }
                goto after_14521;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14521:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    bool succ_9164_ = true;

    Type_u *tmp_14527_ = (this);
    {
        succ_9164_ &= (tmp_14527_->tag == 0);
        if (succ_9164_) {
            {
                return (true);
            }
            goto after_14527;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14527;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14527:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9168_ = true;

    Type_u *tmp_14531_ = (other);
    {
        succ_9168_ &= (tmp_14531_->tag == 0);
        if (succ_9168_) {
            {
                return (true);
            }
            goto after_14531;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14531;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14531:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9173_ = true;
    bool succ_9188_ = true;
    bool succ_9186_ = true;
    bool succ_9202_ = true;

    Type_u *tmp_14553_ = (this);
    {
        succ_9173_ &= (tmp_14553_->tag == 4);
        Type_u **typ = &tmp_14553_->payload.variant4._0;
        succ_9173_ &= true;
        if (succ_9173_) {
            {
                bool succ_9178_ = true;
                bool succ_9176_ = true;
                bool succ_9182_ = true;

                Type_u *tmp_14538_ = (other);
                {
                    succ_9178_ &= (tmp_14538_->tag == 3);
                    succ_9176_ &= (tmp_14538_->payload.variant3._0.tag == 9);
                    succ_9178_ &= succ_9176_;
                    if (succ_9178_) {
                        {
                            return (true);
                        }
                        goto after_14538;
                    }
                }
                {
                    succ_9182_ &= (tmp_14538_->tag == 4);
                    Type_u **otyp = &tmp_14538_->payload.variant4._0;
                    succ_9182_ &= true;
                    if (succ_9182_) {
                        {
                            return ((equalsPU5175PU5175rB)((*typ), (*otyp)));
                        }
                        goto after_14538;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14538;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14538:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14553;
        }
    }
    {
        succ_9188_ &= (tmp_14553_->tag == 3);
        succ_9186_ &= (tmp_14553_->payload.variant3._0.tag == 9);
        succ_9188_ &= succ_9186_;
        if (succ_9188_) {
            {
                bool succ_9192_ = true;
                bool succ_9197_ = true;
                bool succ_9195_ = true;

                Type_u *tmp_14545_ = (other);
                {
                    succ_9192_ &= (tmp_14545_->tag == 4);
                    succ_9192_ &= true;
                    if (succ_9192_) {
                        {
                            return (true);
                        }
                        goto after_14545;
                    }
                }
                {
                    succ_9197_ &= (tmp_14545_->tag == 3);
                    succ_9195_ &= (tmp_14545_->payload.variant3._0.tag == 9);
                    succ_9197_ &= succ_9195_;
                    if (succ_9197_) {
                        {
                            return (true);
                        }
                        goto after_14545;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_14545;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14545:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14553;
        }
    }
    {
        succ_9202_ &= (tmp_14553_->tag == 3);
        PrimType_u *t = &tmp_14553_->payload.variant3._0;
        succ_9202_ &= true;
        if (succ_9202_) {
            {
                bool succ_9206_ = true;

                Type_u *tmp_14550_ = (other);
                {
                    succ_9206_ &= (tmp_14550_->tag == 3);
                    PrimType_u *o = &tmp_14550_->payload.variant3._0;
                    succ_9206_ &= true;
                    if (succ_9206_) {
                        {
                            return (((tagAnyru8)((&(*t)))) == ((tagAnyru8)((&(*o)))));
                        }
                        goto after_14550;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_14550;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14550:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14553;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14553;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14553:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (((tagAnyru8)((this))) != ((tagAnyru8)((other))))
        return (false);
    bool succ_9212_ = true;

    Type_u *tmp_14563_ = (this);
    {
        succ_9212_ &= (tmp_14563_->tag == 2);
        Type_u **typ1 = &tmp_14563_->payload.variant2._0;
        succ_9212_ &= true;
        if (succ_9212_) {
            {
                bool succ_9216_ = true;

                Type_u *tmp_14560_ = (other);
                {
                    succ_9216_ &= (tmp_14560_->tag == 2);
                    Type_u **typ2 = &tmp_14560_->payload.variant2._0;
                    succ_9216_ &= true;
                    if (succ_9216_) {
                        {
                            return ((equalsPU5175PU5175rB)((*typ1), (*typ2)));
                        }
                        goto after_14560;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14560;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14560:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14563;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14563;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14563:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9223_ = true;

    Type_u *tmp_14571_ = (this);
    {
        succ_9223_ &= (tmp_14571_->tag == 5);
        Type_u **typ1 = &tmp_14571_->payload.variant5._0;
        succ_9223_ &= true;
        usize *size1 = &tmp_14571_->payload.variant5._1;
        succ_9223_ &= true;
        if (succ_9223_) {
            {
                bool succ_9228_ = true;

                Type_u *tmp_14568_ = (other);
                {
                    succ_9228_ &= (tmp_14568_->tag == 5);
                    Type_u **typ2 = &tmp_14568_->payload.variant5._0;
                    succ_9228_ &= true;
                    usize *size2 = &tmp_14568_->payload.variant5._1;
                    succ_9228_ &= true;
                    if (succ_9228_) {
                        {
                            return (((*size1) == (*size2)) && ((equalsPU5175PU5175rB)((*typ1), (*typ2))));
                        }
                        goto after_14568;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14568;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14568:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14571;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14571;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14571:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9236_ = true;

    Type_u *tmp_14594_ = (this);
    {
        succ_9236_ &= (tmp_14594_->tag == 6);
        TypeList_s *params = &tmp_14594_->payload.variant6._0;
        succ_9236_ &= true;
        Type_u **ret = &tmp_14594_->payload.variant6._1;
        succ_9236_ &= true;
        FuncAttr_s *attr = &tmp_14594_->payload.variant6._2;
        succ_9236_ &= true;
        if (succ_9236_) {
            {
                bool succ_9242_ = true;

                Type_u *tmp_14591_ = (other);
                {
                    succ_9242_ &= (tmp_14591_->tag == 6);
                    TypeList_s *oparams = &tmp_14591_->payload.variant6._0;
                    succ_9242_ &= true;
                    Type_u **oret = &tmp_14591_->payload.variant6._1;
                    succ_9242_ &= true;
                    FuncAttr_s *oattr = &tmp_14591_->payload.variant6._2;
                    succ_9242_ &= true;
                    if (succ_9242_) {
                        {
                            if (((*attr).isVariadic) != ((*oattr).isVariadic))
                                return (false);
                            if (((*attr).isNoreturn) != ((*oattr).isNoreturn))
                                return (false);
                            if (((*params).length) != ((*oparams).length))
                                return (false);
                            if (!((equalsPU5175PU5175rB)((*ret), (*oret))))
                                return (false);
                            for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                Type_u *p1 = (*((atPS0643uszrPPU5175)((&(*params)), (i))));
                                Type_u *p2 = (*((atPS0643uszrPPU5175)((&(*oparams)), (i))));
                                if (!((equalsPU5175PU5175rB)((p1), (p2))))
                                    return (false);
                            }

                            return (true);
                        }
                        goto after_14591;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14591;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14591:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14594;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14594;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14594:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9252_ = true;

    Type_u *tmp_14611_ = (this);
    {
        succ_9252_ &= (tmp_14611_->tag == 10);
        TypeList_s *elems = &tmp_14611_->payload.variant10._0;
        succ_9252_ &= true;
        if (succ_9252_) {
            {
                bool succ_9256_ = true;

                Type_u *tmp_14608_ = (other);
                {
                    succ_9256_ &= (tmp_14608_->tag == 10);
                    TypeList_s *oelems = &tmp_14608_->payload.variant10._0;
                    succ_9256_ &= true;
                    if (succ_9256_) {
                        {
                            if (((*elems).length) != ((*oelems).length))
                                return (false);
                            for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                Type_u *e1 = (*((atPS0643uszrPPU5175)((&(*elems)), (i))));
                                Type_u *e2 = (*((atPS0643uszrPPU5175)((&(*oelems)), (i))));
                                if (!((equalsPU5175PU5175rB)((e1), (e2))))
                                    return (false);
                            }

                            return (true);
                        }
                        goto after_14608;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14608;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14608:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14611;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14611;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14611:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9266_ = true;

    Type_u *tmp_14619_ = (this);
    {
        succ_9266_ &= (tmp_14619_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14619_->payload.variant7._0;
        succ_9266_ &= true;
        if (succ_9266_) {
            {
                bool succ_9270_ = true;

                Type_u *tmp_14616_ = (other);
                {
                    succ_9270_ &= (tmp_14616_->tag == 7);
                    ParsedStructDecl_s **odecl = &tmp_14616_->payload.variant7._0;
                    succ_9270_ &= true;
                    if (succ_9270_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14616;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14616;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14616:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14619;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14619;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14619:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9277_ = true;

    Type_u *tmp_14627_ = (this);
    {
        succ_9277_ &= (tmp_14627_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14627_->payload.variant8._0;
        succ_9277_ &= true;
        succ_9277_ &= true;
        if (succ_9277_) {
            {
                bool succ_9282_ = true;

                Type_u *tmp_14624_ = (other);
                {
                    succ_9282_ &= (tmp_14624_->tag == 8);
                    ParsedUnionDecl_s **odecl = &tmp_14624_->payload.variant8._0;
                    succ_9282_ &= true;
                    succ_9282_ &= true;
                    if (succ_9282_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14624;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14624;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14624:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14627;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14627;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14627:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9288_ = true;

    Type_u *tmp_14635_ = (this);
    {
        succ_9288_ &= (tmp_14635_->tag == 9);
        ParsedModule_s **decl = &tmp_14635_->payload.variant9._0;
        succ_9288_ &= true;
        if (succ_9288_) {
            {
                bool succ_9292_ = true;

                Type_u *tmp_14632_ = (other);
                {
                    succ_9292_ &= (tmp_14632_->tag == 9);
                    ParsedModule_s **odecl = &tmp_14632_->payload.variant9._0;
                    succ_9292_ &= true;
                    if (succ_9292_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14632;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14632;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14632:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14635;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14635;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14635:
    (void)0; // error: label at end of compound statement is a C23 extension
    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((this))).buffer)));
    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((other))).buffer)));
    ((unreachablePcrN)(("&Type.equals() should\'ve caught all combinations by this point!")));
}
bool isUnknownPU5175rB(Type_u *this) {
    Type_u tmp_70574 = (((Type_u){.tag = 1, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70574)))));
}
bool isFloatPU5175rB(Type_u *this) {
    bool succ_9299_ = true;
    bool succ_9297_ = true;
    bool succ_9304_ = true;
    bool succ_9302_ = true;

    Type_u *tmp_14645_ = (this);
    {
        succ_9299_ &= (tmp_14645_->tag == 3);
        succ_9297_ &= (tmp_14645_->payload.variant3._0.tag == 13);
        succ_9299_ &= succ_9297_;
        if (succ_9299_) {
            {
                return (true);
            }
            goto after_14645;
        }
    }
    {
        succ_9304_ &= (tmp_14645_->tag == 3);
        succ_9302_ &= (tmp_14645_->payload.variant3._0.tag == 14);
        succ_9304_ &= succ_9302_;
        if (succ_9304_) {
            {
                return (true);
            }
            goto after_14645;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14645;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14645:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isIntegerPU5175rB(Type_u *this) { return (((isSignedIntegerPU5175rB)((this))) || ((isUnsignedIntegerPU5175rB)((this)))); }
bool isSignedIntegerPU5175rB(Type_u *this) {
    bool succ_9310_ = true;
    bool succ_9308_ = true;
    bool succ_9315_ = true;
    bool succ_9313_ = true;
    bool succ_9320_ = true;
    bool succ_9318_ = true;
    bool succ_9325_ = true;
    bool succ_9323_ = true;

    Type_u *tmp_14657_ = (this);
    {
        succ_9310_ &= (tmp_14657_->tag == 3);
        succ_9308_ &= (tmp_14657_->payload.variant3._0.tag == 4);
        succ_9310_ &= succ_9308_;
        if (succ_9310_) {
            {
                return (true);
            }
            goto after_14657;
        }
    }
    {
        succ_9315_ &= (tmp_14657_->tag == 3);
        succ_9313_ &= (tmp_14657_->payload.variant3._0.tag == 5);
        succ_9315_ &= succ_9313_;
        if (succ_9315_) {
            {
                return (true);
            }
            goto after_14657;
        }
    }
    {
        succ_9320_ &= (tmp_14657_->tag == 3);
        succ_9318_ &= (tmp_14657_->payload.variant3._0.tag == 6);
        succ_9320_ &= succ_9318_;
        if (succ_9320_) {
            {
                return (true);
            }
            goto after_14657;
        }
    }
    {
        succ_9325_ &= (tmp_14657_->tag == 3);
        succ_9323_ &= (tmp_14657_->payload.variant3._0.tag == 7);
        succ_9325_ &= succ_9323_;
        if (succ_9325_) {
            {
                return (true);
            }
            goto after_14657;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14657;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14657:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isUnsignedIntegerPU5175rB(Type_u *this) {
    bool succ_9331_ = true;
    bool succ_9329_ = true;
    bool succ_9336_ = true;
    bool succ_9334_ = true;
    bool succ_9341_ = true;
    bool succ_9339_ = true;
    bool succ_9346_ = true;
    bool succ_9344_ = true;
    bool succ_9351_ = true;
    bool succ_9349_ = true;

    Type_u *tmp_14670_ = (this);
    {
        succ_9331_ &= (tmp_14670_->tag == 3);
        succ_9329_ &= (tmp_14670_->payload.variant3._0.tag == 0);
        succ_9331_ &= succ_9329_;
        if (succ_9331_) {
            {
                return (true);
            }
            goto after_14670;
        }
    }
    {
        succ_9336_ &= (tmp_14670_->tag == 3);
        succ_9334_ &= (tmp_14670_->payload.variant3._0.tag == 1);
        succ_9336_ &= succ_9334_;
        if (succ_9336_) {
            {
                return (true);
            }
            goto after_14670;
        }
    }
    {
        succ_9341_ &= (tmp_14670_->tag == 3);
        succ_9339_ &= (tmp_14670_->payload.variant3._0.tag == 2);
        succ_9341_ &= succ_9339_;
        if (succ_9341_) {
            {
                return (true);
            }
            goto after_14670;
        }
    }
    {
        succ_9346_ &= (tmp_14670_->tag == 3);
        succ_9344_ &= (tmp_14670_->payload.variant3._0.tag == 3);
        succ_9346_ &= succ_9344_;
        if (succ_9346_) {
            {
                return (true);
            }
            goto after_14670;
        }
    }
    {
        succ_9351_ &= (tmp_14670_->tag == 3);
        succ_9349_ &= (tmp_14670_->payload.variant3._0.tag == 8);
        succ_9351_ &= succ_9349_;
        if (succ_9351_) {
            {
                return (true);
            }
            goto after_14670;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14670;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14670:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isVariadicTypePU5175rB(Type_u *this) {
    bool succ_9356_ = true;

    Type_u *tmp_14675_ = (this);
    {
        succ_9356_ &= (tmp_14675_->tag == 2);
        succ_9356_ &= true;
        if (succ_9356_) {
            {
                return (true);
            }
            goto after_14675;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14675;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14675:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isCharPU5175rB(Type_u *this) {
    bool succ_9362_ = true;
    bool succ_9360_ = true;

    Type_u *tmp_14680_ = (this);
    {
        succ_9362_ &= (tmp_14680_->tag == 3);
        succ_9360_ &= (tmp_14680_->payload.variant3._0.tag == 12);
        succ_9362_ &= succ_9360_;
        if (succ_9362_) {
            {
                return (true);
            }
            goto after_14680;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14680;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14680:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBooleanPU5175rB(Type_u *this) {
    bool succ_9368_ = true;
    bool succ_9366_ = true;

    Type_u *tmp_14685_ = (this);
    {
        succ_9368_ &= (tmp_14685_->tag == 3);
        succ_9366_ &= (tmp_14685_->payload.variant3._0.tag == 10);
        succ_9368_ &= succ_9366_;
        if (succ_9368_) {
            {
                return (true);
            }
            goto after_14685;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14685;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14685:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isNonePU5175rB(Type_u *this) {
    bool succ_9374_ = true;
    bool succ_9372_ = true;

    Type_u *tmp_14690_ = (this);
    {
        succ_9374_ &= (tmp_14690_->tag == 3);
        succ_9372_ &= (tmp_14690_->payload.variant3._0.tag == 11);
        succ_9374_ &= succ_9372_;
        if (succ_9374_) {
            {
                return (true);
            }
            goto after_14690;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14690;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14690:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isAnyPU5175rB(Type_u *this) {
    bool succ_9380_ = true;
    bool succ_9378_ = true;

    Type_u *tmp_14695_ = (this);
    {
        succ_9380_ &= (tmp_14695_->tag == 3);
        succ_9378_ &= (tmp_14695_->payload.variant3._0.tag == 9);
        succ_9380_ &= succ_9378_;
        if (succ_9380_) {
            {
                return (true);
            }
            goto after_14695;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14695;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14695:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isDataPU5175rB(Type_u *this) {
    bool succ_9385_ = true;

    Type_u *tmp_14700_ = (this);
    {
        succ_9385_ &= (tmp_14700_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14700_->payload.variant7._0;
        succ_9385_ &= true;
        if (succ_9385_) {
            {
                return ((*decl)->isDataDefinition);
            }
            goto after_14700;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14700;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14700:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isPrimitivePU5175rB(Type_u *this) {
    Type_u tmp_70629 = (((Type_u){.tag = 3, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70629)))));
}
bool isFunctionPU5175rB(Type_u *this) {
    Type_u tmp_70640 = (((Type_u){.tag = 6, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70640)))));
}
bool isVariadicPU5175rB(Type_u *this) {
    bool succ_9392_ = true;

    Type_u *tmp_14707_ = (this);
    {
        succ_9392_ &= (tmp_14707_->tag == 6);
        succ_9392_ &= true;
        succ_9392_ &= true;
        FuncAttr_s *attr = &tmp_14707_->payload.variant6._2;
        succ_9392_ &= true;
        if (succ_9392_) {
            {
                return ((*attr).isVariadic);
            }
            goto after_14707;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14707;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14707:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isNoreturnPU5175rB(Type_u *this) {
    bool succ_9399_ = true;

    Type_u *tmp_14712_ = (this);
    {
        succ_9399_ &= (tmp_14712_->tag == 6);
        succ_9399_ &= true;
        succ_9399_ &= true;
        FuncAttr_s *attr = &tmp_14712_->payload.variant6._2;
        succ_9399_ &= true;
        if (succ_9399_) {
            {
                return ((*attr).isNoreturn);
            }
            goto after_14712;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14712;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14712:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isPointerPU5175rB(Type_u *this) {
    bool succ_9404_ = true;
    bool succ_9409_ = true;
    bool succ_9407_ = true;

    Type_u *tmp_14719_ = (this);
    {
        succ_9404_ &= (tmp_14719_->tag == 4);
        succ_9404_ &= true;
        if (succ_9404_) {
            {
                return (true);
            }
            goto after_14719;
        }
    }
    {
        succ_9409_ &= (tmp_14719_->tag == 3);
        succ_9407_ &= (tmp_14719_->payload.variant3._0.tag == 9);
        succ_9409_ &= succ_9407_;
        if (succ_9409_) {
            {
                return (true);
            }
            goto after_14719;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14719;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14719:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isStructPointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isStructPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isTuplePointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isTuplePU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isArrayPointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isArrayPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isPointerToPU5175PU5175rB(Type_u *this, Type_u *typ) {
    bool succ_9414_ = true;

    Type_u *tmp_14733_ = (this);
    {
        succ_9414_ &= (tmp_14733_->tag == 4);
        Type_u **to = &tmp_14733_->payload.variant4._0;
        succ_9414_ &= true;
        if (succ_9414_) {
            {
                return ((equalsPU5175PU5175rB)((*to), (typ)));
            }
            goto after_14733;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14733;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14733:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isModulePU5175rB(Type_u *this) {
    Type_u tmp_70704 = (((Type_u){.tag = 9, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70704)))));
}
bool isStructPU5175rB(Type_u *this) {
    Type_u tmp_70715 = (((Type_u){.tag = 7, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70715)))));
}
bool isUnionPU5175rB(Type_u *this) {
    Type_u tmp_70726 = (((Type_u){.tag = 8, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70726)))));
}
bool isArrayPU5175rB(Type_u *this) {
    Type_u tmp_70737 = (((Type_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70737)))));
}
bool isTuplePU5175rB(Type_u *this) {
    Type_u tmp_70748 = (((Type_u){.tag = 10, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70748)))));
}
bool isStructArrayPU5175rB(Type_u *this) {
    if (!((isArrayPU5175rB)((this))))
        return (false);
    return ((isStructPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
Type_u *getUnderlyingTypePU5175BrPU5175(Type_u *this, bool deep) {
    Type_u *underlying = (this);
    while ((((isVariadicTypePU5175rB)((this))) || ((isPointerPU5175rB)((this)))) || ((isArrayPU5175rB)((this)))) {
        bool succ_9420_ = true;
        bool succ_9425_ = true;
        bool succ_9429_ = true;

        Type_u *tmp_14752_ = (underlying);
        {
            succ_9420_ &= (tmp_14752_->tag == 4);
            Type_u **under = &tmp_14752_->payload.variant4._0;
            succ_9420_ &= true;
            if (succ_9420_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14752;
            }
        }
        {
            succ_9425_ &= (tmp_14752_->tag == 5);
            Type_u **under = &tmp_14752_->payload.variant5._0;
            succ_9425_ &= true;
            succ_9425_ &= true;
            if (succ_9425_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14752;
            }
        }
        {
            succ_9429_ &= (tmp_14752_->tag == 2);
            Type_u **under = &tmp_14752_->payload.variant2._0;
            succ_9429_ &= true;
            if (succ_9429_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14752;
            }
        }
        {
            if (true) {
                {
                    break;
                }
                goto after_14752;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14752:
        (void)0; // error: label at end of compound statement is a C23 extension
        if (!(deep))
            break;
    }

    return (underlying);
}
String_s toStringPU5175rS0540(Type_u *this) {
    bool succ_9433_ = true;
    bool succ_9436_ = true;
    bool succ_9440_ = true;
    bool succ_9475_ = true;
    bool succ_9483_ = true;
    bool succ_9488_ = true;
    bool succ_9492_ = true;
    bool succ_9498_ = true;
    bool succ_9510_ = true;
    bool succ_9518_ = true;
    bool succ_9526_ = true;

    Type_u *tmp_14864_ = (this);
    {
        succ_9433_ &= (tmp_14864_->tag == 0);
        if (succ_9433_) {
            {
                return ((newStringFromStrLitPcrS0540)(("<propagated error>")));
            }
            goto after_14864;
        }
    }
    {
        succ_9436_ &= (tmp_14864_->tag == 1);
        if (succ_9436_) {
            {
                return ((newStringFromStrLitPcrS0540)(("<unknown>")));
            }
            goto after_14864;
        }
    }
    {
        succ_9440_ &= (tmp_14864_->tag == 3);
        PrimType_u *typ = &tmp_14864_->payload.variant3._0;
        succ_9440_ &= true;
        if (succ_9440_) {
            {
                bool succ_9443_ = true;
                bool succ_9445_ = true;
                bool succ_9447_ = true;
                bool succ_9449_ = true;
                bool succ_9451_ = true;
                bool succ_9453_ = true;
                bool succ_9455_ = true;
                bool succ_9457_ = true;
                bool succ_9459_ = true;
                bool succ_9461_ = true;
                bool succ_9463_ = true;
                bool succ_9465_ = true;
                bool succ_9467_ = true;
                bool succ_9469_ = true;
                bool succ_9471_ = true;

                PrimType_u tmp_14794_ = (*typ);
                {
                    succ_9443_ &= (tmp_14794_.tag == 0);
                    if (succ_9443_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u8")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9445_ &= (tmp_14794_.tag == 1);
                    if (succ_9445_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u16")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9447_ &= (tmp_14794_.tag == 2);
                    if (succ_9447_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u32")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9449_ &= (tmp_14794_.tag == 3);
                    if (succ_9449_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u64")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9451_ &= (tmp_14794_.tag == 4);
                    if (succ_9451_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i8")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9453_ &= (tmp_14794_.tag == 5);
                    if (succ_9453_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i16")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9455_ &= (tmp_14794_.tag == 6);
                    if (succ_9455_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i32")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9457_ &= (tmp_14794_.tag == 7);
                    if (succ_9457_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i64")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9459_ &= (tmp_14794_.tag == 8);
                    if (succ_9459_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("usize")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9461_ &= (tmp_14794_.tag == 9);
                    if (succ_9461_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("Any")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9463_ &= (tmp_14794_.tag == 10);
                    if (succ_9463_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("bool")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9465_ &= (tmp_14794_.tag == 11);
                    if (succ_9465_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("none")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9467_ &= (tmp_14794_.tag == 12);
                    if (succ_9467_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("char")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9469_ &= (tmp_14794_.tag == 13);
                    if (succ_9469_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f32")));
                        }
                        goto after_14794;
                    }
                }
                {
                    succ_9471_ &= (tmp_14794_.tag == 14);
                    if (succ_9471_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f64")));
                        }
                        goto after_14794;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in toString")));
                        }
                        goto after_14794;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14794:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14864;
        }
    }
    {
        succ_9475_ &= (tmp_14864_->tag == 4);
        Type_u **sub = &tmp_14864_->payload.variant4._0;
        succ_9475_ &= true;
        if (succ_9475_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("&")));
                String_s _s = ((toStringPU5175rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_14864;
        }
    }
    {
        succ_9483_ &= (tmp_14864_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14864_->payload.variant7._0;
        succ_9483_ &= true;
        if (succ_9483_) {
            {
                return ((getFullNamePS5521rS0540)((*decl)));
            }
            goto after_14864;
        }
    }
    {
        succ_9488_ &= (tmp_14864_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14864_->payload.variant8._0;
        succ_9488_ &= true;
        succ_9488_ &= true;
        if (succ_9488_) {
            {
                return ((getFullNamePS0997rS0540)((*decl)));
            }
            goto after_14864;
        }
    }
    {
        succ_9492_ &= (tmp_14864_->tag == 9);
        ParsedModule_s **decl = &tmp_14864_->payload.variant9._0;
        succ_9492_ &= true;
        if (succ_9492_) {
            {
                return ((getFullNamePS1882rS0540)((*decl)));
            }
            goto after_14864;
        }
    }
    {
        succ_9498_ &= (tmp_14864_->tag == 6);
        TypeList_s *params = &tmp_14864_->payload.variant6._0;
        succ_9498_ &= true;
        Type_u **rt = &tmp_14864_->payload.variant6._1;
        succ_9498_ &= true;
        FuncAttr_s *attr = &tmp_14864_->payload.variant6._2;
        succ_9498_ &= true;
        if (succ_9498_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("func (")));
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s p = ((toStringPU5175rS0540)((*((atPS0643uszrPPU5175)((&(*params)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(p))));
                    ((dropPS0540rN)((&(p))));
                    if ((i) != (((*params).length) - ((usize)(1llu)))) {
                        ((pushCharPS0540crN)((&(s)), (',')));
                        ((pushCharPS0540crN)((&(s)), (' ')));
                    }
                }

                if ((*attr).isVariadic) {
                    if (((*params).length) > ((usize)(0llu)))
                        if (!((isVariadicTypePU5175rB)(((((*params).elements))[(((*params).length) - ((usize)(1llu)))])))) {
                            ((pushStrPS0540PcrN)((&(s)), ("...")));
                        }
                }

                ((pushCharPS0540crN)((&(s)), (')')));
                if (!((isNonePU5175rB)((*rt)))) {
                    ((pushStrPS0540PcrN)((&(s)), (" -> ")));
                    String_s r = ((toStringPU5175rS0540)((*rt)));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                    ((dropPS0540rN)((&(r))));
                }

                return (s);
            }
            goto after_14864;
        }
    }
    {
        succ_9510_ &= (tmp_14864_->tag == 5);
        Type_u **sub = &tmp_14864_->payload.variant5._0;
        succ_9510_ &= true;
        usize *size = &tmp_14864_->payload.variant5._1;
        succ_9510_ &= true;
        if (succ_9510_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("[")));
                String_s _s = ((toStringPU5175rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                ((pushCharPS0540crN)((&(s)), (';')));
                ((pushCharPS0540crN)((&(s)), (' ')));
                ((pushNumberPS0540uszrN)((&(s)), (*size)));
                ((pushCharPS0540crN)((&(s)), (']')));
                return (s);
            }
            goto after_14864;
        }
    }
    {
        succ_9518_ &= (tmp_14864_->tag == 2);
        Type_u **typ = &tmp_14864_->payload.variant2._0;
        succ_9518_ &= true;
        if (succ_9518_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("...")));
                String_s _s = ((toStringPU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                return (s);
            }
            goto after_14864;
        }
    }
    {
        succ_9526_ &= (tmp_14864_->tag == 10);
        TypeList_s *elems = &tmp_14864_->payload.variant10._0;
        succ_9526_ &= true;
        if (succ_9526_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("(")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s e = ((toStringPU5175rS0540)((*((atPS0643uszrPPU5175)((&(*elems)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(e))));
                    ((dropPS0540rN)((&(e))));
                    if ((i) != (((*elems).length) - ((usize)(1llu)))) {
                        ((pushCharPS0540crN)((&(s)), (',')));
                        ((pushCharPS0540crN)((&(s)), (' ')));
                    }
                }

                ((pushCharPS0540crN)((&(s)), (')')));
                return (s);
            }
            goto after_14864;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14864;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14864:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of types in Type.toString")));
}
usize getAlignmentInBitsPU5175rusz(Type_u *this) { return (((getAlignmentInBytesPU5175rusz)((this))) * ((usize)(8llu))); }
usize getAlignmentInBytesPU5175rusz(Type_u *this) {
    usize res = ((usize)(0llu));
    bool succ_9539_ = true;
    bool succ_9545_ = true;
    bool succ_9549_ = true;
    bool succ_9585_ = true;
    bool succ_9589_ = true;
    bool succ_9604_ = true;
    bool succ_9608_ = true;

    Type_u *tmp_14935_ = (this);
    {
        succ_9539_ &= (tmp_14935_->tag == 4);
        succ_9539_ &= true;
        if (succ_9539_) {
            {
                ((res) = ((usize)(8llu)));
            }
            goto after_14935;
        }
    }
    {
        succ_9545_ &= (tmp_14935_->tag == 6);
        succ_9545_ &= true;
        succ_9545_ &= true;
        succ_9545_ &= true;
        if (succ_9545_) {
            {
                ((res) = ((usize)(8llu)));
            }
            goto after_14935;
        }
    }
    {
        succ_9549_ &= (tmp_14935_->tag == 3);
        PrimType_u *typ = &tmp_14935_->payload.variant3._0;
        succ_9549_ &= true;
        if (succ_9549_) {
            {
                bool succ_9552_ = true;
                bool succ_9554_ = true;
                bool succ_9556_ = true;
                bool succ_9558_ = true;
                bool succ_9560_ = true;
                bool succ_9562_ = true;
                bool succ_9564_ = true;
                bool succ_9566_ = true;
                bool succ_9568_ = true;
                bool succ_9570_ = true;
                bool succ_9572_ = true;
                bool succ_9574_ = true;
                bool succ_9576_ = true;
                bool succ_9578_ = true;
                bool succ_9580_ = true;

                PrimType_u tmp_14904_ = (*typ);
                {
                    succ_9552_ &= (tmp_14904_.tag == 11);
                    if (succ_9552_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9554_ &= (tmp_14904_.tag == 4);
                    if (succ_9554_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9556_ &= (tmp_14904_.tag == 0);
                    if (succ_9556_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9558_ &= (tmp_14904_.tag == 12);
                    if (succ_9558_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9560_ &= (tmp_14904_.tag == 10);
                    if (succ_9560_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9562_ &= (tmp_14904_.tag == 5);
                    if (succ_9562_) {
                        {
                            ((res) = ((usize)(2llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9564_ &= (tmp_14904_.tag == 1);
                    if (succ_9564_) {
                        {
                            ((res) = ((usize)(2llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9566_ &= (tmp_14904_.tag == 6);
                    if (succ_9566_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9568_ &= (tmp_14904_.tag == 2);
                    if (succ_9568_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9570_ &= (tmp_14904_.tag == 13);
                    if (succ_9570_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9572_ &= (tmp_14904_.tag == 7);
                    if (succ_9572_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9574_ &= (tmp_14904_.tag == 3);
                    if (succ_9574_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9576_ &= (tmp_14904_.tag == 14);
                    if (succ_9576_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9578_ &= (tmp_14904_.tag == 8);
                    if (succ_9578_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    succ_9580_ &= (tmp_14904_.tag == 9);
                    if (succ_9580_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14904;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in Type.getAlignment")));
                        }
                        goto after_14904;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14904:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14935;
        }
    }
    {
        succ_9585_ &= (tmp_14935_->tag == 5);
        Type_u **sub = &tmp_14935_->payload.variant5._0;
        succ_9585_ &= true;
        succ_9585_ &= true;
        if (succ_9585_) {
            {
                ((res) = ((getAlignmentInBytesPU5175rusz)((*sub))));
            }
            goto after_14935;
        }
    }
    {
        succ_9589_ &= (tmp_14935_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14935_->payload.variant7._0;
        succ_9589_ &= true;
        if (succ_9589_) {
            {
                ((assertBPcrN)(((isSuccessPU9661rB)((&((*decl)->typeState)))), ("Can only get alignment of valid structs")));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *td = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((td)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((td)->typeState))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                }

                ((res) = (maxAlign));
            }
            goto after_14935;
        }
    }
    {
        succ_9604_ &= (tmp_14935_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14935_->payload.variant8._0;
        succ_9604_ &= true;
        succ_9604_ &= true;
        if (succ_9604_) {
            {
                ((res) = ((getAlignmentInBytesPS0997rusz)((*decl))));
            }
            goto after_14935;
        }
    }
    {
        succ_9608_ &= (tmp_14935_->tag == 10);
        TypeList_s *elems = &tmp_14935_->payload.variant10._0;
        succ_9608_ &= true;
        if (succ_9608_) {
            {
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    Type_u *tt = ((((*elems).elements))[(i)]);
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                }

                ((res) = (maxAlign));
            }
            goto after_14935;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of type kinds in Type.getAlignment")));
            }
            goto after_14935;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14935:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((res) != ((usize)(0llu))), ("Alignment can\'t be 0 bytes")));
    usize n = ((usize)(1llu));
    while ((n) < (res))
        ((n) = ((n) * ((usize)(2llu))));
    return (n);
}
usize getSizeInBitsPU5175rusz(Type_u *this) {
    usize s = (((getSizeInBytesPU5175rusz)((this))) * ((usize)(8llu)));
    if ((s) == ((usize)(0llu)))
        return ((usize)(1llu));
    return (s);
}
usize getSizeInBytesPU5175rusz(Type_u *this) {
    bool succ_9624_ = true;
    bool succ_9628_ = true;
    bool succ_9634_ = true;
    bool succ_9638_ = true;
    bool succ_9673_ = true;
    bool succ_9678_ = true;
    bool succ_9682_ = true;
    bool succ_9703_ = true;
    bool succ_9707_ = true;

    Type_u *tmp_15030_ = (this);
    {
        succ_9624_ &= (tmp_15030_->tag == 4);
        succ_9624_ &= true;
        if (succ_9624_) {
            {
                return ((usize)(8llu));
            }
            goto after_15030;
        }
    }
    {
        succ_9628_ &= (tmp_15030_->tag == 2);
        succ_9628_ &= true;
        if (succ_9628_) {
            {
                return ((usize)(16llu));
            }
            goto after_15030;
        }
    }
    {
        succ_9634_ &= (tmp_15030_->tag == 6);
        succ_9634_ &= true;
        succ_9634_ &= true;
        succ_9634_ &= true;
        if (succ_9634_) {
            {
                return ((usize)(8llu));
            }
            goto after_15030;
        }
    }
    {
        succ_9638_ &= (tmp_15030_->tag == 3);
        PrimType_u *typ = &tmp_15030_->payload.variant3._0;
        succ_9638_ &= true;
        if (succ_9638_) {
            {
                bool succ_9641_ = true;
                bool succ_9643_ = true;
                bool succ_9645_ = true;
                bool succ_9647_ = true;
                bool succ_9649_ = true;
                bool succ_9651_ = true;
                bool succ_9653_ = true;
                bool succ_9655_ = true;
                bool succ_9657_ = true;
                bool succ_9659_ = true;
                bool succ_9661_ = true;
                bool succ_9663_ = true;
                bool succ_9665_ = true;
                bool succ_9667_ = true;
                bool succ_9669_ = true;

                PrimType_u tmp_14983_ = (*typ);
                {
                    succ_9641_ &= (tmp_14983_.tag == 11);
                    if (succ_9641_) {
                        {
                            return ((usize)(0llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9643_ &= (tmp_14983_.tag == 4);
                    if (succ_9643_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9645_ &= (tmp_14983_.tag == 0);
                    if (succ_9645_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9647_ &= (tmp_14983_.tag == 12);
                    if (succ_9647_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9649_ &= (tmp_14983_.tag == 10);
                    if (succ_9649_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9651_ &= (tmp_14983_.tag == 5);
                    if (succ_9651_) {
                        {
                            return ((usize)(2llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9653_ &= (tmp_14983_.tag == 1);
                    if (succ_9653_) {
                        {
                            return ((usize)(2llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9655_ &= (tmp_14983_.tag == 6);
                    if (succ_9655_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9657_ &= (tmp_14983_.tag == 2);
                    if (succ_9657_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9659_ &= (tmp_14983_.tag == 13);
                    if (succ_9659_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9661_ &= (tmp_14983_.tag == 7);
                    if (succ_9661_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9663_ &= (tmp_14983_.tag == 3);
                    if (succ_9663_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9665_ &= (tmp_14983_.tag == 14);
                    if (succ_9665_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9667_ &= (tmp_14983_.tag == 8);
                    if (succ_9667_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    succ_9669_ &= (tmp_14983_.tag == 9);
                    if (succ_9669_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14983;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in Type.getSize")));
                        }
                        goto after_14983;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14983:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_15030;
        }
    }
    {
        succ_9673_ &= (tmp_15030_->tag == 9);
        succ_9673_ &= true;
        if (succ_9673_) {
            {
                return ((usize)(0llu));
            }
            goto after_15030;
        }
    }
    {
        succ_9678_ &= (tmp_15030_->tag == 5);
        Type_u **sub = &tmp_15030_->payload.variant5._0;
        succ_9678_ &= true;
        usize *size = &tmp_15030_->payload.variant5._1;
        succ_9678_ &= true;
        if (succ_9678_) {
            {
                return (((getSizeInBytesPU5175rusz)((*sub))) * (*size));
            }
            goto after_15030;
        }
    }
    {
        succ_9682_ &= (tmp_15030_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_15030_->payload.variant7._0;
        succ_9682_ &= true;
        if (succ_9682_) {
            {
                ((assertBPcrN)(((isSuccessPU9661rB)((&((*decl)->typeState)))), ("Can only get size of valid structs")));
                usize size = ((usize)(0llu));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *td = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((td)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((td)->typeState))));
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                    if ((i) != ((((*decl)->context).fieldLength) - ((usize)(1llu)))) {
                        ParsedTypeNode_s *next = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), ((i) + ((usize)(1llu)))));
                        Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }

                ((size) = ((nextMultipleOfuszuszrusz)((size), (maxAlign))));
                return (size);
            }
            goto after_15030;
        }
    }
    {
        succ_9703_ &= (tmp_15030_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_15030_->payload.variant8._0;
        succ_9703_ &= true;
        succ_9703_ &= true;
        if (succ_9703_) {
            {
                return ((getSizeInBytesPS0997rusz)((*decl)));
            }
            goto after_15030;
        }
    }
    {
        succ_9707_ &= (tmp_15030_->tag == 10);
        TypeList_s *elems = &tmp_15030_->payload.variant10._0;
        succ_9707_ &= true;
        if (succ_9707_) {
            {
                usize size = ((usize)(0llu));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    Type_u *tt = ((((*elems).elements))[(i)]);
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                    if ((i) != (((*elems).length) - ((usize)(1llu)))) {
                        Type_u *nextType = ((((*elems).elements))[((i) + ((usize)(1llu)))]);
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }

                ((size) = ((nextMultipleOfuszuszrusz)((size), (maxAlign))));
                return (size);
            }
            goto after_15030;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15030;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15030:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of type kinds in Type.getSizeInBytes")));
}
Type_u *getParamPU5175uszrPU5175(Type_u *fnType, usize id) {
    bool succ_9726_ = true;

    Type_u *tmp_15035_ = (fnType);
    {
        succ_9726_ &= (tmp_15035_->tag == 6);
        TypeList_s *params = &tmp_15035_->payload.variant6._0;
        succ_9726_ &= true;
        succ_9726_ &= true;
        succ_9726_ &= true;
        if (succ_9726_) {
            {
                return (*((atPS0643uszrPPU5175)((&(*params)), (id))));
            }
            goto after_15035;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15035;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15035:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("getParam() called on non-function type")));
}
Type_u *getReturnTypePU5175rPU5175(Type_u *fnType) {
    bool succ_9733_ = true;

    Type_u *tmp_15040_ = (fnType);
    {
        succ_9733_ &= (tmp_15040_->tag == 6);
        succ_9733_ &= true;
        Type_u **ret = &tmp_15040_->payload.variant6._1;
        succ_9733_ &= true;
        succ_9733_ &= true;
        if (succ_9733_) {
            {
                return (*ret);
            }
            goto after_15040;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15040;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15040:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("getReturnType() called on non-function type")));
}
Type_u *getTupleElementPU5175uszrPU5175(Type_u *tuple, usize index) {
    bool succ_9738_ = true;

    Type_u *tmp_15043_ = (tuple);
    succ_9738_ &= (tmp_15043_->tag == 10);
    TypeList_s *elems = &tmp_15043_->payload.variant10._0;
    succ_9738_ &= true;
    if (!succ_9738_) {
        ((unreachablePcrN)(("getTupleElement() called on non-tuple type")));
    };
    return (*((atPS0643uszrPPU5175)((&(*elems)), (index))));
}
f64 getMaxFloatValuePU5175rf64(Type_u *this) {
    bool succ_9743_ = true;
    bool succ_9741_ = true;
    bool succ_9750_ = true;
    bool succ_9748_ = true;

    Type_u *tmp_15052_ = (this);
    {
        succ_9743_ &= (tmp_15052_->tag == 3);
        succ_9741_ &= (tmp_15052_->payload.variant3._0.tag == 13);
        succ_9743_ &= succ_9741_;
        if (succ_9743_) {
            {
                i32 VAL = ((i32)(2139095039));
                return ((f64)((*((f32 *)((&(VAL)))))));
            }
            goto after_15052;
        }
    }
    {
        succ_9750_ &= (tmp_15052_->tag == 3);
        succ_9748_ &= (tmp_15052_->payload.variant3._0.tag == 14);
        succ_9750_ &= succ_9748_;
        if (succ_9750_) {
            {
                i64 VAL = ((i64)(9218868437227405311ll));
                return (*((f64 *)((&(VAL)))));
            }
            goto after_15052;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15052;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15052:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Type.getMaxFloatValue() called on non-Float")));
}
Type_u *intoPointerPU5175rPU5175(Type_u *this) { return ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (this)}}}))); }
Type_u *intoArrayTypePU5175uszrPU5175(Type_u *this, usize size) { return ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (this), ._1 = (size)}}}))); }
Type_u *copyPU5175rPU5175(Type_u *this) { return ((wrapU5175rPU5175)((*(this)))); }
Type_u *wrapU5175rPU5175(Type_u t) {
    bool succ_9757_ = true;

    Type_u tmp_15067_ = (t);
    {
        succ_9757_ &= (tmp_15067_.tag == 3);
        PrimType_u *p = &tmp_15067_.payload.variant3._0;
        succ_9757_ &= true;
        if (succ_9757_) {
            {
                usize id = ((usize)(((tagAnyru8)((&(*p))))));
                ((assertBPcrN)(((id) < (PRIM_TYPE_COUNT)), ("Type::Prim has invalid tag")));
                ((*((atPS4174uszrPU5175)((&(types)), (id)))) = (t));
                return ((atPS4174uszrPU5175)((&(types)), (id)));
            }
            goto after_15067;
        }
    }
    {
        if (true) {
            {
                ((pushPS4174U5175rN)((&(types)), (t)));
                if (*((flags).debug))
                    ((pushPS7368S5777rN)((&(debugTypes)), ((LLVMMetadata_s){0})));
                return ((lastPS4174rPU5175)((&(types))));
            }
            goto after_15067;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15067:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
ParsedExpr_s *popPS7823uszrPS2435(ParsedExprList_s *this, usize index) {
    ParsedExpr_s *elem = (*((atPS7823uszrPPS2435)((this), (index))));
    for (usize i = (index); ((i) < (((this)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS7823uszrPPS2435)((this), (i)))) = (*((atPS7823uszrPPS2435)((this), ((i) + ((usize)(1llu)))))));
    }

    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (elem);
}
none pushPS0643PU5175rN(TypeList_s *this, Type_u *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Type_u *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Type_u **atPS0643uszrPPU5175(TypeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TypeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TypeList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS7823PS2435rN(ParsedExprList_s *this, ParsedExpr_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedExpr_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedExprList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedExpr_s **atPS7823uszrPPS2435(ParsedExprList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedExprList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedExprList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS3288PS1100rN(ParsedStmtList_s *this, ParsedStmt_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedStmt_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedStmtList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStmt_s **atPS3288uszrPPS1100(ParsedStmtList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedStmtList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedStmtList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS1982PS1826rN(ParsedPatternList_s *this, ParsedPattern_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedPattern_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedPatternList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedPattern_s **atPS1982uszrPPS1826(ParsedPatternList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedPatternList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedPatternList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS4601S2365rN(UnionVariantLookupList_s *this, UnionVariantLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionVariantLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionVariantLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
UnionVariantLookup_s *atPS4601uszrPS2365(UnionVariantLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UnionVariantLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UnionVariantLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4601PS2365rB(UnionVariantLookupList_s *this, UnionVariantLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS2365PS2365rB)(((atPS4601uszrPS2365)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
none pushPS4836S1592rN(UnionLookupList_s *this, UnionLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
UnionLookup_s *popPS4836rPS1592(UnionLookupList_s *this) {
    UnionLookup_s *l = ((lastPS4836rPS1592)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
UnionLookup_s *atPS4836uszrPS1592(UnionLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UnionLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UnionLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4836PS1592rB(UnionLookupList_s *this, UnionLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1592PS1592rB)(((atPS4836uszrPS1592)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
UnionLookup_s *lastPS4836rPS1592(UnionLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty UnionLookupList")));
    return ((atPS4836uszrPS1592)((this), (((this)->length) - ((usize)(1llu)))));
}
none pushPS0030PS3506rN(ParsedUnionVariantList_s *this, ParsedUnionVariant_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedUnionVariant_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedUnionVariantList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionVariant_s **atPS0030uszrPPS3506(ParsedUnionVariantList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedUnionVariantList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedUnionVariantList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS6760PS1372rN(ParsedTypeNodeList_s *this, ParsedTypeNode_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedTypeNode_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedTypeNodeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTypeNode_s **atPS6760uszrPPS1372(ParsedTypeNodeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedTypeNodeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedTypeNodeList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS9938S6070rN(TokenList_s *this, Token_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Token_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TokenList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Token_s *atPS9938uszrPS6070(TokenList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TokenList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TokenList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS1575U7467rN(ConfigList_s *this, Config_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Config_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ConfigList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS5121S0997rN(ModuleLookupList_s *this, ModuleLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ModuleLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ModuleLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
bool containsPS5121PS0997rB(ModuleLookupList_s *this, ModuleLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0997PS0997rB)(((atPS5121uszrPS0997)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ModuleLookup_s *atPS5121uszrPS0997(ModuleLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ModuleLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ModuleLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
Config_u *atPS1575uszrPU7467(ConfigList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ConfigList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ConfigList.at")));
    return (&((((this)->elements))[(index)]));
}
ModuleLookup_s *lastPS5121rPS0997(ModuleLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ModuleLookupList")));
    return ((atPS5121uszrPS0997)((this), (((this)->length) - ((usize)(1llu)))));
}
none initBlankPS4756uszrN(ParsedAttributeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ParsedAttribute_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedAttributeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4756U4360rN(ParsedAttributeList_s *this, ParsedAttribute_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedAttribute_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedAttributeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedAttribute_u *popPS4756rPU4360(ParsedAttributeList_s *this) {
    ParsedAttribute_u *l = ((lastPS4756rPU4360)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ParsedAttribute_u *atPS4756uszrPU4360(ParsedAttributeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedAttributeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedAttributeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4756PU4360rB(ParsedAttributeList_s *this, ParsedAttribute_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU4360PU4360rB)(((atPS4756uszrPU4360)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ParsedAttribute_u *lastPS4756rPU4360(ParsedAttributeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ParsedAttributeList")));
    return ((atPS4756uszrPU4360)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS4756PS4756rN(ParsedAttributeList_s *this, ParsedAttributeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4756U4360rN)((this), (*((atPS4756uszrPU4360)((other), (i))))));
    }

    ((dropPS4756rN)((other)));
}
none dropPS4756rN(ParsedAttributeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS4756rN(ParsedAttributeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8385uszrN(FunctionLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(FunctionLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FunctionLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8385S0677rN(FunctionLookupList_s *this, FunctionLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(FunctionLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FunctionLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
FunctionLookup_s *popPS8385rPS0677(FunctionLookupList_s *this) {
    FunctionLookup_s *l = ((lastPS8385rPS0677)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
FunctionLookup_s *atPS8385uszrPS0677(FunctionLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in FunctionLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in FunctionLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8385PS0677rB(FunctionLookupList_s *this, FunctionLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0677PS0677rB)(((atPS8385uszrPS0677)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
FunctionLookup_s *lastPS8385rPS0677(FunctionLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty FunctionLookupList")));
    return ((atPS8385uszrPS0677)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8385PS8385rN(FunctionLookupList_s *this, FunctionLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8385S0677rN)((this), (*((atPS8385uszrPS0677)((other), (i))))));
    }

    ((dropPS8385rN)((other)));
}
none dropPS8385rN(FunctionLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8385rN(FunctionLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS7392uszrN(StructLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(StructLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StructLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS7392S4228rN(StructLookupList_s *this, StructLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(StructLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StructLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
StructLookup_s *popPS7392rPS4228(StructLookupList_s *this) {
    StructLookup_s *l = ((lastPS7392rPS4228)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
StructLookup_s *atPS7392uszrPS4228(StructLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StructLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in StructLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS7392PS4228rB(StructLookupList_s *this, StructLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS4228PS4228rB)(((atPS7392uszrPS4228)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
StructLookup_s *lastPS7392rPS4228(StructLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty StructLookupList")));
    return ((atPS7392uszrPS4228)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS7392PS7392rN(StructLookupList_s *this, StructLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS7392S4228rN)((this), (*((atPS7392uszrPS4228)((other), (i))))));
    }

    ((dropPS7392rN)((other)));
}
none dropPS7392rN(StructLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS7392rN(StructLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5541uszrN(ScopeLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ScopeLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ScopeLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5541S1913rN(ScopeLookupList_s *this, ScopeLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ScopeLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ScopeLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ScopeLookup_s *popPS5541rPS1913(ScopeLookupList_s *this) {
    ScopeLookup_s *l = ((lastPS5541rPS1913)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ScopeLookup_s *atPS5541uszrPS1913(ScopeLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ScopeLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ScopeLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5541PS1913rB(ScopeLookupList_s *this, ScopeLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1913PS1913rB)(((atPS5541uszrPS1913)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ScopeLookup_s *lastPS5541rPS1913(ScopeLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ScopeLookupList")));
    return ((atPS5541uszrPS1913)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5541PS5541rN(ScopeLookupList_s *this, ScopeLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5541S1913rN)((this), (*((atPS5541uszrPS1913)((other), (i))))));
    }

    ((dropPS5541rN)((other)));
}
none dropPS5541rN(ScopeLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5541rN(ScopeLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS1581uszrN(TypeLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(TypeLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS1581S6177rN(TypeLookupList_s *this, TypeLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(TypeLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
TypeLookup_s *popPS1581rPS6177(TypeLookupList_s *this) {
    TypeLookup_s *l = ((lastPS1581rPS6177)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
TypeLookup_s *atPS1581uszrPS6177(TypeLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TypeLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TypeLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS1581PS6177rB(TypeLookupList_s *this, TypeLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6177PS6177rB)(((atPS1581uszrPS6177)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
TypeLookup_s *lastPS1581rPS6177(TypeLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty TypeLookupList")));
    return ((atPS1581uszrPS6177)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS1581PS1581rN(TypeLookupList_s *this, TypeLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS1581S6177rN)((this), (*((atPS1581uszrPS6177)((other), (i))))));
    }

    ((dropPS1581rN)((other)));
}
none dropPS1581rN(TypeLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS1581rN(TypeLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS3313uszrN(VariableLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(VariableLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in VariableLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS3313S6661rN(VariableLookupList_s *this, VariableLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(VariableLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in VariableLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
VariableLookup_s *popPS3313rPS6661(VariableLookupList_s *this) {
    VariableLookup_s *l = ((lastPS3313rPS6661)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
VariableLookup_s *atPS3313uszrPS6661(VariableLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in VariableLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in VariableLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS3313PS6661rB(VariableLookupList_s *this, VariableLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6661PS6661rB)(((atPS3313uszrPS6661)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
VariableLookup_s *lastPS3313rPS6661(VariableLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty VariableLookupList")));
    return ((atPS3313uszrPS6661)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS3313PS3313rN(VariableLookupList_s *this, VariableLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS3313S6661rN)((this), (*((atPS3313uszrPS6661)((other), (i))))));
    }

    ((dropPS3313rN)((other)));
}
none dropPS3313rN(VariableLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS3313rN(VariableLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS3606uszrN(ImportLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ImportLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ImportLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS3606S6218rN(ImportLookupList_s *this, ImportLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ImportLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ImportLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ImportLookup_s *popPS3606rPS6218(ImportLookupList_s *this) {
    ImportLookup_s *l = ((lastPS3606rPS6218)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ImportLookup_s *atPS3606uszrPS6218(ImportLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ImportLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ImportLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS3606PS6218rB(ImportLookupList_s *this, ImportLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6218PS6218rB)(((atPS3606uszrPS6218)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ImportLookup_s *lastPS3606rPS6218(ImportLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ImportLookupList")));
    return ((atPS3606uszrPS6218)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS3606PS3606rN(ImportLookupList_s *this, ImportLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS3606S6218rN)((this), (*((atPS3606uszrPS6218)((other), (i))))));
    }

    ((dropPS3606rN)((other)));
}
none dropPS3606rN(ImportLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS3606rN(ImportLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9625uszrN(TCStateList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(TCState_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TCStateList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9625U9661rN(TCStateList_s *this, TCState_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(TCState_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TCStateList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
TCState_u *popPS9625rPU9661(TCStateList_s *this) {
    TCState_u *l = ((lastPS9625rPU9661)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
TCState_u *atPS9625uszrPU9661(TCStateList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TCStateList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TCStateList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9625PU9661rB(TCStateList_s *this, TCState_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU9661PU9661rB)(((atPS9625uszrPU9661)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
TCState_u *lastPS9625rPU9661(TCStateList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty TCStateList")));
    return ((atPS9625uszrPU9661)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9625PS9625rN(TCStateList_s *this, TCStateList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9625U9661rN)((this), (*((atPS9625uszrPU9661)((other), (i))))));
    }

    ((dropPS9625rN)((other)));
}
none dropPS9625rN(TCStateList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9625rN(TCStateList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9911uszrN(RegIndexList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(RegIndex_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegIndexList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9911S6939rN(RegIndexList_s *this, RegIndex_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(RegIndex_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegIndexList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
RegIndex_s *popPS9911rPS6939(RegIndexList_s *this) {
    RegIndex_s *l = ((lastPS9911rPS6939)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
RegIndex_s *atPS9911uszrPS6939(RegIndexList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in RegIndexList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in RegIndexList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9911PS6939rB(RegIndexList_s *this, RegIndex_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6939PS6939rB)(((atPS9911uszrPS6939)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
RegIndex_s *lastPS9911rPS6939(RegIndexList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty RegIndexList")));
    return ((atPS9911uszrPS6939)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9911PS9911rN(RegIndexList_s *this, RegIndexList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9911S6939rN)((this), (*((atPS9911uszrPS6939)((other), (i))))));
    }

    ((dropPS9911rN)((other)));
}
none dropPS9911rN(RegIndexList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9911rN(RegIndexList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS0124uszrN(IRInstrList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRInstr_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRInstrList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS0124S7680rN(IRInstrList_s *this, IRInstr_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRInstr_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRInstrList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRInstr_s *popPS0124rPS7680(IRInstrList_s *this) {
    IRInstr_s *l = ((lastPS0124rPS7680)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRInstr_s *atPS0124uszrPS7680(IRInstrList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRInstrList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRInstrList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS0124PS7680rB(IRInstrList_s *this, IRInstr_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7680PS7680rB)(((atPS0124uszrPS7680)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRInstr_s *lastPS0124rPS7680(IRInstrList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRInstrList")));
    return ((atPS0124uszrPS7680)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS0124PS0124rN(IRInstrList_s *this, IRInstrList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((this), (*((atPS0124uszrPS7680)((other), (i))))));
    }

    ((dropPS0124rN)((other)));
}
none dropPS0124rN(IRInstrList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS0124rN(IRInstrList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9366uszrN(IRScopeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRScope_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9366S7082rN(IRScopeList_s *this, IRScope_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRScope_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRScope_s *popPS9366rPS7082(IRScopeList_s *this) {
    IRScope_s *l = ((lastPS9366rPS7082)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRScope_s *atPS9366uszrPS7082(IRScopeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRScopeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRScopeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9366PS7082rB(IRScopeList_s *this, IRScope_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7082PS7082rB)(((atPS9366uszrPS7082)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRScope_s *lastPS9366rPS7082(IRScopeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRScopeList")));
    return ((atPS9366uszrPS7082)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9366PS9366rN(IRScopeList_s *this, IRScopeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9366S7082rN)((this), (*((atPS9366uszrPS7082)((other), (i))))));
    }

    ((dropPS9366rN)((other)));
}
none dropPS9366rN(IRScopeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9366rN(IRScopeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS2282uszrN(IRRegList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRReg_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRRegList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS2282S1534rN(IRRegList_s *this, IRReg_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRReg_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRRegList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRReg_s *popPS2282rPS1534(IRRegList_s *this) {
    IRReg_s *l = ((lastPS2282rPS1534)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRReg_s *atPS2282uszrPS1534(IRRegList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRRegList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRRegList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS2282PS1534rB(IRRegList_s *this, IRReg_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1534PS1534rB)(((atPS2282uszrPS1534)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRReg_s *lastPS2282rPS1534(IRRegList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRRegList")));
    return ((atPS2282uszrPS1534)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS2282PS2282rN(IRRegList_s *this, IRRegList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS2282S1534rN)((this), (*((atPS2282uszrPS1534)((other), (i))))));
    }

    ((dropPS2282rN)((other)));
}
none dropPS2282rN(IRRegList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS2282rN(IRRegList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS1479uszrN(IRBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS1479S9435rN(IRBlockList_s *this, IRBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRBlock_s *popPS1479rPS9435(IRBlockList_s *this) {
    IRBlock_s *l = ((lastPS1479rPS9435)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRBlock_s *atPS1479uszrPS9435(IRBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS1479PS9435rB(IRBlockList_s *this, IRBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS9435PS9435rB)(((atPS1479uszrPS9435)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRBlock_s *lastPS1479rPS9435(IRBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRBlockList")));
    return ((atPS1479uszrPS9435)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS1479PS1479rN(IRBlockList_s *this, IRBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS1479S9435rN)((this), (*((atPS1479uszrPS9435)((other), (i))))));
    }

    ((dropPS1479rN)((other)));
}
none dropPS1479rN(IRBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS1479rN(IRBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS6662uszrN(LoopBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LoopBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LoopBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS6662S0666rN(LoopBlockList_s *this, LoopBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LoopBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LoopBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LoopBlock_s *popPS6662rPS0666(LoopBlockList_s *this) {
    LoopBlock_s *l = ((lastPS6662rPS0666)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LoopBlock_s *atPS6662uszrPS0666(LoopBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LoopBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LoopBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS6662PS0666rB(LoopBlockList_s *this, LoopBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0666PS0666rB)(((atPS6662uszrPS0666)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LoopBlock_s *lastPS6662rPS0666(LoopBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LoopBlockList")));
    return ((atPS6662uszrPS0666)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS6662PS6662rN(LoopBlockList_s *this, LoopBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS6662S0666rN)((this), (*((atPS6662uszrPS0666)((other), (i))))));
    }

    ((dropPS6662rN)((other)));
}
none dropPS6662rN(LoopBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS6662rN(LoopBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5960uszrN(IRScopeEntryList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRScopeEntry_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeEntryList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5960S9676rN(IRScopeEntryList_s *this, IRScopeEntry_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRScopeEntry_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeEntryList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRScopeEntry_s *popPS5960rPS9676(IRScopeEntryList_s *this) {
    IRScopeEntry_s *l = ((lastPS5960rPS9676)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRScopeEntry_s *atPS5960uszrPS9676(IRScopeEntryList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRScopeEntryList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRScopeEntryList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5960PS9676rB(IRScopeEntryList_s *this, IRScopeEntry_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS9676PS9676rB)(((atPS5960uszrPS9676)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRScopeEntry_s *lastPS5960rPS9676(IRScopeEntryList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRScopeEntryList")));
    return ((atPS5960uszrPS9676)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5960PS5960rN(IRScopeEntryList_s *this, IRScopeEntryList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5960S9676rN)((this), (*((atPS5960uszrPS9676)((other), (i))))));
    }

    ((dropPS5960rN)((other)));
}
none dropPS5960rN(IRScopeEntryList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5960rN(IRScopeEntryList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8040uszrN(IRFuncList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRFunc_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRFuncList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8040S7132rN(IRFuncList_s *this, IRFunc_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRFunc_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRFuncList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRFunc_s *popPS8040rPS7132(IRFuncList_s *this) {
    IRFunc_s *l = ((lastPS8040rPS7132)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRFunc_s *atPS8040uszrPS7132(IRFuncList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRFuncList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRFuncList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8040PS7132rB(IRFuncList_s *this, IRFunc_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7132PS7132rB)(((atPS8040uszrPS7132)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRFunc_s *lastPS8040rPS7132(IRFuncList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRFuncList")));
    return ((atPS8040uszrPS7132)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8040PS8040rN(IRFuncList_s *this, IRFuncList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8040S7132rN)((this), (*((atPS8040uszrPS7132)((other), (i))))));
    }

    ((dropPS8040rN)((other)));
}
none dropPS8040rN(IRFuncList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8040rN(IRFuncList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS4318uszrN(LLVMTypeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMType_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMTypeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4318S0706rN(LLVMTypeList_s *this, LLVMType_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMType_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMTypeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMType_s *popPS4318rPS0706(LLVMTypeList_s *this) {
    LLVMType_s *l = ((lastPS4318rPS0706)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMType_s *atPS4318uszrPS0706(LLVMTypeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMTypeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMTypeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4318PS0706rB(LLVMTypeList_s *this, LLVMType_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0706PS0706rB)(((atPS4318uszrPS0706)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMType_s *lastPS4318rPS0706(LLVMTypeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMTypeList")));
    return ((atPS4318uszrPS0706)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS4318PS4318rN(LLVMTypeList_s *this, LLVMTypeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4318S0706rN)((this), (*((atPS4318uszrPS0706)((other), (i))))));
    }

    ((dropPS4318rN)((other)));
}
none dropPS4318rN(LLVMTypeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS4318rN(LLVMTypeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5884uszrN(RegValueList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(RegValue_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegValueList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5884U5952rN(RegValueList_s *this, RegValue_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(RegValue_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
RegValue_u *popPS5884rPU5952(RegValueList_s *this) {
    RegValue_u *l = ((lastPS5884rPU5952)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
RegValue_u *atPS5884uszrPU5952(RegValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in RegValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in RegValueList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5884PU5952rB(RegValueList_s *this, RegValue_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU5952PU5952rB)(((atPS5884uszrPU5952)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
RegValue_u *lastPS5884rPU5952(RegValueList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty RegValueList")));
    return ((atPS5884uszrPU5952)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5884PS5884rN(RegValueList_s *this, RegValueList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5884U5952rN)((this), (*((atPS5884uszrPU5952)((other), (i))))));
    }

    ((dropPS5884rN)((other)));
}
none dropPS5884rN(RegValueList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5884rN(RegValueList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS0409uszrN(LLVMBasicBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMBasicBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMBasicBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS0409S7469rN(LLVMBasicBlockList_s *this, LLVMBasicBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMBasicBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMBasicBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMBasicBlock_s *popPS0409rPS7469(LLVMBasicBlockList_s *this) {
    LLVMBasicBlock_s *l = ((lastPS0409rPS7469)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMBasicBlock_s *atPS0409uszrPS7469(LLVMBasicBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMBasicBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMBasicBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS0409PS7469rB(LLVMBasicBlockList_s *this, LLVMBasicBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7469PS7469rB)(((atPS0409uszrPS7469)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMBasicBlock_s *lastPS0409rPS7469(LLVMBasicBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMBasicBlockList")));
    return ((atPS0409uszrPS7469)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS0409PS0409rN(LLVMBasicBlockList_s *this, LLVMBasicBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0409S7469rN)((this), (*((atPS0409uszrPS7469)((other), (i))))));
    }

    ((dropPS0409rN)((other)));
}
none dropPS0409rN(LLVMBasicBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS0409rN(LLVMBasicBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8201uszrN(LLVMValueList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMValue_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMValueList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8201S8925rN(LLVMValueList_s *this, LLVMValue_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMValue_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMValue_s *popPS8201rPS8925(LLVMValueList_s *this) {
    LLVMValue_s *l = ((lastPS8201rPS8925)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMValue_s *atPS8201uszrPS8925(LLVMValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMValueList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8201PS8925rB(LLVMValueList_s *this, LLVMValue_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS8925PS8925rB)(((atPS8201uszrPS8925)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMValue_s *lastPS8201rPS8925(LLVMValueList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMValueList")));
    return ((atPS8201uszrPS8925)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8201PS8201rN(LLVMValueList_s *this, LLVMValueList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8201S8925rN)((this), (*((atPS8201uszrPS8925)((other), (i))))));
    }

    ((dropPS8201rN)((other)));
}
none dropPS8201rN(LLVMValueList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8201rN(LLVMValueList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS4113uszrN(UsizeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(usize)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UsizeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4113uszrN(UsizeList_s *this, usize element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UsizeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
usize *atPS4113uszrPusz(UsizeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UsizeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UsizeList.at")));
    return (&((((this)->elements))[(index)]));
}
ImportLookup_s *getPS3606PS6218rPS6218(ImportLookupList_s *this, ImportLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ImportLookup_s *v = ((atPS3606uszrPS6218)((this), (i)));
        if ((equalsPS6218PS6218rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS3606PS6218rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
StructLookup_s *getPS7392PS4228rPS4228(StructLookupList_s *this, StructLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *v = ((atPS7392uszrPS4228)((this), (i)));
        if ((equalsPS4228PS4228rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS7392PS4228rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
UnionLookup_s *getPS4836PS1592rPS1592(UnionLookupList_s *this, UnionLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *v = ((atPS4836uszrPS1592)((this), (i)));
        if ((equalsPS1592PS1592rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS4836PS1592rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
ModuleLookup_s *getPS5121PS0997rPS0997(ModuleLookupList_s *this, ModuleLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *v = ((atPS5121uszrPS0997)((this), (i)));
        if ((equalsPS0997PS0997rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS5121PS0997rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
none toggleIgnoringNodesrN(none) { ((ignoringNodes) = (!(ignoringNodes))); }
String_s mangleVariableNameBuszPS6070rS0540(bool global, usize fileID, Token_s *name) {
    if ((fileID) == (NODE_ID_OFFSET)) {
        return ((toStringPS7720rS0540)((&((name)->content))));
    }

    else {
        String_s mangledName = ((String_s){0});
        ((pushNumberPS0540uszrN)((&(mangledName)), (fileID)));
        ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&((name)->content))));
        return (mangledName);
    }
}
String_s mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540(TLIParent_s parent, Token_s *name, ParamContext_s *params, ParsedTypeNode_s *retType, bool isComptime, ParsedAttributeList_s *attrs) {
    String_s mangledName = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((attrs)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedAttribute_u a = ((((attrs)->elements))[(i)]);
        bool succ_9979_ = true;

        {
            ParsedAttribute_u tmp_16137_ = (a);
            succ_9979_ &= (tmp_16137_.tag == 1);
            Token_s *name = &tmp_16137_.payload.variant1._0;
            succ_9979_ &= true;

            if (succ_9979_) {
                return ((toStringPS7720rS0540)((&((*name).content))));
            }
        }

        bool succ_9981_ = true;

        {
            ParsedAttribute_u tmp_16139_ = (a);
            succ_9981_ &= (tmp_16139_.tag == 5);

            if (succ_9981_) {
                return ((toStringPS7720rS0540)((&((name)->content))));
            }
        }
    }

    while (!((parent).isFile)) {
        ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&(((mod)->name).content))));
        ((pushCharPS0540crN)((&(mangledName)), ('.')));
        ((parent) = ((mod)->parent));
    }

    ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&((name)->content))));
    for (usize i = ((usize)(0llu)); ((i) < ((params)->paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *typeNode = ((getTypeAtIndexPS9803uszrPS1372)((params), (i)));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((typeNode)->typeState)))), ("Expected valid parameter type for mangling")));
        Type_u *typ = ((getTypePU9661rPU5175)((&((typeNode)->typeState))));
        String_s _typ = ((getMangledNamePU5175rS0540)((typ)));
        ((pushStringPS0540PS0540rN)((&(mangledName)), (&(_typ))));
        ((dropPS0540rN)((&(_typ))));
    }

    ((pushCharPS0540crN)((&(mangledName)), ('r')));
    if ((retType) != (NULL)) {
        ((assertBPcrN)(((isSuccessPU9661rB)((&((retType)->typeState)))), ("Expected valid return type for mangling")));
        Type_u *typ = ((getTypePU9661rPU5175)((&((retType)->typeState))));
        String_s _typ = ((getMangledNamePU5175rS0540)((typ)));
        ((pushStringPS0540PS0540rN)((&(mangledName)), (&(_typ))));
        ((dropPS0540rN)((&(_typ))));
    }

    else {
        ((pushCharPS0540crN)((&(mangledName)), ('n')));
    }

    return (mangledName);
}
ParsedFile_s *getFileByFileNameS7720rPS1892(SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        if ((endsWithPS7720PS7720rB)((&((file)->origin)), (&(name)))) {
            return (file);
        }
    }

    return (NULL);
}
bool getFileByFilePathS7720PuszrB(SubStr_s path, usize *fileID) {
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        if ((equalsPS7720PS7720rB)((&((file)->origin)), (&(path)))) {
            ((*(fileID)) = (i));
            return (true);
        }
    }

    return (false);
}
bool equalsPU4360PU4360rB(ParsedAttribute_u *this, ParsedAttribute_u *other) { ((unreachablePcrN)(("ParsedAttribute.equals is not implemented yet"))); }
Config_u newConfigS6070S6070rU7467(Token_s t, Token_s value) {
    SubStr_s tmp_77639 = (((BUILD_A_KEYWORDPcrS7720)(("static"))));
    SubStr_s tmp_77655 = (((BUILD_A_KEYWORDPcrS7720)(("dynamic"))));
    SubStr_s tmp_77671 = (((BUILD_A_KEYWORDPcrS7720)(("libpath"))));
    SubStr_s tmp_77687 = (((BUILD_A_KEYWORDPcrS7720)(("linker"))));

    if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77639))) {
        return ((Config_u){.tag = 1, .payload = {.variant1 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77655))) {
        return ((Config_u){.tag = 2, .payload = {.variant2 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77671))) {
        return ((Config_u){.tag = 3, .payload = {.variant3 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77687))) {
        return ((Config_u){.tag = 4, .payload = {.variant4 = {._0 = (value)}}});
    }

    else {
        return ((Config_u){.tag = 0, .payload = {.variant0 = {._0 = (value)}}});
    }
}
ParsedConfig_s *newParsedConfigS8951S1575rPS0890(Span_s span, ConfigList_s cfgs) {
    ((pushPS9153S0890rN)((&(configs)), ((ParsedConfig_s){.ignored = (ignoringNodes), .span = (span), .configs = (cfgs)})));
    return ((lastPS9153rPS0890)((&(configs))));
}
usize getIDPS0890rusz(ParsedConfig_s *this) { return ((indexOfPS9153PS0890rusz)((&(configs)), (this))); }
ParsedTopLevelItem_s *asTLIPS0890rPS1038(ParsedConfig_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_CONFIG), ((getIDPS0890rusz)((this))))); }
usize getIDPS1892rusz(ParsedFile_s *this) { return ((indexOfPS9483PS1892rusz)((&(files)), (this))); }
none getLineAndColumnFromSpanPS1892PS8951PuszPuszrN(ParsedFile_s *this, Span_s *span, usize *line, usize *column) {
    usize l = ((usize)(1llu));
    usize c = ((usize)(1llu));
    usize p = ((usize)(0llu));
    while ((p) < ((span)->start)) {
        char _c = (((((this)->src).start))[(p)]);
        if ((_c) == ('\n')) {
            ((c) = ((usize)(1llu)));
            ((l) = ((l) + ((usize)(1llu))));
        }

        else {
            ((c) = ((c) + ((usize)(1llu))));
        }

        ((p) = ((p) + ((usize)(1llu))));
    }

    ((*(line)) = (l));
    ((*(column)) = (c));
}
ParsedFile_s *newParsedFileS7720S7720rPS1892(SubStr_s origin, SubStr_s src) {
    ((pushPS9483S1892rN)((&(files)), ((ParsedFile_s){.ignored = (ignoringNodes), .origin = (origin), .src = (src)})));
    return ((lastPS9483rPS1892)((&(files))));
}
bool equalsPS5656PS5656rB(TLIParent_s *this, TLIParent_s *other) { return ((((this)->isFile) == ((other)->isFile)) && (((this)->id) == ((other)->id))); }
ParsedStructDecl_s *asStructPS1038rPS5521(ParsedTopLevelItem_s *this) {
    ((assertBPcrN)((((this)->kind) == (TLI_STRUCT_DECL)), ("ParsedTopLevelItem.asStruct() called on non-struct TLI")));
    return ((atPS2168uszrPS5521)((&(structDecls)), ((this)->nodeID)));
}
ParsedUnionDecl_s *asUnionPS1038rPS0997(ParsedTopLevelItem_s *this) {
    ((assertBPcrN)((((this)->kind) == (TLI_UNION_DECL)), ("ParsedTopLevelItem.asUnion() called on non-union TLI")));
    return ((atPS4268uszrPS0997)((&(unionDecls)), ((this)->nodeID)));
}
usize getIDPS1038rusz(ParsedTopLevelItem_s *this) { return ((indexOfPS9029PS1038rusz)((&(topLevelItems)), (this))); }
ParsedTopLevelItem_s *newParsedTopLevelItemS8951uszuszrPS1038(Span_s span, usize kind, usize nodeID) {
    ((pushPS9029S1038rN)((&(topLevelItems)),
                         ((ParsedTopLevelItem_s){.ignored = (ignoringNodes), .kind = (kind), .span = (span), .nodeID = (nodeID), .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS9029rPS1038)((&(topLevelItems))));
}
DLL_s *newDLLS0540S9457rPS3633(String_s path, Handle_s handle) {
    ((pushPS8168S3633rN)((&(dlls)), ((DLL_s){.path = (path), .handle = (handle)})));
    return ((lastPS8168rPS3633)((&(dlls))));
}
DLL_s *dllNotFoundrPS3633(none) { return ((DLL_s *)((DLL_NOT_FOUND))); }
DLL_s *dllNoSuchFunctionrPS3633(none) { return ((DLL_s *)((DLL_NO_SUCH_FUNCTION))); }
bool isNullPS3633rB(DLL_s *dll) {
    if ((dll) == (NULL))
        return (true);
    if ((dll) == ((dllNotFoundrPS3633)()))
        return (true);
    if ((dll) == ((dllNoSuchFunctionrPS3633)()))
        return (true);
    return ((isNullS9457rB)(((dll)->handle)));
}
usize getIDPS3633rusz(DLL_s *this) { return ((indexOfPS8168PS3633rusz)((&(dlls)), (this))); }
bool equalsPS1882PS1882rB(ParsedModule_s *this, ParsedModule_s *other) {
    if ((equalsPS8951PS8951rB)((&((this)->span)), (&((other)->span))))
        return (true);
    if (!((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))))
        return (false);
    return ((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent))));
}
UsizeList_s getConfigsPS1882rS4113(ParsedModule_s *this) {
    UsizeList_s list = ((UsizeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((this)->tlis)), (i))))))->kind) == (TLI_CONFIG)) {
            ((pushPS4113uszrN)((&(list)), (*((atPS4113uszrPusz)((&((this)->tlis)), (i))))));
        }
    }

    return (list);
}
usize getIDPS1882rusz(ParsedModule_s *this) { return ((indexOfPS7393PS1882rusz)((&(modules)), (this))); }
ParsedTopLevelItem_s *asTLIPS1882rPS1038(ParsedModule_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_MOD_DECL), ((getIDPS1882rusz)((this))))); }
ParsedFile_s *getParentFilePS1882rPS1892(ParsedModule_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
String_s getFullNamePS1882rS0540(ParsedModule_s *this) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushCharPS0540crN)((&(_s)), (':')));
            ((pushCharPS0540crN)((&(_s)), (':')));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushCharPS0540crN)((&(s)), (':')));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
ParsedModule_s *newParsedModuleS5656S8951S6070S4113rPS1882(TLIParent_s parent, Span_s span, Token_s name, UsizeList_s tlis) {
    ((pushPS7393S1882rN)((&(modules)), ((ParsedModule_s){.ignored = (ignoringNodes), .parent = (parent), .name = (name), .span = (span), .tlis = (tlis)})));
    return ((lastPS7393rPS1882)((&(modules))));
}
usize getIDPS5521rusz(ParsedStructDecl_s *this) { return ((indexOfPS2168PS5521rusz)((&(structDecls)), (this))); }
ParsedTopLevelItem_s *asTLIPS5521rPS1038(ParsedStructDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_STRUCT_DECL), ((getIDPS5521rusz)((this))))); }
usize getFieldIndexPS5521PS7720rusz(ParsedStructDecl_s *this, SubStr_s *name) { return ((getFieldIndexPS7871PS7720rusz)((&((this)->context)), (name))); }
usize getFieldOffsetPS5521PS7720Brusz(ParsedStructDecl_s *this, SubStr_s *name, bool inBits) {
    usize offset = ((usize)(0llu));
    usize _idc = ((usize)(0llu));
    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((this), ((getFieldIndexPS5521PS7720rusz)((this), (name))), (&(offset)), (&(_idc)), (inBits)));
    return (offset);
}
none getFieldOffsetAndSizePS5521uszPuszPuszBrN(ParsedStructDecl_s *this, usize index, usize *offset, usize *size, bool inBits) {
    usize o = ((usize)(0llu));
    usize (*sizeFn)(Type_u *) = (getSizeInBytesPU5175rusz);
    usize (*alignFn)(Type_u *) = (getAlignmentInBytesPU5175rusz);
    if (inBits) {
        ((sizeFn) = (getSizeInBitsPU5175rusz));
        ((alignFn) = (getAlignmentInBitsPU5175rusz));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *f1 = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((this)->context)), (i)));
        Type_u *f = ((getTypePU9661rPU5175)((&((f1)->typeState))));
        usize s = ((sizeFn)((f)));
        if ((i) == (index)) {
            ((*(offset)) = (o));
            ((*(size)) = (s));
            return;
        }

        if ((i) != ((((this)->context).fieldLength) - ((usize)(1llu)))) {
            ParsedTypeNode_s *f2 = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((this)->context)), ((i) + ((usize)(1llu)))));
            Type_u *nf = ((getTypePU9661rPU5175)((&((f2)->typeState))));
            ((o) = ((nextMultipleOfuszuszrusz)(((o) + (s)), ((alignFn)((nf))))));
        }
    }

    ((unreachablePcrN)(("Expected to find field offset and size")));
}
ParsedFile_s *getParentFilePS5521rPS1892(ParsedStructDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
ParsedModule_s *getParentModulePS5521rPS1882(ParsedStructDecl_s *this) {
    ((assertBPcrN)((!(((this)->parent).isFile)), ("getParentModule called on struct in a file scope")));
    return ((atPS7393uszrPS1882)((&(modules)), ((usize)((((this)->parent).id)))));
}
String_s getFullNamePS5521PcrS0540(ParsedStructDecl_s *this, char *split) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushStrPS0540PcrN)((&(_s)), (split)));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushStrPS0540PcrN)((&(s)), (split)));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
String_s getFullNamePS5521rS0540(ParsedStructDecl_s *this) { return ((getFullNamePS5521PcrS0540)((this), ("::"))); }
ParsedStructDecl_s *newParsedStructDeclS5656S8951S6070rPS5521(TLIParent_s parent, Span_s span, Token_s name) {
    ((pushPS2168S5521rN)((&(structDecls)), ((ParsedStructDecl_s){.ignored = (ignoringNodes),
                                                                 .parent = (parent),
                                                                 .name = (name),
                                                                 .span = (span),
                                                                 .context = ((StructContext_s){0}),
                                                                 .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS2168rPS5521)((&(structDecls))));
}
usize getAlignmentInBytesPS0997rusz(ParsedUnionDecl_s *this) {
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Can only get alignment of valid unions")));
    usize maxAlign = ((usize)(1llu));
    if ((((this)->variants).length) >= ((usize)(256llu)))
        ((maxAlign) = ((usize)(2llu)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        bool succ_10112_ = true;
        bool succ_10110_ = true;

        tuple_1017 tmp_16374_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
        succ_10110_ = tmp_16374_._0 == true;
        succ_10112_ &= succ_10110_;
        ParsedTypeNodeList_s **fields = &tmp_16374_._1;
        succ_10112_ &= true;
        if (!succ_10112_) {
            continue;
        };
        for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type")));
            Type_u *tt = ((getTypePU9661rPU5175)((&((field)->typeState))));
            usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
            if ((_a) > (maxAlign))
                ((maxAlign) = (_a));
        }
    }

    return (maxAlign);
}
usize getSizeInBytesPS0997rusz(ParsedUnionDecl_s *this) {
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Can only get size of valid unions")));
    ((assertBPcrN)(((((this)->variants).length) < ((usize)(65536llu))), ("getSize expects the Union tag to fit into at most two bytes")));
    usize maxSize = ((usize)(0llu));
    usize maxAlign = ((usize)(1llu));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        usize size = ((usize)(1llu));
        usize align = ((usize)(1llu));
        if ((((this)->variants).length) >= ((usize)(256llu))) {
            ((size) = ((usize)(2llu)));
            ((align) = ((usize)(2llu)));
        }

        bool succ_10133_ = true;
        bool succ_10131_ = true;

        {
            tuple_1017 tmp_16419_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_10131_ = tmp_16419_._0 == true;
            succ_10133_ &= succ_10131_;
            ParsedTypeNodeList_s **fields = &tmp_16419_._1;
            succ_10133_ &= true;

            if (succ_10133_) {
                if (((*fields)->length) > ((usize)(0llu))) {
                    ParsedTypeNode_s *next = ((((*fields)->elements))[((usize)(0llu))]);
                    Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                    ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                }

                for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((field)->typeState))));
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (align))
                        ((align) = (_a));
                    if ((j) != (((*fields)->length) - ((usize)(1llu)))) {
                        ParsedTypeNode_s *next = ((((*fields)->elements))[((j) + ((usize)(1llu)))]);
                        Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }
            }
        }

        if ((size) > (maxSize))
            ((maxSize) = (size));
        if ((align) > (maxAlign))
            ((maxAlign) = (align));
    }

    ((maxSize) = ((nextMultipleOfuszuszrusz)((maxSize), (maxAlign))));
    return (maxSize);
}
usize getIDPS0997rusz(ParsedUnionDecl_s *this) { return ((indexOfPS4268PS0997rusz)((&(unionDecls)), (this))); }
ParsedTopLevelItem_s *asTLIPS0997rPS1038(ParsedUnionDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_UNION_DECL), ((getIDPS0997rusz)((this))))); }
bool resolveVariantByNamePS0997PS6070PPS3506rB(ParsedUnionDecl_s *this, Token_s *name, ParsedUnionVariant_s **out) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        if ((equalsPS7720PS7720rB)((&(((variant)->name).content)), (&((name)->content)))) {
            ((*(out)) = (variant));
            return (true);
        }
    }

    return (false);
}
usize getVariantTagPS0997PS3506rusz(ParsedUnionDecl_s *this, ParsedUnionVariant_s *variant) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((*((atPS0030uszrPPS3506)((&((this)->variants)), (i)))) == (variant)) {
            return (i);
        }
    }

    ((unreachablePcrN)(("getVariantTag() expected to find variant")));
}
ParsedFile_s *getParentFilePS0997rPS1892(ParsedUnionDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
String_s getFullNamePS0997PcrS0540(ParsedUnionDecl_s *this, char *split) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushStrPS0540PcrN)((&(_s)), (split)));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushStrPS0540PcrN)((&(s)), (split)));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
String_s getFullNamePS0997rS0540(ParsedUnionDecl_s *this) { return ((getFullNamePS0997PcrS0540)((this), ("::"))); }
ParsedUnionDecl_s *newParsedUnionDeclS5656S8951S6070rPS0997(TLIParent_s parent, Span_s span, Token_s name) {
    ((pushPS4268S0997rN)((&(unionDecls)), ((ParsedUnionDecl_s){.ignored = (ignoringNodes), .parent = (parent), .name = (name), .span = (span)})));
    return ((lastPS4268rPS0997)((&(unionDecls))));
}
usize getIDPS3506rusz(ParsedUnionVariant_s *this) { return ((indexOfPS4249PS3506rusz)((&(unionVariants)), (this))); }
tuple_1017 get_fieldsPS3506rT_BPS6760(ParsedUnionVariant_s *this) {
    bool succ_10162_ = true;
    bool succ_10167_ = true;

    ParsedUnionVariantData_u *tmp_16475_ = (&((this)->data));
    {
        succ_10162_ &= (tmp_16475_->tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16475_->payload.variant1._0;
        succ_10162_ &= true;
        if (succ_10162_) {
            {
                return ((tuple_1017){(true), (&(*fields))});
            }
            goto after_16475;
        }
    }
    {
        succ_10167_ &= (tmp_16475_->tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16475_->payload.variant2._0;
        succ_10167_ &= true;
        TokenList_s *names = &tmp_16475_->payload.variant2._1;
        succ_10167_ &= true;
        if (succ_10167_) {
            {
                return ((tuple_1017){(true), (&(*fields))});
            }
            goto after_16475;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16475;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16475:
    (void)0; // error: label at end of compound statement is a C23 extension
    return ((tuple_1017){(false), (NULL)});
}
Type_u *toTypePS3506rPU5175(ParsedUnionVariant_s *this) {
    ParsedStructDecl_s *decl = ((newParsedStructDeclS5656S8951S6070rPS5521)(((this)->parent), ((this)->span), ((this)->name)));
    bool succ_10173_ = true;
    bool succ_10176_ = true;
    bool succ_10185_ = true;

    ParsedUnionVariantData_u tmp_16495_ = ((this)->data);
    {
        succ_10173_ &= (tmp_16495_.tag == 0);
        if (succ_10173_) {
            {
            }
            goto after_16495;
        }
    }
    {
        succ_10176_ &= (tmp_16495_.tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16495_.payload.variant1._0;
        succ_10176_ &= true;
        if (succ_10176_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s s = ((String_s){0});
                    ((pushNumberPS0540uszrN)((&(s)), (i)));
                    SubStr_s tmp_78859 = ((asSubStrPS0540rS7720)((&(s))));

                    Token_s name = ((newTokenuszPS7720uszuszrS6070)(((usize)((((this)->parent).id))), (&tmp_78859), ((usize)(0llu)), (TOKEN_IDENT)));
                    ((addFieldPS7871S6070PS1372rN)((&((decl)->context)), (name), ((((*fields).elements))[(i)])));
                }
            }
            goto after_16495;
        }
    }
    {
        succ_10185_ &= (tmp_16495_.tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16495_.payload.variant2._0;
        succ_10185_ &= true;
        TokenList_s *names = &tmp_16495_.payload.variant2._1;
        succ_10185_ &= true;
        if (succ_10185_) {
            {
                ((assertBPcrN)((((*fields).length) == ((*names).length)), ("ParsedUnionVariant.toType: struct count mismatch")));
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((addFieldPS7871S6070PS1372rN)((&((decl)->context)), ((((*names).elements))[(i)]), ((((*fields).elements))[(i)])));
                }
            }
            goto after_16495;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_16495;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16495:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 7, .payload = {.variant7 = {._0 = (decl)}}})));
    (((decl)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}}));
    return (typ);
}
usize getFieldIndexPS3506PS7720rusz(ParsedUnionVariant_s *this, SubStr_s *name) {
    bool succ_10193_ = true;

    {
        ParsedUnionVariantData_u *tmp_16504_ = (&((this)->data));
        succ_10193_ &= (tmp_16504_->tag == 2);
        succ_10193_ &= true;
        TokenList_s *names = &tmp_16504_->payload.variant2._1;
        succ_10193_ &= true;

        if (succ_10193_) {
            for (usize i = ((usize)(0llu)); ((i) < ((*names).length)); ((i) = ((i) + ((usize)(1llu))))) {
                if ((equalsPS7720PS7720rB)((&(((((*names).elements))[(i)]).content)), (name)))
                    return (i);
            }
        }
    }

    ((unreachablePcrN)(("ParsedUnionVariant.getFieldIndex: Expected to find field with name")));
}
none getFieldOffsetAndSizePS3506uszPuszPuszBrN(ParsedUnionVariant_s *this, usize index, usize *offset, usize *size, bool inBits) {
    ParsedTypeNodeList_s fields = ((ParsedTypeNodeList_s){0});
    bool succ_10200_ = true;
    bool succ_10204_ = true;
    bool succ_10207_ = true;

    ParsedUnionVariantData_u tmp_16515_ = ((this)->data);
    {
        succ_10200_ &= (tmp_16515_.tag == 0);
        if (succ_10200_) {
            {
                ((unreachablePcrN)(("ParsedUnionVariant.getFieldOffsetAndSize called on empty union variant")));
            }
            goto after_16515;
        }
    }
    {
        succ_10204_ &= (tmp_16515_.tag == 2);
        ParsedTypeNodeList_s *_fields = &tmp_16515_.payload.variant2._0;
        succ_10204_ &= true;
        succ_10204_ &= true;
        if (succ_10204_) {
            {
                ((fields) = (*_fields));
            }
            goto after_16515;
        }
    }
    {
        succ_10207_ &= (tmp_16515_.tag == 1);
        ParsedTypeNodeList_s *_fields = &tmp_16515_.payload.variant1._0;
        succ_10207_ &= true;
        if (succ_10207_) {
            {
                ((fields) = (*_fields));
            }
            goto after_16515;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_16515;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16515:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((index) < ((fields).length)), ("getFieldOffsetAndSize: Out-of-bounds")));
    ((assertBPcrN)((((fields).length) > ((usize)(0llu))), ("getFieldOffsetAndSize: Empty variant")));
    usize (*sizeFn)(Type_u *) = (getSizeInBytesPU5175rusz);
    usize (*alignFn)(Type_u *) = (getAlignmentInBytesPU5175rusz);
    if (inBits) {
        ((sizeFn) = (getSizeInBitsPU5175rusz));
        ((alignFn) = (getAlignmentInBitsPU5175rusz));
    }

    usize o = ((usize)(0llu));
    if ((*(offset)) != ((usize)(0llu))) {
        Type_u *nf = ((getTypePU9661rPU5175)((&(((((fields).elements))[((usize)(0llu))])->typeState))));
        ((o) = ((nextMultipleOfuszuszrusz)((*(offset)), ((alignFn)((nf))))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *f = ((getTypePU9661rPU5175)((&(((((fields).elements))[(i)])->typeState))));
        usize s = ((sizeFn)((f)));
        if ((i) == (index)) {
            ((*(offset)) = (o));
            ((*(size)) = (s));
            return;
        }

        ((o) = ((o) + (s)));
        if ((i) != (((fields).length) - ((usize)(1llu)))) {
            Type_u *nf = ((getTypePU9661rPU5175)((&(((((fields).elements))[((i) + ((usize)(1llu)))])->typeState))));
            ((o) = ((nextMultipleOfuszuszrusz)((o), ((alignFn)((nf))))));
        }
    }

    ((unreachablePcrN)(("Expected to find field offset and size")));
}
none addFieldPS3506PS1372rN(ParsedUnionVariant_s *this, ParsedTypeNode_s *field) {
    bool succ_10226_ = true;

    ParsedUnionVariantData_u *tmp_16546_ = (&((this)->data));
    succ_10226_ &= (tmp_16546_->tag == 1);
    ParsedTypeNodeList_s *fields = &tmp_16546_->payload.variant1._0;
    succ_10226_ &= true;
    if (!succ_10226_) {
        ((unreachablePcrN)(("ParsedUnionVariant.addField called on non-tuple")));
    };
    ((pushPS6760PS1372rN)((&(*fields)), (field)));
}
Type_u *getTypeAtIndexPS3506uszrPU5175(ParsedUnionVariant_s *this, usize index) {
    ParsedTypeNode_s *node = (NULL);
    bool succ_10232_ = true;
    bool succ_10237_ = true;

    ParsedUnionVariantData_u *tmp_16557_ = (&((this)->data));
    {
        succ_10232_ &= (tmp_16557_->tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16557_->payload.variant1._0;
        succ_10232_ &= true;
        if (succ_10232_) {
            {
                ((assertBPcrN)(((index) < ((*fields).length)), ("Out of bounds access in ParsedUnionVariant.getTypeAtIndex")));
                ((node) = ((((*fields).elements))[(index)]));
            }
            goto after_16557;
        }
    }
    {
        succ_10237_ &= (tmp_16557_->tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16557_->payload.variant2._0;
        succ_10237_ &= true;
        succ_10237_ &= true;
        if (succ_10237_) {
            {
                ((assertBPcrN)(((index) < ((*fields).length)), ("Out of bounds access in ParsedUnionVariant.getTypeAtIndex")));
                ((node) = ((((*fields).elements))[(index)]));
            }
            goto after_16557;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("ParsedUnionVariant.getTypeAtIndex")));
            }
            goto after_16557;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16557:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((isSuccessPU9661rB)((&((node)->typeState)))), ("Expected valid TypeNode state in ParsedUnionVariant.getTypeAtIndex")));
    return ((getTypePU9661rPU5175)((&((node)->typeState))));
}
none addNamedFieldPS3506S6070PS1372rN(ParsedUnionVariant_s *this, Token_s name, ParsedTypeNode_s *typ) {
    bool succ_10243_ = true;

    ParsedUnionVariantData_u *tmp_16561_ = (&((this)->data));
    succ_10243_ &= (tmp_16561_->tag == 2);
    ParsedTypeNodeList_s *fields = &tmp_16561_->payload.variant2._0;
    succ_10243_ &= true;
    TokenList_s *names = &tmp_16561_->payload.variant2._1;
    succ_10243_ &= true;
    if (!succ_10243_) {
        ((unreachablePcrN)(("ParsedUnionVariant.addNamedField called on non-struct")));
    };
    ((assertBPcrN)((((*fields).length) == ((*names).length)), ("ParsedUnionVariant.addNamedField: Unbalanced field and name lists")));
    ((pushPS6760PS1372rN)((&(*fields)), (typ)));
    ((pushPS9938S6070rN)((&(*names)), (name)));
}
bool checkForDuplicateNamePS3506PS6070PPS6070rB(ParsedUnionVariant_s *this, Token_s *name, Token_s **dupl) {
    bool succ_10248_ = true;

    ParsedUnionVariantData_u *tmp_16566_ = (&((this)->data));
    succ_10248_ &= (tmp_16566_->tag == 2);
    succ_10248_ &= true;
    TokenList_s *names = &tmp_16566_->payload.variant2._1;
    succ_10248_ &= true;
    if (!succ_10248_) {
        ((unreachablePcrN)(("ParsedUnionVariant.checkForDuplicateName called on non-struct")));
    };
    bool found = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((*names).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s *n = (&((((*names).elements))[(i)]));
        if ((equalsPS7720PS7720rB)((&((n)->content)), (&((name)->content)))) {
            if (found) {
                ((*(dupl)) = (n));
                return (true);
            }

            ((found) = (true));
        }
    }

    return (false);
}
ParsedUnionVariant_s *newParsedUnionVariantS5656S8951S6070U3836rPS3506(TLIParent_s parent, Span_s span, Token_s name, ParsedUnionVariantData_u data) {
    ((pushPS4249S3506rN)((&(unionVariants)), ((ParsedUnionVariant_s){.ignored = (ignoringNodes), .parent = (parent), .span = (span), .name = (name), .data = (data)})));
    return ((lastPS4249rPS3506)((&(unionVariants))));
}
bool hasAttributePS4904U4360rB(ParsedFuncDecl_s *this, ParsedAttribute_u attr) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == ((tagAnyru8)((&(attr)))))
            return (true);
    }

    return (false);
}
usize getIDPS4904rusz(ParsedFuncDecl_s *this) { return ((indexOfPS4111PS4904rusz)((&(funcDecls)), (this))); }
bool isExternPS4904rB(ParsedFuncDecl_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedAttribute_u tmp_79308 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == (((tagAnyru8)((&tmp_79308)))))
            return (true);
    }

    return (false);
}
ParsedFile_s *getParentFilePS4904rPS1892(ParsedFuncDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
ParsedModule_s *getParentModulePS4904rPS1882(ParsedFuncDecl_s *this) {
    ((assertBPcrN)((!(((this)->parent).isFile)), ("getParentModule called on function in a file scope")));
    return ((atPS7393uszrPS1882)((&(modules)), ((usize)((((this)->parent).id)))));
}
String_s getMangledNamePS4904rS0540(ParsedFuncDecl_s *this) {
    if ((this)->ignored)
        return ((toStringPS7720rS0540)((&(((this)->name).content))));
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Mangling can only be done after type checks")));
    return ((mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540)(((this)->parent), (&((this)->name)), (&((this)->params)), ((this)->retType), ((this)->isComptime), (&((this)->attrs))));
}
ParsedTopLevelItem_s *asTLIPS4904rPS1038(ParsedFuncDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_FUNC_DECL), ((getIDPS4904rusz)((this))))); }
ParsedFuncDecl_s *newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904(TLIParent_s parent, Span_s span, Token_s name, ParamContext_s params, ParsedTypeNode_s *retType, ParsedBlock_s *body) {
    ((pushPS4111S4904rN)((&(funcDecls)), ((ParsedFuncDecl_s){.ignored = (ignoringNodes),
                                                             .parent = (parent),
                                                             .name = (name),
                                                             .span = (span),
                                                             .params = (params),
                                                             .retType = (retType),
                                                             .body = (body),
                                                             .isComptime = (false),
                                                             .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS4111rPS4904)((&(funcDecls))));
}
usize getIDPS7247rusz(ParsedBlock_s *this) { return ((indexOfPS8646PS7247rusz)((&(blocks)), (this))); }
none addStmtPS7247PS1100rN(ParsedBlock_s *this, ParsedStmt_s *stmt) {
    if (((this)->stmtLength) >= ((this)->stmtCapacity)) {
        usize newCap = (((this)->stmtCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->stmtList) = (((realloc))(((this)->stmtList), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->stmtList) != (NULL)), ("Could not resize stmt list")));
        (((this)->stmtCapacity) = (newCap));
    }

    (((((this)->stmtList))[((this)->stmtLength)]) = (stmt));
    (((this)->stmtLength) = (((this)->stmtLength) + ((usize)(1llu))));
}
ParsedStmt_s *getStmtAtIndexPS7247uszrPS1100(ParsedBlock_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->stmtLength)), ("Out of bounds access in ParsedBlock.getStmtAtIndex")));
    return ((((this)->stmtList))[(index)]);
}
ParsedStmt_s *into_stmtPS7247rPS1100(ParsedBlock_s *this) { return ((newParsedStmtS8951U4263rPS1100)(((this)->span), ((StmtData_u){.tag = 4, .payload = {.variant4 = {._0 = (this)}}}))); }
ParsedBlock_s *newParsedBlockrPS7247(none) {
    ((pushPS8646S7247rN)((&(blocks)), ((ParsedBlock_s){.ignored = (ignoringNodes)})));
    return ((lastPS8646rPS7247)((&(blocks))));
}
usize getIDPS1100rusz(ParsedStmt_s *this) { return ((indexOfPS8227PS1100rusz)((&(stmts)), (this))); }
ParsedTopLevelItem_s *asTLIPS1100rPS1038(ParsedStmt_s *this) {
    bool succ_10262_ = true;

    StmtData_u *tmp_16625_ = (&((this)->data));
    {
        succ_10262_ &= (tmp_16625_->tag == 0);
        succ_10262_ &= true;
        if (succ_10262_) {
            {
                return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_VAR_DECL), ((getIDPS1100rusz)((this)))));
            }
            goto after_16625;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16625;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16625:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of STMT to TLI conversions")));
}
ParsedBlock_s *into_blockPS1100rPS7247(ParsedStmt_s *this) {
    ParsedBlock_s *block = ((newParsedBlockrPS7247)());
    ((addStmtPS7247PS1100rN)((block), (this)));
    return (block);
}
ParsedStmt_s *newParsedStmtS8951U4263rPS1100(Span_s span, StmtData_u data) {
    ((pushPS8227S1100rN)((&(stmts)), ((ParsedStmt_s){.ignored = (ignoringNodes), .span = (span), .data = (data)})));
    return ((lastPS8227rPS1100)((&(stmts))));
}
SubStr_s BUILD_A_TYPEPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
usize getBuiltinTypeKindS6070rusz(Token_s name) {
    if ((equalsPS7720PS7720rB)((&((name).content)), (&(ANY))))
        return (PARSED_TYPE_ANY);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I8))))
        return (PARSED_TYPE_I8);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I16))))
        return (PARSED_TYPE_I16);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I32))))
        return (PARSED_TYPE_I32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I64))))
        return (PARSED_TYPE_I64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U8))))
        return (PARSED_TYPE_U8);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U16))))
        return (PARSED_TYPE_U16);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U32))))
        return (PARSED_TYPE_U32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U64))))
        return (PARSED_TYPE_U64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(USIZE))))
        return (PARSED_TYPE_USIZE);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(F32))))
        return (PARSED_TYPE_F32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(F64))))
        return (PARSED_TYPE_F64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(BOOL))))
        return (PARSED_TYPE_BOOL);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(CHAR))))
        return (PARSED_TYPE_CHAR);
    return (PARSED_TYPE_INVALID);
}
usize getIDPS1372rusz(ParsedTypeNode_s *this) { return ((indexOfPS4419PS1372rusz)((&(typeNodes)), (this))); }
ParsedTypeNode_s *newParsedTypeNodeS8951uszrPS1372(Span_s span, usize kind) {
    ((pushPS4419S1372rN)((&(typeNodes)), ((ParsedTypeNode_s){.ignored = (ignoringNodes), .span = (span), .kind = (kind)})));
    return ((lastPS4419rPS1372)((&(typeNodes))));
}
ParsedTypeNode_s *newBuiltinTypeDeclS8951uszrPS1372(Span_s span, usize kind) {
    ParsedTypeNode_s *t = ((atPS4419uszrPS1372)((&(typeNodes)), (kind)));
    (((*(t)).span) = (span));
    (((*(t)).kind) = (PARSED_TYPE_BUILTIN));
    return (t);
}
UnaryExpr_u fromTknuszPS2435rU5427(usize kind, ParsedExpr_s *expr) {
    if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ((UnaryExpr_u){.tag = 2, .payload = {.variant2 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ((UnaryExpr_u){.tag = 3, .payload = {.variant3 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_BANG))
        return ((UnaryExpr_u){.tag = 4, .payload = {.variant4 = {._0 = (expr)}}});
    ((unreachablePcrN)(("fromTkn: Exhaustive handling of unary ops")));
}
none extractOperandPU5427PPS2435rN(UnaryExpr_u *expr, ParsedExpr_s **lhs) {
    bool succ_10351_ = true;
    bool succ_10355_ = true;
    bool succ_10359_ = true;
    bool succ_10363_ = true;
    bool succ_10367_ = true;

    UnaryExpr_u *tmp_16730_ = (expr);
    {
        succ_10351_ &= (tmp_16730_->tag == 0);
        ParsedExpr_s **_lhs = &tmp_16730_->payload.variant0._0;
        succ_10351_ &= true;
        if (succ_10351_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16730;
        }
    }
    {
        succ_10355_ &= (tmp_16730_->tag == 1);
        ParsedExpr_s **_lhs = &tmp_16730_->payload.variant1._0;
        succ_10355_ &= true;
        if (succ_10355_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16730;
        }
    }
    {
        succ_10359_ &= (tmp_16730_->tag == 2);
        ParsedExpr_s **_lhs = &tmp_16730_->payload.variant2._0;
        succ_10359_ &= true;
        if (succ_10359_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16730;
        }
    }
    {
        succ_10363_ &= (tmp_16730_->tag == 3);
        ParsedExpr_s **_lhs = &tmp_16730_->payload.variant3._0;
        succ_10363_ &= true;
        if (succ_10363_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16730;
        }
    }
    {
        succ_10367_ &= (tmp_16730_->tag == 4);
        ParsedExpr_s **_lhs = &tmp_16730_->payload.variant4._0;
        succ_10367_ &= true;
        if (succ_10367_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16730;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("extractOperand: Exhaustive handling of unary expressions")));
            }
            goto after_16730;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16730:
    (void)0; // error: label at end of compound statement is a C23 extension
}
char *binOpAsStrPU0121rPc(BinaryExpr_u *expr) {
    bool succ_10372_ = true;
    bool succ_10376_ = true;
    bool succ_10380_ = true;
    bool succ_10384_ = true;
    bool succ_10388_ = true;
    bool succ_10392_ = true;
    bool succ_10396_ = true;
    bool succ_10400_ = true;
    bool succ_10404_ = true;
    bool succ_10408_ = true;
    bool succ_10412_ = true;
    bool succ_10416_ = true;
    bool succ_10420_ = true;
    bool succ_10424_ = true;
    bool succ_10428_ = true;
    bool succ_10432_ = true;
    bool succ_10436_ = true;
    bool succ_10440_ = true;
    bool succ_10444_ = true;
    bool succ_10448_ = true;

    BinaryExpr_u *tmp_16772_ = (expr);
    {
        succ_10372_ &= (tmp_16772_->tag == 0);
        succ_10372_ &= true;
        if (succ_10372_) {
            {
                return ("::");
            }
            goto after_16772;
        }
    }
    {
        succ_10376_ &= (tmp_16772_->tag == 1);
        succ_10376_ &= true;
        if (succ_10376_) {
            {
                return (".");
            }
            goto after_16772;
        }
    }
    {
        succ_10380_ &= (tmp_16772_->tag == 2);
        succ_10380_ &= true;
        if (succ_10380_) {
            {
                return ("=");
            }
            goto after_16772;
        }
    }
    {
        succ_10384_ &= (tmp_16772_->tag == 3);
        succ_10384_ &= true;
        if (succ_10384_) {
            {
                return ("+");
            }
            goto after_16772;
        }
    }
    {
        succ_10388_ &= (tmp_16772_->tag == 4);
        succ_10388_ &= true;
        if (succ_10388_) {
            {
                return ("-");
            }
            goto after_16772;
        }
    }
    {
        succ_10392_ &= (tmp_16772_->tag == 5);
        succ_10392_ &= true;
        if (succ_10392_) {
            {
                return ("*");
            }
            goto after_16772;
        }
    }
    {
        succ_10396_ &= (tmp_16772_->tag == 6);
        succ_10396_ &= true;
        if (succ_10396_) {
            {
                return ("/");
            }
            goto after_16772;
        }
    }
    {
        succ_10400_ &= (tmp_16772_->tag == 7);
        succ_10400_ &= true;
        if (succ_10400_) {
            {
                return ("%");
            }
            goto after_16772;
        }
    }
    {
        succ_10404_ &= (tmp_16772_->tag == 8);
        succ_10404_ &= true;
        if (succ_10404_) {
            {
                return ("==");
            }
            goto after_16772;
        }
    }
    {
        succ_10408_ &= (tmp_16772_->tag == 9);
        succ_10408_ &= true;
        if (succ_10408_) {
            {
                return ("!=");
            }
            goto after_16772;
        }
    }
    {
        succ_10412_ &= (tmp_16772_->tag == 10);
        succ_10412_ &= true;
        if (succ_10412_) {
            {
                return (">");
            }
            goto after_16772;
        }
    }
    {
        succ_10416_ &= (tmp_16772_->tag == 11);
        succ_10416_ &= true;
        if (succ_10416_) {
            {
                return (">=");
            }
            goto after_16772;
        }
    }
    {
        succ_10420_ &= (tmp_16772_->tag == 12);
        succ_10420_ &= true;
        if (succ_10420_) {
            {
                return ("<");
            }
            goto after_16772;
        }
    }
    {
        succ_10424_ &= (tmp_16772_->tag == 13);
        succ_10424_ &= true;
        if (succ_10424_) {
            {
                return ("<=");
            }
            goto after_16772;
        }
    }
    {
        succ_10428_ &= (tmp_16772_->tag == 14);
        succ_10428_ &= true;
        if (succ_10428_) {
            {
                return ("&&");
            }
            goto after_16772;
        }
    }
    {
        succ_10432_ &= (tmp_16772_->tag == 15);
        succ_10432_ &= true;
        if (succ_10432_) {
            {
                return ("||");
            }
            goto after_16772;
        }
    }
    {
        succ_10436_ &= (tmp_16772_->tag == 16);
        succ_10436_ &= true;
        if (succ_10436_) {
            {
                return ("&");
            }
            goto after_16772;
        }
    }
    {
        succ_10440_ &= (tmp_16772_->tag == 17);
        succ_10440_ &= true;
        if (succ_10440_) {
            {
                return ("|");
            }
            goto after_16772;
        }
    }
    {
        succ_10444_ &= (tmp_16772_->tag == 18);
        succ_10444_ &= true;
        if (succ_10444_) {
            {
                return ("^");
            }
            goto after_16772;
        }
    }
    {
        succ_10448_ &= (tmp_16772_->tag == 19);
        succ_10448_ &= true;
        if (succ_10448_) {
            {
                ((unreachablePcrN)(("binOpAsStr is not defined for indexed access")));
            }
            goto after_16772;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16772;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16772:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("binOpAsStr: Exhaustive handling of binary expressions")));
}
none extractOperandsPU0121PPS2435PPS2435rN(BinaryExpr_u *expr, ParsedExpr_s **lhs, ParsedExpr_s **rhs) {
    bool succ_10454_ = true;
    bool succ_10459_ = true;
    bool succ_10464_ = true;
    bool succ_10469_ = true;
    bool succ_10474_ = true;
    bool succ_10479_ = true;
    bool succ_10484_ = true;
    bool succ_10489_ = true;
    bool succ_10494_ = true;
    bool succ_10499_ = true;
    bool succ_10504_ = true;
    bool succ_10509_ = true;
    bool succ_10514_ = true;
    bool succ_10519_ = true;
    bool succ_10524_ = true;
    bool succ_10529_ = true;
    bool succ_10534_ = true;
    bool succ_10539_ = true;
    bool succ_10544_ = true;
    bool succ_10549_ = true;

    BinaryExpr_u *tmp_16836_ = (expr);
    {
        succ_10454_ &= (tmp_16836_->tag == 0);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant0._0;
        succ_10454_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant0._1;
        succ_10454_ &= true;
        if (succ_10454_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10459_ &= (tmp_16836_->tag == 1);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant1._0;
        succ_10459_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant1._1;
        succ_10459_ &= true;
        if (succ_10459_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10464_ &= (tmp_16836_->tag == 2);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant2._0;
        succ_10464_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant2._1;
        succ_10464_ &= true;
        if (succ_10464_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10469_ &= (tmp_16836_->tag == 3);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant3._0;
        succ_10469_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant3._1;
        succ_10469_ &= true;
        if (succ_10469_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10474_ &= (tmp_16836_->tag == 4);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant4._0;
        succ_10474_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant4._1;
        succ_10474_ &= true;
        if (succ_10474_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10479_ &= (tmp_16836_->tag == 5);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant5._0;
        succ_10479_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant5._1;
        succ_10479_ &= true;
        if (succ_10479_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10484_ &= (tmp_16836_->tag == 6);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant6._0;
        succ_10484_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant6._1;
        succ_10484_ &= true;
        if (succ_10484_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10489_ &= (tmp_16836_->tag == 7);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant7._0;
        succ_10489_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant7._1;
        succ_10489_ &= true;
        if (succ_10489_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10494_ &= (tmp_16836_->tag == 8);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant8._0;
        succ_10494_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant8._1;
        succ_10494_ &= true;
        if (succ_10494_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10499_ &= (tmp_16836_->tag == 9);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant9._0;
        succ_10499_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant9._1;
        succ_10499_ &= true;
        if (succ_10499_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10504_ &= (tmp_16836_->tag == 10);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant10._0;
        succ_10504_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant10._1;
        succ_10504_ &= true;
        if (succ_10504_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10509_ &= (tmp_16836_->tag == 11);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant11._0;
        succ_10509_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant11._1;
        succ_10509_ &= true;
        if (succ_10509_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10514_ &= (tmp_16836_->tag == 12);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant12._0;
        succ_10514_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant12._1;
        succ_10514_ &= true;
        if (succ_10514_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10519_ &= (tmp_16836_->tag == 13);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant13._0;
        succ_10519_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant13._1;
        succ_10519_ &= true;
        if (succ_10519_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10524_ &= (tmp_16836_->tag == 14);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant14._0;
        succ_10524_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant14._1;
        succ_10524_ &= true;
        if (succ_10524_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10529_ &= (tmp_16836_->tag == 15);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant15._0;
        succ_10529_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant15._1;
        succ_10529_ &= true;
        if (succ_10529_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10534_ &= (tmp_16836_->tag == 16);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant16._0;
        succ_10534_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant16._1;
        succ_10534_ &= true;
        if (succ_10534_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10539_ &= (tmp_16836_->tag == 17);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant17._0;
        succ_10539_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant17._1;
        succ_10539_ &= true;
        if (succ_10539_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10544_ &= (tmp_16836_->tag == 18);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant18._0;
        succ_10544_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant18._1;
        succ_10544_ &= true;
        if (succ_10544_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        succ_10549_ &= (tmp_16836_->tag == 19);
        ParsedExpr_s **_lhs = &tmp_16836_->payload.variant19._0;
        succ_10549_ &= true;
        ParsedExpr_s **_rhs = &tmp_16836_->payload.variant19._1;
        succ_10549_ &= true;
        if (succ_10549_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16836;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("extractOperands: Exhaustive handling of binary expressions")));
            }
            goto after_16836;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16836:
    (void)0; // error: label at end of compound statement is a C23 extension
}
BinaryExpr_u fromTknuszPS2435PS2435rU0121(usize kind, ParsedExpr_s *lhs, ParsedExpr_s *rhs) {
    if ((kind) == (TOKEN_PLUS_SINGLE))
        return ((BinaryExpr_u){.tag = 3, .payload = {.variant3 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ((BinaryExpr_u){.tag = 4, .payload = {.variant4 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ((BinaryExpr_u){.tag = 5, .payload = {.variant5 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_SLASH_SINGLE))
        return ((BinaryExpr_u){.tag = 6, .payload = {.variant6 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_DOT))
        return ((BinaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_GREATER_THAN_EQUAL))
        return ((BinaryExpr_u){.tag = 11, .payload = {.variant11 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_GREATER_THAN))
        return ((BinaryExpr_u){.tag = 10, .payload = {.variant10 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_LESS_THAN_EQUAL))
        return ((BinaryExpr_u){.tag = 13, .payload = {.variant13 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_LESS_THAN))
        return ((BinaryExpr_u){.tag = 12, .payload = {.variant12 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_NOT_EQUAL))
        return ((BinaryExpr_u){.tag = 9, .payload = {.variant9 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_EQUAL_DOUBLE))
        return ((BinaryExpr_u){.tag = 8, .payload = {.variant8 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_EQUAL_SINGLE))
        return ((BinaryExpr_u){.tag = 2, .payload = {.variant2 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_SQUARE_OPEN))
        return ((BinaryExpr_u){.tag = 19, .payload = {.variant19 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PERCENT))
        return ((BinaryExpr_u){.tag = 7, .payload = {.variant7 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_AMPERSAND_DOUBLE))
        return ((BinaryExpr_u){.tag = 14, .payload = {.variant14 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PIPE_DOUBLE))
        return ((BinaryExpr_u){.tag = 15, .payload = {.variant15 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ((BinaryExpr_u){.tag = 16, .payload = {.variant16 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PIPE_SINGLE))
        return ((BinaryExpr_u){.tag = 17, .payload = {.variant17 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_CARET))
        return ((BinaryExpr_u){.tag = 18, .payload = {.variant18 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_COLON_DOUBLE))
        return ((BinaryExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (lhs), ._1 = (rhs)}}});
    ((unreachablePcrN)(("fromTkn: Exhaustive handling of binary kinds")));
}
bool isArithmeticPU0121rB(BinaryExpr_u *this) {
    bool succ_10554_ = true;
    bool succ_10558_ = true;
    bool succ_10562_ = true;
    bool succ_10566_ = true;
    bool succ_10570_ = true;

    BinaryExpr_u *tmp_16889_ = (this);
    {
        succ_10554_ &= (tmp_16889_->tag == 3);
        succ_10554_ &= true;
        if (succ_10554_) {
            {
                return (true);
            }
            goto after_16889;
        }
    }
    {
        succ_10558_ &= (tmp_16889_->tag == 4);
        succ_10558_ &= true;
        if (succ_10558_) {
            {
                return (true);
            }
            goto after_16889;
        }
    }
    {
        succ_10562_ &= (tmp_16889_->tag == 5);
        succ_10562_ &= true;
        if (succ_10562_) {
            {
                return (true);
            }
            goto after_16889;
        }
    }
    {
        succ_10566_ &= (tmp_16889_->tag == 6);
        succ_10566_ &= true;
        if (succ_10566_) {
            {
                return (true);
            }
            goto after_16889;
        }
    }
    {
        succ_10570_ &= (tmp_16889_->tag == 7);
        succ_10570_ &= true;
        if (succ_10570_) {
            {
                return (true);
            }
            goto after_16889;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16889;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16889:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isComparisonPU0121rB(BinaryExpr_u *this) {
    bool succ_10575_ = true;
    bool succ_10579_ = true;
    bool succ_10583_ = true;
    bool succ_10587_ = true;
    bool succ_10591_ = true;
    bool succ_10595_ = true;

    BinaryExpr_u *tmp_16904_ = (this);
    {
        succ_10575_ &= (tmp_16904_->tag == 11);
        succ_10575_ &= true;
        if (succ_10575_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        succ_10579_ &= (tmp_16904_->tag == 10);
        succ_10579_ &= true;
        if (succ_10579_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        succ_10583_ &= (tmp_16904_->tag == 13);
        succ_10583_ &= true;
        if (succ_10583_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        succ_10587_ &= (tmp_16904_->tag == 12);
        succ_10587_ &= true;
        if (succ_10587_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        succ_10591_ &= (tmp_16904_->tag == 8);
        succ_10591_ &= true;
        if (succ_10591_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        succ_10595_ &= (tmp_16904_->tag == 9);
        succ_10595_ &= true;
        if (succ_10595_) {
            {
                return (true);
            }
            goto after_16904;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16904;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16904:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isLogicalPU0121rB(BinaryExpr_u *this) {
    bool succ_10600_ = true;
    bool succ_10604_ = true;

    BinaryExpr_u *tmp_16911_ = (this);
    {
        succ_10600_ &= (tmp_16911_->tag == 14);
        succ_10600_ &= true;
        if (succ_10600_) {
            {
                return (true);
            }
            goto after_16911;
        }
    }
    {
        succ_10604_ &= (tmp_16911_->tag == 15);
        succ_10604_ &= true;
        if (succ_10604_) {
            {
                return (true);
            }
            goto after_16911;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16911;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16911:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBitwisePU0121rB(BinaryExpr_u *this) {
    bool succ_10609_ = true;
    bool succ_10613_ = true;
    bool succ_10617_ = true;

    BinaryExpr_u *tmp_16920_ = (this);
    {
        succ_10609_ &= (tmp_16920_->tag == 16);
        succ_10609_ &= true;
        if (succ_10609_) {
            {
                return (true);
            }
            goto after_16920;
        }
    }
    {
        succ_10613_ &= (tmp_16920_->tag == 17);
        succ_10613_ &= true;
        if (succ_10613_) {
            {
                return (true);
            }
            goto after_16920;
        }
    }
    {
        succ_10617_ &= (tmp_16920_->tag == 18);
        succ_10617_ &= true;
        if (succ_10617_) {
            {
                return (true);
            }
            goto after_16920;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16920;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16920:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isAssignmentPU0121rB(BinaryExpr_u *this) {
    bool succ_10622_ = true;

    BinaryExpr_u *tmp_16925_ = (this);
    {
        succ_10622_ &= (tmp_16925_->tag == 2);
        succ_10622_ &= true;
        if (succ_10622_) {
            {
                return (true);
            }
            goto after_16925;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16925;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16925:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
usize getIDPS2435rusz(ParsedExpr_s *this) { return ((indexOfPS7882PS2435rusz)((&(exprs)), (this))); }
ParsedExpr_s *wrapS2435rPS2435(ParsedExpr_s this) {
    ((pushPS7882S2435rN)((&(exprs)), (this)));
    return ((lastPS7882rPS2435)((&(exprs))));
}
ParsedExpr_s *newParsedExprS8951U8798rPS2435(Span_s span, ExprData_u data) { return ((wrapS2435rPS2435)(((ParsedExpr_s){.span = (span), .data = (data)}))); }
usize intoPointerPS2435rusz(ParsedExpr_s *this) {
    ParsedExpr_s unary =
        ((ParsedExpr_s){.span = ((this)->span), .data = ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (this)}}})}}})});
    return ((getIDPS2435rusz)(((wrapS2435rPS2435)((unary)))));
}
bool isLValuePS2435rB(ParsedExpr_s *this) {
    bool succ_10630_ = true;
    bool succ_10628_ = true;
    bool succ_10635_ = true;
    bool succ_10633_ = true;
    bool succ_10646_ = true;
    bool succ_10644_ = true;
    bool succ_10641_ = true;
    bool succ_10653_ = true;

    ExprData_u tmp_16945_ = ((this)->data);
    {
        succ_10630_ &= (tmp_16945_.tag == 5);
        succ_10628_ &= (tmp_16945_.payload.variant5._0.tag == 2);
        succ_10628_ &= true;
        succ_10630_ &= succ_10628_;
        if (succ_10630_) {
            {
                return (true);
            }
            goto after_16945;
        }
    }
    {
        succ_10635_ &= (tmp_16945_.tag == 6);
        succ_10633_ &= (tmp_16945_.payload.variant6._0.tag == 19);
        succ_10633_ &= true;
        succ_10635_ &= succ_10633_;
        if (succ_10635_) {
            {
                return (true);
            }
            goto after_16945;
        }
    }
    {
        succ_10646_ &= (tmp_16945_.tag == 6);
        succ_10644_ &= (tmp_16945_.payload.variant6._0.tag == 1);
        succ_10644_ &= true;
        succ_10641_ &= true;
        succ_10641_ &= true;
        ExprData_u *rhs = &tmp_16945_.payload.variant6._0.payload.variant1._1->data;
        succ_10641_ &= true;
        succ_10641_ &= true;
        succ_10644_ &= succ_10641_;
        succ_10646_ &= succ_10644_;
        if (succ_10646_) {
            {
                bool succ_10649_ = true;

                ExprData_u tmp_16940_ = (*rhs);
                {
                    succ_10649_ &= (tmp_16940_.tag == 4);
                    succ_10649_ &= true;
                    if (succ_10649_) {
                        {
                            return (true);
                        }
                        goto after_16940;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_16940;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_16940:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_16945;
        }
    }
    {
        succ_10653_ &= (tmp_16945_.tag == 4);
        succ_10653_ &= true;
        if (succ_10653_) {
            {
                return (true);
            }
            goto after_16945;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16945;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16945:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBlankPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80305 = (((ExprData_u){.tag = 13, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80305))));
}
bool isIdentifierPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80318 = (((ExprData_u){.tag = 4, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80318))));
}
bool isLiteralPS2435rB(ParsedExpr_s *this) {
    bool succ_10657_ = true;
    bool succ_10661_ = true;
    bool succ_10665_ = true;
    bool succ_10669_ = true;
    bool succ_10672_ = true;
    bool succ_10675_ = true;
    bool succ_10678_ = true;

    ExprData_u *tmp_16964_ = (&((this)->data));
    {
        succ_10657_ &= (tmp_16964_->tag == 0);
        succ_10657_ &= true;
        if (succ_10657_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10661_ &= (tmp_16964_->tag == 1);
        succ_10661_ &= true;
        if (succ_10661_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10665_ &= (tmp_16964_->tag == 2);
        succ_10665_ &= true;
        if (succ_10665_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10669_ &= (tmp_16964_->tag == 3);
        succ_10669_ &= true;
        if (succ_10669_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10672_ &= (tmp_16964_->tag == 12);
        if (succ_10672_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10675_ &= (tmp_16964_->tag == 14);
        if (succ_10675_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        succ_10678_ &= (tmp_16964_->tag == 15);
        if (succ_10678_) {
            {
                return (true);
            }
            goto after_16964;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16964;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16964:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isUnaryPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80343 = (((ExprData_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80343))));
}
bool isCallPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80356 = (((ExprData_u){.tag = 7, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80356))));
}
bool isAssignmentPS2435rB(ParsedExpr_s *this) {
    bool succ_10685_ = true;
    bool succ_10683_ = true;

    ExprData_u *tmp_16971_ = (&((this)->data));
    {
        succ_10685_ &= (tmp_16971_->tag == 6);
        succ_10683_ &= (tmp_16971_->payload.variant6._0.tag == 2);
        succ_10683_ &= true;
        succ_10685_ &= succ_10683_;
        if (succ_10685_) {
            {
                return (true);
            }
            goto after_16971;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16971;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16971:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
usize getIDPS1826rusz(ParsedPattern_s *this) { return ((indexOfPS8361PS1826rusz)((&(patterns)), (this))); }
ParsedPattern_s *newParsedPatternS8951U9267rPS1826(Span_s span, Pattern_u pat) {
    ((pushPS8361S1826rN)((&(patterns)), ((ParsedPattern_s){.ignored = (ignoringNodes), .span = (span), .data = (pat)})));
    return ((lastPS8361rPS1826)((&(patterns))));
}
String_s toStringPS1826rS0540(ParsedPattern_s *this) {
    bool succ_10689_ = true;
    bool succ_10692_ = true;
    bool succ_10696_ = true;
    bool succ_10694_ = true;
    bool succ_10700_ = true;
    bool succ_10698_ = true;
    bool succ_10703_ = true;
    bool succ_10707_ = true;
    bool succ_10711_ = true;
    bool succ_10715_ = true;
    bool succ_10722_ = true;
    bool succ_10731_ = true;
    bool succ_10737_ = true;

    Pattern_u *tmp_17037_ = (&((this)->data));
    {
        succ_10689_ &= (tmp_17037_->tag == 8);
        if (succ_10689_) {
            {
                return ((newStringFromStrLitPcrS0540)(("..")));
            }
            goto after_17037;
        }
    }
    {
        succ_10692_ &= (tmp_17037_->tag == 0);
        if (succ_10692_) {
            {
                return ((newStringFromStrLitPcrS0540)(("_")));
            }
            goto after_17037;
        }
    }
    {
        succ_10696_ &= (tmp_17037_->tag == 9);
        succ_10694_ = tmp_17037_->payload.variant9._0 == true;
        succ_10696_ &= succ_10694_;
        if (succ_10696_) {
            {
                return ((newStringFromStrLitPcrS0540)(("true")));
            }
            goto after_17037;
        }
    }
    {
        succ_10700_ &= (tmp_17037_->tag == 9);
        succ_10698_ = tmp_17037_->payload.variant9._0 == false;
        succ_10700_ &= succ_10698_;
        if (succ_10700_) {
            {
                return ((newStringFromStrLitPcrS0540)(("false")));
            }
            goto after_17037;
        }
    }
    {
        succ_10703_ &= (tmp_17037_->tag == 10);
        if (succ_10703_) {
            {
                return ((newStringFromStrLitPcrS0540)(("null")));
            }
            goto after_17037;
        }
    }
    {
        succ_10707_ &= (tmp_17037_->tag == 2);
        Token_s *ident = &tmp_17037_->payload.variant2._0;
        succ_10707_ &= true;
        if (succ_10707_) {
            {
                return ((toStringPS7720rS0540)((&((*ident).content))));
            }
            goto after_17037;
        }
    }
    {
        succ_10711_ &= (tmp_17037_->tag == 1);
        Token_s *number = &tmp_17037_->payload.variant1._0;
        succ_10711_ &= true;
        if (succ_10711_) {
            {
                return ((toStringPS7720rS0540)((&((*number).content))));
            }
            goto after_17037;
        }
    }
    {
        succ_10715_ &= (tmp_17037_->tag == 4);
        ParsedPattern_s **pat = &tmp_17037_->payload.variant4._0;
        succ_10715_ &= true;
        if (succ_10715_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("&")));
                String_s _s = ((toStringPS1826rS0540)((*pat)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_17037;
        }
    }
    {
        succ_10722_ &= (tmp_17037_->tag == 5);
        Token_s *name = &tmp_17037_->payload.variant5._0;
        succ_10722_ &= true;
        ParsedPatternList_s *pats = &tmp_17037_->payload.variant5._1;
        succ_10722_ &= true;
        if (succ_10722_) {
            {
                String_s s = ((toStringPS7720rS0540)((&((*name).content))));
                if (((*pats).length) == ((usize)(0llu))) {
                    ((pushStrPS0540PcrN)((&(s)), (" { }")));
                }

                else {
                    ((pushStrPS0540PcrN)((&(s)), (" { ")));
                    for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s _s = ((toStringPS1826rS0540)((*((atPS1982uszrPPS1826)((&(*pats)), (i))))));
                        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                        if ((i) != (((*pats).length) - ((usize)(1llu)))) {
                            ((pushStrPS0540PcrN)((&(s)), (", ")));
                        }

                        ((dropPS0540rN)((&(_s))));
                    }

                    ((pushStrPS0540PcrN)((&(s)), (" }")));
                }

                return (s);
            }
            goto after_17037;
        }
    }
    {
        succ_10731_ &= (tmp_17037_->tag == 6);
        Token_s *name = &tmp_17037_->payload.variant6._0;
        succ_10731_ &= true;
        ParsedPattern_s **sub = &tmp_17037_->payload.variant6._1;
        succ_10731_ &= true;
        if (succ_10731_) {
            {
                String_s s = ((toStringPS7720rS0540)((&((*name).content))));
                ((pushStrPS0540PcrN)((&(s)), ("::")));
                String_s _s = ((toStringPS1826rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_17037;
        }
    }
    {
        succ_10737_ &= (tmp_17037_->tag == 7);
        ParsedPatternList_s *pats = &tmp_17037_->payload.variant7._0;
        succ_10737_ &= true;
        if (succ_10737_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("(")));
                for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s _s = ((toStringPS1826rS0540)((*((atPS1982uszrPPS1826)((&(*pats)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                    if ((i) != (((*pats).length) - ((usize)(1llu)))) {
                        ((pushStrPS0540PcrN)((&(s)), (", ")));
                    }

                    ((dropPS0540rN)((&(_s))));
                }

                ((pushStrPS0540PcrN)((&(s)), (")")));
                return (s);
            }
            goto after_17037;
        }
    }
    {
        Pattern_u **unknown = &tmp_17037_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ParsedPattern.toString: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_17037;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17037:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of pattern kinds in ParsedPattern.toString()")));
}
bool equalsPS8951PS8951rB(Span_s *this, Span_s *other) { return (((((this)->file) == ((other)->file)) && (((this)->start) == ((other)->start))) && (((this)->end) == ((other)->end))); }
none printPS8951rN(Span_s *this) {
    String_s s = ((toStringPS8951rS0540)((this)));
    ((printPS0540rN)((&(s))));
    ((dropPS0540rN)((&(s))));
}
String_s toStringPS8951rS0540(Span_s *this) {
    ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), ((this)->file)));
    String_s s = ((toStringPS7720rS0540)((&((file)->origin))));
    usize line = ((usize)(0llu));
    usize col = ((usize)(0llu));
    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (this), (&(line)), (&(col))));
    ((pushCharPS0540crN)((&(s)), (':')));
    ((pushNumberPS0540uszrN)((&(s)), (line)));
    ((pushCharPS0540crN)((&(s)), (':')));
    ((pushNumberPS0540uszrN)((&(s)), (col)));
    return (s);
}
bool comesBeforePS8951PS8951rB(Span_s *this, Span_s *other) { return (((this)->start) < ((other)->start)); }
Span_s newSpanuszuszuszrS8951(usize file, usize start, usize end) {
    ((assertBPcrN)(((end) >= (start)), ("Invalid size for newSpan()")));
    return ((Span_s){.file = (file), .start = (start), .end = (end)});
}
Span_s newSpanBetweenPS8951PS8951rS8951(Span_s *start, Span_s *end) {
    ((assertBPcrN)((((end)->end) >= ((start)->end)), ("newSpanBetween: End Span can\'t end before Start Span.")));
    ((assertBPcrN)((((start)->start) <= ((end)->start)), ("newSpanBetween: Start Span can\'t start after End Span.")));
    ((assertBPcrN)((((start)->file) == ((end)->file)), ("newSpanBetween: Spans can\'t be in different files.")));
    return ((Span_s){.file = ((start)->file), .start = ((start)->start), .end = ((end)->end)});
}
Span_s defaultSpanrS8951(none) { return ((Span_s){.file = ((usize)(0llu)), .start = ((usize)(0llu)), .end = ((usize)(0llu))}); }
bool isMandatoryPS7407rB(Flag_s *flag) { return ((((flag)->mode) & (FLAG_MODE_MANDATORY)) != ((usize)(0llu))); }
String_s toStringPS7407rS0540(Flag_s *this) {
    String_s s = ((String_s){0});
    if (((this)->long_) != (NULL)) {
        ((pushStrPS0540PcrN)((&(s)), ("--")));
        ((pushStrPS0540PcrN)((&(s)), ((this)->long_)));
        bool succ_10769_ = true;

        {
            FlagData_u tmp_17072_ = ((this)->data);
            succ_10769_ &= (tmp_17072_.tag == 1);
            succ_10769_ &= true;

            if (succ_10769_) {
                ((pushStrPS0540PcrN)((&(s)), (" [arg]")));
            }
        }

    }

    else if (((this)->short_) != (NULL)) {
        ((pushCharPS0540crN)((&(s)), ('-')));
        ((pushStrPS0540PcrN)((&(s)), ((this)->short_)));
        bool succ_10772_ = true;

        {
            FlagData_u tmp_17077_ = ((this)->data);
            succ_10772_ &= (tmp_17077_.tag == 1);
            succ_10772_ &= true;

            if (succ_10772_) {
                ((pushStrPS0540PcrN)((&(s)), (" [arg]")));
            }
        }

    }

    else {
        bool succ_10775_ = true;

        FlagData_u tmp_17080_ = ((this)->data);
        succ_10775_ &= (tmp_17080_.tag == 1);
        succ_10775_ &= true;
        if (!succ_10775_) {
            ((unreachablePcrN)(("toString expected String for standalone")));
        };
        ((pushStrPS0540PcrN)((&(s)), ("<standalone>")));
    }

    return (s);
}
bool *addHelpFlagPS7660rPB(FlagParser_s *this) {
    ((assertBPcrN)((((this)->helpFlag) == (NULL)), ("addHelpFlag() called twice")));
    return (((this)->helpFlag) = ((addBoolFlagPS7660PcPcPcrPB)((this), ("h"), ("help"), ("Print help and exit"))));
}
Flag_s *addDefaultFlagPS7660PcPcPcuszU0121rPS7407(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode, FlagData_u data) {
    ((assertBPcrN)((((this)->flagCount) < ((usize)(32llu))), ("Could not add flag: Too many flags")));
    Flag_s *f = (&((((this)->flags).arr)[((this)->flagCount)]));
    bool succ_10778_ = true;

    FlagData_u tmp_17091_ = ((f)->data);
    succ_10778_ &= (tmp_17091_.tag == 0);
    if (!succ_10778_) {
        ((unreachablePcrN)(("addDefaultFlag: Flag not invalid")));
    };
    (((this)->flagCount) = (((this)->flagCount) + ((usize)(1llu))));
    (((f)->mode) = (mode));
    (((f)->short_) = (short_));
    (((f)->long_) = (long_));
    (((f)->descr) = (descr));
    (((f)->data) = (data));
    return (f);
}
String_s *addStringFlagPS7660PcuszrPS0540(FlagParser_s *this, char *descr, usize mode) { return ((addStringFlagPS7660PcPcPcuszrPS0540)((this), (NULL), (NULL), (descr), (mode))); }
String_s *addStringFlagPS7660PcPcPcrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr) {
    return ((addStringFlagPS7660PcPcPcuszrPS0540)((this), (short_), (long_), (descr), (FLAG_MODE_DEFAULT)));
}
String_s *addStringFlagPS7660PcPcPcuszrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode) {
    Flag_s *f = ((addDefaultFlagPS7660PcPcPcuszU0121rPS7407)((this), (short_), (long_), (descr), (mode), ((FlagData_u){.tag = 1, .payload = {.variant1 = {._0 = ((String_s){0})}}})));
    bool succ_10782_ = true;

    FlagData_u *tmp_17103_ = (&((f)->data));
    succ_10782_ &= (tmp_17103_->tag == 1);
    String_s *s = &tmp_17103_->payload.variant1._0;
    succ_10782_ &= true;
    if (!succ_10782_) {
        ((unreachablerN)());
    };
    return (&(*s));
}
bool *addBoolFlagPS7660PcPcrPB(FlagParser_s *this, char *flag, char *descr) {
    if ((((strncmp))(("--"), (flag), ((usize)(2llu)))) == ((i32)(0))) {
        ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(2llu)))));
        return ((addBoolFlagPS7660PcPcPcrPB)((this), (NULL), (flag), (descr)));
    }

    else if ((*(flag)) == ('-')) {
        ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(1llu)))));
        return ((addBoolFlagPS7660PcPcPcrPB)((this), (flag), (NULL), (descr)));
    }

    (((printf))(("%s\n"), (flag)));
    ((assertBPcrN)((false), ("addBoolFlag(&FlagParser, &char, &char) must be called with a flag that has the form -s or --long")));
    ((unreachablerN)());
}
bool *addBoolFlagPS7660PcPcPcrPB(FlagParser_s *this, char *short_, char *long_, char *descr) { return ((addBoolFlagPS7660PcPcPcuszrPB)((this), (short_), (long_), (descr), (FLAG_MODE_DEFAULT))); }
bool *addBoolFlagPS7660PcPcPcuszrPB(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode) {
    Flag_s *f = ((addDefaultFlagPS7660PcPcPcuszU0121rPS7407)((this), (short_), (long_), (descr), (mode), ((FlagData_u){.tag = 2, .payload = {.variant2 = {._0 = (false)}}})));
    bool succ_10787_ = true;

    FlagData_u *tmp_17119_ = (&((f)->data));
    succ_10787_ &= (tmp_17119_->tag == 2);
    bool *b = &tmp_17119_->payload.variant2._0;
    succ_10787_ &= true;
    if (!succ_10787_) {
        ((unreachablerN)());
    };
    return (&(*b));
}
char *shiftArgumentPS7660Pi32PPPcrPc(FlagParser_s *this, i32 *argc, char ***argv) {
    ((assertBrN)(((*(argc)) > ((i32)(0)))));
    char *result = (*(*(argv)));
    ((*(argv)) = (&(((*(argv)))[((usize)(1llu))])));
    ((*(argc)) = ((*(argc)) - ((i32)(1))));
    return (result);
}
none showErrorsAnyPS7660rN(Any stream, FlagParser_s *this) {
    ((assertBPcrN)(((((this)->errors).length) > ((usize)(0llu))), ("showErrors() called but no error collected")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->errors).length)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s *f = (&(((((this)->errors).elements))[(i)]));
        (((fprintf))((stream), ("%.*s"), ((f)->length), ((f)->buffer)));
    }
}
none showUsageAnyPS7660rN(Any stream, FlagParser_s *this) {
    (((fprintf))((stream), ("Usage: %s"), (((this)->programName).buffer)));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        Flag_s *f = (&((((this)->flags).arr)[(i)]));
        if ((isMandatoryPS7407rB)((f))) {
            (((fprintf))((stream), (" %s"), (((toStringPS7407rS0540)((f))).buffer)));
        }
    }

    (((fprintf))((stream), ("\n")));
}
none showHelpAnyPS7660rN(Any stream, FlagParser_s *this) {
    (((fprintf))((stream), ("Help:\n")));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        ((showHelpAnyPS7407rN)((stream), (&((((this)->flags).arr)[(i)]))));
    }
}
none showHelpAnyPS7407rN(Any stream, Flag_s *this) {
    String_s s = ((String_s){0});
    if ((((this)->short_) != (NULL)) && (((this)->long_) != (NULL))) {
        ((pushCharPS0540crN)((&(s)), ('-')));
        ((pushStrPS0540PcrN)((&(s)), ((this)->short_)));
        ((pushStrPS0540PcrN)((&(s)), (" | ")));
        String_s _s = ((toStringPS7407rS0540)((this)));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((dropPS0540rN)((&(_s))));
    }

    else {
        ((s) = ((toStringPS7407rS0540)((this))));
    }

    (((fprintf))((stream), ("%20s: %s"), ((s).buffer), ((this)->descr)));
    if ((isMandatoryPS7407rB)((this))) {
        (((fprintf))((stream), (" [mandatory]")));
    }

    (((fprintf))((stream), ("\n")));
    ((dropPS0540rN)((&(s))));
}
bool helpOrPS7660BrB(FlagParser_s *this, bool or) {
    if (((this)->helpFlag) != (NULL)) {
        return ((*((this)->helpFlag)) || (or));
    }

    return (or);
}
String_s *emitFlagErrorPS7660PcPcrPS0540(FlagParser_s *this, char *msg, char *name) {
    usize len = (((((strlen))((msg))) + (((strlen))((name)))) + ((usize)(1llu)));
    Any buf = (((calloc))((len), (sizeof(char))));
    ((assertBrN)(((buf) != (NULL))));
    (((_snprintf))((buf), (len), (msg), (name)));
    String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), (buf)));
    (((free))((buf)));
    return (err);
}
String_s *emitFlagErrorPS7660PcrPS0540(FlagParser_s *this, char *msg) {
    String_s err = ((newStringFromStrLitPcrS0540)((ERR_STR)));
    ((pushStrPS0540PcrN)((&(err)), (": ")));
    ((pushStrPS0540PcrN)((&(err)), (msg)));
    ((pushCharPS0540crN)((&(err)), ('\n')));
    ((pushPS6808S0540rN)((&((this)->errors)), (err)));
    return ((lastPS6808rPS0540)((&((this)->errors))));
}
String_s emitFlagDescriptionPS7660PS7407rS0540(FlagParser_s *this, Flag_s *f) {
    String_s err = ((newStringFromStrLitPcrS0540)((NOTE_STR)));
    ((pushStrPS0540PcrN)((&(err)), (": Description of flag: ")));
    ((pushStrPS0540PcrN)((&(err)), ((f)->descr)));
    ((pushStrPS0540PcrN)((&(err)), ("\n")));
    return (err);
}
bool runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv) {
    bool res = (((_runOnPS7660i32PPcrB)((this), (argc), (argv))) && ((((this)->errors).length) == ((usize)(0llu))));
    return ((helpOrPS7660BrB)((this), (res)));
}
bool _runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv) {
    if ((((this)->programName).buffer) == (NULL)) {
        char *name = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
        (((this)->programName) = ((newStringFromStrLitPcrS0540)((name))));
    }

    while ((argc) > ((i32)(0))) {
        char *flag = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
        bool long_ = (false);
        bool short_ = (false);
        bool standalone = (false);
        if ((((strncmp))(("--"), (flag), ((usize)(2llu)))) == ((i32)(0))) {
            ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(2llu)))));
            ((long_) = (true));
        }

        else if ((*(flag)) == ('-')) {
            ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(1llu)))));
            ((short_) = (true));
        }

        else {
            ((standalone) = (true));
        }

        bool found = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
            Flag_s *f = (&((((this)->flags).arr)[(i)]));
            if (long_) {
                if (((f)->long_) == (NULL))
                    continue;
                if ((((strcmp))((flag), ((f)->long_))) == ((i32)(0))) {
                    if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                        ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Value for flag --%s was already provided."), ((f)->long_)));
                        return (false);
                    }

                    bool succ_10819_ = true;

                    {
                        FlagData_u *tmp_17216_ = (&((f)->data));
                        succ_10819_ &= (tmp_17216_->tag == 2);
                        bool *b = &tmp_17216_->payload.variant2._0;
                        succ_10819_ &= true;

                        if (succ_10819_) {
                            ((*b) = (true));
                            (((f)->found) = (true));
                        }
                    }

                    bool succ_10823_ = true;

                    {
                        FlagData_u *tmp_17224_ = (&((f)->data));
                        succ_10823_ &= (tmp_17224_->tag == 1);
                        String_s *s = &tmp_17224_->payload.variant1._0;
                        succ_10823_ &= true;

                        if (succ_10823_) {
                            if ((argc) == ((i32)(0))) {
                                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Expected one more positional argument for flag --%s."), ((f)->long_)));
                                return (false);
                            }

                            char *val = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
                            ((*s) = ((newStringFromStrLitPcrS0540)((val))));
                            (((f)->found) = (true));
                        }
                    }

                    ((assertBPcrN)(((f)->found), ("Exhaustive handling of long flags")));
                    ((found) = (true));
                    break;
                }

            }

            else if (short_) {
                if (((f)->short_) == (NULL))
                    continue;
                if ((((strcmp))((flag), ((f)->short_))) == ((i32)(0))) {
                    if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                        ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Value for flag -%s was already provided."), ((f)->short_)));
                        return (false);
                    }

                    bool succ_10828_ = true;

                    {
                        FlagData_u *tmp_17239_ = (&((f)->data));
                        succ_10828_ &= (tmp_17239_->tag == 2);
                        bool *b = &tmp_17239_->payload.variant2._0;
                        succ_10828_ &= true;

                        if (succ_10828_) {
                            ((*b) = (true));
                            (((f)->found) = (true));
                        }
                    }

                    bool succ_10832_ = true;

                    {
                        FlagData_u *tmp_17247_ = (&((f)->data));
                        succ_10832_ &= (tmp_17247_->tag == 1);
                        String_s *s = &tmp_17247_->payload.variant1._0;
                        succ_10832_ &= true;

                        if (succ_10832_) {
                            if ((argc) == ((i32)(0))) {
                                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Expected one more positional argument for flag -%s."), ((f)->short_)));
                                return (false);
                            }

                            char *val = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
                            ((*s) = ((newStringFromStrLitPcrS0540)((val))));
                            (((f)->found) = (true));
                        }
                    }

                    ((assertBPcrN)(((f)->found), ("Exhaustive handling of short flag kinds")));
                    ((found) = (true));
                    break;
                }

            }

            else if (standalone) {
                if (((f)->short_) != (NULL))
                    continue;
                if (((f)->long_) != (NULL))
                    continue;
                if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                    String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), ("Value for standalone flag was already provided.")));
                    String_s note = ((emitFlagDescriptionPS7660PS7407rS0540)((this), (f)));
                    ((pushStringPS0540PS0540rN)((err), (&(note))));
                    ((dropPS0540rN)((&(note))));
                    return (false);
                }

                bool succ_10839_ = true;

                {
                    FlagData_u *tmp_17267_ = (&((f)->data));
                    succ_10839_ &= (tmp_17267_->tag == 2);
                    bool *b = &tmp_17267_->payload.variant2._0;
                    succ_10839_ &= true;

                    if (succ_10839_) {
                        ((*b) = (true));
                        (((f)->found) = (true));
                    }
                }

                bool succ_10843_ = true;

                {
                    FlagData_u *tmp_17270_ = (&((f)->data));
                    succ_10843_ &= (tmp_17270_->tag == 1);
                    String_s *s = &tmp_17270_->payload.variant1._0;
                    succ_10843_ &= true;

                    if (succ_10843_) {
                        ((*s) = ((newStringFromStrLitPcrS0540)((flag))));
                        (((f)->found) = (true));
                    }
                }

                ((assertBPcrN)(((f)->found), ("Exhaustive handling of standalone flag kinds")));
                ((found) = (true));
                break;
            }
        }

        if (!(found)) {
            if (long_)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag --%s."), (flag)));
            if (short_)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag -%s."), (flag)));
            if (standalone)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag %s."), (flag)));
            continue;
        }
    }

    bool allGotten = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        Flag_s *f = (&((((this)->flags).arr)[(i)]));
        if ((!((f)->found)) && ((((f)->mode) & (FLAG_MODE_MANDATORY)) != ((usize)(0llu)))) {
            char *name = ((f)->long_);
            if ((name) == (NULL))
                ((name) = ((f)->short_));
            if ((name) == (NULL)) {
                String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), ("Mandatory standalone flag not provided.")));
                String_s note = ((emitFlagDescriptionPS7660PS7407rS0540)((this), (f)));
                ((pushStringPS0540PS0540rN)((err), (&(note))));
                ((dropPS0540rN)((&(note))));
            }

            else {
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("No value for flag `%s` was provided."), (name)));
            }

            ((allGotten) = (false));
        }
    }

    return (allGotten);
}
bool analyzeControlFlowPS9562rB(IRGen_s *irgen) { return (true); }
none __format_helperPS0540S4175rN(String_s *out, Data_s arg) {
    bool succ_10857_ = true;
    bool succ_10866_ = true;
    bool succ_10870_ = true;

    TypeInfo_u tmp_17367_ = ((arg).info);
    {
        succ_10857_ &= (tmp_17367_.tag == 5);
        SubStr_s *name = &tmp_17367_.payload.variant5._0;
        succ_10857_ &= true;
        succ_10857_ &= true;
        succ_10857_ &= true;
        FieldTypeInfoList_s *fields = &tmp_17367_.payload.variant5._3;
        succ_10857_ &= true;
        if (succ_10857_) {
            {
                if ((((strncmp))(((*name).start), ("SubStr"), ((*name).len))) == ((i32)(0))) {
                    ((pushSubStrPS0540PS7720rN)((out), ((arg).ptr)));
                }

                else if ((((strncmp))(((*name).start), ("String"), ((*name).len))) == ((i32)(0))) {
                    ((pushStringPS0540PS0540rN)((out), ((arg).ptr)));
                }

                else {
                    ((pushSubStrPS0540PS7720rN)((out), (&(*name))));
                    for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        FieldTypeInfo_s *f = (&((((*fields).elements))[(i)]));
                        if ((i) > ((usize)(0llu)))
                            ((pushCharPS0540crN)((out), (',')));
                        ((pushSubStrPS0540PS7720rN)((out), (&((f)->name))));
                        Any field_ptr = ((Any)((((usize)(((arg).ptr))) + ((f)->offset_in_bytes))));
                        ((__format_helperPS0540S4175rN)((out), ((Data_s){.ptr = (field_ptr), .info = (((type_info_table))[((f)->type)])})));
                    }

                    ((pushStrPS0540PcrN)((out), (" }")));
                }
            }
            goto after_17367;
        }
    }
    {
        succ_10866_ &= (tmp_17367_.tag == 1);
        SubStr_s *name = &tmp_17367_.payload.variant1._0;
        succ_10866_ &= true;
        usize *size = &tmp_17367_.payload.variant1._1;
        succ_10866_ &= true;
        usize *align = &tmp_17367_.payload.variant1._2;
        succ_10866_ &= true;
        if (succ_10866_) {
            {
                if ((((strncmp))(((*name).start), ("i8"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i8rN)((out), (*(i8 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i16"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i16rN)((out), (*(i16 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i32"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i32rN)((out), (*(i32 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i64"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i64rN)((out), (*(i64 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u8"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u8rN)((out), (*(u8 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u16"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u16rN)((out), (*(u16 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u32"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u32rN)((out), (*(u32 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u64"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u64rN)((out), (*(u64 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("usize"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("bool"), ((*name).len))) == ((i32)(0)))
                    if (*(bool *)((arg).ptr))
                        ((pushStrPS0540PcrN)((out), ("true")));
                    else
                        ((pushStrPS0540PcrN)((out), ("false")));
                else if ((((strncmp))(((*name).start), ("char"), ((*name).len))) == ((i32)(0)))
                    ((pushCharPS0540crN)((out), (*(char *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("Any"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberAsHexPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                else
                    ((unreachablePcrN)(("__format_helper primitive")));
            }
            goto after_17367;
        }
    }
    {
        succ_10870_ &= (tmp_17367_.tag == 3);
        succ_10870_ &= true;
        usize *underlying = &tmp_17367_.payload.variant3._1;
        succ_10870_ &= true;
        if (succ_10870_) {
            {
                TypeInfo_u tmp_82092 = (type_info_table[12]);

                if ((equalsPU7843PU7843rB)((&(((type_info_table))[(*underlying)])), (&tmp_82092))) {
                    ((pushStrPS0540PcrN)((out), (*(char **)((arg).ptr))));
                }

                else {
                    ((pushNumberAsHexPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                }
            }
            goto after_17367;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("__format_helper")));
            }
            goto after_17367;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17367:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none formatPS0540PcVS4175rN(String_s *out, char *fmt, variadic_4480 args) {
    usize l = (((strlen))((fmt)));
    usize arg_count = ((usize)(0llu));
    bool escaped = (false);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c = (((fmt))[(i)]);
        if ((c) == ('\\')) {
            ((escaped) = (true));
        }

        else if ((c) == ('%')) {
            if (escaped) {
                ((pushCharPS0540crN)((out), (c)));
            }

            else {
                ((assertBPcrN)(((arg_count) < ((args).length)), ("RUNTIME ERROR: Format string received too many arguments")));
                Data_s arg = (((args).ptr)[(arg_count)]);
                ((__format_helperPS0540S4175rN)((out), (arg)));
                ((arg_count) = ((arg_count) + ((usize)(1llu))));
            }

            ((escaped) = (false));
        }

        else {
            ((pushCharPS0540crN)((out), (c)));
            ((escaped) = (false));
        }
    }

    ((assertBPcrN)(((arg_count) == ((args).length)), ("RUNTIME ERROR: Unused arguments in format string")));
}
String_s format1PcVS4175rS0540(char *fmt, variadic_4480 args) {
    String_s s = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(s)), (fmt), (args)));
    return (s);
}
none fprintPcVS4175rN(char *fmt, variadic_4480 args) {
    String_s o = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(o)), (fmt), (args)));
    ((printPS0540rN)((&(o))));
    ((dropPS0540rN)((&(o))));
}
GAF_List_s new_GAF_ListU7843rS3646(TypeInfo_u ti) {
    return ((GAF_List_s){.elements = (NULL), .length = ((usize)(0llu)), .capacity = ((usize)(0llu)), .type = (ti), .type_size = ((get_sizePU7843rusz)((&(ti))))});
}
none enumeratePS3646FN_uszS4175rN(GAF_List_s *this, none (*fn)(usize, Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)((i), ((get_refPS3646uszrS4175)((this), (i)))));
    }
}
none enumeratePS3646FN_usz_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(usize, Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)((i), ((get_refPS3646uszrS4175)((this), (i))), (arg)));
    }
}
none foreachPS3646FNS4175rN(GAF_List_s *this, none (*fn)(Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)(((get_refPS3646uszrS4175)((this), (i)))));
    }
}
none foreachPS3646FN_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)(((get_refPS3646uszrS4175)((this), (i))), (arg)));
    }
}
none pushPS3646S4175rN(GAF_List_s *list, Data_s elem) {
    if (!((equalsPU7843PU7843rB)((&((list)->type)), (&((elem).info))))) {
        SubStr_s want = ((get_namePU7843rS7720)((&((list)->type))));
        SubStr_s got = ((get_namePU7843rS7720)((&((elem).info))));
        (((fprintf))((stderr_), ("got:  %.*s\n"), ((got).len), ((got).start)));
        (((fprintf))((stderr_), ("want: %.*s\n"), ((want).len), ((want).start)));
        (((fprintf))((stderr_), ("GAF_List.push: Attempted to push invalid element\n")));
        (((C_exiti32rN))(((i32)(1))));
    }

    if (((list)->length) >= ((list)->capacity)) {
        usize new_cap = (((list)->capacity) * ((usize)(2llu)));
        if ((new_cap) == ((usize)(0llu)))
            ((new_cap) = ((usize)(32llu)));
        (((list)->elements) = (((realloc))(((list)->elements), ((new_cap) * ((list)->type_size)))));
        ((assertBPcrN)((((list)->elements) != (NULL)), ("GAF_List.push: Could not allocate memory")));
        (((list)->capacity) = (new_cap));
    }

    (((memcpy))(((usize *)((unsigned char *)((usize *)(((list)->elements))) + (((list)->length) * ((list)->type_size)))), ((elem).ptr), ((list)->type_size)));
    (((list)->length) = (((list)->length) + ((usize)(1llu))));
}
none popPS3646rN(GAF_List_s *list) { ((popPS3646AnyrN)((list), (NULL))); }
none popPS3646AnyrN(GAF_List_s *list, Any dst) {
    ((assertBPcrN)((((list)->length) > ((usize)(0llu))), ("GAF_List.pop: Attempted to pop from empty list")));
    (((list)->length) = (((list)->length) - ((usize)(1llu))));
    if ((dst) != (NULL)) {
        usize *elem = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + (((list)->length) * ((list)->type_size))));
        (((memcpy))((dst), (elem), ((list)->type_size)));
    }
}
Data_s get_refPS3646uszrS4175(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.get_ref: Out of bounds access")));
    return ((Data_s){.ptr = ((get_ref_rawPS3646uszrAny)((list), (index))), .info = ((list)->type)});
}
Any get_ref_rawPS3646uszrAny(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.get_ref_raw: Out of bounds access")));
    return ((Any)(((usize)(((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((index) * ((list)->type_size))))))));
}
none swap_removePS3646uszrN(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.swap_remove: Out of bounds removal")));
    usize *dst = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((index) * ((list)->type_size))));
    usize *src = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((((list)->length) - ((usize)(1llu))) * ((list)->type_size))));
    (((memcpy))((dst), (src), ((list)->type_size)));
    (((list)->length) = (((list)->length) - ((usize)(1llu))));
}
usize _anon_46_0S4175rusz(Data_s key) { return ((hashPS7720rusz)(((SubStr_s *)(((key).ptr))))); }
bool _anon_46_1S4175S4175rB(Data_s k1, Data_s k2) { return ((equalsPS7720PS7720rB)(((SubStr_s *)(((k1).ptr))), ((SubStr_s *)(((k2).ptr))))); }
GAF_HashMap_s new_hashmap_with_substr_keyU7843rS4580(TypeInfo_u info) {
    return ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((type_info_table[16]), (info), (_anon_46_0S4175rusz), (_anon_46_1S4175S4175rB)));
}
usize _anon_46_2S4175rusz(Data_s key) { return ((hashPS0540rusz)(((String_s *)(((key).ptr))))); }
bool _anon_46_3S4175S4175rB(Data_s k1, Data_s k2) { return ((equalsPS0540PS0540rB)(((String_s *)(((k1).ptr))), ((String_s *)(((k2).ptr))))); }
GAF_HashMap_s new_hashmap_with_string_keyU7843rS4580(TypeInfo_u info) {
    return ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((type_info_table[18]), (info), (_anon_46_2S4175rusz), (_anon_46_3S4175S4175rB)));
}
GAF_HashMap_s new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580(TypeInfo_u key, TypeInfo_u value, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s)) {
    return ((GAF_HashMap_s){.elements = (NULL),
                            .keys = (NULL),
                            .set_elements = (NULL),
                            .length = ((usize)(0llu)),
                            .capacity = ((usize)(0llu)),
                            .key_type = (key),
                            .key_type_size = ((get_sizePU7843rusz)((&(key)))),
                            .value_type = (value),
                            .value_type_size = ((get_sizePU7843rusz)((&(value)))),
                            .key_hash_fn = (key_hash),
                            .key_equals_fn = (key_equals)});
}
none _anon_46_4S4175S4175PS3646rN(Data_s k, Data_s elem, GAF_List_s *arg) { ((pushPS3646S4175rN)((arg), (elem))); }
GAF_List_s asListPS4580rS3646(GAF_HashMap_s *this) {
    GAF_List_s l = ((new_GAF_ListU7843rS3646)(((this)->value_type)));
    ((foreachPS4580FN_S4175_S4175AnyAnyrN)((this), (_anon_46_4S4175S4175PS3646rN), (&(l))));
    return (l);
}
none enumeratePS4580FN_usz_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s)) {
    usize index = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10906_ = true;

            tuple_4518 tmp_17464_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17464_._0;
            succ_10906_ &= true;
            Data_s *value = &tmp_17464_._1;
            succ_10906_ &= true;
            (void)succ_10906_;
            ((fn)((index), (*key), (*value)));
            ((index) = ((index) + ((usize)(1llu))));
        }
    }
}
none enumeratePS4580FN_usz_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s, Any), Any arg) {
    usize index = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10913_ = true;

            tuple_4518 tmp_17473_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17473_._0;
            succ_10913_ &= true;
            Data_s *value = &tmp_17473_._1;
            succ_10913_ &= true;
            (void)succ_10913_;
            ((fn)((index), (*key), (*value), (arg)));
            ((index) = ((index) + ((usize)(1llu))));
        }
    }
}
none foreachPS4580FN_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10918_ = true;

            tuple_4518 tmp_17481_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17481_._0;
            succ_10918_ &= true;
            Data_s *value = &tmp_17481_._1;
            succ_10918_ &= true;
            (void)succ_10918_;
            ((fn)((*key), (*value)));
        }
    }
}
none foreachPS4580FN_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10923_ = true;

            tuple_4518 tmp_17488_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17488_._0;
            succ_10923_ &= true;
            Data_s *value = &tmp_17488_._1;
            succ_10923_ &= true;
            (void)succ_10923_;
            ((fn)((*key), (*value), (arg)));
        }
    }
}
bool needsResizePS4580rB(GAF_HashMap_s *this) {
    if (((this)->capacity) == ((usize)(0llu)))
        return (true);
    f64 loadFactor = (((f64)(((this)->length))) / ((f64)(((this)->capacity))));
    ((assertBrN)(((loadFactor) <= ((f64)(1)))));
    return ((((f64)(10)) * (loadFactor)) > ((f64)(6)));
}
none resizeIfNecessaryPS4580rN(GAF_HashMap_s *this) {
    if (!((needsResizePS4580rB)((this))))
        return;
    usize newCap = (((this)->capacity) * ((usize)(2llu)));
    if ((newCap) == ((usize)(0llu)))
        ((newCap) = ((usize)(256llu)));
    Any newElements = (((calloc))((newCap), ((this)->value_type_size)));
    ((assertBPcrN)(((newElements) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    Any newKeys = (((calloc))((newCap), ((this)->key_type_size)));
    ((assertBPcrN)(((newKeys) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    Any newSetElements = (((calloc))((newCap), (sizeof(bool))));
    ((assertBPcrN)(((newSetElements) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    GAF_HashMap_s newThis = ((GAF_HashMap_s){.elements = (newElements),
                                             .keys = (newKeys),
                                             .set_elements = (newSetElements),
                                             .length = ((usize)(0llu)),
                                             .capacity = (newCap),
                                             .key_type = ((this)->key_type),
                                             .key_type_size = ((this)->key_type_size),
                                             .value_type = ((this)->value_type),
                                             .value_type_size = ((this)->value_type_size),
                                             .key_hash_fn = ((this)->key_hash_fn),
                                             .key_equals_fn = ((this)->key_equals_fn)});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        bool succ_10937_ = true;

        tuple_4518 tmp_17512_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
        Data_s *key = &tmp_17512_._0;
        succ_10937_ &= true;
        Data_s *value = &tmp_17512_._1;
        succ_10937_ &= true;
        (void)succ_10937_;
        if ((((this)->set_elements))[(i)])
            ((addPS4580S4175S4175rN)((&(newThis)), (*key), (*value)));
    }

    (((free))(((this)->elements)));
    (((free))(((this)->keys)));
    (((free))(((this)->set_elements)));
    ((*(this)) = (newThis));
}
none addPS4580S4175S4175rN(GAF_HashMap_s *this, Data_s key, Data_s value) {
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->key_type)), (&((key).info)))), ("GAF_HashMap.add: Key type mismatch")));
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->value_type)), (&((value).info)))), ("GAF_HashMap.add: Value type mismatch")));
    ((resizeIfNecessaryPS4580rN)((this)));
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize _hash = ((((this)->key_hash_fn)((key))) % ((this)->capacity));
    usize stop = ((_hash) - ((usize)(1llu)));
    if ((_hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((_hash) != (stop)) {
        bool succ_10944_ = true;

        tuple_4518 tmp_17529_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (_hash)));
        Data_s *_key = &tmp_17529_._0;
        succ_10944_ &= true;
        Data_s *_value = &tmp_17529_._1;
        succ_10944_ &= true;
        (void)succ_10944_;
        bool must_write = (false);
        if (!((((this)->set_elements))[(_hash)])) {
            ((must_write) = (true));
            (((this)->length) = (((this)->length) + ((usize)(1llu))));
        }

        else if (((this)->key_equals_fn)((*_key), (key))) {
            ((must_write) = (true));
        }

        if (must_write) {
            (((memcpy))(((*_key).ptr), ((key).ptr), ((this)->key_type_size)));
            (((memcpy))(((*_value).ptr), ((value).ptr), ((this)->value_type_size)));
            (((((this)->set_elements))[(_hash)]) = (true));
            return;
        }

        ((_hash) = (((_hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Could not insert element into HashMap")));
}
bool containsPS4580S4175rB(GAF_HashMap_s *this, Data_s key) { return ((((getPS4580S4175rS4175)((this), (key))).ptr) != (NULL)); }
Data_s getPS4580S4175rS4175(GAF_HashMap_s *this, Data_s key) {
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->key_type)), (&((key).info)))), ("GAF_HashMap.get: Key type mismatch")));
    if (((this)->length) == ((usize)(0llu)))
        return ((Data_s){.info = ((this)->value_type), .ptr = (NULL)});
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize _hash = ((((this)->key_hash_fn)((key))) % ((this)->capacity));
    usize stop = ((_hash) - ((usize)(1llu)));
    if ((_hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((_hash) != (stop)) {
        bool succ_10952_ = true;

        tuple_4518 tmp_17557_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (_hash)));
        Data_s *_key = &tmp_17557_._0;
        succ_10952_ &= true;
        Data_s *_value = &tmp_17557_._1;
        succ_10952_ &= true;
        (void)succ_10952_;
        if (!((((this)->set_elements))[(_hash)]))
            return ((Data_s){.info = ((this)->value_type), .ptr = (NULL)});
        if (((this)->key_equals_fn)((*_key), (key)))
            return (*_value);
        ((_hash) = (((_hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Load Factor guarantees that there\'s always at least one unset Entry in the HashMap.")));
}
tuple_4518 getAtIndexPS4580uszrT_S4175S4175(GAF_HashMap_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->capacity)), ("Out of bounds access in GAF_HashMap.getAtIndex")));
    Data_s key = ((Data_s){.ptr = ((char *)((unsigned char *)((char *)(((this)->keys))) + ((index) * ((this)->key_type_size)))), .info = ((this)->key_type)});
    Data_s value = ((Data_s){.ptr = ((char *)((unsigned char *)((char *)(((this)->elements))) + ((index) * ((this)->value_type_size)))), .info = ((this)->value_type)});
    return ((tuple_4518){(key), (value)});
}
GAF_HashSet_s new_substr_hashsetrS1250(none) { return ((GAF_HashSet_s){._map = ((new_hashmap_with_substr_keyU7843rS4580)((type_info_table[10])))}); }
GAF_HashSet_s new_string_hashsetrS1250(none) { return ((GAF_HashSet_s){._map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[10])))}); }
GAF_HashSet_s new_GAF_HashSetU7843FuszS4175FB_S4175S4175rS1250(TypeInfo_u key, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s)) {
    return ((GAF_HashSet_s){._map = ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((key), (type_info_table[10]), (key_hash), (key_equals)))});
}
none addPS1250S4175rN(GAF_HashSet_s *this, Data_s key) {
    bool tmp_91699 = (true);

    ((addPS4580S4175S4175rN)((&((this)->_map)), (key), ((Data_s){.ptr = &tmp_91699, .info = type_info_table[10]})));
}
bool containsPS1250S4175rB(GAF_HashSet_s *this, Data_s key) { return ((containsPS4580S4175rB)((&((this)->_map)), (key))); }
CStack_s newCStackrS1662(none) { return ((CStack_s){.variables = ((new_hashmap_with_substr_keyU7843rS4580)((type_info_table[216])))}); }
CGen_s newCGenrS9442(none) {
    return ((CGen_s){.stack = ((new_GAF_ListU7843rS3646)((type_info_table[217]))),
                     .variadic_map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .array_map_declared = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .array_map_defined = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .tuple_map_declared = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .tuple_map_defined = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .type_info_table = ((generateTypeInfoTablerS3131)())});
}
tuple_4302 getVariableInfoPS9442S7720rT_S0610B(CGen_s *this, SubStr_s name) {
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->stack).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->stack).length) - (_i)) - ((usize)(1llu)));
        CStack_s *entry = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), (i)))));
        SubStr_s tmp_90992 = (name);

        Data_s _entry = ((getPS4580S4175rS4175)((&((entry)->variables)), ((Data_s){.ptr = &tmp_90992, .info = type_info_table[16]})));
        if (((_entry).ptr) != (NULL)) {
            return ((tuple_4302){(*(Var_Context_s *)((_entry).ptr)), (true)});
        }
    }

    return ((tuple_4302){((Var_Context_s){0}), (false)});
}
String_s unescapeS7720rS0540(SubStr_s s) {
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((s).len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((s).start))[(i)]) == ('\0')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\0")));
        }

        else if (((((s).start))[(i)]) == ('\n')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\n")));
        }

        else if (((((s).start))[(i)]) == ('\t')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\t")));
        }

        else if (((((s).start))[(i)]) == ('\r')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\r")));
        }

        else if (((((s).start))[(i)]) == ('\\')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\\")));
        }

        else if (((((s).start))[(i)]) == ('\'')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\'")));
        }

        else if (((((s).start))[(i)]) == ('\"')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\"")));
        }

        else if ((((u8)(((((s).start))[(i)]))) >= ((u8)(127))) || (((((s).start))[(i)]) < (' '))) {
            ((pushStrPS0540PcrN)((&(out)), ("\\x")));
            String_s tmp = ((String_s){0});
            ((pushNumberAsHexPS0540uszrN)((&(tmp)), ((usize)(((((s).start))[(i)])))));
            (((tmp).buffer) = ((char *)((unsigned char *)((tmp).buffer) + ((usize)(2llu)))));
            (((tmp).length) = (((tmp).length) - ((usize)(2llu))));
            ((pushStringPS0540PS0540rN)((&(out)), (&(tmp))));
            (((tmp).buffer) = ((char *)((unsigned char *)((tmp).buffer) - ((usize)(2llu)))));
            (((tmp).length) = (((tmp).length) + ((usize)(2llu))));
            ((dropPS0540rN)((&(tmp))));
        }

        else {
            ((pushCharPS0540crN)((&(out)), ((((s).start))[(i)])));
        }
    }

    return (out);
}
String_s generateTypeNamePS9442PU5175S0540rS0540(CGen_s *this, Type_u *type, String_s nameForType) {
    return ((generateTypeNamePS9442PU5175S7720rS0540)((this), (type), ((asSubStrPS0540rS7720)((&(nameForType))))));
}
String_s generateTypeNamePS9442PU5175S7720rS0540(CGen_s *this, Type_u *type, SubStr_s nameForType) {
    return ((generateTypeNamePS9442PU5175S7720uszrS0540)((this), (type), (nameForType), ((usize)(0llu))));
}
String_s generateTypeNamePS9442PU5175S7720uszrS0540(CGen_s *this, Type_u *type, SubStr_s nameForType, usize size) {
    String_s out = ((String_s){0});
    bool succ_10974_ = true;

    Type_u *tmp_17662_ = (type);
    {
        succ_10974_ &= (tmp_17662_->tag == 6);
        TypeList_s *params = &tmp_17662_->payload.variant6._0;
        succ_10974_ &= true;
        Type_u **ret = &tmp_17662_->payload.variant6._1;
        succ_10974_ &= true;
        succ_10974_ &= true;
        if (succ_10974_) {
            {
                if ((size) == ((usize)(0llu))) {
                    String_s tmp_90993 = ((generateTypeNamePS9442PU5175rS0540)((this), (*ret)));
                    SubStr_s tmp_90994 = (nameForType);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% (*%)("),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_90993, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90994, .info = type_info_table[16]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_90996 = ((generateTypeNamePS9442PU5175rS0540)((this), (*ret)));
                    SubStr_s tmp_90997 = (nameForType);
                    usize tmp_90998 = (size);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% (*%[%])("),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_90996, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90997, .info = type_info_table[16]}),
                                                                               ((Data_s){.ptr = &tmp_90998, .info = type_info_table[8]})},
                                                               .length = 3})));
                }

                if (((*params).length) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("none"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }

                else {
                    for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_91001 = ((generateTypeNamePS9442PU5175rS0540)((this), ((((*params).elements))[(i)])));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91001, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*params).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (")"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_17662;
        }
    }
    {
        if (true) {
            {
                if (((nameForType).len) != ((usize)(0llu))) {
                    if ((size) != ((usize)(0llu))) {
                        String_s tmp_91005 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        SubStr_s tmp_91006 = (nameForType);
                        usize tmp_91007 = (size);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% %[%]"),
                                                  ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91005, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91006, .info = type_info_table[16]}),
                                                                                      ((Data_s){.ptr = &tmp_91007, .info = type_info_table[8]})},
                                                                   .length = 3})));
                    }

                    else {
                        String_s tmp_91009 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        SubStr_s tmp_91010 = (nameForType);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% %"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91009, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91010, .info = type_info_table[16]})},
                                                      .length = 2})));
                    }

                }

                else {
                    if ((size) != ((usize)(0llu))) {
                        String_s tmp_91012 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        usize tmp_91013 = (size);

                        ((formatPS0540PcVS4175rN)((&(out)), ("%[%]"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91012, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91013, .info = type_info_table[8]})},
                                                      .length = 2})));
                    }

                    else {
                        String_s tmp_91015 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91015, .info = type_info_table[18]})}, .length = 1})));
                    }
                }
            }
            goto after_17662;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17662:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateTypeNamePS9442PU5175rS0540(CGen_s *this, Type_u *type) {
    bool succ_10981_ = true;
    bool succ_10985_ = true;
    bool succ_10989_ = true;
    bool succ_10995_ = true;
    bool succ_11000_ = true;
    bool succ_11006_ = true;
    bool succ_11010_ = true;
    bool succ_11016_ = true;

    Type_u *tmp_17709_ = (type);
    {
        succ_10981_ &= (tmp_17709_->tag == 3);
        succ_10981_ &= true;
        if (succ_10981_) {
            {
                return ((toStringPU5175rS0540)((type)));
            }
            goto after_17709;
        }
    }
    {
        succ_10985_ &= (tmp_17709_->tag == 4);
        Type_u **under = &tmp_17709_->payload.variant4._0;
        succ_10985_ &= true;
        if (succ_10985_) {
            {
                String_s tmp_91017 = ((generateTypeNamePS9442PU5175rS0540)((this), (*under)));

                return ((format1PcVS4175rS0540)(("%*"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91017, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_17709;
        }
    }
    {
        succ_10989_ &= (tmp_17709_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_17709_->payload.variant7._0;
        succ_10989_ &= true;
        if (succ_10989_) {
            {
                String_s name = ((getFullNamePS5521PcrS0540)((*decl), ("_")));
                ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
                return (name);
            }
            goto after_17709;
        }
    }
    {
        succ_10995_ &= (tmp_17709_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_17709_->payload.variant8._0;
        succ_10995_ &= true;
        succ_10995_ &= true;
        if (succ_10995_) {
            {
                String_s name = ((getFullNamePS0997PcrS0540)((*decl), ("_")));
                ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
                return (name);
            }
            goto after_17709;
        }
    }
    {
        succ_11000_ &= (tmp_17709_->tag == 10);
        TypeList_s *elems = &tmp_17709_->payload.variant10._0;
        succ_11000_ &= true;
        if (succ_11000_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_91019 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_91019, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_91020 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91020, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17709;
        }
    }
    {
        succ_11006_ &= (tmp_17709_->tag == 6);
        succ_11006_ &= true;
        if (succ_11006_) {
            {
                return ((generateTypeNamePS9442PU5175S7720rS0540)((this), (type), (((newSubStrOfStrLitPcrS7720)((""))))));
            }
            goto after_17709;
        }
    }
    {
        succ_11010_ &= (tmp_17709_->tag == 5);
        succ_11010_ &= true;
        if (succ_11010_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_91022 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_91022, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_91023 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("array_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91023, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17709;
        }
    }
    {
        succ_11016_ &= (tmp_17709_->tag == 2);
        Type_u **under = &tmp_17709_->payload.variant2._0;
        succ_11016_ &= true;
        if (succ_11016_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_91025 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_91025, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_91026 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("variadic_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91026, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17709;
        }
    }
    {
        if (true) {
            {
                String_s tmp_83725 = ((toStringPU5175rS0540)((type)));

                ((printPS0540rN)((&tmp_83725)));
                (((printf))(("\n")));
                return ((newStringFromStrLitPcrS0540)(("/*TODO: generateTypeName */")));
            }
            goto after_17709;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17709:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generateTypeName")));
}
String_s generateTypeNamePS9442PS1372rS0540(CGen_s *this, ParsedTypeNode_s *type) { return ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((type)->typeState)))))); }
none makeNameCCompatiblePS0540rN(String_s *name) { ((makeNameCCompatiblePS0540PcrN)((name), (""))); }
none makeNameCCompatiblePS0540PcrN(String_s *name, char *prefix) {
    array_33255 forbidden = ((array_33255){("stdin"),    ("stdout"), ("stderr"), ("enum"),   ("union"),    ("struct"), ("if"),   ("else"),  ("switch"), ("case"), ("for"),  ("while"), ("break"),
                                           ("continue"), ("do"),     ("return"), ("signed"), ("unsigned"), ("void"),   ("bool"), ("float"), ("double"), ("int"),  ("char"), ("short"), ("long")});
    ((pushStrPS0540PcrN)((name), (prefix)));
    for (usize i = ((usize)(0llu)); ((i) < (26)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s s = ((newStringFromStrLitPcrS0540)((((forbidden).arr)[(i)])));
        if ((equalsPS0540PS0540rB)((name), (&(s)))) {
            String_s tmp_91028 = (s);

            ((*(name)) = ((format1PcVS4175rS0540)(("%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91028, .info = type_info_table[18]})}, .length = 1}))));
        }

        ((dropPS0540rN)((&(s))));
    }

    ((replacePS0540ccrN)((name), ('.'), ('_')));
}
none generateBuiltinTypedefsPS0540rN(String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Builtin Types:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stddef.h> // NULL\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stdbool.h> // bool\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stdint.h>\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint8_t u8;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint16_t u16;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint32_t u32;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint64_t u64;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int8_t i8;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int16_t i16;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int32_t i32;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int64_t i64;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef void* Any;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef void none;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef float f32;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef double f64;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef u64 usize;\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// C doesn\'t have f32 \\% f32 etc.\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("float fmodf(float x, float y);\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("double fmod(double x, double y);\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none forwardDeclareTypesPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Struct Declarations:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareStructPS0540PS5521rN)((out), ((atPS2168uszrPS5521)((&(structDecls)), (i)))));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Union Declarations:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareUnionPS0540PS0997rN)((out), ((atPS4268uszrPS0997)((&(unionDecls)), (i)))));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Tuple Types:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((forwardDeclareTuplePS9442PS0540PU5175rN)((this), (out), (type)));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Array Types:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((forwardDeclareArrayPS9442PS0540PU5175rN)((this), (out), (type)));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none emitTypeDeclarationPS9442PS0540PS4580PU5175rN(CGen_s *this, String_s *out, GAF_HashMap_s *map, Type_u *type) {
    String_s tmp_91059 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

    Data_s _entry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_91059, .info = type_info_table[18]})));
    bool succ_11039_ = true;
    bool succ_11046_ = true;
    bool succ_11056_ = true;
    bool succ_11068_ = true;

    Type_u *tmp_17850_ = (type);
    {
        succ_11039_ &= (tmp_17850_->tag == 5);
        Type_u **elem = &tmp_17850_->payload.variant5._0;
        succ_11039_ &= true;
        succ_11039_ &= true;
        if (succ_11039_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find array")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                String_s tmp_91060 = ((generateTypeNamePS9442PU5175rS0540)((this), (*elem)));

                Data_s elemEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_91060, .info = type_info_table[18]})));
                if (((elemEntry).ptr) != (NULL)) {
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((elemEntry).ptr)));
                    if (!((entry)->generated)) {
                        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (*elem)));
                    }
                }
            }
            goto after_17850;
        }
    }
    {
        succ_11046_ &= (tmp_17850_->tag == 10);
        TypeList_s *elems = &tmp_17850_->payload.variant10._0;
        succ_11046_ &= true;
        if (succ_11046_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find tuple")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize j = ((usize)(0llu)); ((j) < ((*elems).length)); ((j) = ((j) + ((usize)(1llu))))) {
                    Type_u *field = ((((*elems).elements))[(j)]);
                    String_s tmp_91061 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                    Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_91061, .info = type_info_table[18]})));
                    if (((fieldEntry).ptr) == (NULL))
                        continue;
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                    if ((entry)->generated)
                        continue;
                    ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                }
            }
            goto after_17850;
        }
    }
    {
        succ_11056_ &= (tmp_17850_->tag == 7);
        ParsedStructDecl_s **strukt = &tmp_17850_->payload.variant7._0;
        succ_11056_ &= true;
        if (succ_11056_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find struct")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize j = ((usize)(0llu)); ((j) < (((*strukt)->context).fieldLength)); ((j) = ((j) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *_field = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*strukt)->context)), (j)));
                    Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                    String_s tmp_91062 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                    Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_91062, .info = type_info_table[18]})));
                    if (((fieldEntry).ptr) == (NULL))
                        continue;
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                    if ((entry)->generated)
                        continue;
                    ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                }
            }
            goto after_17850;
        }
    }
    {
        succ_11068_ &= (tmp_17850_->tag == 8);
        ParsedUnionDecl_s **onion = &tmp_17850_->payload.variant8._0;
        succ_11068_ &= true;
        succ_11068_ &= true;
        if (succ_11068_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find union")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize i = ((usize)(0llu)); ((i) < (((*onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*onion)->variants)), (i))));
                    bool succ_11076_ = true;
                    bool succ_11074_ = true;

                    tuple_1017 tmp_17832_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
                    succ_11074_ = tmp_17832_._0 == true;
                    succ_11076_ &= succ_11074_;
                    ParsedTypeNodeList_s **fields = &tmp_17832_._1;
                    succ_11076_ &= true;
                    if (!succ_11076_) {
                        continue;
                    };
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedTypeNode_s *_field = (*((atPS6760uszrPPS1372)((*fields), (j))));
                        Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                        String_s tmp_91063 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                        Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_91063, .info = type_info_table[18]})));
                        if (((fieldEntry).ptr) == (NULL))
                            continue;
                        TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                        if ((entry)->generated)
                            continue;
                        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                    }
                }
            }
            goto after_17850;
        }
    }
    {
        if (true) {
            {
                ((assertBPcrN)((((_entry).ptr) == (NULL)), ("emitTypeDeclaration: Missed a Type")));
            }
            goto after_17850;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17850:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (((_entry).ptr) != (NULL)) {
        TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
        ((assertBPcrN)((!((entry)->generated)), ("emitTypeDeclaration: Type already generated")));
        ((pushStringPS0540PS0540rN)((out), (&((entry)->c_code))));
        (((entry)->generated) = (true));
    }
}
none emitVariadicTypePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11087_ = true;

    Type_u *tmp_17858_ = (type);
    succ_11087_ &= (tmp_17858_->tag == 2);
    Type_u **under = &tmp_17858_->payload.variant2._0;
    succ_11087_ &= true;
    if (!succ_11087_) {
        ((unreachablePcrN)(("emitVariadicType")));
    };
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91064 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_91064, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_91065 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("variadic_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91065, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91067 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91067, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91069 = (ind);
    String_s tmp_91070 = ((generateTypeNamePS9442PU5175rS0540)((this), (*under)));

    ((formatPS0540PcVS4175rN)((out), ("%%* ptr;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91069, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91070, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_91072 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%usize length;\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91072, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91074 = (name);

    ((formatPS0540PcVS4175rN)((out), ("} %;\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91074, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91076 = (_t);
    String_s tmp_91077 = (name);

    ((addPS4580S4175S4175rN)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_91076, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91077, .info = type_info_table[18]})));
}
none generateTypeDeclarationsPS9442PS0540rN(CGen_s *this, String_s *out) {
    GAF_HashMap_s map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[219])));
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((strukt)->ignored)
            continue;
        String_s s = ((String_s){0});
        ((generateStructDefinitionPS9442PS0540PS5521rN)((this), (&(s)), (strukt)));
        String_s tmp_91078 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((strukt)->typeState))))));
        TypeDeclEntry_s tmp_91079 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91078, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91079, .info = type_info_table[219]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((onion)->ignored)
            continue;
        String_s s = ((String_s){0});
        ((generateUnionDefinitionPS9442PS0540PS0997rN)((this), (&(s)), (onion)));
        String_s tmp_91080 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((onion)->typeState))))));
        TypeDeclEntry_s tmp_91081 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91080, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91081, .info = type_info_table[219]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        String_s s = ((String_s){0});
        ((generateTupleDefinitionPS9442PS0540PU5175rN)((this), (&(s)), (type)));
        if (((s).length) == ((usize)(0llu)))
            continue;
        String_s tmp_91082 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
        TypeDeclEntry_s tmp_91083 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91082, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91083, .info = type_info_table[219]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        String_s s = ((String_s){0});
        ((generateArrayDefinitionPS9442PS0540PU5175rN)((this), (&(s)), (type)));
        if (((s).length) == ((usize)(0llu)))
            continue;
        String_s tmp_91084 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
        TypeDeclEntry_s tmp_91085 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91084, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91085, .info = type_info_table[219]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((strukt)->ignored)
            continue;
        Type_u *sType = ((getTypePU9661rPU5175)((&((strukt)->typeState))));
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (sType)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((onion)->ignored)
            continue;
        Type_u *uType = ((getTypePU9661rPU5175)((&((onion)->typeState))));
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (uType)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (type)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (type)));
    }
}
none forwardDeclareFunctionsPS9442PS0540rN(CGen_s *this, String_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareFunctionPS9442PS0540PS4904rN)((this), (out), ((atPS4111uszrPS4904)((&(funcDecls)), (i)))));
    }
}
none generateFunctionDefinitionsPS9442PS0540rN(CGen_s *this, String_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((generateFunctionDefinitionPS9442PS0540PS4904rN)((this), (out), ((atPS4111uszrPS4904)((&(funcDecls)), (i)))));
    }
}
none _anon_44_0PS9442PS0540S6070PU5175PS2435uszrN(CGen_s *this, String_s *out, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent) {
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s tmp_91087 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (_name)));

    ((formatPS0540PcVS4175rN)((out), ("%;\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91087, .info = type_info_table[18]})}, .length = 1})));
    CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
    SubStr_s tmp_91089 = ((tkn).content);
    Var_Context_s tmp_91090 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

    ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91089, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91090, .info = type_info_table[216]})));
}
none generateGlobalVariablesPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Global Variables:\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                ParsedStmt_s *_decl = ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)));
                bool succ_11143_ = true;

                StmtData_u *tmp_17968_ = (&((_decl)->data));
                succ_11143_ &= (tmp_17968_->tag == 0);
                VarDecl_s *decl = &tmp_17968_->payload.variant0._0;
                succ_11143_ &= true;
                if (!succ_11143_) {
                    ((unreachablerN)());
                };
                none (*fast_path)(CGen_s *, String_s *, Token_s, Type_u *, ParsedExpr_s *, usize) = (_anon_44_0PS9442PS0540S6070PU5175PS2435uszrN);
                bool succ_11151_ = true;

                {
                    Pattern_u *tmp_17978_ = (&(((*decl).pat)->data));
                    succ_11151_ &= (tmp_17978_->tag == 3);
                    ParsedPattern_s **subpat = &tmp_17978_->payload.variant3._0;
                    succ_11151_ &= true;
                    ParsedTypeNode_s **typ = &tmp_17978_->payload.variant3._1;
                    succ_11151_ &= true;

                    if (succ_11151_) {
                        bool succ_11155_ = true;

                        {
                            Pattern_u *tmp_17977_ = (&((*subpat)->data));
                            succ_11155_ &= (tmp_17977_->tag == 2);
                            Token_s *tkn = &tmp_17977_->payload.variant2._0;
                            succ_11155_ &= true;

                            if (succ_11155_) {
                                ((fast_path)((this), (out), (*tkn), ((getTypePU9661rPU5175)((&((*typ)->typeState)))), ((*decl).expr), ((usize)(0llu))));
                                continue;
                            }
                        }
                    }
                }

                bool succ_11159_ = true;

                {
                    Pattern_u *tmp_17981_ = (&(((*decl).pat)->data));
                    succ_11159_ &= (tmp_17981_->tag == 2);
                    Token_s *tkn = &tmp_17981_->payload.variant2._0;
                    succ_11159_ &= true;

                    if (succ_11159_) {
                        ((fast_path)((this), (out), (*tkn), ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState)))), ((*decl).expr), ((usize)(0llu))));
                        continue;
                    }
                }

                ((unreachablePcrN)(("generateGlobalVariables: Can\'t use slow_path here")));
            }
        }
    }
}
String_s _anon_44_1PS9442S6070PS2435uszrS0540(CGen_s *this, Token_s tkn, ParsedExpr_s *expr, usize indent) {
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s tmpAlloc = ((String_s){0});
    String_s tmp_91091 = ((generateIndentuszrS0540)((indent)));
    String_s tmp_91092 = (_name);
    String_s tmp_91093 = ((generateExprPS9442PS0540PS2435rS0540)((this), (&(tmpAlloc)), (expr)));

    return ((format1PcVS4175rS0540)(("%% = %;\n"),
                                    ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91091, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91092, .info = type_info_table[18]}),
                                                                        ((Data_s){.ptr = &tmp_91093, .info = type_info_table[18]})},
                                                     .length = 3})));
    ((assertBPcrN)((((tmpAlloc).length) == ((usize)(0llu))), ("generateGlobalInit: Expression needs entry")));
}
String_s generateGlobalInitPS9442PS1100uszrS0540(CGen_s *this, ParsedStmt_s *_decl, usize indent) {
    bool succ_11163_ = true;

    StmtData_u *tmp_17990_ = (&((_decl)->data));
    succ_11163_ &= (tmp_17990_->tag == 0);
    VarDecl_s *decl = &tmp_17990_->payload.variant0._0;
    succ_11163_ &= true;
    if (!succ_11163_) {
        ((unreachablerN)());
    };
    String_s (*fast_path)(CGen_s *, Token_s, ParsedExpr_s *, usize) = (_anon_44_1PS9442S6070PS2435uszrS0540);
    bool succ_11172_ = true;

    {
        Pattern_u *tmp_17999_ = (&(((*decl).pat)->data));
        succ_11172_ &= (tmp_17999_->tag == 3);
        ParsedPattern_s **subpat = &tmp_17999_->payload.variant3._0;
        succ_11172_ &= true;
        succ_11172_ &= true;

        if (succ_11172_) {
            bool succ_11176_ = true;

            {
                Pattern_u *tmp_17998_ = (&((*subpat)->data));
                succ_11176_ &= (tmp_17998_->tag == 2);
                Token_s *tkn = &tmp_17998_->payload.variant2._0;
                succ_11176_ &= true;

                if (succ_11176_) {
                    return ((fast_path)((this), (*tkn), ((*decl).expr), (indent)));
                }
            }
        }
    }

    bool succ_11180_ = true;

    {
        Pattern_u *tmp_18001_ = (&(((*decl).pat)->data));
        succ_11180_ &= (tmp_18001_->tag == 2);
        Token_s *tkn = &tmp_18001_->payload.variant2._0;
        succ_11180_ &= true;

        if (succ_11180_) {
            return ((fast_path)((this), (*tkn), ((*decl).expr), (indent)));
        }
    }

    ((unreachablePcrN)(("generateGlobalInit: Can\'t use slow_path here")));
}
none generateGlobalInitializationPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("none __global_init_please_dont_call_yourself(none) {\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                String_s tmp_91096 = ((generateGlobalInitPS9442PS1100uszrS0540)((this), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID))), (INDENTATION_LEVEL)));

                ((formatPS0540PcVS4175rN)((out), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91096, .info = type_info_table[18]})}, .length = 1})));
            }
        }
    }

    ((formatPS0540PcVS4175rN)((out), ("}\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none transpileToCrN(none) {
    ((generateCCoderN)());
    ((generateBuildScriptrN)());
}
none generateCCoderN(none) {
    String_s c_code = ((String_s){0});
    CGen_s cgen = ((newCGenrS9442)());
    CStack_s tmp_91099 = ((newCStackrS1662)());

    ((pushPS3646S4175rN)((&((cgen).stack)), ((Data_s){.ptr = &tmp_91099, .info = type_info_table[217]})));
    ((generateBuiltinTypedefsPS0540rN)((&(c_code))));
    ((forwardDeclareTypesPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((generateTypeDeclarationsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((forwardDeclareFunctionsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((generateGlobalVariablesPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((generateGlobalInitializationPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((generateFunctionDefinitionsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((generateEntrypointPS0540rN)((&(c_code))));
    ((writeStringToFilePcS0540rN)((((flags).out)->buffer), (c_code)));
    String_s tmp_91104 = (*((flags).out));

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91104, .info = type_info_table[18]})}, .length = 1})));
}
none generateBuildScriptrN(none) {
    ((generateClangScriptrN)());
    String_s tmp_85145 = ((toStringPS7720rS0540)((&(OS_WINDOWS))));
    String_s tmp_85157 = ((toStringPS7720rS0540)((&(OS_LINUX))));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85145))) {
        ((generateClexeScriptrN)());
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85157))) {
        ((generateGCCScriptrN)());
    }

    else {
        ((unreachablePcrN)(("generateBuildScript")));
    }
}
none generateClexeScriptrN(none) {
    String_s file = ((String_s){0});
    String_s tmp_91106 = (*((flags).out));

    String_s name = ((format1PcVS4175rS0540)(("%.cl.bat"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91106, .info = type_info_table[18]})}, .length = 1})));
    String_s command = ((String_s){0});
    String_s tmp_91108 = (*((flags).out));
    String_s tmp_91109 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("@cl.exe /nologo /Fe:%.exe %"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91108, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91109, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" /W4 /wd4047 /wd4024 /wd4100 /wd4189 /wd4702 /wd4101 /wd4456 /wd4459 /wd4457"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11207_ = true;

            Config_u *tmp_18058_ = (_flag);
            succ_11207_ &= (tmp_18058_->tag == 1);
            Token_s *name = &tmp_18058_->payload.variant1._0;
            succ_11207_ &= true;
            if (!succ_11207_) {
                continue;
            };
            SubStr_s tmp_91112 = ((*name).content);

            ((formatPS0540PcVS4175rN)((&(command)), (" %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91112, .info = type_info_table[16]})}, .length = 1})));
        }
    }

    bool emitted_link = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11218_ = true;
            bool succ_11222_ = true;

            Config_u *tmp_18085_ = (_flag);
            {
                succ_11218_ &= (tmp_18085_->tag == 3);
                Token_s *name = &tmp_18085_->payload.variant3._0;
                succ_11218_ &= true;
                if (succ_11218_) {
                    {
                        if (!(emitted_link)) {
                            ((formatPS0540PcVS4175rN)((&(command)), (" /link"), ((variadic_4480){.ptr = NULL, .length = 0})));
                            ((emitted_link) = (true));
                        }

                        SubStr_s tmp_91115 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" /LIBPATH:%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91115, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18085;
                }
            }
            {
                succ_11222_ &= (tmp_18085_->tag == 4);
                Token_s *name = &tmp_18085_->payload.variant4._0;
                succ_11222_ &= true;
                if (succ_11222_) {
                    {
                        if (!(emitted_link)) {
                            ((formatPS0540PcVS4175rN)((&(command)), (" /link"), ((variadic_4480){.ptr = NULL, .length = 0})));
                            ((emitted_link) = (true));
                        }

                        SubStr_s tmp_91118 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91118, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18085;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18085;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18085:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91120 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91120, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91122 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91122, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91124 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91124, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91126 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91126, .info = type_info_table[18]})}, .length = 1})));
}
none generateGCCScriptrN(none) {
    String_s file = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(file)), ("#!/usr/bin/env bash\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    String_s tmp_91129 = (*((flags).out));

    String_s name = ((format1PcVS4175rS0540)(("%.gcc.sh"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91129, .info = type_info_table[18]})}, .length = 1})));
    String_s command = ((String_s){0});
    String_s tmp_91131 = (*((flags).out));
    String_s tmp_91132 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("gcc -x c % -o %.exe"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91131, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91132, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wall -Wextra -Werror -pedantic -std=c99"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-builtin-declaration-mismatch -Wno-incompatible-pointer-types -Wno-missing-braces"), ((variadic_4480){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11239_ = true;
            bool succ_11243_ = true;
            bool succ_11247_ = true;

            Config_u *tmp_18117_ = (_flag);
            {
                succ_11239_ &= (tmp_18117_->tag == 1);
                Token_s *name = &tmp_18117_->payload.variant1._0;
                succ_11239_ &= true;
                if (succ_11239_) {
                    {
                        SubStr_s tmp_91137 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -l %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91137, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18117;
                }
            }
            {
                succ_11243_ &= (tmp_18117_->tag == 3);
                Token_s *name = &tmp_18117_->payload.variant3._0;
                succ_11243_ &= true;
                if (succ_11243_) {
                    {
                        SubStr_s tmp_91139 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -L %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91139, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18117;
                }
            }
            {
                succ_11247_ &= (tmp_18117_->tag == 4);
                Token_s *name = &tmp_18117_->payload.variant4._0;
                succ_11247_ &= true;
                if (succ_11247_) {
                    {
                        SubStr_s tmp_91141 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -Xlinker %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91141, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18117;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18117;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18117:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91143 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91143, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91145 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91145, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91147 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91147, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91149 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91149, .info = type_info_table[18]})}, .length = 1})));
}
none generateClangScriptrN(none) {
    String_s file = ((String_s){0});
    String_s name = ((String_s){0});
    String_s command = ((String_s){0});
    String_s tmp_91151 = (*((flags).out));
    String_s tmp_91152 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("clang % -o %.exe"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91151, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91152, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wall -Wextra -Werror -pedantic -std=c99 -ferror-limit=5"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-incompatible-library-redeclaration -Wno-builtin-requires-header"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-unused-variable -Wno-unused-parameter -Wno-incompatible-function-pointer-types"), ((variadic_4480){.ptr = NULL, .length = 0})));
    String_s tmp_85529 = ((toStringPS7720rS0540)((&(OS_WINDOWS))));
    String_s tmp_85553 = ((toStringPS7720rS0540)((&(OS_LINUX))));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85529))) {
        String_s tmp_91157 = (*((flags).out));

        ((name) = ((format1PcVS4175rS0540)(("%.clang.bat"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91157, .info = type_info_table[18]})}, .length = 1}))));
        ((formatPS0540PcVS4175rN)((&(file)), ("@"), ((variadic_4480){.ptr = NULL, .length = 0})));
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85553))) {
        String_s tmp_91160 = (*((flags).out));

        ((name) = ((format1PcVS4175rS0540)(("%.clang.sh"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91160, .info = type_info_table[18]})}, .length = 1}))));
        ((formatPS0540PcVS4175rN)((&(file)), ("#!/usr/bin/env bash\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    }

    else {
        ((unreachablePcrN)(("generateClangScript")));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11264_ = true;
            bool succ_11268_ = true;
            bool succ_11272_ = true;

            Config_u *tmp_18158_ = (_flag);
            {
                succ_11264_ &= (tmp_18158_->tag == 1);
                Token_s *name = &tmp_18158_->payload.variant1._0;
                succ_11264_ &= true;
                if (succ_11264_) {
                    {
                        SubStr_s tmp_91163 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -l %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91163, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18158;
                }
            }
            {
                succ_11268_ &= (tmp_18158_->tag == 3);
                Token_s *name = &tmp_18158_->payload.variant3._0;
                succ_11268_ &= true;
                if (succ_11268_) {
                    {
                        SubStr_s tmp_91165 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -L %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91165, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18158;
                }
            }
            {
                succ_11272_ &= (tmp_18158_->tag == 4);
                Token_s *name = &tmp_18158_->payload.variant4._0;
                succ_11272_ &= true;
                if (succ_11272_) {
                    {
                        SubStr_s tmp_91167 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -Xlinker %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91167, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18158;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18158;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18158:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91169 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91169, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91171 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91171, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91173 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91173, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91175 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91175, .info = type_info_table[18]})}, .length = 1})));
}
none generateEntrypointPS0540rN(String_s *out) {
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    ((formatPS0540PcVS4175rN)((out), ("// The entry point for the C runtime\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("int main(int argc, char **argv) {\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    String_s tmp_91179 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%__global_init_please_dont_call_yourself();\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91179, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91181 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%return __real_main(argc, argv, &maini32PPcri32);\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91181, .info = type_info_table[18]})}, .length = 1})));
    ((formatPS0540PcVS4175rN)((out), ("}\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none forwardDeclareTuplePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91184 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_91184, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize tmp_91185 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91185, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91187 = (name);
    String_s tmp_91188 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91187, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91188, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_91190 = (_t);
    String_s tmp_91191 = (name);

    ((addPS4580S4175S4175rN)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_91190, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91191, .info = type_info_table[18]})));
}
none generateTupleDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11281_ = true;

    Type_u *tmp_18184_ = (type);
    succ_11281_ &= (tmp_18184_->tag == 10);
    TypeList_s *elems = &tmp_18184_->payload.variant10._0;
    succ_11281_ &= true;
    if (!succ_11281_) {
        ((unreachablePcrN)(("generateTupleDefinition")));
    };
    ((assertBrN)((((*elems).length) != ((usize)(0llu)))));
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91192 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_defined)), ((Data_s){.ptr = &tmp_91192, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_91193 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91193, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91195 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91195, .info = type_info_table[18]})}, .length = 1})));
    for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *field = ((((*elems).elements))[(i)]);
        usize tmp_91197 = (i);

        String_s _name = ((format1PcVS4175rS0540)(("_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91197, .info = type_info_table[8]})}, .length = 1})));
        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
        String_s tmp_91199 = (ind);
        String_s tmp_91200 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

        ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                                  ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91199, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91200, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    String_s tmp_91203 = (_t);
    String_s tmp_91204 = (name);

    ((addPS4580S4175S4175rN)((&((this)->tuple_map_defined)), ((Data_s){.ptr = &tmp_91203, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91204, .info = type_info_table[18]})));
}
none forwardDeclareArrayPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91205 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_91205, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize tmp_91206 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("array_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91206, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91208 = (name);
    String_s tmp_91209 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91208, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91209, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_91211 = (_t);
    String_s tmp_91212 = (name);

    ((addPS4580S4175S4175rN)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_91211, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91212, .info = type_info_table[18]})));
}
none generateArrayDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11298_ = true;

    Type_u *tmp_18214_ = (type);
    succ_11298_ &= (tmp_18214_->tag == 5);
    Type_u **elem = &tmp_18214_->payload.variant5._0;
    succ_11298_ &= true;
    usize *size = &tmp_18214_->payload.variant5._1;
    succ_11298_ &= true;
    if (!succ_11298_) {
        ((unreachablePcrN)(("generateArrayDefinition")));
    };
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91213 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_defined)), ((Data_s){.ptr = &tmp_91213, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize _size = (*size);
    if ((_size) == ((usize)(0llu)))
        ((_size) = ((usize)(1llu)));
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_91214 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("array_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91214, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91216 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91216, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91218 = (ind);
    String_s tmp_91219 = ((generateTypeNamePS9442PU5175S7720uszrS0540)((this), (*elem), (((newSubStrOfStrLitPcrS7720)(("arr")))), (_size)));

    ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91218, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91219, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    String_s tmp_91222 = (_t);
    String_s tmp_91223 = (name);

    ((addPS4580S4175S4175rN)((&((this)->array_map_defined)), ((Data_s){.ptr = &tmp_91222, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91223, .info = type_info_table[18]})));
}
none forwardDeclareStructPS0540PS5521rN(String_s *out, ParsedStructDecl_s *strukt) {
    if ((strukt)->ignored)
        return;
    String_s name = ((getFullNamePS5521PcrS0540)((strukt), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
    String_s tmp_91224 = (name);
    String_s tmp_91225 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91224, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91225, .info = type_info_table[18]})},
                                               .length = 2})));
}
none generateStructDefinitionPS9442PS0540PS5521rN(CGen_s *this, String_s *out, ParsedStructDecl_s *strukt) {
    if ((strukt)->ignored)
        return;
    if ((((strukt)->context).fieldLength) == ((usize)(0llu)))
        return;
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    String_s name = ((getFullNamePS5521PcrS0540)((strukt), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
    String_s tmp_91227 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91227, .info = type_info_table[18]})}, .length = 1})));
    for (usize i = ((usize)(0llu)); ((i) < (((strukt)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s nameTkn = ((getFieldNameAtIndexPS7871uszrS6070)((&((strukt)->context)), (i)));
        ParsedTypeNode_s *_field = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((strukt)->context)), (i)));
        Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
        String_s _name = ((toStringPS7720rS0540)((&((nameTkn).content))));
        ((makeNameCCompatiblePS0540rN)((&(_name))));
        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
        String_s tmp_91229 = (ind);
        String_s tmp_91230 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

        ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                                  ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91229, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91230, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none forwardDeclareUnionPS0540PS0997rN(String_s *out, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return;
    String_s name = ((getFullNamePS0997PcrS0540)((onion), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
    String_s tmp_91233 = (name);
    String_s tmp_91234 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91233, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91234, .info = type_info_table[18]})},
                                               .length = 2})));
}
none generateUnionDefinitionPS9442PS0540PS0997rN(CGen_s *this, String_s *out, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return;
    ((assertBPcrN)(((((onion)->variants).length) < ((usize)(256llu))), ("generateUnionDefinition: Tag needs u16")));
    ((assertBPcrN)(((((onion)->variants).length) != ((usize)(0llu))), ("generateUnionDefinition: Empty Union?")));
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    String_s name = ((getFullNamePS0997PcrS0540)((onion), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
    String_s tmp_91236 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91236, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91238 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%u8 tag;\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91238, .info = type_info_table[18]})}, .length = 1})));
    bool has_non_empty = (false);
    for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
        bool succ_11327_ = true;

        {
            ParsedUnionVariantData_u *tmp_18274_ = (&((variant)->data));
            succ_11327_ &= (tmp_18274_->tag == 0);

            if (succ_11327_) {
                continue;
            } else {
                ((has_non_empty) = (true));
                break;
            }
        }
    }

    if (has_non_empty) {
        String_s tmp_91240 = (ind);

        ((formatPS0540PcVS4175rN)((out), ("%union {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91240, .info = type_info_table[18]})}, .length = 1})));
        for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
            bool succ_11334_ = true;
            bool succ_11332_ = true;

            tuple_1017 tmp_18281_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_11332_ = tmp_18281_._0 == true;
            succ_11334_ &= succ_11332_;
            ParsedTypeNodeList_s **fields = &tmp_18281_._1;
            succ_11334_ &= true;
            if (!succ_11334_) {
                continue;
            };
            String_s tmp_91242 = (ind);
            String_s tmp_91243 = (ind);

            String_s payload =
                ((format1PcVS4175rS0540)(("%%struct {\n"),
                                         ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91242, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91243, .info = type_info_table[18]})},
                                                          .length = 2})));
            for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                ParsedTypeNode_s *_field = (*((atPS6760uszrPPS1372)((*fields), (j))));
                Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                usize tmp_91245 = (j);

                String_s _name = ((format1PcVS4175rS0540)(("_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91245, .info = type_info_table[8]})}, .length = 1})));
                SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
                String_s tmp_91247 = (ind);
                String_s tmp_91248 = (ind);
                String_s tmp_91249 = (ind);
                String_s tmp_91250 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

                ((formatPS0540PcVS4175rN)((&(payload)), ("%%%%;\n"),
                                          ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91247, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91248, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91249, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91250, .info = type_info_table[18]})},
                                                           .length = 4})));
                ((dropPS0540rN)((&(_name))));
            }

            String_s tmp_91252 = (ind);
            String_s tmp_91253 = (ind);
            usize tmp_91254 = (i);

            ((formatPS0540PcVS4175rN)((&(payload)), ("%%} variant%;\n"),
                                      ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91252, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91253, .info = type_info_table[18]}),
                                                                          ((Data_s){.ptr = &tmp_91254, .info = type_info_table[8]})},
                                                       .length = 3})));
            ((pushStringPS0540PS0540rN)((out), (&(payload))));
        }

        String_s tmp_91256 = (ind);

        ((formatPS0540PcVS4175rN)((out), ("%} payload;\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91256, .info = type_info_table[18]})}, .length = 1})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none forwardDeclareFunctionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function) {
    if ((function)->ignored)
        return;
    String_s name = ((getMangledNamePS4904rS0540)((function)));
    ((makeNameCCompatiblePS0540rN)((&(name))));
    ((emitFunctionSignaturePS9442PS0540S0540PS4904BrN)((this), (out), (name), (function), (true)));
    ((formatPS0540PcVS4175rN)((out), (";\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
}
none generateFunctionDefinitionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function) {
    if ((function)->ignored)
        return;
    if ((isExternPS4904rB)((function)))
        return;
    String_s name = ((getMangledNamePS4904rS0540)((function)));
    ((makeNameCCompatiblePS0540rN)((&(name))));
    ((emitFunctionSignaturePS9442PS0540S0540PS4904rN)((this), (out), (name), (function)));
    CStack_s stack = ((newCStackrS1662)());
    for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
        SubStr_s tmp_91260 = ((name).content);
        Var_Context_s tmp_91261 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

        ((addPS4580S4175S4175rN)((&((stack).variables)), ((Data_s){.ptr = &tmp_91260, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91261, .info = type_info_table[216]})));
    }

    CStack_s tmp_91262 = (stack);

    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91262, .info = type_info_table[217]})));
    String_s tmp_91263 = ((generateBlockPS9442PS7247uszrS0540)((this), ((function)->body), (INDENTATION_LEVEL)));

    ((formatPS0540PcVS4175rN)((out), (" %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91263, .info = type_info_table[18]})}, .length = 1})));
    ((popPS3646rN)((&((this)->stack))));
}
none emitFunctionSignaturePS9442PS0540S0540PS4904rN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function) {
    ((emitFunctionSignaturePS9442PS0540S0540PS4904BrN)((this), (out), (name), (function), (false)));
}
none emitFunctionSignaturePS9442PS0540S0540PS4904BrN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function, bool generateVariadics) {
    String_s fnSig = ((String_s){0});
    if ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 3, .payload = {0}})))) {
        ((formatPS0540PcVS4175rN)((out), ("#if defined(__clang__) || defined(__GNUC__)\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("__attribute__((noreturn))\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#elif defined(_WIN32)\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("__declspec(noreturn)\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#else\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#error \"Can\'t mark function as noreturn on your compiler. PRs welcome.\"\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#endif\n"), ((variadic_4480){.ptr = NULL, .length = 0})));
    }

    String_s tmp_91272 = ((generateTypeNamePS9442PS1372rS0540)((this), ((function)->retType)));
    String_s tmp_91273 = (name);

    ((formatPS0540PcVS4175rN)((&(fnSig)), ("% %("),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91272, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91273, .info = type_info_table[18]})},
                                               .length = 2})));
    if ((((function)->params).paramLength) == ((usize)(0llu))) {
        ((formatPS0540PcVS4175rN)((&(fnSig)), ("none"), ((variadic_4480){.ptr = NULL, .length = 0})));
    }

    else {
        for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
            Token_s _name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
            String_s name = ((toStringPS7720rS0540)((&((_name).content))));
            ((makeNameCCompatiblePS0540rN)((&(name))));
            ParsedTypeNode_s *typDecl = ((getTypeAtIndexPS9803uszrPS1372)((&((function)->params)), (i)));
            Type_u *pType = ((getTypePU9661rPU5175)((&((typDecl)->typeState))));
            bool succ_11360_ = true;

            {
                Type_u *tmp_18345_ = (pType);
                succ_11360_ &= (tmp_18345_->tag == 2);
                Type_u **under = &tmp_18345_->payload.variant2._0;
                succ_11360_ &= true;

                if (succ_11360_) {
                    if (generateVariadics) {
                        ((emitVariadicTypePS9442PS0540PU5175rN)((this), (out), (pType)));
                    }
                }
            }

            String_s tmp_91276 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (pType), ((asSubStrPS0540rS7720)((&(name))))));

            ((formatPS0540PcVS4175rN)((&(fnSig)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91276, .info = type_info_table[18]})}, .length = 1})));
            if ((i) != ((((function)->params).paramLength) - ((usize)(1llu)))) {
                ((formatPS0540PcVS4175rN)((&(fnSig)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
        }
    }

    if (((isExternPS4904rB)((function))) && (((function)->params).isVarArg)) {
        ((formatPS0540PcVS4175rN)((&(fnSig)), (", ..."), ((variadic_4480){.ptr = NULL, .length = 0})));
    }

    ((formatPS0540PcVS4175rN)((&(fnSig)), (")"), ((variadic_4480){.ptr = NULL, .length = 0})));
    ((pushStringPS0540PS0540rN)((out), (&(fnSig))));
}
String_s generateBlockPS9442PS7247uszrS0540(CGen_s *this, ParsedBlock_s *block, usize indent) {
    ((assertBPcrN)(((indent) != ((usize)(0llu))), ("generateBlock without indent")));
    String_s out = ((String_s){0});
    String_s tmp_91281 = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));

    ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91281, .info = type_info_table[18]})}, .length = 1})));
    {
        CStack_s tmp_91283 = ((newCStackrS1662)());

        ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91283, .info = type_info_table[217]})));
        for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
            String_s entry = ((String_s){0});
            String_s stmt = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (&(entry)), ((((block)->stmtList))[(i)]), (indent)));
            if (((entry).length) != ((usize)(0llu))) {
                String_s tmp_91284 = (entry);

                ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91284, .info = type_info_table[18]})}, .length = 1})));
                ((dropPS0540rN)((&(entry))));
            }

            String_s tmp_91286 = (stmt);

            ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91286, .info = type_info_table[18]})}, .length = 1})));
        }

        ((popPS3646rN)((&((this)->stack))));
    }

    String_s tmp_91288 = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));

    ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91288, .info = type_info_table[18]})}, .length = 1})));
    return (out);
}
String_s generateIndentuszrS0540(usize indent) {
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (indent)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((&(out)), (' ')));
    }

    return (out);
}
String_s generateStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent) {
    String_s out = ((String_s){0});
    bool succ_11377_ = true;

    {
        StmtData_u *tmp_18385_ = (&((stmt)->data));
        succ_11377_ &= (tmp_18385_->tag == 4);
        succ_11377_ &= true;

        if (succ_11377_) {
        } else {
            ((out) = ((generateIndentuszrS0540)((indent))));
        }
    }

    bool succ_11381_ = true;
    bool succ_11384_ = true;
    bool succ_11388_ = true;
    bool succ_11392_ = true;
    bool succ_11396_ = true;
    bool succ_11401_ = true;
    bool succ_11407_ = true;
    bool succ_11412_ = true;
    bool succ_11419_ = true;
    bool succ_11422_ = true;
    bool succ_11425_ = true;
    bool succ_11429_ = true;
    bool succ_11434_ = true;
    bool succ_11441_ = true;
    bool succ_11457_ = true;
    bool succ_11473_ = true;

    StmtData_u *tmp_18471_ = (&((stmt)->data));
    {
        succ_11381_ &= (tmp_18471_->tag == 0);
        VarDecl_s *decl = &tmp_18471_->payload.variant0._0;
        succ_11381_ &= true;
        if (succ_11381_) {
            {
                String_s tmp_91290 = ((generateVarDeclPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (stmt), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%;"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91290, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11384_ &= (tmp_18471_->tag == 1);
        if (succ_11384_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("return;"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18471;
        }
    }
    {
        succ_11388_ &= (tmp_18471_->tag == 2);
        ParsedExpr_s **expr = &tmp_18471_->payload.variant2._0;
        succ_11388_ &= true;
        if (succ_11388_) {
            {
                String_s tmp_91293 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("return %;"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91293, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11392_ &= (tmp_18471_->tag == 3);
        ParsedExpr_s **expr = &tmp_18471_->payload.variant3._0;
        succ_11392_ &= true;
        if (succ_11392_) {
            {
                String_s tmp_91295 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%;"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91295, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11396_ &= (tmp_18471_->tag == 4);
        ParsedBlock_s **block = &tmp_18471_->payload.variant4._0;
        succ_11396_ &= true;
        if (succ_11396_) {
            {
                String_s tmp_91297 = ((generateBlockPS9442PS7247uszrS0540)((this), (*block), ((indent) + (INDENTATION_LEVEL))));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91297, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11401_ &= (tmp_18471_->tag == 5);
        ParsedExpr_s **cond = &tmp_18471_->payload.variant5._0;
        succ_11401_ &= true;
        ParsedStmt_s **body = &tmp_18471_->payload.variant5._1;
        succ_11401_ &= true;
        if (succ_11401_) {
            {
                String_s tmp_91299 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91300 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("if %\n%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91299, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91300, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18471;
        }
    }
    {
        succ_11407_ &= (tmp_18471_->tag == 6);
        ParsedExpr_s **cond = &tmp_18471_->payload.variant6._0;
        succ_11407_ &= true;
        ParsedStmt_s **body = &tmp_18471_->payload.variant6._1;
        succ_11407_ &= true;
        ParsedStmt_s **elze = &tmp_18471_->payload.variant6._2;
        succ_11407_ &= true;
        if (succ_11407_) {
            {
                String_s tmp_91302 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91303 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));
                String_s tmp_91304 = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91305 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*elze), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("if %\n%\n%else\n%"),
                                          ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91302, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91303, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91304, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91305, .info = type_info_table[18]})},
                                                           .length = 4})));
            }
            goto after_18471;
        }
    }
    {
        succ_11412_ &= (tmp_18471_->tag == 7);
        ParsedExpr_s **cond = &tmp_18471_->payload.variant7._0;
        succ_11412_ &= true;
        ParsedStmt_s **body = &tmp_18471_->payload.variant7._1;
        succ_11412_ &= true;
        if (succ_11412_) {
            {
                String_s tmp_91307 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91308 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("while %\n%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91307, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91308, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18471;
        }
    }
    {
        succ_11419_ &= (tmp_18471_->tag == 8);
        ParsedStmt_s **init = &tmp_18471_->payload.variant8._0;
        succ_11419_ &= true;
        ParsedExpr_s **cond = &tmp_18471_->payload.variant8._1;
        succ_11419_ &= true;
        ParsedExpr_s **step = &tmp_18471_->payload.variant8._2;
        succ_11419_ &= true;
        ParsedStmt_s **body = &tmp_18471_->payload.variant8._3;
        succ_11419_ &= true;
        if (succ_11419_) {
            {
                String_s tmp_91310 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*init), ((usize)(0llu))));
                String_s tmp_91311 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91312 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*step)));
                String_s tmp_91313 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("for (% %; %)\n%"),
                                          ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91310, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91311, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91312, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91313, .info = type_info_table[18]})},
                                                           .length = 4})));
            }
            goto after_18471;
        }
    }
    {
        succ_11422_ &= (tmp_18471_->tag == 9);
        if (succ_11422_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("break;"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18471;
        }
    }
    {
        succ_11425_ &= (tmp_18471_->tag == 10);
        if (succ_11425_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("continue;"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18471;
        }
    }
    {
        succ_11429_ &= (tmp_18471_->tag == 11);
        succ_11429_ &= true;
        if (succ_11429_) {
            {
                String_s tmp_91317 = ((generateMatchStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (stmt), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91317, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11434_ &= (tmp_18471_->tag == 12);
        ParsedExpr_s **expr = &tmp_18471_->payload.variant12._0;
        succ_11434_ &= true;
        ParsedExprList_s *args = &tmp_18471_->payload.variant12._1;
        succ_11434_ &= true;
        if (succ_11434_) {
            {
                String_s s = ((toStringPS8951rS0540)((&((stmt)->span))));
                (((fprintf))((stderr_), ("%s %.*s: Cannot transpile Inline Assembly to C yet.\n"), (ERR_STR), ((s).length), ((s).buffer)));
                (((C_exiti32rN))(((i32)(1))));
            }
            goto after_18471;
        }
    }
    {
        succ_11441_ &= (tmp_18471_->tag == 13);
        ParsedPattern_s **_pat = &tmp_18471_->payload.variant13._0;
        succ_11441_ &= true;
        ParsedExpr_s **_expr = &tmp_18471_->payload.variant13._1;
        succ_11441_ &= true;
        ParsedBlock_s **_block = &tmp_18471_->payload.variant13._2;
        succ_11441_ &= true;
        if (succ_11441_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91319 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91319, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91321 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91321, .info = type_info_table[217]})));
                    usize tmp_91322 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91322, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91324 = (tmp_type);
                    String_s tmp_91325 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91324, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91325, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11450_ = true;

                    tuple_4431 tmp_18422_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18422_._0;
                    succ_11450_ &= true;
                    String_s *success = &tmp_18422_._1;
                    succ_11450_ &= true;
                    (void)succ_11450_;
                    String_s tmp_91327 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91327, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91329 = (ind);
                    String_s tmp_91330 = (*success);
                    String_s tmp_91331 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) %"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91329, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91330, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91331, .info = type_info_table[18]})},
                                                               .length = 3})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91333 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91333, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11457_ &= (tmp_18471_->tag == 14);
        ParsedPattern_s **_pat = &tmp_18471_->payload.variant14._0;
        succ_11457_ &= true;
        ParsedExpr_s **_expr = &tmp_18471_->payload.variant14._1;
        succ_11457_ &= true;
        ParsedBlock_s **_block = &tmp_18471_->payload.variant14._2;
        succ_11457_ &= true;
        ParsedBlock_s **_elze = &tmp_18471_->payload.variant14._3;
        succ_11457_ &= true;
        if (succ_11457_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91335 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91335, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91337 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91337, .info = type_info_table[217]})));
                    usize tmp_91338 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91338, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91340 = (tmp_type);
                    String_s tmp_91341 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91340, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91341, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11466_ = true;

                    tuple_4431 tmp_18438_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18438_._0;
                    succ_11466_ &= true;
                    String_s *success = &tmp_18438_._1;
                    succ_11466_ &= true;
                    (void)succ_11466_;
                    String_s tmp_91343 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91343, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91345 = (ind);
                    String_s tmp_91346 = (*success);
                    String_s tmp_91347 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) % else"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91345, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91346, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91347, .info = type_info_table[18]})},
                                                               .length = 3})));
                    ((popPS3646rN)((&((this)->stack))));
                    CStack_s tmp_91349 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91349, .info = type_info_table[217]})));
                    String_s elze = ((generateBlockPS9442PS7247uszrS0540)((this), (*_elze), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91350 = (ind);
                    String_s tmp_91351 = (elze);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%%"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91350, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91351, .info = type_info_table[18]})},
                                                               .length = 2})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91353 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91353, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        succ_11473_ &= (tmp_18471_->tag == 15);
        ParsedPattern_s **_pat = &tmp_18471_->payload.variant15._0;
        succ_11473_ &= true;
        ParsedExpr_s **_expr = &tmp_18471_->payload.variant15._1;
        succ_11473_ &= true;
        ParsedBlock_s **_block = &tmp_18471_->payload.variant15._2;
        succ_11473_ &= true;
        if (succ_11473_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91355 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%while (true) {\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91355, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91357 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91357, .info = type_info_table[217]})));
                    usize tmp_91358 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91358, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91360 = (tmp_type);
                    String_s tmp_91361 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91360, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91361, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11482_ = true;

                    tuple_4431 tmp_18458_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18458_._0;
                    succ_11482_ &= true;
                    String_s *success = &tmp_18458_._1;
                    succ_11482_ &= true;
                    (void)succ_11482_;
                    String_s tmp_91363 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91363, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91365 = (ind);
                    String_s tmp_91366 = (*success);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (!%) break;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91365, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91366, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91368 = (ind);
                    String_s tmp_91369 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%%\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91368, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91369, .info = type_info_table[18]})},
                                                               .length = 2})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91371 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91371, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    {
        StmtData_u **t = &tmp_18471_;
        if (true) {
            {
                String_s s = ((toStringPS8951rS0540)((&((stmt)->span))));
                (((fprintf))((stderr_), ("%s %.*s: stmt %hhu\n"), (FATAL_STR), ((s).length), ((s).buffer), ((tagAnyru8)((*t)))));
                u8 tmp_91373 = ((tagAnyru8)((*t)));

                return ((format1PcVS4175rS0540)(("\n#error TODO: generateStmt %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91373, .info = type_info_table[0]})}, .length = 1})));
            }
            goto after_18471;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18471:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s _anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540(CGen_s *this, String_s *tmpAlloc, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent) {
    String_s out = ((String_s){0});
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr)));
    String_s tmp_91375 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (_name)));
    String_s tmp_91376 = (e);

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91375, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91376, .info = type_info_table[18]})},
                                               .length = 2})));
    CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
    SubStr_s tmp_91378 = ((tkn).content);
    Var_Context_s tmp_91379 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

    ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91378, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91379, .info = type_info_table[216]})));
    return (out);
}
String_s generateVarDeclPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *_decl, usize indent) {
    bool succ_11488_ = true;

    StmtData_u *tmp_18474_ = (&((_decl)->data));
    succ_11488_ &= (tmp_18474_->tag == 0);
    VarDecl_s *decl = &tmp_18474_->payload.variant0._0;
    succ_11488_ &= true;
    if (!succ_11488_) {
        ((unreachablePcrN)(("generateVarDecl")));
    };
    if (((*decl).isComptime) && (*((flags).warnSimple))) {
        String_s loc = ((toStringPS8951rS0540)((&((_decl)->span))));
        (((fprintf))((stderr_), ("%s: %.*s: Comptime has no effect when transpiling to C.\n"), (WARN_STR), ((loc).length), ((loc).buffer)));
    }

    String_s (*fast_path)(CGen_s *, String_s *, Token_s, Type_u *, ParsedExpr_s *, usize) = (_anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540);
    bool succ_11500_ = true;

    {
        Pattern_u *tmp_18490_ = (&(((*decl).pat)->data));
        succ_11500_ &= (tmp_18490_->tag == 3);
        ParsedPattern_s **subpat = &tmp_18490_->payload.variant3._0;
        succ_11500_ &= true;
        ParsedTypeNode_s **typ = &tmp_18490_->payload.variant3._1;
        succ_11500_ &= true;

        if (succ_11500_) {
            bool succ_11504_ = true;

            {
                Pattern_u *tmp_18489_ = (&((*subpat)->data));
                succ_11504_ &= (tmp_18489_->tag == 2);
                Token_s *tkn = &tmp_18489_->payload.variant2._0;
                succ_11504_ &= true;

                if (succ_11504_) {
                    return ((fast_path)((this), (tmpAlloc), (*tkn), ((getTypePU9661rPU5175)((&((*typ)->typeState)))), ((*decl).expr), (indent)));
                }
            }
        }
    }

    bool succ_11508_ = true;

    {
        Pattern_u *tmp_18492_ = (&(((*decl).pat)->data));
        succ_11508_ &= (tmp_18492_->tag == 2);
        Token_s *tkn = &tmp_18492_->payload.variant2._0;
        succ_11508_ &= true;

        if (succ_11508_) {
            return ((fast_path)((this), (tmpAlloc), (*tkn), ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState)))), ((*decl).expr), (indent)));
        }
    }

    String_s out = ((String_s){0});
    String_s ind = ((generateIndentuszrS0540)((indent)));
    usize id = ((getIDPS1100rusz)((_decl)));
    Type_u *typ = ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState))));
    usize tmp_91380 = (id);

    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91380, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
    String_s tmp_91382 = (tmp_type);
    String_s tmp_91383 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((*decl).expr)));

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91382, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91383, .info = type_info_table[18]})},
                                               .length = 2})));
    bool succ_11519_ = true;

    tuple_4431 tmp_18500_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), ((*decl).pat), (tmp_name), (typ), (indent)));
    String_s *pat = &tmp_18500_._0;
    succ_11519_ &= true;
    String_s *success = &tmp_18500_._1;
    succ_11519_ &= true;
    (void)succ_11519_;
    String_s tmp_91385 = (ind);
    String_s tmp_91386 = (*pat);

    ((formatPS0540PcVS4175rN)((&(out)), ("%%"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91385, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91386, .info = type_info_table[18]})},
                                               .length = 2})));
    if (((*decl).trampoline) != (NULL)) {
        String_s tmp_91388 = (*success);
        String_s tmp_91389 = ((generateBlockPS9442PS7247uszrS0540)((this), ((*decl).trampoline), ((indent) + (INDENTATION_LEVEL))));

        ((formatPS0540PcVS4175rN)((&(out)), ("if (!%) %"),
                                  ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91388, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91389, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    else if (*((flags).debug)) {
        String_s tmp_91391 = (ind);
        String_s tmp_91392 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%if (!%) unreachablePcrN(\"RUNTIME ERROR: pattern of let statement is not exhaustive. this is a bug!\");\n"),
                                  ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91391, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91392, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    else {
        String_s tmp_91394 = (ind);
        String_s tmp_91395 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%(void)%"),
                                  ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91394, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91395, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    return (out);
}
String_s generateMatchStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent) {
    bool succ_11524_ = true;

    StmtData_u *tmp_18512_ = (&((stmt)->data));
    succ_11524_ &= (tmp_18512_->tag == 11);
    ParsedExpr_s **_expr = &tmp_18512_->payload.variant11._0;
    succ_11524_ &= true;
    ParsedPatternList_s *_pats = &tmp_18512_->payload.variant11._1;
    succ_11524_ &= true;
    ParsedStmtList_s *_arms = &tmp_18512_->payload.variant11._2;
    succ_11524_ &= true;
    if (!succ_11524_) {
        ((unreachablePcrN)(("generateMatchStmt")));
    };
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s armInd = ((generateIndentuszrS0540)(((indent) + (INDENTATION_LEVEL))));
    String_s out = ((String_s){0});
    Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
    usize id = ((getIDPS1100rusz)((stmt)));
    usize tmp_91397 = (id);

    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91397, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
    String_s tmp_91399 = (tmp_type);
    String_s tmp_91400 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                              ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91399, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91400, .info = type_info_table[18]})},
                                               .length = 2})));
    for (usize i = ((usize)(0llu)); ((i) < ((*_pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *_pat = ((((*_pats).elements))[(i)]);
        ParsedStmt_s *_arm = ((((*_arms).elements))[(i)]);
        bool succ_11540_ = true;

        tuple_4431 tmp_18524_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (_pat), (tmp_name), (typ), ((indent) + (INDENTATION_LEVEL))));
        String_s *pat = &tmp_18524_._0;
        succ_11540_ &= true;
        String_s *succ = &tmp_18524_._1;
        succ_11540_ &= true;
        (void)succ_11540_;
        String_s arm = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (_arm), ((indent) + (INDENTATION_LEVEL))));
        String_s tmp_91402 = (ind);

        ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91402, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91404 = (*pat);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91404, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91406 = (armInd);
        String_s tmp_91407 = (*succ);
        String_s tmp_91408 = (arm);
        String_s tmp_91409 = (armInd);
        usize tmp_91410 = (id);

        ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) {%%goto after_%;\n}\n"),
                                  ((variadic_4480){.ptr = (Data_s[5]){((Data_s){.ptr = &tmp_91406, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91407, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91408, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91409, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91410, .info = type_info_table[8]})},
                                                   .length = 5})));
        String_s tmp_91412 = (ind);

        ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91412, .info = type_info_table[18]})}, .length = 1})));
    }

    String_s tmp_91414 = (ind);

    ((formatPS0540PcVS4175rN)((&(out)), ("%unreachablePcrN(\"RUNTIME ERROR: match statement is not exhaustive. this is a bug!\");\n"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91414, .info = type_info_table[18]})}, .length = 1})));
    usize tmp_91416 = (id);

    ((formatPS0540PcVS4175rN)((&(out)), ("after_%:\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91416, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91418 = (ind);

    ((formatPS0540PcVS4175rN)((&(out)), ("%(void)0; // error: label at end of compound statement is a C23 extension"),
                              ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91418, .info = type_info_table[18]})}, .length = 1})));
    return (out);
}
tuple_4431 generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s expr, Type_u *type, usize indent) {
    ((assertBPcrN)(((indent) != ((usize)(0llu))), ("generatePattern: wrong indentation")));
    String_s initInd = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));
    String_s ind = ((generateIndentuszrS0540)((indent)));
    bool succ_11545_ = true;
    bool succ_11549_ = true;
    bool succ_11558_ = true;
    bool succ_11562_ = true;
    bool succ_11568_ = true;
    bool succ_11574_ = true;
    bool succ_11581_ = true;
    bool succ_11585_ = true;
    bool succ_11589_ = true;

    Pattern_u *tmp_18594_ = (&((pat)->data));
    {
        succ_11545_ &= (tmp_18594_->tag == 0);
        if (succ_11545_) {
            {
                return ((tuple_4431){((String_s){0}), ((format1PcVS4175rS0540)(("true"), ((variadic_4480){.ptr = NULL, .length = 0})))});
            }
            goto after_18594;
        }
    }
    {
        succ_11549_ &= (tmp_18594_->tag == 2);
        Token_s *tkn = &tmp_18594_->payload.variant2._0;
        succ_11549_ &= true;
        if (succ_11549_) {
            {
                String_s name = ((toStringPS7720rS0540)((&((*tkn).content))));
                ((makeNameCCompatiblePS0540rN)((&(name))));
                CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
                SubStr_s tmp_91421 = ((*tkn).content);
                Var_Context_s tmp_91422 = ((Var_Context_s){.bound_in_reference_pattern = (true)});

                ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91421, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91422, .info = type_info_table[216]})));
                String_s out = ((String_s){0});
                if (true) {
                    ((type) = ((intoPointerPU5175rPU5175)((type))));
                    String_s tmp_91423 = (ind);
                    String_s tmp_91424 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (name)));
                    String_s tmp_91425 = (expr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%% = &%;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91423, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91424, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91425, .info = type_info_table[18]})},
                                                               .length = 3})));
                }

                else {
                    String_s tmp_91427 = (ind);
                    String_s tmp_91428 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (name)));
                    String_s tmp_91429 = (expr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91427, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91428, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91429, .info = type_info_table[18]})},
                                                               .length = 3})));
                }

                return ((tuple_4431){(out), ((format1PcVS4175rS0540)(("true"), ((variadic_4480){.ptr = NULL, .length = 0})))});
            }
            goto after_18594;
        }
    }
    {
        succ_11558_ &= (tmp_18594_->tag == 3);
        ParsedPattern_s **sub = &tmp_18594_->payload.variant3._0;
        succ_11558_ &= true;
        ParsedTypeNode_s **ty = &tmp_18594_->payload.variant3._1;
        succ_11558_ &= true;
        if (succ_11558_) {
            {
                return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (expr), (type), (indent)));
            }
            goto after_18594;
        }
    }
    {
        succ_11562_ &= (tmp_18594_->tag == 4);
        ParsedPattern_s **sub = &tmp_18594_->payload.variant4._0;
        succ_11562_ &= true;
        if (succ_11562_) {
            {
                Type_u *under = ((getUnderlyingTypePU5175BrPU5175)((type), (false)));
                if ((isPointerPU5175rB)((under))) {
                    String_s tmp_91432 = (expr);

                    return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub),
                                                                                           ((format1PcVS4175rS0540)(("*%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){
                                                                                                                                                 .ptr = &tmp_91432, .info = type_info_table[18]})},
                                                                                                                                             .length = 1}))),
                                                                                           (under), (indent)));
                }

                else {
                    return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (expr), (type), (indent)));
                }
            }
            goto after_18594;
        }
    }
    {
        succ_11568_ &= (tmp_18594_->tag == 5);
        Token_s *tkn = &tmp_18594_->payload.variant5._0;
        succ_11568_ &= true;
        ParsedPatternList_s *sub = &tmp_18594_->payload.variant5._1;
        succ_11568_ &= true;
        if (succ_11568_) {
            {
                usize tmp_91434 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91434, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91436 = (initInd);
                String_s tmp_91437 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91436, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91437, .info = type_info_table[18]})},
                                                           .length = 2})));
                return ((generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (pat), (success), (expr), (type), (indent)));
            }
            goto after_18594;
        }
    }
    {
        succ_11574_ &= (tmp_18594_->tag == 6);
        succ_11574_ &= true;
        ParsedPattern_s **sub = &tmp_18594_->payload.variant6._1;
        succ_11574_ &= true;
        if (succ_11574_) {
            {
                usize tmp_91439 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91439, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91441 = (initInd);
                String_s tmp_91442 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91441, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91442, .info = type_info_table[18]})},
                                                           .length = 2})));
                bool ptr = ((isPointerPU5175rB)((type)));
                Type_u *under = (type);
                if (ptr)
                    ((under) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
                if ((isUnionPU5175rB)((under))) {
                    return ((generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (success), (expr), (type), (indent)));
                }

                else if ((isStructPU5175rB)((under))) {
                    return ((generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (success), (expr), (under), (indent)));
                }

                else {
                    ((unreachablePcrN)(("generatePattern")));
                }
            }
            goto after_18594;
        }
    }
    {
        succ_11581_ &= (tmp_18594_->tag == 7);
        ParsedPatternList_s *pats = &tmp_18594_->payload.variant7._0;
        succ_11581_ &= true;
        if (succ_11581_) {
            {
                usize tmp_91444 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91444, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91446 = (initInd);
                String_s tmp_91447 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91446, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91447, .info = type_info_table[18]})},
                                                           .length = 2})));
                return ((generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (pat), (success), (expr), (type), (indent)));
            }
            goto after_18594;
        }
    }
    {
        succ_11585_ &= (tmp_18594_->tag == 8);
        if (succ_11585_) {
            {
                return ((tuple_4431){((String_s){0}), ((format1PcVS4175rS0540)(("true"), ((variadic_4480){.ptr = NULL, .length = 0})))});
            }
            goto after_18594;
        }
    }
    {
        succ_11589_ &= (tmp_18594_->tag == 9);
        bool *b = &tmp_18594_->payload.variant9._0;
        succ_11589_ &= true;
        if (succ_11589_) {
            {
                usize tmp_91450 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91450, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91452 = (initInd);
                String_s tmp_91453 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91452, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91453, .info = type_info_table[18]})},
                                                           .length = 2})));
                String_s tmp_91455 = (ind);
                String_s tmp_91456 = (success);
                String_s tmp_91457 = (expr);
                bool tmp_91458 = (*b);

                return ((tuple_4431){((format1PcVS4175rS0540)(("%% = % == %;\n"), ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91455, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91456, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91457, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91458, .info = type_info_table[10]})},
                                                                                                   .length = 4}))),
                                     (success)});
            }
            goto after_18594;
        }
    }
    {
        Pattern_u **p = &tmp_18594_;
        if (true) {
            {
                u8 tmp_91460 = ((tagAnyru8)((*p)));

                return ((tuple_4431){
                    ((format1PcVS4175rS0540)(("\n#error generatePattern %\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91460, .info = type_info_table[0]})}, .length = 1}))),
                    ((format1PcVS4175rS0540)(("false"), ((variadic_4480){.ptr = NULL, .length = 0})))});
            }
            goto after_18594;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18594:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generatePattern")));
}
tuple_4431 generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent) {
    bool succ_11595_ = true;

    Pattern_u *tmp_18597_ = (&((pat)->data));
    succ_11595_ &= (tmp_18597_->tag == 7);
    ParsedPatternList_s *pats = &tmp_18597_->payload.variant7._0;
    succ_11595_ &= true;
    if (!succ_11595_) {
        ((unreachablePcrN)(("generatePatternTuple")));
    };
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11600_ = true;

    Type_u *tmp_18603_ = (type);
    succ_11600_ &= (tmp_18603_->tag == 10);
    TypeList_s *types = &tmp_18603_->payload.variant10._0;
    succ_11600_ &= true;
    if (!succ_11600_) {
        String_s tmp_91463 = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s tmp_91464 = ((toStringPU5175rS0540)((type)));

        ((fprintPcVS4175rN)(("%: Nope, it\'s actually a %\n"),
                            ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91463, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91464, .info = type_info_table[18]})},
                                             .length = 2})));
        ((unreachablePcrN)(("generatePattern: Tuple")));
    };
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *subPat = ((((*pats).elements))[(i)]);
        Type_u *fieldType = ((((*types).elements))[(i)]);
        String_s subExpr = ((String_s){0});
        if (ptr) {
            String_s tmp_91466 = (expr);
            usize tmp_91467 = (i);

            ((subExpr) =
                 ((format1PcVS4175rS0540)(("%->_%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91466, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91467, .info = type_info_table[8]})},
                                                           .length = 2}))));
        }

        else {
            String_s tmp_91469 = (expr);
            usize tmp_91470 = (i);

            ((subExpr) =
                 ((format1PcVS4175rS0540)(("%._%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91469, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91470, .info = type_info_table[8]})},
                                                           .length = 2}))));
        }

        bool succ_11613_ = true;

        tuple_4431 tmp_18615_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (subExpr), (fieldType), (indent)));
        String_s *_sub = &tmp_18615_._0;
        succ_11613_ &= true;
        String_s *_succ = &tmp_18615_._1;
        succ_11613_ &= true;
        (void)succ_11613_;
        String_s tmp_91472 = (*_sub);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91472, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91474 = (ind);
        String_s tmp_91475 = (successVariable);
        String_s tmp_91476 = (*_succ);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                  ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91474, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91475, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91476, .info = type_info_table[18]})},
                                                   .length = 3})));
        Pattern_u tmp_87853 = (((Pattern_u){.tag = 8, .payload = {0}}));

        if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_87853)))))
            break;
    }

    return ((tuple_4431){(out), (successVariable)});
}
tuple_4431 generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent) {
    Token_s *name = (NULL);
    ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
    bool succ_11620_ = true;
    bool succ_11625_ = true;

    Pattern_u *tmp_18632_ = (&((pat)->data));
    {
        succ_11620_ &= (tmp_18632_->tag == 2);
        Token_s *ident = &tmp_18632_->payload.variant2._0;
        succ_11620_ &= true;
        if (succ_11620_) {
            {
                ((name) = (&(*ident)));
            }
            goto after_18632;
        }
    }
    {
        succ_11625_ &= (tmp_18632_->tag == 5);
        Token_s *ident = &tmp_18632_->payload.variant5._0;
        succ_11625_ &= true;
        ParsedPatternList_s *pats = &tmp_18632_->payload.variant5._1;
        succ_11625_ &= true;
        if (succ_11625_) {
            {
                ((name) = (&(*ident)));
                ((subPatterns) = (*pats));
            }
            goto after_18632;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_18632;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18632:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11632_ = true;

    Type_u *tmp_18637_ = (type);
    succ_11632_ &= (tmp_18637_->tag == 8);
    ParsedUnionDecl_s **decl = &tmp_18637_->payload.variant8._0;
    succ_11632_ &= true;
    succ_11632_ &= true;
    if (!succ_11632_) {
        ((unreachablePcrN)(("generatePatternUnion")));
    };
    ParsedUnionVariant_s *variant = (NULL);
    bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((*decl), (name), (&(variant))));
    ((assertBrN)((found)));
    usize variantTag = ((getVariantTagPS0997PS3506rusz)((*decl), (variant)));
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s out = ((String_s){0});
    if (ptr) {
        String_s tmp_91478 = (ind);
        String_s tmp_91479 = (successVariable);
        String_s tmp_91480 = (expr);
        usize tmp_91481 = (variantTag);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= (%->tag == %);\n"),
                                  ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91478, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91479, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91480, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91481, .info = type_info_table[8]})},
                                                   .length = 4})));
    }

    else {
        String_s tmp_91483 = (ind);
        String_s tmp_91484 = (successVariable);
        String_s tmp_91485 = (expr);
        usize tmp_91486 = (variantTag);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= (%.tag == %);\n"),
                                  ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91483, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91484, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91485, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91486, .info = type_info_table[8]})},
                                                   .length = 4})));
    }

    bool succ_11643_ = true;
    bool succ_11641_ = true;

    {
        tuple_1017 tmp_18666_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
        succ_11641_ = tmp_18666_._0 == true;
        succ_11643_ &= succ_11641_;
        ParsedTypeNodeList_s **fields = &tmp_18666_._1;
        succ_11643_ &= true;

        if (succ_11643_) {
            for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                ParsedPattern_s *subPat = ((((subPatterns).elements))[(i)]);
                ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                String_s subExpr = ((String_s){0});
                if (ptr) {
                    String_s tmp_91488 = (expr);
                    usize tmp_91489 = (variantTag);
                    usize tmp_91490 = (i);

                    ((subExpr) = ((format1PcVS4175rS0540)(("%->payload.variant%._%"), ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91488, .info = type_info_table[18]}),
                                                                                                                          ((Data_s){.ptr = &tmp_91489, .info = type_info_table[8]}),
                                                                                                                          ((Data_s){.ptr = &tmp_91490, .info = type_info_table[8]})},
                                                                                                       .length = 3}))));
                }

                else {
                    String_s tmp_91492 = (expr);
                    usize tmp_91493 = (variantTag);
                    usize tmp_91494 = (i);

                    ((subExpr) = ((format1PcVS4175rS0540)(("%.payload.variant%._%"), ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91492, .info = type_info_table[18]}),
                                                                                                                         ((Data_s){.ptr = &tmp_91493, .info = type_info_table[8]}),
                                                                                                                         ((Data_s){.ptr = &tmp_91494, .info = type_info_table[8]})},
                                                                                                      .length = 3}))));
                }

                bool succ_11653_ = true;

                tuple_4431 tmp_18659_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (subExpr), (fieldType), (indent)));
                String_s *sub = &tmp_18659_._0;
                succ_11653_ &= true;
                String_s *success = &tmp_18659_._1;
                succ_11653_ &= true;
                (void)succ_11653_;
                String_s tmp_91496 = (*sub);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91496, .info = type_info_table[18]})}, .length = 1})));
                String_s tmp_91498 = (ind);
                String_s tmp_91499 = (successVariable);
                String_s tmp_91500 = (*success);

                ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                          ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91498, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91499, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91500, .info = type_info_table[18]})},
                                                           .length = 3})));
                Pattern_u tmp_88010 = (((Pattern_u){.tag = 8, .payload = {0}}));

                if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_88010)))))
                    break;
            }
        }
    }

    return ((tuple_4431){(out), (successVariable)});
}
tuple_4431 generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                   usize indent) {
    bool succ_11657_ = true;

    Pattern_u *tmp_18669_ = (&((pat)->data));
    succ_11657_ &= (tmp_18669_->tag == 5);
    succ_11657_ &= true;
    ParsedPatternList_s *patterns = &tmp_18669_->payload.variant5._1;
    succ_11657_ &= true;
    if (!succ_11657_) {
        ((unreachablePcrN)(("generatePatternStruct")));
    };
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11662_ = true;

    Type_u *tmp_18675_ = (type);
    succ_11662_ &= (tmp_18675_->tag == 7);
    ParsedStructDecl_s **decl = &tmp_18675_->payload.variant7._0;
    succ_11662_ &= true;
    if (!succ_11662_) {
        String_s tmp_91502 = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s tmp_91503 = ((toStringPU5175rS0540)((type)));

        ((fprintPcVS4175rN)(("%: Nope, it\'s actually a %\n"),
                            ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91502, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91503, .info = type_info_table[18]})},
                                             .length = 2})));
        ((unreachablePcrN)(("generatePatternStruct")));
    };
    String_s out = ((String_s){0});
    String_s ind = ((generateIndentuszrS0540)((indent)));
    for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*patterns)), (i))));
        ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
        Token_s fieldName = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (i)));
        Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
        String_s fieldExpr = ((String_s){0});
        if (ptr) {
            String_s tmp_91505 = (expr);
            SubStr_s tmp_91506 = ((fieldName).content);

            ((fieldExpr) =
                 ((format1PcVS4175rS0540)(("%->%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91505, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91506, .info = type_info_table[16]})},
                                                           .length = 2}))));
        }

        else {
            String_s tmp_91508 = (expr);
            SubStr_s tmp_91509 = ((fieldName).content);

            ((fieldExpr) =
                 ((format1PcVS4175rS0540)(("%.%"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91508, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91509, .info = type_info_table[16]})},
                                                           .length = 2}))));
        }

        bool succ_11677_ = true;

        tuple_4431 tmp_18689_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (fieldExpr), (fieldType), (indent)));
        String_s *sub = &tmp_18689_._0;
        succ_11677_ &= true;
        String_s *success = &tmp_18689_._1;
        succ_11677_ &= true;
        (void)succ_11677_;
        String_s tmp_91511 = (*sub);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91511, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91513 = (ind);
        String_s tmp_91514 = (successVariable);
        String_s tmp_91515 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                  ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91513, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91514, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91515, .info = type_info_table[18]})},
                                                   .length = 3})));
        Pattern_u tmp_88145 = (((Pattern_u){.tag = 8, .payload = {0}}));

        if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_88145)))))
            break;
    }

    return ((tuple_4431){(out), (successVariable)});
}
String_s generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    String_s tmp_91517 = ((_generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr)));

    return ((format1PcVS4175rS0540)(("(%)"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91517, .info = type_info_table[18]})}, .length = 1})));
}
String_s _generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    String_s out = ((String_s){0});
    bool succ_11682_ = true;
    bool succ_11700_ = true;
    bool succ_11704_ = true;
    bool succ_11708_ = true;
    bool succ_11721_ = true;
    bool succ_11730_ = true;
    bool succ_11734_ = true;
    bool succ_11738_ = true;
    bool succ_11744_ = true;
    bool succ_11748_ = true;
    bool succ_11758_ = true;
    bool succ_11763_ = true;
    bool succ_11767_ = true;
    bool succ_11770_ = true;
    bool succ_11773_ = true;
    bool succ_11776_ = true;
    bool succ_11780_ = true;
    bool succ_11786_ = true;
    bool succ_11790_ = true;
    bool succ_11800_ = true;
    bool succ_11811_ = true;

    ExprData_u *tmp_18870_ = (&((expr)->data));
    {
        succ_11682_ &= (tmp_18870_->tag == 0);
        Token_s *lit = &tmp_18870_->payload.variant0._0;
        succ_11682_ &= true;
        if (succ_11682_) {
            {
                String_s _lit = ((String_s){0});
                SubStr_s tmp_91519 = ((*lit).content);

                ((formatPS0540PcVS4175rN)((&(_lit)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91519, .info = type_info_table[16]})}, .length = 1})));
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                bool succ_11689_ = true;

                Type_u *tmp_18703_ = (t);
                succ_11689_ &= (tmp_18703_->tag == 3);
                PrimType_u *pt = &tmp_18703_->payload.variant3._0;
                succ_11689_ &= true;
                if (!succ_11689_) {
                    ((unreachablePcrN)(("Integer Literal doesn\'t have primitive type")));
                };
                bool succ_11692_ = true;
                bool succ_11694_ = true;
                bool succ_11696_ = true;

                PrimType_u tmp_18711_ = (*pt);
                {
                    succ_11692_ &= (tmp_18711_.tag == 8);
                    if (succ_11692_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("llu"), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                        goto after_18711;
                    }
                }
                {
                    succ_11694_ &= (tmp_18711_.tag == 3);
                    if (succ_11694_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("llu"), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                        goto after_18711;
                    }
                }
                {
                    succ_11696_ &= (tmp_18711_.tag == 7);
                    if (succ_11696_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("ll"), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                        goto after_18711;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_18711;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_18711:
                (void)0; // error: label at end of compound statement is a C23 extension
                String_s tmp_91524 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));
                String_s tmp_91525 = (_lit);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%)(%)"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91524, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91525, .info = type_info_table[18]})},
                                                           .length = 2})));
                ((dropPS0540rN)((&(_lit))));
            }
            goto after_18870;
        }
    }
    {
        succ_11700_ &= (tmp_18870_->tag == 1);
        Token_s *lit = &tmp_18870_->payload.variant1._0;
        succ_11700_ &= true;
        if (succ_11700_) {
            {
                String_s tmp_91527 = ((unescapeS7720rS0540)(((*lit).content)));

                ((formatPS0540PcVS4175rN)((&(out)), ("\"%\""), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91527, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11704_ &= (tmp_18870_->tag == 2);
        Token_s *lit = &tmp_18870_->payload.variant2._0;
        succ_11704_ &= true;
        if (succ_11704_) {
            {
                String_s tmp_91529 = ((unescapeS7720rS0540)(((*lit).content)));

                ((formatPS0540PcVS4175rN)((&(out)), ("\'%\'"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91529, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11708_ &= (tmp_18870_->tag == 3);
        ArrayContext_s *ctx = &tmp_18870_->payload.variant3._0;
        succ_11708_ &= true;
        if (succ_11708_) {
            {
                String_s tmp_91531 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%){"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91531, .info = type_info_table[18]})}, .length = 1})));
                if (((*ctx).size) == ((usize)(0llu))) {
                    for (usize i = ((usize)(0llu)); ((i) < ((*ctx).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        usize idx = ((getElementAtIndexPS8905uszrusz)((&(*ctx)), (i)));
                        ParsedExpr_s *el = ((atPS7882uszrPS2435)((&(exprs)), (idx)));
                        String_s tmp_91533 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (el)));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91533, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*ctx).elemLength) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }

                }

                else {
                    usize idx = ((getElementAtIndexPS8905uszrusz)((&(*ctx)), ((usize)(0llu))));
                    ParsedExpr_s *el = ((atPS7882uszrPS2435)((&(exprs)), (idx)));
                    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (el)));
                    for (usize i = ((usize)(0llu)); ((i) < ((*ctx).size)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_91536 = (e);

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91536, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*ctx).size) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), ("}"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11721_ &= (tmp_18870_->tag == 4);
        IdentExpr_s *ident = &tmp_18870_->payload.variant4._0;
        succ_11721_ &= true;
        if (succ_11721_) {
            {
                String_s name = ((String_s){0});
                bool succ_11727_ = true;
                bool succ_11726_ = true;

                {
                    tuple_4302 tmp_18755_ = ((getVariableInfoPS9442S7720rT_S0610B)((this), (((*ident).name).content)));
                    Var_Context_s *ctx = &tmp_18755_._0;
                    succ_11727_ &= true;
                    succ_11726_ = tmp_18755_._1 == true;
                    succ_11727_ &= succ_11726_;

                    if (succ_11727_) {
                        ((name) = ((toStringPS7720rS0540)((&(((*ident).name).content)))));
                        if ((*ctx).bound_in_reference_pattern) {
                            String_s tmp_91540 = (name);

                            ((name) = ((format1PcVS4175rS0540)(("*%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91540, .info = type_info_table[18]})}, .length = 1}))));
                        }

                    } else {
                        if ((isFunctionPU5175rB)(((*ident).type))) {
                            ((name) = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((*ident).origID))))));
                        }

                        else {
                            SubStr_s tmp_91542 = (((*ident).name).content);

                            ((fprintPcVS4175rN)(("%\n"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91542, .info = type_info_table[16]})}, .length = 1})));
                            return ((newStringFromStrLitPcrS0540)(("/*TODO: dont know this ident */")));
                        }
                    }
                }

                ((makeNameCCompatiblePS0540rN)((&(name))));
                String_s tmp_91544 = (name);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91544, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11730_ &= (tmp_18870_->tag == 5);
        UnaryExpr_u *unary = &tmp_18870_->payload.variant5._0;
        succ_11730_ &= true;
        if (succ_11730_) {
            {
                ((out) = ((generateUnaryExprPS9442PS0540PU5427rS0540)((this), (tmpAlloc), (&(*unary)))));
            }
            goto after_18870;
        }
    }
    {
        succ_11734_ &= (tmp_18870_->tag == 6);
        BinaryExpr_u *bin = &tmp_18870_->payload.variant6._0;
        succ_11734_ &= true;
        if (succ_11734_) {
            {
                ((out) = ((generateBinaryExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr))));
            }
            goto after_18870;
        }
    }
    {
        succ_11738_ &= (tmp_18870_->tag == 7);
        CallExpr_s *call = &tmp_18870_->payload.variant7._0;
        succ_11738_ &= true;
        if (succ_11738_) {
            {
                String_s tmp_91546 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((*call).base)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%("), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91546, .info = type_info_table[18]})}, .length = 1})));
                for (usize i = ((usize)(0llu)); ((i) < (((*call).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s tmp_91548 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (((((*call).args).elements))[(i)])));

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91548, .info = type_info_table[18]})}, .length = 1})));
                    if ((i) != ((((*call).args).length) - ((usize)(1llu)))) {
                        ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (")"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11744_ &= (tmp_18870_->tag == 8);
        ParsedTypeNode_s **what = &tmp_18870_->payload.variant8._0;
        succ_11744_ &= true;
        if (succ_11744_) {
            {
                String_s tmp_91552 = ((generateTypeNamePS9442PS1372rS0540)((this), (*what)));

                ((formatPS0540PcVS4175rN)((&(out)), ("sizeof(%)"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91552, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11748_ &= (tmp_18870_->tag == 9);
        StructExpr_s *str = &tmp_18870_->payload.variant9._0;
        succ_11748_ &= true;
        if (succ_11748_) {
            {
                String_s tmp_91554 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91554, .info = type_info_table[18]})}, .length = 1})));
                if ((((*str).context).fieldLength) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("0"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }

                else {
                    for (usize i = ((usize)(0llu)); ((i) < (((*str).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        Token_s nameTkn = ((getFieldNameAtIndexPS6291uszrS6070)((&((*str).context)), (i)));
                        ParsedExpr_s *fieldNode = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*str).context)), (i)));
                        String_s _name = ((toStringPS7720rS0540)((&((nameTkn).content))));
                        ((makeNameCCompatiblePS0540rN)((&(_name))));
                        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
                        SubStr_s tmp_91557 = (name);
                        String_s tmp_91558 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (fieldNode)));

                        ((formatPS0540PcVS4175rN)((&(out)), (".% = %"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91557, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91558, .info = type_info_table[18]})},
                                                      .length = 2})));
                        if ((i) != ((((*str).context).fieldLength) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11758_ &= (tmp_18870_->tag == 10);
        UnionExpr_u *uni = &tmp_18870_->payload.variant10._0;
        succ_11758_ &= true;
        if (succ_11758_) {
            {
                ((out) = ((generateUnionInitPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr))));
            }
            goto after_18870;
        }
    }
    {
        succ_11763_ &= (tmp_18870_->tag == 11);
        ParsedExpr_s **subexpr = &tmp_18870_->payload.variant11._0;
        succ_11763_ &= true;
        ParsedTypeNode_s **type = &tmp_18870_->payload.variant11._1;
        succ_11763_ &= true;
        if (succ_11763_) {
            {
                Type_u *exprType = ((getTypePU9661rPU5175)((&((*subexpr)->typeState))));
                if ((isFunctionPU5175rB)((exprType))) {
                    String_s tmp_91562 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91563 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)(usize)(%)"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91562, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91563, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else if ((isDataPU5175rB)((exprType))) {
                    String_s tmp_91565 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91566 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("*(%*)(%.ptr)"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91565, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91566, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_91568 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91569 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)(%)"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91568, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91569, .info = type_info_table[18]})},
                                                               .length = 2})));
                }
            }
            goto after_18870;
        }
    }
    {
        succ_11767_ &= (tmp_18870_->tag == 12);
        if (succ_11767_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("NULL"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11770_ &= (tmp_18870_->tag == 13);
        if (succ_11770_) {
            {
                String_s tmp_91572 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) {0}"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91572, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11773_ &= (tmp_18870_->tag == 14);
        if (succ_11773_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("true"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11776_ &= (tmp_18870_->tag == 15);
        if (succ_11776_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("false"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        succ_11780_ &= (tmp_18870_->tag == 16);
        ParsedFuncDecl_s **function = &tmp_18870_->payload.variant16._0;
        succ_11780_ &= true;
        if (succ_11780_) {
            {
                String_s name = ((getMangledNamePS4904rS0540)((*function)));
                ((makeNameCCompatiblePS0540rN)((&(name))));
                String_s tmp_91576 = (name);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91576, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11786_ &= (tmp_18870_->tag == 17);
        ParsedTypeNode_s **typ = &tmp_18870_->payload.variant17._0;
        succ_11786_ &= true;
        if (succ_11786_) {
            {
                String_s tmp_91578 = ((generateTypeInfoPS9442S8951PU5175rS0540)((this), ((expr)->span), ((getTypePU9661rPU5175)((&((*typ)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91578, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11790_ &= (tmp_18870_->tag == 18);
        ParsedExpr_s **subexpr = &tmp_18870_->payload.variant18._0;
        succ_11790_ &= true;
        if (succ_11790_) {
            {
                Type_u *exprType = ((getTypePU9661rPU5175)((&((*subexpr)->typeState))));
                String_s e = ((String_s){0});
                if ((isPointerPU5175rB)((exprType))) {
                    ((e) = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr))));
                }

                else {
                    String_s sub = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));
                    usize tmp_91580 = ((getIDPS2435rusz)((expr)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91580, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_91582 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (exprType), (tmp_name)));
                    String_s tmp_91583 = (sub);

                    ((formatPS0540PcVS4175rN)((tmpAlloc), ("% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91582, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91583, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91585 = (tmp_name);

                    ((e) = ((format1PcVS4175rS0540)(("&%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91585, .info = type_info_table[18]})}, .length = 1}))));
                }

                String_s ti = ((generateTypeInfoPS9442S8951PU5175rS0540)((this), ((expr)->span), (exprType)));
                String_s tmp_91587 = (e);
                String_s tmp_91588 = (ti);

                ((formatPS0540PcVS4175rN)((&(out)), ("(Data_s) { .ptr = %, .info = % }"),
                                          ((variadic_4480){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91587, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91588, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18870;
        }
    }
    {
        succ_11800_ &= (tmp_18870_->tag == 19);
        ParsedExprList_s *exprs = &tmp_18870_->payload.variant19._0;
        succ_11800_ &= true;
        if (succ_11800_) {
            {
                Type_u *_v = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                String_s vt = ((generateTypeNamePS9442PU5175rS0540)((this), (_v)));
                String_s et = ((generateTypeNamePS9442PU5175rS0540)((this), ((getUnderlyingTypePU5175BrPU5175)((_v), (false)))));
                String_s tmp_91590 = (vt);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { .ptr = "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91590, .info = type_info_table[18]})}, .length = 1})));
                if (((*exprs).length) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("NULL"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }

                else {
                    String_s tmp = ((String_s){0});
                    String_s tmp_91593 = (et);
                    usize tmp_91594 = ((*exprs).length);

                    ((formatPS0540PcVS4175rN)((&(tmp)), ("(%[%]){ "),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91593, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91594, .info = type_info_table[8]})},
                                                               .length = 2})));
                    for (usize i = ((usize)(0llu)); ((i) < ((*exprs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_91596 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((((*exprs).elements))[(i)])));

                        ((formatPS0540PcVS4175rN)((&(tmp)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91596, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*exprs).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(tmp)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }

                    ((formatPS0540PcVS4175rN)((&(tmp)), (" }"), ((variadic_4480){.ptr = NULL, .length = 0})));
                    String_s tmp_91600 = (tmp);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91600, .info = type_info_table[18]})}, .length = 1})));
                }

                usize tmp_91602 = ((*exprs).length);

                ((formatPS0540PcVS4175rN)((&(out)), (" , .length = % }"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91602, .info = type_info_table[8]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    {
        succ_11811_ &= (tmp_18870_->tag == 20);
        ParsedExprList_s *exprs = &tmp_18870_->payload.variant20._0;
        succ_11811_ &= true;
        if (succ_11811_) {
            {
                Type_u *_t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                String_s tt = ((generateTypeNamePS9442PU5175rS0540)((this), (_t)));
                String_s tmp_91604 = (tt);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91604, .info = type_info_table[18]})}, .length = 1})));
                for (usize i = ((usize)(0llu)); ((i) < ((*exprs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s tmp_91606 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((((*exprs).elements))[(i)])));

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91606, .info = type_info_table[18]})}, .length = 1})));
                    if ((i) != (((*exprs).length) - ((usize)(1llu)))) {
                        ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4480){.ptr = NULL, .length = 0})));
            }
            goto after_18870;
        }
    }
    {
        ExprData_u **t = &tmp_18870_;
        if (true) {
            {
                String_s s = ((toStringPS8951rS0540)((&((expr)->span))));
                (((fprintf))((stderr_), ("%s %.*s: expr %hhu\n"), (FATAL_STR), ((s).length), ((s).buffer), ((tagAnyru8)((*t)))));
                u8 tmp_91610 = ((tagAnyru8)((*t)));

                return ((format1PcVS4175rS0540)(("/*TODO: generateExpr %*/"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91610, .info = type_info_table[0]})}, .length = 1})));
            }
            goto after_18870;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18870:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateTypeInfoPS9442S8951PU5175rS0540(CGen_s *this, Span_s span, Type_u *type) {
    usize index = ((index_of_typePS3131PU5175rusz)((&((this)->type_info_table)), (type)));
    if ((index) >= (((this)->type_info_table).length)) {
        String_s l = ((toStringPS8951rS0540)((&(span))));
        String_s t = ((toStringPU5175rS0540)((type)));
        (((fprintf))((stderr_), ("%s: %s: WEEWOO!!! Type Info for Type %s doesn\'t exist!!!\n"), ((l).buffer), (FATAL_STR), ((t).buffer)));
        (((C_exiti32rN))(((i32)(2))));
    }

    usize tmp_91612 = (index);

    return ((format1PcVS4175rS0540)(("type_info_table[%]"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91612, .info = type_info_table[8]})}, .length = 1})));
}
String_s generateUnionInitPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *init) {
    Type_u *type = ((getTypePU9661rPU5175)((&((init)->typeState))));
    bool succ_11828_ = true;

    Type_u *tmp_18882_ = (type);
    succ_11828_ &= (tmp_18882_->tag == 8);
    ParsedUnionDecl_s **decl = &tmp_18882_->payload.variant8._0;
    succ_11828_ &= true;
    usize *_variant = &tmp_18882_->payload.variant8._1;
    succ_11828_ &= true;
    if (!succ_11828_) {
        ((unreachablePcrN)(("generateUnionInit")));
    };
    bool succ_11832_ = true;

    ExprData_u *tmp_18884_ = (&((init)->data));
    succ_11832_ &= (tmp_18884_->tag == 10);
    UnionExpr_u *uni = &tmp_18884_->payload.variant10._0;
    succ_11832_ &= true;
    if (!succ_11832_) {
        ((unreachablePcrN)(("generateUnionInit")));
    };
    String_s out = ((String_s){0});
    String_s tmp_91614 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

    ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91614, .info = type_info_table[18]})}, .length = 1})));
    usize tmp_91616 = (*_variant);

    ((formatPS0540PcVS4175rN)((&(out)), (".tag = %"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91616, .info = type_info_table[8]})}, .length = 1})));
    bool has_non_empty = (false);
    for (usize i = ((usize)(0llu)); ((i) < (((*decl)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *_v = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (i))));
        bool succ_11841_ = true;

        {
            ParsedUnionVariantData_u *tmp_18893_ = (&((_v)->data));
            succ_11841_ &= (tmp_18893_->tag == 0);

            if (succ_11841_) {
            } else {
                ((has_non_empty) = (true));
                break;
            }
        }
    }

    if (has_non_empty) {
        ((formatPS0540PcVS4175rN)((&(out)), (", .payload = "), ((variadic_4480){.ptr = NULL, .length = 0})));
        bool succ_11845_ = true;
        bool succ_11853_ = true;
        bool succ_11862_ = true;

        UnionExpr_u *tmp_18931_ = (&(*uni));
        {
            succ_11845_ &= (tmp_18931_->tag == 0);
            CallExpr_s *texpr = &tmp_18931_->payload.variant0._0;
            succ_11845_ &= true;
            if (succ_11845_) {
                {
                    usize tmp_91619 = (*_variant);

                    ((formatPS0540PcVS4175rN)((&(out)), ("{ .variant% = { "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91619, .info = type_info_table[8]})}, .length = 1})));
                    for (usize i = ((usize)(0llu)); ((i) < (((*texpr).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedExpr_s *v = (((((*texpr).args).elements))[(i)]);
                        String_s te = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (v)));
                        usize tmp_91621 = (i);
                        String_s tmp_91622 = (te);

                        ((formatPS0540PcVS4175rN)((&(out)), ("._% = %"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91621, .info = type_info_table[8]}), ((Data_s){.ptr = &tmp_91622, .info = type_info_table[18]})},
                                                      .length = 2})));
                        if ((i) != ((((*texpr).args).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                        }
                    }

                    ((formatPS0540PcVS4175rN)((&(out)), (" } }"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }
                goto after_18931;
            }
        }
        {
            succ_11853_ &= (tmp_18931_->tag == 1);
            StructExpr_s *sexpr = &tmp_18931_->payload.variant1._0;
            succ_11853_ &= true;
            if (succ_11853_) {
                {
                    usize tmp_91626 = (*_variant);

                    ((formatPS0540PcVS4175rN)((&(out)), ("{ .variant% = { "), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91626, .info = type_info_table[8]})}, .length = 1})));
                    if ((((*sexpr).context).fieldLength) > ((usize)(0llu))) {
                        for (usize i = ((usize)(0llu)); ((i) < (((*sexpr).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                            Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*sexpr).context)), (i)));
                            ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*sexpr).context)), (i)));
                            String_s te = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (field)));
                            usize index = ((getFieldIndexPS3506PS7720rusz)((*((atPS0030uszrPPS3506)((&((*decl)->variants)), (*_variant)))), (&((name).content))));
                            usize tmp_91628 = (index);
                            String_s tmp_91629 = (te);

                            ((formatPS0540PcVS4175rN)((&(out)), ("._% = %"),
                                                      ((variadic_4480){
                                                          .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91628, .info = type_info_table[8]}), ((Data_s){.ptr = &tmp_91629, .info = type_info_table[18]})},
                                                          .length = 2})));
                            if ((i) != ((((*sexpr).context).fieldLength) - ((usize)(1llu)))) {
                                ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4480){.ptr = NULL, .length = 0})));
                            }
                        }

                    }

                    else {
                        ((formatPS0540PcVS4175rN)((&(out)), ("0"), ((variadic_4480){.ptr = NULL, .length = 0})));
                    }

                    ((formatPS0540PcVS4175rN)((&(out)), (" } }"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }
                goto after_18931;
            }
        }
        {
            succ_11862_ &= (tmp_18931_->tag == 2);
            if (succ_11862_) {
                {
                    ((formatPS0540PcVS4175rN)((&(out)), ("{0}"), ((variadic_4480){.ptr = NULL, .length = 0})));
                }
                goto after_18931;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_18931;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_18931:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4480){.ptr = NULL, .length = 0})));
    return (out);
}
bool isCLValuePS2435rB(ParsedExpr_s *this) {
    bool succ_11869_ = true;
    bool succ_11867_ = true;
    bool succ_11875_ = true;
    bool succ_11873_ = true;
    bool succ_11886_ = true;
    bool succ_11884_ = true;
    bool succ_11881_ = true;
    bool succ_11893_ = true;

    ExprData_u tmp_18950_ = ((this)->data);
    {
        succ_11869_ &= (tmp_18950_.tag == 5);
        succ_11867_ &= (tmp_18950_.payload.variant5._0.tag == 2);
        succ_11867_ &= true;
        succ_11869_ &= succ_11867_;
        if (succ_11869_) {
            {
                return (true);
            }
            goto after_18950;
        }
    }
    {
        succ_11875_ &= (tmp_18950_.tag == 6);
        succ_11873_ &= (tmp_18950_.payload.variant6._0.tag == 19);
        ParsedExpr_s **lhs = &tmp_18950_.payload.variant6._0.payload.variant19._0;
        succ_11873_ &= true;
        ParsedExpr_s **rhs = &tmp_18950_.payload.variant6._0.payload.variant19._1;
        succ_11873_ &= true;
        succ_11875_ &= succ_11873_;
        if (succ_11875_) {
            {
                return (true);
            }
            goto after_18950;
        }
    }
    {
        succ_11886_ &= (tmp_18950_.tag == 6);
        succ_11884_ &= (tmp_18950_.payload.variant6._0.tag == 1);
        ParsedExpr_s **lhs = &tmp_18950_.payload.variant6._0.payload.variant1._0;
        succ_11884_ &= true;
        succ_11881_ &= true;
        succ_11881_ &= true;
        ExprData_u *rhs = &tmp_18950_.payload.variant6._0.payload.variant1._1->data;
        succ_11881_ &= true;
        succ_11881_ &= true;
        succ_11884_ &= succ_11881_;
        succ_11886_ &= succ_11884_;
        if (succ_11886_) {
            {
                if (!((isCLValuePS2435rB)((*lhs))))
                    return (false);
                bool succ_11889_ = true;

                ExprData_u tmp_18945_ = (*rhs);
                {
                    succ_11889_ &= (tmp_18945_.tag == 4);
                    succ_11889_ &= true;
                    if (succ_11889_) {
                        {
                            return (true);
                        }
                        goto after_18945;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_18945;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_18945:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_18950;
        }
    }
    {
        succ_11893_ &= (tmp_18950_.tag == 4);
        succ_11893_ &= true;
        if (succ_11893_) {
            {
                return (true);
            }
            goto after_18950;
        }
    }
    {
        if (true) {
            {
            }
            goto after_18950;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18950:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
String_s generateUnaryExprPS9442PS0540PU5427rS0540(CGen_s *this, String_s *tmpAlloc, UnaryExpr_u *unary) {
    String_s out = ((String_s){0});
    bool succ_11899_ = true;
    bool succ_11906_ = true;
    bool succ_11910_ = true;
    bool succ_11914_ = true;
    bool succ_11918_ = true;

    UnaryExpr_u *tmp_18977_ = (unary);
    {
        succ_11899_ &= (tmp_18977_->tag == 1);
        ParsedExpr_s **expr = &tmp_18977_->payload.variant1._0;
        succ_11899_ &= true;
        if (succ_11899_) {
            {
                if ((isCLValuePS2435rB)((*expr))) {
                    String_s tmp_91636 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("&%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91636, .info = type_info_table[18]})}, .length = 1})));
                }

                else {
                    usize tmp_91638 = ((getIDPS2435rusz)((*expr)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91638, .info = type_info_table[8]})}, .length = 1})));
                    String_s t = ((generateTypeNamePS9442PU5175S0540rS0540)((this), ((getTypePU9661rPU5175)((&((*expr)->typeState)))), (tmp_name)));
                    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));
                    String_s tmp_91640 = (t);
                    String_s tmp_91641 = (e);

                    ((formatPS0540PcVS4175rN)((tmpAlloc), ("% = %;\n"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91640, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91641, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91643 = (tmp_name);

                    ((formatPS0540PcVS4175rN)((&(out)), ("&%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91643, .info = type_info_table[18]})}, .length = 1})));
                }
            }
            goto after_18977;
        }
    }
    {
        succ_11906_ &= (tmp_18977_->tag == 2);
        ParsedExpr_s **expr = &tmp_18977_->payload.variant2._0;
        succ_11906_ &= true;
        if (succ_11906_) {
            {
                String_s tmp_91645 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("*%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91645, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18977;
        }
    }
    {
        succ_11910_ &= (tmp_18977_->tag == 3);
        ParsedExpr_s **expr = &tmp_18977_->payload.variant3._0;
        succ_11910_ &= true;
        if (succ_11910_) {
            {
                String_s tmp_91647 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("-%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91647, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18977;
        }
    }
    {
        succ_11914_ &= (tmp_18977_->tag == 4);
        ParsedExpr_s **expr = &tmp_18977_->payload.variant4._0;
        succ_11914_ &= true;
        if (succ_11914_) {
            {
                String_s tmp_91649 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("!%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91649, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18977;
        }
    }
    {
        succ_11918_ &= (tmp_18977_->tag == 0);
        ParsedExpr_s **expr = &tmp_18977_->payload.variant0._0;
        succ_11918_ &= true;
        if (succ_11918_) {
            {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    (((fprintf))((stderr_), ("%s: %.*s: Comptime has no effect when transpiling to C.\n"), (WARN_STR), ((loc).length), ((loc).buffer)));
                }

                String_s tmp_91651 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91651, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18977;
        }
    }
    {
        UnaryExpr_u **t = &tmp_18977_;
        if (true) {
            {
                ((unreachablePcrN)(("generateUnaryExpr")));
            }
            goto after_18977;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18977:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateBinaryExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    bool succ_11924_ = true;

    ExprData_u *tmp_18980_ = (&((expr)->data));
    succ_11924_ &= (tmp_18980_->tag == 6);
    BinaryExpr_u *bin = &tmp_18980_->payload.variant6._0;
    succ_11924_ &= true;
    if (!succ_11924_) {
        ((unreachablePcrN)(("generateBinaryExpr")));
    };
    String_s out = ((String_s){0});
    bool succ_11931_ = true;
    bool succ_11936_ = true;
    bool succ_11952_ = true;
    bool succ_11960_ = true;

    BinaryExpr_u *tmp_19063_ = (&(*bin));
    {
        succ_11931_ &= (tmp_19063_->tag == 0);
        succ_11931_ &= true;
        ParsedExpr_s **rhs = &tmp_19063_->payload.variant0._1;
        succ_11931_ &= true;
        if (succ_11931_) {
            {
                ((out) = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs))));
            }
            goto after_19063;
        }
    }
    {
        succ_11936_ &= (tmp_19063_->tag == 1);
        ParsedExpr_s **lhs = &tmp_19063_->payload.variant1._0;
        succ_11936_ &= true;
        ParsedExpr_s **rhs = &tmp_19063_->payload.variant1._1;
        succ_11936_ &= true;
        if (succ_11936_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s tmp_91653 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91653, .info = type_info_table[18]})}, .length = 1})));
                if ((isArrayPU5175rB)((lhsType))) {
                    bool succ_11942_ = true;

                    Type_u *tmp_18987_ = (lhsType);
                    succ_11942_ &= (tmp_18987_->tag == 5);
                    succ_11942_ &= true;
                    usize *size = &tmp_18987_->payload.variant5._1;
                    succ_11942_ &= true;
                    if (!succ_11942_) {
                        ((unreachablerN)());
                    };
                    (((out).length) = ((usize)(0llu)));
                    ((pushNumberPS0540uszrN)((&(out)), (*size)));
                }

                else if ((isVariadicTypePU5175rB)((lhsType))) {
                    ((pushStrPS0540PcrN)((&(out)), (".length")));
                }

                else if (((isStructPU5175rB)((lhsType))) || ((isStructPointerPU5175rB)((lhsType)))) {
                    if ((isStructPointerPU5175rB)((lhsType))) {
                        ((pushStrPS0540PcrN)((&(out)), ("->")));
                    }

                    else {
                        ((pushStrPS0540PcrN)((&(out)), (".")));
                    }

                    bool succ_11946_ = true;

                    ExprData_u *tmp_18999_ = (&((*rhs)->data));
                    succ_11946_ &= (tmp_18999_->tag == 4);
                    IdentExpr_s *ident = &tmp_18999_->payload.variant4._0;
                    succ_11946_ &= true;
                    if (!succ_11946_) {
                        ((unreachablePcrN)(("Struct Dot doesn\'t have ident RHS")));
                    };
                    String_s _field = ((toStringPS7720rS0540)((&(((*ident).name).content))));
                    ((makeNameCCompatiblePS0540rN)((&(_field))));
                    String_s tmp_91655 = (_field);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4480){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91655, .info = type_info_table[18]})}, .length = 1})));
                }

                else if (((isTuplePU5175rB)((lhsType))) || ((isTuplePointerPU5175rB)((lhsType)))) {
                    return ((newStringFromStrLitPcrS0540)(("/*TODO: dot tuple */")));
                }

                else {
                    ((unreachablePcrN)(("generateBinaryExpr: Dot")));
                }
            }
            goto after_19063;
        }
    }
    {
        succ_11952_ &= (tmp_19063_->tag == 19);
        ParsedExpr_s **lhs = &tmp_19063_->payload.variant19._0;
        succ_11952_ &= true;
        ParsedExpr_s **rhs = &tmp_19063_->payload.variant19._1;
        succ_11952_ &= true;
        if (succ_11952_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs)));
                if ((isArrayPU5175rB)((lhsType))) {
                    String_s tmp_91657 = (lhsExpr);
                    String_s tmp_91658 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%.arr)[%]"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91657, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91658, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else if ((isVariadicTypePU5175rB)((lhsType))) {
                    String_s tmp_91660 = (lhsExpr);
                    String_s tmp_91661 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%.ptr)[%]"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91660, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91661, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_91663 = (lhsExpr);
                    String_s tmp_91664 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)[%]"),
                                              ((variadic_4480){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91663, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91664, .info = type_info_table[18]})},
                                                               .length = 2})));
                }
            }
            goto after_19063;
        }
    }
    {
        succ_11960_ &= (tmp_19063_->tag == 7);
        ParsedExpr_s **lhs = &tmp_19063_->payload.variant7._0;
        succ_11960_ &= true;
        ParsedExpr_s **rhs = &tmp_19063_->payload.variant7._1;
        succ_11960_ &= true;
        if (succ_11960_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs)));
                if ((isFloatPU5175rB)((lhsType))) {
                    if (((getSizeInBytesPU5175rusz)((lhsType))) == ((usize)(4llu))) {
                        String_s tmp_91666 = (lhsExpr);
                        String_s tmp_91667 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("fmodf(%, %)"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91666, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91667, .info = type_info_table[18]})},
                                                      .length = 2})));
                    }

                    else {
                        String_s tmp_91669 = (lhsExpr);
                        String_s tmp_91670 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("fmod(%, %)"),
                                                  ((variadic_4480){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91669, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91670, .info = type_info_table[18]})},
                                                      .length = 2})));
                    }

                }

                else {
                    String_s tmp_91672 = (lhsExpr);
                    String_s tmp_91674 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                              ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91672, .info = type_info_table[18]}),
                                                                                  ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                  ((Data_s){.ptr = &tmp_91674, .info = type_info_table[18]})},
                                                               .length = 3})));
                }
            }
            goto after_19063;
        }
    }
    {
        if (true) {
            {
                ParsedExpr_s *lhs = (NULL);
                ParsedExpr_s *rhs = (NULL);
                ((extractOperandsPU0121PPS2435PPS2435rN)((&(*bin)), (&(lhs)), (&(rhs))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (rhs)));
                if ((isArithmeticPU0121rB)((&(*bin)))) {
                    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
                    Type_u *rhsType = ((getTypePU9661rPU5175)((&((rhs)->typeState))));
                    Type_u *resType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                    String_s rt = ((generateTypeNamePS9442PU5175rS0540)((this), (resType)));
                    if (((isPointerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                        String_s tmp_91676 = (rt);
                        String_s tmp_91677 = (lhsExpr);
                        String_s tmp_91679 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)((unsigned char *)% % (unsigned char *)%)"),
                                                  ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91676, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91677, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                      ((Data_s){.ptr = &tmp_91679, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else if ((isPointerPU5175rB)((lhsType))) {
                        String_s tmp_91681 = (rt);
                        String_s tmp_91682 = (lhsExpr);
                        String_s tmp_91684 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)((unsigned char *)% % %)"),
                                                  ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91681, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91682, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                      ((Data_s){.ptr = &tmp_91684, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else if ((isPointerPU5175rB)((rhsType))) {
                        String_s tmp_91686 = (rt);
                        String_s tmp_91687 = (lhsExpr);
                        String_s tmp_91689 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)(% % (unsigned char *)%)"),
                                                  ((variadic_4480){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91686, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91687, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                      ((Data_s){.ptr = &tmp_91689, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else {
                        String_s tmp_91691 = (lhsExpr);
                        String_s tmp_91693 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                                  ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91691, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                      ((Data_s){.ptr = &tmp_91693, .info = type_info_table[18]})},
                                                                   .length = 3})));
                    }

                }

                else {
                    String_s tmp_91695 = (lhsExpr);
                    String_s tmp_91697 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                              ((variadic_4480){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91695, .info = type_info_table[18]}),
                                                                                  ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[225]}),
                                                                                  ((Data_s){.ptr = &tmp_91697, .info = type_info_table[18]})},
                                                               .length = 3})));
                }
            }
            goto after_19063;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_19063:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
i32 maini32PPcri32(i32 argc, char **argv) {
    if (!((tryFindPcrB)(("cl.exe")))) {
        (((fprintf))((stderr_), ("%s: Developer environment is not initialized properly!\n"), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: Could not find `cl.exe`.\n"), (NOTE_STR)));
        (((fprintf))((stderr_), ("%s: You can activate it by running `vcvarsall.bat x64` from your Visual Studio installation in the current terminal.\n"), (NOTE_STR)));
        (((fprintf))((stderr_), ("%s: You can find it here: `C:\\Program Files\\Microsoft Visual Studio\\<year>\\<version>"), (NOTE_STR)));
        (((fprintf))((stderr_), ("\\VC\\Auxiliary\\Build\\vcvarsall.bat`.\n")));
        (((fprintf))((stderr_), ("%s: In the future the compiler will initialize this environment itself, but until then you will"), (NOTE_STR)));
        (((fprintf))((stderr_), (" have to initialize the environment every time you start the terminal.\n")));
        return ((i32)(1));
    }

    for (usize i = ((usize)(0llu)); ((i) < (PARSED_TYPE_BUILTIN)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4419S1372rN)((&(typeNodes)), ((ParsedTypeNode_s){.span = ((Span_s){0}), .kind = (PARSED_TYPE_BUILTIN)})));
    }

    (((flags).file) = ((addStringFlagPS7660PcuszrPS0540)((&(flagParser)), ("The input file"), (FLAG_MODE_MANDATORY))));
    (((flags).out) = ((addStringFlagPS7660PcPcPcuszrPS0540)((&(flagParser)), ("o"), ("output"), ("The output file"), ((FLAG_MODE_SINGLE) | (FLAG_MODE_MANDATORY)))));
    (((flags).verbose) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("v"), ("verbose"), ("Enable verbose output"))));
    (((flags).warnSimple) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("w"), ("warn"), ("Enable warnings"))));
    (((flags).warnExtra) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-extra"), ("Enable extra warnings"))));
    (((flags).warnUnused) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-unused"), ("Enable warnings about unused expression values, functions, etc."))));
    bool *warnAll = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-all"), ("Enable all warnings")));
    (((flags).target) = ((addStringFlagPS7660PcPcPcrPS0540)((&(flagParser)), ("t"), ("target"), ("The target to compile for. Must be either Windows or Linux."))));
    (((flags).checkOnly) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--check-only"), ("Stop after semantic analysis"))));
    (((flags).emitASM) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-asm"), ("Save the generated assembly code in <output>.asm"))));
    (((flags).emitBIR) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-bir"), ("Save the generated bufo IR in <output>.bir"))));
    (((flags).emitLLVM) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-llvm"), ("Save the generated LLVM IR in <output>.ll"))));
    (((flags).transpileToC) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--transpile-c"), ("Transpile the input to a target-specific C program."))));
    (((flags).dontLink) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--dont-link"), ("Stop after generating <output>.obj"))));
    (((flags).noEntry) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-entry"), ("Don\'t include an entrypoint in the final output"))));
    (((flags).linkDynamic) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--link-dynamic"), ("Use the specified dynamic libraries to link instead of static libraries"))));
    (((flags).debug) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("d"), ("debug"), ("Compile with debug info"))));
    (((flags).trace) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--trace"), ("Trace function calls"))));
    (((flags).opt) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--opt"), ("Enable aggressive optimizations"))));
    (((flags).disableExternalComptime) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-extern-comptime"), ("Don\'t allow any compile time calls to functions marked `@extern`."))));
    (((flags).disableInlineAssembly) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-inline-assembly"), ("Don\'t allow any `asm()` blocks."))));
    bool *help = ((addHelpFlagPS7660rPB)((&(flagParser))));
    if (!((runOnPS7660i32PPcrB)((&(flagParser)), (argc), (argv)))) {
        ((showErrorsAnyPS7660rN)((stderr_), (&(flagParser))));
        ((showUsageAnyPS7660rN)((stderr_), (&(flagParser))));
        ((showHelpAnyPS7660rN)((stderr_), (&(flagParser))));
        return ((i32)(1));
    }

    if (*(help)) {
        ((showUsageAnyPS7660rN)((stdout_), (&(flagParser))));
        ((showHelpAnyPS7660rN)((stdout_), (&(flagParser))));
        return ((i32)(0));
    }

    if (*(warnAll)) {
        ((*((flags).warnExtra)) = (true));
        ((*((flags).warnSimple)) = (true));
        ((*((flags).warnUnused)) = (true));
    }

    if ((*((flags).warnExtra)) && (!(*((flags).warnSimple)))) {
        (((fprintf))((stderr_), ("error: --warn-extra only works in combination with [-w|--warn]\n")));
        return ((i32)(1));
    }

    for (u8 i = ((u8)(0)); ((i) < ((u8)((PRIM_TYPE_COUNT)))); ((i) = ((i) + ((u8)(1))))) {
        ((pushPS4174U5175rN)((&(types)), (((Type_u){.tag = 1, .payload = {0}}))));
        if (*((flags).debug))
            ((pushPS7368S5777rN)((&(debugTypes)), ((LLVMMetadata_s){0})));
        ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (*((PrimType_u *)((&(i)))))}}})));
    }

    String_s tmp_90091 = ((newStringFromStrLitPcrS0540)(("x86_64-pc-windows-msvc")));
    String_s tmp_90108 = ((newStringFromStrLitPcrS0540)(("x86_64-pc-linux-gnu")));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_90091))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("WINDOWS"))));
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_90108))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("LINUX"))));
    }

    else if ((((flags).target)->length) == ((usize)(0llu))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("WINDOWS"))));
    }

    else {
        (((fprintf))((stderr_), ("error: Unknown target %s\n"), (((flags).target)->buffer)));
        ((showHelpAnyPS7660rN)((stderr_), (&(flagParser))));
        return ((i32)(1));
    }

    String_s filepath = (*((flags).file));
    ((filepath) = ((toAbsolutePathPS0540rS0540)((&(filepath)))));
    SubStr_s fileSubStr = ((asSubStrPS0540rS7720)((&(filepath))));
    String_s string = ((readFileToStringPcrS0540)((((flags).file)->buffer)));
    SubStr_s sub = ((newSubStrOfStringPS0540uszuszrS7720)((&(string)), ((usize)(0llu)), ((string).length)));
    Parser_s parser = ((newParserFromSourceuszS7720rS2466)(((usize)(0llu)), (sub)));
    if (!((findStdAndAddToImportsPS2466rB)((&(parser)))))
        return ((i32)(1));
    ((addImportRootPS2466S7720rN)((&(parser)), ((newSubStrOfStrLitPcrS7720)(("./std/")))));
    ParsedFile_s project = ((parseProjectPS2466S7720rS1892)((&(parser)), (fileSubStr)));
    TypeChecker_s checker = ((newTypeCheckerrS3900)());
    if (!((typeCheckProjectPS3900PS1892rB)((&(checker)), (&(project)))))
        return ((i32)(1));
    if (*((flags).transpileToC)) {
        ((transpileToCrN)());
    }

    else {
        IRGen_s generator = ((newIRGeneratorPS7791rS9562)((&((checker).lookup))));
        if (!((generateBytecodePS9562PS1892rB)((&(generator)), (&(project)))))
            return ((i32)(1));
        if (!((analyzeControlFlowPS9562rB)((&(generator)))))
            return ((i32)(1));
        if (*((flags).checkOnly))
            return ((i32)(0));
        IRInterp_s interp = ((newIRInterpreterPS9562rS3154)((&(generator))));
        LLVMCodegen_s llvmCodegen = ((newLLVMCodegenS7720PS9562PS3154rS4053)((fileSubStr), (&(generator)), (&(interp))));
        if (!((generateExecutablePS4053S7720i32PPcrB)((&(llvmCodegen)), ((asSubStrPS0540rS7720)(((flags).out))), (argc), (argv))))
            return ((i32)(1));
        if (!((linkExecutablerB)()))
            return ((i32)(1));
    }

    if (*((flags).debug)) {
        (((printf))(("files.length         = %llu\n"), ((files).length)));
        (((printf))(("topLevelItems.length = %llu\n"), ((topLevelItems).length)));
        (((printf))(("structDecls.length   = %llu\n"), ((structDecls).length)));
        (((printf))(("funcDecls.length     = %llu\n"), ((funcDecls).length)));
        (((printf))(("blocks.length        = %llu\n"), ((blocks).length)));
        (((printf))(("stmts.length         = %llu\n"), ((stmts).length)));
        (((printf))(("typeNodes.length     = %llu\n"), ((typeNodes).length)));
        (((printf))(("exprs.length         = %llu\n"), ((exprs).length)));
    }

    ((dropPS0540rN)((&(string))));
    return ((i32)(0));
}
bool findStdAndAddToImportsPS2466rB(Parser_s *parser) {
    char *_my_path = ((getBufoPathrPc)());
    String_s my_path = ((newStringFromStrLitPcrS0540)((_my_path)));
    (((free))((_my_path)));
    String_s root = ((getRootPS0540rS0540)((&(my_path))));
    ((pushStrPS0540PcrN)((&(root)), ("\\std\\")));
    ((addImportRootPS2466S7720rN)((parser), ((asSubStrPS0540rS7720)((&(root))))));
    return (true);
}
char *getBufoPathrPc(none) {
    u32 MAX_PATH = ((u32)(260));
    array_5566 buf = ((array_5566){
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    u32 length = (((GetModuleFileNameA))(((Handle_s){0}), (&(((buf).arr)[((usize)(0llu))])), (MAX_PATH)));
    Any buffer = (((malloc))((((usize)((length))) + ((usize)(1llu)))));
    (((memset))((buffer), ((i32)(0)), (((usize)((length))) + ((usize)(1llu)))));
    (((memcpy))((buffer), (&(buf)), ((usize)((length)))));
    return ((char *)((buffer)));
}
bool linkExecutablerB(none) {
    if (*((flags).dontLink)) {
        return (true);
    }

    String_s tmp_90464 = ((newStringFromStrLitPcrS0540)(("WINDOWS")));

    if (!((equalsPS0540PS0540rB)(((flags).target), (&tmp_90464)))) {
        (((fprintf))((stderr_), ("%s: Cross-linking is not supported yet. Run with `--dont-link` to generate an object file.\n"), (ERR_STR)));
        return (false);
    }

    String_s s = ((String_s){0});
    if ((tryFindPcrB)(("radlink.exe"))) {
        ((s) = ((newStringFromStrLitPcrS0540)(("radlink.exe "))));
    }

    else if ((tryFindPcrB)(("link.exe"))) {
        ((s) = ((newStringFromStrLitPcrS0540)(("link.exe "))));
    }

    else {
        (((fprintf))((stderr_), ("error: Could not find a linker in PATH. Did you forget to initialize a developer environment?\n")));
        (((fprintf))((stderr_), ("note: Currently we support the normal Visual Studio `link.exe`, and experimentally `radlink.exe` for improved linking times.\n")));
        return (false);
    }

    if (*((flags).debug)) {
        ((pushStrPS0540PcrN)((&(s)), ("/DEBUG:full ")));
        ((pushStrPS0540PcrN)((&(s)), ("/IGNORE:4099 ")));
    }

    ((pushStrPS0540PcrN)((&(s)), ("/INCREMENTAL:NO ")));
    ((pushStrPS0540PcrN)((&(s)), ("/DEFAULTLIB:libcmt ")));
    ((pushStringPS0540PS0540rN)((&(s)), ((flags).out)));
    ((pushStrPS0540PcrN)((&(s)), (".obj ")));
    ((pushStrPS0540PcrN)((&(s)), ("/OUT:")));
    ((pushStringPS0540PS0540rN)((&(s)), ((flags).out)));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ((pushCharPS0540crN)((&(s)), (' ')));
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_12024_ = true;
            bool succ_12028_ = true;
            bool succ_12032_ = true;
            bool succ_12038_ = true;

            Config_u *tmp_19273_ = (_flag);
            {
                succ_12024_ &= (tmp_19273_->tag == 1);
                Token_s *name = &tmp_19273_->payload.variant1._0;
                succ_12024_ &= true;
                if (succ_12024_) {
                    {
                        if (*((flags).linkDynamic))
                            continue;
                        ((pushStrPS0540PcrN)((&(s)), ("\"")));
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                        ((pushStrPS0540PcrN)((&(s)), ("\"")));
                    }
                    goto after_19273;
                }
            }
            {
                succ_12028_ &= (tmp_19273_->tag == 2);
                Token_s *name = &tmp_19273_->payload.variant2._0;
                succ_12028_ &= true;
                if (succ_12028_) {
                    {
                        if (!(*((flags).linkDynamic)))
                            continue;
                        ((pushStrPS0540PcrN)((&(s)), ("\"")));
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                        ((pushStrPS0540PcrN)((&(s)), ("\"")));
                    }
                    goto after_19273;
                }
            }
            {
                succ_12032_ &= (tmp_19273_->tag == 3);
                Token_s *name = &tmp_19273_->payload.variant3._0;
                succ_12032_ &= true;
                if (succ_12032_) {
                    {
                        String_s _p = ((toStringPS7720rS0540)((&((*name).content))));
                        ((pushStrPS0540PcrN)((&(s)), ("/LIBPATH:\"")));
                        if (!((dirExistsPcrB)(((_p).buffer)))) {
                            char *_my_path = ((getBufoPathrPc)());
                            ((pushStrPS0540PcrN)((&(s)), (_my_path)));
                            ((s) = ((getRootPS0540rS0540)((&(s)))));
                            (((free))((_my_path)));
                        }

                        ((pushStringPS0540PS0540rN)((&(s)), (&(_p))));
                        ((pushStrPS0540PcrN)((&(s)), ("\"")));
                        ((dropPS0540rN)((&(_p))));
                    }
                    goto after_19273;
                }
            }
            {
                succ_12038_ &= (tmp_19273_->tag == 4);
                Token_s *name = &tmp_19273_->payload.variant4._0;
                succ_12038_ &= true;
                if (succ_12038_) {
                    {
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                    }
                    goto after_19273;
                }
            }
            {
                Config_u **unknown = &tmp_19273_;
                if (true) {
                    {
                        (((fprintf))((stderr_), ("%s linkExecutable: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                        (((C_exiti32rN))(((i32)(2))));
                    }
                    goto after_19273;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_19273:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    if (!(*((flags).verbose))) {
        ((pushStrPS0540PcrN)((&(s)), (" /NOLOGO")));
    }

    Cmd_s cmd = ((newCmdFromStrLitPcrS3657)(((s).buffer)));
    (((cmd).log) = (*((flags).verbose)));
    bool success = ((runSyncPS3657rB)((&(cmd))));
    ((dropPS0540rN)((&(s))));
    return (success);
}
i32 __real_main(i32 argc, char **argv, i32 (*main)(i32, char **)) {
    ((setupStdHandlesrN)());
    i32 code = ((main)((argc), (argv)));
    (((fflush))((NULL)));
    return (code);
}

// The entry point for the C runtime
int main(int argc, char **argv) {
    __global_init_please_dont_call_yourself();
    return __real_main(argc, argv, &maini32PPcri32);
}
