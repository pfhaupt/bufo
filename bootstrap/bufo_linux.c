// Builtin Types:
#include <stdbool.h> // bool
#include <stddef.h>  // NULL
#include <stdint.h>
typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;
typedef void *Any;
typedef void none;
typedef float f32;
typedef double f64;
typedef u64 usize;
// C doesn't have f32 % f32 etc.
float fmodf(float x, float y);
double fmod(double x, double y);

// Struct Declarations:
typedef struct StringList_s StringList_s;
typedef struct String_s String_s;
typedef struct SubStr_s SubStr_s;
typedef struct StringBuffer_s StringBuffer_s;
typedef struct Handle_s Handle_s;
typedef struct Pid_t_s Pid_t_s;
typedef struct Stat_s Stat_s;
typedef struct Cmd_s Cmd_s;
typedef struct LLVM_TargetMachineOptionsRef_s LLVM_TargetMachineOptionsRef_s;
typedef struct LLVM_TargetMachineRef_s LLVM_TargetMachineRef_s;
typedef struct LLVM_TargetRef_s LLVM_TargetRef_s;
typedef struct LLVM_TargetDataRef_s LLVM_TargetDataRef_s;
typedef struct LLVM_ContextRef_s LLVM_ContextRef_s;
typedef struct LLVM_ModuleRef_s LLVM_ModuleRef_s;
typedef struct LLVM_BuilderRef_s LLVM_BuilderRef_s;
typedef struct LLVM_BasicBlockRef_s LLVM_BasicBlockRef_s;
typedef struct LLVM_ValueRef_s LLVM_ValueRef_s;
typedef struct LLVM_TypeRef_s LLVM_TypeRef_s;
typedef struct LLVM_AttributeRef_s LLVM_AttributeRef_s;
typedef struct LLVM_PassBuilderOptionsRef_s LLVM_PassBuilderOptionsRef_s;
typedef struct LLVM_ErrorRef_s LLVM_ErrorRef_s;
typedef struct LLVM_DIBuilderRef_s LLVM_DIBuilderRef_s;
typedef struct LLVM_MetadataRef_s LLVM_MetadataRef_s;
typedef struct LLVM_DbgRecordRef_s LLVM_DbgRecordRef_s;
typedef struct LLVMBool_s LLVMBool_s;
typedef struct LLVMString_s LLVMString_s;
typedef struct InterpReg_s InterpReg_s;
typedef struct IRValueList_s IRValueList_s;
typedef struct ASMContext_s ASMContext_s;
typedef struct Token_s Token_s;
typedef struct TypeInfoTable_s TypeInfoTable_s;
typedef struct TypeInfoList_s TypeInfoList_s;
typedef struct FieldTypeInfoList_s FieldTypeInfoList_s;
typedef struct FieldTypeInfo_s FieldTypeInfo_s;
typedef struct UnionVariantTypeInfoList_s UnionVariantTypeInfoList_s;
typedef struct Data_s Data_s;
typedef struct LLVMMetadata_s LLVMMetadata_s;
typedef struct ArenaBlock_s ArenaBlock_s;
typedef struct ParsedConfigArena_s ParsedConfigArena_s;
typedef struct ParsedFileArena_s ParsedFileArena_s;
typedef struct ParsedTopLevelItemArena_s ParsedTopLevelItemArena_s;
typedef struct ParsedModuleArena_s ParsedModuleArena_s;
typedef struct ParsedStructDeclArena_s ParsedStructDeclArena_s;
typedef struct ParsedUnionDeclArena_s ParsedUnionDeclArena_s;
typedef struct ParsedUnionVariantArena_s ParsedUnionVariantArena_s;
typedef struct ParsedFuncDeclArena_s ParsedFuncDeclArena_s;
typedef struct ParsedBlockArena_s ParsedBlockArena_s;
typedef struct ParsedStmtArena_s ParsedStmtArena_s;
typedef struct ParsedExprArena_s ParsedExprArena_s;
typedef struct ParsedTypeNodeArena_s ParsedTypeNodeArena_s;
typedef struct TypeArena_s TypeArena_s;
typedef struct DLLArena_s DLLArena_s;
typedef struct ParsedPatternArena_s ParsedPatternArena_s;
typedef struct LLVMMetadataArena_s LLVMMetadataArena_s;
typedef struct Lexer_s Lexer_s;
typedef struct String_IRFuncEntry_s String_IRFuncEntry_s;
typedef struct String_IRFuncHashMap_s String_IRFuncHashMap_s;
typedef struct ByteBuffer_s ByteBuffer_s;
typedef struct Function_s Function_s;
typedef struct GPR_s GPR_s;
typedef struct FPR_s FPR_s;
typedef struct ImmI8_s ImmI8_s;
typedef struct ImmI16_s ImmI16_s;
typedef struct ImmI32_s ImmI32_s;
typedef struct ImmI64_s ImmI64_s;
typedef struct ImmF32_s ImmF32_s;
typedef struct ImmF64_s ImmF64_s;
typedef struct Assembler_s Assembler_s;
typedef struct CallStackInfo_s CallStackInfo_s;
typedef struct CallStack_s CallStack_s;
typedef struct IRInterp_s IRInterp_s;
typedef struct LLVMBasicBlock_s LLVMBasicBlock_s;
typedef struct LLVMAttribute_s LLVMAttribute_s;
typedef struct LLVMValue_s LLVMValue_s;
typedef struct LLVMType_s LLVMType_s;
typedef struct LLVMPassBuilderOptions_s LLVMPassBuilderOptions_s;
typedef struct LLVMDataLayout_s LLVMDataLayout_s;
typedef struct LLVMTargetData_s LLVMTargetData_s;
typedef struct LLVMTarget_s LLVMTarget_s;
typedef struct LLVMTargetMachine_s LLVMTargetMachine_s;
typedef struct LLVMTargetMachineOptions_s LLVMTargetMachineOptions_s;
typedef struct LLVMModule_s LLVMModule_s;
typedef struct LLVMBuilder_s LLVMBuilder_s;
typedef struct LLVMContext_s LLVMContext_s;
typedef struct DebugInfo_s DebugInfo_s;
typedef struct LLVMDIBuilder_s LLVMDIBuilder_s;
typedef struct LLVMDbgRecord_s LLVMDbgRecord_s;
typedef struct LLVMCodegen_s LLVMCodegen_s;
typedef struct RegIndex_s RegIndex_s;
typedef struct IRReg_s IRReg_s;
typedef struct IRInstr_s IRInstr_s;
typedef struct LoopBlock_s LoopBlock_s;
typedef struct IRBlockID_s IRBlockID_s;
typedef struct IRBlock_s IRBlock_s;
typedef struct IRFunc_s IRFunc_s;
typedef struct IRScopeEntry_s IRScopeEntry_s;
typedef struct IRScope_s IRScope_s;
typedef struct IRGen_s IRGen_s;
typedef struct Parser_s Parser_s;
typedef struct Lookup_s Lookup_s;
typedef struct FileLookup_s FileLookup_s;
typedef struct ImportLookup_s ImportLookup_s;
typedef struct ModuleLookup_s ModuleLookup_s;
typedef struct MLConfig_s MLConfig_s;
typedef struct FunctionLookup_s FunctionLookup_s;
typedef struct TypeLookup_s TypeLookup_s;
typedef struct StructLookup_s StructLookup_s;
typedef struct UnionLookup_s UnionLookup_s;
typedef struct UnionVariantLookup_s UnionVariantLookup_s;
typedef struct VariableLookup_s VariableLookup_s;
typedef struct ScopeLookup_s ScopeLookup_s;
typedef struct PatState_s PatState_s;
typedef struct TypeChecker_s TypeChecker_s;
typedef struct ArrayContext_s ArrayContext_s;
typedef struct StructContext_s StructContext_s;
typedef struct StructInitContext_s StructInitContext_s;
typedef struct ParamContext_s ParamContext_s;
typedef struct IfContext_s IfContext_s;
typedef struct FuncAttr_s FuncAttr_s;
typedef struct ParsedAttributeList_s ParsedAttributeList_s;
typedef struct FunctionLookupList_s FunctionLookupList_s;
typedef struct StructLookupList_s StructLookupList_s;
typedef struct ScopeLookupList_s ScopeLookupList_s;
typedef struct TypeLookupList_s TypeLookupList_s;
typedef struct VariableLookupList_s VariableLookupList_s;
typedef struct ImportLookupList_s ImportLookupList_s;
typedef struct ModuleLookupList_s ModuleLookupList_s;
typedef struct TCStateList_s TCStateList_s;
typedef struct RegIndexList_s RegIndexList_s;
typedef struct IRInstrList_s IRInstrList_s;
typedef struct IRScopeList_s IRScopeList_s;
typedef struct IRRegList_s IRRegList_s;
typedef struct IRBlockList_s IRBlockList_s;
typedef struct LoopBlockList_s LoopBlockList_s;
typedef struct IRScopeEntryList_s IRScopeEntryList_s;
typedef struct IRFuncList_s IRFuncList_s;
typedef struct LLVMTypeList_s LLVMTypeList_s;
typedef struct RegValueList_s RegValueList_s;
typedef struct LLVMBasicBlockList_s LLVMBasicBlockList_s;
typedef struct LLVMValueList_s LLVMValueList_s;
typedef struct UsizeList_s UsizeList_s;
typedef struct ConfigList_s ConfigList_s;
typedef struct TokenList_s TokenList_s;
typedef struct ParsedTypeNodeList_s ParsedTypeNodeList_s;
typedef struct ParsedUnionVariantList_s ParsedUnionVariantList_s;
typedef struct UnionLookupList_s UnionLookupList_s;
typedef struct UnionVariantLookupList_s UnionVariantLookupList_s;
typedef struct ParsedPatternList_s ParsedPatternList_s;
typedef struct ParsedStmtList_s ParsedStmtList_s;
typedef struct ParsedExprList_s ParsedExprList_s;
typedef struct TypeList_s TypeList_s;
typedef struct ParsedConfig_s ParsedConfig_s;
typedef struct ParsedFile_s ParsedFile_s;
typedef struct TLIParent_s TLIParent_s;
typedef struct ParsedTopLevelItem_s ParsedTopLevelItem_s;
typedef struct DLL_s DLL_s;
typedef struct ParsedModule_s ParsedModule_s;
typedef struct ParsedStructDecl_s ParsedStructDecl_s;
typedef struct ParsedUnionDecl_s ParsedUnionDecl_s;
typedef struct ParsedUnionVariant_s ParsedUnionVariant_s;
typedef struct ParsedFuncDecl_s ParsedFuncDecl_s;
typedef struct ParsedBlock_s ParsedBlock_s;
typedef struct VarDecl_s VarDecl_s;
typedef struct ParsedStmt_s ParsedStmt_s;
typedef struct ParsedTypeNode_s ParsedTypeNode_s;
typedef struct IdentExpr_s IdentExpr_s;
typedef struct StructExpr_s StructExpr_s;
typedef struct CallExpr_s CallExpr_s;
typedef struct ParsedExpr_s ParsedExpr_s;
typedef struct ParsedPattern_s ParsedPattern_s;
typedef struct Span_s Span_s;
typedef struct Flag_s Flag_s;
typedef struct FlagParser_s FlagParser_s;
typedef struct GAF_List_s GAF_List_s;
typedef struct GAF_HashMap_s GAF_HashMap_s;
typedef struct GAF_HashSet_s GAF_HashSet_s;
typedef struct Var_Context_s Var_Context_s;
typedef struct CStack_s CStack_s;
typedef struct CGen_s CGen_s;
typedef struct TypeDeclEntry_s TypeDeclEntry_s;
typedef struct Flags_s Flags_s;

// Union Declarations:
typedef struct LLVM_CodeGenOptLevel_u LLVM_CodeGenOptLevel_u;
typedef struct LLVM_RelocMode_u LLVM_RelocMode_u;
typedef struct LLVM_CodeModel_u LLVM_CodeModel_u;
typedef struct IRValue_u IRValue_u;
typedef struct ASMDialect_u ASMDialect_u;
typedef struct ASMConstraint_u ASMConstraint_u;
typedef struct ASMLoc_u ASMLoc_u;
typedef struct UnionVariantTypeInfo_u UnionVariantTypeInfo_u;
typedef struct TypeInfo_u TypeInfo_u;
typedef struct RegValue_u RegValue_u;
typedef struct TCState_u TCState_u;
typedef struct PrimType_u PrimType_u;
typedef struct Type_u Type_u;
typedef struct ParsedAttribute_u ParsedAttribute_u;
typedef struct Config_u Config_u;
typedef struct ParsedUnionVariantData_u ParsedUnionVariantData_u;
typedef struct StmtData_u StmtData_u;
typedef struct Assoc_u Assoc_u;
typedef struct ExprData_u ExprData_u;
typedef struct UnaryExpr_u UnaryExpr_u;
typedef struct BinaryExpr_u BinaryExpr_u;
typedef struct UnionExpr_u UnionExpr_u;
typedef struct Pattern_u Pattern_u;
typedef struct FlagData_u FlagData_u;

// Tuple Types:
typedef struct tuple_1044 tuple_1044;
typedef struct tuple_4329 tuple_4329;
typedef struct tuple_4458 tuple_4458;
typedef struct tuple_4545 tuple_4545;

// Array Types:
typedef struct array_244 array_244;
typedef struct array_378 array_378;
typedef struct array_5189 array_5189;
typedef struct array_5236 array_5236;
typedef struct array_5858 array_5858;
typedef struct array_6016 array_6016;
typedef struct array_27594 array_27594;
typedef struct array_32164 array_32164;
typedef struct array_33013 array_33013;

struct StringList_s {
    String_s *elements;
    usize length;
    usize capacity;
};
struct String_s {
    char *buffer;
    usize length;
    usize capacity;
};
struct SubStr_s {
    char *start;
    usize len;
};
struct StringBuffer_s {
    SubStr_s *data;
    usize length;
    usize capacity;
};
struct Handle_s {
    usize ptr;
};
struct Pid_t_s {
    i32 id;
};
struct array_244 {
    i64 arr[3];
};
struct Stat_s {
    u64 st_dev;
    u64 st_ino;
    u64 st_nlink;
    u32 st_mode;
    u32 st_uid;
    u32 st_gid;
    u32 __pad0;
    u64 st_rdev;
    i64 st_size;
    i64 st_blksize;
    i64 st_blocks;
    u64 st_atime;
    u64 st_atime_nsec;
    u64 st_mtime;
    u64 st_mtime_nsec;
    u64 st_ctime;
    u64 st_ctime_nsec;
    array_244 __unused;
};
struct Cmd_s {
    bool log;
    StringBuffer_s buf;
};
struct LLVM_TargetMachineOptionsRef_s {
    Any ptr;
};
struct LLVM_TargetMachineRef_s {
    Any ptr;
};
struct LLVM_TargetRef_s {
    Any ptr;
};
struct LLVM_TargetDataRef_s {
    Any ptr;
};
struct LLVM_ContextRef_s {
    Any ptr;
};
struct LLVM_ModuleRef_s {
    Any ptr;
};
struct LLVM_BuilderRef_s {
    Any ptr;
};
struct LLVM_BasicBlockRef_s {
    Any ptr;
};
struct LLVM_ValueRef_s {
    Any ptr;
};
struct LLVM_TypeRef_s {
    Any ptr;
};
struct LLVM_AttributeRef_s {
    Any ptr;
};
struct LLVM_PassBuilderOptionsRef_s {
    Any ptr;
};
struct LLVM_ErrorRef_s {
    Any ptr;
};
struct LLVM_DIBuilderRef_s {
    Any ptr;
};
struct LLVM_MetadataRef_s {
    Any ptr;
};
struct LLVM_DbgRecordRef_s {
    Any ptr;
};
struct LLVMBool_s {
    i32 val;
};
struct LLVMString_s {
    char *chars;
};
struct InterpReg_s {
    usize offset;
    usize size;
};
struct IRValueList_s {
    IRValue_u *elements;
    usize length;
    usize capacity;
};
struct ASMDialect_u {
    u8 tag;
};
struct ASMContext_s {
    String_s code;
    StringList_s out;
    StringList_s in;
    StringList_s clobber;
    IRValueList_s args;
    bool sideEffects;
    bool alignedStack;
    ASMDialect_u dialect;
    bool canThrow;
};
struct Span_s {
    usize file;
    usize start;
    usize end;
};
struct Token_s {
    Span_s span;
    SubStr_s content;
    usize kind;
};
struct TypeInfoTable_s {
    TypeInfo_u *elements;
    usize length;
    usize capacity;
};
struct TypeInfoList_s {
    usize *elements;
    usize length;
    usize capacity;
};
struct FieldTypeInfoList_s {
    FieldTypeInfo_s *elements;
    usize length;
    usize capacity;
};
struct FieldTypeInfo_s {
    SubStr_s name;
    usize type;
    usize offset_in_bytes;
};
struct UnionVariantTypeInfoList_s {
    UnionVariantTypeInfo_u *elements;
    usize length;
    usize capacity;
};
struct TypeInfo_u {
    u8 tag;
    union {
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
        } variant1;
        struct {
            SubStr_s _0;
            usize _1;
        } variant2;
        struct {
            SubStr_s _0;
            usize _1;
        } variant3;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            usize _3;
            usize _4;
        } variant4;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            FieldTypeInfoList_s _3;
        } variant5;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            UnionVariantTypeInfoList_s _3;
        } variant6;
        struct {
            SubStr_s _0;
            TypeInfoList_s _1;
            usize _2;
        } variant7;
        struct {
            SubStr_s _0;
            usize _1;
            usize _2;
            TypeInfoList_s _3;
        } variant8;
    } payload;
};
struct Data_s {
    Any ptr;
    TypeInfo_u info;
};
struct LLVMMetadata_s {
    LLVM_MetadataRef_s ref;
};
struct ArenaBlock_s {
    Any elements;
    usize length;
    usize capacity;
    usize elemSize;
    ArenaBlock_s *next;
};
struct ParsedConfigArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedFileArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedTopLevelItemArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedModuleArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedStructDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedUnionDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedUnionVariantArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedFuncDeclArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedBlockArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedStmtArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedExprArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedTypeNodeArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct TypeArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct DLLArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct ParsedPatternArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct LLVMMetadataArena_s {
    ArenaBlock_s *start;
    ArenaBlock_s *end;
    usize length;
};
struct Lexer_s {
    usize fileID;
    SubStr_s content;
    usize ptr;
    usize len;
};
struct IRScopeList_s {
    IRScope_s *elements;
    usize length;
    usize capacity;
};
struct IRRegList_s {
    IRReg_s *elements;
    usize length;
    usize capacity;
};
struct IRBlockList_s {
    IRBlock_s *elements;
    usize length;
    usize capacity;
};
struct LoopBlockList_s {
    LoopBlock_s *elements;
    usize length;
    usize capacity;
};
struct IRBlockID_s {
    usize i;
};
struct LLVMValue_s {
    LLVM_ValueRef_s ref;
};
struct RegIndex_s {
    usize i;
};
struct ParsedAttributeList_s {
    ParsedAttribute_u *elements;
    usize length;
    usize capacity;
};
struct IRFunc_s {
    usize originalID;
    String_s name;
    Span_s span;
    usize comptimeLevel;
    IRScopeList_s scopes;
    IRRegList_s registers;
    IRBlockList_s blocks;
    LoopBlockList_s loopBlocks;
    IRBlockID_s currentBlock;
    LLVMValue_s llvmFunc;
    RegIndex_s retPtr;
    ParsedAttributeList_s attrs;
    IRBlockID_s returnBlockID;
    RegIndex_s returnAlloc;
    usize allocaCounter;
};
struct String_IRFuncEntry_s {
    bool set;
    String_s key;
    IRFunc_s value;
};
struct String_IRFuncHashMap_s {
    String_IRFuncEntry_s *elements;
    usize length;
    usize capacity;
    bool locked;
};
struct ByteBuffer_s {
    u8 *elements;
    usize length;
    usize capacity;
};
struct Function_s {
    u64 (*run)(none);
    usize size;
};
struct GPR_s {
    u8 r;
};
struct FPR_s {
    u8 r;
};
struct ImmI8_s {
    u8 b;
};
struct ImmI16_s {
    u16 b;
};
struct ImmI32_s {
    u32 b;
};
struct ImmI64_s {
    u64 b;
};
struct ImmF32_s {
    f32 b;
};
struct ImmF64_s {
    f64 b;
};
struct CallStackInfo_s {
    Span_s span;
    String_s name;
};
struct CallStack_s {
    CallStackInfo_s *elements;
    usize length;
    usize capacity;
};
struct IRInterp_s {
    IRGen_s *irGen;
    u8 *regStackStart;
    RegValueList_s *globalRegisters;
    u8 *globalRegBase;
    u8 *regStackBase;
    u8 *realStackStart;
    u8 *realStackPointer;
    u8 *realStackBase;
    u8 *argStack;
    usize argStackLength;
    usize argStackCapacity;
    CallStack_s callStack;
};
struct LLVMBasicBlock_s {
    LLVM_BasicBlockRef_s ref;
};
struct LLVMAttribute_s {
    LLVM_AttributeRef_s ref;
};
struct LLVMType_s {
    LLVM_TypeRef_s ref;
};
struct LLVMPassBuilderOptions_s {
    LLVM_PassBuilderOptionsRef_s ref;
};
struct LLVMDataLayout_s {
    char *ref;
};
struct LLVMTargetData_s {
    LLVM_TargetDataRef_s ref;
};
struct LLVMTarget_s {
    LLVM_TargetRef_s ref;
};
struct LLVMTargetMachine_s {
    LLVM_TargetMachineRef_s ref;
};
struct LLVMTargetMachineOptions_s {
    LLVM_TargetMachineOptionsRef_s ref;
};
struct LLVMModule_s {
    LLVM_ModuleRef_s ref;
};
struct LLVMBuilder_s {
    LLVM_BuilderRef_s ref;
};
struct LLVMContext_s {
    LLVM_ContextRef_s ref;
};
struct DebugInfo_s {
    LLVMMetadata_s diUnit;
    LLVMMetadata_s diFile;
    LLVMMetadata_s diType;
};
struct LLVMDIBuilder_s {
    LLVM_DIBuilderRef_s ref;
};
struct LLVMDbgRecord_s {
    LLVM_DbgRecordRef_s ref;
};
struct RegValueList_s {
    RegValue_u *elements;
    usize length;
    usize capacity;
};
struct LLVMCodegen_s {
    LLVMContext_s llvmContext;
    LLVMModule_s llvmModule;
    LLVMBuilder_s llvmBuilder;
    LLVMTargetMachine_s llvmTargetMachine;
    LLVMDIBuilder_s llvmDIBuilder;
    IRGen_s *irGen;
    IRInterp_s *interp;
    RegValueList_s global;
};
struct IRReg_s {
    bool isComptime;
    usize offset;
    Type_u *typ;
};
struct RegIndexList_s {
    RegIndex_s *elements;
    usize length;
    usize capacity;
};
struct IRInstr_s {
    usize kind;
    Span_s span;
    bool isComptime;
    RegIndex_s dst;
    RegIndex_s src;
    RegIndex_s op1;
    RegIndexList_s args;
};
struct LoopBlock_s {
    IRBlockID_s before;
    IRBlockID_s after;
};
struct IRInstrList_s {
    IRInstr_s *elements;
    usize length;
    usize capacity;
};
struct IRBlock_s {
    String_s parent;
    IRBlockID_s id;
    IRInstrList_s instructions;
};
struct IRScopeEntry_s {
    SubStr_s name;
    RegIndex_s ptr;
    bool isComptime;
};
struct IRScopeEntryList_s {
    IRScopeEntry_s *elements;
    usize length;
    usize capacity;
};
struct IRScope_s {
    IRScopeEntryList_s entries;
};
struct IRGen_s {
    Lookup_s *lookup;
    IRFunc_s globalScope;
    IRFunc_s initRuntime;
    String_IRFuncHashMap_s functions;
    TypeInfoTable_s type_info_table;
    RegIndex_s type_info_array_register;
    bool error;
};
struct Parser_s {
    Lexer_s lexer;
    usize anonFnCount;
    String_s *importRoots;
    usize importRootLength;
    usize importRootCapacity;
};
struct ModuleLookupList_s {
    ModuleLookup_s *elements;
    usize length;
    usize capacity;
};
struct Lookup_s {
    ModuleLookupList_s files;
};
struct ImportLookupList_s {
    ImportLookup_s *elements;
    usize length;
    usize capacity;
};
struct FunctionLookupList_s {
    FunctionLookup_s *elements;
    usize length;
    usize capacity;
};
struct StructLookupList_s {
    StructLookup_s *elements;
    usize length;
    usize capacity;
};
struct UnionLookupList_s {
    UnionLookup_s *elements;
    usize length;
    usize capacity;
};
struct ScopeLookupList_s {
    ScopeLookup_s *elements;
    usize length;
    usize capacity;
};
struct ModuleLookup_s {
    usize globalID;
    Lookup_s *globalLookup;
    ParsedModule_s *parent;
    Token_s name;
    ImportLookupList_s imports;
    ModuleLookupList_s modules;
    FunctionLookupList_s functions;
    StructLookupList_s structs;
    UnionLookupList_s unions;
    ScopeLookupList_s variables;
};
struct FileLookup_s {
    usize globalID;
    SubStr_s origin;
    ModuleLookup_s mod;
};
struct ImportLookup_s {
    Span_s span;
    usize fileID;
};
struct MLConfig_s {
    bool checkSelf;
    bool checkImport;
    bool checkModule;
    bool checkParent;
    bool allowData;
};
struct TLIParent_s {
    bool isFile;
    u32 id;
};
struct PatState_s {
    bool complete;
};
struct TCState_u {
    u8 tag;
    union {
        struct {
            usize _0;
        } variant2;
        struct {
            Type_u *_0;
        } variant3;
        struct {
            PatState_s _0;
        } variant5;
    } payload;
};
struct VariableLookupList_s {
    VariableLookup_s *elements;
    usize length;
    usize capacity;
};
struct FunctionLookup_s {
    usize globalID;
    TLIParent_s parent;
    Token_s name;
    TCState_u fnType;
    VariableLookupList_s params;
    bool isVarArg;
};
struct TypeLookup_s {
    usize kind;
    Any actual;
};
struct StructLookup_s {
    usize globalID;
    TLIParent_s parent;
    Token_s name;
    VariableLookupList_s fields;
    Type_u *type;
};
struct UnionVariantLookupList_s {
    UnionVariantLookup_s *elements;
    usize length;
    usize capacity;
};
struct UnionLookup_s {
    ParsedUnionDecl_s *global;
    TLIParent_s parent;
    Token_s name;
    UnionVariantLookupList_s variants;
    Type_u *type;
};
struct UnionVariantLookup_s {
    ParsedUnionVariant_s *global;
    usize tag;
    TCState_u typeState;
};
struct VariableLookup_s {
    usize globalID;
    Token_s name;
    TCState_u typeState;
    bool isComptime;
};
struct ScopeLookup_s {
    VariableLookupList_s variables;
};
struct TypeChecker_s {
    usize comptimeDepth;
    ModuleLookup_s *currentModule;
    FunctionLookup_s *currentFunction;
    usize anonFuncDepth;
    Lookup_s lookup;
    bool typeError;
};
struct ArrayContext_s {
    usize *elemList;
    usize elemLength;
    usize elemCapacity;
    usize size;
};
struct StructContext_s {
    Token_s *fieldNames;
    ParsedTypeNode_s **fieldTypes;
    usize fieldLength;
    usize fieldCapacity;
};
struct StructInitContext_s {
    Token_s *fieldNames;
    ParsedExpr_s **fieldExprs;
    usize fieldLength;
    usize fieldCapacity;
};
struct ParamContext_s {
    Token_s *paramNames;
    ParsedTypeNode_s **paramTypes;
    usize paramLength;
    usize paramCapacity;
    bool isVarArg;
};
struct IfContext_s {
    ParsedStmt_s *thenBody;
    ParsedStmt_s *elseBody;
    bool hasElse;
};
struct FuncAttr_s {
    bool isVariadic;
    bool isNoreturn;
};
struct TypeLookupList_s {
    TypeLookup_s *elements;
    usize length;
    usize capacity;
};
struct TCStateList_s {
    TCState_u *elements;
    usize length;
    usize capacity;
};
struct IRFuncList_s {
    IRFunc_s *elements;
    usize length;
    usize capacity;
};
struct LLVMTypeList_s {
    LLVMType_s *elements;
    usize length;
    usize capacity;
};
struct LLVMBasicBlockList_s {
    LLVMBasicBlock_s *elements;
    usize length;
    usize capacity;
};
struct LLVMValueList_s {
    LLVMValue_s *elements;
    usize length;
    usize capacity;
};
struct UsizeList_s {
    usize *elements;
    usize length;
    usize capacity;
};
struct ConfigList_s {
    Config_u *elements;
    usize length;
    usize capacity;
};
struct TokenList_s {
    Token_s *elements;
    usize length;
    usize capacity;
};
struct ParsedTypeNodeList_s {
    ParsedTypeNode_s **elements;
    usize length;
    usize capacity;
};
struct ParsedUnionVariantList_s {
    ParsedUnionVariant_s **elements;
    usize length;
    usize capacity;
};
struct ParsedPatternList_s {
    ParsedPattern_s **elements;
    usize length;
    usize capacity;
};
struct ParsedStmtList_s {
    ParsedStmt_s **elements;
    usize length;
    usize capacity;
};
struct ParsedExprList_s {
    ParsedExpr_s **elements;
    usize length;
    usize capacity;
};
struct TypeList_s {
    Type_u **elements;
    usize length;
    usize capacity;
};
struct ParsedConfig_s {
    bool ignored;
    Span_s span;
    ConfigList_s configs;
};
struct ParsedFile_s {
    bool ignored;
    SubStr_s origin;
    SubStr_s src;
    ParsedModule_s *mod;
    DebugInfo_s debugInfo;
};
struct ParsedTopLevelItem_s {
    bool ignored;
    TLIParent_s parent;
    usize kind;
    Span_s span;
    usize nodeID;
    ParsedAttributeList_s attributes;
    TCState_u typeState;
};
struct DLL_s {
    String_s path;
    Handle_s handle;
};
struct ParsedModule_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    UsizeList_s tlis;
    UsizeList_s dlls;
};
struct ParsedStructDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    StructContext_s context;
    TCState_u typeState;
    DebugInfo_s debugInfo;
    bool isDataDefinition;
};
struct ParsedUnionDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    ParsedUnionVariantList_s variants;
    TCState_u typeState;
    DebugInfo_s debugInfo;
};
struct ParsedUnionVariantData_u {
    u8 tag;
    union {
        struct {
            ParsedTypeNodeList_s _0;
        } variant1;
        struct {
            ParsedTypeNodeList_s _0;
            TokenList_s _1;
        } variant2;
    } payload;
};
struct ParsedUnionVariant_s {
    bool ignored;
    TLIParent_s parent;
    Span_s span;
    Token_s name;
    ParsedUnionVariantData_u data;
};
struct ParsedFuncDecl_s {
    bool ignored;
    TLIParent_s parent;
    Token_s name;
    Span_s span;
    ParamContext_s params;
    ParsedTypeNode_s *retType;
    ParsedBlock_s *body;
    ParsedAttributeList_s attrs;
    bool isComptime;
    TCState_u typeState;
    DLL_s *dllHandle;
    DebugInfo_s debugInfo;
};
struct ParsedBlock_s {
    bool ignored;
    Span_s span;
    ParsedStmt_s **stmtList;
    usize stmtLength;
    usize stmtCapacity;
    TCState_u typeState;
};
struct VarDecl_s {
    ParsedPattern_s *pat;
    ParsedExpr_s *expr;
    ParsedBlock_s *trampoline;
    bool isComptime;
    bool isGlobal;
    usize origin;
};
struct StmtData_u {
    u8 tag;
    union {
        struct {
            VarDecl_s _0;
        } variant0;
        struct {
            ParsedExpr_s *_0;
        } variant2;
        struct {
            ParsedExpr_s *_0;
        } variant3;
        struct {
            ParsedBlock_s *_0;
        } variant4;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
        } variant5;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
            ParsedStmt_s *_2;
        } variant6;
        struct {
            ParsedExpr_s *_0;
            ParsedStmt_s *_1;
        } variant7;
        struct {
            ParsedStmt_s *_0;
            ParsedExpr_s *_1;
            ParsedExpr_s *_2;
            ParsedStmt_s *_3;
        } variant8;
        struct {
            ParsedExpr_s *_0;
            ParsedPatternList_s _1;
            ParsedStmtList_s _2;
        } variant11;
        struct {
            ParsedExpr_s *_0;
            ParsedExprList_s _1;
        } variant12;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
        } variant13;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
            ParsedBlock_s *_3;
        } variant14;
        struct {
            ParsedPattern_s *_0;
            ParsedExpr_s *_1;
            ParsedBlock_s *_2;
        } variant15;
    } payload;
};
struct ParsedStmt_s {
    bool ignored;
    Span_s span;
    StmtData_u data;
    TCState_u typeState;
};
struct ParsedTypeNode_s {
    bool ignored;
    Span_s span;
    usize kind;
    ParsedTypeNode_s *underlyingID;
    ParsedTypeNodeList_s fnParams;
    usize arraySize;
    Token_s nameTkn;
    TCState_u typeState;
};
struct IdentExpr_s {
    Token_s name;
    bool isGlobal;
    usize origID;
    Type_u *type;
};
struct StructExpr_s {
    Token_s name;
    StructInitContext_s context;
};
struct CallExpr_s {
    Span_s span;
    ParsedExpr_s *base;
    ParsedExprList_s args;
    Type_u *retType;
    bool isUnion;
};
struct UnaryExpr_u {
    u8 tag;
    union {
        struct {
            ParsedExpr_s *_0;
        } variant0;
        struct {
            ParsedExpr_s *_0;
        } variant1;
        struct {
            ParsedExpr_s *_0;
        } variant2;
        struct {
            ParsedExpr_s *_0;
        } variant3;
        struct {
            ParsedExpr_s *_0;
        } variant4;
    } payload;
};
struct BinaryExpr_u {
    u8 tag;
    union {
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant0;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant1;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant2;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant3;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant4;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant5;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant6;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant7;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant8;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant9;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant10;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant11;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant12;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant13;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant14;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant15;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant16;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant17;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant18;
        struct {
            ParsedExpr_s *_0;
            ParsedExpr_s *_1;
        } variant19;
    } payload;
};
struct UnionExpr_u {
    u8 tag;
    union {
        struct {
            CallExpr_s _0;
        } variant0;
        struct {
            StructExpr_s _0;
        } variant1;
    } payload;
};
struct ExprData_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant0;
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            ArrayContext_s _0;
        } variant3;
        struct {
            IdentExpr_s _0;
        } variant4;
        struct {
            UnaryExpr_u _0;
        } variant5;
        struct {
            BinaryExpr_u _0;
        } variant6;
        struct {
            CallExpr_s _0;
        } variant7;
        struct {
            ParsedTypeNode_s *_0;
        } variant8;
        struct {
            StructExpr_s _0;
        } variant9;
        struct {
            UnionExpr_u _0;
        } variant10;
        struct {
            ParsedExpr_s *_0;
            ParsedTypeNode_s *_1;
        } variant11;
        struct {
            ParsedFuncDecl_s *_0;
        } variant16;
        struct {
            ParsedTypeNode_s *_0;
        } variant17;
        struct {
            ParsedExpr_s *_0;
        } variant18;
        struct {
            ParsedExprList_s _0;
        } variant19;
        struct {
            ParsedExprList_s _0;
        } variant20;
    } payload;
};
struct ParsedExpr_s {
    bool ignored;
    Span_s span;
    ExprData_u data;
    TCState_u typeState;
};
struct Pattern_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            ParsedPattern_s *_0;
            ParsedTypeNode_s *_1;
        } variant3;
        struct {
            ParsedPattern_s *_0;
        } variant4;
        struct {
            Token_s _0;
            ParsedPatternList_s _1;
        } variant5;
        struct {
            Token_s _0;
            ParsedPattern_s *_1;
        } variant6;
        struct {
            ParsedPatternList_s _0;
        } variant7;
        struct {
            bool _0;
        } variant9;
    } payload;
};
struct ParsedPattern_s {
    bool ignored;
    Span_s span;
    Pattern_u data;
};
struct FlagData_u {
    u8 tag;
    union {
        struct {
            String_s _0;
        } variant1;
        struct {
            bool _0;
        } variant2;
    } payload;
};
struct Flag_s {
    bool found;
    usize mode;
    char *short_;
    char *long_;
    char *descr;
    FlagData_u data;
};
struct array_378 {
    Flag_s arr[32];
};
struct FlagParser_s {
    String_s programName;
    bool *helpFlag;
    array_378 flags;
    usize flagCount;
    StringList_s errors;
};
struct GAF_List_s {
    Any elements;
    usize length;
    usize capacity;
    TypeInfo_u type;
    usize type_size;
};
struct GAF_HashMap_s {
    Any elements;
    Any keys;
    bool *set_elements;
    usize length;
    usize capacity;
    TypeInfo_u key_type;
    usize key_type_size;
    TypeInfo_u value_type;
    usize value_type_size;
    usize (*key_hash_fn)(Data_s);
    bool (*key_equals_fn)(Data_s, Data_s);
};
struct GAF_HashSet_s {
    GAF_HashMap_s _map;
};
struct Var_Context_s {
    bool bound_in_reference_pattern;
};
struct CStack_s {
    GAF_HashMap_s variables;
};
struct CGen_s {
    GAF_List_s stack;
    GAF_HashMap_s variadic_map;
    GAF_HashMap_s array_map_declared;
    GAF_HashMap_s array_map_defined;
    GAF_HashMap_s tuple_map_declared;
    GAF_HashMap_s tuple_map_defined;
    TypeInfoTable_s type_info_table;
};
struct TypeDeclEntry_s {
    String_s c_code;
    bool generated;
};
struct Flags_s {
    String_s *file;
    String_s *out;
    bool *verbose;
    bool *warnSimple;
    bool *warnExtra;
    bool *warnUnused;
    String_s *target;
    bool *checkOnly;
    bool *emitASM;
    bool *emitBIR;
    bool *emitLLVM;
    bool *transpileToC;
    bool *dontLink;
    bool *noEntry;
    bool *linkDynamic;
    bool *debug;
    bool *trace;
    bool *opt;
    bool *disableExternalComptime;
    bool *disableInlineAssembly;
};
struct LLVM_CodeGenOptLevel_u {
    u8 tag;
};
struct LLVM_RelocMode_u {
    u8 tag;
};
struct LLVM_CodeModel_u {
    u8 tag;
};
struct IRValue_u {
    u8 tag;
    union {
        struct {
            LLVM_ValueRef_s _0;
        } variant1;
        struct {
            InterpReg_s _0;
        } variant2;
        struct {
            LLVM_ValueRef_s _0;
            InterpReg_s _1;
        } variant3;
    } payload;
};
struct ASMLoc_u {
    u8 tag;
    union {
        struct {
            char *_0;
        } variant1;
    } payload;
};
struct ASMConstraint_u {
    u8 tag;
    union {
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant0;
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant1;
        struct {
            ASMLoc_u _0;
            IRValue_u _1;
        } variant2;
        struct {
            ASMLoc_u _0;
        } variant3;
    } payload;
};
struct UnionVariantTypeInfo_u {
    u8 tag;
    union {
        struct {
            SubStr_s _0;
        } variant0;
        struct {
            SubStr_s _0;
            TypeInfoList_s _1;
        } variant1;
        struct {
            SubStr_s _0;
            FieldTypeInfoList_s _1;
        } variant2;
    } payload;
};
struct RegValue_u {
    u8 tag;
    union {
        struct {
            LLVMValue_s _0;
        } variant1;
        struct {
            InterpReg_s _0;
        } variant2;
        struct {
            LLVMValue_s _0;
            InterpReg_s _1;
        } variant3;
    } payload;
};
struct PrimType_u {
    u8 tag;
};
struct Type_u {
    u8 tag;
    union {
        struct {
            Type_u *_0;
        } variant2;
        struct {
            PrimType_u _0;
        } variant3;
        struct {
            Type_u *_0;
        } variant4;
        struct {
            Type_u *_0;
            usize _1;
        } variant5;
        struct {
            TypeList_s _0;
            Type_u *_1;
            FuncAttr_s _2;
        } variant6;
        struct {
            ParsedStructDecl_s *_0;
        } variant7;
        struct {
            ParsedUnionDecl_s *_0;
            usize _1;
        } variant8;
        struct {
            ParsedModule_s *_0;
        } variant9;
        struct {
            TypeList_s _0;
        } variant10;
    } payload;
};
struct ParsedAttribute_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
    } payload;
};
struct Config_u {
    u8 tag;
    union {
        struct {
            Token_s _0;
        } variant0;
        struct {
            Token_s _0;
        } variant1;
        struct {
            Token_s _0;
        } variant2;
        struct {
            Token_s _0;
        } variant3;
        struct {
            Token_s _0;
        } variant4;
    } payload;
};
struct Assoc_u {
    u8 tag;
};
struct tuple_1044 {
    bool _0;
    ParsedTypeNodeList_s *_1;
};
struct tuple_4329 {
    Var_Context_s _0;
    bool _1;
};
struct tuple_4458 {
    String_s _0;
    String_s _1;
};
struct tuple_4545 {
    Data_s _0;
    Data_s _1;
};
struct array_5189 {
    char arr[16];
};
struct array_5236 {
    InterpReg_s (*arr[81])(IRInterp_s *, IRFunc_s *, IRInstr_s *, RegValueList_s *, bool);
};
struct array_5858 {
    char arr[50];
};
struct array_6016 {
    char arr[1024];
};
struct array_27594 {
    LLVMType_s arr[2];
};
struct array_32164 {
    LLVM_MetadataRef_s arr[2];
};
struct array_33013 {
    char *arr[26];
};

Any fdopen(i32 fd, char *mode);
usize snprintf(Any buffer, usize size, char *format, ...);
char *realpath(char *path, char *res);
i32 scanf(char *fmt, ...);
usize strlen(char *string);
i32 strcmp(char *s1, char *s2);
i32 strncmp(char *s1, char *s2, usize n);
char *strchr(char *s, char c);
Any malloc(usize bytes);
Any calloc(usize num, usize size);
Any realloc(Any ptr, usize new_size);
none free(Any ptr);
Any memcpy(Any dest, Any src, usize count);
i32 memcmp(Any lhs, Any rhs, usize count);
Any memset(Any s, i32 b, usize count);
Any aligned_alloc(usize alignment, usize size);
Any fopen(char *filename, char *mode);
usize fread(Any buffer, usize size, usize count, Any stream);
usize fwrite(Any buffer, usize size, usize count, Any stream);
i32 fclose(Any stream);
none fprintf(Any stream, char *msg, ...);
i32 fflush(Any stream);
char *getenv(char *name);
usize printf(char *msg, ...);
char putchar(char ch);
usize puts(char *s);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none abort(none);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none C_exiti32rN(i32 code);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none exit(i32 code);
none pushPS6808S0540rN(StringList_s *this, String_s element);
String_s *atPS6808uszrPS0540(StringList_s *this, usize index);
String_s *lastPS6808rPS0540(StringList_s *this);
usize hashPS0540rusz(String_s *this);
String_s toAbsolutePathPS0540rS0540(String_s *this);
String_s getFileNamePS0540rS0540(String_s *this);
String_s getRootPS0540rS0540(String_s *this);
none dropPS0540rN(String_s *this);
String_s copyPS0540rS0540(String_s *this);
none resizePS0540uszrN(String_s *this, usize newCap);
none printPS0540rN(String_s *this);
SubStr_s asSubStrPS0540rS7720(String_s *this);
SubStr_s substringPS0540uszuszrS7720(String_s *this, usize start, usize end);
none pushNumberPS0540uszrN(String_s *this, usize num);
none pushNumberAsHexPS0540uszrN(String_s *this, usize num);
none pushNumberPS0540f32rN(String_s *this, f32 i);
none pushNumberPS0540f64rN(String_s *this, f64 num);
none pushNumberPS0540u8rN(String_s *this, u8 i);
none pushNumberPS0540u16rN(String_s *this, u16 i);
none pushNumberPS0540u32rN(String_s *this, u32 i);
none pushNumberPS0540u64rN(String_s *this, u64 i);
none pushNumberPS0540i8rN(String_s *this, i8 i);
none pushNumberPS0540i16rN(String_s *this, i16 i);
none pushNumberPS0540i32rN(String_s *this, i32 i);
none pushNumberPS0540i64rN(String_s *this, i64 i);
none pushCharPS0540crN(String_s *this, char ch);
none pushHexPS0540u8rN(String_s *this, u8 hex);
none pushSubStrPS0540PS7720rN(String_s *this, SubStr_s *sub);
none pushStringPS0540PS0540rN(String_s *this, String_s *s);
none pushStrPS0540PcrN(String_s *this, char *s);
bool isNumberPS0540rB(String_s *this);
i64 toI64PS0540ri64(String_s *this);
u64 toU64PS0540ru64(String_s *this);
none replacePS0540ccrN(String_s *this, char what, char with);
StringList_s splitByPS0540FB_cPuszrS6808(String_s *this, bool (*pred)(char, usize *));
bool equalsPS0540PS0540rB(String_s *this, String_s *other);
String_s newStringrS0540(none);
String_s newReadonlyStringPcrS0540(char *s);
String_s newStringFromStrLitPcrS0540(char *s);
bool canReadFileToStringPcPS0540rB(char *path, String_s *source);
String_s readFileToStringPcrS0540(char *path);
none writeStringToFilePcS0540rN(char *path, String_s s);
bool isEmptyPS7720rB(SubStr_s *this);
usize hashPS7720uszrusz(SubStr_s *this, usize length);
usize hashPS7720rusz(SubStr_s *this);
u8 lexOrderPS7720PS7720ru8(SubStr_s *this, SubStr_s *other);
bool equalsPS7720PS7720rB(SubStr_s *this, SubStr_s *other);
none printPS7720rN(SubStr_s *this);
String_s getPathParentPS7720rS0540(SubStr_s *this);
String_s toStringPS7720rS0540(SubStr_s *this);
bool beginsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *prefix);
bool endsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *suffix);
none skipUntilPS7720FBcrN(SubStr_s *this, bool (*pred)(char));
SubStr_s splitNextPS7720FBcrS7720(SubStr_s *this, bool (*pred)(char));
none advancePS7720rN(SubStr_s *this);
none advancePS7720uszrN(SubStr_s *this, usize step);
SubStr_s substringPS7720uszuszrS7720(SubStr_s *this, usize start, usize end);
bool hasSpacePS7720rB(SubStr_s *this);
bool isNumberPS7720rB(SubStr_s *this);
u64 toU64PS7720ru64(SubStr_s *this);
f64 toF64PS7720rf64(SubStr_s *this);
SubStr_s newSubStrOfStrLitPcrS7720(char *orig);
SubStr_s newSubStrPcuszuszrS7720(char *orig, usize start, usize end);
SubStr_s newSubStrOfStringPS0540uszuszrS7720(String_s *orig, usize start, usize end);
SubStr_s defaultSubStrrS7720(none);
u8 tagAnyru8(Any union_);
SubStr_s comptimeSubStrPcrS7720(char *s);
none setupStdHandlesrN(none);
usize comptimeStrlenPcrusz(char *str);
usize pow2uszrusz(usize exp);
usize powuszuszrusz(usize base, usize exp);
usize shiftLeftuszuszrusz(usize base, usize bits);
usize shiftRightuszuszrusz(usize base, usize bits);
usize bitCountuszrusz(usize val);
bool isNumericcrB(char ch);
bool isAlphabeticcrB(char ch);
u8 asHexcru8(char ch);
bool isHexDigitcrB(char ch);
bool isWhitespacecrB(char ch);
bool isAlphanumericcrB(char ch);
bool isAsciiUppercasecrB(char ch);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none index_oobPci64rN(char* msg, i64 index);
none _empty_assertBrN(bool cond);
none _empty_assertBPcrN(bool cond, char *msg);
none assertBrN(bool cond);
none _assertBPcrN(bool cond, char *msg);
none assertBPcrN(bool cond, char *msg);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablerN(none);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablePcrN(char* msg);
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none todo_with_msgPcrN(char* msg);
none warningPcrN(char *msg);
none resizePS6678uszrN(StringBuffer_s *this, usize newCap);
none addPS6678S7720rN(StringBuffer_s *this, SubStr_s str);
char *getNthAsCharPtrPS6678uszrPc(StringBuffer_s *this, usize index);
none extendPS6678PS6678rN(StringBuffer_s *this, StringBuffer_s *other);
String_s toCmdStringPS6678rS0540(StringBuffer_s *this);
StringBuffer_s newStringBufferrS6678(none);
bool isNullS9457rB(Handle_s h);
i32 stat(char *path, Stat_s *Statbuf);
char *strerror(i32 errno);
i32 fork(none);
i32 execvp(char *name, char **args);
i32 waitpid(Handle_s pid, i32 *out, i32 flags);
bool WIFSIGNALEDi32rB(i32 Status);
bool WIFEXITEDi32rB(i32 Status);
i32 WTERMSIGi32ri32(i32 Status);
i32 WEXITSTATUSi32ri32(i32 Status);
char *strsignal(i32 signal);
i32 *__errno_location(none);
i32 readlink(char *pathname, char *buf, i32 bufsiz);
Any mmap(Any addr, usize length, i32 prot, i32 flags, i32 fd, usize offset);
i32 munmap(Any addr, usize length);
usize getpagesize(none);
Any dlopen(char *filename, i32 flags);
i32 dlclose(Any handle);
char *dlerror(none);
Handle_s dlopenPci32rS9457(char *filename, i32 flags);
Any dlsym(Any handle, char *symbol);
Handle_s dlsymS9457PcrS9457(Handle_s handle, char *symbol);
i32 *errnorPi32(none);
usize getLastModifiedPcrusz(char *filePath);
bool waitForProcessS9457rB(Handle_s proc);
bool dirExistsPcrB(char *path);
bool runCmdSyncS3657rB(Cmd_s cmd);
Handle_s runCmdAsyncS3657rS9457(Cmd_s cmd);
none addPS3657PcrN(Cmd_s *this, char *arg);
none addSubStrPS3657S7720rN(Cmd_s *this, SubStr_s arg);
none addManyPS3657S6678rN(Cmd_s *this, StringBuffer_s args);
bool runSyncPS3657rB(Cmd_s *this);
Handle_s runAsyncPS3657rS9457(Cmd_s *this);
String_s toStringPS3657rS0540(Cmd_s *this);
char **asCharPtrsPS3657rPPc(Cmd_s *this);
Cmd_s newCmdrS3657(none);
Cmd_s newCmdFromStrLitPcrS3657(char *command);
bool moveFilePcPcrB(char *from, char *to);
bool deleteFilePcrB(char *path);
bool LLVM_isNullS3482rB(LLVM_TargetMachineOptionsRef_s this);
bool LLVM_isNullS5038rB(LLVM_TargetMachineRef_s this);
bool LLVM_isNullS3497rB(LLVM_TargetRef_s this);
bool LLVM_isNullS6307rB(LLVM_TargetDataRef_s this);
bool LLVM_isNullS4183rB(LLVM_ContextRef_s this);
bool LLVM_isNullS3816rB(LLVM_ModuleRef_s this);
bool LLVM_isNullS3273rB(LLVM_BuilderRef_s this);
bool LLVM_isNullS6239rB(LLVM_BasicBlockRef_s this);
bool LLVM_isNullS1407rB(LLVM_ValueRef_s this);
bool LLVM_isNullS6708rB(LLVM_TypeRef_s this);
bool LLVM_isNullS8710rB(LLVM_AttributeRef_s this);
bool LLVM_isNullS7356rB(LLVM_PassBuilderOptionsRef_s this);
bool LLVM_isNullS0284rB(LLVM_ErrorRef_s this);
bool LLVM_isNullS1302rB(LLVM_DIBuilderRef_s this);
bool LLVM_isNullS9683rB(LLVM_MetadataRef_s this);
bool LLVM_isNullS5902rB(LLVM_DbgRecordRef_s this);
i32 LLVM_asI32Anyri32(Any u);
LLVM_TargetRef_s LLVMGetTargetFromName(char *name);
i32 LLVM_InitializeNativeAsmParser(none);
i32 LLVM_InitializeNativeAsmPrinter(none);
i32 LLVM_InitializeNativeDisassembler(none);
i32 LLVM_InitializeNativeTarget(none);
LLVM_TargetMachineRef_s LLVMCreateTargetMachine(LLVM_TargetRef_s T, char *Triple, char *CPU, char *Features, i32 Level, i32 Reloc, i32 CodeModel);
LLVM_TargetMachineRef_s LLVMCreateTargetMachineWithOptions(LLVM_TargetRef_s T, char *Triple, LLVM_TargetMachineOptionsRef_s Options);
i32 LLVMTargetMachineEmitToFile(LLVM_TargetMachineRef_s T, LLVM_ModuleRef_s M, char *path, i32 opts, LLVMString_s *err);
LLVM_TargetDataRef_s LLVMCreateTargetDataLayout(LLVM_TargetMachineRef_s T);
usize LLVMStoreSizeOfType(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
usize LLVMABISizeOfType(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
usize LLVMSizeOfTypeInBits(LLVM_TargetDataRef_s T, LLVM_TypeRef_s Ty);
char *LLVMCopyStringRepOfTargetData(LLVM_TargetDataRef_s T);
LLVM_TargetMachineOptionsRef_s LLVMCreateTargetMachineOptions(none);
none LLVMDisposeTargetMachineOptions(LLVM_TargetMachineOptionsRef_s Options);
none LLVMTargetMachineOptionsSetCPU(LLVM_TargetMachineOptionsRef_s Options, char *CPU);
none LLVMTargetMachineOptionsSetFeatures(LLVM_TargetMachineOptionsRef_s Options, char *Features);
none LLVMTargetMachineOptionsSetABI(LLVM_TargetMachineOptionsRef_s Options, char *ABI);
none LLVMTargetMachineOptionsSetCodeGenOptLevel(LLVM_TargetMachineOptionsRef_s Options, i32 Level);
none LLVMTargetMachineOptionsSetRelocMode(LLVM_TargetMachineOptionsRef_s Options, i32 Reloc);
none LLVMTargetMachineOptionsSetCodeModel(LLVM_TargetMachineOptionsRef_s Options, i32 CodeModel);
LLVM_ContextRef_s LLVMContextCreate(none);
none LLVMContextDispose(LLVM_ContextRef_s context);
LLVM_ModuleRef_s LLVMModuleCreateWithNameInContext(char *id, LLVM_ContextRef_s C);
LLVM_TypeRef_s LLVMIntTypeInContext(LLVM_ContextRef_s c, u32 bits);
LLVM_TypeRef_s LLVMFloatTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMDoubleTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMVoidTypeInContext(LLVM_ContextRef_s c);
LLVM_TypeRef_s LLVMStructTypeInContext(LLVM_ContextRef_s c, LLVM_TypeRef_s *ElementTypes, u32 ElementCount, LLVMBool_s Packed);
LLVM_AttributeRef_s LLVMCreateEnumAttribute(LLVM_ContextRef_s c, u32 KindID, u64 Val);
char *LLVMPrintModuleToString(LLVM_ModuleRef_s M);
LLVMBool_s LLVMPrintModuleToFile(LLVM_ModuleRef_s M, char *Filename, LLVMString_s *ErrorMessage);
LLVM_ValueRef_s LLVMGetNamedFunction(LLVM_ModuleRef_s M, char *Name);
LLVM_ValueRef_s LLVMAddFunction(LLVM_ModuleRef_s M, char *name, LLVM_TypeRef_s FunctionTy);
LLVM_ValueRef_s LLVMAddGlobalInAddressSpace(LLVM_ModuleRef_s M, LLVM_TypeRef_s Ty, char *Name, u32 AddressSpace);
LLVM_ValueRef_s LLVMGetNamedGlobal(LLVM_ModuleRef_s M, char *Name);
LLVMBool_s LLVMVerifyModule(LLVM_ModuleRef_s M, i32 mode, LLVMString_s *code);
none LLVMSetDataLayout(LLVM_ModuleRef_s M, char *Data);
none LLVMSetTarget(LLVM_ModuleRef_s M, char *Target);
none LLVMAddModuleFlag(LLVM_ModuleRef_s M, i32 Behavior, char *Key, usize KeyLen, LLVM_MetadataRef_s Val);
LLVM_ErrorRef_s LLVMRunPasses(LLVM_ModuleRef_s M, char *Passes, LLVM_TargetMachineRef_s TM, LLVM_PassBuilderOptionsRef_s Options);
LLVM_ErrorRef_s LLVMRunPassesOnFunction(LLVM_ValueRef_s F, char *Passes, LLVM_TargetMachineRef_s TM, LLVM_PassBuilderOptionsRef_s Options);
LLVM_PassBuilderOptionsRef_s LLVMCreatePassBuilderOptions(none);
none LLVMDisposePassBuilderOptions(LLVM_PassBuilderOptionsRef_s Options);
none LLVMPassBuilderOptionsSetVerifyEach(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s VerifyEach);
none LLVMPassBuilderOptionsSetDebugLogging(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s DebugLogging);
none LLVMPassBuilderOptionsSetAAPipeline(LLVM_PassBuilderOptionsRef_s Options, char *AAPipeline);
none LLVMPassBuilderOptionsSetLoopInterleaving(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopInterleaving);
none LLVMPassBuilderOptionsSetLoopVectorization(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopVectorization);
none LLVMPassBuilderOptionsSetSLPVectorization(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s SLPVectorization);
none LLVMPassBuilderOptionsSetLoopUnrolling(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s LoopUnrolling);
none LLVMPassBuilderOptionsSetForgetAllSCEVInLoopUnroll(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s ForgetAllSCEVInLoopUnroll);
none LLVMPassBuilderOptionsSetLicmMssaOptCap(LLVM_PassBuilderOptionsRef_s Options, u32 LicmMssaOptCap);
none LLVMPassBuilderOptionsSetLicmMssaNoAccForPromotionCap(LLVM_PassBuilderOptionsRef_s Options, u32 LicmMssaNoAccForPromotionCap);
none LLVMPassBuilderOptionsSetCallGraphProfile(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s CallGraphProfile);
none LLVMPassBuilderOptionsSetMergeFunctions(LLVM_PassBuilderOptionsRef_s Options, LLVMBool_s MergeFunctions);
none LLVMPassBuilderOptionsSetInlinerThreshold(LLVM_PassBuilderOptionsRef_s Options, i32 Threshold);
LLVM_BasicBlockRef_s LLVMAppendBasicBlockInContext(LLVM_ContextRef_s C, LLVM_ValueRef_s FnRef, char *name);
LLVM_BasicBlockRef_s LLVMGetInsertBlock(LLVM_BuilderRef_s Builder);
LLVM_ValueRef_s LLVMGetBasicBlockParent(LLVM_BasicBlockRef_s Block);
LLVM_BasicBlockRef_s LLVMGetFirstBasicBlock(LLVM_ValueRef_s Fn);
LLVM_ValueRef_s LLVMGetLastInstruction(LLVM_BasicBlockRef_s Block);
LLVM_BuilderRef_s LLVMCreateBuilderInContext(LLVM_ContextRef_s context);
LLVM_BuilderRef_s LLVMCreateBuilder(none);
none LLVMPositionBuilder(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderBeforeDbgRecords(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block, LLVM_ValueRef_s Inst);
none LLVMPositionBuilderBefore(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderBeforeInstrAndDbgRecords(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Instr);
none LLVMPositionBuilderAtEnd(LLVM_BuilderRef_s Builder, LLVM_BasicBlockRef_s Block);
LLVM_MetadataRef_s LLVMGetCurrentDebugLocation2(LLVM_BuilderRef_s Builder);
none LLVMSetCurrentDebugLocation2(LLVM_BuilderRef_s Builder, LLVM_MetadataRef_s loc);
none LLVMSetInstDebugLocation(LLVM_BuilderRef_s Builder, LLVM_ValueRef_s Inst);
LLVM_ValueRef_s LLVMBuildRetVoid(LLVM_BuilderRef_s B);
LLVM_ValueRef_s LLVMBuildRet(LLVM_BuilderRef_s B, LLVM_ValueRef_s Value);
LLVM_ValueRef_s LLVMBuildAlloca(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, char *Name);
LLVM_ValueRef_s LLVMBuildStore(LLVM_BuilderRef_s B, LLVM_ValueRef_s Value, LLVM_ValueRef_s Ptr);
LLVM_ValueRef_s LLVMBuildInsertValue(LLVM_BuilderRef_s B, LLVM_ValueRef_s AggVal, LLVM_ValueRef_s EltVal, u32 Index, char *Name);
LLVM_ValueRef_s LLVMBuildBr(LLVM_BuilderRef_s B, LLVM_BasicBlockRef_s Dest);
LLVM_ValueRef_s LLVMBuildCondBr(LLVM_BuilderRef_s B, LLVM_ValueRef_s If, LLVM_BasicBlockRef_s Then, LLVM_BasicBlockRef_s Else);
LLVM_ValueRef_s LLVMBuildLoad2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Ptr, char *name);
LLVM_ValueRef_s LLVMBuildAdd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSub(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildMul(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildUDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildSRem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildURem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFAdd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFSub(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFMul(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFDiv(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFRem(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildICmp(LLVM_BuilderRef_s B, i32 pred, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildFCmp(LLVM_BuilderRef_s B, i32 pred, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildNot(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, char *name);
LLVM_ValueRef_s LLVMBuildOr(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildAnd(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildXor(LLVM_BuilderRef_s B, LLVM_ValueRef_s LHS, LLVM_ValueRef_s RHS, char *name);
LLVM_ValueRef_s LLVMBuildPtrToInt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Ptr, LLVM_TypeRef_s Int, char *name);
LLVM_ValueRef_s LLVMBuildIntToPtr(LLVM_BuilderRef_s B, LLVM_ValueRef_s Ptr, LLVM_TypeRef_s Int, char *name);
LLVM_ValueRef_s LLVMBuildSIToFP(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildUIToFP(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildFPToSI(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildFPToUI(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s DestTy, char *Name);
LLVM_ValueRef_s LLVMBuildCall2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Fn, LLVM_ValueRef_s *Args, u32 NumArgs, char *Name);
LLVM_ValueRef_s LLVMBuildGlobalStringPtr(LLVM_BuilderRef_s B, char *Str, char *Name);
LLVM_ValueRef_s LLVMBuildSExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildZExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildTrunc(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildStructGEP2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Pointer, u32 Idx, char *Name);
LLVM_ValueRef_s LLVMBuildGEP2(LLVM_BuilderRef_s B, LLVM_TypeRef_s Ty, LLVM_ValueRef_s Pointer, LLVM_ValueRef_s *Indices, u32 Length, char *Name);
LLVM_ValueRef_s LLVMBuildFPExt(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildFPTrunc(LLVM_BuilderRef_s B, LLVM_ValueRef_s Val, LLVM_TypeRef_s Typ, char *name);
LLVM_ValueRef_s LLVMBuildUnreachable(LLVM_BuilderRef_s B);
LLVM_ValueRef_s LLVMBuildMemCpy(LLVM_BuilderRef_s B, LLVM_ValueRef_s Dst, u32 DstAlign, LLVM_ValueRef_s Src, u32 SrcAlign, LLVM_ValueRef_s Size);
LLVM_TypeRef_s LLVMTypeOf(LLVM_ValueRef_s Val);
LLVM_ValueRef_s LLVMConstInt(LLVM_TypeRef_s IntTy, usize N, LLVMBool_s SignExtend);
LLVM_ValueRef_s LLVMConstReal(LLVM_TypeRef_s RealTy, f64 F);
LLVM_ValueRef_s LLVMConstNull(LLVM_TypeRef_s Ty);
none LLVMDumpValue(LLVM_ValueRef_s V);
LLVM_TypeRef_s LLVMGlobalGetValueType(LLVM_ValueRef_s Val);
none LLVMAddAttributeAtIndex(LLVM_ValueRef_s Val, u32 index, LLVM_AttributeRef_s Attr);
none LLVMSetAlignment(LLVM_ValueRef_s Val, u32 Bytes);
none LLVMGlobalSetMetadata(LLVM_ValueRef_s Global, u32 Kind, LLVM_MetadataRef_s MD);
LLVM_ValueRef_s LLVMIsAGlobalVariable(LLVM_ValueRef_s Val);
none LLVMSetInitializer(LLVM_ValueRef_s GlobalVar, LLVM_ValueRef_s ConstantVal);
LLVM_ValueRef_s LLVMGetInitializer(LLVM_ValueRef_s GlobalVar);
LLVM_ValueRef_s LLVMGetParam(LLVM_ValueRef_s FnRef, u32 index);
none LLVMSetValueName2(LLVM_ValueRef_s Val, char *Name, usize NameLen);
none LLVMSetValueName(LLVM_ValueRef_s Val, char *Name);
char *LLVMGetValueName2(LLVM_ValueRef_s Val, usize *Length);
char *LLVMGetValueName(LLVM_ValueRef_s Val);
u32 LLVMGetEnumAttributeKindForName(char *Name, usize SLen);
LLVM_TypeRef_s LLVMFunctionType(LLVM_TypeRef_s ReturnType, LLVM_TypeRef_s *ParamTypes, u32 ParamCount, LLVMBool_s IsVarArg);
LLVM_TypeRef_s LLVMPointerType(LLVM_TypeRef_s ElementType, u32 AddressSpace);
LLVM_TypeRef_s LLVMArrayType(LLVM_TypeRef_s ElementType, u32 size);
none LLVMGetParamTypes(LLVM_TypeRef_s FunctionTy, LLVM_TypeRef_s *Dest);
u32 LLVMCountParamTypes(LLVM_TypeRef_s FunctionTy);
LLVM_TypeRef_s LLVMGetReturnType(LLVM_TypeRef_s FunctionTy);
char *LLVMPrintTypeToString(LLVM_TypeRef_s Ty);
LLVM_ValueRef_s LLVMGetInlineAsm(LLVM_TypeRef_s Ty, char *AsmString, usize AsmStringSize, char *Constraints, usize ConstraintsSize, LLVMBool_s HasSideEffects, LLVMBool_s IsAlignStack, u32 Dialect,
                                 LLVMBool_s CanThrow);
i32 LLVMGetTypeKind(LLVM_TypeRef_s Ty);
LLVM_DIBuilderRef_s LLVMCreateDIBuilder(LLVM_ModuleRef_s M);
none LLVMDisposeDIBuilder(LLVM_DIBuilderRef_s Builder);
none LLVMDIBuilderFinalize(LLVM_DIBuilderRef_s Builder);
LLVM_MetadataRef_s LLVMDIBuilderCreateCompileUnit(LLVM_DIBuilderRef_s Builder, i32 Lang, LLVM_MetadataRef_s FileRef, char *Producer, usize ProducerLen, LLVMBool_s isOptimized, char *Flags,
                                                  usize FlagsLen, u32 RuntimeVer, char *SplitName, usize SplitNameLen, i32 Kind, u32 DWOId, LLVMBool_s SplitDebugInlining,
                                                  LLVMBool_s DebugInfoForProfiling, char *SysRoot, usize SysRootLen, char *SDK, usize SDKLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateExpression(LLVM_DIBuilderRef_s Builder, usize *Addr, usize Length);
LLVM_MetadataRef_s LLVMDIBuilderCreateFile(LLVM_DIBuilderRef_s Builder, char *Filename, usize FilenameLen, char *Directory, usize DirectoryLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateFunction(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, char *LinkageName, usize LinkageNameLen, LLVM_MetadataRef_s File,
                                               u32 LineNo, LLVM_MetadataRef_s Ty, LLVMBool_s IsLocalToUnit, LLVMBool_s IsDefinition, u32 ScopeLine, i32 Flags, LLVMBool_s IsOptimized);
LLVM_MetadataRef_s LLVMDIBuilderCreateDebugLocation(LLVM_ContextRef_s Ctx, u32 Line, u32 Col, LLVM_MetadataRef_s Scope, LLVM_MetadataRef_s InlinedAt);
LLVM_MetadataRef_s LLVMDIBuilderCreateAutoVariable(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNo, LLVM_MetadataRef_s Ty,
                                                   LLVMBool_s AlwaysPreserve, i32 Flags, u32 AlignInBits);
LLVM_MetadataRef_s LLVMDIBuilderCreateBasicType(LLVM_DIBuilderRef_s Builder, char *Name, usize NameLen, u64 SizeInBits, u32 Encoding, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreateParameterVariable(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, u32 ArgNo, LLVM_MetadataRef_s File, u32 LineNo,
                                                        LLVM_MetadataRef_s Ty, LLVMBool_s AlwaysPreserve, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreatePointerType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s PointeeTy, u64 SizeInBits, u32 AlignInBits, u32 AddressSpace, char *Name, usize NameLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateStructType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                 u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s DerivedFrom, LLVM_MetadataRef_s *Elements, u32 NumElements, u32 RunTimeLang,
                                                 LLVM_MetadataRef_s VTableHolder, char *UniqueId, usize UniqueIdLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateVariantPart(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                  u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s Discriminator, LLVM_MetadataRef_s *Elements, u32 NumElements, char *Unique, usize UniqueLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateVariantMemberType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                        u32 AlignInBits, u64 OffsetInBits, LLVM_ValueRef_s Discriminant, i32 Flags, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateMemberType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                 u32 AlignInBits, u64 OffsetInBits, i32 Flags, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateSubroutineType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s File, LLVM_MetadataRef_s *ParameterTypes, u32 NumParameterTypes, i32 Flags);
LLVM_MetadataRef_s LLVMDIBuilderCreateTypedef(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Type, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNo, LLVM_MetadataRef_s Scope,
                                              u32 AlignInBits);
LLVM_MetadataRef_s LLVMDIBuilderCreateUnionType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, LLVM_MetadataRef_s File, u32 LineNumber, u64 SizeInBits,
                                                u32 AlignInBits, i32 Flags, LLVM_MetadataRef_s *Elements, u32 NumElements, u32 RunTimeLang, char *UniqueId, usize UniqueLen);
LLVM_MetadataRef_s LLVMDIBuilderCreateArrayType(LLVM_DIBuilderRef_s Builder, u64 Size, u32 AlignInBits, LLVM_MetadataRef_s Ty, LLVM_MetadataRef_s *Subscripts, u32 NumSubscripts);
LLVM_MetadataRef_s LLVMDIBuilderCreateArtificialType(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Ty);
LLVM_MetadataRef_s LLVMDIBuilderCreateUnspecifiedType(LLVM_DIBuilderRef_s Builder, char *Name, usize NameLen);
LLVM_DbgRecordRef_s LLVMDIBuilderInsertDeclareRecordAtEnd(LLVM_DIBuilderRef_s Builder, LLVM_ValueRef_s Storage, LLVM_MetadataRef_s VarInfo, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s DebugLoc,
                                                          LLVM_BasicBlockRef_s Block);
LLVM_DbgRecordRef_s LLVMDIBuilderInsertDeclareRecordBefore(LLVM_DIBuilderRef_s Builder, LLVM_ValueRef_s Storage, LLVM_MetadataRef_s VarInfo, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s DebugLoc,
                                                           LLVM_ValueRef_s Instr);
LLVM_MetadataRef_s LLVMDIBuilderCreateGlobalVariableExpression(LLVM_DIBuilderRef_s Builder, LLVM_MetadataRef_s Scope, char *Name, usize NameLen, char *Linkage, usize LinkLen, LLVM_MetadataRef_s File,
                                                               u32 LineNo, LLVM_MetadataRef_s Ty, LLVMBool_s LocalToUnit, LLVM_MetadataRef_s Expr, LLVM_MetadataRef_s Decl, u32 AlignInBits);
none LLVMMetadataReplaceAllUsesWith(LLVM_MetadataRef_s TempTargetMetadata, LLVM_MetadataRef_s Replacement);
none LLVMSetSubprogram(LLVM_ValueRef_s Func, LLVM_MetadataRef_s SP);
LLVM_MetadataRef_s LLVMGetSubprogram(LLVM_ValueRef_s Func);
LLVM_MetadataRef_s LLVMTemporaryMDNode(LLVM_ContextRef_s Ctx, LLVM_MetadataRef_s *Data, usize NumElements);
none LLVMDisposeTemporaryMDNode(LLVM_MetadataRef_s TempNode);
LLVM_MetadataRef_s LLVMValueAsMetadata(LLVM_ValueRef_s Val);
u32 LLVMGetMDKindID(char *Name, u32 NameLen);
LLVMBool_s newLLVMBoolBrS2924(bool b);
bool equalsPS9925PS9925rB(InterpReg_s *this, InterpReg_s *other);
InterpReg_s asInterpPU9869PcrS9925(IRValue_u *this, char *err);
LLVM_ValueRef_s asLLVMPU9869PcrS1407(IRValue_u *this, char *err);
none pushPS1193U9869rN(IRValueList_s *this, IRValue_u element);
IRValue_u *atPS1193uszrPU9869(IRValueList_s *this, usize index);
LLVM_ValueRef_s getArgPS6859uszrS1407(ASMContext_s *context, usize index);
none pushPS6859PcrN(ASMContext_s *context, char *code);
none inPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint);
none outPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint);
String_s constrainPS6859U6852rS0540(ASMContext_s *context, ASMLoc_u loc);
none constrainPS6859U9995rN(ASMContext_s *context, ASMConstraint_u cons);
none constrainPS6859PcrN(ASMContext_s *context, char *code);
String_s collectPS6859rS0540(ASMContext_s *context);
char *tokenKindToStringuszrPc(usize kind);
none printPS6070rN(Token_s *this);
String_s getLocationPS6070rS0540(Token_s *this);
String_s toStringPS6070rS0540(Token_s *this);
SubStr_s getSubStrPS6070rS7720(Token_s *this);
Span_s getSpanPS6070rS8951(Token_s *this);
bool equalsPS6070PS6070rB(Token_s *this, Token_s *other);
Token_s dummyTokenuszrS6070(usize kind);
Token_s newTokenuszPS7720uszuszrS6070(usize fileID, SubStr_s *sub, usize start, usize kind);
Token_s newTokenEOFuszuszrS6070(usize fileID, usize start);
Token_s defaultTokenrS6070(none);
none push_entryPS3131U7843rN(TypeInfoTable_s *table, TypeInfo_u info);
usize index_ofPS3131PU7843rusz(TypeInfoTable_s *table, TypeInfo_u *info);
bool containsPS3131PU7843rB(TypeInfoTable_s *table, TypeInfo_u *info);
none pushPS2495uszrN(TypeInfoList_s *this, usize element);
none pushPS0131S3911rN(FieldTypeInfoList_s *this, FieldTypeInfo_s element);
none pushPS3117U0081rN(UnionVariantTypeInfoList_s *this, UnionVariantTypeInfo_u element);
SubStr_s get_namePU0081rS7720(UnionVariantTypeInfo_u *info);
bool equalsPU7843PU7843rB(TypeInfo_u *ti1, TypeInfo_u *ti2);
usize get_sizePU7843rusz(TypeInfo_u *info);
usize get_alignPU7843rusz(TypeInfo_u *info);
SubStr_s get_namePU7843rS7720(TypeInfo_u *info);
none pushPS3111AnyuszrN(ArenaBlock_s *this, Any elem, usize newCap);
Any atPS3111uszrAny(ArenaBlock_s *this, usize index);
Any lastPS3111rAny(ArenaBlock_s *this);
usize indexOfPS3111Anyrusz(ArenaBlock_s *this, Any elem);
ArenaBlock_s *allocateBlockuszuszrPS3111(usize cap, usize size);
none pushPS9153S0890rN(ParsedConfigArena_s *this, ParsedConfig_s elem);
ParsedConfig_s *atPS9153uszrPS0890(ParsedConfigArena_s *this, usize index);
ParsedConfig_s *lastPS9153rPS0890(ParsedConfigArena_s *this);
usize indexOfPS9153PS0890rusz(ParsedConfigArena_s *this, ParsedConfig_s *elem);
none pushPS9483S1892rN(ParsedFileArena_s *this, ParsedFile_s elem);
ParsedFile_s *atPS9483uszrPS1892(ParsedFileArena_s *this, usize index);
ParsedFile_s *lastPS9483rPS1892(ParsedFileArena_s *this);
usize indexOfPS9483PS1892rusz(ParsedFileArena_s *this, ParsedFile_s *elem);
none pushPS9029S1038rN(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s elem);
ParsedTopLevelItem_s *atPS9029uszrPS1038(ParsedTopLevelItemArena_s *this, usize index);
ParsedTopLevelItem_s *lastPS9029rPS1038(ParsedTopLevelItemArena_s *this);
usize indexOfPS9029PS1038rusz(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s *elem);
none pushPS7393S1882rN(ParsedModuleArena_s *this, ParsedModule_s elem);
ParsedModule_s *atPS7393uszrPS1882(ParsedModuleArena_s *this, usize index);
ParsedModule_s *lastPS7393rPS1882(ParsedModuleArena_s *this);
usize indexOfPS7393PS1882rusz(ParsedModuleArena_s *this, ParsedModule_s *elem);
none pushPS2168S5521rN(ParsedStructDeclArena_s *this, ParsedStructDecl_s elem);
ParsedStructDecl_s *atPS2168uszrPS5521(ParsedStructDeclArena_s *this, usize index);
ParsedStructDecl_s *lastPS2168rPS5521(ParsedStructDeclArena_s *this);
usize indexOfPS2168PS5521rusz(ParsedStructDeclArena_s *this, ParsedStructDecl_s *elem);
none pushPS4268S0997rN(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s elem);
ParsedUnionDecl_s *atPS4268uszrPS0997(ParsedUnionDeclArena_s *this, usize index);
ParsedUnionDecl_s *lastPS4268rPS0997(ParsedUnionDeclArena_s *this);
usize indexOfPS4268PS0997rusz(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s *elem);
none pushPS4249S3506rN(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s elem);
ParsedUnionVariant_s *atPS4249uszrPS3506(ParsedUnionVariantArena_s *this, usize index);
ParsedUnionVariant_s *lastPS4249rPS3506(ParsedUnionVariantArena_s *this);
usize indexOfPS4249PS3506rusz(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s *elem);
none pushPS4111S4904rN(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s elem);
ParsedFuncDecl_s *atPS4111uszrPS4904(ParsedFuncDeclArena_s *this, usize index);
ParsedFuncDecl_s *lastPS4111rPS4904(ParsedFuncDeclArena_s *this);
usize indexOfPS4111PS4904rusz(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s *elem);
none pushPS8646S7247rN(ParsedBlockArena_s *this, ParsedBlock_s elem);
ParsedBlock_s *atPS8646uszrPS7247(ParsedBlockArena_s *this, usize index);
ParsedBlock_s *lastPS8646rPS7247(ParsedBlockArena_s *this);
usize indexOfPS8646PS7247rusz(ParsedBlockArena_s *this, ParsedBlock_s *elem);
none pushPS8227S1100rN(ParsedStmtArena_s *this, ParsedStmt_s elem);
ParsedStmt_s *atPS8227uszrPS1100(ParsedStmtArena_s *this, usize index);
ParsedStmt_s *lastPS8227rPS1100(ParsedStmtArena_s *this);
usize indexOfPS8227PS1100rusz(ParsedStmtArena_s *this, ParsedStmt_s *elem);
none pushPS7882S2435rN(ParsedExprArena_s *this, ParsedExpr_s elem);
ParsedExpr_s *atPS7882uszrPS2435(ParsedExprArena_s *this, usize index);
ParsedExpr_s *lastPS7882rPS2435(ParsedExprArena_s *this);
usize indexOfPS7882PS2435rusz(ParsedExprArena_s *this, ParsedExpr_s *elem);
none pushPS4419S1372rN(ParsedTypeNodeArena_s *this, ParsedTypeNode_s elem);
ParsedTypeNode_s *atPS4419uszrPS1372(ParsedTypeNodeArena_s *this, usize index);
ParsedTypeNode_s *lastPS4419rPS1372(ParsedTypeNodeArena_s *this);
usize indexOfPS4419PS1372rusz(ParsedTypeNodeArena_s *this, ParsedTypeNode_s *elem);
none pushPS4174U5175rN(TypeArena_s *this, Type_u elem);
Type_u *atPS4174uszrPU5175(TypeArena_s *this, usize index);
Type_u *lastPS4174rPU5175(TypeArena_s *this);
usize indexOfPS4174PU5175rusz(TypeArena_s *this, Type_u *elem);
none pushPS8168S3633rN(DLLArena_s *this, DLL_s elem);
DLL_s *atPS8168uszrPS3633(DLLArena_s *this, usize index);
DLL_s *lastPS8168rPS3633(DLLArena_s *this);
usize indexOfPS8168PS3633rusz(DLLArena_s *this, DLL_s *elem);
none pushPS8361S1826rN(ParsedPatternArena_s *this, ParsedPattern_s elem);
ParsedPattern_s *atPS8361uszrPS1826(ParsedPatternArena_s *this, usize index);
ParsedPattern_s *lastPS8361rPS1826(ParsedPatternArena_s *this);
usize indexOfPS8361PS1826rusz(ParsedPatternArena_s *this, ParsedPattern_s *elem);
none pushPS7368S5777rN(LLVMMetadataArena_s *this, LLVMMetadata_s elem);
LLVMMetadata_s *atPS7368uszrPS5777(LLVMMetadataArena_s *this, usize index);
LLVMMetadata_s *lastPS7368rPS5777(LLVMMetadataArena_s *this);
usize indexOfPS7368PS5777rusz(LLVMMetadataArena_s *this, LLVMMetadata_s *elem);
SubStr_s BUILD_A_KEYWORDPcrS7720(char *s);
bool isKeywordPS3493PS7720rB(Lexer_s *this, SubStr_s *word);
char escapeCharSequencePS3493PS7720PS0540Puszrc(Lexer_s *this, SubStr_s *tmp, String_s *s, usize *len);
bool advancePS3493rB(Lexer_s *this);
Token_s peekPS3493rS6070(Lexer_s *this);
Token_s nextPS3493rS6070(Lexer_s *this);
Token_s __nextPS3493BrS6070(Lexer_s *this, bool peek);
Lexer_s newLexeruszS7720rS3493(usize fileID, SubStr_s content);
IRFuncList_s asListPS2612rS8040(String_IRFuncHashMap_s *this);
bool needsResizePS2612rB(String_IRFuncHashMap_s *this);
usize indexOfPS2612PS0540rusz(String_IRFuncHashMap_s *this, String_s *key);
IRFunc_s *atPS2612uszrPS7132(String_IRFuncHashMap_s *this, usize index);
none resizeIfNecessaryPS2612rN(String_IRFuncHashMap_s *this);
none addPS2612S0540S7132rN(String_IRFuncHashMap_s *this, String_s key, IRFunc_s value);
IRFunc_s *getPS2612PS0540rPS7132(String_IRFuncHashMap_s *this, String_s *key);
String_IRFuncEntry_s *getEntryPS2612PS0540rPS0516(String_IRFuncHashMap_s *this, String_s *key);
String_IRFuncEntry_s *getAtIndexPS2612uszrPS0516(String_IRFuncHashMap_s *this, usize index);
bool containsKeyPS2612PS0540rB(String_IRFuncHashMap_s *this, String_s *key);
none freeS1803rN(Function_s fn);
none pushPS5123ccccccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8);
none pushPS5123ccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4);
none pushPS5123cccrN(ByteBuffer_s *buf, char b1, char b2, char b3);
none pushPS5123ccrN(ByteBuffer_s *buf, char b1, char b2);
none pushPS5123crN(ByteBuffer_s *buf, char b1);
none pushPS5123u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2);
none pushPS5123u8u8u8u8u8u8u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2, u8 b3, u8 b4, u8 b5, u8 b6, u8 b7, u8 b8);
none pushPS5123u8rN(ByteBuffer_s *buf, u8 element);
none extendPS5123PS5123rN(ByteBuffer_s *buf, ByteBuffer_s *other);
none pushImmPS5123S8630rN(ByteBuffer_s *bytes, ImmI32_s imm);
none pushImmPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm);
none modRMPS5123u8u8S7038rN(ByteBuffer_s *bytes, u8 addr, u8 opext, GPR_s reg);
none modPrefixPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r);
none movPS5123S7038S7038rN(ByteBuffer_s *bytes, GPR_s to, GPR_s from);
none movPS5123S5949S5363rN(ByteBuffer_s *bytes, FPR_s r, ImmF32_s imm);
none movPS5123S5949S5464rN(ByteBuffer_s *bytes, FPR_s r, ImmF64_s imm);
none movPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none movPS5123S7038S8731rN(ByteBuffer_s *bytes, GPR_s r, ImmI64_s imm);
none pushPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg);
none popPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg);
none movPS5123S7038u32S8731rN(ByteBuffer_s *bytes, GPR_s r, u32 offset, ImmI64_s imm);
none addPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none subPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm);
none callPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r);
none pushPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm);
none pushPS2247S6579rN(CallStack_s *this, CallStackInfo_s element);
CallStackInfo_s *atPS2247uszrPS6579(CallStack_s *this, usize index);
CallStackInfo_s *popPS2247rPS6579(CallStack_s *this);
CallStackInfo_s *lastPS2247rPS6579(CallStack_s *this);
none dumpRegisterStackPS3154uszrN(IRInterp_s *this, usize bytes);
u8 *getGlobalPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg);
u8 *getRegStackPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg);
u8 *advanceRealStackPS3154S8951uszrPu8(IRInterp_s *this, Span_s span, usize size);
none pushArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size);
none popArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size);
InterpReg_s evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateAllocaPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetParamPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateStorePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateMovePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCondBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateBitwiseXorPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
InterpReg_s evaluateSinglePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime);
bool evaluateBlockPS3154PS7192PS7132PS5884BrB(IRInterp_s *this, IRBlockID_s *blockID, IRFunc_s *irFunc, RegValueList_s *regs, bool forcedComptime);
Function_s compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803(IRInterp_s *this, IRFunc_s *currFunc, IRFunc_s *calledFunc, IRInstr_s *instr, usize fn, RegValueList_s *regs);
none evaluateCallPS3154S8951PS7132PS5884rN(IRInterp_s *this, Span_s span, IRFunc_s *irFunc, RegValueList_s *regs);
none pushRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size);
none popRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size);
none pushCallStackPS3154S8951S0540rN(IRInterp_s *this, Span_s span, String_s name);
none popCallStackPS3154rN(IRInterp_s *this);
none dumpCallStackPS3154PS0540rN(IRInterp_s *this, String_s *loc);
IRInterp_s newIRInterpreterPS9562rS3154(IRGen_s *irGen);
bool equalsPS7469PS7469rB(LLVMBasicBlock_s *this, LLVMBasicBlock_s *other);
none guardReferencePS7469rN(LLVMBasicBlock_s *this);
LLVMValue_s getParentPS7469rS8925(LLVMBasicBlock_s *this);
bool getLastInstructionPS7469PS8925rB(LLVMBasicBlock_s *this, LLVMValue_s *out);
LLVMBasicBlock_s newLLVMBasicBlockFromRefS6239rS7469(LLVM_BasicBlockRef_s ref);
LLVMAttribute_s newLLVMAttributeFromRefS8710rS6660(LLVM_AttributeRef_s ref);
bool equalsPS8925PS8925rB(LLVMValue_s *this, LLVMValue_s *other);
none guardReferencePS8925rN(LLVMValue_s *this);
bool isStructValuePS8925rB(LLVMValue_s *this);
none dumpPS8925rN(LLVMValue_s *this);
LLVMType_s getGlobalTypePS8925rS0706(LLVMValue_s *this);
LLVMValue_s getNthParamPS8925uszrS8925(LLVMValue_s *this, usize index);
LLVMBasicBlock_s getFirstBasicBlockPS8925rS7469(LLVMValue_s *this);
LLVMType_s getTypePS8925rS0706(LLVMValue_s *this);
none setNamePS8925S7720rN(LLVMValue_s *this, SubStr_s name);
SubStr_s getNamePS8925rS7720(LLVMValue_s *this);
none setInitializerPS8925S8925rN(LLVMValue_s *this, LLVMValue_s val);
LLVMValue_s getInitializerPS8925rS8925(LLVMValue_s *this);
none addAttributePS8925u32S6660rN(LLVMValue_s *this, u32 index, LLVMAttribute_s attr);
LLVMValue_s newLLVMValueFromRefS1407rS8925(LLVM_ValueRef_s ref);
bool equalsPS0706PS0706rB(LLVMType_s *this, LLVMType_s *other);
bool isFunctionPS0706rB(LLVMType_s *this);
LLVMType_s getReturnTypePS0706rS0706(LLVMType_s *this);
bool isVoidPS0706rB(LLVMType_s *this);
bool isStructPS0706rB(LLVMType_s *this);
bool isPointerPS0706rB(LLVMType_s *this);
char *toCharsPS0706rPc(LLVMType_s *this);
LLVMType_s intoFunctionTypePS0706S4318BrS0706(LLVMType_s *this, LLVMTypeList_s params, bool varArg);
LLVMType_s intoPointerTypePS0706rS0706(LLVMType_s *this);
LLVMType_s intoArrayTypePS0706u32rS0706(LLVMType_s *this, u32 size);
LLVMValue_s constIntPS0706uszBrS8925(LLVMType_s *this, usize value, bool signExtend);
LLVMValue_s constZeroPS0706rS8925(LLVMType_s *this);
LLVMValue_s constFloatPS0706f64rS8925(LLVMType_s *this, f64 value);
LLVMValue_s getInlineAsmPS0706PS6859rS8925(LLVMType_s *this, ASMContext_s *context);
LLVMType_s newLLVMTypeFromRefS6708rS0706(LLVM_TypeRef_s ref);
LLVMPassBuilderOptions_s createPassBuilderOptionsrS4890(none);
none disposePassBuilderOptionsS4890rN(LLVMPassBuilderOptions_s opt);
none setVerifyEachS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s verify);
none setDebugLoggingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s debug);
none setAAPipelineS4890PcrN(LLVMPassBuilderOptions_s opt, char *pipeline);
none setLoopInterleavingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s interleave);
none setLoopVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize);
none setSLPVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize);
none setLoopUnrollingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s unroll);
none setForgetAllSCEVInLoopUnrollS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s forget);
none setLicmMssaOptCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap);
none setLicmMssaNoAccForPromotionCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap);
none setCallGraphProfileS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s profile);
none setMergeFunctionsS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s merge);
none setInlinerThresholdS4890i32rN(LLVMPassBuilderOptions_s opt, i32 threshold);
usize getBitSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
usize getABISizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
usize getStoreSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ);
LLVMDataLayout_s getDataLayoutPS8369rS7896(LLVMTargetData_s *this);
LLVMTargetData_s newLLVMTargetDataFromRefS6307rS8369(LLVM_TargetDataRef_s ref);
LLVMTargetMachine_s createTargetMachinePS4231PcPcPcrS7964(LLVMTarget_s *this, char *triple, char *cpu, char *features);
LLVMTargetMachine_s createTargetMachineWithOptionsS4231PcS6312rS7964(LLVMTarget_s this, char *triple, LLVMTargetMachineOptions_s options);
LLVMTarget_s newLLVMTargetFromRefS3497rS4231(LLVM_TargetRef_s ref);
none writeToFilePS7964S1718i32PcrN(LLVMTargetMachine_s *this, LLVMModule_s mod, i32 mode, char *filepath);
LLVMTargetData_s getTargetDataPS7964rS8369(LLVMTargetMachine_s *this);
LLVMTargetMachine_s newLLVMTargetMachineFromRefS5038rS7964(LLVM_TargetMachineRef_s ref);
LLVMTargetMachineOptions_s createTargetMachineOptionsrS6312(none);
none disposeTargetMachineOptionsS6312rN(LLVMTargetMachineOptions_s opt);
none setCPUS6312PcrN(LLVMTargetMachineOptions_s opt, char *cpu);
none setFeaturesS6312PcrN(LLVMTargetMachineOptions_s opt, char *features);
none setABIS6312PcrN(LLVMTargetMachineOptions_s opt, char *ABI);
none setCodeGenOptLevelS6312U5589rN(LLVMTargetMachineOptions_s opt, LLVM_CodeGenOptLevel_u level);
none setRelocModeS6312U2415rN(LLVMTargetMachineOptions_s opt, LLVM_RelocMode_u reloc);
none setCodeModelS6312U0545rN(LLVMTargetMachineOptions_s opt, LLVM_CodeModel_u model);
none printPS1718rN(LLVMModule_s *this);
none setTriplePS1718PcrN(LLVMModule_s *this, char *triple);
none setDataLayoutPS1718S7896rN(LLVMModule_s *this, LLVMDataLayout_s layout);
bool writeToFilePS1718S7720rB(LLVMModule_s *this, SubStr_s path);
bool verifyPS1718rB(LLVMModule_s *this);
LLVMValue_s addFunctionPS1718S7720S0706rS8925(LLVMModule_s *this, SubStr_s name, LLVMType_s function);
bool hasFunctionPS1718S7720rB(LLVMModule_s *this, SubStr_s name);
LLVMValue_s getFunctionPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name);
LLVMValue_s addGlobalPS1718S0706u32S7720rS8925(LLVMModule_s *this, LLVMType_s typ, u32 space, SubStr_s name);
LLVMValue_s getGlobalPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name);
bool runPassesS1718PcS7964S4890rB(LLVMModule_s this, char *passes, LLVMTargetMachine_s target, LLVMPassBuilderOptions_s options);
none addModuleFlagS1718i32S7720S8925rN(LLVMModule_s this, i32 behavior, SubStr_s flag, LLVMValue_s value);
LLVMModule_s newLLVMModuleFromRefS3816rS1718(LLVM_ModuleRef_s ref);
none guardReferencePS6343rN(LLVMBuilder_s *this);
none positionAtEndPS6343S7469rN(LLVMBuilder_s *this, LLVMBasicBlock_s block);
none positionBeforePS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s instr);
LLVMBasicBlock_s getInsertBlockPS6343rS7469(LLVMBuilder_s *this);
LLVMValue_s buildInsertValuePS6343S8925S8925u32PcrS8925(LLVMBuilder_s *this, LLVMValue_s aggregate, LLVMValue_s element, u32 offset, char *name);
LLVMValue_s buildAllocaPS6343S0706S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildStorePS6343S8925S8925rS8925(LLVMBuilder_s *this, LLVMValue_s ptr, LLVMValue_s value);
LLVMValue_s buildLoadPS6343S0706S8925S7720rS8925(LLVMBuilder_s *this, LLVMType_s pType, LLVMValue_s ptr, SubStr_s name);
none buildReturnPS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s value);
none buildReturnVoidPS6343rN(LLVMBuilder_s *this);
LLVMValue_s buildBrPS6343S7469rS8925(LLVMBuilder_s *this, LLVMBasicBlock_s dest);
LLVMValue_s buildCondBrPS6343S8925S7469S7469rS8925(LLVMBuilder_s *this, LLVMValue_s cond, LLVMBasicBlock_s tru, LLVMBasicBlock_s fals);
LLVMValue_s buildIntAddPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntSubPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntMulPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntDivPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildIntModPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name);
LLVMValue_s buildFloatAddPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatSubPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatMulPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatDivPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatModPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildIntComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildFloatComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildNotPS6343S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, SubStr_s name);
LLVMValue_s buildOrPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildAndPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildXorPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name);
LLVMValue_s buildPtrToIntPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntToPtrPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntToFloatPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name);
LLVMValue_s buildFloatToIntPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name);
LLVMValue_s buildIntSignExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntZeroExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildFloatExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildFloatTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildIntTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name);
LLVMValue_s buildCallPS6343S8925S0706S8201S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s fn, LLVMType_s fnType, LLVMValueList_s args, LLVMType_s retType, SubStr_s name);
LLVMValue_s buildGlobalStringPtrPS6343PcS7720rS8925(LLVMBuilder_s *this, char *start, SubStr_s name);
LLVMValue_s buildStructGEPPS6343S0706S8925uszS7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, usize index, SubStr_s name);
LLVMValue_s buildGEPPS6343S0706S8925S8201S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, LLVMValueList_s indices, SubStr_s name);
none buildUnreachablePS6343rN(LLVMBuilder_s *this);
LLVMValue_s buildMemcpyPS6343S8925u32S8925u32S8925rS8925(LLVMBuilder_s *this, LLVMValue_s dst, u32 dstAlign, LLVMValue_s src, u32 srcAlign, LLVMValue_s size);
LLVMBuilder_s newLLVMBuilderFromRefS3273rS6343(LLVM_BuilderRef_s ref);
none dropPS0773rN(LLVMContext_s *this);
none guardReferencePS0773rN(LLVMContext_s *this);
none initializeTargetsPS0773rN(LLVMContext_s *this);
LLVMTarget_s createTargetPS0773PcrS4231(LLVMContext_s *this, char *name);
char *createTargetTriplePS0773PcrPc(LLVMContext_s *this, char *name);
LLVMModule_s createModuleWithNamePS0773S7720rS1718(LLVMContext_s *this, SubStr_s name);
LLVMBuilder_s createBuilderPS0773rS6343(LLVMContext_s *this);
LLVMType_s createIntegerTypePS0773i64rS0706(LLVMContext_s *this, i64 bitsize);
LLVMType_s createFloatTypePS0773rS0706(LLVMContext_s *this);
LLVMType_s createDoubleTypePS0773rS0706(LLVMContext_s *this);
LLVMType_s createStructTypePS0773PS0706u32BrS0706(LLVMContext_s *this, LLVMType_s *elements, u32 count, bool packed);
LLVMType_s createVoidTypePS0773rS0706(LLVMContext_s *this);
LLVMBasicBlock_s appendBasicBlockPS0773S8925S7720rS7469(LLVMContext_s *this, LLVMValue_s fn, SubStr_s name);
LLVMAttribute_s createEnumAttributePS0773u32u64rS6660(LLVMContext_s *this, u32 id, u64 val);
LLVMContext_s newLLVMContextrS0773(none);
LLVMDIBuilder_s createDIBuilderS1718rS1476(LLVMModule_s mod);
none disposeDIBuilderS1476rN(LLVMDIBuilder_s builder);
none finalizeDIBuilderS1476rN(LLVMDIBuilder_s builder);
LLVMMetadata_s createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777(LLVMDIBuilder_s builder, i32 lang, LLVMMetadata_s file, SubStr_s producer, LLVMBool_s isOptimized,
                                                                                                     SubStr_s flags, u32 runtimeVer, SubStr_s splitName, i32 kind, u32 dwoid,
                                                                                                     LLVMBool_s splitDebugInlining, LLVMBool_s debugInfoForProfiling, SubStr_s sysRoot, SubStr_s sdk);
LLVMMetadata_s createFileS1476PcuszPcuszrS5777(LLVMDIBuilder_s builder, char *filename, usize fileLen, char *dir, usize dirLen);
LLVMMetadata_s createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, SubStr_s linkage, LLVMMetadata_s file, u32 line,
                                                                                          LLVMMetadata_s type, LLVMBool_s localToUnit, LLVMBool_s isDefinition, u32 scopeLine, i32 flags,
                                                                                          LLVMBool_s isOptimized);
LLVMMetadata_s createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, u32 arg, LLVMMetadata_s file, u32 line,
                                                                                    LLVMMetadata_s ty, LLVMBool_s alwaysPreserve, i32 flags);
LLVMMetadata_s createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, LLVMMetadata_s file, u32 line, LLVMMetadata_s ty,
                                                                               LLVMBool_s alwaysPreserve, i32 flags, u32 align);
u32 getEncodingU7375ru32(PrimType_u p);
SubStr_s getFullNameU7375rS7720(PrimType_u p);
LLVMMetadata_s createSubroutineTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
LLVMMetadata_s createDebugInfoForPrimitiveTypeS1476PU5175rS5777(LLVMDIBuilder_s builder, Type_u *type);
LLVMMetadata_s createDebugInfoForStructTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
LLVMMetadata_s createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, LLVMContext_s llvmContext);
LLVMMetadata_s createTagTypeS1476S5777PU5175uszrS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, usize line);
LLVMMetadata_s createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, usize line, i32 flags);
LLVMMetadata_s createTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type);
none setSubprogramS8925S5777rN(LLVMValue_s fn, LLVMMetadata_s sp);
LLVMMetadata_s getSubprogramS8925rS5777(LLVMValue_s fn);
LLVMMetadata_s createExpressionS1476PuszuszrS5777(LLVMDIBuilder_s diBuilder, usize *addr, usize length);
LLVMMetadata_s createDebugLocationS0773u32u32S5777rS5777(LLVMContext_s ctx, u32 line, u32 col, LLVMMetadata_s scope);
none setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder, LLVMContext_s ctx, LLVMValue_s fn, IRFunc_s *irFunc, Span_s span);
none resetCurrentDebugLocationS1476S6343rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder);
LLVMDbgRecord_s insertDeclareRecordBeforeS1476S8925S5777S5777S5777S8925rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                              LLVMValue_s instr);
LLVMDbgRecord_s insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                             LLVMBasicBlock_s block);
bool equalsPU5952PU5952rB(RegValue_u *this, RegValue_u *other);
none addInterpValuePU5952S9925rN(RegValue_u *this, InterpReg_s val);
none addLLVMValuePU5952S8925rN(RegValue_u *this, LLVMValue_s val);
InterpReg_s asInterpPU5952PcrS9925(RegValue_u *this, char *err);
LLVMValue_s asLLVMPU5952PcrS8925(RegValue_u *this, char *err);
bool isLLVMPU5952rB(RegValue_u *this);
bool isInterpPU5952rB(RegValue_u *this);
bool generateDebugInfoPS4053i32PPcrB(LLVMCodegen_s *this, i32 argc, char **argv);
bool generateExecutablePS4053S7720i32PPcrB(LLVMCodegen_s *this, SubStr_s outPath, i32 argc, char **argv);
bool generateRuntimeInitializationPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *initRuntime);
bool generateEntryPointPS4053rB(LLVMCodegen_s *this);
bool generateGlobalPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *global);
none generateLLVMFunctionHeaderPS4053PS7132rN(LLVMCodegen_s *this, IRFunc_s *irFunc);
LLVMType_s prepareReturnTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
LLVMType_s prepareParameterPS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
usize getLLVMTypeSizePS4053PS0706rusz(LLVMCodegen_s *this, LLVMType_s *typ);
bool _generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc);
bool generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc);
none generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *llvmBlocks, IRBlock_s *block, RegValueList_s *regs);
LLVMValue_s generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *blocks, IRInstr_s *instr,
                                                                        RegValueList_s *regs);
LLVMValueList_s collectValuesFromASMPS4053PS6859rS8201(LLVMCodegen_s *this, ASMContext_s *context);
LLVMType_s generateTypeFromASMPS4053PS6859rS0706(LLVMCodegen_s *this, ASMContext_s *context);
u8 *getComptimePointerPS4053PS9925rPu8(LLVMCodegen_s *this, InterpReg_s *reg);
LLVMValue_s generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925(LLVMCodegen_s *this, Type_u *typ, InterpReg_s reg);
LLVMValue_s generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925(LLVMCodegen_s *this, Type_u *typ, u8 *start);
LLVMType_s generateLLVMFunctionTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ);
LLVMType_s generateLLVMTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *type);
LLVMCodegen_s newLLVMCodegenS7720PS9562PS3154rS4053(SubStr_s name, IRGen_s *irGen, IRInterp_s *interp);
bool equalsPS6939PS6939rB(RegIndex_s *this, RegIndex_s *other);
bool equalsPS1534PS1534rB(IRReg_s *this, IRReg_s *other);
bool equalsPS7680PS7680rB(IRInstr_s *this, IRInstr_s *other);
bool isTerminatorPS7680rB(IRInstr_s *this);
none dumpPS7680rN(IRInstr_s *this);
bool equalsPS0666PS0666rB(LoopBlock_s *this, LoopBlock_s *other);
bool equalsPS9435PS9435rB(IRBlock_s *this, IRBlock_s *other);
bool isTerminatedPS9435rB(IRBlock_s *this);
none dumpPS9435rN(IRBlock_s *this);
none pushInstructionPS9435S7680rN(IRBlock_s *this, IRInstr_s instr);
none insertInstructionPS9435uszS7680rN(IRBlock_s *this, usize index, IRInstr_s instr);
bool hasAttributePS7132U4360rB(IRFunc_s *this, ParsedAttribute_u attr);
bool isExternPS7132rB(IRFunc_s *this);
IRBlockID_s appendBlockPS7132rS7192(IRFunc_s *this);
none setCurrentBlockPS7132S7192rN(IRFunc_s *this, IRBlockID_s id);
IRBlockID_s getCurrentBlockPS7132rS7192(IRFunc_s *this);
IRBlock_s *getCurrentBlockAsRefPS7132rPS9435(IRFunc_s *this);
IRBlock_s *getBlockByIDPS7132S7192rPS9435(IRFunc_s *this, IRBlockID_s id);
none pushLoopBlocksPS7132S7192S7192rN(IRFunc_s *this, IRBlockID_s before, IRBlockID_s after);
none popLoopBlocksPS7132rN(IRFunc_s *this);
ParsedFuncDecl_s *getFuncNodePS7132rPS4904(IRFunc_s *this);
none dumpInstructionsPS7132rN(IRFunc_s *this);
bool equalsPS7132PS7132rB(IRFunc_s *this, IRFunc_s *other);
usize enterScopePS7132rusz(IRFunc_s *this);
usize leaveScopePS7132rusz(IRFunc_s *this);
none startComptimePS7132rN(IRFunc_s *this);
none endComptimePS7132rN(IRFunc_s *this);
usize getRegisterSizeInBytesPS7132rusz(IRFunc_s *this);
RegIndex_s allocateRegisterPS7132PU5175rS6939(IRFunc_s *this, Type_u *typ);
IRReg_s *getRegisterPS7132S6939rPS1534(IRFunc_s *this, RegIndex_s index);
IRScopeEntry_s *getIdentifierByNamePS7132S7720rPS9676(IRFunc_s *this, SubStr_s name);
none pushInstructionPS7132S7680rN(IRFunc_s *this, IRInstr_s instr);
none buildDebugInfoParamPS7132S8951S6939uszS7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, SubStr_s name);
none buildDebugInfoAllocaPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s name);
none buildAllocaPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size);
none buildFetchGlobalPointerPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildFetchLocalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex);
none buildLoadFunctionPtrPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize funcID);
none buildLoadPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildMovePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildGetParamPS7132S8951S6939uszuszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, usize size);
none buildStorePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildCallPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s funcID, RegIndexList_s args);
none buildReturnExprPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s val);
none buildReturnEmptyPS7132S8951rN(IRFunc_s *this, Span_s span);
none buildLoadStringPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s str);
none buildLoadBoolPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize val);
none buildLoadIntegerPS7132S8951S6939PU5175uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, Type_u *t, usize val);
none buildLoadNullPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildLoadF32PS7132S8951S6939f32rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f32 val);
none buildLoadF64PS7132S8951S6939f64rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f64 val);
none buildLoadBlankPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size);
none buildLogicalNotPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildBinaryOpPS7132S8951uszS6939S6939S6939rN(IRFunc_s *this, Span_s span, usize kind, RegIndex_s dst, RegIndex_s lhs, RegIndex_s rhs);
none buildInsertValuePS7132S8951S6939uszS6939rN(IRFunc_s *this, Span_s span, RegIndex_s aggr, usize index, RegIndex_s val);
none buildUnreachablePS7132S8951rN(IRFunc_s *this, Span_s span);
none buildUnterminatedPS7132S8951rN(IRFunc_s *this, Span_s span);
none buildBrPS7132S8951S7192rN(IRFunc_s *this, Span_s span, IRBlockID_s block);
none buildCondBrPS7132S8951S6939S7192S7192rN(IRFunc_s *this, Span_s span, RegIndex_s cond, IRBlockID_s drue, IRBlockID_s falze);
bool buildBreakPS7132S8951rB(IRFunc_s *this, Span_s span);
bool buildContinuePS7132S8951rB(IRFunc_s *this, Span_s span);
none buildIntSignExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildIntZeroExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildIntTruncatePS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits);
none buildF32ToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF64ToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF32ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildF64ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildCreateArrayPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildCreateStructPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildCreateUnionPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst);
none buildPtrToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildIntToPtrPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
none buildGetFieldPtrPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, usize index);
none buildGetElementPtrPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, RegIndexList_s indices);
none buildMemcpyPS7132S8951S6939S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s src, RegIndex_s dst, RegIndex_s size);
none buildEmitAssemblyPS7132S8951S6939PU5175rN(IRFunc_s *this, Span_s span, RegIndex_s context, Type_u *fnType);
none buildIntoIRValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src);
bool equalsPS9676PS9676rB(IRScopeEntry_s *this, IRScopeEntry_s *other);
bool equalsPS7082PS7082rB(IRScope_s *this, IRScope_s *other);
none addEntryPS7082S7720S6939BrN(IRScope_s *this, SubStr_s name, RegIndex_s ptr, bool isComptime);
IRScopeEntry_s *getIdentifierByNamePS7082S7720rPS9676(IRScope_s *this, SubStr_s name);
IRScopeEntry_s *getIdentifierByNamePS9562PS7132S7720PBrPS9676(IRGen_s *this, IRFunc_s *function, SubStr_s name, bool *isGlobal);
usize getFunctionByNamePS9562PS0540rusz(IRGen_s *this, String_s *name);
usize getFunctionByMangledNamePS9562PcPcrusz(IRGen_s *this, char *name, char *imp);
bool fillLookupPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
bool _anon_26_0PS3131uszrB(TypeInfoTable_s *table, usize index);
usize _anon_26_1PS4113uszrusz(UsizeList_s *removed, usize index);
TypeInfoTable_s generateTypeInfoTablerS3131(none);
bool generateTypeInfoTablePS9562PS7132PS1892rB(IRGen_s *this, IRFunc_s *function, ParsedFile_s *project);
none _anon_26_2PS7132S8951S6939S6939uszS6939rN(IRFunc_s *function, Span_s span, RegIndex_s ptr, RegIndex_s tmp, usize byte_offset, RegIndex_s val);
RegIndex_s _anon_26_3PS9562PS7132S8951PU5175uszrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *ti, usize len);
bool generateRuntimeTypeInfoPS9562rB(IRGen_s *this);
bool generateRuntimeInitializationPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
bool generateBytecodePS9562PS1892rB(IRGen_s *this, ParsedFile_s *project);
none generateFunctionHeaderPS9562PS7132PU5175PS9803rN(IRGen_s *this, IRFunc_s *function, Type_u *retType, ParamContext_s *params);
RegIndexList_s _anon_26_4PS7132PS4904rS9911(IRFunc_s *function, ParsedFuncDecl_s *fn);
none generateFunctionBodyPS9562PS7132PS7247PS1372rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *body, ParsedTypeNode_s *retTypeNode);
none generateFunctionPS9562PS4904rN(IRGen_s *this, ParsedFuncDecl_s *funcDecl);
none generateBytecodeBlockPS9562PS7132PS7247rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *block);
none generateBytecodeStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *stmt);
none generateBytecodeMatchStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *match);
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory);
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory, bool isComptimeVariable);
none generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable);
none generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                   bool isComptimeVariable);
none generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable);
RegIndex_s generateBytecodeExprPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateTypeInfoPS9562PS7132S8951PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *type);
RegIndex_s generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnionExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprAsPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr);
RegIndex_s generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr);
RegIndex_s prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939(IRGen_s *this, Span_s span, IRFunc_s *function, RegIndex_s base, RegIndexList_s args, Type_u *retType, RegIndex_s retPtr,
                                                                           bool needsPtr);
RegIndex_s generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, usize funcID, Type_u *retType, RegIndexList_s args);
RegIndex_s generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
none addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, usize index, bool isComptime);
none addVariablePS9562PS7132S8951PS7082S7720S6939BrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, bool isComptime);
RegIndex_s generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939(IRGen_s *this, IRFunc_s *function, IdentExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr);
RegIndex_s generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type);
RegIndex_s loadLiteralPS9562PS7132S6939PS6070rS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s reg, Token_s *tkn);
RegIndex_s generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr);
RegIndex_s generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr);
RegIndex_s generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnaryExpr_u *expr, Type_u *type, bool needsPtr);
none prepareParameterPS9562PS7132uszS8951S7720PU5175BrN(IRGen_s *this, IRFunc_s *function, usize index, Span_s span, SubStr_s name, Type_u *typ, bool retValue);
RegIndex_s getRegisterForSizePS9562PS7132uszrS6939(IRGen_s *this, IRFunc_s *function, usize size);
RegIndex_s prepareArgumentPS9562PS7132S8951S6939PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, RegIndex_s value, Type_u *typ);
RegIndex_s generateBytecodeExprCallPS9562PS7132PS3328BrS6939(IRGen_s *this, IRFunc_s *function, CallExpr_s *expr, bool needsPtr);
IRGen_s newIRGeneratorPS7791rS9562(Lookup_s *lookup);
none addImportRootPS2466S7720rN(Parser_s *this, SubStr_s filePath);
String_s getImportRootAtIndexPS2466uszrS0540(Parser_s *this, usize index);
none inheritImportRootsPS2466PS2466rN(Parser_s *this, Parser_s *parent);
Token_s expectSoftIdentifierPS2466rS6070(Parser_s *this);
Token_s expectPS2466uszrS6070(Parser_s *this, usize tknKind);
bool eatPS2466uszrB(Parser_s *this, usize tknKind);
bool atPS2466uszrB(Parser_s *this, usize tknKind);
bool parsedEOFPS2466rB(Parser_s *this);
bool _anon_25_1PS2466PS1892S7720rB(Parser_s *this, ParsedFile_s *root, SubStr_s name);
none _anon_25_0PS2466PS1892BPcrN(Parser_s *this, ParsedFile_s *root, bool cond, char *name);
ParsedFile_s parseProjectPS2466S7720rS1892(Parser_s *this, SubStr_s root);
none parseFilePS2466S7720PS1892rN(Parser_s *this, SubStr_s root, ParsedFile_s *file);
bool parseAttributesPS2466PS4756BrB(Parser_s *this, ParsedAttributeList_s *attrs, bool inModule);
ParsedTopLevelItem_s *parseTopLevelItemPS2466S4756BrPS1038(Parser_s *this, ParsedAttributeList_s attributes, bool skip);
ParsedTopLevelItem_s *parseTopLevelItemPS2466S5656S4756BrPS1038(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes, bool skip);
ParsedModule_s *parseModulePS2466S5656S4756rPS1882(Parser_s *this, TLIParent_s _parent, ParsedAttributeList_s modAttr);
ParsedConfig_s *parseConfigPS2466S5656S4756rPS0890(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes);
ParsedTopLevelItem_s *parseImportPS2466BrPS1038(Parser_s *this, bool skip);
ParsedTopLevelItem_s *parseImportByNamePS2466S8951S0540BrPS1038(Parser_s *this, Span_s loc, String_s file, bool skip);
ParsedUnionDecl_s *parseUnionDeclPS2466S5656rPS0997(Parser_s *this, TLIParent_s parent);
ParsedUnionVariant_s *parseUnionVariantPS2466S5656rPS3506(Parser_s *this, TLIParent_s parent);
ParsedStructDecl_s *parseStructDeclPS2466S5656rPS5521(Parser_s *this, TLIParent_s parent);
ParsedFuncDecl_s *parseFuncDeclPS2466S5656BrPS4904(Parser_s *this, TLIParent_s parent, bool isExtern);
ParsedTypeNode_s *parseReturnTypePS2466rPS1372(Parser_s *this);
ParamContext_s parseParametersPS2466rS9803(Parser_s *this);
ParsedBlock_s *parseBlockPS2466rPS7247(Parser_s *this);
ParsedStmt_s *parseStmtPS2466rPS1100(Parser_s *this);
ParsedStmt_s *parseMatchStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedPattern_s *parsePatternPS2466rPS1826(Parser_s *this);
ParsedStmt_s *parseForStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseWhileStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseReturnStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseIfStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw);
ParsedStmt_s *parseVarDeclStmtPS2466S6070BrPS1100(Parser_s *this, Token_s kw, bool isGlobal);
ParsedTypeNode_s *parseTypeNodePS2466rPS1372(Parser_s *this);
ParsedTypeNodeList_s _anon_25_2PS2466BrS6760(Parser_s *this, bool allowedVariadic);
ParsedTypeNode_s *parseTypeNodePS2466BrPS1372(Parser_s *this, bool allowedVariadic);
ParsedExpr_s *parseExprPS2466rPS2435(Parser_s *this);
ParsedExpr_s *parseExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
ParsedExpr_s *__parseExprPS2466uszU6350rPS2435(Parser_s *this, usize precedence, Assoc_u associativity);
ParsedExpr_s *__parseExprPS2466uszU6350BrPS2435(Parser_s *this, usize precedence, Assoc_u associativity, bool struct_init_allowed);
ParsedExpr_s *parsePrimaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
ParsedExpr_s *parseSecondaryExprPS2466PS2435uszU6350BrPS2435(Parser_s *this, ParsedExpr_s *lhs, usize precedence, Assoc_u associativity, bool struct_init_allowed);
ParsedExpr_s *parseUnaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed);
bool matchesBinaryExprPS2466rB(Parser_s *this);
bool matchesUnaryExprPS2466rB(Parser_s *this);
usize getBinaryPrecedencePS2466PS6070rusz(Parser_s *this, Token_s *tkn);
Assoc_u getBinaryAssociativityPS2466PS6070rU6350(Parser_s *this, Token_s *tkn);
usize getUnaryPrecedencePS2466uszrusz(Parser_s *this, usize tknKind);
Parser_s newParserFromSourceuszS7720rS2466(usize fileID, SubStr_s src);
ModuleLookup_s *insertFilePS7791PS1892rPS0997(Lookup_s *this, ParsedFile_s *file);
FunctionLookup_s *getFunctionByGlobalIDPS7791uszrPS0677(Lookup_s *this, usize funcID);
ModuleLookup_s *getModuleByGlobalIDPS7791uszrPS0997(Lookup_s *this, usize modID);
StructLookup_s *getStructByGlobalIDPS7791uszrPS4228(Lookup_s *this, usize structID);
UnionLookup_s *getUnionByGlobalDeclPS7791PS0997rPS1592(Lookup_s *this, ParsedUnionDecl_s *decl);
TypeLookup_s getTypeLookupForTypePS7791PU5175rS6177(Lookup_s *this, Type_u *typ);
StructLookup_s *findStructByNameInFilePS7791PS7720PS7720rPS4228(Lookup_s *this, SubStr_s *file, SubStr_s *name);
UnionLookup_s *findUnionByNameInFilePS7791PS7720PS7720rPS1592(Lookup_s *this, SubStr_s *file, SubStr_s *name);
TypeLookupList_s searchAllFilesForTypeNamePS7791PS7720rS1581(Lookup_s *this, SubStr_s *name);
FunctionLookupList_s searchAllFilesForFunctionNamePS7791PS6070rS8385(Lookup_s *this, Token_s *name);
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070rS3313(Lookup_s *this, Token_s *name);
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070BrS3313(Lookup_s *this, Token_s *name, bool globalOnly);
bool equalsPS5071PS5071rB(FileLookup_s *this, FileLookup_s *other);
bool insertTLIPS0997PS1038rB(ModuleLookup_s *this, ParsedTopLevelItem_s *tli);
bool _anon_24_0PS1913PS6661PS1826PS6070rB(ScopeLookup_s *globalScope, VariableLookup_s *lookup, ParsedPattern_s *pat, Token_s *name);
bool insertVariablesPS0997PS1826PS1913BrB(ModuleLookup_s *this, ParsedPattern_s *pat, ScopeLookup_s *globalScope, bool isComptime);
bool containsDuplicateFunctionPS0997PS0677PPS0677rB(ModuleLookup_s *this, FunctionLookup_s *function, FunctionLookup_s **dupl);
bool equalsPS6218PS6218rB(ImportLookup_s *this, ImportLookup_s *other);
bool equalsPS0997PS0997rB(ModuleLookup_s *this, ModuleLookup_s *other);
FunctionLookup_s *getFunctionByGlobalIDPS0997uszrPS0677(ModuleLookup_s *this, usize funcID);
FunctionLookup_s *getFunctionByGlobalIDPS0997uszBrPS0677(ModuleLookup_s *this, usize funcID, bool checkImport);
ModuleLookup_s *getModuleByGlobalIDPS0997uszrPS0997(ModuleLookup_s *this, usize modID);
ModuleLookup_s *getModuleByGlobalIDPS0997uszBrPS0997(ModuleLookup_s *this, usize modID, bool checkImport);
StructLookup_s *getStructByGlobalIDPS0997uszrPS4228(ModuleLookup_s *this, usize structID);
StructLookup_s *getStructByGlobalIDPS0997uszBrPS4228(ModuleLookup_s *this, usize structID, bool checkImport);
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997rPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl);
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997BrPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl, bool checkImport);
u32 resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32(ModuleLookup_s *this, Token_s *name, VariableLookup_s **var, TypeLookup_s *typ, FunctionLookupList_s *fun);
bool resolveModuleByNamePS0997PS6070PPS0997rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod);
bool resolveModuleByNamePS0997PS6070PPS0997S5972rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod, MLConfig_s c);
bool resolveVariableByNamePS0997PS6070PS5541PS6661rB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var);
bool resolveVariableByNamePS0997PS6070PS5541PS6661BrB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var, bool checkImport);
StructLookupList_s resolveAllStructsWithFieldPS0997PS6070PU5175rS7392(ModuleLookup_s *this, Token_s *name, Type_u *typ);
bool resolveTypeByNamePS0997PS7720PS6177rB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ);
bool resolveTypeByNamePS0997PS7720PS6177BrB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ, bool checkImport);
FunctionLookupList_s resolveFunctionByNamePS0997PS6070rS8385(ModuleLookup_s *this, Token_s *name);
FunctionLookupList_s resolveFunctionByNamePS0997PS6070BrS8385(ModuleLookup_s *this, Token_s *name, bool checkImport);
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ);
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ, MLConfig_s config);
bool resolveUnionByNamePS0997PS6070PPS1592rB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion);
bool resolveUnionByNamePS0997PS6070PPS1592BrB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion, bool checkImport);
none addParameterPS0677uszS6070U9661rN(FunctionLookup_s *this, usize globalID, Token_s name, TCState_u typeState);
bool checkForDuplicateParamPS0677PS6070PS6661rB(FunctionLookup_s *this, Token_s *name, VariableLookup_s *dupl);
bool equalsPS0677PS0677rB(FunctionLookup_s *this, FunctionLookup_s *other);
String_s getNamePS6177rS0540(TypeLookup_s *this);
String_s getLocationPS6177rS0540(TypeLookup_s *this);
bool equalsPS6177PS6177rB(TypeLookup_s *this, TypeLookup_s *other);
bool isStructPS6177rB(TypeLookup_s *this);
bool isUnionPS6177rB(TypeLookup_s *this);
StructLookup_s *asStructPS6177rPS4228(TypeLookup_s *this);
UnionLookup_s *asUnionPS6177rPS1592(TypeLookup_s *this);
TypeLookup_s newTypeLookupuszAnyrS6177(usize kind, Any actual);
TypeLookup_s asTypeLookupPS4228rS6177(StructLookup_s *this);
bool equalsPS4228PS4228rB(StructLookup_s *this, StructLookup_s *other);
bool resolveFieldByNamePS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *out);
bool hasFieldPS4228PS7720rB(StructLookup_s *this, SubStr_s *name);
usize getIndexByNamePS4228PS6070rusz(StructLookup_s *this, Token_s *name);
bool checkForDuplicateFieldPS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *dupl);
none addFieldPS4228uszS6070U9661rN(StructLookup_s *this, usize globalID, Token_s name, TCState_u typeState);
TypeLookup_s asTypeLookupPS1592rS6177(UnionLookup_s *this);
bool equalsPS1592PS1592rB(UnionLookup_s *this, UnionLookup_s *other);
bool resolveVariantByNamePS1592PS6070PPS2365rB(UnionLookup_s *this, Token_s *name, UnionVariantLookup_s **variant);
bool checkForDuplicateVariantPS1592PS3506PPS2365rB(UnionLookup_s *this, ParsedUnionVariant_s *curr, UnionVariantLookup_s **dupl);
none addVariantPS1592PS3506U9661rN(UnionLookup_s *this, ParsedUnionVariant_s *variant, TCState_u typeState);
bool equalsPS2365PS2365rB(UnionVariantLookup_s *this, UnionVariantLookup_s *other);
bool checkForDuplicateNamePS2365PS6070PPS6070rB(UnionVariantLookup_s *this, Token_s *name, Token_s **dupl);
StructLookup_s intoStructLookupPS2365rS4228(UnionVariantLookup_s *this);
bool isParameterPS6661rB(VariableLookup_s *this);
bool equalsPS6661PS6661rB(VariableLookup_s *this, VariableLookup_s *other);
bool equalsPS1913PS1913rB(ScopeLookup_s *this, ScopeLookup_s *other);
none addVariablePS1913S6661rN(ScopeLookup_s *this, VariableLookup_s variable);
bool isKnownVariablePS1913S7720PS6070rB(ScopeLookup_s *this, SubStr_s name, Token_s *existing);
bool getVarIndexByNamePS1913S7720PuszrB(ScopeLookup_s *this, SubStr_s name, usize *index);
bool getVariableByNamePS1913S7720PS6661rB(ScopeLookup_s *this, SubStr_s name, VariableLookup_s *var);
VariableLookup_s *getVariableAtIndexPS1913uszrPS6661(ScopeLookup_s *this, usize index);
none clearPS1913rN(ScopeLookup_s *this);
bool equalsPU9661PU9661rB(TCState_u *this, TCState_u *other);
bool isInvalidPU9661rB(TCState_u *this);
bool wantsInferPU9661rB(TCState_u *this);
bool isCriticalErrorPU9661rB(TCState_u *this);
bool isErrorPU9661rB(TCState_u *this);
bool isSuccessPU9661rB(TCState_u *this);
bool isTypePU9661rB(TCState_u *this);
bool isPatternPU9661rB(TCState_u *this);
Type_u *getTypePU9661rPU5175(TCState_u *this);
usize getErrorPU9661rusz(TCState_u *this);
PatState_s getPatStatePU9661rS1259(TCState_u *this);
none enterAnonFuncPS3900rN(TypeChecker_s *this);
none leaveAnonFuncPS3900rN(TypeChecker_s *this);
none enterComptimePS3900rN(TypeChecker_s *this);
none leaveComptimePS3900rN(TypeChecker_s *this);
char *pluszPcPcrPc(usize count, char *s1, char *s2);
TCState_u reportUnknownIdentifierPS3900PS6070rU9661(TypeChecker_s *this, Token_s *name);
none reportVerboseNotePS3900S0540uszPcPcrN(TypeChecker_s *this, String_s loc, usize count, char *s1, char *s2);
TCState_u reportTypeMismatchPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *expected, Type_u *got);
TCState_u reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Type_u *lhsType, Span_s rhsSpan, Type_u *rhsType);
TCState_u reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Span_s rhsSpan);
TCState_u reportDuplicateFieldPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s fieldToken, Span_s declSpan);
TCState_u reportDuplicateParameterPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s paramToken, Span_s declSpan);
TCState_u reportUnknownFieldPS3900S6070PS4228BrU9661(TypeChecker_s *this, Token_s name, StructLookup_s *decl, bool isUnion);
TCState_u reportUnknownTypePS3900PS0997S6070S1581rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name, TypeLookupList_s alternatives);
TCState_u reportDuplicateFunctionPS3900PS0677PS0677rU9661(TypeChecker_s *this, FunctionLookup_s *f1, FunctionLookup_s *f2);
TCState_u reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661(TypeChecker_s *this, Token_s ident, Type_u *fnType, FunctionLookupList_s *functions);
TCState_u reportVariableRedeclarationPS3900S6070S6070rU9661(TypeChecker_s *this, Token_s newDecl, Token_s oldDecl);
TCState_u reportRecursiveTypePS3900PS6177PS1581rU9661(TypeChecker_s *this, TypeLookup_s *checked, TypeLookupList_s *cycle);
TCState_u reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *from, Type_u *to);
TCState_u reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *typ);
TCState_u reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661(TypeChecker_s *this, Token_s ident, VariableLookup_s *var);
TCState_u reportAnyDereferencePS3900PS2435rU9661(TypeChecker_s *this, ParsedExpr_s *expr);
TCState_u reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance);
TCState_u reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *tuple, usize index);
TCState_u reportCouldNotInferTypePS3900S8951rU9661(TypeChecker_s *this, Span_s span);
TCState_u reportMemberAccessNoOptionsPS3900S8951rU9661(TypeChecker_s *this, Span_s span);
TCState_u reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661(TypeChecker_s *this, Span_s span, StructLookupList_s *structs);
TCState_u reportFunctionCallTooManyOptionsPS3900PS3328rU9661(TypeChecker_s *this, CallExpr_s *expr);
TCState_u reportCallToNonFunctionPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *base);
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args);
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args, bool atLeast);
TCState_u reportUnknownSubmodulePS3900PS0997S6070rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name);
TCState_u reportUnknownModulePS3900S6070rU9661(TypeChecker_s *this, Token_s name);
TCState_u reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661(TypeChecker_s *this, Span_s span, Token_s name, TypeLookup_s typ);
TCState_u reportDuplicateVariantPS3900PS3506PS2365rU9661(TypeChecker_s *this, ParsedUnionVariant_s *orig, UnionVariantLookup_s *dupl);
TCState_u reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661(TypeChecker_s *this, ParsedUnionVariant_s *variant, Token_s *first, Token_s *dupl);
TCState_u reportImpossiblePatternPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
TCState_u reportNotEnoughPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
char *_anon_23_0U3836rPc(ParsedUnionVariantData_u data);
TCState_u reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661(TypeChecker_s *this, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, Span_s span, ParsedUnionVariantData_u gotVar);
TCState_u reportInvalidVariantPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
char *_anon_23_1U3836rPc(ParsedUnionVariantData_u data);
TCState_u reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type, ParsedUnionVariantData_u expVar, ParsedUnionVariantData_u gotVar);
TCState_u reportNoSuchVariantPS3900PS1592S6070rU9661(TypeChecker_s *this, UnionLookup_s *lookup, Token_s tkn);
TCState_u reportTooManyPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type);
TCState_u reportStatementInNakedFunctionPS3900PS1100rU9661(TypeChecker_s *this, ParsedStmt_s *stmt);
TCState_u reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted);
TCState_u reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted);
TCState_u reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661(TypeChecker_s *this, ParsedStmt_s *stmt, usize argCount, usize paramCount);
TCState_u reportMissingTrampolinePS3900S8951rU9661(TypeChecker_s *this, Span_s span);
none reportUnnecessaryTrampolinePS3900S8951rN(TypeChecker_s *this, Span_s span);
none emergencyPrintPS3900S8951rN(TypeChecker_s *this, Span_s where);
bool typeCheckProjectPS3900PS1892rB(TypeChecker_s *this, ParsedFile_s *project);
bool dfsPS3900PU5175PS1581PS1581rB(TypeChecker_s *this, Type_u *type, TypeLookupList_s *visited, TypeLookupList_s *finished);
bool dfsPS3900S6177PS1581PS1581rB(TypeChecker_s *this, TypeLookup_s typeLookup, TypeLookupList_s *visited, TypeLookupList_s *finished);
bool findRecursiveTypesPS3900rB(TypeChecker_s *this);
bool fillLookupPS3900rB(TypeChecker_s *this);
bool typeCheckFilesPS3900rB(TypeChecker_s *this);
TCState_u typeCheckModulePS3900uszPS5541rU9661(TypeChecker_s *this, usize modID, ScopeLookupList_s *scopes);
TCState_u typeCheckUnionDeclPS3900PS0997rU9661(TypeChecker_s *this, ParsedUnionDecl_s *onion);
TCState_u typeCheckStructDeclPS3900uszrU9661(TypeChecker_s *this, usize structID);
TCState_u typeCheckFunctionPS3900uszPS5541BrU9661(TypeChecker_s *this, usize funcID, ScopeLookupList_s *scopes, bool signatureOnly);
TCState_u typeCheckFunctionPS3900PS4904PS5541BrU9661(TypeChecker_s *this, ParsedFuncDecl_s *function, ScopeLookupList_s *scopes, bool signatureOnly);
TCState_u typeCheckBlockPS3900PS7247PS5541BrU9661(TypeChecker_s *this, ParsedBlock_s *block, ScopeLookupList_s *scopes, bool nakedFunc);
TCState_u typeCheckStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, ScopeLookupList_s *scopes);
TCState_u typeCheckMatchStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *match, ScopeLookupList_s *scopes);
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope);
TCState_u _anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, Token_s ident, ScopeLookupList_s *scopes, ScopeLookup_s *scope,
                                                               bool globalScope);
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope, bool globalScope);
TCState_u typeCheckVarDeclPS3900uszPS5541BrU9661(TypeChecker_s *this, usize varDeclID, ScopeLookupList_s *scopes, bool globalScope);
TCState_u handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661(TypeChecker_s *this, Span_s span, ParsedPattern_s *pat, ParsedExpr_s *expr, ScopeLookupList_s *scopes, bool globalScope);
TCState_u typeCheckVarDeclPS3900PS1100PS5541BrU9661(TypeChecker_s *this, ParsedStmt_s *varDecl, ScopeLookupList_s *scopes, bool globalScope);
TCState_u typeCheckExprPS3900uszPS5541rU9661(TypeChecker_s *this, usize exprID, ScopeLookupList_s *scopes);
TCState_u typeCheckExprPS3900PS2435PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedExpr_s *curr, ParsedTypeNode_s *type, ScopeLookupList_s *scopes);
TCState_u typeCheckExprUnaryPS3900PU5427PS5541rU9661(TypeChecker_s *this, UnaryExpr_u *unary, ScopeLookupList_s *scopes);
TCState_u _anon_23_3PS3900PS7823PS0643PS5541BrU9661(TypeChecker_s *this, ParsedExprList_s *args, TypeList_s *params, ScopeLookupList_s *scopes, bool variadic);
TCState_u typeCheckExprCallPS3900PS3328PS5541rU9661(TypeChecker_s *this, CallExpr_s *call, ScopeLookupList_s *scopes);
TCState_u typeCheckExprStructInitPS3900PS4761PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckIdentifierPS3900PS7464PS5541rU9661(TypeChecker_s *this, IdentExpr_s *ident, ScopeLookupList_s *scopes);
TCState_u typeCheckExprBinaryPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprLogicalPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprBitwisePS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprAssignPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes);
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes, bool isUnion);
TCState_u typeCheckExprPathAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *unionType, ScopeLookupList_s *scopes);
TCState_u typeCheckExprMemberAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u checkIfInferIsNeededPS3900uszPU9661uszPU9661PS5541rU9661(TypeChecker_s *this, usize lhsID, TCState_u *lhsState, usize rhsID, TCState_u *rhsState, ScopeLookupList_s *scopes);
TCState_u checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *lhsExpr, TCState_u *lhsState, ParsedExpr_s *rhsExpr, TCState_u *rhsState,
                                                                         ScopeLookupList_s *scopes);
TCState_u inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedPattern_s *pat, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900uszuszPS5541rU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900uszPU5175PS5541rU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes);
TCState_u inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes);
TCState_u tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoExprPS3900uszuszPS5541BrU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661(TypeChecker_s *this, Span_s span, UnaryExpr_u *unary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *binary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661(TypeChecker_s *this, IdentExpr_s *ident, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661(TypeChecker_s *this, CallExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly);
TCState_u typeCheckExprArithmeticPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckExprComparisonPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes);
TCState_u typeCheckTypeNodePS3900PS1372rU9661(TypeChecker_s *this, ParsedTypeNode_s *typeNode);
TypeChecker_s newTypeCheckerrS3900(none);
none addElementPS8905PS2435rN(ArrayContext_s *this, ParsedExpr_s *elem);
usize getElementAtIndexPS8905uszrusz(ArrayContext_s *this, usize index);
none addFieldPS7871S6070PS1372rN(StructContext_s *this, Token_s name, ParsedTypeNode_s *typ);
Token_s getFieldNameAtIndexPS7871uszrS6070(StructContext_s *this, usize index);
ParsedTypeNode_s *getFieldTypeAtIndexPS7871uszrPS1372(StructContext_s *this, usize index);
usize getFieldIndexPS7871PS7720rusz(StructContext_s *this, SubStr_s *name);
usize getFieldOffsetPS7871PS7720rusz(StructContext_s *this, SubStr_s *name);
none addFieldPS6291S6070PS2435rN(StructInitContext_s *this, Token_s name, ParsedExpr_s *expr);
Token_s getFieldNameAtIndexPS6291uszrS6070(StructInitContext_s *this, usize index);
ParsedExpr_s *getFieldExprAtIndexPS6291uszrPS2435(StructInitContext_s *this, usize index);
none addParameterPS9803S6070PS1372rN(ParamContext_s *this, Token_s name, ParsedTypeNode_s *typ);
bool hasThisPS9803rB(ParamContext_s *this);
Token_s getNameAtIndexPS9803uszrS6070(ParamContext_s *this, usize index);
ParsedTypeNode_s *getTypeAtIndexPS9803uszrPS1372(ParamContext_s *this, usize index);
usize nextMultipleOfuszuszrusz(usize a, usize b);
usize index_of_typePS3131PU5175rusz(TypeInfoTable_s *table, Type_u *type);
bool containsInvalidTypePU5175rB(Type_u *this);
String_s getMangledNamePU5175rS0540(Type_u *this);
usize getIDPU5175rusz(Type_u *this);
bool equalsPU5175PU5175rB(Type_u *this, Type_u *other);
bool _equalsPU5175PU5175BrB(Type_u *this, Type_u *other, bool allowData);
bool isUnknownPU5175rB(Type_u *this);
bool isFloatPU5175rB(Type_u *this);
bool isIntegerPU5175rB(Type_u *this);
bool isSignedIntegerPU5175rB(Type_u *this);
bool isUnsignedIntegerPU5175rB(Type_u *this);
bool isVariadicTypePU5175rB(Type_u *this);
bool isCharPU5175rB(Type_u *this);
bool isBooleanPU5175rB(Type_u *this);
bool isNonePU5175rB(Type_u *this);
bool isAnyPU5175rB(Type_u *this);
bool isDataPU5175rB(Type_u *this);
bool isPrimitivePU5175rB(Type_u *this);
bool isFunctionPU5175rB(Type_u *this);
bool isVariadicPU5175rB(Type_u *this);
bool isNoreturnPU5175rB(Type_u *this);
bool isPointerPU5175rB(Type_u *this);
bool isStructPointerPU5175rB(Type_u *this);
bool isTuplePointerPU5175rB(Type_u *this);
bool isArrayPointerPU5175rB(Type_u *this);
bool isPointerToPU5175PU5175rB(Type_u *this, Type_u *typ);
bool isModulePU5175rB(Type_u *this);
bool isStructPU5175rB(Type_u *this);
bool isUnionPU5175rB(Type_u *this);
bool isArrayPU5175rB(Type_u *this);
bool isTuplePU5175rB(Type_u *this);
bool isStructArrayPU5175rB(Type_u *this);
Type_u *getUnderlyingTypePU5175BrPU5175(Type_u *this, bool deep);
String_s toStringPU5175rS0540(Type_u *this);
usize getAlignmentInBitsPU5175rusz(Type_u *this);
usize getAlignmentInBytesPU5175rusz(Type_u *this);
usize getSizeInBitsPU5175rusz(Type_u *this);
usize getSizeInBytesPU5175rusz(Type_u *this);
Type_u *getParamPU5175uszrPU5175(Type_u *fnType, usize id);
Type_u *getReturnTypePU5175rPU5175(Type_u *fnType);
Type_u *getTupleElementPU5175uszrPU5175(Type_u *tuple, usize index);
f64 getMaxFloatValuePU5175rf64(Type_u *this);
Type_u *intoPointerPU5175rPU5175(Type_u *this);
Type_u *intoArrayTypePU5175uszrPU5175(Type_u *this, usize size);
Type_u *copyPU5175rPU5175(Type_u *this);
Type_u *wrapU5175rPU5175(Type_u t);
ParsedExpr_s *popPS7823uszrPS2435(ParsedExprList_s *this, usize index);
none pushPS0643PU5175rN(TypeList_s *this, Type_u *element);
Type_u **atPS0643uszrPPU5175(TypeList_s *this, usize index);
none pushPS7823PS2435rN(ParsedExprList_s *this, ParsedExpr_s *element);
ParsedExpr_s **atPS7823uszrPPS2435(ParsedExprList_s *this, usize index);
none pushPS3288PS1100rN(ParsedStmtList_s *this, ParsedStmt_s *element);
ParsedStmt_s **atPS3288uszrPPS1100(ParsedStmtList_s *this, usize index);
none pushPS1982PS1826rN(ParsedPatternList_s *this, ParsedPattern_s *element);
ParsedPattern_s **atPS1982uszrPPS1826(ParsedPatternList_s *this, usize index);
none pushPS4601S2365rN(UnionVariantLookupList_s *this, UnionVariantLookup_s element);
UnionVariantLookup_s *atPS4601uszrPS2365(UnionVariantLookupList_s *this, usize index);
bool containsPS4601PS2365rB(UnionVariantLookupList_s *this, UnionVariantLookup_s *element);
none pushPS4836S1592rN(UnionLookupList_s *this, UnionLookup_s element);
UnionLookup_s *popPS4836rPS1592(UnionLookupList_s *this);
UnionLookup_s *atPS4836uszrPS1592(UnionLookupList_s *this, usize index);
bool containsPS4836PS1592rB(UnionLookupList_s *this, UnionLookup_s *element);
UnionLookup_s *lastPS4836rPS1592(UnionLookupList_s *this);
none pushPS0030PS3506rN(ParsedUnionVariantList_s *this, ParsedUnionVariant_s *element);
ParsedUnionVariant_s **atPS0030uszrPPS3506(ParsedUnionVariantList_s *this, usize index);
none pushPS6760PS1372rN(ParsedTypeNodeList_s *this, ParsedTypeNode_s *element);
ParsedTypeNode_s **atPS6760uszrPPS1372(ParsedTypeNodeList_s *this, usize index);
none pushPS9938S6070rN(TokenList_s *this, Token_s element);
Token_s *atPS9938uszrPS6070(TokenList_s *this, usize index);
none pushPS1575U7467rN(ConfigList_s *this, Config_u element);
none pushPS5121S0997rN(ModuleLookupList_s *this, ModuleLookup_s element);
bool containsPS5121PS0997rB(ModuleLookupList_s *this, ModuleLookup_s *element);
ModuleLookup_s *atPS5121uszrPS0997(ModuleLookupList_s *this, usize index);
Config_u *atPS1575uszrPU7467(ConfigList_s *this, usize index);
ModuleLookup_s *lastPS5121rPS0997(ModuleLookupList_s *this);
none initBlankPS4756uszrN(ParsedAttributeList_s *this, usize newCap);
none pushPS4756U4360rN(ParsedAttributeList_s *this, ParsedAttribute_u element);
ParsedAttribute_u *popPS4756rPU4360(ParsedAttributeList_s *this);
ParsedAttribute_u *atPS4756uszrPU4360(ParsedAttributeList_s *this, usize index);
bool containsPS4756PU4360rB(ParsedAttributeList_s *this, ParsedAttribute_u *element);
ParsedAttribute_u *lastPS4756rPU4360(ParsedAttributeList_s *this);
none extendPS4756PS4756rN(ParsedAttributeList_s *this, ParsedAttributeList_s *other);
none dropPS4756rN(ParsedAttributeList_s *this);
none clearPS4756rN(ParsedAttributeList_s *this);
none initBlankPS8385uszrN(FunctionLookupList_s *this, usize newCap);
none pushPS8385S0677rN(FunctionLookupList_s *this, FunctionLookup_s element);
FunctionLookup_s *popPS8385rPS0677(FunctionLookupList_s *this);
FunctionLookup_s *atPS8385uszrPS0677(FunctionLookupList_s *this, usize index);
bool containsPS8385PS0677rB(FunctionLookupList_s *this, FunctionLookup_s *element);
FunctionLookup_s *lastPS8385rPS0677(FunctionLookupList_s *this);
none extendPS8385PS8385rN(FunctionLookupList_s *this, FunctionLookupList_s *other);
none dropPS8385rN(FunctionLookupList_s *this);
none clearPS8385rN(FunctionLookupList_s *this);
none initBlankPS7392uszrN(StructLookupList_s *this, usize newCap);
none pushPS7392S4228rN(StructLookupList_s *this, StructLookup_s element);
StructLookup_s *popPS7392rPS4228(StructLookupList_s *this);
StructLookup_s *atPS7392uszrPS4228(StructLookupList_s *this, usize index);
bool containsPS7392PS4228rB(StructLookupList_s *this, StructLookup_s *element);
StructLookup_s *lastPS7392rPS4228(StructLookupList_s *this);
none extendPS7392PS7392rN(StructLookupList_s *this, StructLookupList_s *other);
none dropPS7392rN(StructLookupList_s *this);
none clearPS7392rN(StructLookupList_s *this);
none initBlankPS5541uszrN(ScopeLookupList_s *this, usize newCap);
none pushPS5541S1913rN(ScopeLookupList_s *this, ScopeLookup_s element);
ScopeLookup_s *popPS5541rPS1913(ScopeLookupList_s *this);
ScopeLookup_s *atPS5541uszrPS1913(ScopeLookupList_s *this, usize index);
bool containsPS5541PS1913rB(ScopeLookupList_s *this, ScopeLookup_s *element);
ScopeLookup_s *lastPS5541rPS1913(ScopeLookupList_s *this);
none extendPS5541PS5541rN(ScopeLookupList_s *this, ScopeLookupList_s *other);
none dropPS5541rN(ScopeLookupList_s *this);
none clearPS5541rN(ScopeLookupList_s *this);
none initBlankPS1581uszrN(TypeLookupList_s *this, usize newCap);
none pushPS1581S6177rN(TypeLookupList_s *this, TypeLookup_s element);
TypeLookup_s *popPS1581rPS6177(TypeLookupList_s *this);
TypeLookup_s *atPS1581uszrPS6177(TypeLookupList_s *this, usize index);
bool containsPS1581PS6177rB(TypeLookupList_s *this, TypeLookup_s *element);
TypeLookup_s *lastPS1581rPS6177(TypeLookupList_s *this);
none extendPS1581PS1581rN(TypeLookupList_s *this, TypeLookupList_s *other);
none dropPS1581rN(TypeLookupList_s *this);
none clearPS1581rN(TypeLookupList_s *this);
none initBlankPS3313uszrN(VariableLookupList_s *this, usize newCap);
none pushPS3313S6661rN(VariableLookupList_s *this, VariableLookup_s element);
VariableLookup_s *popPS3313rPS6661(VariableLookupList_s *this);
VariableLookup_s *atPS3313uszrPS6661(VariableLookupList_s *this, usize index);
bool containsPS3313PS6661rB(VariableLookupList_s *this, VariableLookup_s *element);
VariableLookup_s *lastPS3313rPS6661(VariableLookupList_s *this);
none extendPS3313PS3313rN(VariableLookupList_s *this, VariableLookupList_s *other);
none dropPS3313rN(VariableLookupList_s *this);
none clearPS3313rN(VariableLookupList_s *this);
none initBlankPS3606uszrN(ImportLookupList_s *this, usize newCap);
none pushPS3606S6218rN(ImportLookupList_s *this, ImportLookup_s element);
ImportLookup_s *popPS3606rPS6218(ImportLookupList_s *this);
ImportLookup_s *atPS3606uszrPS6218(ImportLookupList_s *this, usize index);
bool containsPS3606PS6218rB(ImportLookupList_s *this, ImportLookup_s *element);
ImportLookup_s *lastPS3606rPS6218(ImportLookupList_s *this);
none extendPS3606PS3606rN(ImportLookupList_s *this, ImportLookupList_s *other);
none dropPS3606rN(ImportLookupList_s *this);
none clearPS3606rN(ImportLookupList_s *this);
none initBlankPS9625uszrN(TCStateList_s *this, usize newCap);
none pushPS9625U9661rN(TCStateList_s *this, TCState_u element);
TCState_u *popPS9625rPU9661(TCStateList_s *this);
TCState_u *atPS9625uszrPU9661(TCStateList_s *this, usize index);
bool containsPS9625PU9661rB(TCStateList_s *this, TCState_u *element);
TCState_u *lastPS9625rPU9661(TCStateList_s *this);
none extendPS9625PS9625rN(TCStateList_s *this, TCStateList_s *other);
none dropPS9625rN(TCStateList_s *this);
none clearPS9625rN(TCStateList_s *this);
none initBlankPS9911uszrN(RegIndexList_s *this, usize newCap);
none pushPS9911S6939rN(RegIndexList_s *this, RegIndex_s element);
RegIndex_s *popPS9911rPS6939(RegIndexList_s *this);
RegIndex_s *atPS9911uszrPS6939(RegIndexList_s *this, usize index);
bool containsPS9911PS6939rB(RegIndexList_s *this, RegIndex_s *element);
RegIndex_s *lastPS9911rPS6939(RegIndexList_s *this);
none extendPS9911PS9911rN(RegIndexList_s *this, RegIndexList_s *other);
none dropPS9911rN(RegIndexList_s *this);
none clearPS9911rN(RegIndexList_s *this);
none initBlankPS0124uszrN(IRInstrList_s *this, usize newCap);
none pushPS0124S7680rN(IRInstrList_s *this, IRInstr_s element);
IRInstr_s *popPS0124rPS7680(IRInstrList_s *this);
IRInstr_s *atPS0124uszrPS7680(IRInstrList_s *this, usize index);
bool containsPS0124PS7680rB(IRInstrList_s *this, IRInstr_s *element);
IRInstr_s *lastPS0124rPS7680(IRInstrList_s *this);
none extendPS0124PS0124rN(IRInstrList_s *this, IRInstrList_s *other);
none dropPS0124rN(IRInstrList_s *this);
none clearPS0124rN(IRInstrList_s *this);
none initBlankPS9366uszrN(IRScopeList_s *this, usize newCap);
none pushPS9366S7082rN(IRScopeList_s *this, IRScope_s element);
IRScope_s *popPS9366rPS7082(IRScopeList_s *this);
IRScope_s *atPS9366uszrPS7082(IRScopeList_s *this, usize index);
bool containsPS9366PS7082rB(IRScopeList_s *this, IRScope_s *element);
IRScope_s *lastPS9366rPS7082(IRScopeList_s *this);
none extendPS9366PS9366rN(IRScopeList_s *this, IRScopeList_s *other);
none dropPS9366rN(IRScopeList_s *this);
none clearPS9366rN(IRScopeList_s *this);
none initBlankPS2282uszrN(IRRegList_s *this, usize newCap);
none pushPS2282S1534rN(IRRegList_s *this, IRReg_s element);
IRReg_s *popPS2282rPS1534(IRRegList_s *this);
IRReg_s *atPS2282uszrPS1534(IRRegList_s *this, usize index);
bool containsPS2282PS1534rB(IRRegList_s *this, IRReg_s *element);
IRReg_s *lastPS2282rPS1534(IRRegList_s *this);
none extendPS2282PS2282rN(IRRegList_s *this, IRRegList_s *other);
none dropPS2282rN(IRRegList_s *this);
none clearPS2282rN(IRRegList_s *this);
none initBlankPS1479uszrN(IRBlockList_s *this, usize newCap);
none pushPS1479S9435rN(IRBlockList_s *this, IRBlock_s element);
IRBlock_s *popPS1479rPS9435(IRBlockList_s *this);
IRBlock_s *atPS1479uszrPS9435(IRBlockList_s *this, usize index);
bool containsPS1479PS9435rB(IRBlockList_s *this, IRBlock_s *element);
IRBlock_s *lastPS1479rPS9435(IRBlockList_s *this);
none extendPS1479PS1479rN(IRBlockList_s *this, IRBlockList_s *other);
none dropPS1479rN(IRBlockList_s *this);
none clearPS1479rN(IRBlockList_s *this);
none initBlankPS6662uszrN(LoopBlockList_s *this, usize newCap);
none pushPS6662S0666rN(LoopBlockList_s *this, LoopBlock_s element);
LoopBlock_s *popPS6662rPS0666(LoopBlockList_s *this);
LoopBlock_s *atPS6662uszrPS0666(LoopBlockList_s *this, usize index);
bool containsPS6662PS0666rB(LoopBlockList_s *this, LoopBlock_s *element);
LoopBlock_s *lastPS6662rPS0666(LoopBlockList_s *this);
none extendPS6662PS6662rN(LoopBlockList_s *this, LoopBlockList_s *other);
none dropPS6662rN(LoopBlockList_s *this);
none clearPS6662rN(LoopBlockList_s *this);
none initBlankPS5960uszrN(IRScopeEntryList_s *this, usize newCap);
none pushPS5960S9676rN(IRScopeEntryList_s *this, IRScopeEntry_s element);
IRScopeEntry_s *popPS5960rPS9676(IRScopeEntryList_s *this);
IRScopeEntry_s *atPS5960uszrPS9676(IRScopeEntryList_s *this, usize index);
bool containsPS5960PS9676rB(IRScopeEntryList_s *this, IRScopeEntry_s *element);
IRScopeEntry_s *lastPS5960rPS9676(IRScopeEntryList_s *this);
none extendPS5960PS5960rN(IRScopeEntryList_s *this, IRScopeEntryList_s *other);
none dropPS5960rN(IRScopeEntryList_s *this);
none clearPS5960rN(IRScopeEntryList_s *this);
none initBlankPS8040uszrN(IRFuncList_s *this, usize newCap);
none pushPS8040S7132rN(IRFuncList_s *this, IRFunc_s element);
IRFunc_s *popPS8040rPS7132(IRFuncList_s *this);
IRFunc_s *atPS8040uszrPS7132(IRFuncList_s *this, usize index);
bool containsPS8040PS7132rB(IRFuncList_s *this, IRFunc_s *element);
IRFunc_s *lastPS8040rPS7132(IRFuncList_s *this);
none extendPS8040PS8040rN(IRFuncList_s *this, IRFuncList_s *other);
none dropPS8040rN(IRFuncList_s *this);
none clearPS8040rN(IRFuncList_s *this);
none initBlankPS4318uszrN(LLVMTypeList_s *this, usize newCap);
none pushPS4318S0706rN(LLVMTypeList_s *this, LLVMType_s element);
LLVMType_s *popPS4318rPS0706(LLVMTypeList_s *this);
LLVMType_s *atPS4318uszrPS0706(LLVMTypeList_s *this, usize index);
bool containsPS4318PS0706rB(LLVMTypeList_s *this, LLVMType_s *element);
LLVMType_s *lastPS4318rPS0706(LLVMTypeList_s *this);
none extendPS4318PS4318rN(LLVMTypeList_s *this, LLVMTypeList_s *other);
none dropPS4318rN(LLVMTypeList_s *this);
none clearPS4318rN(LLVMTypeList_s *this);
none initBlankPS5884uszrN(RegValueList_s *this, usize newCap);
none pushPS5884U5952rN(RegValueList_s *this, RegValue_u element);
RegValue_u *popPS5884rPU5952(RegValueList_s *this);
RegValue_u *atPS5884uszrPU5952(RegValueList_s *this, usize index);
bool containsPS5884PU5952rB(RegValueList_s *this, RegValue_u *element);
RegValue_u *lastPS5884rPU5952(RegValueList_s *this);
none extendPS5884PS5884rN(RegValueList_s *this, RegValueList_s *other);
none dropPS5884rN(RegValueList_s *this);
none clearPS5884rN(RegValueList_s *this);
none initBlankPS0409uszrN(LLVMBasicBlockList_s *this, usize newCap);
none pushPS0409S7469rN(LLVMBasicBlockList_s *this, LLVMBasicBlock_s element);
LLVMBasicBlock_s *popPS0409rPS7469(LLVMBasicBlockList_s *this);
LLVMBasicBlock_s *atPS0409uszrPS7469(LLVMBasicBlockList_s *this, usize index);
bool containsPS0409PS7469rB(LLVMBasicBlockList_s *this, LLVMBasicBlock_s *element);
LLVMBasicBlock_s *lastPS0409rPS7469(LLVMBasicBlockList_s *this);
none extendPS0409PS0409rN(LLVMBasicBlockList_s *this, LLVMBasicBlockList_s *other);
none dropPS0409rN(LLVMBasicBlockList_s *this);
none clearPS0409rN(LLVMBasicBlockList_s *this);
none initBlankPS8201uszrN(LLVMValueList_s *this, usize newCap);
none pushPS8201S8925rN(LLVMValueList_s *this, LLVMValue_s element);
LLVMValue_s *popPS8201rPS8925(LLVMValueList_s *this);
LLVMValue_s *atPS8201uszrPS8925(LLVMValueList_s *this, usize index);
bool containsPS8201PS8925rB(LLVMValueList_s *this, LLVMValue_s *element);
LLVMValue_s *lastPS8201rPS8925(LLVMValueList_s *this);
none extendPS8201PS8201rN(LLVMValueList_s *this, LLVMValueList_s *other);
none dropPS8201rN(LLVMValueList_s *this);
none clearPS8201rN(LLVMValueList_s *this);
none initBlankPS4113uszrN(UsizeList_s *this, usize newCap);
none pushPS4113uszrN(UsizeList_s *this, usize element);
usize *atPS4113uszrPusz(UsizeList_s *this, usize index);
ImportLookup_s *getPS3606PS6218rPS6218(ImportLookupList_s *this, ImportLookup_s *val);
StructLookup_s *getPS7392PS4228rPS4228(StructLookupList_s *this, StructLookup_s *val);
UnionLookup_s *getPS4836PS1592rPS1592(UnionLookupList_s *this, UnionLookup_s *val);
ModuleLookup_s *getPS5121PS0997rPS0997(ModuleLookupList_s *this, ModuleLookup_s *val);
none toggleIgnoringNodesrN(none);
String_s mangleVariableNameBuszPS6070rS0540(bool global, usize fileID, Token_s *name);
String_s mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540(TLIParent_s parent, Token_s *name, ParamContext_s *params, ParsedTypeNode_s *retType, bool isComptime, ParsedAttributeList_s *attrs);
ParsedFile_s *getFileByFileNameS7720rPS1892(SubStr_s name);
bool getFileByFilePathS7720PuszrB(SubStr_s path, usize *fileID);
bool equalsPU4360PU4360rB(ParsedAttribute_u *this, ParsedAttribute_u *other);
Config_u newConfigS6070S6070rU7467(Token_s t, Token_s value);
ParsedConfig_s *newParsedConfigS8951S1575rPS0890(Span_s span, ConfigList_s cfgs);
usize getIDPS0890rusz(ParsedConfig_s *this);
ParsedTopLevelItem_s *asTLIPS0890rPS1038(ParsedConfig_s *this);
usize getIDPS1892rusz(ParsedFile_s *this);
none getLineAndColumnFromSpanPS1892PS8951PuszPuszrN(ParsedFile_s *this, Span_s *span, usize *line, usize *column);
ParsedFile_s *newParsedFileS7720S7720rPS1892(SubStr_s origin, SubStr_s src);
bool equalsPS5656PS5656rB(TLIParent_s *this, TLIParent_s *other);
ParsedStructDecl_s *asStructPS1038rPS5521(ParsedTopLevelItem_s *this);
ParsedUnionDecl_s *asUnionPS1038rPS0997(ParsedTopLevelItem_s *this);
usize getIDPS1038rusz(ParsedTopLevelItem_s *this);
ParsedTopLevelItem_s *newParsedTopLevelItemS8951uszuszrPS1038(Span_s span, usize kind, usize nodeID);
DLL_s *newDLLS0540S9457rPS3633(String_s path, Handle_s handle);
DLL_s *dllNotFoundrPS3633(none);
DLL_s *dllNoSuchFunctionrPS3633(none);
bool isNullPS3633rB(DLL_s *dll);
usize getIDPS3633rusz(DLL_s *this);
bool equalsPS1882PS1882rB(ParsedModule_s *this, ParsedModule_s *other);
UsizeList_s getConfigsPS1882rS4113(ParsedModule_s *this);
usize getIDPS1882rusz(ParsedModule_s *this);
ParsedTopLevelItem_s *asTLIPS1882rPS1038(ParsedModule_s *this);
ParsedFile_s *getParentFilePS1882rPS1892(ParsedModule_s *this);
String_s getFullNamePS1882rS0540(ParsedModule_s *this);
ParsedModule_s *newParsedModuleS5656S8951S6070S4113rPS1882(TLIParent_s parent, Span_s span, Token_s name, UsizeList_s tlis);
usize getIDPS5521rusz(ParsedStructDecl_s *this);
ParsedTopLevelItem_s *asTLIPS5521rPS1038(ParsedStructDecl_s *this);
usize getFieldIndexPS5521PS7720rusz(ParsedStructDecl_s *this, SubStr_s *name);
usize getFieldOffsetPS5521PS7720Brusz(ParsedStructDecl_s *this, SubStr_s *name, bool inBits);
none getFieldOffsetAndSizePS5521uszPuszPuszBrN(ParsedStructDecl_s *this, usize index, usize *offset, usize *size, bool inBits);
ParsedFile_s *getParentFilePS5521rPS1892(ParsedStructDecl_s *this);
ParsedModule_s *getParentModulePS5521rPS1882(ParsedStructDecl_s *this);
String_s getFullNamePS5521PcrS0540(ParsedStructDecl_s *this, char *split);
String_s getFullNamePS5521rS0540(ParsedStructDecl_s *this);
ParsedStructDecl_s *newParsedStructDeclS5656S8951S6070rPS5521(TLIParent_s parent, Span_s span, Token_s name);
usize getAlignmentInBytesPS0997rusz(ParsedUnionDecl_s *this);
usize getSizeInBytesPS0997rusz(ParsedUnionDecl_s *this);
usize getIDPS0997rusz(ParsedUnionDecl_s *this);
ParsedTopLevelItem_s *asTLIPS0997rPS1038(ParsedUnionDecl_s *this);
bool resolveVariantByNamePS0997PS6070PPS3506rB(ParsedUnionDecl_s *this, Token_s *name, ParsedUnionVariant_s **out);
usize getVariantTagPS0997PS3506rusz(ParsedUnionDecl_s *this, ParsedUnionVariant_s *variant);
ParsedFile_s *getParentFilePS0997rPS1892(ParsedUnionDecl_s *this);
String_s getFullNamePS0997PcrS0540(ParsedUnionDecl_s *this, char *split);
String_s getFullNamePS0997rS0540(ParsedUnionDecl_s *this);
ParsedUnionDecl_s *newParsedUnionDeclS5656S8951S6070rPS0997(TLIParent_s parent, Span_s span, Token_s name);
usize getIDPS3506rusz(ParsedUnionVariant_s *this);
tuple_1044 get_fieldsPS3506rT_BPS6760(ParsedUnionVariant_s *this);
Type_u *toTypePS3506rPU5175(ParsedUnionVariant_s *this);
usize getFieldIndexPS3506PS7720rusz(ParsedUnionVariant_s *this, SubStr_s *name);
none getFieldOffsetAndSizePS3506uszPuszPuszBrN(ParsedUnionVariant_s *this, usize index, usize *offset, usize *size, bool inBits);
none addFieldPS3506PS1372rN(ParsedUnionVariant_s *this, ParsedTypeNode_s *field);
Type_u *getTypeAtIndexPS3506uszrPU5175(ParsedUnionVariant_s *this, usize index);
none addNamedFieldPS3506S6070PS1372rN(ParsedUnionVariant_s *this, Token_s name, ParsedTypeNode_s *typ);
bool checkForDuplicateNamePS3506PS6070PPS6070rB(ParsedUnionVariant_s *this, Token_s *name, Token_s **dupl);
ParsedUnionVariant_s *newParsedUnionVariantS5656S8951S6070U3836rPS3506(TLIParent_s parent, Span_s span, Token_s name, ParsedUnionVariantData_u data);
bool hasAttributePS4904U4360rB(ParsedFuncDecl_s *this, ParsedAttribute_u attr);
usize getIDPS4904rusz(ParsedFuncDecl_s *this);
bool isExternPS4904rB(ParsedFuncDecl_s *this);
ParsedFile_s *getParentFilePS4904rPS1892(ParsedFuncDecl_s *this);
ParsedModule_s *getParentModulePS4904rPS1882(ParsedFuncDecl_s *this);
String_s getMangledNamePS4904rS0540(ParsedFuncDecl_s *this);
ParsedTopLevelItem_s *asTLIPS4904rPS1038(ParsedFuncDecl_s *this);
ParsedFuncDecl_s *newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904(TLIParent_s parent, Span_s span, Token_s name, ParamContext_s params, ParsedTypeNode_s *retType, ParsedBlock_s *body);
usize getIDPS7247rusz(ParsedBlock_s *this);
none addStmtPS7247PS1100rN(ParsedBlock_s *this, ParsedStmt_s *stmt);
ParsedStmt_s *getStmtAtIndexPS7247uszrPS1100(ParsedBlock_s *this, usize index);
ParsedStmt_s *into_stmtPS7247rPS1100(ParsedBlock_s *this);
ParsedBlock_s *newParsedBlockrPS7247(none);
usize getIDPS1100rusz(ParsedStmt_s *this);
ParsedTopLevelItem_s *asTLIPS1100rPS1038(ParsedStmt_s *this);
ParsedBlock_s *into_blockPS1100rPS7247(ParsedStmt_s *this);
ParsedStmt_s *newParsedStmtS8951U4263rPS1100(Span_s span, StmtData_u data);
SubStr_s BUILD_A_TYPEPcrS7720(char *s);
usize getBuiltinTypeKindS6070rusz(Token_s name);
usize getIDPS1372rusz(ParsedTypeNode_s *this);
ParsedTypeNode_s *newParsedTypeNodeS8951uszrPS1372(Span_s span, usize kind);
ParsedTypeNode_s *newBuiltinTypeDeclS8951uszrPS1372(Span_s span, usize kind);
UnaryExpr_u fromTknuszPS2435rU5427(usize kind, ParsedExpr_s *expr);
none extractOperandPU5427PPS2435rN(UnaryExpr_u *expr, ParsedExpr_s **lhs);
char *binOpAsStrPU0121rPc(BinaryExpr_u *expr);
none extractOperandsPU0121PPS2435PPS2435rN(BinaryExpr_u *expr, ParsedExpr_s **lhs, ParsedExpr_s **rhs);
BinaryExpr_u fromTknuszPS2435PS2435rU0121(usize kind, ParsedExpr_s *lhs, ParsedExpr_s *rhs);
bool isArithmeticPU0121rB(BinaryExpr_u *this);
bool isComparisonPU0121rB(BinaryExpr_u *this);
bool isLogicalPU0121rB(BinaryExpr_u *this);
bool isBitwisePU0121rB(BinaryExpr_u *this);
bool isAssignmentPU0121rB(BinaryExpr_u *this);
usize getIDPS2435rusz(ParsedExpr_s *this);
ParsedExpr_s *wrapS2435rPS2435(ParsedExpr_s this);
ParsedExpr_s *newParsedExprS8951U8798rPS2435(Span_s span, ExprData_u data);
usize intoPointerPS2435rusz(ParsedExpr_s *this);
bool isLValuePS2435rB(ParsedExpr_s *this);
bool isBlankPS2435rB(ParsedExpr_s *this);
bool isIdentifierPS2435rB(ParsedExpr_s *this);
bool isLiteralPS2435rB(ParsedExpr_s *this);
bool isUnaryPS2435rB(ParsedExpr_s *this);
bool isCallPS2435rB(ParsedExpr_s *this);
bool isAssignmentPS2435rB(ParsedExpr_s *this);
usize getIDPS1826rusz(ParsedPattern_s *this);
ParsedPattern_s *newParsedPatternS8951U9267rPS1826(Span_s span, Pattern_u pat);
String_s toStringPS1826rS0540(ParsedPattern_s *this);
bool equalsPS8951PS8951rB(Span_s *this, Span_s *other);
none printPS8951rN(Span_s *this);
String_s toStringPS8951rS0540(Span_s *this);
bool comesBeforePS8951PS8951rB(Span_s *this, Span_s *other);
Span_s newSpanuszuszuszrS8951(usize file, usize start, usize end);
Span_s newSpanBetweenPS8951PS8951rS8951(Span_s *start, Span_s *end);
Span_s defaultSpanrS8951(none);
bool isMandatoryPS7407rB(Flag_s *flag);
String_s toStringPS7407rS0540(Flag_s *this);
bool *addHelpFlagPS7660rPB(FlagParser_s *this);
Flag_s *addDefaultFlagPS7660PcPcPcuszU0121rPS7407(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode, FlagData_u data);
String_s *addStringFlagPS7660PcuszrPS0540(FlagParser_s *this, char *descr, usize mode);
String_s *addStringFlagPS7660PcPcPcrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr);
String_s *addStringFlagPS7660PcPcPcuszrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode);
bool *addBoolFlagPS7660PcPcrPB(FlagParser_s *this, char *flag, char *descr);
bool *addBoolFlagPS7660PcPcPcrPB(FlagParser_s *this, char *short_, char *long_, char *descr);
bool *addBoolFlagPS7660PcPcPcuszrPB(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode);
char *shiftArgumentPS7660Pi32PPPcrPc(FlagParser_s *this, i32 *argc, char ***argv);
none showErrorsAnyPS7660rN(Any stream, FlagParser_s *this);
none showUsageAnyPS7660rN(Any stream, FlagParser_s *this);
none showHelpAnyPS7660rN(Any stream, FlagParser_s *this);
none showHelpAnyPS7407rN(Any stream, Flag_s *this);
bool helpOrPS7660BrB(FlagParser_s *this, bool or);
String_s *emitFlagErrorPS7660PcPcrPS0540(FlagParser_s *this, char *msg, char *name);
String_s *emitFlagErrorPS7660PcrPS0540(FlagParser_s *this, char *msg);
String_s emitFlagDescriptionPS7660PS7407rS0540(FlagParser_s *this, Flag_s *f);
bool runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv);
bool _runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv);
bool analyzeControlFlowPS9562rB(IRGen_s *irgen);
none __format_helperPS0540S4175rN(String_s *out, Data_s arg);
typedef struct variadic_4507 {
    Data_s *ptr;
    usize length;
} variadic_4507;
none formatPS0540PcVS4175rN(String_s *out, char *fmt, variadic_4507 args);
String_s format1PcVS4175rS0540(char *fmt, variadic_4507 args);
none fprintPcVS4175rN(char *fmt, variadic_4507 args);
GAF_List_s new_GAF_ListU7843rS3646(TypeInfo_u ti);
none enumeratePS3646FN_uszS4175rN(GAF_List_s *this, none (*fn)(usize, Data_s));
none enumeratePS3646FN_usz_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(usize, Data_s, Any), Any arg);
none foreachPS3646FNS4175rN(GAF_List_s *this, none (*fn)(Data_s));
none foreachPS3646FN_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(Data_s, Any), Any arg);
none pushPS3646S4175rN(GAF_List_s *list, Data_s elem);
none popPS3646rN(GAF_List_s *list);
none popPS3646AnyrN(GAF_List_s *list, Any dst);
Data_s get_refPS3646uszrS4175(GAF_List_s *list, usize index);
Any get_ref_rawPS3646uszrAny(GAF_List_s *list, usize index);
none swap_removePS3646uszrN(GAF_List_s *list, usize index);
usize _anon_46_0S4175rusz(Data_s key);
bool _anon_46_1S4175S4175rB(Data_s k1, Data_s k2);
GAF_HashMap_s new_hashmap_with_substr_keyU7843rS4580(TypeInfo_u info);
usize _anon_46_2S4175rusz(Data_s key);
bool _anon_46_3S4175S4175rB(Data_s k1, Data_s k2);
GAF_HashMap_s new_hashmap_with_string_keyU7843rS4580(TypeInfo_u info);
GAF_HashMap_s new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580(TypeInfo_u key, TypeInfo_u value, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s));
none _anon_46_4S4175S4175PS3646rN(Data_s k, Data_s elem, GAF_List_s *arg);
GAF_List_s asListPS4580rS3646(GAF_HashMap_s *this);
none enumeratePS4580FN_usz_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s));
none enumeratePS4580FN_usz_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s, Any), Any arg);
none foreachPS4580FN_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s));
none foreachPS4580FN_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s, Any), Any arg);
bool needsResizePS4580rB(GAF_HashMap_s *this);
none resizeIfNecessaryPS4580rN(GAF_HashMap_s *this);
none addPS4580S4175S4175rN(GAF_HashMap_s *this, Data_s key, Data_s value);
bool containsPS4580S4175rB(GAF_HashMap_s *this, Data_s key);
Data_s getPS4580S4175rS4175(GAF_HashMap_s *this, Data_s key);
tuple_4545 getAtIndexPS4580uszrT_S4175S4175(GAF_HashMap_s *this, usize index);
GAF_HashSet_s new_substr_hashsetrS1250(none);
GAF_HashSet_s new_string_hashsetrS1250(none);
GAF_HashSet_s new_GAF_HashSetU7843FuszS4175FB_S4175S4175rS1250(TypeInfo_u key, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s));
none addPS1250S4175rN(GAF_HashSet_s *this, Data_s key);
bool containsPS1250S4175rB(GAF_HashSet_s *this, Data_s key);
CStack_s newCStackrS1662(none);
CGen_s newCGenrS9442(none);
tuple_4329 getVariableInfoPS9442S7720rT_S0610B(CGen_s *this, SubStr_s name);
String_s unescapeS7720rS0540(SubStr_s s);
String_s generateTypeNamePS9442PU5175S0540rS0540(CGen_s *this, Type_u *type, String_s nameForType);
String_s generateTypeNamePS9442PU5175S7720rS0540(CGen_s *this, Type_u *type, SubStr_s nameForType);
String_s generateTypeNamePS9442PU5175S7720uszrS0540(CGen_s *this, Type_u *type, SubStr_s nameForType, usize size);
String_s generateTypeNamePS9442PU5175rS0540(CGen_s *this, Type_u *type);
String_s generateTypeNamePS9442PS1372rS0540(CGen_s *this, ParsedTypeNode_s *type);
none makeNameCCompatiblePS0540rN(String_s *name);
none makeNameCCompatiblePS0540PcrN(String_s *name, char *prefix);
none generateBuiltinTypedefsPS0540rN(String_s *out);
none forwardDeclareTypesPS9442PS0540rN(CGen_s *this, String_s *out);
none emitTypeDeclarationPS9442PS0540PS4580PU5175rN(CGen_s *this, String_s *out, GAF_HashMap_s *map, Type_u *type);
none emitVariadicTypePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateTypeDeclarationsPS9442PS0540rN(CGen_s *this, String_s *out);
none forwardDeclareFunctionsPS9442PS0540rN(CGen_s *this, String_s *out);
none generateFunctionDefinitionsPS9442PS0540rN(CGen_s *this, String_s *out);
none _anon_44_0PS9442PS0540S6070PU5175PS2435uszrN(CGen_s *this, String_s *out, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent);
none generateGlobalVariablesPS9442PS0540rN(CGen_s *this, String_s *out);
String_s _anon_44_1PS9442S6070PS2435uszrS0540(CGen_s *this, Token_s tkn, ParsedExpr_s *expr, usize indent);
String_s generateGlobalInitPS9442PS1100uszrS0540(CGen_s *this, ParsedStmt_s *_decl, usize indent);
none generateGlobalInitializationPS9442PS0540rN(CGen_s *this, String_s *out);
none transpileToCrN(none);
none generateCCoderN(none);
none generateBuildScriptrN(none);
none generateClexeScriptrN(none);
none generateGCCScriptrN(none);
none generateClangScriptrN(none);
none generateEntrypointPS0540rN(String_s *out);
none forwardDeclareTuplePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateTupleDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none forwardDeclareArrayPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none generateArrayDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type);
none forwardDeclareStructPS0540PS5521rN(String_s *out, ParsedStructDecl_s *strukt);
none generateStructDefinitionPS9442PS0540PS5521rN(CGen_s *this, String_s *out, ParsedStructDecl_s *strukt);
none forwardDeclareUnionPS0540PS0997rN(String_s *out, ParsedUnionDecl_s *onion);
none generateUnionDefinitionPS9442PS0540PS0997rN(CGen_s *this, String_s *out, ParsedUnionDecl_s *onion);
none forwardDeclareFunctionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function);
none generateFunctionDefinitionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function);
none emitFunctionSignaturePS9442PS0540S0540PS4904rN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function);
none emitFunctionSignaturePS9442PS0540S0540PS4904BrN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function, bool generateVariadics);
String_s generateBlockPS9442PS7247uszrS0540(CGen_s *this, ParsedBlock_s *block, usize indent);
String_s generateIndentuszrS0540(usize indent);
String_s generateStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent);
String_s _anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540(CGen_s *this, String_s *tmpAlloc, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent);
String_s generateVarDeclPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *_decl, usize indent);
String_s generateMatchStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent);
tuple_4458 generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s expr, Type_u *type, usize indent);
tuple_4458 generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent);
tuple_4458 generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent);
tuple_4458 generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                   usize indent);
String_s generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
String_s _generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
String_s generateTypeInfoPS9442S8951PU5175rS0540(CGen_s *this, Span_s span, Type_u *type);
String_s generateUnionInitPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *init);
bool isCLValuePS2435rB(ParsedExpr_s *this);
String_s generateUnaryExprPS9442PS0540PU5427rS0540(CGen_s *this, String_s *tmpAlloc, UnaryExpr_u *unary);
String_s generateBinaryExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr);
i32 maini32PPcri32(i32 argc, char **argv);
bool findStdAndAddToImportsPS2466rB(Parser_s *parser);
char *getBufoPathrPc(none);
bool linkExecutablerB(none);
i32 __real_main(i32 argc, char **argv, i32 (*main)(i32, char **));

// Global Variables:
FlagParser_s flagParser;
Flags_s flags;
SubStr_s OS_WINDOWS;
SubStr_s OS_LINUX;
char *FATAL_STR;
char *ERR_STR;
char *WARN_STR;
char *NOTE_STR;
u32 U32_MAX;
Any stdin_;
Any stdout_;
Any stderr_;
bool done;
bool PRINT_WARNING;
u8 ORDER_LESS;
u8 ORDER_EQUAL;
u8 ORDER_GREATER;
array_5189 HEX_CHAR;
usize INITIAL_STRINGBUFFER_CAP;
Handle_s INVALID_HANDLE;
i32 ENOENT;
i32 PROT_READ;
i32 PROT_WRITE;
i32 PROT_EXEC;
i32 MAP_PRIVATE;
i32 MAP_ANONYMOUS;
i32 RTLD_LAZY;
usize NODE_ID_OFFSET;
bool ignoringNodes;
ParsedFileArena_s files;
ParsedTopLevelItemArena_s topLevelItems;
ParsedModuleArena_s modules;
ParsedStructDeclArena_s structDecls;
ParsedUnionDeclArena_s unionDecls;
ParsedUnionVariantArena_s unionVariants;
ParsedFuncDeclArena_s funcDecls;
ParsedBlockArena_s blocks;
ParsedStmtArena_s stmts;
ParsedTypeNodeArena_s typeNodes;
ParsedExprArena_s exprs;
ParsedConfigArena_s configs;
DLLArena_s dlls;
ParsedPatternArena_s patterns;
SubStr_s _ATTR_EXTERN;
SubStr_s _ATTR_OS;
SubStr_s _ATTR_NORETURN;
SubStr_s _ATTR_NAKED;
SubStr_s _ATTR_NO_MANGLE;
usize TLI_INVALID;
usize TLI_IMPORT;
usize TLI_VAR_DECL;
usize TLI_STRUCT_DECL;
usize TLI_UNION_DECL;
usize TLI_FUNC_DECL;
usize TLI_MOD_DECL;
usize TLI_CONFIG;
usize DLL_NOT_FOUND;
usize DLL_NO_SUCH_FUNCTION;
usize PARSED_TYPE_INVALID;
usize PARSED_TYPE_UNKNOWN;
usize PARSED_TYPE_NONE;
usize PARSED_TYPE_ANY;
usize PARSED_TYPE_BLANK;
usize PARSED_TYPE_I8;
usize PARSED_TYPE_I16;
usize PARSED_TYPE_I32;
usize PARSED_TYPE_I64;
usize PARSED_TYPE_U8;
usize PARSED_TYPE_U16;
usize PARSED_TYPE_U32;
usize PARSED_TYPE_U64;
usize PARSED_TYPE_USIZE;
usize PARSED_TYPE_BOOL;
usize PARSED_TYPE_CHAR;
usize PARSED_TYPE_IDENT;
usize PARSED_TYPE_REF;
usize PARSED_TYPE_ARRAY;
usize PARSED_TYPE_F32;
usize PARSED_TYPE_F64;
usize PARSED_TYPE_FUNC;
usize PARSED_TYPE_MODULE;
usize PARSED_TYPE_VARIADIC;
usize PARSED_TYPE_TUPLE;
usize PARSED_TYPE_BUILTIN;
SubStr_s ANY;
SubStr_s I8;
SubStr_s I16;
SubStr_s I32;
SubStr_s I64;
SubStr_s U8;
SubStr_s U16;
SubStr_s U32;
SubStr_s U64;
SubStr_s USIZE;
SubStr_s F32;
SubStr_s F64;
SubStr_s BOOL;
SubStr_s CHAR;
i32 LLVMVoidTypeKind;
i32 LLVMHalfTypeKind;
i32 LLVMFloatTypeKind;
i32 LLVMDoubleTypeKind;
i32 LLVMX86_FP80TypeKind;
i32 LLVMFP128TypeKind;
i32 LLVMPPC_FP128TypeKind;
i32 LLVMLabelTypeKind;
i32 LLVMIntegerTypeKind;
i32 LLVMFunctionTypeKind;
i32 LLVMStructTypeKind;
i32 LLVMArrayTypeKind;
i32 LLVMPointerTypeKind;
i32 LLVMVectorTypeKind;
i32 LLVMMetadataTypeKind;
i32 LLVMTokenTypeKind;
i32 LLVMScalableVectorTypeKind;
i32 LLVMBFloatTypeKind;
i32 LLVMX86_AMXTypeKind;
i32 LLVMTargetExtTypeKind;
i32 LLVMIntEQ;
i32 LLVMIntNE;
i32 LLVMIntUGT;
i32 LLVMIntUGE;
i32 LLVMIntULT;
i32 LLVMIntULE;
i32 LLVMIntSGT;
i32 LLVMIntSGE;
i32 LLVMIntSLT;
i32 LLVMIntSLE;
i32 LLVMRealPredicateFalse;
i32 LLVMRealOEQ;
i32 LLVMRealOGT;
i32 LLVMRealOGE;
i32 LLVMRealOLT;
i32 LLVMRealOLE;
i32 LLVMRealONE;
i32 LLVMRealORD;
i32 LLVMRealUNO;
i32 LLVMRealUEQ;
i32 LLVMRealUGT;
i32 LLVMRealUGE;
i32 LLVMRealULT;
i32 LLVMRealULE;
i32 LLVMRealUNE;
i32 LLVMRealPredicateTrue;
i32 LLVMAbortProcessAction;
i32 LLVMPrintMessageAction;
i32 LLVMReturnStatusAction;
i32 LLVMAssemblyFile;
i32 LLVMObjectFile;
i32 LLVMDIFlagZero;
i32 LLVMDIFlagPrivate;
i32 LLVMDIFlagProtected;
i32 LLVMDIFlagPublic;
i32 LLVMDIFlagFwdDecl;
i32 LLVMDIFlagAppleBlock;
i32 LLVMDIFlagReservedBit4;
i32 LLVMDIFlagVirtual;
i32 LLVMDIFlagArtificial;
i32 LLVMDIFlagExplicit;
i32 LLVMDIFlagPrototyped;
i32 LLVMDIFlagObjcClassComplete;
i32 LLVMDIFlagObjectPointer;
i32 LLVMDIFlagVector;
i32 LLVMDIFlagStaticMember;
i32 LLVMDIFlagLValueReference;
i32 LLVMDIFlagRValueReference;
i32 LLVMDIFlagReserved;
i32 LLVMDIFlagSingleInheritance;
i32 LLVMDIFlagMultipleInheritance;
i32 LLVMDIFlagVirtualInheritance;
i32 LLVMDIFlagIntroducedVirtual;
i32 LLVMDIFlagBitField;
i32 LLVMDIFlagNoReturn;
i32 LLVMDIFlagTypePassByValue;
i32 LLVMDIFlagTypePassByReference;
i32 LLVMDIFlagEnumClass;
i32 LLVMDIFlagFixedEnum;
i32 LLVMDIFlagThunk;
i32 LLVMDIFlagNonTrivial;
i32 LLVMDIFlagBigEndian;
i32 LLVMDIFlagLittleEndian;
i32 LLVMDIFlagIndirectVirtualBase;
i32 LLVMDIFlagAccessibility;
i32 LLVMDIFlagPtrToMemberRep;
i32 LLVMDWARFEmissionKindNone;
i32 LLVMDWARFEmissionKindFull;
i32 LLVMDWARFEmissionKindLineTablesOnly;
i32 LLVMDWARFSourceLanguageC89;
i32 LLVMDWARFSourceLanguageC;
i32 LLVMDWARFSourceLanguageAda83;
i32 LLVMDWARFSourceLanguageC_plus_plus;
i32 LLVMDWARFSourceLanguageCobol74;
i32 LLVMDWARFSourceLanguageCobol85;
i32 LLVMDWARFSourceLanguageFortran77;
i32 LLVMDWARFSourceLanguageFortran90;
i32 LLVMDWARFSourceLanguagePascal83;
i32 LLVMDWARFSourceLanguageModula2;
i32 LLVMDWARFSourceLanguageJava;
i32 LLVMDWARFSourceLanguageC99;
i32 LLVMDWARFSourceLanguageAda95;
i32 LLVMDWARFSourceLanguageFortran95;
i32 LLVMDWARFSourceLanguagePLI;
i32 LLVMDWARFSourceLanguageObjC;
i32 LLVMDWARFSourceLanguageObjC_plus_plus;
i32 LLVMDWARFSourceLanguageUPC;
i32 LLVMDWARFSourceLanguageD;
i32 LLVMDWARFSourceLanguagePython;
i32 LLVMDWARFSourceLanguageOpenCL;
i32 LLVMDWARFSourceLanguageGo;
i32 LLVMDWARFSourceLanguageModula3;
i32 LLVMDWARFSourceLanguageHaskell;
i32 LLVMDWARFSourceLanguageC_plus_plus_03;
i32 LLVMDWARFSourceLanguageC_plus_plus_11;
i32 LLVMDWARFSourceLanguageOCaml;
i32 LLVMDWARFSourceLanguageRust;
i32 LLVMDWARFSourceLanguageC11;
i32 LLVMDWARFSourceLanguageSwift;
i32 LLVMDWARFSourceLanguageJulia;
i32 LLVMDWARFSourceLanguageDylan;
i32 LLVMDWARFSourceLanguageC_plus_plus_14;
i32 LLVMDWARFSourceLanguageFortran03;
i32 LLVMDWARFSourceLanguageFortran08;
i32 LLVMDWARFSourceLanguageRenderScript;
i32 LLVMDWARFSourceLanguageBLISS;
i32 LLVMDWARFSourceLanguageKotlin;
i32 LLVMDWARFSourceLanguageZig;
i32 LLVMDWARFSourceLanguageCrystal;
i32 LLVMDWARFSourceLanguageC_plus_plus_17;
i32 LLVMDWARFSourceLanguageC_plus_plus_20;
i32 LLVMDWARFSourceLanguageC17;
i32 LLVMDWARFSourceLanguageFortran18;
i32 LLVMDWARFSourceLanguageAda2005;
i32 LLVMDWARFSourceLanguageAda2012;
i32 LLVMDWARFSourceLanguageHIP;
i32 LLVMDWARFSourceLanguageAssembly;
i32 LLVMDWARFSourceLanguageC_sharp;
i32 LLVMDWARFSourceLanguageMojo;
i32 LLVMDWARFSourceLanguageGLSL;
i32 LLVMDWARFSourceLanguageGLSL_ES;
i32 LLVMDWARFSourceLanguageHLSL;
i32 LLVMDWARFSourceLanguageOpenCL_CPP;
i32 LLVMDWARFSourceLanguageCPP_for_OpenCL;
i32 LLVMDWARFSourceLanguageSYCL;
i32 LLVMDWARFSourceLanguageRuby;
i32 LLVMDWARFSourceLanguageMove;
i32 LLVMDWARFSourceLanguageHylo;
i32 LLVMDWARFSourceLanguageMetal;
i32 LLVMDWARFSourceLanguageMips_Assembler;
i32 LLVMDWARFSourceLanguageGOOGLE_RenderScript;
i32 LLVMDWARFSourceLanguageBORLAND_Delphi;
i32 LLVMModuleFlagBehaviorError;
i32 LLVMModuleFlagBehaviorWarning;
i32 LLVMModuleFlagBehaviorRequire;
i32 LLVMModuleFlagBehaviorOverride;
i32 LLVMModuleFlagBehaviorAppend;
i32 LLVMModuleFlagBehaviorAppendUnique;
usize TOKEN_EOF;
usize TOKEN_IDENT;
usize TOKEN_KEYWORD;
usize TOKEN_STRING_LITERAL;
usize TOKEN_INT_LITERAL;
usize TOKEN_CHAR_LITERAL;
usize TOKEN_PAREN_OPEN;
usize TOKEN_PAREN_CLOSE;
usize TOKEN_CURLY_OPEN;
usize TOKEN_CURLY_CLOSE;
usize TOKEN_SQUARE_OPEN;
usize TOKEN_SQUARE_CLOSE;
usize TOKEN_SEMI_COLON;
usize TOKEN_COLON_SINGLE;
usize TOKEN_COLON_DOUBLE;
usize TOKEN_EQUAL_SINGLE;
usize TOKEN_EQUAL_DOUBLE;
usize TOKEN_AMPERSAND_SINGLE;
usize TOKEN_AMPERSAND_DOUBLE;
usize TOKEN_COMMA;
usize TOKEN_ARROW_THIN;
usize TOKEN_ARROW_THICK;
usize TOKEN_PLUS_SINGLE;
usize TOKEN_UNDERSCORE;
usize TOKEN_DOT;
usize TOKEN_AT;
usize TOKEN_MINUS_SINGLE;
usize TOKEN_ASTERISK_SINGLE;
usize TOKEN_NOT_EQUAL;
usize TOKEN_BANG;
usize TOKEN_SLASH_SINGLE;
usize TOKEN_LESS_THAN_EQUAL;
usize TOKEN_LESS_THAN;
usize TOKEN_GREATER_THAN_EQUAL;
usize TOKEN_GREATER_THAN;
usize TOKEN_PERCENT;
usize TOKEN_PIPE_SINGLE;
usize TOKEN_PIPE_DOUBLE;
usize TOKEN_DOTDOT;
usize TOKEN_DOTDOTDOT;
usize TOKEN_CARET;
usize TOKEN_WILDCARD;
usize PRIM_TYPE_COUNT;
TypeArena_s types;
LLVMMetadataArena_s debugTypes;
TypeInfo_u *type_info_table;
usize ARENA_SIZE_SMALL;
usize ARENA_SIZE_MEDIUM;
usize ARENA_SIZE_LARGE;
usize ARENA_SIZE_HUGE;
usize ELSE_BIT;
SubStr_s KEYWORD_LET;
SubStr_s KEYWORD_COMPTIME;
SubStr_s KEYWORD_FUNC;
SubStr_s KEYWORD_STRUCT;
SubStr_s KEYWORD_ENUM;
SubStr_s KEYWORD_UNION;
SubStr_s KEYWORD_RETURN;
SubStr_s KEYWORD_MODULE;
SubStr_s KEYWORD_IMPORT;
SubStr_s KEYWORD_IF;
SubStr_s KEYWORD_ELSE;
SubStr_s KEYWORD_WHILE;
SubStr_s KEYWORD_SIZEOF;
SubStr_s KEYWORD_AS;
SubStr_s KEYWORD_FOR;
SubStr_s KEYWORD_BREAK;
SubStr_s KEYWORD_CONTINUE;
SubStr_s KEYWORD_NULL;
SubStr_s KEYWORD_BLANK;
SubStr_s KEYWORD_TRUE;
SubStr_s KEYWORD_FALSE;
SubStr_s KEYWORD_CONFIG;
SubStr_s KEYWORD_MATCH;
SubStr_s KEYWORD_ASM;
SubStr_s KEYWORD_TYPEINFO;
usize ERROR_INVALID;
usize ERROR_NO_SUCH_MODULE;
usize ERROR_NO_SUCH_IDENTIFIER;
usize ERROR_NO_SUCH_FUNCTION;
usize ERROR_NO_SUCH_METHOD;
usize ERROR_NO_SUCH_TYPE;
usize ERROR_USE_BEFORE_DECLARATION;
usize ERROR_FIELD_COUNT_MISMATCH;
usize ERROR_INDEXED_TYPE_MISMATCH;
usize ERROR_UNEXPECTED_LITERAL;
usize ERROR_ARRAY_SIZE_MISMATCH;
usize ERROR_TYPE_MISMATCH;
usize ERROR_INVALID_POINTER_ARITHMETIC;
usize ERROR_DUPLICATE_PARAMETER;
usize ERROR_DUPLICATE_FIELD;
usize ERROR_UNKNOWN_FIELD;
usize ERROR_DUPLICATE_FUNCTION;
usize ERROR_NO_CALL_CANDIDATE;
usize ERROR_VARIABLE_REDECLARATION;
usize ERROR_RECURSIVE_TYPE;
usize ERROR_DUPLICATE_METHOD;
usize ERROR_BLANK_FOR_NULL;
usize ERROR_NON_PRIMITIVE_CAST;
usize ERROR_INDEXED_ACCESS_ON_NON_ARRAY;
usize ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT;
usize ERROR_ANY_DEREF;
usize ERROR_MEMBER_ACCESS_NON_STRUCT;
usize ERROR_MEMBER_ACCESS_NO_OPTIONS;
usize ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS;
usize ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS;
usize ERROR_CALL_TO_NON_FUNCTION;
usize ERROR_UNKNOWN_SUBMODULE;
usize ERROR_MODULE_ACCESS_NON_MODULE;
usize ERROR_DEREF_NON_POINTER;
usize ERROR_DUPLICATE_UNION_VARIANT;
usize ERROR_DUPLICATE_UNION_NAME;
usize ERROR_NON_EXHAUSTIVE_MATCH;
usize ERROR_IMPOSSIBLE_PATTERN;
usize ERROR_NULL_NON_PTR;
usize ERROR_FILE_MISSING;
usize ERROR_ASSEMBLY_IN_COMPTIME_CONTEXT;
usize ERROR_NAKED_STATEMENT;
usize ERROR_INVALID_VARIANT_INIT;
usize ERROR_NO_SUCH_VARIANT;
usize ERROR_INFER_FAILED;
usize ERROR_MISSING_TRAMPOLINE;
u32 IDENT_NONE;
u32 IDENT_FUNC;
u32 IDENT_VAR;
u32 IDENT_TYPE;
usize TYPE_LOOKUP_INVALID;
usize TYPE_LOOKUP_STRUCT;
usize TYPE_LOOKUP_UNION;
bool syntaxError;
bool needsPrelude;
bool needsAssembly;
bool needsTypeInfo;
usize INSTR_INVALID;
usize INSTR_ALLOCA;
usize INSTR_GET_PARAM;
usize INSTR_STORE;
usize INSTR_FETCH_GLOBAL_PTR;
usize INSTR_FETCH_GLOBAL_VALUE;
usize INSTR_FETCH_COMPTIME_VALUE;
usize INSTR_LOAD_FUNCTION_PTR;
usize INSTR_LOAD;
usize INSTR_MOVE;
usize INSTR_CALL;
usize INSTR_RETURN_EXPR;
usize INSTR_RETURN_VOID;
usize INSTR_LOAD_STRING;
usize INSTR_LOAD_BOOL;
usize INSTR_LOAD_I8;
usize INSTR_LOAD_U8;
usize INSTR_LOAD_I16;
usize INSTR_LOAD_U16;
usize INSTR_LOAD_I32;
usize INSTR_LOAD_U32;
usize INSTR_LOAD_I64;
usize INSTR_LOAD_U64;
usize INSTR_LOAD_NULL;
usize INSTR_LOAD_F32;
usize INSTR_LOAD_F64;
usize INSTR_LOAD_BLANK;
usize INSTR_COND_BR;
usize INSTR_BR;
usize INSTR_INT_ADD;
usize INSTR_INT_SUB;
usize INSTR_INT_MUL;
usize INSTR_INT_DIV;
usize INSTR_INT_MOD;
usize INSTR_INT_CMP_EQ;
usize INSTR_INT_CMP_NEQ;
usize INSTR_INT_CMP_GT;
usize INSTR_INT_CMP_GTE;
usize INSTR_INT_CMP_LT;
usize INSTR_INT_CMP_LTE;
usize INSTR_FLOAT_ADD;
usize INSTR_FLOAT_SUB;
usize INSTR_FLOAT_MUL;
usize INSTR_FLOAT_DIV;
usize INSTR_FLOAT_MOD;
usize INSTR_FLOAT_CMP_EQ;
usize INSTR_FLOAT_CMP_NEQ;
usize INSTR_FLOAT_CMP_GT;
usize INSTR_FLOAT_CMP_GTE;
usize INSTR_FLOAT_CMP_LT;
usize INSTR_FLOAT_CMP_LTE;
usize INSTR_LOGICAL_NOT;
usize INSTR_LOGICAL_AND;
usize INSTR_LOGICAL_OR;
usize INSTR_BITWISE_AND;
usize INSTR_BITWISE_OR;
usize INSTR_BITWISE_XOR;
usize INSTR_INSERT_VALUE;
usize INSTR_INT_SIGN_EXTEND;
usize INSTR_INT_ZERO_EXTEND;
usize INSTR_INT_TRUNCATE;
usize INSTR_INT_TO_F32;
usize INSTR_INT_TO_F64;
usize INSTR_F32_TO_INT;
usize INSTR_F64_TO_INT;
usize INSTR_F32_TO_F64;
usize INSTR_F64_TO_F32;
usize INSTR_CREATE_ARRAY;
usize INSTR_CREATE_STRUCT;
usize INSTR_CREATE_UNION;
usize INSTR_PTR_TO_INT;
usize INSTR_INT_TO_PTR;
usize INSTR_GET_FIELD_PTR;
usize INSTR_GET_ELEMENT_PTR;
usize INSTR_UNREACHABLE;
usize INSTR_UNTERMINATED;
usize INSTR_MEMCPY;
usize INSTR_EMIT_ASSEMBLY;
usize INSTR_INTO_IR_VALUE;
usize INSTR_DEBUG_INFO_ALLOCA;
usize INSTR_DEBUG_INFO_PARAM;
usize PARAM_SHIFT;
usize REG_STACK_SIZE;
usize STACK_SIZE;
array_5236 instrFns;
GPR_s RAX;
GPR_s RCX;
GPR_s RDX;
GPR_s RBX;
GPR_s RSP;
GPR_s RBP;
GPR_s RSI;
GPR_s RDI;
GPR_s R8;
GPR_s R9;
GPR_s R10;
GPR_s R11;
GPR_s R12;
GPR_s R13;
GPR_s R14;
GPR_s R15;
FPR_s XMM0;
FPR_s XMM1;
FPR_s XMM2;
FPR_s XMM3;
FPR_s XMM4;
FPR_s XMM5;
u8 ADDR_INDIRECT;
u8 ADDR_DISP8;
u8 ADDR_DISP32;
u8 ADDR_REG;
u32 DW_ATE_address;
u32 DW_ATE_boolean;
u32 DW_ATE_complex_float;
u32 DW_ATE_float;
u32 DW_ATE_signed;
u32 DW_ATE_signed_char;
u32 DW_ATE_unsigned;
u32 DW_ATE_unsigned_char;
u32 DW_ATE_imaginary_float;
u32 DW_ATE_packed_decimal;
u32 DW_ATE_numeric_string;
u32 DW_ATE_edited;
u32 DW_ATE_signed_fixed;
u32 DW_ATE_unsigned_fixed;
u32 DW_ATE_decimal_float;
u32 DW_ATE_UTF;
u32 DW_ATE_UCS;
u32 DW_ATE_ASCII;
u32 DW_ATE_lo_user;
u32 DW_ATE_hi_user;
usize FLAG_INVALID;
usize FLAG_STRING;
usize FLAG_BOOL;
usize FLAG_MODE_DEFAULT;
usize FLAG_MODE_SINGLE;
usize FLAG_MODE_MANDATORY;
usize INDENTATION_LEVEL;
none __global_init_please_dont_call_yourself(none) {
    flagParser = ((FlagParser_s){0});
    flags = ((Flags_s){0});
    OS_WINDOWS = ((comptimeSubStrPcrS7720)(("WINDOWS")));
    OS_LINUX = ((comptimeSubStrPcrS7720)(("LINUX")));
    FATAL_STR = ("\x1B[95m[FATAL]\x1B[0m");
    ERR_STR = ("\x1B[91merror\x1B[0m");
    WARN_STR = ("\x1B[93mwarning\x1B[0m");
    NOTE_STR = ("\x1B[92mnote\x1B[0m");
    U32_MAX = (((u32)(0)) - ((u32)(1)));
    stdin_ = (NULL);
    stdout_ = (NULL);
    stderr_ = (NULL);
    done = (false);
    PRINT_WARNING = (true);
    ORDER_LESS = ((u8)(0));
    ORDER_EQUAL = ((u8)(1));
    ORDER_GREATER = ((u8)(2));
    HEX_CHAR = ((array_5189){('0'), ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7'), ('8'), ('9'), ('A'), ('B'), ('C'), ('D'), ('E'), ('F')});
    INITIAL_STRINGBUFFER_CAP = ((usize)(16llu));
    INVALID_HANDLE = ((Handle_s){.ptr = ((usize)(18446744073709551615llu))});
    ENOENT = ((i32)(2));
    PROT_READ = ((i32)(1));
    PROT_WRITE = ((i32)(2));
    PROT_EXEC = ((i32)(4));
    MAP_PRIVATE = ((i32)(2));
    MAP_ANONYMOUS = ((i32)(32));
    RTLD_LAZY = ((i32)(1));
    NODE_ID_OFFSET = ((usize)(10000000000llu));
    ignoringNodes = (false);
    files = ((ParsedFileArena_s){0});
    topLevelItems = ((ParsedTopLevelItemArena_s){0});
    modules = ((ParsedModuleArena_s){0});
    structDecls = ((ParsedStructDeclArena_s){0});
    unionDecls = ((ParsedUnionDeclArena_s){0});
    unionVariants = ((ParsedUnionVariantArena_s){0});
    funcDecls = ((ParsedFuncDeclArena_s){0});
    blocks = ((ParsedBlockArena_s){0});
    stmts = ((ParsedStmtArena_s){0});
    typeNodes = ((ParsedTypeNodeArena_s){0});
    exprs = ((ParsedExprArena_s){0});
    configs = ((ParsedConfigArena_s){0});
    dlls = ((DLLArena_s){0});
    patterns = ((ParsedPatternArena_s){0});
    _ATTR_EXTERN = ((BUILD_A_KEYWORDPcrS7720)(("extern")));
    _ATTR_OS = ((BUILD_A_KEYWORDPcrS7720)(("os")));
    _ATTR_NORETURN = ((BUILD_A_KEYWORDPcrS7720)(("noreturn")));
    _ATTR_NAKED = ((BUILD_A_KEYWORDPcrS7720)(("naked")));
    _ATTR_NO_MANGLE = ((BUILD_A_KEYWORDPcrS7720)(("no_mangle")));
    TLI_INVALID = ((usize)(0llu));
    TLI_IMPORT = ((usize)(1llu));
    TLI_VAR_DECL = ((usize)(2llu));
    TLI_STRUCT_DECL = ((usize)(3llu));
    TLI_UNION_DECL = ((usize)(4llu));
    TLI_FUNC_DECL = ((usize)(5llu));
    TLI_MOD_DECL = ((usize)(6llu));
    TLI_CONFIG = ((usize)(7llu));
    DLL_NOT_FOUND = ((usize)(1llu));
    DLL_NO_SUCH_FUNCTION = ((usize)(2llu));
    PARSED_TYPE_INVALID = ((usize)(0llu));
    PARSED_TYPE_UNKNOWN = ((usize)(1llu));
    PARSED_TYPE_NONE = ((usize)(2llu));
    PARSED_TYPE_ANY = ((usize)(3llu));
    PARSED_TYPE_BLANK = ((usize)(4llu));
    PARSED_TYPE_I8 = ((usize)(5llu));
    PARSED_TYPE_I16 = ((usize)(6llu));
    PARSED_TYPE_I32 = ((usize)(7llu));
    PARSED_TYPE_I64 = ((usize)(8llu));
    PARSED_TYPE_U8 = ((usize)(9llu));
    PARSED_TYPE_U16 = ((usize)(10llu));
    PARSED_TYPE_U32 = ((usize)(11llu));
    PARSED_TYPE_U64 = ((usize)(12llu));
    PARSED_TYPE_USIZE = ((usize)(13llu));
    PARSED_TYPE_BOOL = ((usize)(14llu));
    PARSED_TYPE_CHAR = ((usize)(15llu));
    PARSED_TYPE_IDENT = ((usize)(16llu));
    PARSED_TYPE_REF = ((usize)(17llu));
    PARSED_TYPE_ARRAY = ((usize)(18llu));
    PARSED_TYPE_F32 = ((usize)(19llu));
    PARSED_TYPE_F64 = ((usize)(20llu));
    PARSED_TYPE_FUNC = ((usize)(21llu));
    PARSED_TYPE_MODULE = ((usize)(22llu));
    PARSED_TYPE_VARIADIC = ((usize)(23llu));
    PARSED_TYPE_TUPLE = ((usize)(24llu));
    PARSED_TYPE_BUILTIN = ((usize)(25llu));
    ANY = ((BUILD_A_TYPEPcrS7720)(("Any")));
    I8 = ((BUILD_A_TYPEPcrS7720)(("i8")));
    I16 = ((BUILD_A_TYPEPcrS7720)(("i16")));
    I32 = ((BUILD_A_TYPEPcrS7720)(("i32")));
    I64 = ((BUILD_A_TYPEPcrS7720)(("i64")));
    U8 = ((BUILD_A_TYPEPcrS7720)(("u8")));
    U16 = ((BUILD_A_TYPEPcrS7720)(("u16")));
    U32 = ((BUILD_A_TYPEPcrS7720)(("u32")));
    U64 = ((BUILD_A_TYPEPcrS7720)(("u64")));
    USIZE = ((BUILD_A_TYPEPcrS7720)(("usize")));
    F32 = ((BUILD_A_TYPEPcrS7720)(("f32")));
    F64 = ((BUILD_A_TYPEPcrS7720)(("f64")));
    BOOL = ((BUILD_A_TYPEPcrS7720)(("bool")));
    CHAR = ((BUILD_A_TYPEPcrS7720)(("char")));
    LLVMVoidTypeKind = ((i32)(0));
    LLVMHalfTypeKind = ((i32)(1));
    LLVMFloatTypeKind = ((i32)(2));
    LLVMDoubleTypeKind = ((i32)(3));
    LLVMX86_FP80TypeKind = ((i32)(4));
    LLVMFP128TypeKind = ((i32)(5));
    LLVMPPC_FP128TypeKind = ((i32)(6));
    LLVMLabelTypeKind = ((i32)(7));
    LLVMIntegerTypeKind = ((i32)(8));
    LLVMFunctionTypeKind = ((i32)(9));
    LLVMStructTypeKind = ((i32)(10));
    LLVMArrayTypeKind = ((i32)(11));
    LLVMPointerTypeKind = ((i32)(12));
    LLVMVectorTypeKind = ((i32)(13));
    LLVMMetadataTypeKind = ((i32)(14));
    LLVMTokenTypeKind = ((i32)(16));
    LLVMScalableVectorTypeKind = ((i32)(17));
    LLVMBFloatTypeKind = ((i32)(18));
    LLVMX86_AMXTypeKind = ((i32)(19));
    LLVMTargetExtTypeKind = ((i32)(20));
    LLVMIntEQ = ((i32)(32));
    LLVMIntNE = ((i32)(33));
    LLVMIntUGT = ((i32)(34));
    LLVMIntUGE = ((i32)(35));
    LLVMIntULT = ((i32)(36));
    LLVMIntULE = ((i32)(37));
    LLVMIntSGT = ((i32)(38));
    LLVMIntSGE = ((i32)(39));
    LLVMIntSLT = ((i32)(40));
    LLVMIntSLE = ((i32)(41));
    LLVMRealPredicateFalse = ((i32)(0));
    LLVMRealOEQ = ((i32)(1));
    LLVMRealOGT = ((i32)(2));
    LLVMRealOGE = ((i32)(3));
    LLVMRealOLT = ((i32)(4));
    LLVMRealOLE = ((i32)(5));
    LLVMRealONE = ((i32)(6));
    LLVMRealORD = ((i32)(7));
    LLVMRealUNO = ((i32)(8));
    LLVMRealUEQ = ((i32)(9));
    LLVMRealUGT = ((i32)(10));
    LLVMRealUGE = ((i32)(11));
    LLVMRealULT = ((i32)(12));
    LLVMRealULE = ((i32)(13));
    LLVMRealUNE = ((i32)(14));
    LLVMRealPredicateTrue = ((i32)(15));
    LLVMAbortProcessAction = ((i32)(0));
    LLVMPrintMessageAction = ((i32)(1));
    LLVMReturnStatusAction = ((i32)(2));
    LLVMAssemblyFile = ((i32)(0));
    LLVMObjectFile = ((i32)(1));
    LLVMDIFlagZero = ((i32)(0));
    LLVMDIFlagPrivate = ((i32)(1));
    LLVMDIFlagProtected = ((i32)(2));
    LLVMDIFlagPublic = ((i32)(3));
    LLVMDIFlagFwdDecl = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(2llu))))));
    LLVMDIFlagAppleBlock = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(3llu))))));
    LLVMDIFlagReservedBit4 = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(4llu))))));
    LLVMDIFlagVirtual = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(5llu))))));
    LLVMDIFlagArtificial = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(6llu))))));
    LLVMDIFlagExplicit = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(7llu))))));
    LLVMDIFlagPrototyped = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(8llu))))));
    LLVMDIFlagObjcClassComplete = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(9llu))))));
    LLVMDIFlagObjectPointer = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(10llu))))));
    LLVMDIFlagVector = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(11llu))))));
    LLVMDIFlagStaticMember = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(12llu))))));
    LLVMDIFlagLValueReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(13llu))))));
    LLVMDIFlagRValueReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(14llu))))));
    LLVMDIFlagReserved = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(15llu))))));
    LLVMDIFlagSingleInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(16llu))))));
    LLVMDIFlagMultipleInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(2llu)), ((usize)(16llu))))));
    LLVMDIFlagVirtualInheritance = ((i32)(((shiftLeftuszuszrusz)(((usize)(3llu)), ((usize)(16llu))))));
    LLVMDIFlagIntroducedVirtual = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(18llu))))));
    LLVMDIFlagBitField = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(19llu))))));
    LLVMDIFlagNoReturn = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(20llu))))));
    LLVMDIFlagTypePassByValue = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(22llu))))));
    LLVMDIFlagTypePassByReference = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(23llu))))));
    LLVMDIFlagEnumClass = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(24llu))))));
    LLVMDIFlagFixedEnum = (LLVMDIFlagEnumClass);
    LLVMDIFlagThunk = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(25llu))))));
    LLVMDIFlagNonTrivial = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(26llu))))));
    LLVMDIFlagBigEndian = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(27llu))))));
    LLVMDIFlagLittleEndian = ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(28llu))))));
    LLVMDIFlagIndirectVirtualBase = (((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(2llu)))))) | ((i32)(((shiftLeftuszuszrusz)(((usize)(1llu)), ((usize)(5llu)))))));
    LLVMDIFlagAccessibility = (((LLVMDIFlagPrivate) | (LLVMDIFlagProtected)) | (LLVMDIFlagPublic));
    LLVMDIFlagPtrToMemberRep = (((LLVMDIFlagSingleInheritance) | (LLVMDIFlagMultipleInheritance)) | (LLVMDIFlagVirtualInheritance));
    LLVMDWARFEmissionKindNone = ((i32)(0));
    LLVMDWARFEmissionKindFull = ((i32)(1));
    LLVMDWARFEmissionKindLineTablesOnly = ((i32)(2));
    LLVMDWARFSourceLanguageC89 = ((i32)(0));
    LLVMDWARFSourceLanguageC = ((i32)(1));
    LLVMDWARFSourceLanguageAda83 = ((i32)(2));
    LLVMDWARFSourceLanguageC_plus_plus = ((i32)(3));
    LLVMDWARFSourceLanguageCobol74 = ((i32)(4));
    LLVMDWARFSourceLanguageCobol85 = ((i32)(5));
    LLVMDWARFSourceLanguageFortran77 = ((i32)(6));
    LLVMDWARFSourceLanguageFortran90 = ((i32)(7));
    LLVMDWARFSourceLanguagePascal83 = ((i32)(8));
    LLVMDWARFSourceLanguageModula2 = ((i32)(9));
    LLVMDWARFSourceLanguageJava = ((i32)(10));
    LLVMDWARFSourceLanguageC99 = ((i32)(11));
    LLVMDWARFSourceLanguageAda95 = ((i32)(12));
    LLVMDWARFSourceLanguageFortran95 = ((i32)(13));
    LLVMDWARFSourceLanguagePLI = ((i32)(14));
    LLVMDWARFSourceLanguageObjC = ((i32)(15));
    LLVMDWARFSourceLanguageObjC_plus_plus = ((i32)(16));
    LLVMDWARFSourceLanguageUPC = ((i32)(17));
    LLVMDWARFSourceLanguageD = ((i32)(18));
    LLVMDWARFSourceLanguagePython = ((i32)(19));
    LLVMDWARFSourceLanguageOpenCL = ((i32)(20));
    LLVMDWARFSourceLanguageGo = ((i32)(21));
    LLVMDWARFSourceLanguageModula3 = ((i32)(22));
    LLVMDWARFSourceLanguageHaskell = ((i32)(23));
    LLVMDWARFSourceLanguageC_plus_plus_03 = ((i32)(24));
    LLVMDWARFSourceLanguageC_plus_plus_11 = ((i32)(25));
    LLVMDWARFSourceLanguageOCaml = ((i32)(26));
    LLVMDWARFSourceLanguageRust = ((i32)(27));
    LLVMDWARFSourceLanguageC11 = ((i32)(28));
    LLVMDWARFSourceLanguageSwift = ((i32)(29));
    LLVMDWARFSourceLanguageJulia = ((i32)(30));
    LLVMDWARFSourceLanguageDylan = ((i32)(31));
    LLVMDWARFSourceLanguageC_plus_plus_14 = ((i32)(32));
    LLVMDWARFSourceLanguageFortran03 = ((i32)(33));
    LLVMDWARFSourceLanguageFortran08 = ((i32)(34));
    LLVMDWARFSourceLanguageRenderScript = ((i32)(35));
    LLVMDWARFSourceLanguageBLISS = ((i32)(36));
    LLVMDWARFSourceLanguageKotlin = ((i32)(37));
    LLVMDWARFSourceLanguageZig = ((i32)(38));
    LLVMDWARFSourceLanguageCrystal = ((i32)(39));
    LLVMDWARFSourceLanguageC_plus_plus_17 = ((i32)(40));
    LLVMDWARFSourceLanguageC_plus_plus_20 = ((i32)(41));
    LLVMDWARFSourceLanguageC17 = ((i32)(42));
    LLVMDWARFSourceLanguageFortran18 = ((i32)(43));
    LLVMDWARFSourceLanguageAda2005 = ((i32)(44));
    LLVMDWARFSourceLanguageAda2012 = ((i32)(45));
    LLVMDWARFSourceLanguageHIP = ((i32)(46));
    LLVMDWARFSourceLanguageAssembly = ((i32)(47));
    LLVMDWARFSourceLanguageC_sharp = ((i32)(48));
    LLVMDWARFSourceLanguageMojo = ((i32)(49));
    LLVMDWARFSourceLanguageGLSL = ((i32)(50));
    LLVMDWARFSourceLanguageGLSL_ES = ((i32)(51));
    LLVMDWARFSourceLanguageHLSL = ((i32)(52));
    LLVMDWARFSourceLanguageOpenCL_CPP = ((i32)(53));
    LLVMDWARFSourceLanguageCPP_for_OpenCL = ((i32)(54));
    LLVMDWARFSourceLanguageSYCL = ((i32)(55));
    LLVMDWARFSourceLanguageRuby = ((i32)(56));
    LLVMDWARFSourceLanguageMove = ((i32)(57));
    LLVMDWARFSourceLanguageHylo = ((i32)(58));
    LLVMDWARFSourceLanguageMetal = ((i32)(59));
    LLVMDWARFSourceLanguageMips_Assembler = ((i32)(60));
    LLVMDWARFSourceLanguageGOOGLE_RenderScript = ((i32)(61));
    LLVMDWARFSourceLanguageBORLAND_Delphi = ((i32)(62));
    LLVMModuleFlagBehaviorError = ((i32)(0));
    LLVMModuleFlagBehaviorWarning = ((i32)(1));
    LLVMModuleFlagBehaviorRequire = ((i32)(2));
    LLVMModuleFlagBehaviorOverride = ((i32)(3));
    LLVMModuleFlagBehaviorAppend = ((i32)(4));
    LLVMModuleFlagBehaviorAppendUnique = ((i32)(5));
    TOKEN_EOF = ((usize)(0llu));
    TOKEN_IDENT = ((usize)(1llu));
    TOKEN_KEYWORD = ((usize)(2llu));
    TOKEN_STRING_LITERAL = ((usize)(3llu));
    TOKEN_INT_LITERAL = ((usize)(4llu));
    TOKEN_CHAR_LITERAL = ((usize)(5llu));
    TOKEN_PAREN_OPEN = ((usize)(6llu));
    TOKEN_PAREN_CLOSE = ((usize)(7llu));
    TOKEN_CURLY_OPEN = ((usize)(8llu));
    TOKEN_CURLY_CLOSE = ((usize)(9llu));
    TOKEN_SQUARE_OPEN = ((usize)(10llu));
    TOKEN_SQUARE_CLOSE = ((usize)(11llu));
    TOKEN_SEMI_COLON = ((usize)(12llu));
    TOKEN_COLON_SINGLE = ((usize)(13llu));
    TOKEN_COLON_DOUBLE = ((usize)(14llu));
    TOKEN_EQUAL_SINGLE = ((usize)(15llu));
    TOKEN_EQUAL_DOUBLE = ((usize)(16llu));
    TOKEN_AMPERSAND_SINGLE = ((usize)(17llu));
    TOKEN_AMPERSAND_DOUBLE = ((usize)(18llu));
    TOKEN_COMMA = ((usize)(19llu));
    TOKEN_ARROW_THIN = ((usize)(20llu));
    TOKEN_ARROW_THICK = ((usize)(21llu));
    TOKEN_PLUS_SINGLE = ((usize)(22llu));
    TOKEN_UNDERSCORE = ((usize)(23llu));
    TOKEN_DOT = ((usize)(24llu));
    TOKEN_AT = ((usize)(25llu));
    TOKEN_MINUS_SINGLE = ((usize)(26llu));
    TOKEN_ASTERISK_SINGLE = ((usize)(27llu));
    TOKEN_NOT_EQUAL = ((usize)(28llu));
    TOKEN_BANG = ((usize)(29llu));
    TOKEN_SLASH_SINGLE = ((usize)(30llu));
    TOKEN_LESS_THAN_EQUAL = ((usize)(31llu));
    TOKEN_LESS_THAN = ((usize)(32llu));
    TOKEN_GREATER_THAN_EQUAL = ((usize)(33llu));
    TOKEN_GREATER_THAN = ((usize)(34llu));
    TOKEN_PERCENT = ((usize)(35llu));
    TOKEN_PIPE_SINGLE = ((usize)(36llu));
    TOKEN_PIPE_DOUBLE = ((usize)(37llu));
    TOKEN_DOTDOT = ((usize)(38llu));
    TOKEN_DOTDOTDOT = ((usize)(39llu));
    TOKEN_CARET = ((usize)(40llu));
    TOKEN_WILDCARD = ((usize)(41llu));
    PRIM_TYPE_COUNT = ((usize)(15llu));
    types = ((TypeArena_s){0});
    debugTypes = ((LLVMMetadataArena_s){0});
    type_info_table = (NULL);
    ARENA_SIZE_SMALL = ((usize)(16llu));
    ARENA_SIZE_MEDIUM = ((usize)(128llu));
    ARENA_SIZE_LARGE = ((usize)(1024llu));
    ARENA_SIZE_HUGE = ((usize)(8192llu));
    ELSE_BIT = ((pow2uszrusz)(((usize)(20llu))));
    KEYWORD_LET = ((BUILD_A_KEYWORDPcrS7720)(("let")));
    KEYWORD_COMPTIME = ((BUILD_A_KEYWORDPcrS7720)(("comptime")));
    KEYWORD_FUNC = ((BUILD_A_KEYWORDPcrS7720)(("func")));
    KEYWORD_STRUCT = ((BUILD_A_KEYWORDPcrS7720)(("struct")));
    KEYWORD_ENUM = ((BUILD_A_KEYWORDPcrS7720)(("enum")));
    KEYWORD_UNION = ((BUILD_A_KEYWORDPcrS7720)(("union")));
    KEYWORD_RETURN = ((BUILD_A_KEYWORDPcrS7720)(("return")));
    KEYWORD_MODULE = ((BUILD_A_KEYWORDPcrS7720)(("module")));
    KEYWORD_IMPORT = ((BUILD_A_KEYWORDPcrS7720)(("import")));
    KEYWORD_IF = ((BUILD_A_KEYWORDPcrS7720)(("if")));
    KEYWORD_ELSE = ((BUILD_A_KEYWORDPcrS7720)(("else")));
    KEYWORD_WHILE = ((BUILD_A_KEYWORDPcrS7720)(("while")));
    KEYWORD_SIZEOF = ((BUILD_A_KEYWORDPcrS7720)(("sizeof")));
    KEYWORD_AS = ((BUILD_A_KEYWORDPcrS7720)(("as")));
    KEYWORD_FOR = ((BUILD_A_KEYWORDPcrS7720)(("for")));
    KEYWORD_BREAK = ((BUILD_A_KEYWORDPcrS7720)(("break")));
    KEYWORD_CONTINUE = ((BUILD_A_KEYWORDPcrS7720)(("continue")));
    KEYWORD_NULL = ((BUILD_A_KEYWORDPcrS7720)(("null")));
    KEYWORD_BLANK = ((BUILD_A_KEYWORDPcrS7720)(("blank")));
    KEYWORD_TRUE = ((BUILD_A_KEYWORDPcrS7720)(("true")));
    KEYWORD_FALSE = ((BUILD_A_KEYWORDPcrS7720)(("false")));
    KEYWORD_CONFIG = ((BUILD_A_KEYWORDPcrS7720)(("config")));
    KEYWORD_MATCH = ((BUILD_A_KEYWORDPcrS7720)(("match")));
    KEYWORD_ASM = ((BUILD_A_KEYWORDPcrS7720)(("asm")));
    KEYWORD_TYPEINFO = ((BUILD_A_KEYWORDPcrS7720)(("type_info")));
    ERROR_INVALID = ((usize)(0llu));
    ERROR_NO_SUCH_MODULE = ((usize)(1llu));
    ERROR_NO_SUCH_IDENTIFIER = ((usize)(2llu));
    ERROR_NO_SUCH_FUNCTION = ((usize)(3llu));
    ERROR_NO_SUCH_METHOD = ((usize)(4llu));
    ERROR_NO_SUCH_TYPE = ((usize)(5llu));
    ERROR_USE_BEFORE_DECLARATION = ((usize)(6llu));
    ERROR_FIELD_COUNT_MISMATCH = ((usize)(7llu));
    ERROR_INDEXED_TYPE_MISMATCH = ((usize)(8llu));
    ERROR_UNEXPECTED_LITERAL = ((usize)(9llu));
    ERROR_ARRAY_SIZE_MISMATCH = ((usize)(10llu));
    ERROR_TYPE_MISMATCH = ((usize)(11llu));
    ERROR_INVALID_POINTER_ARITHMETIC = ((usize)(12llu));
    ERROR_DUPLICATE_PARAMETER = ((usize)(13llu));
    ERROR_DUPLICATE_FIELD = ((usize)(14llu));
    ERROR_UNKNOWN_FIELD = ((usize)(15llu));
    ERROR_DUPLICATE_FUNCTION = ((usize)(16llu));
    ERROR_NO_CALL_CANDIDATE = ((usize)(17llu));
    ERROR_VARIABLE_REDECLARATION = ((usize)(18llu));
    ERROR_RECURSIVE_TYPE = ((usize)(19llu));
    ERROR_DUPLICATE_METHOD = ((usize)(20llu));
    ERROR_BLANK_FOR_NULL = ((usize)(21llu));
    ERROR_NON_PRIMITIVE_CAST = ((usize)(22llu));
    ERROR_INDEXED_ACCESS_ON_NON_ARRAY = ((usize)(23llu));
    ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT = ((usize)(24llu));
    ERROR_ANY_DEREF = ((usize)(25llu));
    ERROR_MEMBER_ACCESS_NON_STRUCT = ((usize)(26llu));
    ERROR_MEMBER_ACCESS_NO_OPTIONS = ((usize)(27llu));
    ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS = ((usize)(28llu));
    ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS = ((usize)(29llu));
    ERROR_CALL_TO_NON_FUNCTION = ((usize)(30llu));
    ERROR_UNKNOWN_SUBMODULE = ((usize)(31llu));
    ERROR_MODULE_ACCESS_NON_MODULE = ((usize)(32llu));
    ERROR_DEREF_NON_POINTER = ((usize)(33llu));
    ERROR_DUPLICATE_UNION_VARIANT = ((usize)(34llu));
    ERROR_DUPLICATE_UNION_NAME = ((usize)(35llu));
    ERROR_NON_EXHAUSTIVE_MATCH = ((usize)(36llu));
    ERROR_IMPOSSIBLE_PATTERN = ((usize)(37llu));
    ERROR_NULL_NON_PTR = ((usize)(38llu));
    ERROR_FILE_MISSING = ((usize)(39llu));
    ERROR_ASSEMBLY_IN_COMPTIME_CONTEXT = ((usize)(40llu));
    ERROR_NAKED_STATEMENT = ((usize)(41llu));
    ERROR_INVALID_VARIANT_INIT = ((usize)(42llu));
    ERROR_NO_SUCH_VARIANT = ((usize)(43llu));
    ERROR_INFER_FAILED = ((usize)(44llu));
    ERROR_MISSING_TRAMPOLINE = ((usize)(45llu));
    IDENT_NONE = ((u32)(0));
    IDENT_FUNC = ((u32)(1));
    IDENT_VAR = ((u32)(2));
    IDENT_TYPE = ((u32)(3));
    TYPE_LOOKUP_INVALID = ((usize)(0llu));
    TYPE_LOOKUP_STRUCT = ((usize)(1llu));
    TYPE_LOOKUP_UNION = ((usize)(2llu));
    syntaxError = (false);
    needsPrelude = (false);
    needsAssembly = (false);
    needsTypeInfo = (false);
    INSTR_INVALID = ((usize)(0llu));
    INSTR_ALLOCA = ((usize)(1llu));
    INSTR_GET_PARAM = ((usize)(2llu));
    INSTR_STORE = ((usize)(3llu));
    INSTR_FETCH_GLOBAL_PTR = ((usize)(4llu));
    INSTR_FETCH_GLOBAL_VALUE = ((usize)(5llu));
    INSTR_FETCH_COMPTIME_VALUE = ((usize)(6llu));
    INSTR_LOAD_FUNCTION_PTR = ((usize)(7llu));
    INSTR_LOAD = ((usize)(8llu));
    INSTR_MOVE = ((usize)(9llu));
    INSTR_CALL = ((usize)(10llu));
    INSTR_RETURN_EXPR = ((usize)(11llu));
    INSTR_RETURN_VOID = ((usize)(12llu));
    INSTR_LOAD_STRING = ((usize)(13llu));
    INSTR_LOAD_BOOL = ((usize)(14llu));
    INSTR_LOAD_I8 = ((usize)(15llu));
    INSTR_LOAD_U8 = ((usize)(16llu));
    INSTR_LOAD_I16 = ((usize)(17llu));
    INSTR_LOAD_U16 = ((usize)(18llu));
    INSTR_LOAD_I32 = ((usize)(19llu));
    INSTR_LOAD_U32 = ((usize)(20llu));
    INSTR_LOAD_I64 = ((usize)(21llu));
    INSTR_LOAD_U64 = ((usize)(22llu));
    INSTR_LOAD_NULL = ((usize)(23llu));
    INSTR_LOAD_F32 = ((usize)(24llu));
    INSTR_LOAD_F64 = ((usize)(25llu));
    INSTR_LOAD_BLANK = ((usize)(26llu));
    INSTR_COND_BR = ((usize)(27llu));
    INSTR_BR = ((usize)(28llu));
    INSTR_INT_ADD = ((usize)(29llu));
    INSTR_INT_SUB = ((usize)(30llu));
    INSTR_INT_MUL = ((usize)(31llu));
    INSTR_INT_DIV = ((usize)(32llu));
    INSTR_INT_MOD = ((usize)(33llu));
    INSTR_INT_CMP_EQ = ((usize)(34llu));
    INSTR_INT_CMP_NEQ = ((usize)(35llu));
    INSTR_INT_CMP_GT = ((usize)(36llu));
    INSTR_INT_CMP_GTE = ((usize)(37llu));
    INSTR_INT_CMP_LT = ((usize)(38llu));
    INSTR_INT_CMP_LTE = ((usize)(39llu));
    INSTR_FLOAT_ADD = ((usize)(40llu));
    INSTR_FLOAT_SUB = ((usize)(41llu));
    INSTR_FLOAT_MUL = ((usize)(42llu));
    INSTR_FLOAT_DIV = ((usize)(43llu));
    INSTR_FLOAT_MOD = ((usize)(44llu));
    INSTR_FLOAT_CMP_EQ = ((usize)(45llu));
    INSTR_FLOAT_CMP_NEQ = ((usize)(46llu));
    INSTR_FLOAT_CMP_GT = ((usize)(47llu));
    INSTR_FLOAT_CMP_GTE = ((usize)(48llu));
    INSTR_FLOAT_CMP_LT = ((usize)(49llu));
    INSTR_FLOAT_CMP_LTE = ((usize)(50llu));
    INSTR_LOGICAL_NOT = ((usize)(51llu));
    INSTR_LOGICAL_AND = ((usize)(52llu));
    INSTR_LOGICAL_OR = ((usize)(53llu));
    INSTR_BITWISE_AND = ((usize)(54llu));
    INSTR_BITWISE_OR = ((usize)(55llu));
    INSTR_BITWISE_XOR = ((usize)(56llu));
    INSTR_INSERT_VALUE = ((usize)(57llu));
    INSTR_INT_SIGN_EXTEND = ((usize)(58llu));
    INSTR_INT_ZERO_EXTEND = ((usize)(59llu));
    INSTR_INT_TRUNCATE = ((usize)(60llu));
    INSTR_INT_TO_F32 = ((usize)(61llu));
    INSTR_INT_TO_F64 = ((usize)(62llu));
    INSTR_F32_TO_INT = ((usize)(63llu));
    INSTR_F64_TO_INT = ((usize)(64llu));
    INSTR_F32_TO_F64 = ((usize)(65llu));
    INSTR_F64_TO_F32 = ((usize)(66llu));
    INSTR_CREATE_ARRAY = ((usize)(67llu));
    INSTR_CREATE_STRUCT = ((usize)(68llu));
    INSTR_CREATE_UNION = ((usize)(69llu));
    INSTR_PTR_TO_INT = ((usize)(70llu));
    INSTR_INT_TO_PTR = ((usize)(71llu));
    INSTR_GET_FIELD_PTR = ((usize)(72llu));
    INSTR_GET_ELEMENT_PTR = ((usize)(73llu));
    INSTR_UNREACHABLE = ((usize)(74llu));
    INSTR_UNTERMINATED = ((usize)(75llu));
    INSTR_MEMCPY = ((usize)(76llu));
    INSTR_EMIT_ASSEMBLY = ((usize)(77llu));
    INSTR_INTO_IR_VALUE = ((usize)(78llu));
    INSTR_DEBUG_INFO_ALLOCA = ((usize)(79llu));
    INSTR_DEBUG_INFO_PARAM = ((usize)(80llu));
    PARAM_SHIFT = ((usize)(6llu));
    REG_STACK_SIZE = ((usize)(16777216llu));
    STACK_SIZE = ((usize)(4194304llu));
    instrFns = ((array_5236){(evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateAllocaPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetParamPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateStorePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateMovePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCondBrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntAddPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntSubPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntMulPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntModPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatModPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925),
                             (evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925),
                             (evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925),
                             (evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925)});
    RAX = ((GPR_s){.r = ((u8)(0))});
    RCX = ((GPR_s){.r = ((u8)(1))});
    RDX = ((GPR_s){.r = ((u8)(2))});
    RBX = ((GPR_s){.r = ((u8)(3))});
    RSP = ((GPR_s){.r = ((u8)(4))});
    RBP = ((GPR_s){.r = ((u8)(5))});
    RSI = ((GPR_s){.r = ((u8)(6))});
    RDI = ((GPR_s){.r = ((u8)(7))});
    R8 = ((GPR_s){.r = ((u8)(8))});
    R9 = ((GPR_s){.r = ((u8)(9))});
    R10 = ((GPR_s){.r = ((u8)(10))});
    R11 = ((GPR_s){.r = ((u8)(11))});
    R12 = ((GPR_s){.r = ((u8)(12))});
    R13 = ((GPR_s){.r = ((u8)(13))});
    R14 = ((GPR_s){.r = ((u8)(14))});
    R15 = ((GPR_s){.r = ((u8)(15))});
    XMM0 = ((FPR_s){.r = ((u8)(0))});
    XMM1 = ((FPR_s){.r = ((u8)(1))});
    XMM2 = ((FPR_s){.r = ((u8)(2))});
    XMM3 = ((FPR_s){.r = ((u8)(3))});
    XMM4 = ((FPR_s){.r = ((u8)(4))});
    XMM5 = ((FPR_s){.r = ((u8)(5))});
    ADDR_INDIRECT = ((u8)(0));
    ADDR_DISP8 = ((u8)(1));
    ADDR_DISP32 = ((u8)(2));
    ADDR_REG = ((u8)(3));
    DW_ATE_address = ((u32)(1));
    DW_ATE_boolean = ((u32)(2));
    DW_ATE_complex_float = ((u32)(3));
    DW_ATE_float = ((u32)(4));
    DW_ATE_signed = ((u32)(5));
    DW_ATE_signed_char = ((u32)(6));
    DW_ATE_unsigned = ((u32)(7));
    DW_ATE_unsigned_char = ((u32)(8));
    DW_ATE_imaginary_float = ((u32)(9));
    DW_ATE_packed_decimal = ((u32)(10));
    DW_ATE_numeric_string = ((u32)(11));
    DW_ATE_edited = ((u32)(12));
    DW_ATE_signed_fixed = ((u32)(13));
    DW_ATE_unsigned_fixed = ((u32)(14));
    DW_ATE_decimal_float = ((u32)(15));
    DW_ATE_UTF = ((u32)(16));
    DW_ATE_UCS = ((u32)(17));
    DW_ATE_ASCII = ((u32)(18));
    DW_ATE_lo_user = ((u32)(128));
    DW_ATE_hi_user = ((u32)(255));
    FLAG_INVALID = ((usize)(0llu));
    FLAG_STRING = ((usize)(1llu));
    FLAG_BOOL = ((usize)(2llu));
    FLAG_MODE_DEFAULT = ((usize)(0llu));
    FLAG_MODE_SINGLE = ((pow2uszrusz)(((usize)(0llu))));
    FLAG_MODE_MANDATORY = ((pow2uszrusz)(((usize)(1llu))));
    INDENTATION_LEVEL = ((usize)(4llu));
}

#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none C_exiti32rN(i32 code) {
    (((fflush))((NULL)));
    (((exit))((code)));
}
none pushPS6808S0540rN(StringList_s *this, String_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(String_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StringList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
String_s *atPS6808uszrPS0540(StringList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StringList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in StringList.at")));
    return (&((((this)->elements))[(index)]));
}
String_s *lastPS6808rPS0540(StringList_s *this) { return ((atPS6808uszrPS0540)((this), (((this)->length) - ((usize)(1llu))))); }
usize hashPS0540rusz(String_s *this) {
    SubStr_s tmp_127 = ((asSubStrPS0540rS7720)((this)));

    return ((hashPS7720rusz)((&tmp_127)));
}
String_s toAbsolutePathPS0540rS0540(String_s *this) {
    char *buf = (((calloc))(((usize)(1024llu)), ((usize)(1llu))));
    ((assertBrN)(((buf) != (NULL))));
    char *abs = (((realpath))(((this)->buffer), (buf)));
    String_s s = ((newStringFromStrLitPcrS0540)((buf)));
    (((free))((buf)));
    return (s);
}
String_s getFileNamePS0540rS0540(String_s *this) {
    String_s root = ((getRootPS0540rS0540)((this)));
    ((assertBPcrN)((((this)->length) > ((root).length)), ("getFileName: zero-char file name??")));
    SubStr_s tmp_195 = ((substringPS0540uszuszrS7720)((this), ((root).length), ((this)->length)));

    String_s name = ((toStringPS7720rS0540)((&tmp_195)));
    ((dropPS0540rN)((&(root))));
    return (name);
}
String_s getRootPS0540rS0540(String_s *this) {
    String_s c = ((copyPS0540rS0540)((this)));
    while ((((c).length) > ((usize)(0llu))) && (((((c).buffer))[(((c).length) - ((usize)(1llu)))]) != ('/')))
        (((c).length) = (((c).length) - ((usize)(1llu))));
    ((assertBPcrN)((((c).length) != ((usize)(0llu))), ("getRoot: Found no root")));
    return (c);
}
none dropPS0540rN(String_s *this) { (((free))(((this)->buffer))); }
String_s copyPS0540rS0540(String_s *this) {
    Any bfr = (((calloc))(((this)->capacity), (sizeof(char))));
    ((assertBPcrN)(((bfr) != (NULL)), ("Could not copy String")));
    Any _bfr = (((memcpy))((bfr), ((this)->buffer), ((this)->capacity)));
    ((assertBrN)(((_bfr) != (NULL))));
    ((assertBrN)(((bfr) == (_bfr))));
    return ((String_s){.buffer = (bfr), .length = ((this)->length), .capacity = ((this)->capacity)});
}
none resizePS0540uszrN(String_s *this, usize newCap) {
    if ((newCap) < ((usize)(256llu)))
        ((newCap) = ((usize)(256llu)));
    char *old = ((this)->buffer);
    (((this)->buffer) = (((calloc))((newCap), (sizeof(char)))));
    ((assertBPcrN)((((this)->buffer) != (NULL)), ("Could not resize String")));
    (((memcpy))(((this)->buffer), (old), ((this)->length)));
    (((free))((old)));
    (((this)->capacity) = (newCap));
}
none printPS0540rN(String_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        (((printf))(("%c"), (*((char *)((unsigned char *)((this)->buffer) + (i))))));
    }
}
SubStr_s asSubStrPS0540rS7720(String_s *this) { return ((substringPS0540uszuszrS7720)((this), ((usize)(0llu)), ((this)->length))); }
SubStr_s substringPS0540uszuszrS7720(String_s *this, usize start, usize end) { return ((newSubStrOfStringPS0540uszuszrS7720)((this), (start), (end))); }
none pushNumberPS0540uszrN(String_s *this, usize num) {
    array_5858 bfr = ((array_5858){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((snprintf))((NULL), ((usize)(0llu)), ("%llu"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumber()")));
    (((snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("%llu"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberAsHexPS0540uszrN(String_s *this, usize num) {
    array_5858 bfr = ((array_5858){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((snprintf))((NULL), ((usize)(0llu)), ("0x%llX"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumberAsHex()")));
    (((snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("0x%llX"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberPS0540f32rN(String_s *this, f32 i) { ((pushNumberPS0540f64rN)((this), ((f64)((i))))); }
none pushNumberPS0540f64rN(String_s *this, f64 num) {
    array_5858 bfr = ((array_5858){('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
                                   ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    usize length = (((snprintf))((NULL), ((usize)(0llu)), ("%f"), (num)));
    ((assertBPcrN)(((length) < ((usize)(50llu))), ("Buffer Overflow in String.pushNumber()")));
    (((snprintf))((&(bfr)), ((length) + ((usize)(1llu))), ("%f"), (num)));
    for (usize i = ((usize)(0llu)); ((i) < (length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((this), (((bfr).arr)[(i)])));
    }
}
none pushNumberPS0540u8rN(String_s *this, u8 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u16rN(String_s *this, u16 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u32rN(String_s *this, u32 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540u64rN(String_s *this, u64 i) { ((pushNumberPS0540uszrN)((this), ((usize)((i))))); }
none pushNumberPS0540i8rN(String_s *this, i8 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i16rN(String_s *this, i16 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i32rN(String_s *this, i32 i) { ((pushNumberPS0540i64rN)((this), ((i64)((i))))); }
none pushNumberPS0540i64rN(String_s *this, i64 i) {
    if ((i) < ((i64)(0ll))) {
        ((pushCharPS0540crN)((this), ('-')));
        ((i) = (-(i)));
    }

    ((pushNumberPS0540uszrN)((this), ((usize)((i)))));
}
none pushCharPS0540crN(String_s *this, char ch) {
    if ((((this)->length) >= ((this)->capacity)) || (((this)->capacity) < ((usize)(256llu)))) {
        ((resizePS0540uszrN)((this), (((usize)(2llu)) * ((this)->capacity))));
    }

    (((((this)->buffer))[((this)->length)]) = (ch));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushHexPS0540u8rN(String_s *this, u8 hex) {
    u8 lower = ((hex) % ((u8)(16)));
    u8 upper = (((hex) / ((u8)(16))) % ((u8)(16)));
    ((assertBrN)(((lower) < ((u8)(16)))));
    ((assertBrN)(((upper) < ((u8)(16)))));
    ((pushCharPS0540crN)((this), ('\\')));
    ((pushCharPS0540crN)((this), ('x')));
    ((pushCharPS0540crN)((this), (((HEX_CHAR).arr)[((usize)((upper)))])));
    ((pushCharPS0540crN)((this), (((HEX_CHAR).arr)[((usize)((lower)))])));
}
none pushSubStrPS0540PS7720rN(String_s *this, SubStr_s *sub) {
    usize newLen = (((this)->length) + ((sub)->len));
    if ((newLen) >= ((this)->capacity))
        ((resizePS0540uszrN)((this), ((newLen) + ((usize)(32llu)))));
    (((memcpy))(((char *)((unsigned char *)((this)->buffer) + (((this)->length) * (sizeof(char))))), ((sub)->start), ((sub)->len)));
    (((this)->length) = (newLen));
}
none pushStringPS0540PS0540rN(String_s *this, String_s *s) {
    SubStr_s tmp_718 = ((asSubStrPS0540rS7720)((s)));

    ((pushSubStrPS0540PS7720rN)((this), (&tmp_718)));
}
none pushStrPS0540PcrN(String_s *this, char *s) {
    usize _len = (((strlen))((s)));
    SubStr_s tmp_730 = ((SubStr_s){.start = (s), .len = (_len)});

    ((pushSubStrPS0540PS7720rN)((this), (&tmp_730)));
}
bool isNumberPS0540rB(String_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        if ((ch) == ('\0')) {
            break;
        }

        if (!((isNumericcrB)((ch)))) {
            return (false);
        }
    }

    return (((this)->length) > ((usize)(0llu)));
}
i64 toI64PS0540ri64(String_s *this) {
    ((assertBPcrN)(((isNumberPS0540rB)((this))), ("not a number")));
    i64 val = ((i64)(0ll));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        i64 digit = ((i64)(((ch) - ('0'))));
        ((val) = ((((i64)(10ll)) * (val)) + (digit)));
    }

    return (val);
}
u64 toU64PS0540ru64(String_s *this) {
    ((assertBPcrN)(((isNumberPS0540rB)((this))), ("not a number")));
    u64 val = ((u64)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->buffer))[(i)]);
        u64 digit = ((u64)(((ch) - ('0'))));
        ((val) = ((((u64)(10llu)) * (val)) + (digit)));
    }

    return (val);
}
none replacePS0540ccrN(String_s *this, char what, char with) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->buffer))[(i)]) == (what))
            (((((this)->buffer))[(i)]) = (with));
    }
}
StringList_s splitByPS0540FB_cPuszrS6808(String_s *this, bool (*pred)(char, usize *)) {
    StringList_s list = ((StringList_s){0});
    usize last = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        usize skip = ((usize)(0llu));
        if ((pred)(((((this)->buffer))[(i)]), (&(skip)))) {
            SubStr_s _s = ((substringPS0540uszuszrS7720)((this), (last), (i)));
            ((pushPS6808S0540rN)((&(list)), ((toStringPS7720rS0540)((&(_s))))));
            ((i) = ((i) + (skip)));
            ((last) = (i));
        }
    }

    if ((last) != ((this)->length)) {
        SubStr_s _s = ((substringPS0540uszuszrS7720)((this), (last), ((this)->length)));
        ((pushPS6808S0540rN)((&(list)), ((toStringPS7720rS0540)((&(_s))))));
    }

    return (list);
}
bool equalsPS0540PS0540rB(String_s *this, String_s *other) {
    if (((this)->length) != ((other)->length))
        return (false);
    SubStr_s tmp_935 = ((asSubStrPS0540rS7720)((this)));
    SubStr_s tmp_939 = ((asSubStrPS0540rS7720)((other)));

    return ((equalsPS7720PS7720rB)((&tmp_935), (&tmp_939)));
}
String_s newStringrS0540(none) {
    usize cap = ((usize)(16llu));
    Any _m = (((calloc))((cap), (sizeof(char))));
    char *buff = ((char *)((_m)));
    return ((String_s){.buffer = (buff), .length = ((usize)(0llu)), .capacity = ((usize)(16llu))});
}
String_s newReadonlyStringPcrS0540(char *s) { return ((String_s){.buffer = (s), .length = ((comptimeStrlenPcrusz)((s))), .capacity = ((comptimeStrlenPcrusz)((s)))}); }
String_s newStringFromStrLitPcrS0540(char *s) {
    usize len = (((strlen))((s)));
    char *buff = (((calloc))(((len) + ((usize)(1llu))), (sizeof(char))));
    ((assertBrN)(((buff) != (NULL))));
    (((memcpy))((buff), (s), (len)));
    return ((String_s){.buffer = ((char *)((buff))), .length = (len), .capacity = (len)});
}
bool canReadFileToStringPcPS0540rB(char *path, String_s *source) {
    Any file = (((fopen))((path), ("rb")));
    if ((file) == (NULL)) {
        return (false);
    }

    array_6016 buf = ((array_6016){
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    while (true) {
        usize size = (((fread))((&(buf)), ((usize)(1llu)), ((usize)(1024llu)), (file)));
        if ((size) == ((usize)(0llu))) {
            break;
        }

        for (usize i = ((usize)(0llu)); ((i) < (size)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushCharPS0540crN)((source), (((buf).arr)[(i)])));
        }
    }

    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
    return (true);
}
String_s readFileToStringPcrS0540(char *path) {
    String_s s = ((newStringrS0540)());
    Any file = (((fopen))((path), ("rb")));
    if ((file) == (NULL)) {
        (((fprintf))((stderr_), ("error: Could not open file `%s`.\n"), (path)));
        (((C_exiti32rN))(((i32)(1))));
    }

    array_6016 buf = ((array_6016){
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'),
        ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0'), ('\0')});
    while (true) {
        usize size = (((fread))((&(buf)), ((usize)(1llu)), ((usize)(1024llu)), (file)));
        if ((size) == ((usize)(0llu))) {
            break;
        }

        for (usize i = ((usize)(0llu)); ((i) < (size)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushCharPS0540crN)((&(s)), (((buf).arr)[(i)])));
        }
    }

    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
    return (s);
}
none writeStringToFilePcS0540rN(char *path, String_s s) {
    Any file = (((fopen))((path), ("wb")));
    if ((file) == (NULL)) {
        (((fprintf))((stderr_), ("error: Could not open file `%s`.\n"), (path)));
        (((C_exiti32rN))(((i32)(1))));
    }

    usize size = (((fwrite))(((s).buffer), ((usize)(1llu)), ((s).length), (file)));
    ((assertBrN)(((((fclose))((file))) == ((i32)(0)))));
}
bool isEmptyPS7720rB(SubStr_s *this) { return (((this)->start) == (NULL)); }
usize hashPS7720uszrusz(SubStr_s *this, usize length) {
    usize d = ((powuszuszrusz)(((usize)(10llu)), (length)));
    return (((hashPS7720rusz)((this))) % (d));
}
usize hashPS7720rusz(SubStr_s *this) {
    usize hash = ((usize)(5381llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        ((hash) = ((((shiftLeftuszuszrusz)((hash), ((usize)(5llu)))) + (hash)) + ((usize)(((((this)->start))[(i)])))));
    }

    return (hash);
}
u8 lexOrderPS7720PS7720ru8(SubStr_s *this, SubStr_s *other) {
    if (((this)->len) < ((other)->len)) {
        return (ORDER_LESS);
    }

    if (((this)->len) > ((other)->len)) {
        return (ORDER_GREATER);
    }

    usize l = ((this)->len);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c1 = ((((this)->start))[(i)]);
        char c2 = ((((other)->start))[(i)]);
        if ((c1) < (c2)) {
            return (ORDER_LESS);
        }

        if ((c1) > (c2)) {
            return (ORDER_GREATER);
        }
    }

    return (ORDER_EQUAL);
}
bool equalsPS7720PS7720rB(SubStr_s *this, SubStr_s *other) {
    if (((this)->len) != ((other)->len)) {
        return (false);
    }

    usize l = ((this)->len);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c1 = ((((this)->start))[(i)]);
        char c2 = ((((other)->start))[(i)]);
        if ((c1) != (c2)) {
            return (false);
        }
    }

    return (true);
}
none printPS7720rN(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char p = ((((this)->start))[(i)]);
        ((assertBPcrN)(((p) == (((putchar))((p)))), ("Wrote wrong character in SubStr.print")));
    }
}
String_s getPathParentPS7720rS0540(SubStr_s *this) {
    String_s s = ((toStringPS7720rS0540)((this)));
    while (((s).length) > ((usize)(0llu))) {
        char c = ((((s).buffer))[(((s).length) - ((usize)(1llu)))]);
        if (((c) == ('/')) || ((c) == ('\\'))) {
            break;
        }

        ((pushCharPS0540crN)((&(s)), ('\0')));
        (((s).length) = (((s).length) - ((usize)(2llu))));
    }

    return (s);
}
String_s toStringPS7720rS0540(SubStr_s *this) {
    Any buf = (((calloc))((((this)->len) + ((usize)(1llu))), (sizeof(char))));
    ((assertBPcrN)(((buf) != (NULL)), ("toString(SubStr)")));
    (((memcpy))((buf), ((this)->start), ((this)->len)));
    return ((String_s){.buffer = (buf), .length = ((this)->len), .capacity = (((this)->len) + ((usize)(1llu)))});
}
bool beginsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *prefix) {
    if (((prefix)->len) > ((this)->len))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((prefix)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[(i)]) != ((((prefix)->start))[(i)])) {
            return (false);
        }
    }

    return (true);
}
bool endsWithPS7720PS7720rB(SubStr_s *this, SubStr_s *suffix) {
    if (((suffix)->len) > ((this)->len))
        return (false);
    usize offset = (((this)->len) - ((suffix)->len));
    for (usize i = ((usize)(0llu)); ((i) < ((suffix)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[((offset) + (i))]) != ((((suffix)->start))[(i)])) {
            return (false);
        }
    }

    return (true);
}
none skipUntilPS7720FBcrN(SubStr_s *this, bool (*pred)(char)) {
    while (((this)->len) > ((usize)(0llu))) {
        if (!((pred)(((((this)->start))[((usize)(0llu))])))) {
            ((advancePS7720rN)((this)));
        }

        else {
            break;
        }
    }
}
SubStr_s splitNextPS7720FBcrS7720(SubStr_s *this, bool (*pred)(char)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((pred)(((((this)->start))[(i)]))) {
            SubStr_s _s1 = ((substringPS7720uszuszrS7720)((this), ((usize)(0llu)), (i)));
            ((advancePS7720uszrN)((this), (i)));
            return (_s1);
        }
    }

    return (*(this));
}
none advancePS7720rN(SubStr_s *this) { ((advancePS7720uszrN)((this), ((usize)(1llu)))); }
none advancePS7720uszrN(SubStr_s *this, usize step) {
    ((assertBPcrN)(((step) <= ((this)->len)), ("SubStr.advance: Step too big!")));
    (((this)->start) = ((char *)((unsigned char *)((this)->start) + (step))));
    (((this)->len) = (((this)->len) - (step)));
}
SubStr_s substringPS7720uszuszrS7720(SubStr_s *this, usize start, usize end) {
    ((assertBPcrN)(((end) <= ((this)->len)), ("Index out of bounds for String Substring.")));
    ((assertBPcrN)((((end) - (start)) <= ((this)->len)), ("Invalid length for String Substring.")));
    return ((newSubStrPcuszuszrS7720)(((this)->start), (start), (end)));
}
bool hasSpacePS7720rB(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((this)->start))[(i)]) == (' ')) {
            return (true);
        }
    }

    return (false);
}
bool isNumberPS7720rB(SubStr_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->start))[(i)]);
        if ((ch) == ('\0')) {
            break;
        }

        if (!((isNumericcrB)((ch)))) {
            return (false);
        }
    }

    return (((this)->len) > ((usize)(0llu)));
}
u64 toU64PS7720ru64(SubStr_s *this) {
    ((assertBPcrN)(((isNumberPS7720rB)((this))), ("not a number")));
    u64 val = ((u64)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->len)); ((i) = ((i) + ((usize)(1llu))))) {
        char ch = ((((this)->start))[(i)]);
        u64 digit = ((u64)(((ch) - ('0'))));
        ((val) = ((((u64)(10llu)) * (val)) + (digit)));
    }

    return (val);
}
f64 toF64PS7720rf64(SubStr_s *this) { return ((f64)(((toU64PS7720ru64)((this))))); }
SubStr_s newSubStrOfStrLitPcrS7720(char *orig) { return ((newSubStrPcuszuszrS7720)((orig), ((usize)(0llu)), ((comptimeStrlenPcrusz)((orig))))); }
SubStr_s newSubStrPcuszuszrS7720(char *orig, usize start, usize end) { return ((SubStr_s){.start = ((char *)((unsigned char *)(orig) + (start))), .len = ((end) - (start))}); }
SubStr_s newSubStrOfStringPS0540uszuszrS7720(String_s *orig, usize start, usize end) {
    return ((SubStr_s){.start = ((char *)((unsigned char *)((orig)->buffer) + (start))), .len = ((end) - (start))});
}
SubStr_s defaultSubStrrS7720(none) {
    char *s = ("You are not supposed to read this. Please issue a bug report.");
    usize l = (((strlen))((s)));
    return ((newSubStrPcuszuszrS7720)((s), ((usize)(0llu)), (l)));
}
u8 tagAnyru8(Any union_) { return (*((u8 *)((union_)))); }
SubStr_s comptimeSubStrPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
none setupStdHandlesrN(none) {
    if (done)
        return;
    if ((stdin_) == (NULL))
        ((stdin_) = (((fdopen))(((i32)(0)), ("a"))));
    ((_assertBPcrN)(((stdin_) != (NULL)), ("Could not initialize STDIN!")));
    if ((stdout_) == (NULL))
        ((stdout_) = (((fdopen))(((i32)(1)), ("a"))));
    ((_assertBPcrN)(((stdout_) != (NULL)), ("Could not initialize STDOUT!")));
    if ((stderr_) == (NULL))
        ((stderr_) = (((fdopen))(((i32)(2)), ("a"))));
    ((_assertBPcrN)(((stderr_) != (NULL)), ("Could not initialize STDERR!")));
    ((done) = (true));
}
usize comptimeStrlenPcrusz(char *str) {
    usize len = ((usize)(0llu));
    while ((*((char *)((unsigned char *)(str) + (len)))) != ('\0'))
        ((len) = ((len) + ((usize)(1llu))));
    return (len);
}
usize pow2uszrusz(usize exp) {
    usize result = ((usize)(1llu));
    while ((exp) > ((usize)(0llu))) {
        ((result) = ((result) * ((usize)(2llu))));
        ((exp) = ((exp) - ((usize)(1llu))));
    }

    return (result);
}
usize powuszuszrusz(usize base, usize exp) {
    usize result = ((usize)(1llu));
    while ((exp) > ((usize)(0llu))) {
        ((result) = ((result) * (base)));
        ((exp) = ((exp) - ((usize)(1llu))));
    }

    return (result);
}
usize shiftLeftuszuszrusz(usize base, usize bits) {
    while ((bits) > ((usize)(0llu))) {
        ((base) = ((base) * ((usize)(2llu))));
        ((bits) = ((bits) - ((usize)(1llu))));
    }

    return (base);
}
usize shiftRightuszuszrusz(usize base, usize bits) {
    while ((bits) > ((usize)(0llu))) {
        ((base) = ((base) / ((usize)(2llu))));
        ((bits) = ((bits) - ((usize)(1llu))));
    }

    return (base);
}
usize bitCountuszrusz(usize val) {
    usize r = ((usize)(0llu));
    while ((val) > ((usize)(0llu))) {
        ((val) = ((shiftRightuszuszrusz)((val), ((usize)(1llu)))));
        ((r) = ((r) + ((usize)(1llu))));
    }

    return (r);
}
bool isNumericcrB(char ch) {
    u8 _u8 = ((u8)((ch)));
    return (((_u8) >= ((u8)(48))) && ((_u8) <= ((u8)(57))));
}
bool isAlphabeticcrB(char ch) {
    u8 _u8 = ((u8)((ch)));
    return ((((_u8) >= ((u8)(65))) && ((_u8) <= ((u8)(90)))) || (((_u8) >= ((u8)(97))) && ((_u8) <= ((u8)(122)))));
}
u8 asHexcru8(char ch) {
    ((assertBPcrN)(((isHexDigitcrB)((ch))), ("can\'t convert non-hex value to hex")));
    u8 v = ((u8)(0));
    if ((isNumericcrB)((ch)))
        ((v) = (((u8)((ch))) - ((u8)(48))));
    else if ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(70))))
        ((v) = (((u8)((ch))) - ((u8)(55))));
    else if ((((u8)((ch))) >= ((u8)(97))) && (((u8)((ch))) <= ((u8)(102))))
        ((v) = (((u8)((ch))) - ((u8)(87))));
    ((assertBPcrN)(((v) < ((u8)(16))), ("hex out of bounds")));
    return (v);
}
bool isHexDigitcrB(char ch) { return ((((isNumericcrB)((ch))) || ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(70))))) || ((((u8)((ch))) >= ((u8)(97))) && (((u8)((ch))) <= ((u8)(102))))); }
bool isWhitespacecrB(char ch) { return (((((ch) == (' ')) || ((ch) == ('\r'))) || ((ch) == ('\n'))) || ((ch) == ('\t'))); }
bool isAlphanumericcrB(char ch) { return (((isAlphabeticcrB)((ch))) || ((isNumericcrB)((ch)))); }
bool isAsciiUppercasecrB(char ch) { return ((((u8)((ch))) >= ((u8)(65))) && (((u8)((ch))) <= ((u8)(90)))); }
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none index_oobPci64rN(char* msg, i64 index) {
    ((setupStdHandlesrN)());
    (((fprintf))((stderr_), (msg), (index)));
    (((C_exiti32rN))(((i32)(2))));
}
none _empty_assertBrN(bool cond) {}
none _empty_assertBPcrN(bool cond, char *msg) {}
none assertBrN(bool cond) {
    if (!(cond)) {
        ((setupStdHandlesrN)());
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED\n")));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED\n")));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
none _assertBPcrN(bool cond, char *msg) {
    if (!(cond)) {
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED: %s\n"), (msg)));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED: %s\n"), (msg)));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
none assertBPcrN(bool cond, char *msg) {
    if (!(cond)) {
        ((setupStdHandlesrN)());
        if ((stderr_) == (NULL)) {
            (((printf))(("ASSERTION FAILED: %s\n"), (msg)));
            (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
        }

        else {
            (((fprintf))((stderr_), ("ASSERTION FAILED: %s\n"), (msg)));
        }

        (((C_exiti32rN))(((i32)(2))));
    }
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablerN(none) {
    ((unreachablePcrN)(("Explicit call to unreachable()")));
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none unreachablePcrN(char* msg) {
    ((setupStdHandlesrN)());
    if ((stderr_) == (NULL)) {
        (((printf))(("%s Entered unreachable code: %s"), (FATAL_STR), (msg)));
        (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
    }

    else {
        (((fprintf))((stderr_), ("%s Entered unreachable code: %s\n"), (FATAL_STR), (msg)));
    }

    (((C_exiti32rN))(((i32)(2))));
}
#if defined(__clang__) || defined(__GNUC__)
__attribute__((noreturn))
#elif defined(_WIN32)
__declspec(noreturn)
#else
#error "Can't mark function as noreturn on your compiler. PRs welcome."
#endif
none todo_with_msgPcrN(char* msg) {
    ((setupStdHandlesrN)());
    if ((stderr_) == (NULL)) {
        (((printf))(("TODO: %s\n"), (msg)));
        (((printf))(("%s Could not print to STDERR because STDERR is NULL!\n"), (FATAL_STR)));
    }

    else {
        (((fprintf))((stderr_), ("TODO: %s\n"), (msg)));
    }

    (((C_exiti32rN))(((i32)(2))));
}
none warningPcrN(char *msg) {
    if (!(PRINT_WARNING))
        return;
    (((fprintf))((stderr_), ("\x1B[93m[WARNING]\x1B[0m %s\n"), (msg)));
}
none resizePS6678uszrN(StringBuffer_s *this, usize newCap) {
    Any _new = (((realloc))(((this)->data), ((newCap) * (sizeof(SubStr_s)))));
    ((assertBrN)(((_new) != (NULL))));
    (((this)->data) = ((SubStr_s *)((_new))));
    (((this)->capacity) = (newCap));
}
none addPS6678S7720rN(StringBuffer_s *this, SubStr_s str) {
    if (((this)->length) >= ((this)->capacity))
        ((resizePS6678uszrN)((this), (((usize)(2llu)) * ((this)->capacity))));
    ((*((SubStr_s *)((unsigned char *)((this)->data) + (((this)->length) * (sizeof(SubStr_s)))))) = (str));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
char *getNthAsCharPtrPS6678uszrPc(StringBuffer_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StringBuf.getNthAsCharPtr()")));
    return ((*((SubStr_s *)((unsigned char *)((this)->data) + ((index) * (sizeof(SubStr_s)))))).start);
}
none extendPS6678PS6678rN(StringBuffer_s *this, StringBuffer_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((addPS6678S7720rN)((this), (*((SubStr_s *)((unsigned char *)((other)->data) + ((i) * (sizeof(SubStr_s))))))));
    }
}
String_s toCmdStringPS6678rS0540(StringBuffer_s *this) {
    String_s s = ((newStringrS0540)());
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s str = (*((SubStr_s *)((unsigned char *)((this)->data) + ((i) * (sizeof(SubStr_s))))));
        if ((hasSpacePS7720rB)((&(str)))) {
            ((pushCharPS0540crN)((&(s)), ('\"')));
            ((pushSubStrPS0540PS7720rN)((&(s)), (&(str))));
            ((pushCharPS0540crN)((&(s)), ('\"')));
        }

        else {
            ((pushSubStrPS0540PS7720rN)((&(s)), (&(str))));
        }

        if ((i) != (((this)->length) - ((usize)(1llu))))
            ((pushCharPS0540crN)((&(s)), (' ')));
    }

    return (s);
}
StringBuffer_s newStringBufferrS6678(none) {
    Any _bfr = (((calloc))((INITIAL_STRINGBUFFER_CAP), (sizeof(SubStr_s))));
    SubStr_s *_data = ((SubStr_s *)((_bfr)));
    return ((StringBuffer_s){.data = (_data), .length = ((usize)(0llu)), .capacity = (INITIAL_STRINGBUFFER_CAP)});
}
bool isNullS9457rB(Handle_s h) { return (((h).ptr) == ((usize)(0llu))); }
bool WIFSIGNALEDi32rB(i32 Status) { return (((((Status) & ((i32)(127))) + ((i32)(1))) / ((i32)(2))) > ((i32)(0))); }
bool WIFEXITEDi32rB(i32 Status) { return (((WTERMSIGi32ri32)((Status))) == ((i32)(0))); }
i32 WTERMSIGi32ri32(i32 Status) { return ((Status) & ((i32)(127))); }
i32 WEXITSTATUSi32ri32(i32 Status) { return (((Status) & ((i32)(65280))) / ((i32)(256))); }
Handle_s dlopenPci32rS9457(char *filename, i32 flags) { return ((Handle_s){.ptr = ((usize)(((Any)(((dlopen)((filename), (flags)))))))}); }
Handle_s dlsymS9457PcrS9457(Handle_s handle, char *symbol) { return ((Handle_s){.ptr = ((usize)(((dlsym)(((Any)(((handle).ptr))), (symbol)))))}); }
i32 *errnorPi32(none) { return ((__errno_location)()); }
usize getLastModifiedPcrusz(char *filePath) {
    Stat_s statbuf = ((Stat_s){0});
    if (((stat)((filePath), (&(statbuf)))) < ((i32)(0))) {
        if ((*((errnorPi32)())) == (ENOENT))
            return ((usize)(0llu));
        (((fprintf))((stderr_), ("[ERROR] Could not get time of %s: %#010x\n"), (filePath), ((strerror)((*((errnorPi32)()))))));
        return ((usize)(0llu));
    }

    return ((usize)(((statbuf).st_mtime)));
}
bool waitForProcessS9457rB(Handle_s proc) {
    if (((proc).ptr) == ((INVALID_HANDLE).ptr))
        return (false);
    while (true) {
        i32 wstatus = ((i32)(0));
        if (((waitpid)((proc), (&(wstatus)), ((i32)(0)))) < ((i32)(0))) {
            (((fprintf))((stderr_), ("[ERROR] Could not wait on command (pid %d): %s\n"), (proc), ((strerror)((*((errnorPi32)()))))));
            return (false);
        }

        if ((WIFEXITEDi32rB)((wstatus))) {
            i32 exit_status = ((WEXITSTATUSi32ri32)((wstatus)));
            if ((exit_status) != ((i32)(0))) {
                (((fprintf))((stderr_), ("[ERROR] Command exited with exit code %d\n"), (exit_status)));
                return (false);
            }

            break;
        }

        if ((WIFSIGNALEDi32rB)((wstatus))) {
            (((fprintf))((stderr_), ("[ERROR] Command process was terminated by %s\n"), ((strsignal)(((WTERMSIGi32ri32)((wstatus)))))));
            return (false);
        }
    }

    return (true);
}
bool dirExistsPcrB(char *path) {
    Stat_s statbuf = ((Stat_s){0});
    if (((stat)((path), (&(statbuf)))) < ((i32)(0))) {
        if ((*((errnorPi32)())) == (ENOENT))
            return (false);
    }

    return (true);
}
bool runCmdSyncS3657rB(Cmd_s cmd) {
    Handle_s proc = ((runCmdAsyncS3657rS9457)((cmd)));
    if (((proc).ptr) == ((INVALID_HANDLE).ptr))
        return (false);
    return ((waitForProcessS9457rB)((proc)));
}
Handle_s runCmdAsyncS3657rS9457(Cmd_s cmd) {
    i32 cpid = ((fork)());
    if ((cpid) < ((i32)(0))) {
        (((fprintf))((stderr_), ("[ERROR] Could not fork child process: %s\n"), ((strerror)((*((errnorPi32)()))))));
        return (INVALID_HANDLE);
    }

    if ((cpid) == ((i32)(0))) {
        String_s str = ((toStringPS3657rS0540)((&(cmd))));
        ((pushCharPS0540crN)((&(str)), ('\0')));
        if ((cmd).log) {
            (((printf))(("[CMD] %s\n"), ((str).buffer)));
        }

        String_s progName = ((toStringPS7720rS0540)((&(((((cmd).buf).data))[((usize)(0llu))]))));
        char **args = ((asCharPtrsPS3657rPPc)((&(cmd))));
        if (((execvp)(((char *)(((progName).buffer))), (args))) < ((i32)(0))) {
            (((fprintf))((stderr_), ("[ERROR] Could not exec child process: %s\n"), ((strerror)((*((errnorPi32)()))))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((unreachablePcrN)(("execvp")));
    }

    return ((Handle_s){.ptr = ((usize)((cpid)))});
}
none addPS3657PcrN(Cmd_s *this, char *arg) { ((addPS6678S7720rN)((&((this)->buf)), ((newSubStrOfStrLitPcrS7720)((arg))))); }
none addSubStrPS3657S7720rN(Cmd_s *this, SubStr_s arg) { ((addPS6678S7720rN)((&((this)->buf)), (arg))); }
none addManyPS3657S6678rN(Cmd_s *this, StringBuffer_s args) { ((extendPS6678PS6678rN)((&((this)->buf)), (&(args)))); }
bool runSyncPS3657rB(Cmd_s *this) { return ((runCmdSyncS3657rB)((*(this)))); }
Handle_s runAsyncPS3657rS9457(Cmd_s *this) { return ((runCmdAsyncS3657rS9457)((*(this)))); }
String_s toStringPS3657rS0540(Cmd_s *this) { return ((toCmdStringPS6678rS0540)((&((this)->buf)))); }
char **asCharPtrsPS3657rPPc(Cmd_s *this) {
    Any _any = (((calloc))(((((this)->buf).length) + ((usize)(1llu))), (sizeof(char *))));
    ((assertBrN)(((_any) != (NULL))));
    char **_mut = ((char **)((_any)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->buf).length)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s elem = ((toStringPS7720rS0540)(((SubStr_s *)((unsigned char *)(((this)->buf).data) + ((i) * (sizeof(SubStr_s)))))));
        ((*((char **)((unsigned char *)(_mut) + ((i) * (sizeof(char *)))))) = ((char *)(((elem).buffer))));
    }

    return ((char **)((_any)));
}
Cmd_s newCmdrS3657(none) { return ((Cmd_s){.buf = ((newStringBufferrS6678)())}); }
Cmd_s newCmdFromStrLitPcrS3657(char *command) {
    Cmd_s cmd = ((newCmdrS3657)());
    usize pos = ((usize)(0llu));
    usize len = (((strlen))((command)));
    while ((pos) < (len)) {
        char *nextSpace = (((strchr))((command), (' ')));
        if ((nextSpace) == (NULL))
            break;
        usize offset = ((usize)((unsigned char *)(nextSpace) - (unsigned char *)(command)));
        SubStr_s substr = ((newSubStrPcuszuszrS7720)((command), ((usize)(0llu)), (offset)));
        ((addSubStrPS3657S7720rN)((&(cmd)), (substr)));
        ((command) = ((char *)((unsigned char *)((char *)((unsigned char *)(command) + (offset))) + ((usize)(1llu)))));
        ((pos) = (((pos) + (offset)) + ((usize)(1llu))));
    }

    if ((pos) < (len)) {
        SubStr_s rest = ((newSubStrPcuszuszrS7720)((command), ((usize)(0llu)), (((strlen))((command)))));
        ((addSubStrPS3657S7720rN)((&(cmd)), (rest)));
    }

    return (cmd);
}
bool moveFilePcPcrB(char *from, char *to) {
    Cmd_s moveCmd = ((newCmdFromStrLitPcrS3657)(("mv")));
    ((addPS3657PcrN)((&(moveCmd)), (from)));
    ((addPS3657PcrN)((&(moveCmd)), (to)));
    return ((runSyncPS3657rB)((&(moveCmd))));
}
bool deleteFilePcrB(char *path) {
    Cmd_s delCmd = ((newCmdFromStrLitPcrS3657)(("rm")));
    ((addPS3657PcrN)((&(delCmd)), (path)));
    return ((runSyncPS3657rB)((&(delCmd))));
}
bool LLVM_isNullS3482rB(LLVM_TargetMachineOptionsRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS5038rB(LLVM_TargetMachineRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3497rB(LLVM_TargetRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6307rB(LLVM_TargetDataRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS4183rB(LLVM_ContextRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3816rB(LLVM_ModuleRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS3273rB(LLVM_BuilderRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6239rB(LLVM_BasicBlockRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS1407rB(LLVM_ValueRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS6708rB(LLVM_TypeRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS8710rB(LLVM_AttributeRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS7356rB(LLVM_PassBuilderOptionsRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS0284rB(LLVM_ErrorRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS1302rB(LLVM_DIBuilderRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS9683rB(LLVM_MetadataRef_s this) { return (((this).ptr) == (NULL)); }
bool LLVM_isNullS5902rB(LLVM_DbgRecordRef_s this) { return (((this).ptr) == (NULL)); }
i32 LLVM_asI32Anyri32(Any u) { return ((i32)((*((u8 *)((u)))))); }
LLVMBool_s newLLVMBoolBrS2924(bool b) {
    if (b)
        return ((LLVMBool_s){.val = ((i32)(1))});
    return ((LLVMBool_s){.val = ((i32)(0))});
}
bool equalsPS9925PS9925rB(InterpReg_s *this, InterpReg_s *other) { ((unreachablePcrN)(("InterpReg.equals is never called"))); }
InterpReg_s asInterpPU9869PcrS9925(IRValue_u *this, char *err) {
    bool succ_604_ = true;
    bool succ_609_ = true;

    IRValue_u *tmp_829_ = (this);
    {
        succ_604_ &= (tmp_829_->tag == 2);
        InterpReg_s *interp = &tmp_829_->payload.variant2._0;
        succ_604_ &= true;
        if (succ_604_) {
            {
                return (*interp);
            }
            goto after_829;
        }
    }
    {
        succ_609_ &= (tmp_829_->tag == 3);
        succ_609_ &= true;
        InterpReg_s *interp = &tmp_829_->payload.variant3._1;
        succ_609_ &= true;
        if (succ_609_) {
            {
                return (*interp);
            }
            goto after_829;
        }
    }
    {
        if (true) {
            {
            }
            goto after_829;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_829:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
LLVM_ValueRef_s asLLVMPU9869PcrS1407(IRValue_u *this, char *err) {
    bool succ_614_ = true;
    bool succ_619_ = true;

    IRValue_u *tmp_836_ = (this);
    {
        succ_614_ &= (tmp_836_->tag == 1);
        LLVM_ValueRef_s *llvm = &tmp_836_->payload.variant1._0;
        succ_614_ &= true;
        if (succ_614_) {
            {
                return (*llvm);
            }
            goto after_836;
        }
    }
    {
        succ_619_ &= (tmp_836_->tag == 3);
        LLVM_ValueRef_s *llvm = &tmp_836_->payload.variant3._0;
        succ_619_ &= true;
        succ_619_ &= true;
        if (succ_619_) {
            {
                return (*llvm);
            }
            goto after_836;
        }
    }
    {
        if (true) {
            {
            }
            goto after_836;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_836:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
none pushPS1193U9869rN(IRValueList_s *this, IRValue_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRValue_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRValue_u *atPS1193uszrPU9869(IRValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRValueList.at")));
    return (&((((this)->elements))[(index)]));
}
LLVM_ValueRef_s getArgPS6859uszrS1407(ASMContext_s *context, usize index) { return ((asLLVMPU9869PcrS1407)((&(((((context)->args).elements))[(index)])), ("ASMContext.getArg"))); }
none pushPS6859PcrN(ASMContext_s *context, char *code) {
    ((pushStrPS0540PcrN)((&((context)->code)), (code)));
    ((pushStrPS0540PcrN)((&((context)->code)), ("\n")));
}
none inPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint) {
    ((pushPS1193U9869rN)((&((context)->args)), (arg)));
    ((pushPS6808S0540rN)((&((context)->in)), ((newStringFromStrLitPcrS0540)((constraint)))));
}
none outPS6859U9869PcrN(ASMContext_s *context, IRValue_u arg, char *constraint) {
    ((pushPS1193U9869rN)((&((context)->args)), (arg)));
    ((pushPS6808S0540rN)((&((context)->out)), ((newStringFromStrLitPcrS0540)((constraint)))));
}
String_s constrainPS6859U6852rS0540(ASMContext_s *context, ASMLoc_u loc) {
    String_s r = ((String_s){0});
    bool succ_628_ = true;
    bool succ_631_ = true;

    ASMLoc_u *tmp_868_ = (&(loc));
    {
        succ_628_ &= (tmp_868_->tag == 1);
        char **reg = &tmp_868_->payload.variant1._0;
        succ_628_ &= true;
        if (succ_628_) {
            {
                ((r) = ((newStringFromStrLitPcrS0540)(("{"))));
                ((pushStrPS0540PcrN)((&(r)), (*reg)));
                ((pushCharPS0540crN)((&(r)), ('}')));
            }
            goto after_868;
        }
    }
    {
        succ_631_ &= (tmp_868_->tag == 0);
        if (succ_631_) {
            {
                ((r) = ((newStringFromStrLitPcrS0540)(("r"))));
            }
            goto after_868;
        }
    }
    {
        ASMLoc_u **unknown = &tmp_868_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ASMContext.constrain: Unhandled tag %hhu\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_868;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_868:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (r);
}
none constrainPS6859U9995rN(ASMContext_s *context, ASMConstraint_u cons) {
    bool succ_637_ = true;
    bool succ_643_ = true;
    bool succ_649_ = true;

    ASMConstraint_u *tmp_889_ = (&(cons));
    {
        succ_637_ &= (tmp_889_->tag == 1);
        ASMLoc_u *loc = &tmp_889_->payload.variant1._0;
        succ_637_ &= true;
        IRValue_u *val = &tmp_889_->payload.variant1._1;
        succ_637_ &= true;
        if (succ_637_) {
            {
                String_s in = ((constrainPS6859U6852rS0540)((context), (*loc)));
                ((pushPS6808S0540rN)((&((context)->in)), (in)));
                ((pushPS1193U9869rN)((&((context)->args)), (*val)));
            }
            goto after_889;
        }
    }
    {
        succ_643_ &= (tmp_889_->tag == 0);
        ASMLoc_u *loc = &tmp_889_->payload.variant0._0;
        succ_643_ &= true;
        IRValue_u *val = &tmp_889_->payload.variant0._1;
        succ_643_ &= true;
        if (succ_643_) {
            {
                String_s in = ((constrainPS6859U6852rS0540)((context), (*loc)));
                String_s out = ((newStringFromStrLitPcrS0540)(("=")));
                ((pushStringPS0540PS0540rN)((&(out)), (&(in))));
                ((pushPS6808S0540rN)((&((context)->out)), (out)));
                ((pushPS6808S0540rN)((&((context)->in)), (in)));
                ((pushPS1193U9869rN)((&((context)->args)), (*val)));
            }
            goto after_889;
        }
    }
    {
        succ_649_ &= (tmp_889_->tag == 3);
        ASMLoc_u *loc = &tmp_889_->payload.variant3._0;
        succ_649_ &= true;
        if (succ_649_) {
            {
                String_s clob = ((constrainPS6859U6852rS0540)((context), (*loc)));
                String_s out = ((newStringFromStrLitPcrS0540)(("~")));
                ((pushStringPS0540PS0540rN)((&(out)), (&(clob))));
                ((pushPS6808S0540rN)((&((context)->clobber)), (out)));
            }
            goto after_889;
        }
    }
    {
        ASMConstraint_u **unknown = &tmp_889_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ASMContext.constrain: Unhandled tag %hhu\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_889;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_889:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none constrainPS6859PcrN(ASMContext_s *context, char *code) {
    usize l = (((strlen))((code)));
    char *ptr = (code);
    usize c = ((usize)(0llu));
    while ((c) < (l)) {
        while ((((ptr))[((usize)(0llu))]) != (','))
            ((ptr) = ((char *)((unsigned char *)(ptr) + ((usize)(1llu)))));
        usize diff = ((usize)((unsigned char *)(ptr) - (unsigned char *)(code)));
        String_s s = ((String_s){0});
        for (usize i = ((usize)(0llu)); ((i) < (diff)); ((i) = ((i) + ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (((code))[(i)])));
        if (((s).length) > ((usize)(0llu))) {
            if (((((s).buffer))[((usize)(0llu))]) == ('=')) {
                ((pushPS6808S0540rN)((&((context)->out)), (s)));
            }

            else if (((((s).buffer))[((usize)(0llu))]) == ('~')) {
                ((pushPS6808S0540rN)((&((context)->clobber)), (s)));
            }

            else {
                ((pushPS6808S0540rN)((&((context)->in)), (s)));
            }
        }

        ((code) = (ptr));
        ((c) = (((c) + (diff)) + ((usize)(1llu))));
        ((ptr) = ((char *)((unsigned char *)((char *)((unsigned char *)(ptr) + (diff))) + ((usize)(1llu)))));
    }
}
String_s collectPS6859rS0540(ASMContext_s *context) {
    String_s s = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((context)->out).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->out)), (i)))));
        if ((((((context)->in).length) > ((usize)(0llu))) || ((((context)->clobber).length) > ((usize)(0llu)))) || ((i) != ((((context)->out).length) - ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((context)->in).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->in)), (i)))));
        if (((((context)->clobber).length) > ((usize)(0llu))) || ((i) != ((((context)->in).length) - ((usize)(1llu)))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((context)->clobber).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushStringPS0540PS0540rN)((&(s)), ((atPS6808uszrPS0540)((&((context)->clobber)), (i)))));
        if ((i) != ((((context)->clobber).length) - ((usize)(1llu))))
            ((pushCharPS0540crN)((&(s)), (',')));
    }

    return (s);
}
char *tokenKindToStringuszrPc(usize kind) {
    if ((kind) == (TOKEN_EOF))
        return ("TOKEN_EOF");
    else if ((kind) == (TOKEN_IDENT))
        return ("Identifier");
    else if ((kind) == (TOKEN_KEYWORD))
        return ("Keyword");
    else if ((kind) == (TOKEN_STRING_LITERAL))
        return ("String literal");
    else if ((kind) == (TOKEN_INT_LITERAL))
        return ("Integer literal");
    else if ((kind) == (TOKEN_CHAR_LITERAL))
        return ("Character literal");
    else if ((kind) == (TOKEN_PAREN_OPEN))
        return ("`(`");
    else if ((kind) == (TOKEN_PAREN_CLOSE))
        return ("`)`");
    else if ((kind) == (TOKEN_CURLY_OPEN))
        return ("`{`");
    else if ((kind) == (TOKEN_CURLY_CLOSE))
        return ("`}`");
    else if ((kind) == (TOKEN_SQUARE_OPEN))
        return ("`[`");
    else if ((kind) == (TOKEN_SQUARE_CLOSE))
        return ("`]`");
    else if ((kind) == (TOKEN_SEMI_COLON))
        return ("`;`");
    else if ((kind) == (TOKEN_COLON_SINGLE))
        return ("`:`");
    else if ((kind) == (TOKEN_COLON_DOUBLE))
        return ("`::`");
    else if ((kind) == (TOKEN_EQUAL_SINGLE))
        return ("`=`");
    else if ((kind) == (TOKEN_EQUAL_DOUBLE))
        return ("`==`");
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ("`&`");
    else if ((kind) == (TOKEN_AMPERSAND_DOUBLE))
        return ("`&&`");
    else if ((kind) == (TOKEN_COMMA))
        return ("`,`");
    else if ((kind) == (TOKEN_ARROW_THIN))
        return ("`->`");
    else if ((kind) == (TOKEN_ARROW_THICK))
        return ("`=>`");
    else if ((kind) == (TOKEN_PLUS_SINGLE))
        return ("`+`");
    else if ((kind) == (TOKEN_UNDERSCORE))
        return ("`_`");
    else if ((kind) == (TOKEN_DOT))
        return ("`.`");
    else if ((kind) == (TOKEN_AT))
        return ("`@`");
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ("`-`");
    else if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ("`*`");
    else if ((kind) == (TOKEN_NOT_EQUAL))
        return ("`!=`");
    else if ((kind) == (TOKEN_BANG))
        return ("`!`");
    else if ((kind) == (TOKEN_SLASH_SINGLE))
        return ("`/`");
    else if ((kind) == (TOKEN_LESS_THAN_EQUAL))
        return ("`<=`");
    else if ((kind) == (TOKEN_LESS_THAN))
        return ("`<`");
    else if ((kind) == (TOKEN_GREATER_THAN_EQUAL))
        return ("`>=`");
    else if ((kind) == (TOKEN_GREATER_THAN))
        return ("`>`");
    else if ((kind) == (TOKEN_PERCENT))
        return ("`%`");
    else if ((kind) == (TOKEN_PIPE_SINGLE))
        return ("`|`");
    else if ((kind) == (TOKEN_PIPE_DOUBLE))
        return ("`||`");
    else if ((kind) == (TOKEN_DOTDOT))
        return ("`..`");
    else if ((kind) == (TOKEN_DOTDOTDOT))
        return ("`...`");
    else if ((kind) == (TOKEN_CARET))
        return ("`^`");
    else if ((kind) == (TOKEN_WILDCARD))
        return ("`_`");
    ((unreachablePcrN)(("Exhaustive handling of kinds in tokenKindToString")));
}
none printPS6070rN(Token_s *this) {
    (((printf))(("kind=%llu, content="), ((this)->kind)));
    ((printPS7720rN)((&((this)->content))));
}
String_s getLocationPS6070rS0540(Token_s *this) { return ((toStringPS8951rS0540)((&((this)->span)))); }
String_s toStringPS6070rS0540(Token_s *this) { return ((toStringPS7720rS0540)((&((this)->content)))); }
SubStr_s getSubStrPS6070rS7720(Token_s *this) { return ((this)->content); }
Span_s getSpanPS6070rS8951(Token_s *this) { return ((this)->span); }
bool equalsPS6070PS6070rB(Token_s *this, Token_s *other) {
    if (((this)->kind) != ((other)->kind))
        return (false);
    if (!((equalsPS8951PS8951rB)((&((this)->span)), (&((other)->span)))))
        return (false);
    if (!((equalsPS7720PS7720rB)((&((this)->content)), (&((other)->content)))))
        return (false);
    return (true);
}
Token_s dummyTokenuszrS6070(usize kind) {
    SubStr_s tmp_3955 = ((defaultSubStrrS7720)());

    return ((newTokenuszPS7720uszuszrS6070)(((usize)(0llu)), (&tmp_3955), ((usize)(0llu)), (kind)));
}
Token_s newTokenuszPS7720uszuszrS6070(usize fileID, SubStr_s *sub, usize start, usize kind) {
    Span_s s = ((newSpanuszuszuszrS8951)((fileID), (start), ((start) + ((sub)->len))));
    return ((Token_s){.content = (*(sub)), .span = (s), .kind = (kind)});
}
Token_s newTokenEOFuszuszrS6070(usize fileID, usize start) {
    return ((Token_s){.content = ((newSubStrPcuszuszrS7720)(("End Of File"), ((usize)(0llu)), ((usize)(11llu)))),
                      .span = ((newSpanuszuszuszrS8951)((fileID), (start), ((start) + ((usize)(1llu))))),
                      .kind = (TOKEN_EOF)});
}
Token_s defaultTokenrS6070(none) { return ((Token_s){.content = ((defaultSubStrrS7720)()), .span = ((defaultSpanrS8951)()), .kind = (TOKEN_EOF)}); }
none push_entryPS3131U7843rN(TypeInfoTable_s *table, TypeInfo_u info) {
    if (((table)->length) >= ((table)->capacity)) {
        usize newCap = (((table)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((table)->elements) = (((realloc))(((table)->elements), ((newCap) * (sizeof(TypeInfo_u))))));
        ((assertBPcrN)((((table)->elements) != (NULL)), ("generateTypeInfoTable: Could not allocate memory")));
        (((table)->capacity) = (newCap));
    }

    (((((table)->elements))[((table)->length)]) = (info));
    (((table)->length) = (((table)->length) + ((usize)(1llu))));
}
usize index_ofPS3131PU7843rusz(TypeInfoTable_s *table, TypeInfo_u *info) {
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_4089 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_4093 = ((get_namePU7843rS7720)((info)));

        if ((((tagAnyru8)((&((((table)->elements))[(i)])))) == ((tagAnyru8)((info)))) && ((equalsPS7720PS7720rB)((&tmp_4089), (&tmp_4093)))) {
            return (i);
        }
    }

    return ((table)->length);
}
bool containsPS3131PU7843rB(TypeInfoTable_s *table, TypeInfo_u *info) {
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_4132 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_4136 = ((get_namePU7843rS7720)((info)));

        if ((((tagAnyru8)((&((((table)->elements))[(i)])))) == ((tagAnyru8)((info)))) && ((equalsPS7720PS7720rB)((&tmp_4132), (&tmp_4136)))) {
            return (true);
        }
    }

    return (false);
}
none pushPS2495uszrN(TypeInfoList_s *this, usize element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS0131S3911rN(FieldTypeInfoList_s *this, FieldTypeInfo_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(FieldTypeInfo_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FieldTypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS3117U0081rN(UnionVariantTypeInfoList_s *this, UnionVariantTypeInfo_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionVariantTypeInfo_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionVariantTypeInfoList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
SubStr_s get_namePU0081rS7720(UnionVariantTypeInfo_u *info) {
    bool succ_773_ = true;
    bool succ_778_ = true;
    bool succ_783_ = true;

    UnionVariantTypeInfo_u *tmp_1142_ = (info);
    {
        succ_773_ &= (tmp_1142_->tag == 0);
        SubStr_s *name = &tmp_1142_->payload.variant0._0;
        succ_773_ &= true;
        if (succ_773_) {
            {
                return (*name);
            }
            goto after_1142;
        }
    }
    {
        succ_778_ &= (tmp_1142_->tag == 1);
        SubStr_s *name = &tmp_1142_->payload.variant1._0;
        succ_778_ &= true;
        succ_778_ &= true;
        if (succ_778_) {
            {
                return (*name);
            }
            goto after_1142;
        }
    }
    {
        succ_783_ &= (tmp_1142_->tag == 2);
        SubStr_s *name = &tmp_1142_->payload.variant2._0;
        succ_783_ &= true;
        succ_783_ &= true;
        if (succ_783_) {
            {
                return (*name);
            }
            goto after_1142;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1142;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1142:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of variant info kinds in get_name()")));
}
bool equalsPU7843PU7843rB(TypeInfo_u *ti1, TypeInfo_u *ti2) {
    if (((tagAnyru8)((ti1))) != ((tagAnyru8)((ti2))))
        return (false);
    SubStr_s tmp_4349 = ((get_namePU7843rS7720)((ti1)));
    SubStr_s tmp_4353 = ((get_namePU7843rS7720)((ti2)));

    return ((equalsPS7720PS7720rB)((&tmp_4349), (&tmp_4353)));
}
usize get_sizePU7843rusz(TypeInfo_u *info) {
    bool succ_790_ = true;
    bool succ_794_ = true;
    bool succ_799_ = true;
    bool succ_803_ = true;
    bool succ_811_ = true;
    bool succ_818_ = true;
    bool succ_825_ = true;
    bool succ_832_ = true;
    bool succ_835_ = true;

    TypeInfo_u *tmp_1166_ = (info);
    {
        succ_790_ &= (tmp_1166_->tag == 1);
        succ_790_ &= true;
        usize *size_in_bytes = &tmp_1166_->payload.variant1._1;
        succ_790_ &= true;
        succ_790_ &= true;
        if (succ_790_) {
            {
                return (*size_in_bytes);
            }
            goto after_1166;
        }
    }
    {
        succ_794_ &= (tmp_1166_->tag == 3);
        succ_794_ &= true;
        if (succ_794_) {
            {
                return ((usize)(8llu));
            }
            goto after_1166;
        }
    }
    {
        succ_799_ &= (tmp_1166_->tag == 2);
        succ_799_ &= true;
        succ_799_ &= true;
        if (succ_799_) {
            {
                return ((usize)(16llu));
            }
            goto after_1166;
        }
    }
    {
        succ_803_ &= (tmp_1166_->tag == 7);
        succ_803_ &= true;
        if (succ_803_) {
            {
                return ((usize)(8llu));
            }
            goto after_1166;
        }
    }
    {
        succ_811_ &= (tmp_1166_->tag == 4);
        succ_811_ &= true;
        usize *size_in_bytes = &tmp_1166_->payload.variant4._1;
        succ_811_ &= true;
        succ_811_ &= true;
        succ_811_ &= true;
        succ_811_ &= true;
        if (succ_811_) {
            {
                return (*size_in_bytes);
            }
            goto after_1166;
        }
    }
    {
        succ_818_ &= (tmp_1166_->tag == 5);
        succ_818_ &= true;
        usize *size_in_bytes = &tmp_1166_->payload.variant5._1;
        succ_818_ &= true;
        succ_818_ &= true;
        succ_818_ &= true;
        if (succ_818_) {
            {
                return (*size_in_bytes);
            }
            goto after_1166;
        }
    }
    {
        succ_825_ &= (tmp_1166_->tag == 6);
        succ_825_ &= true;
        usize *size_in_bytes = &tmp_1166_->payload.variant6._1;
        succ_825_ &= true;
        succ_825_ &= true;
        succ_825_ &= true;
        if (succ_825_) {
            {
                return (*size_in_bytes);
            }
            goto after_1166;
        }
    }
    {
        succ_832_ &= (tmp_1166_->tag == 8);
        succ_832_ &= true;
        usize *size_in_bytes = &tmp_1166_->payload.variant8._1;
        succ_832_ &= true;
        succ_832_ &= true;
        succ_832_ &= true;
        if (succ_832_) {
            {
                return (*size_in_bytes);
            }
            goto after_1166;
        }
    }
    {
        succ_835_ &= (tmp_1166_->tag == 0);
        if (succ_835_) {
            {
                ((unreachablePcrN)(("get_size(TypeInfo::Unknown)")));
            }
            goto after_1166;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1166;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1166:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_size()")));
}
usize get_alignPU7843rusz(TypeInfo_u *info) {
    bool succ_842_ = true;
    bool succ_846_ = true;
    bool succ_851_ = true;
    bool succ_855_ = true;
    bool succ_863_ = true;
    bool succ_870_ = true;
    bool succ_877_ = true;
    bool succ_884_ = true;
    bool succ_887_ = true;

    TypeInfo_u *tmp_1187_ = (info);
    {
        succ_842_ &= (tmp_1187_->tag == 1);
        succ_842_ &= true;
        succ_842_ &= true;
        usize *align_in_bytes = &tmp_1187_->payload.variant1._2;
        succ_842_ &= true;
        if (succ_842_) {
            {
                return (*align_in_bytes);
            }
            goto after_1187;
        }
    }
    {
        succ_846_ &= (tmp_1187_->tag == 3);
        succ_846_ &= true;
        if (succ_846_) {
            {
                return ((usize)(8llu));
            }
            goto after_1187;
        }
    }
    {
        succ_851_ &= (tmp_1187_->tag == 2);
        succ_851_ &= true;
        succ_851_ &= true;
        if (succ_851_) {
            {
                return ((usize)(8llu));
            }
            goto after_1187;
        }
    }
    {
        succ_855_ &= (tmp_1187_->tag == 7);
        succ_855_ &= true;
        if (succ_855_) {
            {
                return ((usize)(8llu));
            }
            goto after_1187;
        }
    }
    {
        succ_863_ &= (tmp_1187_->tag == 4);
        succ_863_ &= true;
        succ_863_ &= true;
        usize *align_in_bytes = &tmp_1187_->payload.variant4._2;
        succ_863_ &= true;
        succ_863_ &= true;
        succ_863_ &= true;
        if (succ_863_) {
            {
                return (*align_in_bytes);
            }
            goto after_1187;
        }
    }
    {
        succ_870_ &= (tmp_1187_->tag == 5);
        succ_870_ &= true;
        succ_870_ &= true;
        usize *align_in_bytes = &tmp_1187_->payload.variant5._2;
        succ_870_ &= true;
        succ_870_ &= true;
        if (succ_870_) {
            {
                return (*align_in_bytes);
            }
            goto after_1187;
        }
    }
    {
        succ_877_ &= (tmp_1187_->tag == 6);
        succ_877_ &= true;
        succ_877_ &= true;
        usize *align_in_bytes = &tmp_1187_->payload.variant6._2;
        succ_877_ &= true;
        succ_877_ &= true;
        if (succ_877_) {
            {
                return (*align_in_bytes);
            }
            goto after_1187;
        }
    }
    {
        succ_884_ &= (tmp_1187_->tag == 8);
        succ_884_ &= true;
        succ_884_ &= true;
        usize *align_in_bytes = &tmp_1187_->payload.variant8._2;
        succ_884_ &= true;
        succ_884_ &= true;
        if (succ_884_) {
            {
                return (*align_in_bytes);
            }
            goto after_1187;
        }
    }
    {
        succ_887_ &= (tmp_1187_->tag == 0);
        if (succ_887_) {
            {
                ((unreachablePcrN)(("get_size(TypeInfo::Unknown)")));
            }
            goto after_1187;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1187;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1187:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_size()")));
}
SubStr_s get_namePU7843rS7720(TypeInfo_u *info) {
    bool succ_893_ = true;
    bool succ_898_ = true;
    bool succ_903_ = true;
    bool succ_908_ = true;
    bool succ_913_ = true;
    bool succ_918_ = true;
    bool succ_923_ = true;
    bool succ_928_ = true;
    bool succ_931_ = true;

    TypeInfo_u *tmp_1208_ = (info);
    {
        succ_893_ &= (tmp_1208_->tag == 1);
        SubStr_s *name = &tmp_1208_->payload.variant1._0;
        succ_893_ &= true;
        succ_893_ &= true;
        if (succ_893_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_898_ &= (tmp_1208_->tag == 3);
        SubStr_s *name = &tmp_1208_->payload.variant3._0;
        succ_898_ &= true;
        succ_898_ &= true;
        if (succ_898_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_903_ &= (tmp_1208_->tag == 2);
        SubStr_s *name = &tmp_1208_->payload.variant2._0;
        succ_903_ &= true;
        succ_903_ &= true;
        if (succ_903_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_908_ &= (tmp_1208_->tag == 7);
        SubStr_s *name = &tmp_1208_->payload.variant7._0;
        succ_908_ &= true;
        succ_908_ &= true;
        if (succ_908_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_913_ &= (tmp_1208_->tag == 4);
        SubStr_s *name = &tmp_1208_->payload.variant4._0;
        succ_913_ &= true;
        succ_913_ &= true;
        if (succ_913_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_918_ &= (tmp_1208_->tag == 5);
        SubStr_s *name = &tmp_1208_->payload.variant5._0;
        succ_918_ &= true;
        succ_918_ &= true;
        if (succ_918_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_923_ &= (tmp_1208_->tag == 6);
        SubStr_s *name = &tmp_1208_->payload.variant6._0;
        succ_923_ &= true;
        succ_923_ &= true;
        if (succ_923_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_928_ &= (tmp_1208_->tag == 8);
        SubStr_s *name = &tmp_1208_->payload.variant8._0;
        succ_928_ &= true;
        succ_928_ &= true;
        if (succ_928_) {
            {
                return (*name);
            }
            goto after_1208;
        }
    }
    {
        succ_931_ &= (tmp_1208_->tag == 0);
        if (succ_931_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("<unknown>"))));
            }
            goto after_1208;
        }
    }
    {
        if (true) {
            {
            }
            goto after_1208;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_1208:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of info kinds in get_name()")));
}
none pushPS3111AnyuszrN(ArenaBlock_s *this, Any elem, usize newCap) {
    if (((this)->next) != (NULL)) {
        ((pushPS3111AnyuszrN)(((this)->next), (elem), (newCap)));
        return;
    }

    else if (((this)->length) == ((this)->capacity)) {
        (((this)->next) = ((allocateBlockuszuszrPS3111)((newCap), ((this)->elemSize))));
        ((pushPS3111AnyuszrN)(((this)->next), (elem), (newCap)));
        return;
    }

    ((assertBrN)((((this)->length) < ((this)->capacity))));
    (((memcpy))(((u8 *)((unsigned char *)((u8 *)(((this)->elements))) + (((this)->length) * ((this)->elemSize)))), (elem), ((this)->elemSize)));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Any atPS3111uszrAny(ArenaBlock_s *this, usize index) {
    if ((index) >= ((this)->capacity)) {
        ((assertBPcrN)((((this)->next) != (NULL)), ("Out of bounds access in ArenaBlock")));
        return ((atPS3111uszrAny)(((this)->next), ((index) - ((this)->capacity))));
    }

    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ArenaBlock")));
    return ((usize *)((unsigned char *)((usize *)(((this)->elements))) + ((index) * ((this)->elemSize))));
}
Any lastPS3111rAny(ArenaBlock_s *this) {
    ((assertBPcrN)((((this)->length) > ((usize)(0llu))), ("ArenaBlock.last() called on empty Arena")));
    ((assertBPcrN)((((this)->next) == (NULL)), ("ArenaBlock.last() called on block in the middle of a chain")));
    return ((atPS3111uszrAny)((this), (((this)->length) - ((usize)(1llu)))));
}
usize indexOfPS3111Anyrusz(ArenaBlock_s *this, Any elem) {
    if ((((this)->elements) <= (elem)) && (((usize)((elem))) < (((usize)(((this)->elements))) + (((this)->capacity) * ((this)->elemSize))))) {
        usize index = ((((usize)((elem))) - ((usize)(((this)->elements)))) / ((this)->elemSize));
        ((assertBPcrN)(((index) < ((this)->length)), ("ArenaBlock.indexOf() does not contain the element")));
        return (index);
    }

    else {
        ((assertBPcrN)((((this)->next) != (NULL)), ("ArenaBlock.indexOf() does not contain the element")));
        return (((this)->capacity) + ((indexOfPS3111Anyrusz)(((this)->next), (elem))));
    }
}
ArenaBlock_s *allocateBlockuszuszrPS3111(usize cap, usize size) {
    Any mem = (((calloc))(((usize)(1llu)), (sizeof(ArenaBlock_s))));
    ((assertBPcrN)(((mem) != (NULL)), ("Could not allocate ArenaBlock instance")));
    Any elements = (((calloc))((cap), (size)));
    ((assertBPcrN)(((elements) != (NULL)), ("Could not allocate ArenaBlock elements")));
    ArenaBlock_s *block = ((ArenaBlock_s *)((mem)));
    ((*(block)) = ((ArenaBlock_s){.elements = (elements), .length = ((usize)(0llu)), .capacity = (cap), .next = (NULL), .elemSize = (size)}));
    return (block);
}
none pushPS9153S0890rN(ParsedConfigArena_s *this, ParsedConfig_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedConfig_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedConfig_s *atPS9153uszrPS0890(ParsedConfigArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedConfigArena.at() called on empty Arena")));
    return ((ParsedConfig_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedConfig_s *lastPS9153rPS0890(ParsedConfigArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedConfigArena.last() called on empty Arena")));
    return ((ParsedConfig_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9153PS0890rusz(ParsedConfigArena_s *this, ParsedConfig_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedConfigArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS9483S1892rN(ParsedFileArena_s *this, ParsedFile_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedFile_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedFile_s *atPS9483uszrPS1892(ParsedFileArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFileArena.at() called on empty Arena")));
    return ((ParsedFile_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedFile_s *lastPS9483rPS1892(ParsedFileArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedFileArena.last() called on empty Arena")));
    return ((ParsedFile_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9483PS1892rusz(ParsedFileArena_s *this, ParsedFile_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFileArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS9029S1038rN(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedTopLevelItem_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTopLevelItem_s *atPS9029uszrPS1038(ParsedTopLevelItemArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTopLevelItemArena.at() called on empty Arena")));
    return ((ParsedTopLevelItem_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedTopLevelItem_s *lastPS9029rPS1038(ParsedTopLevelItemArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedTopLevelItemArena.last() called on empty Arena")));
    return ((ParsedTopLevelItem_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS9029PS1038rusz(ParsedTopLevelItemArena_s *this, ParsedTopLevelItem_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTopLevelItemArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7393S1882rN(ParsedModuleArena_s *this, ParsedModule_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedModule_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedModule_s *atPS7393uszrPS1882(ParsedModuleArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedModuleArena.at() called on empty Arena")));
    return ((ParsedModule_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedModule_s *lastPS7393rPS1882(ParsedModuleArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedModuleArena.last() called on empty Arena")));
    return ((ParsedModule_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7393PS1882rusz(ParsedModuleArena_s *this, ParsedModule_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedModuleArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS2168S5521rN(ParsedStructDeclArena_s *this, ParsedStructDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(ParsedStructDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStructDecl_s *atPS2168uszrPS5521(ParsedStructDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStructDeclArena.at() called on empty Arena")));
    return ((ParsedStructDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedStructDecl_s *lastPS2168rPS5521(ParsedStructDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedStructDeclArena.last() called on empty Arena")));
    return ((ParsedStructDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS2168PS5521rusz(ParsedStructDeclArena_s *this, ParsedStructDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStructDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4268S0997rN(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedUnionDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionDecl_s *atPS4268uszrPS0997(ParsedUnionDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionDeclArena.at() called on empty Arena")));
    return ((ParsedUnionDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedUnionDecl_s *lastPS4268rPS0997(ParsedUnionDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedUnionDeclArena.last() called on empty Arena")));
    return ((ParsedUnionDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4268PS0997rusz(ParsedUnionDeclArena_s *this, ParsedUnionDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4249S3506rN(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedUnionVariant_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionVariant_s *atPS4249uszrPS3506(ParsedUnionVariantArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionVariantArena.at() called on empty Arena")));
    return ((ParsedUnionVariant_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedUnionVariant_s *lastPS4249rPS3506(ParsedUnionVariantArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedUnionVariantArena.last() called on empty Arena")));
    return ((ParsedUnionVariant_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4249PS3506rusz(ParsedUnionVariantArena_s *this, ParsedUnionVariant_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedUnionVariantArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4111S4904rN(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_LARGE), (sizeof(ParsedFuncDecl_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_LARGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedFuncDecl_s *atPS4111uszrPS4904(ParsedFuncDeclArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFuncDeclArena.at() called on empty Arena")));
    return ((ParsedFuncDecl_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedFuncDecl_s *lastPS4111rPS4904(ParsedFuncDeclArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedFuncDeclArena.last() called on empty Arena")));
    return ((ParsedFuncDecl_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4111PS4904rusz(ParsedFuncDeclArena_s *this, ParsedFuncDecl_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedFuncDeclArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8646S7247rN(ParsedBlockArena_s *this, ParsedBlock_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedBlock_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedBlock_s *atPS8646uszrPS7247(ParsedBlockArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedBlockArena.at() called on empty Arena")));
    return ((ParsedBlock_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedBlock_s *lastPS8646rPS7247(ParsedBlockArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedBlockArena.last() called on empty Arena")));
    return ((ParsedBlock_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8646PS7247rusz(ParsedBlockArena_s *this, ParsedBlock_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedBlockArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8227S1100rN(ParsedStmtArena_s *this, ParsedStmt_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_LARGE), (sizeof(ParsedStmt_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_LARGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStmt_s *atPS8227uszrPS1100(ParsedStmtArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStmtArena.at() called on empty Arena")));
    return ((ParsedStmt_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedStmt_s *lastPS8227rPS1100(ParsedStmtArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedStmtArena.last() called on empty Arena")));
    return ((ParsedStmt_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8227PS1100rusz(ParsedStmtArena_s *this, ParsedStmt_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedStmtArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7882S2435rN(ParsedExprArena_s *this, ParsedExpr_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(ParsedExpr_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedExpr_s *atPS7882uszrPS2435(ParsedExprArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedExprArena.at() called on empty Arena")));
    return ((ParsedExpr_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedExpr_s *lastPS7882rPS2435(ParsedExprArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedExprArena.last() called on empty Arena")));
    return ((ParsedExpr_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7882PS2435rusz(ParsedExprArena_s *this, ParsedExpr_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedExprArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4419S1372rN(ParsedTypeNodeArena_s *this, ParsedTypeNode_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(ParsedTypeNode_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTypeNode_s *atPS4419uszrPS1372(ParsedTypeNodeArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTypeNodeArena.at() called on empty Arena")));
    return ((ParsedTypeNode_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedTypeNode_s *lastPS4419rPS1372(ParsedTypeNodeArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedTypeNodeArena.last() called on empty Arena")));
    return ((ParsedTypeNode_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4419PS1372rusz(ParsedTypeNodeArena_s *this, ParsedTypeNode_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedTypeNodeArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS4174U5175rN(TypeArena_s *this, Type_u elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(Type_u)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Type_u *atPS4174uszrPU5175(TypeArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("TypeArena.at() called on empty Arena")));
    return ((Type_u *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
Type_u *lastPS4174rPU5175(TypeArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("TypeArena.last() called on empty Arena")));
    return ((Type_u *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS4174PU5175rusz(TypeArena_s *this, Type_u *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("TypeArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8168S3633rN(DLLArena_s *this, DLL_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_SMALL), (sizeof(DLL_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_SMALL)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
DLL_s *atPS8168uszrPS3633(DLLArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("DLLArena.at() called on empty Arena")));
    return ((DLL_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
DLL_s *lastPS8168rPS3633(DLLArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("DLLArena.last() called on empty Arena")));
    return ((DLL_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8168PS3633rusz(DLLArena_s *this, DLL_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("DLLArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS8361S1826rN(ParsedPatternArena_s *this, ParsedPattern_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_MEDIUM), (sizeof(ParsedPattern_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_MEDIUM)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedPattern_s *atPS8361uszrPS1826(ParsedPatternArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedPatternArena.at() called on empty Arena")));
    return ((ParsedPattern_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
ParsedPattern_s *lastPS8361rPS1826(ParsedPatternArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("ParsedPatternArena.last() called on empty Arena")));
    return ((ParsedPattern_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS8361PS1826rusz(ParsedPatternArena_s *this, ParsedPattern_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("ParsedPatternArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
none pushPS7368S5777rN(LLVMMetadataArena_s *this, LLVMMetadata_s elem) {
    if (((this)->start) == (NULL)) {
        (((this)->start) = ((allocateBlockuszuszrPS3111)((ARENA_SIZE_HUGE), (sizeof(LLVMMetadata_s)))));
        ((assertBrN)((((this)->end) == (NULL))));
        (((this)->end) = ((this)->start));
    }

    ((pushPS3111AnyuszrN)(((this)->end), (&(elem)), (ARENA_SIZE_HUGE)));
    if ((((this)->end)->next) != (NULL))
        (((this)->end) = (((this)->end)->next));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMMetadata_s *atPS7368uszrPS5777(LLVMMetadataArena_s *this, usize index) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("LLVMMetadataArena.at() called on empty Arena")));
    return ((LLVMMetadata_s *)(((atPS3111uszrAny)(((this)->start), (index)))));
}
LLVMMetadata_s *lastPS7368rPS5777(LLVMMetadataArena_s *this) {
    ((assertBPcrN)((((this)->end) != (NULL)), ("LLVMMetadataArena.last() called on empty Arena")));
    return ((LLVMMetadata_s *)(((lastPS3111rAny)(((this)->end)))));
}
usize indexOfPS7368PS5777rusz(LLVMMetadataArena_s *this, LLVMMetadata_s *elem) {
    ((assertBPcrN)((((this)->start) != (NULL)), ("LLVMMetadataArena.indexOf() called on empty Arena")));
    return ((indexOfPS3111Anyrusz)(((this)->start), (elem)));
}
SubStr_s BUILD_A_KEYWORDPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
bool isKeywordPS3493PS7720rB(Lexer_s *this, SubStr_s *word) {
    return (
        (((((((((((((((((((((((((equalsPS7720PS7720rB)((word), (&(KEYWORD_LET)))) || ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FUNC))))) || ((equalsPS7720PS7720rB)((word), (&(KEYWORD_COMPTIME))))) ||
                             ((equalsPS7720PS7720rB)((word), (&(KEYWORD_STRUCT))))) ||
                            ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ENUM))))) ||
                           ((equalsPS7720PS7720rB)((word), (&(KEYWORD_UNION))))) ||
                          ((equalsPS7720PS7720rB)((word), (&(KEYWORD_RETURN))))) ||
                         ((equalsPS7720PS7720rB)((word), (&(KEYWORD_MODULE))))) ||
                        ((equalsPS7720PS7720rB)((word), (&(KEYWORD_IMPORT))))) ||
                       ((equalsPS7720PS7720rB)((word), (&(KEYWORD_IF))))) ||
                      ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ELSE))))) ||
                     ((equalsPS7720PS7720rB)((word), (&(KEYWORD_WHILE))))) ||
                    ((equalsPS7720PS7720rB)((word), (&(KEYWORD_SIZEOF))))) ||
                   ((equalsPS7720PS7720rB)((word), (&(KEYWORD_AS))))) ||
                  ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FOR))))) ||
                 ((equalsPS7720PS7720rB)((word), (&(KEYWORD_BREAK))))) ||
                ((equalsPS7720PS7720rB)((word), (&(KEYWORD_CONTINUE))))) ||
               ((equalsPS7720PS7720rB)((word), (&(KEYWORD_NULL))))) ||
              ((equalsPS7720PS7720rB)((word), (&(KEYWORD_BLANK))))) ||
             ((equalsPS7720PS7720rB)((word), (&(KEYWORD_TRUE))))) ||
            ((equalsPS7720PS7720rB)((word), (&(KEYWORD_FALSE))))) ||
           ((equalsPS7720PS7720rB)((word), (&(KEYWORD_CONFIG))))) ||
          ((equalsPS7720PS7720rB)((word), (&(KEYWORD_MATCH))))) ||
         ((equalsPS7720PS7720rB)((word), (&(KEYWORD_ASM))))) ||
        ((equalsPS7720PS7720rB)((word), (&(KEYWORD_TYPEINFO)))));
}
char escapeCharSequencePS3493PS7720PS0540Puszrc(Lexer_s *this, SubStr_s *tmp, String_s *s, usize *len) {
    bool escaped = (false);
    usize extraOffset = ((usize)(0llu));
    char c = ((((tmp)->start))[((usize)(0llu))]);
    if ((c) == ('\\')) {
        ((c) = ((((tmp)->start))[((usize)(1llu))]));
        if ((c) == ('n')) {
            ((pushCharPS0540crN)((s), ('\n')));
        }

        else if ((c) == ('r')) {
            ((pushCharPS0540crN)((s), ('\r')));
        }

        else if ((c) == ('t')) {
            ((pushCharPS0540crN)((s), ('\t')));
        }

        else if ((c) == ('0')) {
            ((pushCharPS0540crN)((s), ('\0')));
        }

        else if ((c) == ('\\')) {
            ((pushCharPS0540crN)((s), ('\\')));
        }

        else if ((c) == ('\'')) {
            ((pushCharPS0540crN)((s), ('\'')));
        }

        else if ((c) == ('\"')) {
            ((pushCharPS0540crN)((s), ('\"')));
        }

        else if ((c) == ('x')) {
            char lower = ((((tmp)->start))[((usize)(2llu))]);
            char upper = ((((tmp)->start))[((usize)(3llu))]);
            ((assertBPcrN)(((isHexDigitcrB)((lower))), ("Expected hex digits for \\x")));
            ((assertBPcrN)(((isHexDigitcrB)((upper))), ("Expected hex digits for \\x")));
            char byte = ((char)(((((asHexcru8)((lower))) * ((u8)(16))) + ((asHexcru8)((upper))))));
            ((pushCharPS0540crN)((s), (byte)));
            ((extraOffset) = ((usize)(2llu)));
        }

        else {
            SubStr_s tmp_6634 = ((newSubStrPcuszuszrS7720)((&(c)), ((usize)(0llu)), ((usize)(1llu))));

            Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_6634), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
            String_s loc = ((toStringPS8951rS0540)((&((t).span))));
            (((fprintf))((stderr_), ("%s: %s: Can\'t escape character `%c`.\n"), ((loc).buffer), (ERR_STR), (c)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((escaped) = (true));
    }

    else {
        ((pushCharPS0540crN)((s), (c)));
    }

    usize step = ((usize)(1llu));
    if (escaped) {
        ((step) = ((usize)(2llu)));
    }

    ((step) = ((step) + (extraOffset)));
    ((*(len)) = ((*(len)) + (step)));
    ((*(tmp)) = ((substringPS7720uszuszrS7720)((tmp), (step), ((tmp)->len))));
    return ((((tmp)->start))[((usize)(0llu))]);
}
bool advancePS3493rB(Lexer_s *this) {
    (((this)->ptr) = (((this)->ptr) + ((usize)(1llu))));
    (((this)->content) = ((substringPS7720uszuszrS7720)((&((this)->content)), ((usize)(1llu)), (((this)->content).len))));
    return (((this)->ptr) >= ((this)->len));
}
Token_s peekPS3493rS6070(Lexer_s *this) {
    usize ptr = ((this)->ptr);
    SubStr_s content = ((this)->content);
    usize len = ((this)->len);
    Token_s tkn = ((__nextPS3493BrS6070)((this), (true)));
    (((this)->ptr) = (ptr));
    (((this)->content) = (content));
    (((this)->len) = (len));
    return (tkn);
}
Token_s nextPS3493rS6070(Lexer_s *this) { return ((__nextPS3493BrS6070)((this), (false))); }
Token_s __nextPS3493BrS6070(Lexer_s *this, bool peek) {
    if (((this)->ptr) == ((this)->len)) {
        return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
    }

    char currChar = (((((this)->content).start))[((usize)(0llu))]);
    while ((isWhitespacecrB)((currChar))) {
        if ((advancePS3493rB)((this))) {
            return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
        }

        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
    }

    if (((isAlphabeticcrB)((currChar))) || ((currChar) == ('_'))) {
        usize len = ((usize)(0llu));
        SubStr_s tmp = ((this)->content);
        char c = ((((tmp).start))[((usize)(0llu))]);
        while ((((isNumericcrB)((c))) || ((isAlphabeticcrB)((c)))) || ((c) == ('_'))) {
            ((len) = ((len) + ((usize)(1llu))));
            ((tmp) = ((substringPS7720uszuszrS7720)((&(tmp)), ((usize)(1llu)), ((tmp).len))));
            ((c) = ((((tmp).start))[((usize)(0llu))]));
        }

        SubStr_s word = ((substringPS7720uszuszrS7720)((&((this)->content)), ((usize)(0llu)), (len)));
        (((this)->ptr) = (((this)->ptr) + (len)));
        (((this)->content) = (tmp));
        SubStr_s tmp_6895 = (((BUILD_A_KEYWORDPcrS7720)(("_"))));

        if ((equalsPS7720PS7720rB)((&(word)), (&tmp_6895))) {
            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_WILDCARD)));
        }

        if ((isKeywordPS3493PS7720rB)((this), (&(word)))) {
            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_KEYWORD)));
        }

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_IDENT)));
    }

    else if ((isNumericcrB)((currChar))) {
        usize len = ((usize)(0llu));
        SubStr_s tmp = ((this)->content);
        usize val = ((usize)(0llu));
        bool prefixed = (false);
        if ((currChar) == ('0')) {
            ((len) = ((len) + ((usize)(1llu))));
            ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
            ((currChar) = ((((tmp).start))[((usize)(0llu))]));
            if ((currChar) == ('x')) {
                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                ((prefixed) = (true));
                while (true) {
                    char c = ((((tmp).start))[((usize)(0llu))]);
                    if ((isHexDigitcrB)((c))) {
                        ((val) = ((((usize)(16llu)) * (val)) + ((usize)(((asHexcru8)((c)))))));
                    }

                    else if ((c) == ('_')) {
                    }

                    else {
                        break;
                    }

                    ((len) = ((len) + ((usize)(1llu))));
                    ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                }

            }

            else if ((currChar) == ('b')) {
                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                ((prefixed) = (true));
                while (true) {
                    char c = ((((tmp).start))[((usize)(0llu))]);
                    if (((c) == ('0')) || ((c) == ('1'))) {
                        ((val) = (((usize)(2llu)) * (val)));
                        if ((c) == ('1'))
                            ((val) = ((val) + ((usize)(1llu))));
                    }

                    else if ((c) == ('_')) {
                    }

                    else {
                        break;
                    }

                    ((len) = ((len) + ((usize)(1llu))));
                    ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
                }

            }

            else if ((isAlphabeticcrB)((currChar))) {
                SubStr_s tmp_7116 = ((newSubStrPcuszuszrS7720)((&(currChar)), ((usize)(0llu)), ((usize)(1llu))));

                Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7116), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
                String_s loc = ((toStringPS8951rS0540)((&((t).span))));
                (((fprintf))((stderr_), ("%s: %s: Invalid number prefix `%c`.\n"), ((loc).buffer), (ERR_STR), (currChar)));
                (((C_exiti32rN))(((i32)(1))));
            }
        }

        if (!(prefixed)) {
            ((assertBrN)(((val) == ((usize)(0llu)))));
            while (true) {
                char c = ((((tmp).start))[((usize)(0llu))]);
                if ((isNumericcrB)((c))) {
                    ((val) = ((((usize)(10llu)) * (val)) + (((usize)((c))) - ((usize)(48llu)))));
                }

                else if ((c) == ('_')) {
                }

                else {
                    break;
                }

                ((len) = ((len) + ((usize)(1llu))));
                ((tmp) = ((newSubStrPcuszuszrS7720)(((tmp).start), ((usize)(1llu)), ((tmp).len))));
            }
        }

        String_s _word = ((newStringrS0540)());
        ((pushNumberPS0540uszrN)((&(_word)), (val)));
        SubStr_s word = ((asSubStrPS0540rS7720)((&(_word))));
        (((this)->ptr) = (((this)->ptr) + (len)));
        (((this)->content) = (tmp));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_INT_LITERAL)));
    }

    else if ((currChar) == ('\"')) {
        ((advancePS3493rB)((this)));
        if ((((this)->content).len) == ((usize)(0llu))) {
            ((todo_with_msgPcrN)(("unbalanced \"")));
        }

        if (peek) {
            SubStr_s tmp_7255 = ((newSubStrPcuszuszrS7720)(("\""), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7255), (((this)->ptr) - ((usize)(1llu))), (TOKEN_STRING_LITERAL)));
        }

        usize len = ((usize)(0llu));
        String_s s = ((newStringrS0540)());
        char c = (((((this)->content).start))[((usize)(0llu))]);
        while ((c) != ('\"')) {
            usize l = ((usize)(0llu));
            ((c) = ((escapeCharSequencePS3493PS7720PS0540Puszrc)((this), (&((this)->content)), (&(s)), (&(l)))));
            (((this)->ptr) = (((this)->ptr) + (l)));
            ((len) = ((len) + (l)));
        }

        SubStr_s word = ((substringPS0540uszuszrS7720)((&(s)), ((usize)(0llu)), ((s).length)));
        ((advancePS3493rB)((this)));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_STRING_LITERAL)));
    }

    else if ((currChar) == ('\'')) {
        ((advancePS3493rB)((this)));
        if ((((this)->content).len) == ((usize)(0llu))) {
            ((todo_with_msgPcrN)(("unbalanced \'")));
        }

        usize len = ((usize)(0llu));
        String_s s = ((newStringrS0540)());
        char c = (((((this)->content).start))[((usize)(0llu))]);
        while ((c) != ('\'')) {
            usize l = ((usize)(0llu));
            ((c) = ((escapeCharSequencePS3493PS7720PS0540Puszrc)((this), (&((this)->content)), (&(s)), (&(l)))));
            (((this)->ptr) = (((this)->ptr) + (l)));
            ((len) = ((len) + (l)));
        }

        SubStr_s word = ((substringPS0540uszuszrS7720)((&(s)), ((usize)(0llu)), ((s).length)));
        if (((word).len) != ((usize)(1llu))) {
            Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_IDENT)));
            String_s loc = ((toStringPS8951rS0540)((&((t).span))));
            (((fprintf))((stderr_), ("%s: %s: Invalid character literal `%.*s`.\n"), ((loc).buffer), (ERR_STR), ((word).len), ((word).start)));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((advancePS3493rB)((this)));
        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&(word)), (((this)->ptr) - (len)), (TOKEN_CHAR_LITERAL)));
    }

    else if ((currChar) == ('(')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7469 = ((newSubStrPcuszuszrS7720)(("("), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7469), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PAREN_OPEN)));
    }

    else if ((currChar) == (')')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7492 = ((newSubStrPcuszuszrS7720)((")"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7492), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PAREN_CLOSE)));
    }

    else if ((currChar) == ('{')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7515 = ((newSubStrPcuszuszrS7720)(("{"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7515), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CURLY_OPEN)));
    }

    else if ((currChar) == ('}')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7538 = ((newSubStrPcuszuszrS7720)(("}"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7538), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CURLY_CLOSE)));
    }

    else if ((currChar) == ('[')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7561 = ((newSubStrPcuszuszrS7720)(("["), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7561), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SQUARE_OPEN)));
    }

    else if ((currChar) == (']')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7584 = ((newSubStrPcuszuszrS7720)(("]"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7584), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SQUARE_CLOSE)));
    }

    else if ((currChar) == ('<')) {
        ((advancePS3493rB)((this)));
        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
        if ((currChar) == ('=')) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7622 = ((newSubStrPcuszuszrS7720)(("<="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7622), (((this)->ptr) - ((usize)(2llu))), (TOKEN_LESS_THAN_EQUAL)));
        }

        else {
            SubStr_s tmp_7639 = ((newSubStrPcuszuszrS7720)(("<"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7639), (((this)->ptr) - ((usize)(1llu))), (TOKEN_LESS_THAN)));
        }

    }

    else if ((currChar) == ('>')) {
        ((advancePS3493rB)((this)));
        ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
        if ((currChar) == ('=')) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7677 = ((newSubStrPcuszuszrS7720)((">="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7677), (((this)->ptr) - ((usize)(2llu))), (TOKEN_GREATER_THAN_EQUAL)));
        }

        else {
            SubStr_s tmp_7694 = ((newSubStrPcuszuszrS7720)((">"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7694), (((this)->ptr) - ((usize)(1llu))), (TOKEN_GREATER_THAN)));
        }

    }

    else if ((currChar) == (';')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7717 = ((newSubStrPcuszuszrS7720)((";"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7717), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SEMI_COLON)));
    }

    else if ((currChar) == (':')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == (':'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7760 = ((newSubStrPcuszuszrS7720)(("::"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7760), (((this)->ptr) - ((usize)(2llu))), (TOKEN_COLON_DOUBLE)));
        }

        else {
            SubStr_s tmp_7777 = ((newSubStrPcuszuszrS7720)((":"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7777), (((this)->ptr) - ((usize)(1llu))), (TOKEN_COLON_SINGLE)));
        }

    }

    else if ((currChar) == ('=')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('='))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7820 = ((newSubStrPcuszuszrS7720)(("=="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7820), (((this)->ptr) - ((usize)(2llu))), (TOKEN_EQUAL_DOUBLE)));
        }

        else if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('>'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7857 = ((newSubStrPcuszuszrS7720)(("=>"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7857), (((this)->ptr) - ((usize)(2llu))), (TOKEN_ARROW_THICK)));
        }

        else {
            SubStr_s tmp_7874 = ((newSubStrPcuszuszrS7720)(("="), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7874), (((this)->ptr) - ((usize)(1llu))), (TOKEN_EQUAL_SINGLE)));
        }

    }

    else if ((currChar) == ('&')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('&'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_7917 = ((newSubStrPcuszuszrS7720)(("&&"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7917), (((this)->ptr) - ((usize)(2llu))), (TOKEN_AMPERSAND_DOUBLE)));
        }

        else {
            SubStr_s tmp_7934 = ((newSubStrPcuszuszrS7720)(("&"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7934), (((this)->ptr) - ((usize)(1llu))), (TOKEN_AMPERSAND_SINGLE)));
        }

    }

    else if ((currChar) == ('_')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_7957 = ((newSubStrPcuszuszrS7720)(("_"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_7957), (((this)->ptr) - ((usize)(1llu))), (TOKEN_UNDERSCORE)));
    }

    else if ((currChar) == ('.')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('.'))) {
            ((advancePS3493rB)((this)));
            if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('.'))) {
                ((advancePS3493rB)((this)));
                SubStr_s tmp_8020 = ((newSubStrPcuszuszrS7720)(("..."), ((usize)(0llu)), ((usize)(3llu))));

                return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8020), (((this)->ptr) - ((usize)(3llu))), (TOKEN_DOTDOTDOT)));
            }

            SubStr_s tmp_8037 = ((newSubStrPcuszuszrS7720)((".."), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8037), (((this)->ptr) - ((usize)(2llu))), (TOKEN_DOTDOT)));
        }

        SubStr_s tmp_8054 = ((newSubStrPcuszuszrS7720)(("."), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8054), (((this)->ptr) - ((usize)(1llu))), (TOKEN_DOT)));
    }

    else if ((currChar) == (',')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8077 = ((newSubStrPcuszuszrS7720)((","), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8077), (((this)->ptr) - ((usize)(1llu))), (TOKEN_COMMA)));
    }

    else if ((currChar) == ('+')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8100 = ((newSubStrPcuszuszrS7720)(("+"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8100), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PLUS_SINGLE)));
    }

    else if ((currChar) == ('*')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8123 = ((newSubStrPcuszuszrS7720)(("*"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8123), (((this)->ptr) - ((usize)(1llu))), (TOKEN_ASTERISK_SINGLE)));
    }

    else if ((currChar) == ('@')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8146 = ((newSubStrPcuszuszrS7720)(("@"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8146), (((this)->ptr) - ((usize)(1llu))), (TOKEN_AT)));
    }

    else if ((currChar) == ('%')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8169 = ((newSubStrPcuszuszrS7720)(("%"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8169), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PERCENT)));
    }

    else if ((currChar) == ('^')) {
        ((advancePS3493rB)((this)));
        SubStr_s tmp_8192 = ((newSubStrPcuszuszrS7720)(("^"), ((usize)(0llu)), ((usize)(1llu))));

        return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8192), (((this)->ptr) - ((usize)(1llu))), (TOKEN_CARET)));
    }

    else if ((currChar) == ('|')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('|'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8235 = ((newSubStrPcuszuszrS7720)(("||"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8235), (((this)->ptr) - ((usize)(2llu))), (TOKEN_PIPE_DOUBLE)));
        }

        else {
            SubStr_s tmp_8252 = ((newSubStrPcuszuszrS7720)(("|"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8252), (((this)->ptr) - ((usize)(1llu))), (TOKEN_PIPE_SINGLE)));
        }

    }

    else if ((currChar) == ('-')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('>'))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8295 = ((newSubStrPcuszuszrS7720)(("->"), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8295), (((this)->ptr) - ((usize)(2llu))), (TOKEN_ARROW_THIN)));
        }

        else {
            SubStr_s tmp_8312 = ((newSubStrPcuszuszrS7720)(("-"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8312), (((this)->ptr) - ((usize)(1llu))), (TOKEN_MINUS_SINGLE)));
        }

    }

    else if ((currChar) == ('!')) {
        ((advancePS3493rB)((this)));
        if ((((this)->ptr) < ((this)->len)) && ((((((this)->content).start))[((usize)(0llu))]) == ('='))) {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8355 = ((newSubStrPcuszuszrS7720)(("!="), ((usize)(0llu)), ((usize)(2llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8355), (((this)->ptr) - ((usize)(2llu))), (TOKEN_NOT_EQUAL)));
        }

        else {
            SubStr_s tmp_8372 = ((newSubStrPcuszuszrS7720)(("!"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8372), (((this)->ptr) - ((usize)(1llu))), (TOKEN_BANG)));
        }

    }

    else if (((currChar) == ('/')) && ((((((this)->content).start))[((usize)(1llu))]) == ('*'))) {
        while (true) {
            if ((advancePS3493rB)((this))) {
                return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
            }

            ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
            char next = (((((this)->content).start))[((usize)(1llu))]);
            if (((currChar) == ('*')) && ((next) == ('/'))) {
                break;
            }
        }

        ((advancePS3493rB)((this)));
        ((advancePS3493rB)((this)));
        return ((nextPS3493rS6070)((this)));
    }

    else if ((currChar) == ('/')) {
        if ((((((this)->content).start))[((usize)(1llu))]) == ('/')) {
            while ((currChar) != ('\n')) {
                if ((advancePS3493rB)((this))) {
                    return ((newTokenEOFuszuszrS6070)(((this)->fileID), ((this)->ptr)));
                }

                ((currChar) = (((((this)->content).start))[((usize)(0llu))]));
            }

            return ((nextPS3493rS6070)((this)));
        }

        else {
            ((advancePS3493rB)((this)));
            SubStr_s tmp_8487 = ((newSubStrPcuszuszrS7720)(("/"), ((usize)(0llu)), ((usize)(1llu))));

            return ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8487), (((this)->ptr) - ((usize)(1llu))), (TOKEN_SLASH_SINGLE)));
        }

    }

    else {
        SubStr_s tmp_8505 = ((newSubStrPcuszuszrS7720)((&(currChar)), ((usize)(0llu)), ((usize)(1llu))));

        Token_s t = ((newTokenuszPS7720uszuszrS6070)(((this)->fileID), (&tmp_8505), (((this)->ptr) + ((usize)(1llu))), (TOKEN_IDENT)));
        String_s loc = ((toStringPS8951rS0540)((&((t).span))));
        (((fprintf))((stderr_), ("%s: %s: Unknown character `%c`.\n"), ((loc).buffer), (ERR_STR), (currChar)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
Lexer_s newLexeruszS7720rS3493(usize fileID, SubStr_s content) { return ((Lexer_s){.content = (content), .fileID = (fileID), .ptr = ((usize)(0llu)), .len = ((content).len)}); }
IRFuncList_s asListPS2612rS8040(String_IRFuncHashMap_s *this) {
    IRFuncList_s l = ((IRFuncList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (i)));
        if ((elem)->set) {
            ((pushPS8040S7132rN)((&(l)), ((elem)->value)));
        }
    }

    return (l);
}
bool needsResizePS2612rB(String_IRFuncHashMap_s *this) {
    if (((this)->capacity) == ((usize)(0llu))) {
        return (true);
    }

    else {
        f64 loadFactor = (((f64)(((this)->length))) / ((f64)(((this)->capacity))));
        ((assertBrN)(((loadFactor) <= ((f64)(1)))));
        return ((((f64)(10)) * (loadFactor)) > ((f64)(6)));
    }
}
usize indexOfPS2612PS0540rusz(String_IRFuncHashMap_s *this, String_s *key) {
    (((this)->locked) = (true));
    String_IRFuncEntry_s *elem = ((getEntryPS2612PS0540rPS0516)((this), (key)));
    ((assertBPcrN)(((elem) != (NULL)), ("String_IRFuncHashMap.indexOf() does not contain key")));
    return (((usize)((unsigned char *)(elem) - (unsigned char *)((this)->elements))) / (sizeof(String_IRFuncEntry_s)));
}
IRFunc_s *atPS2612uszrPS7132(String_IRFuncHashMap_s *this, usize index) {
    ((assertBPcrN)(((this)->locked), ("Can only get elements at an index if the HashMap is locked")));
    String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (index)));
    ((assertBPcrN)(((elem) != (NULL)), ("Expected to find element at the given index")));
    ((assertBPcrN)(((elem)->set), ("Expected set element at the given index")));
    return (&((elem)->value));
}
none resizeIfNecessaryPS2612rN(String_IRFuncHashMap_s *this) {
    if ((needsResizePS2612rB)((this))) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(256llu)));
        String_IRFuncEntry_s *newElements = (((calloc))((newCap), (sizeof(String_IRFuncEntry_s))));
        ((assertBPcrN)(((newElements) != (NULL)), ("Could not allocate memory in String_IRFuncHashMap.resizeIfNecessary")));
        String_IRFuncHashMap_s newThis = ((String_IRFuncHashMap_s){.elements = (newElements), .length = ((usize)(0llu)), .capacity = (newCap), .locked = ((this)->locked)});
        for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
            String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (i)));
            if ((elem)->set)
                ((addPS2612S0540S7132rN)((&(newThis)), ((elem)->key), ((elem)->value)));
        }

        (((free))(((this)->elements)));
        ((*(this)) = (newThis));
    }
}
none addPS2612S0540S7132rN(String_IRFuncHashMap_s *this, String_s key, IRFunc_s value) {
    if ((this)->locked) {
        ((todo_with_msgPcrN)(("HashMap is locked, can\'t add elements")));
    }

    ((resizeIfNecessaryPS2612rN)((this)));
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize hash = (((hashPS0540rusz)((&(key)))) % ((this)->capacity));
    usize index = (hash);
    usize stop = ((hash) - ((usize)(1llu)));
    if ((hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((index) != (stop)) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (index)));
        if (!((elem)->set)) {
            ((*(elem)) = ((String_IRFuncEntry_s){.set = (true), .key = (key), .value = (value)}));
            (((this)->length) = (((this)->length) + ((usize)(1llu))));
            return;
        }

        ((index) = (((index) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Could not insert element into HashMap")));
}
IRFunc_s *getPS2612PS0540rPS7132(String_IRFuncHashMap_s *this, String_s *key) {
    String_IRFuncEntry_s *entry = ((getEntryPS2612PS0540rPS0516)((this), (key)));
    if ((entry) == (NULL))
        return (NULL);
    return (&((entry)->value));
}
String_IRFuncEntry_s *getEntryPS2612PS0540rPS0516(String_IRFuncHashMap_s *this, String_s *key) {
    if (((this)->length) == ((usize)(0llu)))
        return (NULL);
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize hash = (((hashPS0540rusz)((key))) % ((this)->capacity));
    usize stop = ((hash) - ((usize)(1llu)));
    if ((hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((hash) != (stop)) {
        String_IRFuncEntry_s *elem = ((getAtIndexPS2612uszrPS0516)((this), (hash)));
        if (!((elem)->set))
            return (NULL);
        if ((equalsPS0540PS0540rB)((&((elem)->key)), (key)))
            return (elem);
        ((hash) = (((hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Load Factor guarantees that there\'s always at least one unset Entry in the HashMap.")));
}
String_IRFuncEntry_s *getAtIndexPS2612uszrPS0516(String_IRFuncHashMap_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->capacity)), ("Out of bounds access in String_IRFuncHashMap.getAtIndex")));
    return ((String_IRFuncEntry_s *)((unsigned char *)((this)->elements) + ((index) * (sizeof(String_IRFuncEntry_s)))));
}
bool containsKeyPS2612PS0540rB(String_IRFuncHashMap_s *this, String_s *key) { return (((getPS2612PS0540rPS7132)((this), (key))) != (NULL)); }
none freeS1803rN(Function_s fn) {
    if (((munmap)(((Any)(usize)(((fn).run))), ((fn).size))) != ((i32)(0))) {
        (((printf))(("warning: Could not free function at %p\n"), ((fn).run)));
    }
}
none pushPS5123ccccccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8) {
    ((pushPS5123u8u8u8u8u8u8u8u8rN)((buf), ((u8)((b1))), ((u8)((b2))), ((u8)((b3))), ((u8)((b4))), ((u8)((b5))), ((u8)((b6))), ((u8)((b7))), ((u8)((b8)))));
}
none pushPS5123ccccrN(ByteBuffer_s *buf, char b1, char b2, char b3, char b4) {
    ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2)))));
    ((pushPS5123u8u8rN)((buf), ((u8)((b3))), ((u8)((b4)))));
}
none pushPS5123cccrN(ByteBuffer_s *buf, char b1, char b2, char b3) {
    ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2)))));
    ((pushPS5123u8rN)((buf), ((u8)((b3)))));
}
none pushPS5123ccrN(ByteBuffer_s *buf, char b1, char b2) { ((pushPS5123u8u8rN)((buf), ((u8)((b1))), ((u8)((b2))))); }
none pushPS5123crN(ByteBuffer_s *buf, char b1) { ((pushPS5123u8rN)((buf), ((u8)((b1))))); }
none pushPS5123u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2) {
    ((pushPS5123u8rN)((buf), (b1)));
    ((pushPS5123u8rN)((buf), (b2)));
}
none pushPS5123u8u8u8u8u8u8u8u8rN(ByteBuffer_s *buf, u8 b1, u8 b2, u8 b3, u8 b4, u8 b5, u8 b6, u8 b7, u8 b8) {
    ((pushPS5123u8rN)((buf), (b1)));
    ((pushPS5123u8rN)((buf), (b2)));
    ((pushPS5123u8rN)((buf), (b3)));
    ((pushPS5123u8rN)((buf), (b4)));
    ((pushPS5123u8rN)((buf), (b5)));
    ((pushPS5123u8rN)((buf), (b6)));
    ((pushPS5123u8rN)((buf), (b7)));
    ((pushPS5123u8rN)((buf), (b8)));
}
none pushPS5123u8rN(ByteBuffer_s *buf, u8 element) {
    if (((buf)->length) >= ((buf)->capacity)) {
        usize newCap = (((buf)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((buf)->elements) = (((realloc))(((buf)->elements), ((newCap) * (sizeof(u8))))));
        ((assertBPcrN)((((buf)->elements) != (NULL)), ("Could not allocate memory in ByteBuffer.push")));
        (((buf)->capacity) = (newCap));
    }

    (((((buf)->elements))[((buf)->length)]) = (element));
    (((buf)->length) = (((buf)->length) + ((usize)(1llu))));
}
none extendPS5123PS5123rN(ByteBuffer_s *buf, ByteBuffer_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5123u8rN)((buf), ((((other)->elements))[(i)])));
    }

    (((free))(((other)->elements)));
    ((*(other)) = ((ByteBuffer_s){0}));
}
none pushImmPS5123S8630rN(ByteBuffer_s *bytes, ImmI32_s imm) {
    u8 *p = ((u8 *)((&((imm).b))));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(0llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(1llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(2llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(3llu))])));
}
none pushImmPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm) {
    u8 *p = ((u8 *)((&((imm).b))));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(0llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(1llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(2llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(3llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(4llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(5llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(6llu))])));
    ((pushPS5123u8rN)((bytes), (((p))[((usize)(7llu))])));
}
none modRMPS5123u8u8S7038rN(ByteBuffer_s *bytes, u8 addr, u8 opext, GPR_s reg) {
    u8 byte = ((u8)(((shiftLeftuszuszrusz)(((usize)((addr))), ((usize)(6llu))))));
    ((byte) = ((byte) | ((u8)(((shiftLeftuszuszrusz)(((usize)((opext))), ((usize)(3llu))))))));
    ((byte) = ((byte) | (((reg).r) % ((u8)(8)))));
    ((pushPS5123u8rN)((bytes), (byte)));
}
none modPrefixPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r) {
    u8 rex = ((u8)(('H')));
    if (((tagAnyru8)((&(r)))) >= ((u8)(8)))
        ((rex) = ((rex) | ((u8)(1))));
    ((pushPS5123u8rN)((bytes), (rex)));
}
none movPS5123S7038S7038rN(ByteBuffer_s *bytes, GPR_s to, GPR_s from) {
    ((modPrefixPS5123S7038rN)((bytes), (from)));
    ((pushPS5123crN)((bytes), ('\x89')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((tagAnyru8)((&(from)))), (to)));
}
none movPS5123S5949S5363rN(ByteBuffer_s *bytes, FPR_s r, ImmF32_s imm) {
    u32 v = (*((u32 *)((&((imm).b)))));
    ((movPS5123S7038S8630rN)((bytes), (RAX), ((ImmI32_s){.b = (v)})));
    ((pushPS5123cccrN)((bytes), ('f'), ('\xF'), ('n')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((r).r), (RAX)));
}
none movPS5123S5949S5464rN(ByteBuffer_s *bytes, FPR_s r, ImmF64_s imm) {
    u64 v = (*((u64 *)((&((imm).b)))));
    ((movPS5123S7038S8731rN)((bytes), (RAX), ((ImmI64_s){.b = (v)})));
    ((pushPS5123ccccrN)((bytes), ('f'), ('H'), ('\xF'), ('n')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((r).r), (RAX)));
}
none movPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    char opcode = ((char)((((u8)(('\xB8'))) + (((r).r) % ((u8)(8))))));
    ((pushPS5123crN)((bytes), (opcode)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none movPS5123S7038S8731rN(ByteBuffer_s *bytes, GPR_s r, ImmI64_s imm) {
    char opcode = ((char)((((u8)(('\xB8'))) + (((r).r) % ((u8)(8))))));
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), (opcode)));
    ((pushImmPS5123S8731rN)((bytes), (imm)));
}
none pushPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg) {
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(6)), (reg)));
}
none popPS5123S7038rN(ByteBuffer_s *bytes, GPR_s reg) {
    ((pushPS5123crN)((bytes), ('\x8F')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(0)), (reg)));
}
none movPS5123S7038u32S8731rN(ByteBuffer_s *bytes, GPR_s r, u32 offset, ImmI64_s imm) {
    ((movPS5123S7038S8731rN)((bytes), (RBX), (imm)));
    ((assertBPcrN)(((offset) < ((u32)(256))), ("only single byte offset for now")));
    ((pushPS5123ccccrN)((bytes), ('H'), ('\x89'), ('\\'), ('$')));
    ((pushPS5123crN)((bytes), ((char)((offset)))));
}
none addPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), ('\x81')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(0)), (r)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none subPS5123S7038S8630rN(ByteBuffer_s *bytes, GPR_s r, ImmI32_s imm) {
    ((modPrefixPS5123S7038rN)((bytes), (r)));
    ((pushPS5123crN)((bytes), ('\x81')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(5)), (r)));
    ((pushImmPS5123S8630rN)((bytes), (imm)));
}
none callPS5123S7038rN(ByteBuffer_s *bytes, GPR_s r) {
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(2)), (r)));
}
none pushPS5123S8731rN(ByteBuffer_s *bytes, ImmI64_s imm) {
    ((movPS5123S7038S8731rN)((bytes), (RAX), (imm)));
    ((pushPS5123crN)((bytes), ('\xFF')));
    ((modRMPS5123u8u8S7038rN)((bytes), (ADDR_REG), ((u8)(6)), (RAX)));
}
none pushPS2247S6579rN(CallStack_s *this, CallStackInfo_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(CallStackInfo_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in CallStack.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
CallStackInfo_s *atPS2247uszrPS6579(CallStack_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in CallStack.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in CallStack.at")));
    return (&((((this)->elements))[(index)]));
}
CallStackInfo_s *popPS2247rPS6579(CallStack_s *this) {
    CallStackInfo_s *l = ((lastPS2247rPS6579)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
CallStackInfo_s *lastPS2247rPS6579(CallStack_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty CallStack")));
    return ((atPS2247uszrPS6579)((this), (((this)->length) - ((usize)(1llu)))));
}
none dumpRegisterStackPS3154uszrN(IRInterp_s *this, usize bytes) {
    usize cols = ((usize)(4llu));
    for (usize i = ((usize)(0llu)); ((i) < (bytes)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((i) > ((usize)(0llu))) && (((i) % (((usize)(8llu)) * (cols))) == ((usize)(0llu))))
            (((printf))(("\n")));
        (((printf))(("%2hhX"), (*((u8 *)((unsigned char *)((this)->regStackStart) + (i))))));
    }

    (((printf))(("\n")));
}
u8 *getGlobalPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg) { return ((u8 *)((unsigned char *)((u8 *)((unsigned char *)((this)->globalRegBase) - ((reg)->offset))) - ((reg)->size))); }
u8 *getRegStackPointerPS3154PS9925rPu8(IRInterp_s *this, InterpReg_s *reg) {
    u8 *ptr = ((u8 *)((unsigned char *)((u8 *)((unsigned char *)((this)->regStackBase) - ((reg)->offset))) - ((reg)->size)));
    ((assertBPcrN)(((ptr) < ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))), ("Stack Overflow in IRInterp.getRegStackPointer")));
    ((assertBPcrN)(((ptr) >= ((this)->regStackStart)), ("Stack Underflow in IRInterp.getRegStackPointer")));
    return (ptr);
}
u8 *advanceRealStackPS3154S8951uszrPu8(IRInterp_s *this, Span_s span, usize size) {
    u8 *_p = ((this)->realStackPointer);
    u8 *new = ((u8 *)((unsigned char *)((this)->realStackPointer) + (size)));
    if ((new) >= ((u8 *)((unsigned char *)((this)->realStackStart) + (STACK_SIZE)))) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last allocation tried to allocate %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->realStackPointer) = (new));
    return (_p);
}
none pushArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size) {
    usize new = (((this)->argStackLength) + (size));
    if ((new) >= ((this)->argStackCapacity)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Argument Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last function call tried to push %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((memcpy))(((u8 *)((unsigned char *)((this)->argStack) + ((this)->argStackLength))), (start), (size)));
    (((this)->argStackLength) = (new));
}
none popArgumentPS3154S8951Pu8uszrN(IRInterp_s *this, Span_s span, u8 *start, usize size) {
    usize new = (((this)->argStackLength) - (size));
    if (((this)->argStackLength) < (size)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s: Argument Stack Underflow in the comptime interpreter.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Last function call tried to pop %llu byte(s).\n"), ((loc).buffer), (NOTE_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->argStackLength) = (new));
    (((memcpy))((start), ((u8 *)((unsigned char *)((this)->argStack) + ((this)->argStackLength))), (size)));
}
InterpReg_s evaluateNotImplementedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((dumpInstructionsPS7132rN)((irFunc)));
    String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
    (((printf))(("%s: "), ((loc).buffer)));
    ((dumpPS7680rN)((instr)));
    ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
    ((unreachablePcrN)(("Not implemented")));
}
InterpReg_s evaluateAllocaPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("Alloca got non-pointer")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    ((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))))))) = ((usize)(((advanceRealStackPS3154S8951uszrPu8)((this), ((instr)->span), (((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateGetParamPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    usize size = (((instr)->op1).i);
    ((assertBPcrN)(((size) <= ((usize)(8llu))), ("Interp: Expected small size for GetParam")));
    InterpReg_s dst = ((InterpReg_s){.offset = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->offset), .size = (size)});
    ((popArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), (size)));
    return (dst);
}
InterpReg_s evaluateStorePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    ((assertBPcrN)(((isPointerPU5175rB)(((dst)->typ))), ("Store expected Ptr Dst")));
    usize size = ((getSizeInBytesPU5175rusz)(((dst)->typ)));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = (size)});
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Store src")));
    u8 *srcLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg))));
    u8 *dstLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg)))))))));
    (((memcpy))((dstLoc), (srcLoc), ((srcReg).size)));
    return (dstReg);
}
InterpReg_s evaluateFetchGlobalPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10154 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchGlobalPtr")));

    u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10154)));
    Type_u *t = ((fReg)->typ);
    usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
    (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), (ptr), (size)));
    return (reg);
}
InterpReg_s evaluateFetchGlobalValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10202 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchGlobalValue")));

    u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10202)));
    usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
    (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), ((Any)((*((usize *)((ptr)))))), (size)));
    return (reg);
}
InterpReg_s evaluateFetchComptimeValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    if ((((instr)->op1).i) == ((usize)(1llu))) {
        IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        InterpReg_s tmp_10257 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)(((this)->globalRegisters), (((instr)->src).i))), ("Interp FetchComptimeValue")));

        u8 *ptr = ((getGlobalPointerPS3154PS9925rPu8)((this), (&tmp_10257)));
        usize size = ((getSizeInBytesPU5175rusz)(((fReg)->typ)));
        InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = (size)});
        (((memcpy))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg)))), (ptr), (size)));
        return (reg);
    }

    else {
        return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp FetchComptimeValue")));
    }
}
InterpReg_s evaluateLoadFunctionPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFunctionPU5175rB)(((fReg)->typ))), ("LoadFunctionPtr got non-function")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Load src")));
    ((assertBPcrN)((((srcReg).size) == ((usize)(8llu))), ("Load expected Ptr Src")));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = ((getSizeInBytesPU5175rusz)(((dst)->typ)))});
    u8 *srcLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg)))))))));
    u8 *dstLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    (((memcpy))((dstLoc), (srcLoc), ((dstReg).size)));
    return (dstReg);
}
InterpReg_s evaluateMovePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dst = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s srcReg = ((asInterpPU5952PcrS9925)((src), ("Interp Move src")));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((dst)->offset), .size = ((getSizeInBytesPU5175rusz)(((dst)->typ)))});
    u8 *srcLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(srcReg))));
    u8 *dstLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    (((memcpy))((dstLoc), (srcLoc), ((dstReg).size)));
    return (dstReg);
}
InterpReg_s evaluateInstrCallPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s tmp_10450 = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Call")));

    usize id = (*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&tmp_10450))))));
    IRFunc_s *calledFunc = ((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (id)));
    ParsedFuncDecl_s *f = ((atPS4111uszrPS4904)((&(funcDecls)), ((calledFunc)->originalID)));
    if ((isExternPS4904rB)((f))) {
        if (!((isNullPS3633rB)(((f)->dllHandle)))) {
            if (*((flags).disableExternalComptime)) {
                String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
                (((fprintf))((stderr_), ("%s: %s: Cannot call external function `%s` at compile time.\n"), ((loc).buffer), (ERR_STR), (((calledFunc)->name).buffer)));
                (((fprintf))((stderr_), ("%s: %s: Flag `--no-extern-comptime` was provided.\n"), ((loc).buffer), (NOTE_STR)));
                ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
                (((C_exiti32rN))(((i32)(1))));
            }

            Function_s fun = ((compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803)((this), (irFunc), (calledFunc), (instr), ((((f)->dllHandle)->handle).ptr), (regs)));
            Type_u *retType = (NULL);
            bool succ_1289_ = true;

            Type_u *tmp_2277_ = ((getTypePU9661rPU5175)((&((f)->typeState))));
            {
                succ_1289_ &= (tmp_2277_->tag == 6);
                succ_1289_ &= true;
                Type_u **_ret = &tmp_2277_->payload.variant6._1;
                succ_1289_ &= true;
                succ_1289_ &= true;
                if (succ_1289_) {
                    {
                        ((retType) = (*_ret));
                    }
                    goto after_2277;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("IRGen.evaluateInstrCall: Expected function type")));
                    }
                    goto after_2277;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_2277:
            (void)0; // error: label at end of compound statement is a C23 extension
            u64 val = (((fun).run)());
            usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
            InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
            if (((getSizeInBytesPU5175rusz)((retType))) == ((usize)(0llu))) {
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(1llu))) {
                ((*((u8 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u8 *)((&(val))))));
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(2llu))) {
                ((*((u16 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u16 *)((&(val))))));
            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(4llu))) {
                if ((isFloatPU5175rB)((retType))) {
                    ((*((f32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((f32 *)((&(val))))));
                }

                else {
                    ((*((u32 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u32 *)((&(val))))));
                }

            }

            else if (((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(8llu))) {
                if ((isFloatPU5175rB)((retType))) {
                    ((*((f64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((f64 *)((&(val))))));
                }

                else {
                    ((*((u64 *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*((u64 *)((&(val))))));
                }

            }

            else {
            }

            ((freeS1803rN)((fun)));
            return (dst);
        }

        else {
            String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
            (((fprintf))((stderr_), ("%s: %s: Can not call external function `%s` at compile time.\n"), ((loc).buffer), (ERR_STR), (((calledFunc)->name).buffer)));
            if (((f)->dllHandle) == ((dllNotFoundrPS3633)())) {
                ParsedModule_s *m = ((getParentModulePS4904rPS1882)((f)));
                String_s _loc = ((toStringPS8951rS0540)((&((m)->span))));
                UsizeList_s cfg = ((getConfigsPS1882rS4113)((m)));
                if (((cfg).length) == ((usize)(0llu))) {
                    (((fprintf))((stderr_), ("%s: %s: No configuration found!\n"), ((_loc).buffer), (NOTE_STR)));
                }

                else {
                    (((fprintf))((stderr_), ("%s: %s: Could not load any of the libraries specified in the module configuration.\n"), ((loc).buffer), (NOTE_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    for (usize i = ((usize)(0llu)); ((i) < ((cfg).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(cfg)), (i))))));
                        ((assertBrN)((((tli)->kind) == (TLI_CONFIG))));
                        ((dropPS0540rN)((&(_loc))));
                        ((_loc) = ((toStringPS8951rS0540)((&((tli)->span)))));
                        (((fprintf))((stderr_), ("%s: %s: Module configuration declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    }
                }

                ((dropPS0540rN)((&(_loc))));
            }

            else if (((f)->dllHandle) == ((dllNoSuchFunctionrPS3633)())) {
                ParsedModule_s *m = ((getParentModulePS4904rPS1882)((f)));
                String_s _loc = ((toStringPS8951rS0540)((&((m)->span))));
                UsizeList_s cfg = ((getConfigsPS1882rS4113)((m)));
                if (((cfg).length) == ((usize)(0llu))) {
                    (((fprintf))((stderr_), ("%s: %s: No configuration found!\n"), ((_loc).buffer), (NOTE_STR)));
                }

                else {
                    String_s _fnLoc = ((toStringPS8951rS0540)((&((f)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Could not find the function in any of the specified libraries.\n"), ((loc).buffer), (ERR_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Function declared here.\n"), ((_fnLoc).buffer), (NOTE_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    for (usize i = ((usize)(0llu)); ((i) < ((cfg).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(cfg)), (i))))));
                        ((assertBrN)((((tli)->kind) == (TLI_CONFIG))));
                        ((dropPS0540rN)((&(_loc))));
                        ((_loc) = ((toStringPS8951rS0540)((&((tli)->span)))));
                        (((fprintf))((stderr_), ("%s: %s: Module configuration declared here.\n"), ((_loc).buffer), (NOTE_STR)));
                    }

                    ((dropPS0540rN)((&(_fnLoc))));
                }

                ((dropPS0540rN)((&(_loc))));
            }

            else if (((f)->dllHandle) == (NULL)) {
            }

            else {
                ((unreachablePcrN)(("actually null-ptr")));
            }

            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

    }

    else {
        usize argSize = ((this)->argStackLength);
        u8 *stackStart = ((this)->realStackStart);
        u8 *regStackStart = ((this)->regStackStart);
        for (usize _i = ((usize)(0llu)); ((_i) < (((instr)->args).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
            usize i = (((((instr)->args).length) - (_i)) - ((usize)(1llu)));
            RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((atPS9911uszrPS6939)((&((instr)->args)), (i)))->i)));
            InterpReg_s arg = ((asInterpPU5952PcrS9925)((reg), ("call arg")));
            ((pushArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(arg)))), ((arg).size)));
        }

        RegValueList_s callRegs = ((RegValueList_s){0});
        ((initBlankPS5884uszrN)((&(callRegs)), (((calledFunc)->registers).length)));
        ((evaluateCallPS3154S8951PS7132PS5884rN)((this), ((instr)->span), (calledFunc), (&(callRegs))));
        usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
        InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
        ((popArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), (size)));
        ((assertBPcrN)(((argSize) == ((this)->argStackLength)), ("Imbalanced argument stack after calling IRInterp.evaluateCall")));
        ((assertBPcrN)(((stackStart) == ((this)->realStackStart)), ("Imbalanced real stack after calling IRInterp.evaluateCall")));
        ((assertBPcrN)(((regStackStart) == ((this)->regStackStart)), ("Imbalanced reg stack after calling IRInterp.evaluateCall")));
        return (dst);
    }
}
InterpReg_s evaluateReturnExprPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *expr = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rExpr = ((asInterpPU5952PcrS9925)((expr), ("ReturnExpr")));
    ((pushArgumentPS3154S8951Pu8uszrN)((this), ((instr)->span), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rExpr)))), ((rExpr).size)));
    return ((InterpReg_s){0});
}
InterpReg_s evaluateReturnVoidPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) { return ((InterpReg_s){0}); }
InterpReg_s evaluateLoadStringPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("LoadString expected Ptr")));
    ((assertBPcrN)(((isCharPU5175rB)(((getUnderlyingTypePU5175BrPU5175)(((fReg)->typ), (false))))), ("LoadString expected Ptr to Char")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadBoolPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    u8 isTrue = ((u8)((((instr)->src).i)));
    ((assertBPcrN)((((isTrue) == ((u8)(0))) || ((isTrue) == ((u8)(1)))), ("LoadBool expected 0 or 1")));
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u8 *)((regStackLoc)))) = (isTrue));
    return (reg);
}
InterpReg_s evaluateLoadI8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI8 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i8 *)((regStackLoc)))) = ((i8)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU8PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)((((isIntegerPU5175rB)(((fReg)->typ))) || ((isCharPU5175rB)(((fReg)->typ)))), ("LoadU8 got non-int non-char")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(1llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u8 *)((regStackLoc)))) = ((u8)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadI16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI16 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(2llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i16 *)((regStackLoc)))) = ((i16)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU16PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU16 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(2llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u16 *)((regStackLoc)))) = ((u16)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadI32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadI32 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((i32 *)((regStackLoc)))) = ((i32)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU32 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((u32 *)((regStackLoc)))) = ((u32)((((instr)->src).i))));
    return (reg);
}
InterpReg_s evaluateLoadU64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isIntegerPU5175rB)(((fReg)->typ))), ("LoadU64 got non-int")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = (((instr)->src).i));
    return (reg);
}
InterpReg_s evaluateLoadNullPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isPointerPU5175rB)(((fReg)->typ))), ("LoadNull got non-ptr")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((usize *)((regStackLoc)))) = ((usize)(0llu)));
    return (reg);
}
InterpReg_s evaluateLoadF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFloatPU5175rB)(((fReg)->typ))), ("LoadF32 got non-float")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(4llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((f32 *)((regStackLoc)))) = (*((f32 *)((&(((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateLoadF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    ((assertBPcrN)(((isFloatPU5175rB)(((fReg)->typ))), ("LoadF64 got non-float")));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    ((*((f64 *)((regStackLoc)))) = (*((f64 *)((&(((instr)->src).i))))));
    return (reg);
}
InterpReg_s evaluateLoadBlankPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCondBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *cond = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rCond = ((asInterpPU5952PcrS9925)((cond), ("CondBr")));
    ((assertBPcrN)((((rCond).size) == ((usize)(1llu))), ("comptime CondBr expected single byte Cond")));
    u8 *condLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rCond))));
    u8 v = (*(condLoc));
    ((assertBPcrN)((((v) == ((u8)(0))) || ((v) == ((u8)(1)))), ("condition is not 0 or 1")));
    usize id = ((usize)(0llu));
    if ((v) == ((u8)(1))) {
        ((id) = (((instr)->dst).i));
    }

    else {
        ((id) = (((instr)->op1).i));
    }

    return ((InterpReg_s){.offset = (id), .size = ((usize)(1llu))});
}
InterpReg_s evaluateBrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((InterpReg_s){.offset = (((instr)->dst).i), .size = ((usize)(1llu))});
}
InterpReg_s evaluateIntAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("AddInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("AddInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("AddInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) + (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) + (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) + (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) + (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) + (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) + (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) + (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) + (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("SubInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("SubInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("SubInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) - (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) - (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) - (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) - (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) - (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) - (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) - (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) - (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("MulInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("MulInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("MulInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) * (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) * (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) * (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) * (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) * (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) * (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) * (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) * (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int mul with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ModInt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ModInt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("ModInt expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((start)))) = ((*((i8 *)((lhsStart)))) % (*((i8 *)((rhsStart))))));
        else
            ((*((u8 *)((start)))) = ((*((u8 *)((lhsStart)))) % (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((start)))) = ((*((i16 *)((lhsStart)))) % (*((i16 *)((rhsStart))))));
        else
            ((*((u16 *)((start)))) = ((*((u16 *)((lhsStart)))) % (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((start)))) = ((*((i32 *)((lhsStart)))) % (*((i32 *)((rhsStart))))));
        else
            ((*((u32 *)((start)))) = ((*((u32 *)((lhsStart)))) % (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((start)))) = ((*((i64 *)((lhsStart)))) % (*((i64 *)((rhsStart))))));
        else
            ((*((u64 *)((start)))) = ((*((u64 *)((lhsStart)))) % (*((u64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("int mod with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateIntCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpNeq/ICmpEq LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpNeq/ICmpEq RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpNeq/ICmpEq got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((((isIntegerPU5175rB)((t1))) || ((isPointerPU5175rB)((t1)))) || ((isCharPU5175rB)((t1)))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((eq) = ((*((i8 *)((lhsStart)))) == (*((i8 *)((rhsStart))))));
            else
                ((eq) = ((*((u8 *)((lhsStart)))) == (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((eq) = ((*((i16 *)((lhsStart)))) == (*((i16 *)((rhsStart))))));
            else
                ((eq) = ((*((u16 *)((lhsStart)))) == (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((eq) = ((*((i32 *)((lhsStart)))) == (*((i32 *)((rhsStart))))));
            else
                ((eq) = ((*((u32 *)((lhsStart)))) == (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((eq) = ((*((i64 *)((lhsStart)))) == (*((i64 *)((rhsStart))))));
            else
                ((eq) = ((*((u64 *)((lhsStart)))) == (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpEq/ICmpNeq on non-int")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_NEQ))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateIntCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpGt/ICmpLte LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpGt/ICmpLte RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpGt/ICmpLte got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool gt = (false);
    if ((isIntegerPU5175rB)((t1))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((gt) = ((*((i8 *)((lhsStart)))) > (*((i8 *)((rhsStart))))));
            else
                ((gt) = ((*((u8 *)((lhsStart)))) > (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((gt) = ((*((i16 *)((lhsStart)))) > (*((i16 *)((rhsStart))))));
            else
                ((gt) = ((*((u16 *)((lhsStart)))) > (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((gt) = ((*((i32 *)((lhsStart)))) > (*((i32 *)((rhsStart))))));
            else
                ((gt) = ((*((u32 *)((lhsStart)))) > (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((gt) = ((*((i64 *)((lhsStart)))) > (*((i64 *)((rhsStart))))));
            else
                ((gt) = ((*((u64 *)((lhsStart)))) > (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmpgt with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpGt/ICmpLte on non-int")));
    }

    u8 r = ((u8)(0));
    if (gt)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_LTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateIntCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("ICmpLt/ICmpGte LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("ICmpLt/ICmpGte RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("ICmpLt/ICmpGte got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool gt = (false);
    if ((isIntegerPU5175rB)((t1))) {
        bool signed_ = ((isSignedIntegerPU5175rB)((t1)));
        if ((s1) == ((usize)(1llu))) {
            if (signed_)
                ((gt) = ((*((i8 *)((lhsStart)))) < (*((i8 *)((rhsStart))))));
            else
                ((gt) = ((*((u8 *)((lhsStart)))) < (*((u8 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(2llu))) {
            if (signed_)
                ((gt) = ((*((i16 *)((lhsStart)))) < (*((i16 *)((rhsStart))))));
            else
                ((gt) = ((*((u16 *)((lhsStart)))) < (*((u16 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(4llu))) {
            if (signed_)
                ((gt) = ((*((i32 *)((lhsStart)))) < (*((i32 *)((rhsStart))))));
            else
                ((gt) = ((*((u32 *)((lhsStart)))) < (*((u32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            if (signed_)
                ((gt) = ((*((i64 *)((lhsStart)))) < (*((i64 *)((rhsStart))))));
            else
                ((gt) = ((*((u64 *)((lhsStart)))) < (*((u64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("int cmpgt with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp ICmpGt/ICmpLte on non-int")));
    }

    u8 r = ((u8)(0));
    if (gt)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_INT_CMP_GTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatAddPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatAdd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatAdd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatAdd expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) + (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) + (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float add with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatSubPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatSub LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatSub RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatSub expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) - (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) - (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float sub with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatMulPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatMul LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatMul RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatMul expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) * (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) * (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float mul with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatDivPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatDiv LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatDiv RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatDiv expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = ((*((f32 *)((lhsStart)))) / (*((f32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = ((*((f64 *)((lhsStart)))) / (*((f64 *)((rhsStart))))));
    }

    else {
        ((unreachablePcrN)(("float div with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatModPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FloatMod LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FloatMod RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((rLhs).size);
    usize s2 = ((rRhs).size);
    ((assertBPcrN)(((s1) == (s2)), ("FloatMod expected LHS and RHS to be the same size")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    if ((s1) == ((usize)(4llu))) {
        ((*((f32 *)((start)))) = (fmodf((*((f32 *)((lhsStart)))), (*((f32 *)((rhsStart)))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((f64 *)((start)))) = (fmod((*((f64 *)((lhsStart)))), (*((f64 *)((rhsStart)))))));
    }

    else {
        ((unreachablePcrN)(("float mod with sus bitsize")));
    }

    return (dst);
}
InterpReg_s evaluateFloatCmpEqAndNeqPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpNeq/FCmpEq LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpNeq/FCmpEq RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpNeq/FCmpEq got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) == (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) == (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpEq/FCmpNeq on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_NEQ))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatCmpGtAndLtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpLte/FCmpGt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpLte/FCmpGt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpLte/FCmpGt got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) > (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) > (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpGt/FCmpLte on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_LTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateFloatCmpLtAndGtePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("FCmpGte/FCmpLt LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("FCmpGte/FCmpLt RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("FCmpGte/FCmpLt got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    bool eq = (false);
    if ((isFloatPU5175rB)((t1))) {
        if ((s1) == ((usize)(4llu))) {
            ((eq) = ((*((f32 *)((lhsStart)))) < (*((f32 *)((rhsStart))))));
        }

        else if ((s1) == ((usize)(8llu))) {
            ((eq) = ((*((f64 *)((lhsStart)))) < (*((f64 *)((rhsStart))))));
        }

        else {
            ((unreachablePcrN)(("float cmp with sus bitsize")));
        }

    }

    else {
        ((unreachablePcrN)(("Interp FCmpLt/FCmpGte on non-float")));
    }

    u8 r = ((u8)(0));
    if (eq)
        ((r) = ((u8)(1)));
    if (((instr)->kind) == (INSTR_FLOAT_CMP_GTE))
        ((r) = (((u8)(1)) - (r)));
    ((*(start)) = (r));
    return (dst);
}
InterpReg_s evaluateLogicalNotPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("LNot SRC")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 val = (*(srcStart));
    ((assertBPcrN)((((val) == ((u8)(0))) || ((val) == ((u8)(1)))), ("Logical Not got non-zero non-one")));
    ((*(dstStart)) = (((u8)(1)) - (val)));
    return (dst);
}
InterpReg_s evaluateLogicalAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("LAnd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("LAnd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("LAnd got differently sized operands")));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 l = (*(lhsStart));
    u8 r = (*(rhsStart));
    ((*(dstStart)) = ((u8)(0)));
    if (((l) == ((u8)(1))) && ((r) == ((u8)(1)))) {
        ((*(dstStart)) = ((u8)(1)));
    }

    return (dst);
}
InterpReg_s evaluateLogicalOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("LOr LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("LOr RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("LOr got differently sized operands")));
    ((assertBPcrN)(((s1) == ((usize)(1llu))), ("Idk")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(1llu))});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    u8 l = (*(lhsStart));
    u8 r = (*(rhsStart));
    ((*(dstStart)) = ((u8)(0)));
    if (((l) == ((u8)(1))) || ((r) == ((u8)(1)))) {
        ((*(dstStart)) = ((u8)(1)));
    }

    return (dst);
}
InterpReg_s evaluateBitwiseAndPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BAnd LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BAnd RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BAnd got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) & (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) & (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) & (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) & (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BAnd")));
    return (dst);
}
InterpReg_s evaluateBitwiseOrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BOr LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BOr RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BOr got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) | (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) | (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) | (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) | (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BOr")));
    return (dst);
}
InterpReg_s evaluateBitwiseXorPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *lhs = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *rhs = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rLhs = ((asInterpPU5952PcrS9925)((lhs), ("BXor LHS")));
    InterpReg_s rRhs = ((asInterpPU5952PcrS9925)((rhs), ("BXor RHS")));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->op1)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) == (s2)), ("BXor got differently sized operands")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s1)});
    u8 *lhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rLhs))));
    u8 *rhsStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rRhs))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    if ((s1) == ((usize)(1llu))) {
        ((*((u8 *)((dstStart)))) = ((*((u8 *)((lhsStart)))) ^ (*((u8 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(2llu))) {
        ((*((u16 *)((dstStart)))) = ((*((u16 *)((lhsStart)))) ^ (*((u16 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(4llu))) {
        ((*((u32 *)((dstStart)))) = ((*((u32 *)((lhsStart)))) ^ (*((u32 *)((rhsStart))))));
    }

    else if ((s1) == ((usize)(8llu))) {
        ((*((u64 *)((dstStart)))) = ((*((u64 *)((lhsStart)))) ^ (*((u64 *)((rhsStart))))));
    }

    else
        ((unreachablePcrN)(("Exhaustive handling of types in BXOr")));
    return (dst);
}
InterpReg_s evaluateInsertValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    Type_u *t = ((dstReg)->typ);
    bool succ_1996_ = true;
    bool succ_2004_ = true;

    Type_u *tmp_3146_ = (t);
    {
        succ_1996_ &= (tmp_3146_->tag == 5);
        Type_u **under = &tmp_3146_->payload.variant5._0;
        succ_1996_ &= true;
        usize *_size = &tmp_3146_->payload.variant5._1;
        succ_1996_ &= true;
        if (succ_1996_) {
            {
                InterpReg_s valReg = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("Interp InsertValue Array")));
                usize size = ((getSizeInBytesPU5175rusz)((*under)));
                usize offset = ((((instr)->src).i) * (size));
                (((memcpy))(((u8 *)((unsigned char *)(dstStart) + (offset))), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(valReg)))), (size)));
            }
            goto after_3146;
        }
    }
    {
        succ_2004_ &= (tmp_3146_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_3146_->payload.variant7._0;
        succ_2004_ &= true;
        if (succ_2004_) {
            {
                usize offset = ((usize)(0llu));
                usize fieldSize = ((usize)(0llu));
                ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (((instr)->src).i), (&(offset)), (&(fieldSize)), (false)));
                InterpReg_s valReg = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("Interp InsertValue Struct")));
                ((assertBPcrN)((((valReg).size) == (fieldSize)), ("field size mismatch in Interp InsertValue")));
                (((memcpy))(((u8 *)((unsigned char *)(dstStart) + (offset))), ((getRegStackPointerPS3154PS9925rPu8)((this), (&(valReg)))), (fieldSize)));
            }
            goto after_3146;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Interp InsertValue expected Array or Struct")));
            }
            goto after_3146;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_3146:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
InterpReg_s evaluateIntSignExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("SExt src")));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    ((assertBPcrN)(((isSignedIntegerPU5175rB)((t))), ("SExt expected Signed Integer")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((rSrc).size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    ((todo_with_msgPcrN)(("sext")));
}
InterpReg_s evaluateIntZeroExtendPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("ZExt src")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s2) > (s1)), ("Zero Extend expected dst to be greater than src")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s2)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    (((memset))((dstStart), ((i32)(0)), (s2)));
    if ((s1) == ((usize)(1llu)))
        ((*(dstStart)) = (*(srcStart)));
    else if ((s1) == ((usize)(2llu)))
        ((*((u16 *)((dstStart)))) = (*((u16 *)((srcStart)))));
    else if ((s1) == ((usize)(4llu)))
        ((*((u32 *)((dstStart)))) = (*((u32 *)((srcStart)))));
    else
        ((unreachablePcrN)(("ZExt 8 byte to what?")));
    return (dst);
}
InterpReg_s evaluateIntTruncatePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("Trunc src")));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    Type_u *t1 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    Type_u *t2 = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
    usize s1 = ((getSizeInBytesPU5175rusz)((t1)));
    usize s2 = ((getSizeInBytesPU5175rusz)((t2)));
    ((assertBPcrN)(((s1) > (s2)), ("Int Truncate expected src to be greater than dst")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (s2)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    (((memset))((dstStart), ((i32)(0)), (s2)));
    if ((s1) == ((usize)(8llu)))
        ((*((u64 *)((dstStart)))) = (*((u64 *)((srcStart)))));
    else if ((s1) == ((usize)(4llu)))
        ((*((u32 *)((dstStart)))) = (*((u32 *)((srcStart)))));
    else if ((s1) == ((usize)(2llu)))
        ((*((u16 *)((dstStart)))) = (*((u16 *)((srcStart)))));
    else
        ((unreachablePcrN)(("Truncate 1 byte to what?")));
    return (dst);
}
InterpReg_s evaluateF32ToF64PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F32ToF64")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(8llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f32 v = (*((f32 *)((srcStart))));
    ((*((f64 *)((dstStart)))) = ((f64)((v))));
    return (dst);
}
InterpReg_s evaluateF64ToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F64ToF32")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(4llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f64 v = (*((f64 *)((srcStart))));
    ((*((f32 *)((dstStart)))) = ((f32)((v))));
    return (dst);
}
InterpReg_s evaluateCreateArrayPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCreateStructPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateCreateUnionPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)))});
    (((memset))(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst)))), ((i32)(0)), ((dst).size)));
    return (dst);
}
InterpReg_s evaluateIntToF32PS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp IntToF32")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = ((usize)(4llu))});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    bool signed_ = ((isSignedIntegerPU5175rB)((t)));
    usize s = ((getSizeInBytesPU5175rusz)((t)));
    f32 v = ((f32)(0));
    if ((s) == ((usize)(1llu))) {
        if (signed_)
            ((v) = ((f32)((*((i8 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u8 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(2llu))) {
        if (signed_)
            ((v) = ((f32)((*((i16 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u16 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(4llu))) {
        if (signed_)
            ((v) = ((f32)((*((i32 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u32 *)((srcStart)))))));
    }

    else if ((s) == ((usize)(8llu))) {
        if (signed_)
            ((v) = ((f32)((*((i64 *)((srcStart)))))));
        else
            ((v) = ((f32)((*((u64 *)((srcStart)))))));
    }

    else {
        ((unreachablePcrN)(("Interp unexpected size in IntToF32")));
    }

    ((*((f32 *)((dstStart)))) = (v));
    return (dst);
}
InterpReg_s evaluateF32ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F32ToInt")));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    bool signed_ = ((isSignedIntegerPU5175rB)(((dstReg)->typ)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f32 v = (*((f32 *)((srcStart))));
    if ((size) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((dstStart)))) = ((i8)((v))));
        else
            ((*((u8 *)((dstStart)))) = ((u8)((v))));
    }

    else if ((size) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((dstStart)))) = ((i16)((v))));
        else
            ((*((u16 *)((dstStart)))) = ((u16)((v))));
    }

    else if ((size) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((dstStart)))) = ((i32)((v))));
        else
            ((*((u32 *)((dstStart)))) = ((u32)((v))));
    }

    else if ((size) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((dstStart)))) = ((i64)((v))));
        else
            ((*((u64 *)((dstStart)))) = ((u64)((v))));
    }

    else {
        ((unreachablePcrN)(("Interp F32ToInt: Exhaustive handling of destinations")));
    }

    return (dst);
}
InterpReg_s evaluateF64ToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s src = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp F64ToInt")));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    bool signed_ = ((isSignedIntegerPU5175rB)(((dstReg)->typ)));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    u8 *srcStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(src))));
    u8 *dstStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))));
    f64 v = (*((f64 *)((srcStart))));
    if ((size) == ((usize)(1llu))) {
        if (signed_)
            ((*((i8 *)((dstStart)))) = ((i8)((v))));
        else
            ((*((u8 *)((dstStart)))) = ((u8)((v))));
    }

    else if ((size) == ((usize)(2llu))) {
        if (signed_)
            ((*((i16 *)((dstStart)))) = ((i16)((v))));
        else
            ((*((u16 *)((dstStart)))) = ((u16)((v))));
    }

    else if ((size) == ((usize)(4llu))) {
        if (signed_)
            ((*((i32 *)((dstStart)))) = ((i32)((v))));
        else
            ((*((u32 *)((dstStart)))) = ((u32)((v))));
    }

    else if ((size) == ((usize)(8llu))) {
        if (signed_)
            ((*((i64 *)((dstStart)))) = ((i64)((v))));
        else
            ((*((u64 *)((dstStart)))) = ((u64)((v))));
    }

    else {
        ((unreachablePcrN)(("Interp F64ToInt: Exhaustive handling of destinations")));
    }

    return (dst);
}
InterpReg_s evaluatePtrToIntPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp PtrToInt")));
}
InterpReg_s evaluateIntToPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    return ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("Interp IntToPtr")));
}
InterpReg_s evaluateGetFieldPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *fReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s fAggr = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("IRInterp: GetFieldPtr")));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    ((assertBPcrN)(((isStructPointerPU5175rB)((t))), ("IRInterp: GetFieldPtr got non-struct pointer")));
    Type_u *u = ((getUnderlyingTypePU5175BrPU5175)((t), (false)));
    ParsedStructDecl_s *decl = (NULL);
    bool succ_2157_ = true;

    Type_u *tmp_3332_ = (u);
    {
        succ_2157_ &= (tmp_3332_->tag == 7);
        ParsedStructDecl_s **_decl = &tmp_3332_->payload.variant7._0;
        succ_2157_ &= true;
        if (succ_2157_) {
            {
                ((decl) = (*_decl));
            }
            goto after_3332;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected Struct in evaluateGetFieldPtr")));
            }
            goto after_3332;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_3332:
    (void)0; // error: label at end of compound statement is a C23 extension
    usize offset = ((usize)(0llu));
    usize size = ((usize)(0llu));
    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((decl), (((instr)->op1).i), (&(offset)), (&(size)), (false)));
    InterpReg_s reg = ((InterpReg_s){.offset = ((fReg)->offset), .size = ((usize)(8llu))});
    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(reg))));
    u8 *ptr = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(fAggr))));
    ((*((usize *)((regStackLoc)))) = ((*((usize *)((ptr)))) + (offset)));
    return (reg);
}
InterpReg_s evaluateGetElementPtrPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *elemReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    InterpReg_s aggr = ((asInterpPU5952PcrS9925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("IRInterp: GetElementPtr")));
    u8 *ptr = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(aggr))));
    InterpReg_s dstReg = ((InterpReg_s){.offset = ((elemReg)->offset), .size = ((usize)(8llu))});
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ);
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        RegIndex_s *arg = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), ((arg)->i)));
        InterpReg_s tmp_15609 = ((asInterpPU5952PcrS9925)((reg), ("IRInterp: GetElementPtr index")));

        usize elems = (*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&tmp_15609))))));
        bool succ_2189_ = true;
        bool succ_2194_ = true;
        bool succ_2201_ = true;
        bool succ_2198_ = true;

        Type_u *tmp_3363_ = (t);
        {
            succ_2189_ &= (tmp_3363_->tag == 4);
            Type_u **underlying = &tmp_3363_->payload.variant4._0;
            succ_2189_ &= true;
            if (succ_2189_) {
                {
                    ((offset) = ((offset) + ((elems) * ((getSizeInBytesPU5175rusz)((*underlying))))));
                    ((t) = (*underlying));
                }
                goto after_3363;
            }
        }
        {
            succ_2194_ &= (tmp_3363_->tag == 5);
            Type_u **underlying = &tmp_3363_->payload.variant5._0;
            succ_2194_ &= true;
            succ_2194_ &= true;
            if (succ_2194_) {
                {
                    ((offset) = ((offset) + ((elems) * ((getSizeInBytesPU5175rusz)((*underlying))))));
                    ((t) = (*underlying));
                }
                goto after_3363;
            }
        }
        {
            succ_2201_ &= (tmp_3363_->tag == 4);
            succ_2198_ &= (tmp_3363_->payload.variant4._0->tag == 7);
            ParsedStructDecl_s **decl = &tmp_3363_->payload.variant4._0->payload.variant7._0;
            succ_2198_ &= true;
            succ_2201_ &= succ_2198_;
            if (succ_2201_) {
                {
                    ((todo_with_msgPcrN)(("IRInterp: evaluateGetElementPtr on Struct")));
                }
                goto after_3363;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s IRInterp: evaluateGetElementPtr source has unexpected type!\n"), (FATAL_STR)));
                    (((fprintf))((stderr_), ("%s IRInterp: The type: %s\n"), (FATAL_STR), (((toStringPU5175rS0540)((t))).buffer)));
                    (((C_exiti32rN))(((i32)(2))));
                }
                goto after_3363;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_3363:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    u8 *regStackLoc = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(dstReg))));
    ((*((usize *)((regStackLoc)))) = ((*((usize *)((ptr)))) + (offset)));
    return (dstReg);
}
InterpReg_s evaluateUnreachablePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((unreachablePcrN)(("IRInterp: Hit INSTR_UNREACHABLE")));
}
InterpReg_s evaluateUnterminatedPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    ((unreachablePcrN)(("IRInterp: Hit INSTR_UNTERMINATED")));
}
InterpReg_s evaluateMemcpyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    RegValue_u *dst = ((atPS5884uszrPU5952)((regs), (((instr)->dst).i)));
    RegValue_u *size = ((atPS5884uszrPU5952)((regs), (((instr)->op1).i)));
    InterpReg_s rSrc = ((asInterpPU5952PcrS9925)((src), ("Memcpy src")));
    InterpReg_s rDst = ((asInterpPU5952PcrS9925)((dst), ("Memcpy dst")));
    InterpReg_s rSize = ((asInterpPU5952PcrS9925)((size), ("Memcpy size")));
    u8 *srcLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSrc)))))))));
    u8 *dstLoc = ((u8 *)((*((usize *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(rDst)))))))));
    u8 *sizeStart = ((getRegStackPointerPS3154PS9925rPu8)((this), (&(rSize))));
    usize sizeValue = (*((usize *)((sizeStart))));
    (((memcpy))((dstLoc), (srcLoc), (sizeValue)));
    return (rDst);
}
InterpReg_s evaluateEmitAssemblyPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    String_s loc = ((toStringPS8951rS0540)((&((instr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Inline Assembly can\'t be used in a comptime context.\n"), ((loc).buffer), (ERR_STR)));
    ((dumpCallStackPS3154PS0540rN)((this), (&(loc))));
    ((dropPS0540rN)((&(loc))));
    (((C_exiti32rN))(((i32)(1))));
}
InterpReg_s evaluateIntoIRValuePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    RegValue_u *src = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    ((assertBPcrN)(((size) == (sizeof(RegValue_u))), ("IntoIRValue: size mismatch with llvm")));
    ((assertBPcrN)(((size) == (sizeof(IRValue_u))), ("IntoIRValue: size mismatch with asm")));
    InterpReg_s dst = ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
    ((*((RegValue_u *)(((getRegStackPointerPS3154PS9925rPu8)((this), (&(dst))))))) = (*(src)));
    return (dst);
}
InterpReg_s evaluateDebugInfoPS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    IRReg_s *dstReg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
    usize size = ((getSizeInBytesPU5175rusz)(((dstReg)->typ)));
    return ((InterpReg_s){.offset = ((dstReg)->offset), .size = (size)});
}
InterpReg_s evaluateSinglePS3154PS7132PS7680PS5884BrS9925(IRInterp_s *this, IRFunc_s *irFunc, IRInstr_s *instr, RegValueList_s *regs, bool forcedComptime) {
    if (!(forcedComptime)) {
        ((assertBPcrN)(((instr)->isComptime), ("Expected comptime instr in IRInterp.evaluateSingle")));
    }

    ((assertBPcrN)((((this)->regStackBase) < ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))), ("Stack Cursor Overflow in IRInterp.evaluateSingle")));
    if ((*((flags).debug)) && (*((flags).verbose)))
        ((dumpPS7680rN)((instr)));
    return ((((instrFns).arr)[((instr)->kind)])((this), (irFunc), (instr), (regs), (forcedComptime)));
}
bool evaluateBlockPS3154PS7192PS7132PS5884BrB(IRInterp_s *this, IRBlockID_s *blockID, IRFunc_s *irFunc, RegValueList_s *regs, bool forcedComptime) {
    IRBlock_s *block = ((getBlockByIDPS7132S7192rPS9435)((irFunc), (*(blockID))));
    ((assertBPcrN)(((((block)->instructions).length) > ((usize)(0llu))), ("Interp: Encountered empty block")));
    for (usize ip = ((usize)(0llu)); ((ip) < (((block)->instructions).length)); ((ip) = ((ip) + ((usize)(1llu))))) {
        IRInstr_s *instr = ((atPS0124uszrPS7680)((&((block)->instructions)), (ip)));
        InterpReg_s result = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)((this), (irFunc), (instr), (regs), (forcedComptime)));
        if ((ip) == ((((block)->instructions).length) - ((usize)(1llu)))) {
            ((assertBPcrN)(((isTerminatorPS7680rB)((instr))), ("Interp: Unexpected non-terminator at the end of a block")));
            bool ret = (((result).size) == ((usize)(1llu)));
            if (ret) {
                ((*(blockID)) = ((IRBlockID_s){.i = ((result).offset)}));
            }

            return (ret);
        }

        else {
            ((assertBPcrN)((!((isTerminatorPS7680rB)((instr)))), ("Interp: Unexpected terminator in the middle of a block")));
            ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (result)));
        }
    }

    return (false);
}
Function_s compileFunctionCallPS3154PS7132PS7132PS7680uszPS5884rS1803(IRInterp_s *this, IRFunc_s *currFunc, IRFunc_s *calledFunc, IRInstr_s *instr, usize fn, RegValueList_s *regs) {
    ((todo_with_msgPcrN)(("comptime extern call")));
}
none evaluateCallPS3154S8951PS7132PS5884rN(IRInterp_s *this, Span_s span, IRFunc_s *irFunc, RegValueList_s *regs) {
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((irFunc)));
    ParsedFuncDecl_s *fn = ((atPS4111uszrPS4904)((&(funcDecls)), ((irFunc)->originalID)));
    ((pushCallStackPS3154S8951S0540rN)((this), (span), ((toStringPS7720rS0540)((&(((fn)->name).content))))));
    ((pushRegisterStackPS3154S8951uszrN)((this), (span), (funcSize)));
    IRBlockID_s blockID = ((IRBlockID_s){.i = ((usize)(0llu))});
    while ((evaluateBlockPS3154PS7192PS7132PS5884BrB)((this), (&(blockID)), (irFunc), (regs), (true))) {
    }

    ((popRegisterStackPS3154S8951uszrN)((this), (span), (funcSize)));
    ((popCallStackPS3154rN)((this)));
    return;
}
none pushRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size) {
    u8 *new = ((u8 *)((unsigned char *)((this)->regStackBase) + (size)));
    if ((new) > ((u8 *)((unsigned char *)((this)->regStackStart) + (REG_STACK_SIZE)))) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s Register Stack Overflow in the comptime interpreter.\n"), ((loc).buffer), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: %s Tried to reserve %llu byte(s).\n"), ((loc).buffer), (FATAL_STR), (size)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->regStackBase) = (new));
}
none popRegisterStackPS3154S8951uszrN(IRInterp_s *this, Span_s span, usize size) {
    u8 *new = ((u8 *)((unsigned char *)((this)->regStackBase) - (size)));
    if ((new) < ((this)->regStackStart)) {
        String_s loc = ((toStringPS8951rS0540)((&(span))));
        (((fprintf))((stderr_), ("%s: %s Register Stack Underflow in the comptime interpreter.\n"), ((loc).buffer), (FATAL_STR)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(2))));
    }

    (((this)->regStackBase) = (new));
    ((assertBPcrN)((((this)->regStackBase) >= ((this)->globalRegBase)), ("Register Stack overwrote global stack")));
}
none pushCallStackPS3154S8951S0540rN(IRInterp_s *this, Span_s span, String_s name) { ((pushPS2247S6579rN)((&((this)->callStack)), ((CallStackInfo_s){.span = (span), .name = (name)}))); }
none popCallStackPS3154rN(IRInterp_s *this) {
    ((assertBPcrN)(((((this)->callStack).length) > ((usize)(0llu))), ("IRInterp.popCallStack() called on empty stack!")));
    ((popPS2247rPS6579)((&((this)->callStack))));
}
none dumpCallStackPS3154PS0540rN(IRInterp_s *this, String_s *loc) {
    (((fprintf))((stderr_), ("%s: %s: The current call stack:\n"), ((loc)->buffer), (NOTE_STR)));
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->callStack).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->callStack).length) - (_i)) - ((usize)(1llu)));
        CallStackInfo_s *e = ((atPS2247uszrPS6579)((&((this)->callStack)), (i)));
        String_s l = ((toStringPS8951rS0540)((&((e)->span))));
        (((fprintf))((stderr_), ("%s: %s: Entered function `%s` here.\n"), ((l).buffer), (NOTE_STR), (((e)->name).buffer)));
        ((dropPS0540rN)((&(l))));
    }
}
IRInterp_s newIRInterpreterPS9562rS3154(IRGen_s *irGen) {
    u8 *regStack = (((malloc))((REG_STACK_SIZE)));
    ((assertBPcrN)(((regStack) != (NULL)), ("Could not prepare IRInterp.regStack")));
    u8 *realStack = (((malloc))((STACK_SIZE)));
    ((assertBPcrN)(((realStack) != (NULL)), ("Could not prepare IRInterp.realStack")));
    u8 *argStack = (((malloc))(((usize)(640000llu))));
    ((assertBPcrN)(((argStack) != (NULL)), ("Could not prepare IRInterp.argStack")));
    return ((IRInterp_s){.irGen = (irGen),
                         .globalRegisters = (NULL),
                         .regStackStart = (regStack),
                         .globalRegBase = (regStack),
                         .regStackBase = (regStack),
                         .realStackStart = (realStack),
                         .realStackPointer = (realStack),
                         .realStackBase = (realStack),
                         .argStack = (argStack),
                         .argStackLength = ((usize)(0llu)),
                         .argStackCapacity = ((usize)(640000llu))});
}
bool equalsPS7469PS7469rB(LLVMBasicBlock_s *this, LLVMBasicBlock_s *other) { return ((((this)->ref).ptr) == (((other)->ref).ptr)); }
none guardReferencePS7469rN(LLVMBasicBlock_s *this) { ((assertBPcrN)((!(((LLVM_isNullS6239rB))(((this)->ref)))), ("LLVM Basic Block is null"))); }
LLVMValue_s getParentPS7469rS8925(LLVMBasicBlock_s *this) {
    ((guardReferencePS7469rN)((this)));
    LLVM_ValueRef_s parent = (((LLVMGetBasicBlockParent))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((parent)))), ("Could not get parent from basic block")));
    return ((newLLVMValueFromRefS1407rS8925)((parent)));
}
bool getLastInstructionPS7469PS8925rB(LLVMBasicBlock_s *this, LLVMValue_s *out) {
    ((guardReferencePS7469rN)((this)));
    LLVM_ValueRef_s instr = (((LLVMGetLastInstruction))(((this)->ref)));
    if (((LLVM_isNullS1407rB))((instr)))
        return (false);
    ((*(out)) = ((newLLVMValueFromRefS1407rS8925)((instr))));
    return (true);
}
LLVMBasicBlock_s newLLVMBasicBlockFromRefS6239rS7469(LLVM_BasicBlockRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((ref)))), ("Passed invalid reference to newLLVMBasicBlockFromRef")));
    return ((LLVMBasicBlock_s){.ref = (ref)});
}
LLVMAttribute_s newLLVMAttributeFromRefS8710rS6660(LLVM_AttributeRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS8710rB))((ref)))), ("newLLVMAttributeFromRef called with invalid reference")));
    return ((LLVMAttribute_s){.ref = (ref)});
}
bool equalsPS8925PS8925rB(LLVMValue_s *this, LLVMValue_s *other) { ((todo_with_msgPcrN)(("LLVMValue.equals"))); }
none guardReferencePS8925rN(LLVMValue_s *this) { ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((this)->ref)))), ("LLVM Value is null"))); }
bool isStructValuePS8925rB(LLVMValue_s *this) {
    LLVMType_s t = ((getTypePS8925rS0706)((this)));
    return ((isStructPS0706rB)((&(t))));
}
none dumpPS8925rN(LLVMValue_s *this) { (((LLVMDumpValue))(((this)->ref))); }
LLVMType_s getGlobalTypePS8925rS0706(LLVMValue_s *this) {
    LLVM_TypeRef_s t = (((LLVMGlobalGetValueType))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get global type of LLVMValue")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
LLVMValue_s getNthParamPS8925uszrS8925(LLVMValue_s *this, usize index) {
    LLVM_ValueRef_s param = (((LLVMGetParam))(((this)->ref), ((u32)((index)))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((param)))), ("Could not get parameter of LLVMValue")));
    return ((newLLVMValueFromRefS1407rS8925)((param)));
}
LLVMBasicBlock_s getFirstBasicBlockPS8925rS7469(LLVMValue_s *this) {
    LLVM_BasicBlockRef_s block = (((LLVMGetFirstBasicBlock))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not get first basic block from LLVMValue")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMType_s getTypePS8925rS0706(LLVMValue_s *this) {
    LLVM_TypeRef_s t = (((LLVMTypeOf))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get type of LLVMValue")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
none setNamePS8925S7720rN(LLVMValue_s *this, SubStr_s name) { (((LLVMSetValueName2))(((this)->ref), ((name).start), ((name).len))); }
SubStr_s getNamePS8925rS7720(LLVMValue_s *this) {
    usize len = ((usize)(0llu));
    char *name = (((LLVMGetValueName2))(((this)->ref), (&(len))));
    return ((newSubStrPcuszuszrS7720)((name), ((usize)(0llu)), (len)));
}
none setInitializerPS8925S8925rN(LLVMValue_s *this, LLVMValue_s val) {
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((val).ref)))), ("Expected valid LLVMValue in LLVMValue.setInitializer")));
    (((LLVMSetInitializer))(((this)->ref), ((val).ref)));
}
LLVMValue_s getInitializerPS8925rS8925(LLVMValue_s *this) {
    LLVM_ValueRef_s val = (((LLVMGetInitializer))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get initializer of LLVMValue")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
none addAttributePS8925u32S6660rN(LLVMValue_s *this, u32 index, LLVMAttribute_s attr) { (((LLVMAddAttributeAtIndex))(((this)->ref), (index), ((attr).ref))); }
LLVMValue_s newLLVMValueFromRefS1407rS8925(LLVM_ValueRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((ref)))), ("Passed invalid reference to newLLVMValueFromRef")));
    return ((LLVMValue_s){.ref = (ref)});
}
bool equalsPS0706PS0706rB(LLVMType_s *this, LLVMType_s *other) { return ((((this)->ref).ptr) == (((other)->ref).ptr)); }
bool isFunctionPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMFunctionTypeKind)); }
LLVMType_s getReturnTypePS0706rS0706(LLVMType_s *this) {
    ((assertBPcrN)(((isFunctionPS0706rB)((this))), ("LLVM::getReturnType() called on non-function")));
    LLVM_TypeRef_s t = (((LLVMGetReturnType))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((t)))), ("Could not get return type")));
    return ((newLLVMTypeFromRefS6708rS0706)((t)));
}
bool isVoidPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMVoidTypeKind)); }
bool isStructPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMStructTypeKind)); }
bool isPointerPS0706rB(LLVMType_s *this) { return ((((LLVMGetTypeKind))(((this)->ref))) == (LLVMPointerTypeKind)); }
char *toCharsPS0706rPc(LLVMType_s *this) { return (((LLVMPrintTypeToString))(((this)->ref))); }
LLVMType_s intoFunctionTypePS0706S4318BrS0706(LLVMType_s *this, LLVMTypeList_s params, bool varArg) {
    ((assertBrN)(((sizeof(LLVMType_s)) == ((usize)(8llu)))));
    LLVM_TypeRef_s fn = (((LLVMFunctionType))(((this)->ref), ((LLVM_TypeRef_s *)(((params).elements))), ((u32)(((params).length))), ((newLLVMBoolBrS2924)((varArg)))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((fn)))), ("Could not turn LLVMType into a FunctionType")));
    return ((newLLVMTypeFromRefS6708rS0706)((fn)));
}
LLVMType_s intoPointerTypePS0706rS0706(LLVMType_s *this) {
    LLVM_TypeRef_s ptr = (((LLVMPointerType))(((this)->ref), ((u32)(0))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((ptr)))), ("Could not turn LLVMType into a PointerType")));
    return ((newLLVMTypeFromRefS6708rS0706)((ptr)));
}
LLVMType_s intoArrayTypePS0706u32rS0706(LLVMType_s *this, u32 size) {
    LLVM_TypeRef_s arr = (((LLVMArrayType))(((this)->ref), (size)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((arr)))), ("Could not turn LLVMType into a ArrayType")));
    return ((newLLVMTypeFromRefS6708rS0706)((arr)));
}
LLVMValue_s constIntPS0706uszBrS8925(LLVMType_s *this, usize value, bool signExtend) {
    LLVMBool_s s = ((newLLVMBoolBrS2924)((signExtend)));
    LLVM_ValueRef_s val = (((LLVMConstInt))(((this)->ref), (value), (s)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant integer")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s constZeroPS0706rS8925(LLVMType_s *this) {
    LLVM_ValueRef_s val = (((LLVMConstNull))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant zero")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s constFloatPS0706f64rS8925(LLVMType_s *this, f64 value) {
    LLVM_ValueRef_s val = (((LLVMConstReal))(((this)->ref), (value)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not get constant float")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s getInlineAsmPS0706PS6859rS8925(LLVMType_s *this, ASMContext_s *context) {
    String_s constraints = ((collectPS6859rS0540)((context)));
    LLVM_ValueRef_s val =
        (((LLVMGetInlineAsm))(((this)->ref), (((context)->code).buffer), (((context)->code).length), ((constraints).buffer), ((constraints).length), ((newLLVMBoolBrS2924)(((context)->sideEffects))),
                              ((newLLVMBoolBrS2924)(((context)->alignedStack))), ((u32)(((tagAnyru8)((&((context)->dialect)))))), ((newLLVMBoolBrS2924)(((context)->canThrow)))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not generate inline assembly")));
    ((dropPS0540rN)((&(constraints))));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMType_s newLLVMTypeFromRefS6708rS0706(LLVM_TypeRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((ref)))), ("Passed invalid reference to newLLVMTypeFromRef")));
    return ((LLVMType_s){.ref = (ref)});
}
LLVMPassBuilderOptions_s createPassBuilderOptionsrS4890(none) {
    LLVM_PassBuilderOptionsRef_s v = (((LLVMCreatePassBuilderOptions))());
    ((assertBPcrN)((!(((LLVM_isNullS7356rB))((v)))), ("Could not create Pass Builder Options")));
    return ((LLVMPassBuilderOptions_s){.ref = (v)});
}
none disposePassBuilderOptionsS4890rN(LLVMPassBuilderOptions_s opt) { (((LLVMDisposePassBuilderOptions))(((opt).ref))); }
none setVerifyEachS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s verify) { (((LLVMPassBuilderOptionsSetVerifyEach))(((opt).ref), (verify))); }
none setDebugLoggingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s debug) { (((LLVMPassBuilderOptionsSetDebugLogging))(((opt).ref), (debug))); }
none setAAPipelineS4890PcrN(LLVMPassBuilderOptions_s opt, char *pipeline) { (((LLVMPassBuilderOptionsSetAAPipeline))(((opt).ref), (pipeline))); }
none setLoopInterleavingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s interleave) { (((LLVMPassBuilderOptionsSetLoopInterleaving))(((opt).ref), (interleave))); }
none setLoopVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize) { (((LLVMPassBuilderOptionsSetLoopVectorization))(((opt).ref), (vectorize))); }
none setSLPVectorizationS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s vectorize) { (((LLVMPassBuilderOptionsSetSLPVectorization))(((opt).ref), (vectorize))); }
none setLoopUnrollingS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s unroll) { (((LLVMPassBuilderOptionsSetLoopUnrolling))(((opt).ref), (unroll))); }
none setForgetAllSCEVInLoopUnrollS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s forget) { (((LLVMPassBuilderOptionsSetForgetAllSCEVInLoopUnroll))(((opt).ref), (forget))); }
none setLicmMssaOptCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap) { (((LLVMPassBuilderOptionsSetLicmMssaOptCap))(((opt).ref), (cap))); }
none setLicmMssaNoAccForPromotionCapS4890u32rN(LLVMPassBuilderOptions_s opt, u32 cap) { (((LLVMPassBuilderOptionsSetLicmMssaNoAccForPromotionCap))(((opt).ref), (cap))); }
none setCallGraphProfileS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s profile) { (((LLVMPassBuilderOptionsSetCallGraphProfile))(((opt).ref), (profile))); }
none setMergeFunctionsS4890S2924rN(LLVMPassBuilderOptions_s opt, LLVMBool_s merge) { (((LLVMPassBuilderOptionsSetMergeFunctions))(((opt).ref), (merge))); }
none setInlinerThresholdS4890i32rN(LLVMPassBuilderOptions_s opt, i32 threshold) { (((LLVMPassBuilderOptionsSetInlinerThreshold))(((opt).ref), (threshold))); }
usize getBitSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMSizeOfTypeInBits))(((this)->ref), ((typ)->ref))); }
usize getABISizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMABISizeOfType))(((this)->ref), ((typ)->ref))); }
usize getStoreSizePS8369PS0706rusz(LLVMTargetData_s *this, LLVMType_s *typ) { return (((LLVMStoreSizeOfType))(((this)->ref), ((typ)->ref))); }
LLVMDataLayout_s getDataLayoutPS8369rS7896(LLVMTargetData_s *this) {
    char *c = (((LLVMCopyStringRepOfTargetData))(((this)->ref)));
    if (*((flags).debug)) {
        (((printf))(("[INFO] LLVM Data Layout: %s\n"), (c)));
    }

    return ((LLVMDataLayout_s){.ref = (c)});
}
LLVMTargetData_s newLLVMTargetDataFromRefS6307rS8369(LLVM_TargetDataRef_s ref) { return ((LLVMTargetData_s){.ref = (ref)}); }
LLVMTargetMachine_s createTargetMachinePS4231PcPcPcrS7964(LLVMTarget_s *this, char *triple, char *cpu, char *features) {
    LLVM_TargetMachineRef_s target = (((LLVMCreateTargetMachine))(((this)->ref), (triple), (cpu), (features), ((i32)(0)), ((i32)(0)), ((i32)(0))));
    ((assertBPcrN)((!(((LLVM_isNullS5038rB))((target)))), ("Could not create target machine")));
    return ((newLLVMTargetMachineFromRefS5038rS7964)((target)));
}
LLVMTargetMachine_s createTargetMachineWithOptionsS4231PcS6312rS7964(LLVMTarget_s this, char *triple, LLVMTargetMachineOptions_s options) {
    LLVM_TargetMachineRef_s target = (((LLVMCreateTargetMachineWithOptions))(((this).ref), (triple), ((options).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5038rB))((target)))), ("Could not create target machine")));
    return ((newLLVMTargetMachineFromRefS5038rS7964)((target)));
}
LLVMTarget_s newLLVMTargetFromRefS3497rS4231(LLVM_TargetRef_s ref) { return ((LLVMTarget_s){.ref = (ref)}); }
none writeToFilePS7964S1718i32PcrN(LLVMTargetMachine_s *this, LLVMModule_s mod, i32 mode, char *filepath) {
    LLVMString_s err = ((LLVMString_s){0});
    if ((((LLVMTargetMachineEmitToFile))(((this)->ref), ((mod).ref), (filepath), (mode), (&(err)))) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s Could not write LLVM module to file!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s %s\n"), (FATAL_STR), ((err).chars)));
        (((C_exiti32rN))(((i32)(1))));
    }
}
LLVMTargetData_s getTargetDataPS7964rS8369(LLVMTargetMachine_s *this) {
    LLVM_TargetDataRef_s data = (((LLVMCreateTargetDataLayout))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6307rB))((data)))), ("Could not get TargetData")));
    return ((newLLVMTargetDataFromRefS6307rS8369)((data)));
}
LLVMTargetMachine_s newLLVMTargetMachineFromRefS5038rS7964(LLVM_TargetMachineRef_s ref) { return ((LLVMTargetMachine_s){.ref = (ref)}); }
LLVMTargetMachineOptions_s createTargetMachineOptionsrS6312(none) {
    LLVM_TargetMachineOptionsRef_s opt = (((LLVMCreateTargetMachineOptions))());
    ((assertBPcrN)((!(((LLVM_isNullS3482rB))((opt)))), ("Could not create target machine options")));
    return ((LLVMTargetMachineOptions_s){.ref = (opt)});
}
none disposeTargetMachineOptionsS6312rN(LLVMTargetMachineOptions_s opt) { (((LLVMDisposeTargetMachineOptions))(((opt).ref))); }
none setCPUS6312PcrN(LLVMTargetMachineOptions_s opt, char *cpu) { (((LLVMTargetMachineOptionsSetCPU))(((opt).ref), (cpu))); }
none setFeaturesS6312PcrN(LLVMTargetMachineOptions_s opt, char *features) { (((LLVMTargetMachineOptionsSetFeatures))(((opt).ref), (features))); }
none setABIS6312PcrN(LLVMTargetMachineOptions_s opt, char *ABI) { (((LLVMTargetMachineOptionsSetABI))(((opt).ref), (ABI))); }
none setCodeGenOptLevelS6312U5589rN(LLVMTargetMachineOptions_s opt, LLVM_CodeGenOptLevel_u level) {
    (((LLVMTargetMachineOptionsSetCodeGenOptLevel))(((opt).ref), (((LLVM_asI32Anyri32))((&(level))))));
}
none setRelocModeS6312U2415rN(LLVMTargetMachineOptions_s opt, LLVM_RelocMode_u reloc) { (((LLVMTargetMachineOptionsSetRelocMode))(((opt).ref), (((LLVM_asI32Anyri32))((&(reloc)))))); }
none setCodeModelS6312U0545rN(LLVMTargetMachineOptions_s opt, LLVM_CodeModel_u model) { (((LLVMTargetMachineOptionsSetCodeModel))(((opt).ref), (((LLVM_asI32Anyri32))((&(model)))))); }
none printPS1718rN(LLVMModule_s *this) {
    char *s = (((LLVMPrintModuleToString))(((this)->ref)));
    (((printf))(("%s\n"), (s)));
}
none setTriplePS1718PcrN(LLVMModule_s *this, char *triple) { (((LLVMSetTarget))(((this)->ref), (triple))); }
none setDataLayoutPS1718S7896rN(LLVMModule_s *this, LLVMDataLayout_s layout) { (((LLVMSetDataLayout))(((this)->ref), ((layout).ref))); }
bool writeToFilePS1718S7720rB(LLVMModule_s *this, SubStr_s path) {
    LLVMString_s err = ((LLVMString_s){0});
    String_s _n = ((toStringPS7720rS0540)((&(path))));
    LLVMBool_s code = (((LLVMPrintModuleToFile))(((this)->ref), ((_n).buffer), (&(err))));
    if (((code).val) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s Could not write LLVM Module to file!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s\n"), ((err).chars)));
        ((dropPS0540rN)((&(_n))));
        return (false);
    }

    ((dropPS0540rN)((&(_n))));
    return (true);
}
bool verifyPS1718rB(LLVMModule_s *this) {
    LLVMString_s err = ((LLVMString_s){0});
    LLVMBool_s code = (((LLVMVerifyModule))(((this)->ref), (LLVMReturnStatusAction), (&(err))));
    if (((code).val) != ((i32)(0))) {
        (((fprintf))((stderr_), ("%s LLVM Module verification failed!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s\n"), ((err).chars)));
        return (false);
    }

    return (true);
}
LLVMValue_s addFunctionPS1718S7720S0706rS8925(LLVMModule_s *this, SubStr_s name, LLVMType_s function) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))(((function).ref)))), ("Expected valid LLVMType in LLVMModule.addFunction")));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMAddFunction))(((this)->ref), ((_n).buffer), ((function).ref)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((f)))), ("Could not add function to module")));
    return ((newLLVMValueFromRefS1407rS8925)((f)));
}
bool hasFunctionPS1718S7720rB(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMGetNamedFunction))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    return (!(((LLVM_isNullS1407rB))((f))));
}
LLVMValue_s getFunctionPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s f = (((LLVMGetNamedFunction))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((f)))), ("Could not get function from module")));
    return ((newLLVMValueFromRefS1407rS8925)((f)));
}
LLVMValue_s addGlobalPS1718S0706u32S7720rS8925(LLVMModule_s *this, LLVMType_s typ, u32 space, SubStr_s name) {
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))(((typ).ref)))), ("Expected valid LLVMType in LLVMModule.addGlobal")));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s g = (((LLVMAddGlobalInAddressSpace))(((this)->ref), ((typ).ref), ((_n).buffer), (space)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((g)))), ("Could not add global in module")));
    return ((newLLVMValueFromRefS1407rS8925)((g)));
}
LLVMValue_s getGlobalPS1718S7720rS8925(LLVMModule_s *this, SubStr_s name) {
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s g = (((LLVMGetNamedGlobal))(((this)->ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((g)))), ("Could not get global in module")));
    return ((newLLVMValueFromRefS1407rS8925)((g)));
}
bool runPassesS1718PcS7964S4890rB(LLVMModule_s this, char *passes, LLVMTargetMachine_s target, LLVMPassBuilderOptions_s options) {
    ((assertBrN)((!(((LLVM_isNullS3816rB))(((this).ref))))));
    return (((((LLVMRunPasses))(((this).ref), (passes), ((target).ref), ((options).ref))).ptr) == (NULL));
}
none addModuleFlagS1718i32S7720S8925rN(LLVMModule_s this, i32 behavior, SubStr_s flag, LLVMValue_s value) {
    LLVM_MetadataRef_s meta = (((LLVMValueAsMetadata))(((value).ref)));
    (((LLVMAddModuleFlag))(((this).ref), (behavior), ((flag).start), ((flag).len), (meta)));
}
LLVMModule_s newLLVMModuleFromRefS3816rS1718(LLVM_ModuleRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS3816rB))((ref)))), ("Passed invalid reference to newLLVMModuleFromRef")));
    return ((LLVMModule_s){.ref = (ref)});
}
none guardReferencePS6343rN(LLVMBuilder_s *this) { ((assertBPcrN)((!(((LLVM_isNullS3273rB))(((this)->ref)))), ("LLVM Builder is null"))); }
none positionAtEndPS6343S7469rN(LLVMBuilder_s *this, LLVMBasicBlock_s block) {
    ((guardReferencePS6343rN)((this)));
    (((LLVMPositionBuilderAtEnd))(((this)->ref), ((block).ref)));
}
none positionBeforePS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s instr) {
    ((guardReferencePS6343rN)((this)));
    (((LLVMPositionBuilderBefore))(((this)->ref), ((instr).ref)));
}
LLVMBasicBlock_s getInsertBlockPS6343rS7469(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_BasicBlockRef_s block = (((LLVMGetInsertBlock))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not get insert block from builder")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMValue_s buildInsertValuePS6343S8925S8925u32PcrS8925(LLVMBuilder_s *this, LLVMValue_s aggregate, LLVMValue_s element, u32 offset, char *name) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s val = (((LLVMBuildInsertValue))(((this)->ref), ((aggregate).ref), ((element).ref), (offset), (name)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((val)))), ("Could not build insert value in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((val)));
}
LLVMValue_s buildAllocaPS6343S0706S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s alloced = (((LLVMBuildAlloca))(((this)->ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((alloced)))), ("Could not build alloca in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((alloced)));
}
LLVMValue_s buildStorePS6343S8925S8925rS8925(LLVMBuilder_s *this, LLVMValue_s ptr, LLVMValue_s value) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s store = (((LLVMBuildStore))(((this)->ref), ((value).ref), ((ptr).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((store)))), ("Could not build store in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((store)));
}
LLVMValue_s buildLoadPS6343S0706S8925S7720rS8925(LLVMBuilder_s *this, LLVMType_s pType, LLVMValue_s ptr, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildLoad2))(((this)->ref), ((pType).ref), ((ptr).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build load in builder")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
none buildReturnPS6343S8925rN(LLVMBuilder_s *this, LLVMValue_s value) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s ret = (((LLVMBuildRet))(((this)->ref), ((value).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((ret)))), ("Could not build return in builder")));
}
none buildReturnVoidPS6343rN(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s value = (((LLVMBuildRetVoid))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build return void in builder")));
}
LLVMValue_s buildBrPS6343S7469rS8925(LLVMBuilder_s *this, LLVMBasicBlock_s dest) {
    ((guardReferencePS6343rN)((this)));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))(((dest).ref)))), ("Destination for Br is null!")));
    LLVM_ValueRef_s value = (((LLVMBuildBr))(((this)->ref), ((dest).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build Br")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildCondBrPS6343S8925S7469S7469rS8925(LLVMBuilder_s *this, LLVMValue_s cond, LLVMBasicBlock_s tru, LLVMBasicBlock_s fals) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s value = (((LLVMBuildCondBr))(((this)->ref), ((cond).ref), ((tru).ref), ((fals).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build CondBr")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntAddPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildAdd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int add")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntSubPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildSub))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int sub")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntMulPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildMul))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int mul")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntDivPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildUDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int div")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntModPS6343S8925S8925BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSRem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildURem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int mod")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatAddPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFAdd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float add")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatSubPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFSub))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float sub")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatMulPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFMul))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float mul")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatDivPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFDiv))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float div")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatModPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFRem))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float mod")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildICmp))(((this)->ref), (predicate), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int compare")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatComparePS6343i32S8925S8925S7720rS8925(LLVMBuilder_s *this, i32 predicate, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFCmp))(((this)->ref), (predicate), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float compare")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildNotPS6343S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildNot))(((this)->ref), ((val).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical not")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildOrPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildOr))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical or")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildAndPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildAnd))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical and")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildXorPS6343S8925S8925S7720rS8925(LLVMBuilder_s *this, LLVMValue_s lhs, LLVMValue_s rhs, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildXor))(((this)->ref), ((lhs).ref), ((rhs).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build logical xor")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildPtrToIntPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildPtrToInt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build ptr to int")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntToPtrPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildIntToPtr))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int to ptr")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntToFloatPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildSIToFP))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildUIToFP))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int to float")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatToIntPS6343S8925S0706BS7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, bool signed_, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = ((LLVM_ValueRef_s){0});
    if (signed_) {
        ((value) = (((LLVMBuildFPToSI))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    else {
        ((value) = (((LLVMBuildFPToUI))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer))));
    }

    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float to int")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntSignExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildSExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int sign extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntZeroExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildZExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int zero extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatExtendPS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFPExt))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float extend")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildFloatTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildFPTrunc))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build float truncate")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildIntTruncatePS6343S8925S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s val, LLVMType_s typ, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s value = (((LLVMBuildTrunc))(((this)->ref), ((val).ref), ((typ).ref), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build int truncate")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildCallPS6343S8925S0706S8201S0706S7720rS8925(LLVMBuilder_s *this, LLVMValue_s fn, LLVMType_s fnType, LLVMValueList_s args, LLVMType_s retType, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    ((assertBrN)(((sizeof(LLVMValue_s)) == ((usize)(8llu)))));
    String_s _n = ((String_s){0});
    if ((isVoidPS0706rB)((&(retType)))) {
        ((_n) = ((newStringFromStrLitPcrS0540)((""))));
    }

    else {
        ((_n) = ((toStringPS7720rS0540)((&(name)))));
    }

    LLVM_ValueRef_s value = (((LLVMBuildCall2))(((this)->ref), ((fnType).ref), ((fn).ref), ((LLVM_ValueRef_s *)(((args).elements))), ((u32)(((args).length))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((clearPS8201rN)((&(args))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((value)))), ("Could not build call")));
    return ((newLLVMValueFromRefS1407rS8925)((value)));
}
LLVMValue_s buildGlobalStringPtrPS6343PcS7720rS8925(LLVMBuilder_s *this, char *start, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s s = (((LLVMBuildGlobalStringPtr))(((this)->ref), (start), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build global string")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
LLVMValue_s buildStructGEPPS6343S0706S8925uszS7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, usize index, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    LLVM_ValueRef_s s = (((LLVMBuildStructGEP2))(((this)->ref), ((typ).ref), ((aggr).ref), ((u32)((index))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build struct GEP")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
LLVMValue_s buildGEPPS6343S0706S8925S8201S7720rS8925(LLVMBuilder_s *this, LLVMType_s typ, LLVMValue_s aggr, LLVMValueList_s indices, SubStr_s name) {
    ((guardReferencePS6343rN)((this)));
    String_s _n = ((toStringPS7720rS0540)((&(name))));
    ((assertBrN)(((sizeof(LLVMValue_s)) == ((usize)(8llu)))));
    LLVM_ValueRef_s s = (((LLVMBuildGEP2))(((this)->ref), ((typ).ref), ((aggr).ref), ((LLVM_ValueRef_s *)(((indices).elements))), ((u32)(((indices).length))), ((_n).buffer)));
    ((dropPS0540rN)((&(_n))));
    ((clearPS8201rN)((&(indices))));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((s)))), ("Could not build GEP")));
    return ((newLLVMValueFromRefS1407rS8925)((s)));
}
none buildUnreachablePS6343rN(LLVMBuilder_s *this) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s v = (((LLVMBuildUnreachable))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((v)))), ("Could not build unreachable")));
}
LLVMValue_s buildMemcpyPS6343S8925u32S8925u32S8925rS8925(LLVMBuilder_s *this, LLVMValue_s dst, u32 dstAlign, LLVMValue_s src, u32 srcAlign, LLVMValue_s size) {
    ((guardReferencePS6343rN)((this)));
    LLVM_ValueRef_s v = (((LLVMBuildMemCpy))(((this)->ref), ((dst).ref), (dstAlign), ((src).ref), (srcAlign), ((size).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1407rB))((v)))), ("Could not build memcpy")));
    return ((newLLVMValueFromRefS1407rS8925)((v)));
}
LLVMBuilder_s newLLVMBuilderFromRefS3273rS6343(LLVM_BuilderRef_s ref) {
    ((assertBPcrN)((!(((LLVM_isNullS3273rB))((ref)))), ("Passed invalid reference to newLLVMBuilderFromRef")));
    return ((LLVMBuilder_s){.ref = (ref)});
}
none dropPS0773rN(LLVMContext_s *this) { (((LLVMContextDispose))(((this)->ref))); }
none guardReferencePS0773rN(LLVMContext_s *this) { ((assertBPcrN)((!(((LLVM_isNullS4183rB))(((this)->ref)))), ("LLVM Context is null"))); }
none initializeTargetsPS0773rN(LLVMContext_s *this) {
    ((assertBPcrN)(((((LLVM_InitializeNativeAsmParser))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeAsmPrinter))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeDisassembler))()) == ((i32)(0))), ("Could not initialize Targets")));
    ((assertBPcrN)(((((LLVM_InitializeNativeTarget))()) == ((i32)(0))), ("Could not initialize Targets")));
}
LLVMTarget_s createTargetPS0773PcrS4231(LLVMContext_s *this, char *name) {
    LLVM_TargetRef_s target = (((LLVMGetTargetFromName))((name)));
    ((assertBPcrN)((!(((LLVM_isNullS3497rB))((target)))), ("Could not create target triple")));
    return ((newLLVMTargetFromRefS3497rS4231)((target)));
}
char *createTargetTriplePS0773PcrPc(LLVMContext_s *this, char *name) {
    String_s tmp_19723 = ((newStringFromStrLitPcrS0540)(("WINDOWS")));
    String_s tmp_19733 = ((newStringFromStrLitPcrS0540)(("LINUX")));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_19723))) {
        return ("x86_64-pc-windows-msvc");
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_19733))) {
        return ("x86_64-unknown-linux-gnu");
    }

    else {
        ((unreachablePcrN)(("createTargetTriple: Unknown target!")));
    }
}
LLVMModule_s createModuleWithNamePS0773S7720rS1718(LLVMContext_s *this, SubStr_s name) {
    ((guardReferencePS0773rN)((this)));
    String_s _name = ((toStringPS7720rS0540)((&(name))));
    LLVM_ModuleRef_s mod = (((LLVMModuleCreateWithNameInContext))(((_name).buffer), ((this)->ref)));
    ((dropPS0540rN)((&(_name))));
    ((assertBPcrN)((!(((LLVM_isNullS3816rB))((mod)))), ("Could not create module in context")));
    return ((newLLVMModuleFromRefS3816rS1718)((mod)));
}
LLVMBuilder_s createBuilderPS0773rS6343(LLVMContext_s *this) {
    ((guardReferencePS0773rN)((this)));
    LLVM_BuilderRef_s builder = (((LLVMCreateBuilderInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS3273rB))((builder)))), ("Could not create builder in context")));
    return ((newLLVMBuilderFromRefS3273rS6343)((builder)));
}
LLVMType_s createIntegerTypePS0773i64rS0706(LLVMContext_s *this, i64 bitsize) {
    ((assertBPcrN)(((bitsize) > ((i64)(0ll))), ("Got invalid bitsize in createIntegerType")));
    ((assertBPcrN)(((bitsize) <= ((i64)(8388607ll))), ("Got invalid bitsize in createIntegerType")));
    LLVM_TypeRef_s int_ = (((LLVMIntTypeInContext))(((this)->ref), ((u32)((bitsize)))));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((int_)))), ("Could not create integer type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((int_)));
}
LLVMType_s createFloatTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s float_ = (((LLVMFloatTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((float_)))), ("Could not create float type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((float_)));
}
LLVMType_s createDoubleTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s double_ = (((LLVMDoubleTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((double_)))), ("Could not create double type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((double_)));
}
LLVMType_s createStructTypePS0773PS0706u32BrS0706(LLVMContext_s *this, LLVMType_s *elements, u32 count, bool packed) {
    LLVMBool_s b = ((newLLVMBoolBrS2924)((packed)));
    LLVM_TypeRef_s strukt = (((LLVMStructTypeInContext))(((this)->ref), ((LLVM_TypeRef_s *)((elements))), (count), (b)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((strukt)))), ("Could not create struct type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((strukt)));
}
LLVMType_s createVoidTypePS0773rS0706(LLVMContext_s *this) {
    LLVM_TypeRef_s void_ = (((LLVMVoidTypeInContext))(((this)->ref)));
    ((assertBPcrN)((!(((LLVM_isNullS6708rB))((void_)))), ("Could not create void type in context")));
    return ((newLLVMTypeFromRefS6708rS0706)((void_)));
}
LLVMBasicBlock_s appendBasicBlockPS0773S8925S7720rS7469(LLVMContext_s *this, LLVMValue_s fn, SubStr_s name) {
    String_s _name = ((toStringPS7720rS0540)((&(name))));
    LLVM_BasicBlockRef_s block = (((LLVMAppendBasicBlockInContext))(((this)->ref), ((fn).ref), ((_name).buffer)));
    ((dropPS0540rN)((&(_name))));
    ((assertBPcrN)((!(((LLVM_isNullS6239rB))((block)))), ("Could not append basic block in context")));
    return ((newLLVMBasicBlockFromRefS6239rS7469)((block)));
}
LLVMAttribute_s createEnumAttributePS0773u32u64rS6660(LLVMContext_s *this, u32 id, u64 val) {
    LLVM_AttributeRef_s attr = (((LLVMCreateEnumAttribute))(((this)->ref), (id), (val)));
    ((assertBPcrN)((!(((LLVM_isNullS8710rB))((attr)))), ("Could not create enum attribute in context")));
    return ((newLLVMAttributeFromRefS8710rS6660)((attr)));
}
LLVMContext_s newLLVMContextrS0773(none) {
    LLVM_ContextRef_s ref = (((LLVMContextCreate))());
    ((assertBPcrN)((!(((LLVM_isNullS4183rB))((ref)))), ("Could not create LLVM Context")));
    return ((LLVMContext_s){.ref = (ref)});
}
LLVMDIBuilder_s createDIBuilderS1718rS1476(LLVMModule_s mod) {
    LLVM_DIBuilderRef_s di = (((LLVMCreateDIBuilder))(((mod).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS1302rB))((di)))), ("Could not create DIBuilder")));
    return ((LLVMDIBuilder_s){.ref = (di)});
}
none disposeDIBuilderS1476rN(LLVMDIBuilder_s builder) { (((LLVMDisposeDIBuilder))(((builder).ref))); }
none finalizeDIBuilderS1476rN(LLVMDIBuilder_s builder) { (((LLVMDIBuilderFinalize))(((builder).ref))); }
LLVMMetadata_s createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777(LLVMDIBuilder_s builder, i32 lang, LLVMMetadata_s file, SubStr_s producer, LLVMBool_s isOptimized,
                                                                                                     SubStr_s flags, u32 runtimeVer, SubStr_s splitName, i32 kind, u32 dwoid,
                                                                                                     LLVMBool_s splitDebugInlining, LLVMBool_s debugInfoForProfiling, SubStr_s sysRoot, SubStr_s sdk) {
    LLVM_MetadataRef_s unit = (((LLVMDIBuilderCreateCompileUnit))(((builder).ref), (lang), ((file).ref), ((producer).start), ((producer).len), (isOptimized), ((flags).start), ((flags).len),
                                                                  (runtimeVer), ((splitName).start), ((splitName).len), (kind), (dwoid), (splitDebugInlining), (debugInfoForProfiling),
                                                                  ((sysRoot).start), ((sysRoot).len), ((sdk).start), ((sdk).len)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((unit)))), ("Could not create debug compile unit")));
    return ((LLVMMetadata_s){.ref = (unit)});
}
LLVMMetadata_s createFileS1476PcuszPcuszrS5777(LLVMDIBuilder_s builder, char *filename, usize fileLen, char *dir, usize dirLen) {
    LLVM_MetadataRef_s file = (((LLVMDIBuilderCreateFile))(((builder).ref), (filename), (fileLen), (dir), (dirLen)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((file)))), ("Could not create debug file")));
    return ((LLVMMetadata_s){.ref = (file)});
}
LLVMMetadata_s createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, SubStr_s linkage, LLVMMetadata_s file, u32 line,
                                                                                          LLVMMetadata_s type, LLVMBool_s localToUnit, LLVMBool_s isDefinition, u32 scopeLine, i32 flags,
                                                                                          LLVMBool_s isOptimized) {
    LLVM_MetadataRef_s fn = (((LLVMDIBuilderCreateFunction))(((builder).ref), ((scope).ref), ((name).start), ((name).len), ((linkage).start), ((linkage).len), ((file).ref), (line), ((type).ref),
                                                             (localToUnit), (isDefinition), (scopeLine), (flags), (isOptimized)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((fn)))), ("Could not create debug function")));
    return ((LLVMMetadata_s){.ref = (fn)});
}
LLVMMetadata_s createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, u32 arg, LLVMMetadata_s file, u32 line,
                                                                                    LLVMMetadata_s ty, LLVMBool_s alwaysPreserve, i32 flags) {
    LLVM_MetadataRef_s p = (((LLVMDIBuilderCreateParameterVariable))(((builder).ref), ((scope).ref), ((name).start), ((name).len), (arg), ((file).ref), (line), ((ty).ref), (alwaysPreserve), (flags)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((p)))), ("Could not create debug parameter")));
    return ((LLVMMetadata_s){.ref = (p)});
}
LLVMMetadata_s createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s scope, SubStr_s name, LLVMMetadata_s file, u32 line, LLVMMetadata_s ty,
                                                                               LLVMBool_s alwaysPreserve, i32 flags, u32 align) {
    LLVM_MetadataRef_s v = (((LLVMDIBuilderCreateAutoVariable))(((builder).ref), ((scope).ref), ((name).start), ((name).len), ((file).ref), (line), ((ty).ref), (alwaysPreserve), (flags), (align)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((v)))), ("Could not create debug variable")));
    return ((LLVMMetadata_s){.ref = (v)});
}
u32 getEncodingU7375ru32(PrimType_u p) {
    bool succ_2590_ = true;
    bool succ_2592_ = true;
    bool succ_2594_ = true;
    bool succ_2596_ = true;
    bool succ_2598_ = true;
    bool succ_2600_ = true;
    bool succ_2602_ = true;
    bool succ_2604_ = true;
    bool succ_2606_ = true;
    bool succ_2608_ = true;
    bool succ_2610_ = true;
    bool succ_2612_ = true;
    bool succ_2614_ = true;
    bool succ_2616_ = true;
    bool succ_2618_ = true;

    PrimType_u tmp_4151_ = (p);
    {
        succ_2590_ &= (tmp_4151_.tag == 0);
        if (succ_2590_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4151;
        }
    }
    {
        succ_2592_ &= (tmp_4151_.tag == 1);
        if (succ_2592_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4151;
        }
    }
    {
        succ_2594_ &= (tmp_4151_.tag == 2);
        if (succ_2594_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4151;
        }
    }
    {
        succ_2596_ &= (tmp_4151_.tag == 3);
        if (succ_2596_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4151;
        }
    }
    {
        succ_2598_ &= (tmp_4151_.tag == 4);
        if (succ_2598_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4151;
        }
    }
    {
        succ_2600_ &= (tmp_4151_.tag == 5);
        if (succ_2600_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4151;
        }
    }
    {
        succ_2602_ &= (tmp_4151_.tag == 6);
        if (succ_2602_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4151;
        }
    }
    {
        succ_2604_ &= (tmp_4151_.tag == 7);
        if (succ_2604_) {
            {
                return (DW_ATE_signed);
            }
            goto after_4151;
        }
    }
    {
        succ_2606_ &= (tmp_4151_.tag == 8);
        if (succ_2606_) {
            {
                return (DW_ATE_unsigned);
            }
            goto after_4151;
        }
    }
    {
        succ_2608_ &= (tmp_4151_.tag == 9);
        if (succ_2608_) {
            {
                return (DW_ATE_address);
            }
            goto after_4151;
        }
    }
    {
        succ_2610_ &= (tmp_4151_.tag == 10);
        if (succ_2610_) {
            {
                return (DW_ATE_boolean);
            }
            goto after_4151;
        }
    }
    {
        succ_2612_ &= (tmp_4151_.tag == 11);
        if (succ_2612_) {
            {
                ((unreachablePcrN)(("getEncoding(None)")));
            }
            goto after_4151;
        }
    }
    {
        succ_2614_ &= (tmp_4151_.tag == 12);
        if (succ_2614_) {
            {
                return (DW_ATE_unsigned_char);
            }
            goto after_4151;
        }
    }
    {
        succ_2616_ &= (tmp_4151_.tag == 13);
        if (succ_2616_) {
            {
                return (DW_ATE_float);
            }
            goto after_4151;
        }
    }
    {
        succ_2618_ &= (tmp_4151_.tag == 14);
        if (succ_2618_) {
            {
                return (DW_ATE_float);
            }
            goto after_4151;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4151;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4151:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of primitive types in getEncoding")));
}
SubStr_s getFullNameU7375rS7720(PrimType_u p) {
    bool succ_2621_ = true;
    bool succ_2623_ = true;
    bool succ_2625_ = true;
    bool succ_2627_ = true;
    bool succ_2629_ = true;
    bool succ_2631_ = true;
    bool succ_2633_ = true;
    bool succ_2635_ = true;
    bool succ_2637_ = true;
    bool succ_2639_ = true;
    bool succ_2641_ = true;
    bool succ_2643_ = true;
    bool succ_2645_ = true;
    bool succ_2647_ = true;
    bool succ_2649_ = true;

    PrimType_u tmp_4184_ = (p);
    {
        succ_2621_ &= (tmp_4184_.tag == 0);
        if (succ_2621_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u8"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2623_ &= (tmp_4184_.tag == 1);
        if (succ_2623_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u16"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2625_ &= (tmp_4184_.tag == 2);
        if (succ_2625_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u32"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2627_ &= (tmp_4184_.tag == 3);
        if (succ_2627_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("u64"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2629_ &= (tmp_4184_.tag == 4);
        if (succ_2629_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i8"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2631_ &= (tmp_4184_.tag == 5);
        if (succ_2631_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i16"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2633_ &= (tmp_4184_.tag == 6);
        if (succ_2633_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i32"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2635_ &= (tmp_4184_.tag == 7);
        if (succ_2635_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("i64"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2637_ &= (tmp_4184_.tag == 8);
        if (succ_2637_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("usize"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2639_ &= (tmp_4184_.tag == 9);
        if (succ_2639_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("Any"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2641_ &= (tmp_4184_.tag == 10);
        if (succ_2641_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("bool"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2643_ &= (tmp_4184_.tag == 11);
        if (succ_2643_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("none"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2645_ &= (tmp_4184_.tag == 12);
        if (succ_2645_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("char"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2647_ &= (tmp_4184_.tag == 13);
        if (succ_2647_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("f32"))));
            }
            goto after_4184;
        }
    }
    {
        succ_2649_ &= (tmp_4184_.tag == 14);
        if (succ_2649_) {
            {
                return (((newSubStrOfStrLitPcrS7720)(("f64"))));
            }
            goto after_4184;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4184;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4184:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of primitive types in getFullName")));
}
LLVMMetadata_s createSubroutineTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    bool succ_2655_ = true;

    Type_u *tmp_4199_ = (type);
    {
        succ_2655_ &= (tmp_4199_->tag == 6);
        TypeList_s *args = &tmp_4199_->payload.variant6._0;
        succ_2655_ &= true;
        Type_u **ret = &tmp_4199_->payload.variant6._1;
        succ_2655_ &= true;
        succ_2655_ &= true;
        if (succ_2655_) {
            {
                LLVM_MetadataRef_s *types = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*args).length) + ((usize)(1llu))))));
                ((assertBrN)(((types) != (NULL))));
                ((((types))[((usize)(0llu))]) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*ret))).ref));
                for (usize i = ((usize)(0llu)); ((i) < ((*args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((((types))[((i) + ((usize)(1llu)))]) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((((*args).elements))[(i)]))).ref));
                }

                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateSubroutineType))(((builder).ref), ((diFile).ref), (types), ((u32)((((*args).length) + ((usize)(1llu))))), (LLVMDIFlagZero)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for function type")));
                (((free))((types)));
                return ((LLVMMetadata_s){.ref = (meta)});
            }
            goto after_4199;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4199;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4199:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("createSubroutineType: Expected function type")));
}
LLVMMetadata_s createDebugInfoForPrimitiveTypeS1476PU5175rS5777(LLVMDIBuilder_s builder, Type_u *type) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2667_ = true;
    bool succ_2665_ = true;
    bool succ_2678_ = true;
    bool succ_2676_ = true;
    bool succ_2684_ = true;

    Type_u *tmp_4224_ = (type);
    {
        succ_2667_ &= (tmp_4224_->tag == 3);
        succ_2665_ &= (tmp_4224_->payload.variant3._0.tag == 9);
        succ_2667_ &= succ_2665_;
        if (succ_2667_) {
            {
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName = ((newSubStrOfStrLitPcrS7720)(("any")));
                LLVM_MetadataRef_s meta =
                    (((LLVMDIBuilderCreatePointerType))(((builder).ref), ((LLVM_MetadataRef_s){0}), ((u64)((size))), ((u32)((align))), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for Any type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4224;
        }
    }
    {
        succ_2678_ &= (tmp_4224_->tag == 3);
        succ_2676_ &= (tmp_4224_->payload.variant3._0.tag == 11);
        succ_2678_ &= succ_2676_;
        if (succ_2678_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for primitive type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4224;
        }
    }
    {
        succ_2684_ &= (tmp_4224_->tag == 3);
        PrimType_u *prim = &tmp_4224_->payload.variant3._0;
        succ_2684_ &= true;
        if (succ_2684_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((*prim)));
                usize size = ((getSizeInBitsPU5175rusz)((type)));
                u32 encoding = ((getEncodingU7375ru32)((*prim)));
                i32 flags = (LLVMDIFlagZero);
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateBasicType))(((builder).ref), ((fullName).start), ((fullName).len), ((u64)((size))), (encoding), (flags)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for primitive type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4224;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForPrimitiveType: Expected primitive type")));
            }
            goto after_4224;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4224:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createDebugInfoForStructTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2695_ = true;

    Type_u *tmp_4265_ = (type);
    {
        succ_2695_ &= (tmp_4265_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_4265_->payload.variant7._0;
        succ_2695_ &= true;
        if (succ_2695_) {
            {
                ParsedFile_s *file = ((getParentFilePS5521rPS1892)((*decl)));
                usize line = ((usize)(0llu));
                usize col = ((usize)(0llu));
                ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(line)), (&(col))));
                String_s unique = ((getFullNamePS5521rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                i32 _flags = (LLVMDIFlagPublic);
                LLVM_MetadataRef_s *elements = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*decl)->context).fieldLength))));
                ((assertBrN)(((elements) != (NULL))));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (i)));
                    TCState_u fts = (((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)))->typeState);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&(fts))));
                    LLVM_MetadataRef_s fieldDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (fieldType))).ref);
                    usize fieldLine = ((usize)(0llu));
                    usize fieldColumn = ((usize)(0llu));
                    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(fieldLine)), (&(fieldColumn))));
                    usize fieldOffset = ((usize)(0llu));
                    usize fieldSize = ((usize)(0llu));
                    usize fieldAlign = ((getAlignmentInBitsPU5175rusz)((fieldType)));
                    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (i), (&(fieldOffset)), (&(fieldSize)), (true)));
                    ((((elements))[(i)]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), (((name).content).start), (((name).content).len), ((diDecl).ref), ((u32)((fieldLine))),
                                                                              ((u64)((fieldSize))), ((u32)((fieldAlign))), ((u64)((fieldOffset))), (LLVMDIFlagZero), (fieldDebugType))));
                }

                char *start = ((((*decl)->name).content).start);
                usize len = ((((*decl)->name).content).len);
                usize size = ((getSizeInBitsPU5175rusz)(((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                usize align = ((getAlignmentInBitsPU5175rusz)(((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), (start), (len), ((diDecl).ref), ((u32)((line))), ((u64)((size))), ((u32)((align))),
                                                                             (_flags), ((LLVM_MetadataRef_s){0}), (elements), ((u32)((((*decl)->context).fieldLength))), ((u32)(0)),
                                                                             ((LLVM_MetadataRef_s){0}), ((unique).buffer), ((unique).length)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for struct type")));
                (((free))((elements)));
                ((dropPS0540rN)((&(unique))));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
                (((LLVMMetadataReplaceAllUsesWith))(((((*decl)->debugInfo).diType).ref), (meta)));
                ((((*decl)->debugInfo).diType) = (data));
            }
            goto after_4265;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForStructType: Expected struct type")));
            }
            goto after_4265;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4265:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, LLVMContext_s llvmContext) {
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2733_ = true;

    Type_u *tmp_4332_ = (type);
    {
        succ_2733_ &= (tmp_4332_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4332_->payload.variant8._0;
        succ_2733_ &= true;
        succ_2733_ &= true;
        if (succ_2733_) {
            {
                ParsedFile_s *file = ((getParentFilePS0997rPS1892)((*decl)));
                String_s unique = ((getFullNamePS0997rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                usize line = ((usize)(0llu));
                usize col = ((usize)(0llu));
                ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((*decl)->span)), (&(line)), (&(col))));
                i32 flags = (LLVMDIFlagZero);
                u64 tagSize = ((u64)(8llu));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((tagSize) = ((tagSize) * ((u64)(2llu))));
                LLVMMetadata_s tag = ((createTagTypeS1476S5777PU5175uszrS5777)((builder), (diFile), (type), (line)));
                LLVM_MetadataRef_s *elems = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * (((*decl)->variants).length))));
                ((assertBrN)(((elems) != (NULL))));
                u64 maxSize = ((u64)(0llu));
                u32 maxAlign = ((u32)(8));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((maxAlign) = ((maxAlign) * ((u32)(2))));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (i))));
                    SubStr_s name = (((variant)->name).content);
                    Type_u *variantType = ((toTypePS3506rPU5175)((variant)));
                    u64 variantSize = ((u64)(((getSizeInBitsPU5175rusz)((variantType)))));
                    u32 variantAlign = ((u32)(((getAlignmentInBitsPU5175rusz)((variantType)))));
                    if ((variantSize) > (maxSize))
                        ((maxSize) = (variantSize));
                    if ((variantAlign) > (maxAlign))
                        ((maxAlign) = (variantAlign));
                    LLVM_MetadataRef_s variantDebugType = (((createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777)((builder), (diFile), (*decl), (variant), (line), (flags))).ref);
                    LLVM_MetadataRef_s variantMember = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((name).start), ((name).len), ((diFile).ref), ((u32)((line))), (variantSize),
                                                                                          (variantAlign), ((u64)(0llu)), (flags), (variantDebugType)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((variantMember)))), ("Could not create debug info for union variant")));
                    ((((elems))[(i)]) = (variantMember));
                }

                u64 size = ((u64)(((getSizeInBitsPU5175rusz)((type)))));
                u32 align = ((u32)(((getAlignmentInBitsPU5175rusz)((type)))));
                ((assertBPcrN)(((maxAlign) == (align)), ("Alignment mismatch")));
                ((assertBPcrN)(((maxSize) <= (size)), ("Size mismatch")));
                u64 payloadOffset = (tagSize);
                LLVM_MetadataRef_s meta = ((LLVM_MetadataRef_s){0});
                if ((((*decl)->variants).length) > ((usize)(0llu))) {
                    String_s _payloadStr = ((copyPS0540rS0540)((&(unique))));
                    ((pushStrPS0540PcrN)((&(_payloadStr)), ("._payload")));
                    String_s payloadStr = ((copyPS0540rS0540)((&(unique))));
                    ((pushStrPS0540PcrN)((&(payloadStr)), (".payload")));
                    LLVM_MetadataRef_s _payload =
                        (((LLVMDIBuilderCreateUnionType))(((builder).ref), ((diDecl).ref), ((_payloadStr).buffer), ((_payloadStr).length), ((diFile).ref), ((u32)((line))), (maxSize), (maxAlign),
                                                          (flags), (elems), ((u32)((((*decl)->variants).length))), ((u32)(0)), ((_payloadStr).buffer), ((_payloadStr).length)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((_payload)))), ("Could not create debug info for payload")));
                    LLVM_MetadataRef_s payload = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((payloadStr).buffer), ((payloadStr).length), ((diFile).ref), ((u32)((line))),
                                                                                    (maxSize), (maxAlign), (payloadOffset), (flags), (_payload)));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((payload)))), ("Could not create debug info for payload")));
                    array_32164 comb = ((array_32164){((tag).ref), (payload)});
                    ((meta) = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), ((unique).buffer), ((unique).length), ((diFile).ref), ((u32)((line))), (size), (align), (flags),
                                                                 ((LLVM_MetadataRef_s){0}), (&(((comb).arr)[((usize)(0llu))])), ((u32)(2)), ((u32)(0)), ((LLVM_MetadataRef_s){0}), ((unique).buffer),
                                                                 ((unique).length))));
                    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for union")));
                    ((dropPS0540rN)((&(payloadStr))));
                    ((dropPS0540rN)((&(_payloadStr))));
                }

                else {
                    ((meta) = ((tag).ref));
                }

                ((dropPS0540rN)((&(unique))));
                (((free))((elems)));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
                (((LLVMMetadataReplaceAllUsesWith))(((((*decl)->debugInfo).diType).ref), (meta)));
                ((((*decl)->debugInfo).diType) = (data));
            }
            goto after_4332;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createDebugInfoForUnionType: Expected union type")));
            }
            goto after_4332;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4332:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (data);
}
LLVMMetadata_s createTagTypeS1476S5777PU5175uszrS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type, usize line) {
    bool succ_2775_ = true;

    Type_u *tmp_4351_ = (type);
    {
        succ_2775_ &= (tmp_4351_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4351_->payload.variant8._0;
        succ_2775_ &= true;
        succ_2775_ &= true;
        if (succ_2775_) {
            {
                ParsedFile_s *file = ((getParentFilePS0997rPS1892)((*decl)));
                String_s unique = ((getFullNamePS0997rS0540)((*decl)));
                LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
                LLVMMetadata_s _tag =
                    ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))));
                u64 tagSize = ((u64)(8llu));
                u32 tagAlign = ((u32)(8));
                if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                    ((_tag) = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))))));
                    ((tagSize) = ((u64)(16llu)));
                    ((tagAlign) = ((u32)(16)));
                }

                LLVM_MetadataRef_s tag = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ("tag"), ((usize)(3llu)), ((diDecl).ref), ((u32)((line))), (tagSize), (tagAlign),
                                                                            ((u64)(0llu)), (LLVMDIFlagZero), ((_tag).ref)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((tag)))), ("Could not create debug info for union tag")));
                return ((LLVMMetadata_s){.ref = (tag)});
            }
            goto after_4351;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("createTagType: Expected union type")));
            }
            goto after_4351;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4351:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("createTagType")));
}
LLVMMetadata_s createUnionVariantTypeS1476S5777PS0997PS3506uszi32rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, usize line, i32 flags) {
    ParsedFile_s *file = ((getParentFilePS0997rPS1892)((decl)));
    LLVMMetadata_s diDecl = (((file)->debugInfo).diFile);
    String_s pl = ((getFullNamePS0997rS0540)((decl)));
    ((pushCharPS0540crN)((&(pl)), ('.')));
    {
        String_s _v = ((toStringPS7720rS0540)((&(((variant)->name).content))));
        ((pushStringPS0540PS0540rN)((&(pl)), (&(_v))));
        ((dropPS0540rN)((&(_v))));
    }

    LLVM_MetadataRef_s meta = ((LLVM_MetadataRef_s){0});
    bool succ_2796_ = true;
    bool succ_2794_ = true;

    tuple_1044 tmp_4363_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
    succ_2794_ = tmp_4363_._0 == true;
    succ_2796_ &= succ_2794_;
    ParsedTypeNodeList_s **fields = &tmp_4363_._1;
    succ_2796_ &= true;
    if (!succ_2796_) {
        ((unreachablePcrN)(("createUnionVariantType")));
    };
    if (((*fields)->length) > ((usize)(0llu))) {
        LLVM_MetadataRef_s *inner = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * ((*fields)->length))));
        ((assertBrN)(((inner) != (NULL))));
        for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
            String_s name = ((String_s){0});
            ((pushNumberPS0540uszrN)((&(name)), (i)));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
            LLVM_MetadataRef_s fieldDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (fieldType))).ref);
            usize fieldLine = ((usize)(0llu));
            usize fieldColumn = ((usize)(0llu));
            ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((fieldNode)->span)), (&(fieldLine)), (&(fieldColumn))));
            usize fieldOffset = ((usize)(0llu));
            usize fieldSize = ((usize)(0llu));
            usize fieldAlign = ((getAlignmentInBitsPU5175rusz)((fieldType)));
            ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (i), (&(fieldOffset)), (&(fieldSize)), (true)));
            ((((inner))[(i)]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diDecl).ref), ((name).buffer), ((name).length), ((diFile).ref), ((u32)((fieldLine))), ((u64)((fieldSize))),
                                                                   ((u32)((fieldAlign))), ((u64)((fieldOffset))), (flags), (fieldDebugType))));
        }

        Type_u *variantType = ((toTypePS3506rPU5175)((variant)));
        u64 size = ((u64)(((getSizeInBitsPU5175rusz)((variantType)))));
        u32 align = ((u32)(((getAlignmentInBitsPU5175rusz)((variantType)))));
        ((meta) = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diDecl).ref), ((pl).buffer), ((pl).length), ((diFile).ref), ((u32)((line))), (size), (align), (flags),
                                                     ((LLVM_MetadataRef_s){0}), (inner), ((u32)(((*fields)->length))), ((u32)(0)), ((LLVM_MetadataRef_s){0}), ((pl).buffer), ((pl).length))));
        (((free))((inner)));
    }

    else {
        ((meta) = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))))).ref));
    }

    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for union variant")));
    ((dropPS0540rN)((&(pl))));
    return ((LLVMMetadata_s){.ref = (meta)});
}
LLVMMetadata_s createTypeS1476S5777PU5175rS5777(LLVMDIBuilder_s builder, LLVMMetadata_s diFile, Type_u *type) {
    LLVMMetadata_s *dt = ((atPS7368uszrPS5777)((&(debugTypes)), ((getIDPU5175rusz)((type)))));
    if (!(((LLVM_isNullS9683rB))(((dt)->ref))))
        return (*(dt));
    LLVMMetadata_s data = ((LLVMMetadata_s){0});
    bool succ_2823_ = true;
    bool succ_2826_ = true;
    bool succ_2832_ = true;
    bool succ_2848_ = true;
    bool succ_2860_ = true;
    bool succ_2868_ = true;
    bool succ_2880_ = true;
    bool succ_2885_ = true;
    bool succ_2889_ = true;

    Type_u *tmp_4456_ = (type);
    {
        succ_2823_ &= (tmp_4456_->tag == 3);
        PrimType_u *p = &tmp_4456_->payload.variant3._0;
        succ_2823_ &= true;
        if (succ_2823_) {
            {
                return (*((atPS7368uszrPS5777)((&(debugTypes)), ((usize)(((tagAnyru8)((&(*p)))))))));
            }
            goto after_4456;
        }
    }
    {
        succ_2826_ &= (tmp_4456_->tag == 1);
        if (succ_2826_) {
            {
                SubStr_s fullName = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for unknown type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4456;
        }
    }
    {
        succ_2832_ &= (tmp_4456_->tag == 2);
        Type_u **under = &tmp_4456_->payload.variant2._0;
        succ_2832_ &= true;
        if (succ_2832_) {
            {
                i32 _flags = (LLVMDIFlagPublic);
                LLVM_MetadataRef_s *elements = (((malloc))(((sizeof(LLVM_MetadataRef_s)) * ((usize)(2llu)))));
                ((assertBrN)(((elements) != (NULL))));
                SubStr_s ptrName = ((newSubStrOfStrLitPcrS7720)(("ptr")));
                SubStr_s sizeName = ((newSubStrOfStrLitPcrS7720)(("length")));
                LLVM_MetadataRef_s ptrDebugType = (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((intoPointerPU5175rPU5175)((*under))))).ref);
                LLVM_MetadataRef_s sizeDebugType =
                    (((createTypeS1476S5777PU5175rS5777)((builder), (diFile), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}}))))).ref);
                ((((elements))[((usize)(0llu))]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diFile).ref), ((ptrName).start), ((ptrName).len), ((diFile).ref), ((u32)(0)), ((u64)(64llu)),
                                                                                      ((u32)(64)), ((u64)(0llu)), (LLVMDIFlagZero), (ptrDebugType))));
                ((((elements))[((usize)(1llu))]) = (((LLVMDIBuilderCreateMemberType))(((builder).ref), ((diFile).ref), ((sizeName).start), ((sizeName).len), ((diFile).ref), ((u32)(0)), ((u64)(64llu)),
                                                                                      ((u32)(64)), ((u64)(64llu)), (LLVMDIFlagZero), (sizeDebugType))));
                String_s varName = ((newStringFromStrLitPcrS0540)(("var<")));
                String_s _s = ((toStringPU5175rS0540)((*under)));
                ((pushStringPS0540PS0540rN)((&(varName)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                ((pushCharPS0540crN)((&(varName)), ('>')));
                char *start = ((varName).buffer);
                usize len = ((varName).length);
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreateStructType))(((builder).ref), ((diFile).ref), (start), (len), ((diFile).ref), ((u32)(0)), ((u64)(128llu)), ((u32)(64)), (_flags),
                                                                             ((LLVM_MetadataRef_s){0}), (elements), ((u32)(2)), ((u32)(0)), ((LLVM_MetadataRef_s){0}), (start), (len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for variadic type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4456;
        }
    }
    {
        succ_2848_ &= (tmp_4456_->tag == 4);
        Type_u **under = &tmp_4456_->payload.variant4._0;
        succ_2848_ &= true;
        if (succ_2848_) {
            {
                LLVMMetadata_s pointee = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*under)));
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName = (((newSubStrOfStrLitPcrS7720)(("ptr"))));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreatePointerType))(((builder).ref), ((pointee).ref), (size), (align), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for pointer type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4456;
        }
    }
    {
        succ_2860_ &= (tmp_4456_->tag == 5);
        Type_u **under = &tmp_4456_->payload.variant5._0;
        succ_2860_ &= true;
        usize *size = &tmp_4456_->payload.variant5._1;
        succ_2860_ &= true;
        if (succ_2860_) {
            {
                LLVMMetadata_s element = ((createTypeS1476S5777PU5175rS5777)((builder), (diFile), (*under)));
                LLVM_MetadataRef_s meta =
                    (((LLVMDIBuilderCreateArrayType))(((builder).ref), ((u64)((*size))), ((u32)(((getAlignmentInBitsPU5175rusz)((*under))))), ((element).ref), (&((element).ref)), ((u32)(1))));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for array type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4456;
        }
    }
    {
        succ_2868_ &= (tmp_4456_->tag == 6);
        succ_2868_ &= true;
        succ_2868_ &= true;
        succ_2868_ &= true;
        if (succ_2868_) {
            {
                u64 size = ((u64)(64llu));
                u32 align = ((u32)(64));
                SubStr_s fullName1 = ((getFullNameU7375rS7720)((((PrimType_u){.tag = 11}))));
                LLVM_MetadataRef_s pointee = (((LLVMDIBuilderCreateUnspecifiedType))(((builder).ref), ((fullName1).start), ((fullName1).len)));
                SubStr_s fullName = ((newSubStrOfStrLitPcrS7720)(("fnPtr")));
                LLVM_MetadataRef_s meta = (((LLVMDIBuilderCreatePointerType))(((builder).ref), (pointee), (size), (align), ((u32)(0)), ((fullName).start), ((fullName).len)));
                ((assertBPcrN)((!(((LLVM_isNullS9683rB))((meta)))), ("Could not create debug info for function type")));
                ((data) = ((LLVMMetadata_s){.ref = (meta)}));
            }
            goto after_4456;
        }
    }
    {
        succ_2880_ &= (tmp_4456_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_4456_->payload.variant7._0;
        succ_2880_ &= true;
        if (succ_2880_) {
            {
                return (((*decl)->debugInfo).diType);
            }
            goto after_4456;
        }
    }
    {
        succ_2885_ &= (tmp_4456_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_4456_->payload.variant8._0;
        succ_2885_ &= true;
        succ_2885_ &= true;
        if (succ_2885_) {
            {
                return (((*decl)->debugInfo).diType);
            }
            goto after_4456;
        }
    }
    {
        succ_2889_ &= (tmp_4456_->tag == 9);
        succ_2889_ &= true;
        if (succ_2889_) {
            {
                ((todo_with_msgPcrN)(("createType(LLVMDIBuilder: Type::Module")));
            }
            goto after_4456;
        }
    }
    {
        Type_u **unknown = &tmp_4456_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s createType(LLVMDIBuilder): Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_4456;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4456:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((*(dt)) = (data));
    return (data);
}
none setSubprogramS8925S5777rN(LLVMValue_s fn, LLVMMetadata_s sp) { (((LLVMSetSubprogram))(((fn).ref), ((sp).ref))); }
LLVMMetadata_s getSubprogramS8925rS5777(LLVMValue_s fn) {
    LLVM_MetadataRef_s s = (((LLVMGetSubprogram))(((fn).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((s)))), ("Could not get Subprogram")));
    return ((LLVMMetadata_s){.ref = (s)});
}
LLVMMetadata_s createExpressionS1476PuszuszrS5777(LLVMDIBuilder_s diBuilder, usize *addr, usize length) {
    LLVM_MetadataRef_s e = (((LLVMDIBuilderCreateExpression))(((diBuilder).ref), (addr), (length)));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((e)))), ("Could not create debug expression")));
    return ((LLVMMetadata_s){.ref = (e)});
}
LLVMMetadata_s createDebugLocationS0773u32u32S5777rS5777(LLVMContext_s ctx, u32 line, u32 col, LLVMMetadata_s scope) {
    LLVM_MetadataRef_s loc = (((LLVMDIBuilderCreateDebugLocation))(((ctx).ref), (line), (col), ((scope).ref), ((LLVM_MetadataRef_s){0})));
    ((assertBPcrN)((!(((LLVM_isNullS9683rB))((loc)))), ("Could not create debug location")));
    return ((LLVMMetadata_s){.ref = (loc)});
}
none setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder, LLVMContext_s ctx, LLVMValue_s fn, IRFunc_s *irFunc, Span_s span) {
    ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), ((span).file)));
    usize line = ((usize)(0llu));
    usize col = ((usize)(0llu));
    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&(span)), (&(line)), (&(col))));
    LLVMMetadata_s sub = ((getSubprogramS8925rS5777)((fn)));
    LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)((ctx), ((u32)((line))), ((u32)((col))), (sub)));
    (((LLVMSetCurrentDebugLocation2))(((builder).ref), ((loc).ref)));
}
none resetCurrentDebugLocationS1476S6343rN(LLVMDIBuilder_s diBuilder, LLVMBuilder_s builder) { (((LLVMSetCurrentDebugLocation2))(((builder).ref), ((LLVM_MetadataRef_s){0}))); }
LLVMDbgRecord_s insertDeclareRecordBeforeS1476S8925S5777S5777S5777S8925rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                              LLVMValue_s instr) {
    LLVM_DbgRecordRef_s record = (((LLVMDIBuilderInsertDeclareRecordBefore))(((diBuilder).ref), ((storage).ref), ((info).ref), ((expr).ref), ((loc).ref), ((instr).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5902rB))((record)))), ("Could not insert record")));
    return ((LLVMDbgRecord_s){.ref = (record)});
}
LLVMDbgRecord_s insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276(LLVMDIBuilder_s diBuilder, LLVMValue_s storage, LLVMMetadata_s info, LLVMMetadata_s expr, LLVMMetadata_s loc,
                                                                             LLVMBasicBlock_s block) {
    LLVM_DbgRecordRef_s record = (((LLVMDIBuilderInsertDeclareRecordAtEnd))(((diBuilder).ref), ((storage).ref), ((info).ref), ((expr).ref), ((loc).ref), ((block).ref)));
    ((assertBPcrN)((!(((LLVM_isNullS5902rB))((record)))), ("Could not insert record")));
    return ((LLVMDbgRecord_s){.ref = (record)});
}
bool equalsPU5952PU5952rB(RegValue_u *this, RegValue_u *other) { ((todo_with_msgPcrN)(("RegValue.equals"))); }
none addInterpValuePU5952S9925rN(RegValue_u *this, InterpReg_s val) {
    bool succ_2906_ = true;
    bool succ_2910_ = true;
    bool succ_2913_ = true;
    bool succ_2918_ = true;

    RegValue_u *tmp_4494_ = (this);
    {
        succ_2906_ &= (tmp_4494_->tag == 1);
        LLVMValue_s *llvm = &tmp_4494_->payload.variant1._0;
        succ_2906_ &= true;
        if (succ_2906_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (*llvm), ._1 = (val)}}}));
            }
            goto after_4494;
        }
    }
    {
        succ_2910_ &= (tmp_4494_->tag == 2);
        succ_2910_ &= true;
        if (succ_2910_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 2, .payload = {.variant2 = {._0 = (val)}}}));
            }
            goto after_4494;
        }
    }
    {
        succ_2913_ &= (tmp_4494_->tag == 0);
        if (succ_2913_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 2, .payload = {.variant2 = {._0 = (val)}}}));
            }
            goto after_4494;
        }
    }
    {
        succ_2918_ &= (tmp_4494_->tag == 3);
        LLVMValue_s *llvm = &tmp_4494_->payload.variant3._0;
        succ_2918_ &= true;
        succ_2918_ &= true;
        if (succ_2918_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (*llvm), ._1 = (val)}}}));
            }
            goto after_4494;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_4494;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4494:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none addLLVMValuePU5952S8925rN(RegValue_u *this, LLVMValue_s val) {
    bool succ_2923_ = true;
    bool succ_2927_ = true;
    bool succ_2930_ = true;
    bool succ_2935_ = true;

    RegValue_u *tmp_4505_ = (this);
    {
        succ_2923_ &= (tmp_4505_->tag == 1);
        succ_2923_ &= true;
        if (succ_2923_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 1, .payload = {.variant1 = {._0 = (val)}}}));
            }
            goto after_4505;
        }
    }
    {
        succ_2927_ &= (tmp_4505_->tag == 2);
        InterpReg_s *interp = &tmp_4505_->payload.variant2._0;
        succ_2927_ &= true;
        if (succ_2927_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (val), ._1 = (*interp)}}}));
            }
            goto after_4505;
        }
    }
    {
        succ_2930_ &= (tmp_4505_->tag == 0);
        if (succ_2930_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 1, .payload = {.variant1 = {._0 = (val)}}}));
            }
            goto after_4505;
        }
    }
    {
        succ_2935_ &= (tmp_4505_->tag == 3);
        succ_2935_ &= true;
        InterpReg_s *interp = &tmp_4505_->payload.variant3._1;
        succ_2935_ &= true;
        if (succ_2935_) {
            {
                ((*(this)) = ((RegValue_u){.tag = 3, .payload = {.variant3 = {._0 = (val), ._1 = (*interp)}}}));
            }
            goto after_4505;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_4505;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4505:
    (void)0; // error: label at end of compound statement is a C23 extension
}
InterpReg_s asInterpPU5952PcrS9925(RegValue_u *this, char *err) {
    bool succ_2940_ = true;
    bool succ_2945_ = true;

    RegValue_u *tmp_4511_ = (this);
    {
        succ_2940_ &= (tmp_4511_->tag == 2);
        InterpReg_s *interp = &tmp_4511_->payload.variant2._0;
        succ_2940_ &= true;
        if (succ_2940_) {
            {
                return (*interp);
            }
            goto after_4511;
        }
    }
    {
        succ_2945_ &= (tmp_4511_->tag == 3);
        succ_2945_ &= true;
        InterpReg_s *interp = &tmp_4511_->payload.variant3._1;
        succ_2945_ &= true;
        if (succ_2945_) {
            {
                return (*interp);
            }
            goto after_4511;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4511;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4511:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
LLVMValue_s asLLVMPU5952PcrS8925(RegValue_u *this, char *err) {
    bool succ_2950_ = true;
    bool succ_2955_ = true;

    RegValue_u *tmp_4518_ = (this);
    {
        succ_2950_ &= (tmp_4518_->tag == 1);
        LLVMValue_s *llvm = &tmp_4518_->payload.variant1._0;
        succ_2950_ &= true;
        if (succ_2950_) {
            {
                return (*llvm);
            }
            goto after_4518;
        }
    }
    {
        succ_2955_ &= (tmp_4518_->tag == 3);
        LLVMValue_s *llvm = &tmp_4518_->payload.variant3._0;
        succ_2955_ &= true;
        succ_2955_ &= true;
        if (succ_2955_) {
            {
                return (*llvm);
            }
            goto after_4518;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4518;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4518:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)((err)));
}
bool isLLVMPU5952rB(RegValue_u *this) {
    bool succ_2960_ = true;
    bool succ_2965_ = true;

    RegValue_u *tmp_4525_ = (this);
    {
        succ_2960_ &= (tmp_4525_->tag == 1);
        succ_2960_ &= true;
        if (succ_2960_) {
            {
                return (true);
            }
            goto after_4525;
        }
    }
    {
        succ_2965_ &= (tmp_4525_->tag == 3);
        succ_2965_ &= true;
        succ_2965_ &= true;
        if (succ_2965_) {
            {
                return (true);
            }
            goto after_4525;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4525;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4525:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isInterpPU5952rB(RegValue_u *this) {
    bool succ_2970_ = true;
    bool succ_2975_ = true;

    RegValue_u *tmp_4532_ = (this);
    {
        succ_2970_ &= (tmp_4532_->tag == 2);
        succ_2970_ &= true;
        if (succ_2970_) {
            {
                return (true);
            }
            goto after_4532;
        }
    }
    {
        succ_2975_ &= (tmp_4532_->tag == 3);
        succ_2975_ &= true;
        succ_2975_ &= true;
        if (succ_2975_) {
            {
                return (true);
            }
            goto after_4532;
        }
    }
    {
        if (true) {
            {
            }
            goto after_4532;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_4532:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool generateDebugInfoPS4053i32PPcrB(LLVMCodegen_s *this, i32 argc, char **argv) {
    ((assertBPcrN)((!(((LLVM_isNullS1302rB))((((this)->llvmDIBuilder).ref)))), ("Can\'t generate debug info because DIBuilder is null!")));
    ((assertBPcrN)((((types).length) == ((debugTypes).length)), ("Expected to have as many debug types as normal types")));
    SubStr_s producer = ((newSubStrOfStrLitPcrS7720)(("Bufo Programming Language")));
    String_s cli = ((newStringFromStrLitPcrS0540)((((argv))[((usize)(0llu))])));
    for (i32 i = ((i32)(1)); ((i) < (argc)); ((i) = ((i) + ((i32)(1))))) {
        ((pushCharPS0540crN)((&(cli)), (' ')));
        ((pushStrPS0540PcrN)((&(cli)), (((argv))[((usize)((i)))])));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *f = ((atPS9483uszrPS1892)((&(files)), (i)));
        String_s path = ((toStringPS7720rS0540)((&((f)->origin))));
        String_s root = ((getRootPS0540rS0540)((&(path))));
        String_s file = ((getFileNamePS0540rS0540)((&(path))));
        LLVMMetadata_s diFile = ((createFileS1476PcuszPcuszrS5777)(((this)->llvmDIBuilder), ((file).buffer), ((file).length), ((root).buffer), ((root).length)));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("Could not create debug file")));
        LLVMMetadata_s diUnit =
            ((createCompileUnitS1476i32S5777S7720S2924S7720u32S7720i32u32S2924S2924S7720S7720rS5777)(((this)->llvmDIBuilder), (LLVMDWARFSourceLanguageC), (diFile), (producer),
                                                                                                     ((newLLVMBoolBrS2924)((*((flags).opt)))), ((asSubStrPS0540rS7720)((&(cli)))), ((u32)(0)),
                                                                                                     ((SubStr_s){0}), (LLVMDWARFEmissionKindFull), ((u32)(0)), ((newLLVMBoolBrS2924)((true))),
                                                                                                     ((newLLVMBoolBrS2924)((true))), ((SubStr_s){0}), ((SubStr_s){0})));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("Could not create Compile Unit")));
        (((f)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diUnit = (diUnit)}));
        ((dropPS0540rN)((&(file))));
        ((dropPS0540rN)((&(root))));
        ((dropPS0540rN)((&(path))));
    }

    ((assertBPcrN)((((types).length) >= (PRIM_TYPE_COUNT)), ("Expected to find at least all primitive types")));
    for (usize i = ((usize)(0llu)); ((i) < (PRIM_TYPE_COUNT)); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS7368uszrPS5777)((&(debugTypes)), (i)))) = ((createDebugInfoForPrimitiveTypeS1476PU5175rS5777)(((this)->llvmDIBuilder), ((atPS4174uszrPU5175)((&(types)), (i))))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diType = ((LLVMMetadata_s){.ref = (((LLVMTemporaryMDNode))((((this)->llvmContext).ref), (NULL), ((usize)(0llu))))})}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diType = ((LLVMMetadata_s){.ref = (((LLVMTemporaryMDNode))((((this)->llvmContext).ref), (NULL), ((usize)(0llu))))})}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((decl)->ignored)
            continue;
        Type_u *fts = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ParsedFile_s *file = ((getParentFilePS5521rPS1892)((decl)));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diType = ((createDebugInfoForStructTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), (fts)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diType = (diType)}));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((decl)->ignored)
            continue;
        Type_u *fts = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ParsedFile_s *file = ((getParentFilePS0997rPS1892)((decl)));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diType = ((createDebugInfoForUnionTypeS1476S5777PU5175S0773rS5777)(((this)->llvmDIBuilder), (diFile), (fts), ((this)->llvmContext)));
        (((decl)->debugInfo) = ((DebugInfo_s){.diFile = (diFile), .diType = (diType)}));
    }

    ((dropPS0540rN)((&(cli))));
    return (true);
}
bool generateExecutablePS4053S7720i32PPcrB(LLVMCodegen_s *this, SubStr_s outPath, i32 argc, char **argv) {
    IRFuncList_s fns = ((asListPS2612rS8040)((&(((this)->irGen)->functions))));
    if (*((flags).debug)) {
        if (!((generateDebugInfoPS4053i32PPcrB)((this), (argc), (argv))))
            return (false);
        if (*((flags).verbose)) {
            ((dumpInstructionsPS7132rN)((&(((this)->irGen)->globalScope))));
            for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
                IRFunc_s *f = ((atPS8040uszrPS7132)((&(fns)), (i)));
                ((dumpInstructionsPS7132rN)((f)));
            }
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((generateLLVMFunctionHeaderPS4053PS7132rN)((this), ((atPS8040uszrPS7132)((&(fns)), (i)))));
    }

    if (!((generateRuntimeInitializationPS4053PS7132rB)((this), (&(((this)->irGen)->initRuntime)))))
        return (false);
    if (!((generateEntryPointPS4053rB)((this))))
        return (false);
    if (!((generateGlobalPS4053PS7132rB)((this), (&(((this)->irGen)->globalScope)))))
        return (false);
    if (!((_generateFunctionPS4053PS7132rB)((this), (&(((this)->irGen)->initRuntime)))))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRFunc_s *f = ((atPS8040uszrPS7132)((&(fns)), (i)));
        if (!((generateFunctionPS4053PS7132rB)((this), (f))))
            return (false);
    }

    if (*((flags).debug)) {
        ((finalizeDIBuilderS1476rN)(((this)->llvmDIBuilder)));
    }

    if ((*((flags).debug)) && (*((flags).emitLLVM)))
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("debug_before.ll")))));
    if (!((verifyPS1718rB)((&((this)->llvmModule)))))
        return (false);
    if (*((flags).opt)) {
        LLVMPassBuilderOptions_s passOptions = ((createPassBuilderOptionsrS4890)());
        ((setLoopInterleavingS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLoopVectorizationS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setSLPVectorizationS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLoopUnrollingS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setForgetAllSCEVInLoopUnrollS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setLicmMssaOptCapS4890u32rN)((passOptions), ((u32)(100))));
        ((setLicmMssaNoAccForPromotionCapS4890u32rN)((passOptions), ((u32)(8))));
        ((setCallGraphProfileS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setMergeFunctionsS4890S2924rN)((passOptions), ((newLLVMBoolBrS2924)((true)))));
        ((setInlinerThresholdS4890i32rN)((passOptions), ((i32)(250))));
        if (!((runPassesS1718PcS7964S4890rB)(((this)->llvmModule), ("default<O3>"), ((this)->llvmTargetMachine), (passOptions)))) {
            return (false);
        }

        ((disposePassBuilderOptionsS4890rN)((passOptions)));
    }

    if ((*((flags).debug)) && (*((flags).emitLLVM)))
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("debug_after.ll")))));
    String_s objPath = ((toStringPS7720rS0540)((&(outPath))));
    ((pushStrPS0540PcrN)((&(objPath)), (".obj")));
    if (*((flags).verbose)) {
        (((printf))(("[INFO] Saving object file at %s\n"), ((objPath).buffer)));
    }

    ((writeToFilePS7964S1718i32PcrN)((&((this)->llvmTargetMachine)), ((this)->llvmModule), (LLVMObjectFile), ((objPath).buffer)));
    if (*((flags).emitASM)) {
        String_s asmPath = ((toStringPS7720rS0540)((&(outPath))));
        ((pushStrPS0540PcrN)((&(asmPath)), (".s")));
        (((printf))(("[INFO] Saving assembly code in %s\n"), ((asmPath).buffer)));
        ((writeToFilePS7964S1718i32PcrN)((&((this)->llvmTargetMachine)), ((this)->llvmModule), (LLVMAssemblyFile), ((asmPath).buffer)));
        ((dropPS0540rN)((&(asmPath))));
    }

    if (*((flags).emitLLVM)) {
        String_s llvmPath = ((toStringPS7720rS0540)((&(outPath))));
        ((pushStrPS0540PcrN)((&(llvmPath)), (".ll")));
        (((printf))(("[INFO] Saving LLVM IR in %s\n"), ((llvmPath).buffer)));
        ((writeToFilePS1718S7720rB)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&(llvmPath))))));
        ((dropPS0540rN)((&(llvmPath))));
    }

    return (true);
}
bool generateRuntimeInitializationPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *initRuntime) {
    Type_u *rt_type = ((wrapU5175rPU5175)(((Type_u){
        .tag = 6,
        .payload = {.variant6 = {._0 = ((TypeList_s){0}), ._1 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), ._2 = ((FuncAttr_s){0})}}})));
    LLVMType_s llvmFuncType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), (rt_type)));
    LLVMValue_s llvmFuncValue = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&((initRuntime)->name)))), (llvmFuncType)));
    if (*((flags).debug)) {
        ParsedFile_s *file = (NULL);
        for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedFile_s *f = ((atPS9483uszrPS1892)((&(files)), (i)));
            SubStr_s tmp_23008 = ((asSubStrPS0540rS7720)(((flags).file)));

            if ((endsWithPS7720PS7720rB)((&((f)->origin)), (&tmp_23008))) {
                ((file) = (f));
                break;
            }
        }

        ((assertBrN)(((file) != (NULL))));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((initRuntime)->span)), (&(line)), (&(col))));
        SubStr_s linkage = ((asSubStrPS0540rS7720)((&((initRuntime)->name))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diUnit = (((file)->debugInfo).diUnit);
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("DebugInfo File is null")));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("DebugInfo Unit is null")));
        LLVMMetadata_s sp =
            ((createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777)(((this)->llvmDIBuilder), (diUnit), ((asSubStrPS0540rS7720)((&((initRuntime)->name)))), (linkage), (diFile),
                                                                                          ((u32)((line))), ((createSubroutineTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), (rt_type))),
                                                                                          ((newLLVMBoolBrS2924)((false))), ((newLLVMBoolBrS2924)((true))), ((u32)((line))), (LLVMDIFlagPrototyped),
                                                                                          ((newLLVMBoolBrS2924)((*((flags).opt))))));
        ((setSubprogramS8925S5777rN)((llvmFuncValue), (sp)));
    }

    (((initRuntime)->llvmFunc) = (llvmFuncValue));
    return (true);
}
bool generateEntryPointPS4053rB(LLVMCodegen_s *this) {
    if (*((flags).noEntry))
        return (true);
    SubStr_s realMainName = ((newSubStrOfStrLitPcrS7720)(("__real_main")));
    if (!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (realMainName)))) {
        (((fprintf))((stderr_), ("%s Could not find entry point!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: Expected to find `std/runtime.bufo` in the list of imports, but failed!\n"), (NOTE_STR)));
        return (false);
    }

    LLVMValue_s realMainFunc = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (realMainName)));
    SubStr_s mainName = ((newSubStrOfStrLitPcrS7720)(("maini32PPcri32")));
    if (!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (mainName)))) {
        (((fprintf))((stderr_), ("%s Could not find main function!\n"), (FATAL_STR)));
        (((fprintf))((stderr_), ("%s: The compiler currently requires that the input file also defines a main function.\n"), (NOTE_STR)));
        (((fprintf))((stderr_), ("%s: The compiler is looking for a function with the signature `func main(argc: i32, argv: &&char) -> i32`.\n"), (NOTE_STR)));
        return (false);
    }

    LLVMValue_s mainFunc = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (mainName)));
    LLVMType_s retType = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
    LLVMTypeList_s params = ((LLVMTypeList_s){0});
    ((pushPS4318S0706rN)((&(params)), ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))))));
    LLVMType_s _p = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
    ((pushPS4318S0706rN)((&(params)), ((intoPointerTypePS0706rS0706)((&(_p))))));
    LLVMType_s tmp_23240 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

    ((pushPS4318S0706rN)((&(params)), ((intoPointerTypePS0706rS0706)((&tmp_23240)))));
    LLVMType_s retFnType = ((intoFunctionTypePS0706S4318BrS0706)((&(retType)), (params), (false)));
    ((assertBrN)((!((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("main"))))))));
    LLVMValue_s main = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((newSubStrOfStrLitPcrS7720)(("main"))), (retFnType)));
    LLVMBasicBlock_s entry = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (main), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    ((positionAtEndPS6343S7469rN)((&((this)->llvmBuilder)), (entry)));
    LLVMValueList_s args = ((LLVMValueList_s){0});
    {
        SubStr_s rt_name = ((newSubStrOfStrLitPcrS7720)((".init_runtime")));
        ((assertBPcrN)(((hasFunctionPS1718S7720rB)((&((this)->llvmModule)), (rt_name))), ("Could not find .init_runtime")));
        LLVMValue_s runtime_func = ((getFunctionPS1718S7720rS8925)((&((this)->llvmModule)), (rt_name)));
        LLVMType_s _retType = ((createVoidTypePS0773rS0706)((&((this)->llvmContext))));
        LLVMTypeList_s _params = ((LLVMTypeList_s){0});
        LLVMType_s _retFnType = ((intoFunctionTypePS0706S4318BrS0706)((&(_retType)), (_params), (false)));
        ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (runtime_func), (_retFnType), ((LLVMValueList_s){0}), (_retType), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    }

    ((pushPS8201S8925rN)((&(args)), ((getNthParamPS8925uszrS8925)((&(main)), ((usize)(0llu))))));
    ((pushPS8201S8925rN)((&(args)), ((getNthParamPS8925uszrS8925)((&(main)), ((usize)(1llu))))));
    ((pushPS8201S8925rN)((&(args)), (mainFunc)));
    LLVMValue_s v = ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (realMainFunc), (retFnType), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("entry")))));
    ((buildReturnPS6343S8925rN)((&((this)->llvmBuilder)), (v)));
    return (true);
}
bool generateGlobalPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *global) {
    (((this)->global) = ((RegValueList_s){0}));
    ((initBlankPS5884uszrN)((&((this)->global)), (((global)->registers).length)));
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((global)));
    LLVMValue_s llvmFunc = ((LLVMValue_s){0});
    LLVMBasicBlockList_s blocks = ((LLVMBasicBlockList_s){0});
    ((pushRegisterStackPS3154S8951uszrN)(((this)->interp), ((defaultSpanrS8951)()), (funcSize)));
    ((((this)->interp)->globalRegisters) = (&((this)->global)));
    ((((this)->interp)->globalRegBase) = (((this)->interp)->regStackBase));
    ((assertBPcrN)(((((global)->blocks).length) == ((usize)(1llu))), ("Expected to only find one IRBlock in global scope")));
    ((generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN)((this), (&(llvmFunc)), (global), (&(blocks)), ((atPS1479uszrPS9435)((&((global)->blocks)), ((usize)(0llu)))), (&((this)->global))));
    return (true);
}
none generateLLVMFunctionHeaderPS4053PS7132rN(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    LLVMValue_s llvmFunc = ((LLVMValue_s){0});
    ParsedFuncDecl_s *function = ((getFuncNodePS7132rPS4904)((irFunc)));
    LLVMType_s llvmFuncType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), ((getTypePU9661rPU5175)((&((function)->typeState))))));
    LLVMValue_s llvmFuncValue = ((addFunctionPS1718S7720S0706rS8925)((&((this)->llvmModule)), ((asSubStrPS0540rS7720)((&((irFunc)->name)))), (llvmFuncType)));
    if ((hasAttributePS7132U4360rB)((irFunc), (((ParsedAttribute_u){.tag = 3, .payload = {0}})))) {
        u32 id = (((LLVMGetEnumAttributeKindForName))(("noreturn"), ((usize)(8llu))));
        ((assertBPcrN)(((id) != ((u32)(0))), ("Could not get noreturn attribute from LLVM")));
        ((addAttributePS8925u32S6660rN)((&(llvmFuncValue)), (U32_MAX), ((createEnumAttributePS0773u32u64rS6660)((&((this)->llvmContext)), (id), ((u64)(1llu))))));
    }

    if ((hasAttributePS7132U4360rB)((irFunc), (((ParsedAttribute_u){.tag = 4, .payload = {0}})))) {
        u32 id = (((LLVMGetEnumAttributeKindForName))(("naked"), ((usize)(5llu))));
        ((assertBPcrN)(((id) != ((u32)(0))), ("Could not get naked attribute from LLVM")));
        ((addAttributePS8925u32S6660rN)((&(llvmFuncValue)), (U32_MAX), ((createEnumAttributePS0773u32u64rS6660)((&((this)->llvmContext)), (id), ((u64)(1llu))))));
    }

    if (*((flags).debug)) {
        ParsedFile_s *file = ((getParentFilePS4904rPS1892)((function)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((function)->span)), (&(line)), (&(col))));
        SubStr_s linkage = ((asSubStrPS0540rS7720)((&((irFunc)->name))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s diUnit = (((file)->debugInfo).diUnit);
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diFile).ref)))), ("DebugInfo File is null")));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((diUnit).ref)))), ("DebugInfo Unit is null")));
        LLVMMetadata_s sp =
            ((createFunctionS1476S5777S7720S7720S5777u32S5777S2924S2924u32i32S2924rS5777)(((this)->llvmDIBuilder), (diUnit), (((function)->name).content), (linkage), (diFile), ((u32)((line))),
                                                                                          ((createSubroutineTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile),
                                                                                                                                        ((getTypePU9661rPU5175)((&((function)->typeState)))))),
                                                                                          ((newLLVMBoolBrS2924)((false))), ((newLLVMBoolBrS2924)((!((isExternPS4904rB)((function)))))), ((u32)((line))),
                                                                                          (LLVMDIFlagPrototyped), ((newLLVMBoolBrS2924)((*((flags).opt))))));
        ((setSubprogramS8925S5777rN)((llvmFuncValue), (sp)));
    }

    (((irFunc)->llvmFunc) = (llvmFuncValue));
    IRFunc_s *origFunc = ((getPS2612PS0540rPS7132)((&(((this)->irGen)->functions)), (&((irFunc)->name))));
    (((origFunc)->llvmFunc) = (llvmFuncValue));
}
LLVMType_s prepareReturnTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        return ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
    }

    else {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
    }
}
LLVMType_s prepareParameterPS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        return ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
    }

    else if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), ((intoPointerPU5175rPU5175)((typ)))));
    }

    else {
        return ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
    }
}
usize getLLVMTypeSizePS4053PS0706rusz(LLVMCodegen_s *this, LLVMType_s *typ) {
    LLVMTargetData_s data = ((getTargetDataPS7964rS8369)((&((this)->llvmTargetMachine))));
    usize s1 = ((getStoreSizePS8369PS0706rusz)((&(data)), (typ)));
    usize s2 = ((getABISizePS8369PS0706rusz)((&(data)), (typ)));
    usize s3 = (((getBitSizePS8369PS0706rusz)((&(data)), (typ))) / ((usize)(8llu)));
    ((assertBPcrN)(((((s1) == (s2)) && ((s1) == (s3))) && ((s2) == (s3))), ("LLVMTargetData returned different type sizes")));
    return (s1);
}
bool _generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    LLVMValue_s llvmFuncValue = ((irFunc)->llvmFunc);
    ((assertBrN)((!(((LLVM_isNullS1407rB))(((llvmFuncValue).ref))))));
    LLVMBasicBlockList_s blocks = ((LLVMBasicBlockList_s){0});
    ((initBlankPS0409uszrN)((&(blocks)), (((irFunc)->blocks).length)));
    ((assertBPcrN)((((blocks).length) != ((usize)(0llu))), ("Every IRFunc has at least one instruction")));
    ((*((atPS0409uszrPS7469)((&(blocks)), ((usize)(0llu))))) = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (llvmFuncValue), ((newSubStrOfStrLitPcrS7720)(("entry"))))));
    for (usize i = ((usize)(1llu)); ((i) < (((irFunc)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS0409uszrPS7469)((&(blocks)), (i)))) = ((appendBasicBlockPS0773S8925S7720rS7469)((&((this)->llvmContext)), (llvmFuncValue), ((newSubStrOfStrLitPcrS7720)(("b"))))));
    }

    RegValueList_s regs = ((RegValueList_s){0});
    ((initBlankPS5884uszrN)((&(regs)), (((irFunc)->registers).length)));
    usize funcSize = ((getRegisterSizeInBytesPS7132rusz)((irFunc)));
    ((pushRegisterStackPS3154S8951uszrN)(((this)->interp), ((irFunc)->span), (funcSize)));
    if (*((flags).debug))
        ((resetCurrentDebugLocationS1476S6343rN)(((this)->llvmDIBuilder), ((this)->llvmBuilder)));
    for (usize i = ((usize)(0llu)); ((i) < (((irFunc)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRBlock_s *block = ((getBlockByIDPS7132S7192rPS9435)((irFunc), ((IRBlockID_s){.i = (i)})));
        ((positionAtEndPS6343S7469rN)((&((this)->llvmBuilder)), (*((atPS0409uszrPS7469)((&(blocks)), (i))))));
        ((generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN)((this), (&(llvmFuncValue)), (irFunc), (&(blocks)), (block), (&(regs))));
    }

    ((popRegisterStackPS3154S8951uszrN)(((this)->interp), ((irFunc)->span), (funcSize)));
    return (true);
}
bool generateFunctionPS4053PS7132rB(LLVMCodegen_s *this, IRFunc_s *irFunc) {
    if ((isExternPS7132rB)((irFunc)))
        return (true);
    return ((_generateFunctionPS4053PS7132rB)((this), (irFunc)));
}
none generateBlockPS4053PS8925PS7132PS0409PS9435PS5884rN(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *llvmBlocks, IRBlock_s *block, RegValueList_s *regs) {
    for (usize i = ((usize)(0llu)); ((i) < (((block)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRInstr_s *instr = ((atPS0124uszrPS7680)((&((block)->instructions)), (i)));
        if (*((flags).debug)) {
            bool isGlobal = (((LLVM_isNullS1407rB))(((llvmFunc)->ref)));
            if (!(isGlobal)) {
                ((setCurrentDebugLocationS1476S6343S0773S8925PS7132S8951rN)(((this)->llvmDIBuilder), ((this)->llvmBuilder), ((this)->llvmContext), (*(llvmFunc)), (irFunc), ((instr)->span)));
            }
        }

        if (((instr)->kind) == (INSTR_ALLOCA)) {
            if (!((instr)->isComptime)) {
                LLVMValue_s llvm = ((generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925)((this), (llvmFunc), (irFunc), (llvmBlocks), (instr), (regs)));
                ((addLLVMValuePU5952S8925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (llvm)));
            }

            InterpReg_s interp = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)(((this)->interp), (irFunc), (instr), (regs), (true)));
            ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (interp)));
        }

        else if ((instr)->isComptime) {
            InterpReg_s val = ((evaluateSinglePS3154PS7132PS7680PS5884BrS9925)(((this)->interp), (irFunc), (instr), (regs), (false)));
            if (!((isTerminatorPS7680rB)((instr))))
                ((addInterpValuePU5952S9925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (val)));
        }

        else {
            LLVMValue_s val = ((generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925)((this), (llvmFunc), (irFunc), (llvmBlocks), (instr), (regs)));
            if (!((isTerminatorPS7680rB)((instr))))
                ((addLLVMValuePU5952S8925rN)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), (val)));
        }
    }
}
LLVMValue_s generateLLVMInstrPS4053PS8925PS7132PS0409PS7680PS5884rS8925(LLVMCodegen_s *this, LLVMValue_s *llvmFunc, IRFunc_s *irFunc, LLVMBasicBlockList_s *blocks, IRInstr_s *instr,
                                                                        RegValueList_s *regs) {
    bool isGlobal = (((LLVM_isNullS1407rB))(((llvmFunc)->ref)));
    if (((instr)->kind) == (INSTR_DEBUG_INFO_PARAM)) {
        ((assertBrN)((*((flags).debug))));
        ((assertBrN)((!(isGlobal))));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMValue_s dstLLVM = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM DebugInfo Param")));
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (((instr)->span).file)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((instr)->span)), (&(line)), (&(col))));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM DebugInfo Param non-ptr")));
        LLVMMetadata_s mt = ((createTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)))));
        char *start = ((char *)(((shiftRightuszuszrusz)((((instr)->src).i), (PARAM_SHIFT)))));
        usize index = ((((instr)->src).i) % ((shiftLeftuszuszrusz)(((usize)(1llu)), (PARAM_SHIFT))));
        LLVMMetadata_s scope = ((getSubprogramS8925rS5777)((*(llvmFunc))));
        LLVMMetadata_s meta = ((
            createParameterVariableS1476S5777S7720u32S5777u32S5777S2924i32rS5777)(((this)->llvmDIBuilder), (scope), ((newSubStrPcuszuszrS7720)((start), ((usize)(0llu)), (((instr)->op1).i))),
                                                                                  (((u32)((index))) + ((u32)(1))), (diFile), ((u32)((line))), (mt), ((newLLVMBoolBrS2924)((true))), (LLVMDIFlagZero)));
        LLVMMetadata_s expr = ((createExpressionS1476PuszuszrS5777)(((this)->llvmDIBuilder), (NULL), ((usize)(0llu))));
        LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)(((this)->llvmContext), ((u32)((line))), ((u32)((col))), (scope)));
        ((insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276)(((this)->llvmDIBuilder), (dstLLVM), (meta), (expr), (loc), ((getInsertBlockPS6343rS7469)((&((this)->llvmBuilder))))));
        return (dstLLVM);
    }

    else if (((instr)->kind) == (INSTR_DEBUG_INFO_ALLOCA)) {
        ((assertBrN)((*((flags).debug))));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMValue_s dstLLVM = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM DebugInfo Alloca")));
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (((instr)->span).file)));
        usize line = ((usize)(0llu));
        usize col = ((usize)(0llu));
        ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (&((instr)->span)), (&(line)), (&(col))));
        LLVMMetadata_s expr = ((createExpressionS1476PuszuszrS5777)(((this)->llvmDIBuilder), (NULL), ((usize)(0llu))));
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM DebugInfo Alloca non-ptr")));
        LLVMMetadata_s diFile = (((file)->debugInfo).diFile);
        LLVMMetadata_s mt = ((createTypeS1476S5777PU5175rS5777)(((this)->llvmDIBuilder), (diFile), ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)))));
        if (isGlobal) {
            LLVMMetadata_s meta = ((LLVMMetadata_s){
                .ref = (((LLVMDIBuilderCreateGlobalVariableExpression))((((this)->llvmDIBuilder).ref), ((((file)->debugInfo).diUnit).ref), ((char *)((((instr)->src).i))), (((instr)->op1).i),
                                                                        ((char *)((((instr)->src).i))), (((instr)->op1).i), ((diFile).ref), ((u32)((line))), ((mt).ref), ((newLLVMBoolBrS2924)((true))),
                                                                        ((expr).ref), ((LLVM_MetadataRef_s){0}), ((u32)(((getAlignmentInBitsPU5175rusz)(((reg)->typ)))))))});
            ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((meta).ref)))), ("Could not create global variable expression")));
            (((LLVMGlobalSetMetadata))(((dstLLVM).ref), ((u32)(0)), ((meta).ref)));
            return (dstLLVM);
        }

        LLVMMetadata_s scope = ((getSubprogramS8925rS5777)((*(llvmFunc))));
        LLVMMetadata_s meta =
            ((createAutoVariableS1476S5777S7720S5777u32S5777S2924i32u32rS5777)(((this)->llvmDIBuilder), (scope), ((SubStr_s){.start = ((char *)((((instr)->src).i))), .len = (((instr)->op1).i)}),
                                                                               (diFile), ((u32)((line))), (mt), ((newLLVMBoolBrS2924)((true))), (LLVMDIFlagZero),
                                                                               ((u32)(((getAlignmentInBitsPU5175rusz)(((reg)->typ)))))));
        ((assertBPcrN)((!(((LLVM_isNullS9683rB))(((meta).ref)))), ("Could not get scope for DebugInfo-Alloca")));
        LLVMMetadata_s loc = ((createDebugLocationS0773u32u32S5777rS5777)(((this)->llvmContext), ((u32)((line))), ((u32)((col))), (scope)));
        ((insertDeclareRecordAtEndS1476S8925S5777S5777S5777S7469rS7276)(((this)->llvmDIBuilder), (dstLLVM), (meta), (expr), (loc), ((getInsertBlockPS6343rS7469)((&((this)->llvmBuilder))))));
        return (dstLLVM);
    }

    else if (((instr)->kind) == (INSTR_ALLOCA)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        ((assertBPcrN)(((isPointerPU5175rB)(((reg)->typ))), ("LLVM Alloca expected ptr dst")));
        Type_u *t = ((getUnderlyingTypePU5175BrPU5175)(((reg)->typ), (false)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), (t)));
        if (isGlobal) {
            return ((addGlobalPS1718S0706u32S7720rS8925)((&((this)->llvmModule)), (typ), ((u32)(0)), ((newSubStrOfStrLitPcrS7720)(("g")))));
        }

        else {
            return ((buildAllocaPS6343S0706S7720rS8925)((&((this)->llvmBuilder)), (typ), ((newSubStrOfStrLitPcrS7720)(("v")))));
        }

    }

    else if (((instr)->kind) == (INSTR_GET_PARAM)) {
        ((assertBrN)((!(isGlobal))));
        LLVMValue_s param = ((getNthParamPS8925uszrS8925)((llvmFunc), (((instr)->src).i)));
        ((setNamePS8925S7720rN)((&(param)), ((newSubStrOfStrLitPcrS7720)(("p")))));
        return (param);
    }

    else if (((instr)->kind) == (INSTR_STORE)) {
        LLVMValue_s dstVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM Store dst")));
        LLVMValue_s srcVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Store src")));
        if (isGlobal) {
            ((setInitializerPS8925S8925rN)((&(dstVal)), (srcVal)));
        }

        else {
            ((buildStorePS6343S8925S8925rS8925)((&((this)->llvmBuilder)), (dstVal), (srcVal)));
        }

        return (dstVal);
    }

    else if (((instr)->kind) == (INSTR_LOAD_FUNCTION_PTR)) {
        IRFunc_s *called = ((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (((instr)->src).i)));
        return ((called)->llvmFunc);
    }

    else if (((instr)->kind) == (INSTR_LOAD)) {
        Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
        LLVMType_s dstTyp = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
        if ((isLLVMPU5952rB)((reg))) {
            LLVMValue_s srcVal = ((asLLVMPU5952PcrS8925)((reg), ("LLVM Load")));
            if (isGlobal) {
                return ((getInitializerPS8925rS8925)((&(srcVal))));
            }

            else {
                return ((buildLoadPS6343S0706S8925S7720rS8925)((&((this)->llvmBuilder)), (dstTyp), (srcVal), ((newSubStrOfStrLitPcrS7720)(("load")))));
            }

        }

        else {
            InterpReg_s tmp_24823 = ((asInterpPU5952PcrS9925)((reg), ("LLVM Load from comptime")));

            u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (&tmp_24823)));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), ((u8 *)((*((usize *)((start))))))));
        }

    }

    else if (((instr)->kind) == (INSTR_MOVE)) {
        return ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Move")));
    }

    else if (((instr)->kind) == (INSTR_FETCH_GLOBAL_PTR)) {
        RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
        if ((isLLVMPU5952rB)((val))) {
            return ((asLLVMPU5952PcrS8925)((val), ("We just checked if it is LLVM")));
        }

        else {
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            return ((generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925)((this), (typ), (reg)));
        }

    }

    else if (((instr)->kind) == (INSTR_FETCH_GLOBAL_VALUE)) {
        RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
        Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
        ((assertBPcrN)(((isLLVMPU5952rB)((val))), ("FetchGlobalValue got non-LLVM src")));
        LLVMType_s dstTyp = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
        LLVMValue_s reg = ((asLLVMPU5952PcrS8925)((val), ("We just checked if it is LLVM")));
        return ((buildLoadPS6343S0706S8925S7720rS8925)((&((this)->llvmBuilder)), (dstTyp), (reg), ((newSubStrOfStrLitPcrS7720)(("fetchglobalval")))));
    }

    else if (((instr)->kind) == (INSTR_FETCH_COMPTIME_VALUE)) {
        if ((((instr)->op1).i) == ((usize)(1llu))) {
            RegValue_u *val = ((atPS5884uszrPU5952)((&((this)->global)), (((instr)->src).i)));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            ((assertBPcrN)((!((isLLVMPU5952rB)((val)))), ("FetchComptimeValue global=1 got non-Interp src")));
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            u8 *start = ((getGlobalPointerPS3154PS9925rPu8)(((this)->interp), (&(reg))));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), (start)));
        }

        else {
            RegValue_u *val = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
            Type_u *typ = (((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)))->typ);
            ((assertBPcrN)((!((isLLVMPU5952rB)((val)))), ("FetchComptimeValue global=0 got non-Interp src")));
            InterpReg_s reg = ((asInterpPU5952PcrS9925)((val), ("We just checked if it is Interp")));
            u8 *start = ((getComptimePointerPS4053PS9925rPu8)((this), (&(reg))));
            return ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (typ), (start)));
        }

    }

    else if (((instr)->kind) == (INSTR_INT_ADD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM AddInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM AddInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntAddPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("iadd")))));
    }

    else if (((instr)->kind) == (INSTR_INT_SUB)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM SubInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM SubInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntSubPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("isub")))));
    }

    else if (((instr)->kind) == (INSTR_INT_MUL)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM MulInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM MulInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntMulPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("imul")))));
    }

    else if (((instr)->kind) == (INSTR_INT_DIV)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM DivInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM DivInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntDivPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("idiv")))));
    }

    else if (((instr)->kind) == (INSTR_INT_MOD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ModInt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ModInt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        return ((buildIntModPS6343S8925S8925BS7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), (signed_), ((newSubStrOfStrLitPcrS7720)(("imod")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_ADD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM AddFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM AddFloat")));
        return ((buildFloatAddPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fadd")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_SUB)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM SubFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM SubFloat")));
        return ((buildFloatSubPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fsub")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_MUL)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM MulFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM MulFloat")));
        return ((buildFloatMulPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fmul")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_DIV)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM DivFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM DivFloat")));
        return ((buildFloatDivPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fdiv")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_MOD)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ModFloat")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ModFloat")));
        return ((buildFloatModPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fmod")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_NEQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpNeq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpNeq")));
        return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntNE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpne")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_EQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpEq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpEq")));
        return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntEQ), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpeq")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_LT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpLt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpLt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSLT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpslt")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntULT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpult")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_LTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpLte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpLte")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSLE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsle")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntULE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpule")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_GT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpGt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpGt")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsgt")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntUGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpugt")))));
    }

    else if (((instr)->kind) == (INSTR_INT_CMP_GTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM ICmpGte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM ICmpGte")));
        bool signed_ = ((isSignedIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)))->typ)));
        if (signed_)
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntSGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpsge")))));
        else
            return ((buildIntComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMIntUGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("icmpuge")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_NEQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpNeq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpNeq")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUNE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpne")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_EQ)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpEq")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpEq")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUEQ), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpeq")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_LT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpLt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpLt")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealULT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpult")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_LTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpLte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpLte")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealULE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpule")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_GT)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpGt")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpGt")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUGT), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpugt")))));
    }

    else if (((instr)->kind) == (INSTR_FLOAT_CMP_GTE)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM FCmpGte")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM FCmpGte")));
        return ((buildFloatComparePS6343i32S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (LLVMRealUGE), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("fcmpuge")))));
    }

    else if (((instr)->kind) == (INSTR_LOGICAL_NOT)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical Not")));
        return ((buildNotPS6343S8925S7720rS8925)((&((this)->llvmBuilder)), (val), ((newSubStrOfStrLitPcrS7720)(("lnot")))));
    }

    else if ((((instr)->kind) == (INSTR_LOGICAL_OR)) || (((instr)->kind) == (INSTR_BITWISE_OR))) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical Or")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Logical Or")));
        return ((buildOrPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("lor")))));
    }

    else if ((((instr)->kind) == (INSTR_LOGICAL_AND)) || (((instr)->kind) == (INSTR_BITWISE_AND))) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Logical And")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Logical And")));
        return ((buildAndPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("land")))));
    }

    else if (((instr)->kind) == (INSTR_BITWISE_XOR)) {
        LLVMValue_s lhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Bitwise Xor")));
        LLVMValue_s rhsVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Bitwise Xor")));
        return ((buildXorPS6343S8925S8925S7720rS8925)((&((this)->llvmBuilder)), (lhsVal), (rhsVal), ((newSubStrOfStrLitPcrS7720)(("bxor")))));
    }

    else if (((instr)->kind) == (INSTR_CALL)) {
        LLVMValue_s calledFunc = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Call")));
        ((assertBPcrN)((!(((LLVM_isNullS1407rB))(((calledFunc).ref)))), ("Call tried to call invalid LLVMValue")));
        LLVMValueList_s args = ((LLVMValueList_s){0});
        ((initBlankPS8201uszrN)((&(args)), (((instr)->args).length)));
        for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            RegIndex_s *_a = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
            IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), (*(_a))));
            RegValue_u *argReg = ((atPS5884uszrPU5952)((regs), ((_a)->i)));
            ((*((atPS8201uszrPS8925)((&(args)), (i)))) = ((asLLVMPU5952PcrS8925)((argReg), ("LLVM Call Arg"))));
        }

        IRReg_s *base = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *bt = ((base)->typ);
        if ((isPointerPU5175rB)((bt)))
            ((bt) = ((getUnderlyingTypePU5175BrPU5175)((bt), (true))));
        ((assertBPcrN)(((isFunctionPU5175rB)((bt))), ("Call tried to call non-function base")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s retType = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        LLVMType_s fnType = ((generateLLVMFunctionTypePS4053PU5175rS0706)((this), (bt)));
        return ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (calledFunc), (fnType), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("call")))));
    }

    else if (((instr)->kind) == (INSTR_COND_BR)) {
        LLVMValue_s cond = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM CondBr")));
        ((buildCondBrPS6343S8925S7469S7469rS8925)((&((this)->llvmBuilder)), (cond), (*((atPS0409uszrPS7469)((blocks), (((instr)->dst).i)))), (*((atPS0409uszrPS7469)((blocks), (((instr)->op1).i))))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_UNREACHABLE)) {
        ((buildUnreachablePS6343rN)((&((this)->llvmBuilder))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_UNTERMINATED)) {
        (((fprintf))((stderr_), ("%s %s: UNTERMINATED BLOCK FOUND!!!\n"), (((toStringPS8951rS0540)((&((instr)->span)))).buffer), (FATAL_STR)));
        ((unreachablePcrN)(("LLVM: Received INSTR_UNTERMINATED, Control Flow Analysis should\'ve caught this!")));
    }

    else if (((instr)->kind) == (INSTR_BR)) {
        ((buildBrPS6343S7469rS8925)((&((this)->llvmBuilder)), (*((atPS0409uszrPS7469)((blocks), (((instr)->dst).i))))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_RETURN_EXPR)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM RetExpr")));
        ((buildReturnPS6343S8925rN)((&((this)->llvmBuilder)), (val)));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_RETURN_VOID)) {
        ((buildReturnVoidPS6343rN)((&((this)->llvmBuilder))));
        return ((LLVMValue_s){0});
    }

    else if (((instr)->kind) == (INSTR_LOAD_I8)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U8)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I16)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U16)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I32)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U32)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_I64)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (true)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_U64)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_F32)) {
        LLVMType_s t = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        return ((constFloatPS0706f64rS8925)((&(t)), ((f64)((*((f32 *)((&(((instr)->src).i)))))))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_F64)) {
        LLVMType_s t = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
        return ((constFloatPS0706f64rS8925)((&(t)), (*((f64 *)((&(((instr)->src).i)))))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_BOOL)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
        return ((constIntPS0706uszBrS8925)((&(t)), (((instr)->src).i), (false)));
    }

    else if (((instr)->kind) == (INSTR_LOAD_NULL)) {
        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        LLVMType_s pt = ((intoPointerTypePS0706rS0706)((&(t))));
        return ((constZeroPS0706rS8925)((&(pt))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_BLANK)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_ARRAY)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        ((assertBPcrN)(((isArrayPU5175rB)(((reg)->typ))), ("LLVM Expected Array in INSTR_CREATE_ARRAY")));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_STRUCT)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_CREATE_UNION)) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((constZeroPS0706rS8925)((&(typ))));
    }

    else if (((instr)->kind) == (INSTR_INSERT_VALUE)) {
        LLVMValue_s dstVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM InsertValue")));
        usize index = (((instr)->src).i);
        LLVMValue_s elemVal = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM InsertValue")));
        LLVMValue_s newVal = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (dstVal), (elemVal), ((u32)((index))), ("arr_elem")));
        return (newVal);
    }

    else if (((instr)->kind) == (INSTR_PTR_TO_INT)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM PtrToInt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        return ((buildPtrToIntPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("p2i")))));
    }

    else if (((instr)->kind) == (INSTR_INT_TO_PTR)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntToPtr")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
        LLVMType_s ptr = ((intoPointerTypePS0706rS0706)((&(typ))));
        return ((buildIntToPtrPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (ptr), ((newSubStrOfStrLitPcrS7720)(("i2p")))));
    }

    else if ((((instr)->kind) == (INSTR_INT_TO_F32)) || (((instr)->kind) == (INSTR_INT_TO_F64))) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntToF32 / IntToF64")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        bool signed_ = ((isSignedIntegerPU5175rB)(((reg)->typ)));
        LLVMType_s typ = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        if (((instr)->kind) == (INSTR_INT_TO_F64))
            ((typ) = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext)))));
        return ((buildIntToFloatPS6343S8925S0706BS7720rS8925)((&((this)->llvmBuilder)), (val), (typ), (signed_), ((newSubStrOfStrLitPcrS7720)(("i2f")))));
    }

    else if ((((instr)->kind) == (INSTR_F32_TO_INT)) || (((instr)->kind) == (INSTR_F64_TO_INT))) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F32ToInt / F64ToInt")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->dst)));
        bool signed_ = ((isSignedIntegerPU5175rB)(((reg)->typ)));
        LLVMType_s typ = ((generateLLVMTypePS4053PU5175rS0706)((this), ((reg)->typ)));
        return ((buildFloatToIntPS6343S8925S0706BS7720rS8925)((&((this)->llvmBuilder)), (val), (typ), (signed_), ((newSubStrOfStrLitPcrS7720)(("f2i")))));
    }

    else if (((instr)->kind) == (INSTR_F32_TO_F64)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F32ToF64")));
        LLVMType_s typ = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
        return ((buildFloatExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("f32tof64")))));
    }

    else if (((instr)->kind) == (INSTR_F64_TO_F32)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM F64ToF32")));
        LLVMType_s typ = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
        return ((buildFloatTruncatePS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("f64tof32")))));
    }

    else if (((instr)->kind) == (INSTR_INT_SIGN_EXTEND)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntSignExt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntSignExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("sext")))));
    }

    else if (((instr)->kind) == (INSTR_INT_ZERO_EXTEND)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntZeroExt")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntZeroExtendPS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("zext")))));
    }

    else if (((instr)->kind) == (INSTR_INT_TRUNCATE)) {
        LLVMValue_s val = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM IntTrunc")));
        LLVMType_s typ = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)((((instr)->op1).i)))));
        return ((buildIntTruncatePS6343S8925S0706S7720rS8925)((&((this)->llvmBuilder)), (val), (typ), ((newSubStrOfStrLitPcrS7720)(("trunc")))));
    }

    else if (((instr)->kind) == (INSTR_LOAD_STRING)) {
        return ((buildGlobalStringPtrPS6343PcS7720rS8925)((&((this)->llvmBuilder)), ((char *)((((instr)->src).i))), ((newSubStrOfStrLitPcrS7720)(("str")))));
    }

    else if (((instr)->kind) == (INSTR_GET_ELEMENT_PTR)) {
        LLVMValueList_s indices = ((LLVMValueList_s){0});
        ((initBlankPS8201uszrN)((&(indices)), (((instr)->args).length)));
        for (usize i = ((usize)(0llu)); ((i) < (((instr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            RegIndex_s *_a = ((atPS9911uszrPS6939)((&((instr)->args)), (i)));
            IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), (*(_a))));
            RegValue_u *argReg = ((atPS5884uszrPU5952)((regs), ((_a)->i)));
            ((*((atPS8201uszrPS8925)((&(indices)), (i)))) = ((asLLVMPU5952PcrS8925)((argReg), ("LLVM GEP Index"))));
        }

        LLVMValue_s aggr = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM GetElementPtr")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *ptr = ((reg)->typ);
        Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((ptr), (false)));
        return ((buildGEPPS6343S0706S8925S8201S7720rS8925)((&((this)->llvmBuilder)), ((generateLLVMTypePS4053PU5175rS0706)((this), (underlying))), (aggr), (indices),
                                                           ((newSubStrOfStrLitPcrS7720)(("gep")))));
    }

    else if (((instr)->kind) == (INSTR_GET_FIELD_PTR)) {
        LLVMValue_s aggr = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM GetFieldPtr")));
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((irFunc), ((instr)->src)));
        Type_u *ptr = ((reg)->typ);
        ((assertBPcrN)(((isPointerPU5175rB)((ptr))), ("LLVM GetFieldPtr wants ptr reg")));
        LLVMType_s aggrType = ((getTypePS8925rS0706)((&(aggr))));
        ((assertBPcrN)(((isPointerPS0706rB)((&(aggrType)))), ("Expected Pointer to Struct in GetFieldPtr")));
        Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((ptr), (false)));
        ((assertBPcrN)(((((isVariadicTypePU5175rB)((underlying))) || ((isStructPU5175rB)((underlying)))) || ((isTuplePU5175rB)((underlying)))), ("LLVM GetFieldPtr wants ptr to struct")));
        return ((buildStructGEPPS6343S0706S8925uszS7720rS8925)((&((this)->llvmBuilder)), ((generateLLVMTypePS4053PU5175rS0706)((this), (underlying))), (aggr), (((instr)->op1).i),
                                                               ((newSubStrOfStrLitPcrS7720)(("field_ptr")))));
    }

    else if (((instr)->kind) == (INSTR_MEMCPY)) {
        LLVMValue_s src = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->src).i))), ("LLVM Memcpy src")));
        LLVMValue_s dst = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->dst).i))), ("LLVM Memcpy dst")));
        LLVMValue_s size = ((asLLVMPU5952PcrS8925)(((atPS5884uszrPU5952)((regs), (((instr)->op1).i))), ("LLVM Memcpy op1")));
        ((buildMemcpyPS6343S8925u32S8925u32S8925rS8925)((&((this)->llvmBuilder)), (dst), ((u32)(1)), (src), ((u32)(1)), (size)));
        return (dst);
    }

    else if (((instr)->kind) == (INSTR_EMIT_ASSEMBLY)) {
        RegValue_u *reg = ((atPS5884uszrPU5952)((regs), (((instr)->src).i)));
        InterpReg_s tmp_27479 = ((asInterpPU5952PcrS9925)((reg), ("LLVM EmitAsm src")));

        u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (&tmp_27479)));
        Type_u *fnType = ((Type_u *)((((instr)->op1).i)));
        ASMContext_s *context = ((ASMContext_s *)((start)));
        LLVMType_s retType = ((generateTypeFromASMPS4053PS6859rS0706)((this), (context)));
        LLVMValueList_s args = ((collectValuesFromASMPS4053PS6859rS8201)((this), (context)));
        LLVMTypeList_s params = ((LLVMTypeList_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ((pushPS4318S0706rN)((&(params)), ((getTypePS8925rS0706)((&((((args).elements))[(i)]))))));
        }

        LLVMType_s asmFn = ((intoFunctionTypePS0706S4318BrS0706)((&(retType)), (params), (false)));
        LLVMValue_s asmCall = ((getInlineAsmPS0706PS6859rS8925)((&(asmFn)), (context)));
        return ((buildCallPS6343S8925S0706S8201S0706S7720rS8925)((&((this)->llvmBuilder)), (asmCall), (asmFn), (args), (retType), ((newSubStrOfStrLitPcrS7720)(("asm")))));
    }

    else {
        (((printf))(("LLVM %llu\n"), ((instr)->kind)));
        ((todo_with_msgPcrN)(("unknown llvm kind")));
    }
}
LLVMValueList_s collectValuesFromASMPS4053PS6859rS8201(LLVMCodegen_s *this, ASMContext_s *context) {
    LLVMValueList_s list = ((LLVMValueList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((context)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8201S8925rN)((&(list)), ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), (i)))))));
    }

    return (list);
}
LLVMType_s generateTypeFromASMPS4053PS6859rS0706(LLVMCodegen_s *this, ASMContext_s *context) {
    if ((((context)->out).length) == ((usize)(0llu)))
        return ((createVoidTypePS0773rS0706)((&((this)->llvmContext))));
    if ((((context)->out).length) == ((usize)(1llu))) {
        LLVMValue_s arg = ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), ((usize)(0llu))))));
        return ((getTypePS8925rS0706)((&(arg))));
    }

    LLVMType_s *fields = (((calloc))((((context)->out).length), (sizeof(LLVMType_s))));
    ((assertBrN)(((fields) != (NULL))));
    for (usize i = ((usize)(0llu)); ((i) < (((context)->out).length)); ((i) = ((i) + ((usize)(1llu))))) {
        LLVMValue_s arg = ((newLLVMValueFromRefS1407rS8925)(((getArgPS6859uszrS1407)((context), (i)))));
        ((((fields))[(i)]) = ((getTypePS8925rS0706)((&(arg)))));
    }

    LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)((((context)->out).length))), (false)));
    (((free))((fields)));
    return (t);
}
u8 *getComptimePointerPS4053PS9925rPu8(LLVMCodegen_s *this, InterpReg_s *reg) {
    u8 *start = ((getRegStackPointerPS3154PS9925rPu8)(((this)->interp), (reg)));
    ((assertBPcrN)(((start) >= (((this)->interp)->regStackStart)), ("Expected comptime value to be allocated on Interp Reg Stack")));
    ((assertBPcrN)(((start) < ((u8 *)((unsigned char *)(((this)->interp)->regStackStart) + (REG_STACK_SIZE)))), ("Expected comptime value to be allocated on Interp Reg Stack")));
    return (start);
}
LLVMValue_s generateLLVMValueFromComptimePtrPS4053PU5175S9925rS8925(LLVMCodegen_s *this, Type_u *typ, InterpReg_s reg) {
    ((assertBPcrN)(((isPointerPU5175rB)((typ))), ("generateLLVMValueFromComptimePtr expected Pointer")));
    ((assertBPcrN)((((reg).size) == ((usize)(8llu))), ("generateLLVMValueFromComptimePtr expected Pointer sized register")));
    Type_u *underlying = ((getUnderlyingTypePU5175BrPU5175)((typ), (false)));
    u8 *start = ((getComptimePointerPS4053PS9925rPu8)((this), (&(reg))));
    LLVMValue_s val = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (underlying), (start)));
    LLVMType_s _underlying = ((generateLLVMTypePS4053PU5175rS0706)((this), ((getUnderlyingTypePU5175BrPU5175)((typ), (false)))));
    LLVMValue_s alloc = ((buildAllocaPS6343S0706S7720rS8925)((&((this)->llvmBuilder)), (_underlying), ((newSubStrOfStrLitPcrS7720)(("comptimeToLLVM")))));
    ((buildStorePS6343S8925S8925rS8925)((&((this)->llvmBuilder)), (alloc), (val)));
    return (alloc);
}
LLVMValue_s generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925(LLVMCodegen_s *this, Type_u *typ, u8 *start) {
    ((assertBPcrN)(((start) != (NULL)), ("generateLLVMValueFromComptimeValue got nullptr")));
    usize size = ((getSizeInBytesPU5175rusz)((typ)));
    bool succ_3543_ = true;
    bool succ_3573_ = true;
    bool succ_3594_ = true;
    bool succ_3610_ = true;
    bool succ_3623_ = true;
    bool succ_3633_ = true;
    bool succ_3630_ = true;
    bool succ_3628_ = true;

    Type_u *tmp_5549_ = (typ);
    {
        succ_3543_ &= (tmp_5549_->tag == 3);
        PrimType_u *prim = &tmp_5549_->payload.variant3._0;
        succ_3543_ &= true;
        if (succ_3543_) {
            {
                if ((isIntegerPU5175rB)((typ))) {
                    if ((size) == ((usize)(1llu))) {
                        u8 val = (*((u8 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(2llu))) {
                        u16 val = (*((u16 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(16ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(4llu))) {
                        u32 val = (*((u32 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(32ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else if ((size) == ((usize)(8llu))) {
                        u64 val = (*((u64 *)((start))));
                        LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));
                        return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                    }

                    else {
                        ((unreachablePcrN)(("unexpected int size")));
                    }

                }

                else if ((isFloatPU5175rB)((typ))) {
                    if ((size) == ((usize)(4llu))) {
                        f32 val = (*((f32 *)((start))));
                        LLVMType_s t = ((createFloatTypePS0773rS0706)((&((this)->llvmContext))));
                        return ((constFloatPS0706f64rS8925)((&(t)), ((f64)((val)))));
                    }

                    else if ((size) == ((usize)(8llu))) {
                        f64 val = (*((f64 *)((start))));
                        LLVMType_s t = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext))));
                        return ((constFloatPS0706f64rS8925)((&(t)), (val)));
                    }

                    else {
                        ((unreachablePcrN)(("unexpected float size")));
                    }

                }

                else if ((isBooleanPU5175rB)((typ))) {
                    u8 val = (*((u8 *)((start))));
                    ((assertBPcrN)((((val) == ((u8)(0))) || ((val) == ((u8)(1)))), ("comptime bool is not 0 or 1")));
                    LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
                    return ((constIntPS0706uszBrS8925)((&(t)), ((usize)((val))), (false)));
                }

                else if ((isNonePU5175rB)((typ))) {
                    LLVMType_s t = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll))));
                    return ((constIntPS0706uszBrS8925)((&(t)), ((usize)(1llu)), (false)));
                }

                else {
                    ((todo_with_msgPcrN)(("prim")));
                }
            }
            goto after_5549;
        }
    }
    {
        succ_3573_ &= (tmp_5549_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_5549_->payload.variant7._0;
        succ_3573_ &= true;
        if (succ_3573_) {
            {
                LLVMType_s lType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                ((assertBPcrN)(((isStructPS0706rB)((&(lType)))), ("Expected LLVMType to be struct for comptime struct")));
                LLVMValue_s strukt = ((constZeroPS0706rS8925)((&(lType))));
                usize offset = ((usize)(0llu));
                usize _size = ((usize)(0llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *tDecl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    Type_u *fType = ((getTypePU9661rPU5175)((&((tDecl)->typeState))));
                    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((*decl), (i), (&(offset)), (&(_size)), (false)));
                    LLVMValue_s elemVal = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (fType), ((u8 *)((unsigned char *)(start) + (offset)))));
                    ((strukt) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (strukt), (elemVal), ((u32)((i))), ("comptime_struct_field"))));
                }

                return (strukt);
            }
            goto after_5549;
        }
    }
    {
        succ_3594_ &= (tmp_5549_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_5549_->payload.variant8._0;
        succ_3594_ &= true;
        usize *variant = &tmp_5549_->payload.variant8._1;
        succ_3594_ &= true;
        if (succ_3594_) {
            {
                LLVMType_s lType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                ((assertBPcrN)(((isStructPS0706rB)((&(lType)))), ("Expected LLVMType to be struct for comptime union")));
                LLVMValue_s union_ = ((constZeroPS0706rS8925)((&(lType))));
                if ((size) == ((usize)(0llu))) {
                    return (union_);
                }

                PrimType_u smol = (((PrimType_u){.tag = 0}));
                if ((((*decl)->variants).length) >= ((usize)(256llu)))
                    ((smol) = (((PrimType_u){.tag = 1})));
                Type_u *byte = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
                {
                    LLVMValue_s tag = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (byte), (start)));
                    ((union_) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (union_), (tag), ((u32)(0)), ("comptime_union_tag"))));
                }

                {
                    usize dataSize = ((size) - ((usize)(1llu)));
                    u8 *offset = ((u8 *)((unsigned char *)(start) + ((usize)(1llu))));
                    if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                        ((dataSize) = ((size) - ((usize)(2llu))));
                        ((offset) = ((u8 *)((unsigned char *)(start) + ((usize)(2llu)))));
                    }

                    Type_u *byt = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})));
                    LLVMValue_s data =
                        ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (byt), ._1 = (dataSize)}}}))),
                                                                                   (offset)));
                    ((union_) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (union_), (data), ((u32)(1)), ("comptime_union_tag"))));
                }

                return (union_);
            }
            goto after_5549;
        }
    }
    {
        succ_3610_ &= (tmp_5549_->tag == 5);
        Type_u **elemType = &tmp_5549_->payload.variant5._0;
        succ_3610_ &= true;
        usize *size = &tmp_5549_->payload.variant5._1;
        succ_3610_ &= true;
        if (succ_3610_) {
            {
                LLVMType_s llvmType = ((generateLLVMTypePS4053PU5175rS0706)((this), (typ)));
                usize elemSize = ((getSizeInBytesPU5175rusz)((*elemType)));
                LLVMValue_s array = ((constZeroPS0706rS8925)((&(llvmType))));
                for (usize i = ((usize)(0llu)); ((i) < (*size)); ((i) = ((i) + ((usize)(1llu))))) {
                    usize offset = ((elemSize) * (i));
                    LLVMValue_s elem = ((generateLLVMValueFromComptimeValuePS4053PU5175Pu8rS8925)((this), (*elemType), ((u8 *)((unsigned char *)(start) + (offset)))));
                    ((array) = ((buildInsertValuePS6343S8925S8925u32PcrS8925)((&((this)->llvmBuilder)), (array), (elem), ((u32)((i))), ("comptime_array_elem"))));
                }

                return (array);
            }
            goto after_5549;
        }
    }
    {
        succ_3623_ &= (tmp_5549_->tag == 6);
        succ_3623_ &= true;
        succ_3623_ &= true;
        succ_3623_ &= true;
        if (succ_3623_) {
            {
                usize id = (*((usize *)((start))));
                return (((atPS2612uszrPS7132)((&(((this)->irGen)->functions)), (id)))->llvmFunc);
            }
            goto after_5549;
        }
    }
    {
        succ_3633_ &= (tmp_5549_->tag == 4);
        succ_3630_ &= (tmp_5549_->payload.variant4._0->tag == 3);
        succ_3628_ &= (tmp_5549_->payload.variant4._0->payload.variant3._0.tag == 12);
        succ_3630_ &= succ_3628_;
        succ_3633_ &= succ_3630_;
        if (succ_3633_) {
            {
                return ((buildGlobalStringPtrPS6343PcS7720rS8925)((&((this)->llvmBuilder)), ((char *)((*((usize *)((start)))))), ((newSubStrOfStrLitPcrS7720)(("comptime_str")))));
            }
            goto after_5549;
        }
    }
    {
        Type_u **typ = &tmp_5549_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((*typ))).buffer)));
                ((todo_with_msgPcrN)(("generateLLVMValueFromComptime")));
            }
            goto after_5549;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5549:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling in generateLLVMValueFromComptime")));
}
LLVMType_s generateLLVMFunctionTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *typ) {
    TypeList_s fnParams = ((TypeList_s){0});
    Type_u *retType = (NULL);
    bool isVarArg = (false);
    bool succ_3645_ = true;

    Type_u *tmp_5560_ = (typ);
    {
        succ_3645_ &= (tmp_5560_->tag == 6);
        TypeList_s *_params = &tmp_5560_->payload.variant6._0;
        succ_3645_ &= true;
        Type_u **_ret = &tmp_5560_->payload.variant6._1;
        succ_3645_ &= true;
        FuncAttr_s *attr = &tmp_5560_->payload.variant6._2;
        succ_3645_ &= true;
        if (succ_3645_) {
            {
                ((fnParams) = (*_params));
                ((retType) = (*_ret));
                ((isVarArg) = ((*attr).isVariadic));
            }
            goto after_5560;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("generateLLVMFunctionType called on non function")));
            }
            goto after_5560;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5560:
    (void)0; // error: label at end of compound statement is a C23 extension
    LLVMTypeList_s params = ((LLVMTypeList_s){0});
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        ((retType) = ((intoPointerPU5175rPU5175)((retType))));
        ((pushPS4318S0706rN)((&(params)), ((prepareParameterPS4053PU5175rS0706)((this), (retType)))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = (*((atPS0643uszrPPU5175)((&(fnParams)), (i))));
        ((pushPS4318S0706rN)((&(params)), ((prepareParameterPS4053PU5175rS0706)((this), (t)))));
    }

    LLVMType_s llvmType = ((prepareReturnTypePS4053PU5175rS0706)((this), (retType)));
    LLVMType_s llvmFuncType = ((intoFunctionTypePS0706S4318BrS0706)((&(llvmType)), (params), (isVarArg)));
    return (llvmFuncType);
}
LLVMType_s generateLLVMTypePS4053PU5175rS0706(LLVMCodegen_s *this, Type_u *type) {
    LLVMType_s typ = ((LLVMType_s){0});
    bool succ_3662_ = true;
    bool succ_3677_ = true;
    bool succ_3683_ = true;
    bool succ_3688_ = true;
    bool succ_3692_ = true;
    bool succ_3705_ = true;
    bool succ_3717_ = true;
    bool succ_3723_ = true;

    Type_u *tmp_5655_ = (type);
    {
        succ_3662_ &= (tmp_5655_->tag == 3);
        succ_3662_ &= true;
        if (succ_3662_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(((getSizeInBitsPU5175rusz)((type))))))));
                }

                else if ((isCharPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(8ll)))));
                }

                else if ((isBooleanPU5175rB)((type))) {
                    ((typ) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(1ll)))));
                }

                else if ((isFloatPU5175rB)((type))) {
                    bool succ_3667_ = true;
                    bool succ_3665_ = true;
                    bool succ_3672_ = true;
                    bool succ_3670_ = true;

                    Type_u *tmp_5587_ = (type);
                    {
                        succ_3667_ &= (tmp_5587_->tag == 3);
                        succ_3665_ &= (tmp_5587_->payload.variant3._0.tag == 13);
                        succ_3667_ &= succ_3665_;
                        if (succ_3667_) {
                            {
                                ((typ) = ((createFloatTypePS0773rS0706)((&((this)->llvmContext)))));
                            }
                            goto after_5587;
                        }
                    }
                    {
                        succ_3672_ &= (tmp_5587_->tag == 3);
                        succ_3670_ &= (tmp_5587_->payload.variant3._0.tag == 14);
                        succ_3672_ &= succ_3670_;
                        if (succ_3672_) {
                            {
                                ((typ) = ((createDoubleTypePS0773rS0706)((&((this)->llvmContext)))));
                            }
                            goto after_5587;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablePcrN)(("Expected TYPE_F32 or TYPE_F64")));
                            }
                            goto after_5587;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_5587:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }

                else if ((isNonePU5175rB)((type))) {
                    ((typ) = ((createVoidTypePS0773rS0706)((&((this)->llvmContext)))));
                }

                else if ((isAnyPU5175rB)((type))) {
                    LLVMType_s tmp_28378 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                    ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28378))));
                }

                else {
                    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((type))).buffer)));
                    ((todo_with_msgPcrN)(("generate primitive type")));
                }
            }
            goto after_5655;
        }
    }
    {
        succ_3677_ &= (tmp_5655_->tag == 4);
        succ_3677_ &= true;
        if (succ_3677_) {
            {
                LLVMType_s tmp_28404 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28404))));
            }
            goto after_5655;
        }
    }
    {
        succ_3683_ &= (tmp_5655_->tag == 6);
        succ_3683_ &= true;
        succ_3683_ &= true;
        succ_3683_ &= true;
        if (succ_3683_) {
            {
                LLVMType_s tmp_28416 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((typ) = ((intoPointerTypePS0706rS0706)((&tmp_28416))));
            }
            goto after_5655;
        }
    }
    {
        succ_3688_ &= (tmp_5655_->tag == 5);
        Type_u **under = &tmp_5655_->payload.variant5._0;
        succ_3688_ &= true;
        usize *size = &tmp_5655_->payload.variant5._1;
        succ_3688_ &= true;
        if (succ_3688_) {
            {
                LLVMType_s tmp_28425 = ((generateLLVMTypePS4053PU5175rS0706)((this), (*under)));

                ((typ) = ((intoArrayTypePS0706u32rS0706)((&tmp_28425), ((u32)((*size))))));
            }
            goto after_5655;
        }
    }
    {
        succ_3692_ &= (tmp_5655_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_5655_->payload.variant7._0;
        succ_3692_ &= true;
        if (succ_3692_) {
            {
                LLVMType_s *fields = (((malloc))(((((*decl)->context).fieldLength) * (sizeof(LLVMType_s)))));
                ((assertBPcrN)(((fields) != (NULL)), ("Could not allocate memory in LLVMCodegen.generateLLVMType")));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *tDecl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((((fields))[(i)]) = ((generateLLVMTypePS4053PU5175rS0706)((this), ((getTypePU9661rPU5175)((&((tDecl)->typeState)))))));
                }

                LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)((((*decl)->context).fieldLength))), (false)));
                (((free))((fields)));
                ((typ) = (t));
            }
            goto after_5655;
        }
    }
    {
        succ_3705_ &= (tmp_5655_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_5655_->payload.variant8._0;
        succ_3705_ &= true;
        succ_3705_ &= true;
        if (succ_3705_) {
            {
                u32 size = ((u32)(((getSizeInBytesPU5175rusz)((type)))));
                if ((size) == ((u32)(0))) {
                    ((assertBPcrN)(((((*decl)->variants).length) == ((usize)(0llu))), ("LLVM: Union has size 0, but contains variants")));
                    ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (NULL), ((u32)(0)), (false))));
                }

                else {
                    PrimType_u smol = (((PrimType_u){.tag = 0}));
                    u32 offset = ((u32)(1));
                    if ((((*decl)->variants).length) >= ((usize)(256llu))) {
                        ((smol) = (((PrimType_u){.tag = 1})));
                        ((offset) = ((u32)(2)));
                    }

                    LLVMType_s tag = ((generateLLVMTypePS4053PU5175rS0706)((this), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})))));
                    LLVMType_s data = ((intoArrayTypePS0706u32rS0706)((&(tag)), ((size) - (offset))));
                    array_27594 fields = ((array_27594){(tag), (data)});
                    ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (&(((fields).arr)[((usize)(0llu))])), ((u32)(2)), (false))));
                }
            }
            goto after_5655;
        }
    }
    {
        succ_3717_ &= (tmp_5655_->tag == 2);
        succ_3717_ &= true;
        if (succ_3717_) {
            {
                LLVMType_s *fields = (((calloc))(((usize)(2llu)), (sizeof(LLVMType_s))));
                ((assertBrN)(((fields) != (NULL))));
                LLVMType_s tmp_28605 = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll))));

                ((((fields))[((usize)(0llu))]) = ((intoPointerTypePS0706rS0706)((&tmp_28605))));
                ((((fields))[((usize)(1llu))]) = ((createIntegerTypePS0773i64rS0706)((&((this)->llvmContext)), ((i64)(64ll)))));
                ((typ) = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)(2)), (false))));
            }
            goto after_5655;
        }
    }
    {
        succ_3723_ &= (tmp_5655_->tag == 10);
        TypeList_s *elems = &tmp_5655_->payload.variant10._0;
        succ_3723_ &= true;
        if (succ_3723_) {
            {
                LLVMType_s *fields = (((malloc))((((*elems).length) * (sizeof(LLVMType_s)))));
                ((assertBPcrN)(((fields) != (NULL)), ("Could not allocate memory in LLVMCodegen.generateLLVMType")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((((fields))[(i)]) = ((generateLLVMTypePS4053PU5175rS0706)((this), ((((*elems).elements))[(i)]))));
                }

                LLVMType_s t = ((createStructTypePS0773PS0706u32BrS0706)((&((this)->llvmContext)), (fields), ((u32)(((*elems).length))), (false)));
                (((free))((fields)));
                ((typ) = (t));
            }
            goto after_5655;
        }
    }
    {
        if (true) {
            {
                ((todo_with_msgPcrN)(("generate llvm type")));
            }
            goto after_5655;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_5655:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (typ);
}
LLVMCodegen_s newLLVMCodegenS7720PS9562PS3154rS4053(SubStr_s name, IRGen_s *irGen, IRInterp_s *interp) {
    LLVMContext_s llvmContext = ((newLLVMContextrS0773)());
    LLVMModule_s llvmModule = ((createModuleWithNamePS0773S7720rS1718)((&(llvmContext)), (name)));
    LLVMBuilder_s llvmBuilder = ((createBuilderPS0773rS6343)((&(llvmContext))));
    LLVMDIBuilder_s llvmDIBuilder = ((createDIBuilderS1718rS1476)((llvmModule)));
    ((initializeTargetsPS0773rN)((&(llvmContext))));
    LLVMTarget_s target = ((createTargetPS0773PcrS4231)((&(llvmContext)), ("x86-64")));
    char *triple = ((createTargetTriplePS0773PcrPc)((&(llvmContext)), ("x86-64")));
    LLVMTargetMachineOptions_s options = ((createTargetMachineOptionsrS6312)());
    ((setCPUS6312PcrN)((options), ("x86-64")));
    ((setCodeGenOptLevelS6312U5589rN)((options), (((LLVM_CodeGenOptLevel_u){.tag = 0}))));
    ((setRelocModeS6312U2415rN)((options), (((LLVM_RelocMode_u){.tag = 0}))));
    ((setCodeModelS6312U0545rN)((options), (((LLVM_CodeModel_u){.tag = 0}))));
    LLVMTargetMachine_s targetMachine = ((createTargetMachineWithOptionsS4231PcS6312rS7964)((target), (triple), (options)));
    ((disposeTargetMachineOptionsS6312rN)((options)));
    ((setTriplePS1718PcrN)((&(llvmModule)), (triple)));
    LLVMTargetData_s l = ((getTargetDataPS7964rS8369)((&(targetMachine))));
    ((setDataLayoutPS1718S7896rN)((&(llvmModule)), ((getDataLayoutPS8369rS7896)((&(l))))));
    {
        LLVMType_s u32 = ((createIntegerTypePS0773i64rS0706)((&(llvmContext)), ((i64)(32ll))));
        ((addModuleFlagS1718i32S7720S8925rN)((llvmModule), (LLVMModuleFlagBehaviorError), ((newSubStrOfStrLitPcrS7720)(("CodeView"))),
                                             ((constIntPS0706uszBrS8925)((&(u32)), ((usize)(1llu)), (false)))));
        ((addModuleFlagS1718i32S7720S8925rN)((llvmModule), (LLVMModuleFlagBehaviorWarning), ((newSubStrOfStrLitPcrS7720)(("Debug Info Version"))),
                                             ((constIntPS0706uszBrS8925)((&(u32)), ((usize)(3llu)), (false)))));
    }

    return ((LLVMCodegen_s){.llvmContext = (llvmContext),
                            .llvmModule = (llvmModule),
                            .llvmBuilder = (llvmBuilder),
                            .llvmTargetMachine = (targetMachine),
                            .llvmDIBuilder = (llvmDIBuilder),
                            .irGen = (irGen),
                            .interp = (interp),
                            .global = ((RegValueList_s){0})});
}
bool equalsPS6939PS6939rB(RegIndex_s *this, RegIndex_s *other) { return (((this)->i) == ((other)->i)); }
bool equalsPS1534PS1534rB(IRReg_s *this, IRReg_s *other) { ((unreachablePcrN)(("IRReg.equals is not implemented yet"))); }
bool equalsPS7680PS7680rB(IRInstr_s *this, IRInstr_s *other) { ((unreachablePcrN)(("IRInstr.equals is not implemented yet"))); }
bool isTerminatorPS7680rB(IRInstr_s *this) {
    return ((((((((this)->kind) == (INSTR_RETURN_EXPR)) || (((this)->kind) == (INSTR_RETURN_VOID))) || (((this)->kind) == (INSTR_COND_BR))) || (((this)->kind) == (INSTR_BR))) ||
             (((this)->kind) == (INSTR_UNREACHABLE))) ||
            (((this)->kind) == (INSTR_UNTERMINATED)));
}
none dumpPS7680rN(IRInstr_s *this) {
    if ((!(*((flags).emitBIR))) && ((this)->isComptime))
        (((printf))(("\x1B[92m")));
    if (*((flags).debug)) {
        String_s s = ((toStringPS8951rS0540)((&((this)->span))));
        (((printf))(("%s "), ((s).buffer)));
        ((dropPS0540rN)((&(s))));
    }

    if (((this)->kind) == (INSTR_ALLOCA))
        (((printf))(("r%llu = Alloca %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_GET_PARAM))
        (((printf))(("r%llu = GetParam %llu (%llu bytes)"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_STORE))
        (((printf))(("Store r%llu, r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_GLOBAL_PTR))
        (((printf))(("r%llu = FetchGlobalPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_GLOBAL_VALUE))
        (((printf))(("r%llu = FetchGlobalValue r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_FETCH_COMPTIME_VALUE))
        (((printf))(("r%llu = FetchComptimeValue r%llu, global=%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOAD))
        (((printf))(("r%llu = Load r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_FUNCTION_PTR))
        (((printf))(("r%llu = LoadFunctionPtr %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_MOVE))
        (((printf))(("r%llu = Move r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_CALL)) {
        (((printf))(("r%llu = Call r%llu"), (((this)->dst).i), (((this)->src).i)));
        for (usize i = ((usize)(0llu)); ((i) < (((this)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            (((printf))((", r%llu"), (((atPS9911uszrPS6939)((&((this)->args)), (i)))->i)));
        }

    }

    else if (((this)->kind) == (INSTR_RETURN_EXPR))
        (((printf))(("RetExpr r%llu"), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_RETURN_VOID))
        (((printf))(("RetVoid")));
    else if (((this)->kind) == (INSTR_LOAD_STRING))
        (((printf))(("r%llu = LoadString %p, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOAD_BOOL))
        (((printf))(("r%llu = Load Bool %hhu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I8))
        (((printf))(("r%llu = Load I8 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U8))
        (((printf))(("r%llu = Load U8 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I16))
        (((printf))(("r%llu = Load I16 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U16))
        (((printf))(("r%llu = Load U16 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I32))
        (((printf))(("r%llu = Load I32 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U32))
        (((printf))(("r%llu = Load U32 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_I64))
        (((printf))(("r%llu = Load I64 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_U64))
        (((printf))(("r%llu = Load U64 %llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOAD_NULL))
        (((printf))(("r%llu = Load Null"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_LOAD_F32))
        (((printf))(("r%llu = Load F32 %f"), (((this)->dst).i), ((f64)((*((f32 *)((&(((this)->src).i)))))))));
    else if (((this)->kind) == (INSTR_LOAD_F64))
        (((printf))(("r%llu = Load F64 %f"), (((this)->dst).i), (*((f64 *)((&(((this)->src).i)))))));
    else if (((this)->kind) == (INSTR_LOAD_BLANK))
        (((printf))(("r%llu = Load Blank"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_COND_BR))
        (((printf))(("CondBr r%llu, true=%llu, false=%llu"), (((this)->src).i), (((this)->dst).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BR))
        (((printf))(("Br %llu"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_INT_ADD))
        (((printf))(("r%llu = AddInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_SUB))
        (((printf))(("r%llu = SubInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_MUL))
        (((printf))(("r%llu = MulInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_DIV))
        (((printf))(("r%llu = DivInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_MOD))
        (((printf))(("r%llu = ModInt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_EQ))
        (((printf))(("r%llu = ICmpEq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_NEQ))
        (((printf))(("r%llu = ICmpNeq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_GT))
        (((printf))(("r%llu = ICmpGt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_GTE))
        (((printf))(("r%llu = ICmpGte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_LT))
        (((printf))(("r%llu = ICmpLt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_CMP_LTE))
        (((printf))(("r%llu = ICmpLte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_ADD))
        (((printf))(("r%llu = AddFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_SUB))
        (((printf))(("r%llu = SubFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_MUL))
        (((printf))(("r%llu = MulFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_DIV))
        (((printf))(("r%llu = DivFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_MOD))
        (((printf))(("r%llu = ModFloat r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_EQ))
        (((printf))(("r%llu = FCmpEq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_NEQ))
        (((printf))(("r%llu = FCmpNeq r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_GT))
        (((printf))(("r%llu = FCmpGt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_GTE))
        (((printf))(("r%llu = FCmpGte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_LT))
        (((printf))(("r%llu = FCmpLt r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_FLOAT_CMP_LTE))
        (((printf))(("r%llu = FCmpLte r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_NOT))
        (((printf))(("r%llu = LNot r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_AND))
        (((printf))(("r%llu = LAnd r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_LOGICAL_OR))
        (((printf))(("r%llu = LOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_AND))
        (((printf))(("r%llu = BAnd r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_OR))
        (((printf))(("r%llu = BOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_BITWISE_XOR))
        (((printf))(("r%llu = BXOr r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INSERT_VALUE))
        (((printf))(("r%llu = InsertValue r%llu, %llu, r%llu"), (((this)->dst).i), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_SIGN_EXTEND))
        (((printf))(("r%llu = IntSExt r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_ZERO_EXTEND))
        (((printf))(("r%llu = IntZExt r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_TRUNCATE))
        (((printf))(("r%llu = IntTrunc r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F32))
        (((printf))(("r%llu = IntToF32 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F64))
        (((printf))(("r%llu = IntToF64 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F32_TO_INT))
        (((printf))(("r%llu = F32ToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F64_TO_INT))
        (((printf))(("r%llu = F64ToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_F64))
        (((printf))(("r%llu = IntToF64 r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F32_TO_F64))
        (((printf))(("r%llu = FloatExt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_F64_TO_F32))
        (((printf))(("r%llu = FloatTrunc r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_CREATE_ARRAY))
        (((printf))(("r%llu = CreateArray"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_CREATE_STRUCT))
        (((printf))(("r%llu = CreateStruct"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_CREATE_UNION))
        (((printf))(("r%llu = CreateUnion"), (((this)->dst).i)));
    else if (((this)->kind) == (INSTR_PTR_TO_INT))
        (((printf))(("r%llu = PtrToInt r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_INT_TO_PTR))
        (((printf))(("r%llu = IntToPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_GET_FIELD_PTR))
        (((printf))(("r%llu = GetFieldPtr r%llu, %llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_UNREACHABLE))
        (((printf))(("unreachable")));
    else if (((this)->kind) == (INSTR_UNTERMINATED))
        (((printf))(("<unterminated block>")));
    else if (((this)->kind) == (INSTR_MEMCPY))
        (((printf))(("Memcpy r%llu, r%llu, r%llu"), (((this)->dst).i), (((this)->src).i), (((this)->op1).i)));
    else if (((this)->kind) == (INSTR_EMIT_ASSEMBLY))
        (((printf))(("EmitAsm r%llu (%s)"), (((this)->src).i), (((toStringPU5175rS0540)(((Type_u *)((((this)->op1).i))))).buffer)));
    else if (((this)->kind) == (INSTR_INTO_IR_VALUE))
        (((printf))(("r%llu = IntoIRValue r%llu"), (((this)->dst).i), (((this)->src).i)));
    else if (((this)->kind) == (INSTR_DEBUG_INFO_ALLOCA))
        (((printf))(("<Debug Info Alloca>")));
    else if (((this)->kind) == (INSTR_DEBUG_INFO_PARAM))
        (((printf))(("<Debug Info Param>")));
    else if (((this)->kind) == (INSTR_GET_ELEMENT_PTR)) {
        (((printf))(("r%llu = GetElementPtr r%llu"), (((this)->dst).i), (((this)->src).i)));
        for (usize i = ((usize)(0llu)); ((i) < (((this)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
            (((printf))((", r%llu"), (((atPS9911uszrPS6939)((&((this)->args)), (i)))->i)));
        }

    }

    else {
        (((fprintf))((stderr_), ("kind: %llu\n"), ((this)->kind)));
        ((unreachablePcrN)(("Exhaustive handling in IRInstr.dump()")));
    }

    if ((!(*((flags).emitBIR))) && ((this)->isComptime))
        (((printf))(("\x1B[0m\n")));
    else
        (((printf))(("\n")));
}
bool equalsPS0666PS0666rB(LoopBlock_s *this, LoopBlock_s *other) { return (((((this)->before).i) == (((other)->before).i)) && ((((this)->after).i) == (((other)->after).i))); }
bool equalsPS9435PS9435rB(IRBlock_s *this, IRBlock_s *other) { return (((equalsPS0540PS0540rB)((&((this)->parent)), (&((other)->parent)))) && ((((this)->id).i) == (((other)->id).i))); }
bool isTerminatedPS9435rB(IRBlock_s *this) {
    if ((((this)->instructions).length) == ((usize)(0llu)))
        return (false);
    return ((isTerminatorPS7680rB)(((lastPS0124rPS7680)((&((this)->instructions))))));
}
none dumpPS9435rN(IRBlock_s *this) {
    (((printf))(("b%llu:\n"), ((this)->id)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        (((printf))(("  %4d: "), (i)));
        ((dumpPS7680rN)(((atPS0124uszrPS7680)((&((this)->instructions)), (i)))));
    }
}
none pushInstructionPS9435S7680rN(IRBlock_s *this, IRInstr_s instr) { ((pushPS0124S7680rN)((&((this)->instructions)), (instr))); }
none insertInstructionPS9435uszS7680rN(IRBlock_s *this, usize index, IRInstr_s instr) {
    ((assertBPcrN)(((index) <= (((this)->instructions).length)), ("Out of bounds in insertInstruction")));
    IRInstrList_s instructions = ((IRInstrList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (index)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((&(instructions)), (*((atPS0124uszrPS7680)((&((this)->instructions)), (i))))));
    }

    ((pushPS0124S7680rN)((&(instructions)), (instr)));
    for (usize i = (index); ((i) < (((this)->instructions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((&(instructions)), (*((atPS0124uszrPS7680)((&((this)->instructions)), (i))))));
    }

    ((dropPS0124rN)((&((this)->instructions))));
    (((this)->instructions) = (instructions));
}
bool hasAttributePS7132U4360rB(IRFunc_s *this, ParsedAttribute_u attr) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == ((tagAnyru8)((&(attr)))))
            return (true);
    }

    return (false);
}
bool isExternPS7132rB(IRFunc_s *this) { return ((isExternPS4904rB)(((getFuncNodePS7132rPS4904)((this))))); }
IRBlockID_s appendBlockPS7132rS7192(IRFunc_s *this) {
    IRBlockID_s id = ((IRBlockID_s){.i = (((this)->blocks).length)});
    ((pushPS1479S9435rN)((&((this)->blocks)), ((IRBlock_s){.parent = ((this)->name), .id = (id)})));
    return (id);
}
none setCurrentBlockPS7132S7192rN(IRFunc_s *this, IRBlockID_s id) {
    ((assertBPcrN)((((id).i) < (((this)->blocks).length)), ("setCurrentBlock called with invalid ID")));
    (((this)->currentBlock) = (id));
}
IRBlockID_s getCurrentBlockPS7132rS7192(IRFunc_s *this) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getCurrentBlock called on empty IRFunc")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("getCurrentBlock points to invalid block")));
    return ((this)->currentBlock);
}
IRBlock_s *getCurrentBlockAsRefPS7132rPS9435(IRFunc_s *this) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getCurrentBlockAsRef called on empty IRFunc")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("getCurrentBlockAsRef points to invalid block")));
    return ((atPS1479uszrPS9435)((&((this)->blocks)), (((this)->currentBlock).i)));
}
IRBlock_s *getBlockByIDPS7132S7192rPS9435(IRFunc_s *this, IRBlockID_s id) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("getBlockByID called on empty IRFunc")));
    ((assertBPcrN)((((id).i) < (((this)->blocks).length)), ("getBlockByID called with invalid ID")));
    return ((atPS1479uszrPS9435)((&((this)->blocks)), ((id).i)));
}
none pushLoopBlocksPS7132S7192S7192rN(IRFunc_s *this, IRBlockID_s before, IRBlockID_s after) { ((pushPS6662S0666rN)((&((this)->loopBlocks)), ((LoopBlock_s){.before = (before), .after = (after)}))); }
none popLoopBlocksPS7132rN(IRFunc_s *this) { ((popPS6662rPS0666)((&((this)->loopBlocks)))); }
ParsedFuncDecl_s *getFuncNodePS7132rPS4904(IRFunc_s *this) { return ((atPS4111uszrPS4904)((&(funcDecls)), ((this)->originalID))); }
none dumpInstructionsPS7132rN(IRFunc_s *this) {
    (((printf))(("%s:\n"), (((this)->name).buffer)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->blocks).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((dumpPS9435rN)(((atPS1479uszrPS9435)((&((this)->blocks)), (i)))));
    }
}
bool equalsPS7132PS7132rB(IRFunc_s *this, IRFunc_s *other) { ((unreachablePcrN)(("IRFunc.equals is not implemented yet"))); }
usize enterScopePS7132rusz(IRFunc_s *this) {
    ((pushPS9366S7082rN)((&((this)->scopes)), ((IRScope_s){0})));
    return (((this)->scopes).length);
}
usize leaveScopePS7132rusz(IRFunc_s *this) {
    usize s = (((this)->scopes).length);
    ((popPS9366rPS7082)((&((this)->scopes))));
    return (s);
}
none startComptimePS7132rN(IRFunc_s *this) { (((this)->comptimeLevel) = (((this)->comptimeLevel) + ((usize)(1llu)))); }
none endComptimePS7132rN(IRFunc_s *this) {
    ((assertBrN)((((this)->comptimeLevel) > ((usize)(0llu)))));
    (((this)->comptimeLevel) = (((this)->comptimeLevel) - ((usize)(1llu))));
}
usize getRegisterSizeInBytesPS7132rusz(IRFunc_s *this) {
    usize size = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->registers).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRReg_s *reg = ((getRegisterPS7132S6939rPS1534)((this), ((RegIndex_s){.i = (i)})));
        ((size) = ((size) + ((getSizeInBytesPU5175rusz)(((reg)->typ)))));
    }

    return (size);
}
RegIndex_s allocateRegisterPS7132PU5175rS6939(IRFunc_s *this, Type_u *typ) {
    usize size = (((this)->registers).length);
    usize offset = ((usize)(0llu));
    if ((size) > ((usize)(0llu))) {
        IRReg_s *last = ((lastPS2282rPS1534)((&((this)->registers))));
        ((offset) = (((last)->offset) + ((getSizeInBytesPU5175rusz)(((last)->typ)))));
    }

    ((pushPS2282S1534rN)((&((this)->registers)), ((IRReg_s){.isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .offset = (offset), .typ = (typ)})));
    return ((RegIndex_s){.i = (size)});
}
IRReg_s *getRegisterPS7132S6939rPS1534(IRFunc_s *this, RegIndex_s index) {
    ((assertBPcrN)((((index).i) < (((this)->registers).length)), ("Out of bounds access in IRFunc.getRegister")));
    return ((atPS2282uszrPS1534)((&((this)->registers)), ((index).i)));
}
IRScopeEntry_s *getIdentifierByNamePS7132S7720rPS9676(IRFunc_s *this, SubStr_s name) {
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->scopes).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->scopes).length) - (_i)) - ((usize)(1llu)));
        IRScopeEntry_s *entry = ((getIdentifierByNamePS7082S7720rPS9676)(((atPS9366uszrPS7082)((&((this)->scopes)), (i))), (name)));
        if ((entry) != (NULL)) {
            return (entry);
        }
    }

    return (NULL);
}
none pushInstructionPS7132S7680rN(IRFunc_s *this, IRInstr_s instr) {
    ((assertBPcrN)(((((this)->blocks).length) > ((usize)(0llu))), ("IRFunc.pushInstruction called on empty block list")));
    ((assertBPcrN)(((((this)->currentBlock).i) < (((this)->blocks).length)), ("IRFunc.pushInstruction: Current block was invalid")));
    ((pushInstructionPS9435S7680rN)(((atPS1479uszrPS9435)((&((this)->blocks)), (((this)->currentBlock).i))), (instr)));
}
none buildDebugInfoParamPS7132S8951S6939uszS7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, SubStr_s name) {
    usize val = (((shiftLeftuszuszrusz)(((usize)(((name).start))), (PARAM_SHIFT))) + (index));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_DEBUG_INFO_PARAM),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (val)}),
                                                         .op1 = ((RegIndex_s){.i = ((name).len)})})));
}
none buildDebugInfoAllocaPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s name) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_DEBUG_INFO_ALLOCA),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = ((usize)(((name).start)))}),
                                                         .op1 = ((RegIndex_s){.i = ((name).len)})})));
}
none buildAllocaPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size) {
    IRInstr_s alloca = ((IRInstr_s){.kind = (INSTR_ALLOCA), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (size)})});
    IRBlock_s *entry = ((getBlockByIDPS7132S7192rPS9435)((this), ((IRBlockID_s){.i = ((usize)(0llu))})));
    ((insertInstructionPS9435uszS7680rN)((entry), ((this)->allocaCounter), (alloca)));
    (((this)->allocaCounter) = (((this)->allocaCounter) + ((usize)(1llu))));
}
none buildFetchGlobalPointerPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_FETCH_GLOBAL_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (globalIndex)})));
}
none buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_FETCH_GLOBAL_VALUE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (globalIndex)})));
}
none buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_FETCH_COMPTIME_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (globalIndex),
                                                         .op1 = ((RegIndex_s){.i = ((usize)(1llu))})})));
}
none buildFetchLocalComptimeValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s globalIndex) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_FETCH_COMPTIME_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (globalIndex),
                                                         .op1 = ((RegIndex_s){.i = ((usize)(0llu))})})));
}
none buildLoadFunctionPtrPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize funcID) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_FUNCTION_PTR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (funcID)})})));
}
none buildLoadPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildMovePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_MOVE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildGetParamPS7132S8951S6939uszuszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize index, usize size) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_GET_PARAM),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (index)}),
                                                         .op1 = ((RegIndex_s){.i = (size)})})));
}
none buildStorePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_STORE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildCallPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s funcID, RegIndexList_s args) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_CALL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (funcID), .args = (args)})));
}
none buildReturnExprPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_RETURN_EXPR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .src = (val)})));
}
none buildReturnEmptyPS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_RETURN_VOID), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildLoadStringPS7132S8951S6939S7720rN(IRFunc_s *this, Span_s span, RegIndex_s dst, SubStr_s str) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_STRING),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = ((usize)(((str).start)))}),
                                                         .op1 = ((RegIndex_s){.i = ((str).len)})})));
}
none buildLoadBoolPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize val) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_LOAD_BOOL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (val)})})));
}
none buildLoadIntegerPS7132S8951S6939PU5175uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, Type_u *t, usize val) {
    usize kind = (INSTR_LOAD_I8);
    if ((isCharPU5175rB)((t))) {
        ((kind) = (INSTR_LOAD_U8));
    }

    else {
        ((assertBPcrN)(((isIntegerPU5175rB)((t))), ("IRFunc.buildLoadInteger got non-int type")));
        usize size = ((getSizeInBytesPU5175rusz)((t)));
        if ((size) == ((usize)(2llu)))
            ((kind) = (INSTR_LOAD_I16));
        if ((size) == ((usize)(4llu)))
            ((kind) = (INSTR_LOAD_I32));
        if ((size) == ((usize)(8llu)))
            ((kind) = (INSTR_LOAD_I64));
        if (!((isSignedIntegerPU5175rB)((t))))
            ((kind) = ((kind) + ((usize)(1llu))));
    }

    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (kind), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (val)})})));
}
none buildLoadNullPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_NULL), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildLoadF32PS7132S8951S6939f32rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f32 val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_F32),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (*((usize *)((&(val)))))})})));
}
none buildLoadF64PS7132S8951S6939f64rN(IRFunc_s *this, Span_s span, RegIndex_s dst, f64 val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOAD_F64),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = ((RegIndex_s){.i = (*((usize *)((&(val)))))})})));
}
none buildLoadBlankPS7132S8951S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, usize size) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_LOAD_BLANK), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = ((RegIndex_s){.i = (size)})})));
}
none buildLogicalNotPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_LOGICAL_NOT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildBinaryOpPS7132S8951uszS6939S6939S6939rN(IRFunc_s *this, Span_s span, usize kind, RegIndex_s dst, RegIndex_s lhs, RegIndex_s rhs) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (kind), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (lhs), .op1 = (rhs)})));
}
none buildInsertValuePS7132S8951S6939uszS6939rN(IRFunc_s *this, Span_s span, RegIndex_s aggr, usize index, RegIndex_s val) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INSERT_VALUE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (aggr),
                                                         .src = ((RegIndex_s){.i = (index)}),
                                                         .op1 = (val)})));
}
none buildUnreachablePS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_UNREACHABLE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildUnterminatedPS7132S8951rN(IRFunc_s *this, Span_s span) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_UNTERMINATED), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu)))})));
}
none buildBrPS7132S8951S7192rN(IRFunc_s *this, Span_s span, IRBlockID_s block) {
    ((assertBPcrN)((((block).i) < (((this)->blocks).length)), ("buildBr called with invalid ID")));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_BR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = ((RegIndex_s){.i = ((block).i)})})));
}
none buildCondBrPS7132S8951S6939S7192S7192rN(IRFunc_s *this, Span_s span, RegIndex_s cond, IRBlockID_s drue, IRBlockID_s falze) {
    ((assertBPcrN)((((drue).i) < (((this)->blocks).length)), ("buildCondBr called with invalid ID")));
    ((assertBPcrN)((((falze).i) < (((this)->blocks).length)), ("buildCondBr called with invalid ID")));
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_COND_BR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = ((RegIndex_s){.i = ((drue).i)}),
                                                         .src = (cond),
                                                         .op1 = ((RegIndex_s){.i = ((falze).i)})})));
}
bool buildBreakPS7132S8951rB(IRFunc_s *this, Span_s span) {
    if ((((this)->loopBlocks).length) == ((usize)(0llu)))
        return (false);
    LoopBlock_s *block = ((lastPS6662rPS0666)((&((this)->loopBlocks))));
    ((buildBrPS7132S8951S7192rN)((this), (span), ((block)->after)));
    return (true);
}
bool buildContinuePS7132S8951rB(IRFunc_s *this, Span_s span) {
    if ((((this)->loopBlocks).length) == ((usize)(0llu)))
        return (false);
    LoopBlock_s *block = ((lastPS6662rPS0666)((&((this)->loopBlocks))));
    ((buildBrPS7132S8951S7192rN)((this), (span), ((block)->before)));
    return (true);
}
none buildIntSignExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_SIGN_EXTEND),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildIntZeroExtendPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_ZERO_EXTEND),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildIntTruncatePS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src, usize bits) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TRUNCATE),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (dst),
                                                         .src = (src),
                                                         .op1 = ((RegIndex_s){.i = (bits)})})));
}
none buildF32ToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F32_TO_F64), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF64ToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F64_TO_F32), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToF32PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_F32), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToF64PS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_F64), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF32ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F32_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildF64ToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_F64_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildCreateArrayPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_ARRAY), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildCreateStructPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_STRUCT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildCreateUnionPS7132S8951S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_CREATE_UNION), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst)})));
}
none buildPtrToIntPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_PTR_TO_INT), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildIntToPtrPS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INT_TO_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
none buildGetFieldPtrPS7132S8951S6939S6939uszrN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, usize index) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_GET_FIELD_PTR),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .dst = (elem),
                                                         .src = (aggr),
                                                         .op1 = ((RegIndex_s){.i = (index)})})));
}
none buildGetElementPtrPS7132S8951S6939S6939S9911rN(IRFunc_s *this, Span_s span, RegIndex_s elem, RegIndex_s aggr, RegIndexList_s indices) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){
                                        .kind = (INSTR_GET_ELEMENT_PTR), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (elem), .src = (aggr), .args = (indices)})));
}
none buildMemcpyPS7132S8951S6939S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s src, RegIndex_s dst, RegIndex_s size) {
    ((pushInstructionPS7132S7680rN)((this),
                                    ((IRInstr_s){.kind = (INSTR_MEMCPY), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src), .op1 = (size)})));
}
none buildEmitAssemblyPS7132S8951S6939PU5175rN(IRFunc_s *this, Span_s span, RegIndex_s context, Type_u *fnType) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_EMIT_ASSEMBLY),
                                                         .span = (span),
                                                         .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))),
                                                         .src = (context),
                                                         .op1 = ((RegIndex_s){.i = ((usize)((fnType)))})})));
}
none buildIntoIRValuePS7132S8951S6939S6939rN(IRFunc_s *this, Span_s span, RegIndex_s dst, RegIndex_s src) {
    ((pushInstructionPS7132S7680rN)((this), ((IRInstr_s){.kind = (INSTR_INTO_IR_VALUE), .span = (span), .isComptime = (((this)->comptimeLevel) > ((usize)(0llu))), .dst = (dst), .src = (src)})));
}
bool equalsPS9676PS9676rB(IRScopeEntry_s *this, IRScopeEntry_s *other) { ((unreachablePcrN)(("IRScopeEntry.equals is not implemented yet"))); }
bool equalsPS7082PS7082rB(IRScope_s *this, IRScope_s *other) { ((unreachablePcrN)(("IRScope.equals is not implemented yet"))); }
none addEntryPS7082S7720S6939BrN(IRScope_s *this, SubStr_s name, RegIndex_s ptr, bool isComptime) {
    ((pushPS5960S9676rN)((&((this)->entries)), ((IRScopeEntry_s){.name = (name), .ptr = (ptr), .isComptime = (isComptime)})));
}
IRScopeEntry_s *getIdentifierByNamePS7082S7720rPS9676(IRScope_s *this, SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->entries).length)); ((i) = ((i) + ((usize)(1llu))))) {
        IRScopeEntry_s *entry = ((atPS5960uszrPS9676)((&((this)->entries)), (i)));
        if ((equalsPS7720PS7720rB)((&(name)), (&((entry)->name)))) {
            return (entry);
        }
    }

    return (NULL);
}
IRScopeEntry_s *getIdentifierByNamePS9562PS7132S7720PBrPS9676(IRGen_s *this, IRFunc_s *function, SubStr_s name, bool *isGlobal) {
    IRScopeEntry_s *entry = ((getIdentifierByNamePS7132S7720rPS9676)((function), (name)));
    if ((entry) != (NULL)) {
        ((*(isGlobal)) = (false));
        return (entry);
    }

    ((entry) = ((getIdentifierByNamePS7132S7720rPS9676)((&((this)->globalScope)), (name))));
    if ((entry) != (NULL)) {
        ((*(isGlobal)) = (true));
        return (entry);
    }

    return (NULL);
}
usize getFunctionByNamePS9562PS0540rusz(IRGen_s *this, String_s *name) { return ((indexOfPS2612PS0540rusz)((&((this)->functions)), (name))); }
usize getFunctionByMangledNamePS9562PcPcrusz(IRGen_s *this, char *name, char *imp) {
    String_s fn = ((newStringFromStrLitPcrS0540)((name)));
    if (!((containsKeyPS2612PS0540rB)((&((this)->functions)), (&(fn))))) {
        (((fprintf))((stderr_), ("%s Could not insert implicit function call! Reason: Could not find function `%s`!\n"), (FATAL_STR), (name)));
        (((fprintf))((stderr_), ("%s: Certain features in the language require extra support from the standard library. "), (NOTE_STR)));
        (((fprintf))((stderr_), ("Normally the compiler automatically imports the required files, however it seems like it failed this time.\n")));
        (((fprintf))((stderr_), ("%s: Please import `%s` and try again.\n"), (NOTE_STR), (imp)));
        (((fprintf))((stderr_), ("%s: Please create a bug report on https://github.com/pfhaupt/bufo/issues/new.\n"), (NOTE_STR)));
        (((C_exiti32rN))(((i32)(2))));
    }

    usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(fn))));
    ((dropPS0540rN)((&(fn))));
    return (funcID);
}
bool fillLookupPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFuncDecl_s *function = ((atPS4111uszrPS4904)((&(funcDecls)), (i)));
        if ((function)->ignored)
            continue;
        String_s name = ((getMangledNamePS4904rS0540)((function)));
        if ((containsKeyPS2612PS0540rB)((&((this)->functions)), (&(name)))) {
            IRFunc_s *fn = ((getPS2612PS0540rPS7132)((&((this)->functions)), (&(name))));
            String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
            String_s loc1 = ((toStringPS8951rS0540)((&((fn)->span))));
            (((fprintf))((stderr_), ("%s: %s Hash collision - Function Lookup already contains function!\n"), ((loc).buffer), (FATAL_STR)));
            (((fprintf))((stderr_), ("%s: %s Function with mangled name %s already defined here!\n"), ((loc1).buffer), (FATAL_STR), ((name).buffer)));
            ((dropPS0540rN)((&(loc1))));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(2))));
        }

        IRFunc_s irfunc = ((IRFunc_s){.name = (name), .span = ((function)->span), .originalID = ((getIDPS4904rusz)((function))), .comptimeLevel = ((usize)(0llu)), .attrs = ((function)->attrs)});
        ((addPS2612S0540S7132rN)((&((this)->functions)), (name), (irfunc)));
    }

    return (true);
}
bool _anon_26_0PS3131uszrB(TypeInfoTable_s *table, usize index) {
    bool succ_4253_ = true;

    {
        TypeInfo_u tmp_6413_ = ((((table)->elements))[(index)]);
        succ_4253_ &= (tmp_6413_.tag == 0);

        if (succ_4253_) {
            return (true);
        }
    }

    return (false);
}
usize _anon_26_1PS4113uszrusz(UsizeList_s *removed, usize index) {
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((removed)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        usize removed_index = ((((removed)->elements))[(i)]);
        if ((removed_index) > (index))
            break;
        ((offset) = ((offset) + ((usize)(1llu))));
    }

    return (offset);
}
TypeInfoTable_s generateTypeInfoTablerS3131(none) {
    TypeInfoTable_s table = ((TypeInfoTable_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = ((atPS4174uszrPU5175)((&(types)), (i)));
        bool succ_3991_ = true;
        bool succ_3996_ = true;
        bool succ_4001_ = true;
        bool succ_4007_ = true;
        bool succ_4014_ = true;
        bool succ_4022_ = true;
        bool succ_4028_ = true;
        bool succ_4035_ = true;
        bool succ_4041_ = true;
        bool succ_4047_ = true;

        Type_u *tmp_6226_ = (t);
        {
            succ_3991_ &= (tmp_6226_->tag == 1);
            if (succ_3991_) {
                {
                    TypeInfo_u u = (((TypeInfo_u){.tag = 0, .payload = {0}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(u)))))
                        ((push_entryPS3131U7843rN)((&(table)), (u)));
                }
                goto after_6226;
            }
        }
        {
            succ_3996_ &= (tmp_6226_->tag == 3);
            PrimType_u *prim = &tmp_6226_->payload.variant3._0;
            succ_3996_ &= true;
            if (succ_3996_) {
                {
                    ((assertBPcrN)(((i) < (PRIM_TYPE_COUNT)), ("nope")));
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    ((push_entryPS3131U7843rN)((&(table)), (((TypeInfo_u){.tag = 1,
                                                                          .payload = {.variant1 = {._0 = ((asSubStrPS0540rS7720)((&(name)))),
                                                                                                   ._1 = ((getSizeInBytesPU5175rusz)((t))),
                                                                                                   ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}))));
                }
                goto after_6226;
            }
        }
        {
            succ_4001_ &= (tmp_6226_->tag == 4);
            Type_u **underlying = &tmp_6226_->payload.variant4._0;
            succ_4001_ &= true;
            if (succ_4001_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u p = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(p)))))
                        ((push_entryPS3131U7843rN)((&(table)), (p)));
                }
                goto after_6226;
            }
        }
        {
            succ_4007_ &= (tmp_6226_->tag == 2);
            succ_4007_ &= true;
            if (succ_4007_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u v = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(v)))))
                        ((push_entryPS3131U7843rN)((&(table)), (v)));
                }
                goto after_6226;
            }
        }
        {
            succ_4014_ &= (tmp_6226_->tag == 5);
            Type_u **elem = &tmp_6226_->payload.variant5._0;
            succ_4014_ &= true;
            usize *len = &tmp_6226_->payload.variant5._1;
            succ_4014_ &= true;
            if (succ_4014_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u a = (((TypeInfo_u){
                        .tag = 4,
                        .payload = {.variant4 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t))), ._4 = (*len)}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(a)))))
                        ((push_entryPS3131U7843rN)((&(table)), (a)));
                }
                goto after_6226;
            }
        }
        {
            succ_4022_ &= (tmp_6226_->tag == 6);
            TypeList_s *args = &tmp_6226_->payload.variant6._0;
            succ_4022_ &= true;
            Type_u **ret = &tmp_6226_->payload.variant6._1;
            succ_4022_ &= true;
            succ_4022_ &= true;
            if (succ_4022_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u f = (((TypeInfo_u){.tag = 7, .payload = {.variant7 = {._0 = ((asSubStrPS0540rS7720)((&(name))))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(f)))))
                        ((push_entryPS3131U7843rN)((&(table)), (f)));
                }
                goto after_6226;
            }
        }
        {
            succ_4028_ &= (tmp_6226_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_6226_->payload.variant7._0;
            succ_4028_ &= true;
            if (succ_4028_) {
                {
                    String_s name = ((getFullNamePS5521rS0540)((*decl)));
                    TypeInfo_u s = (((TypeInfo_u){
                        .tag = 5, .payload = {.variant5 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(s)))))
                        ((push_entryPS3131U7843rN)((&(table)), (s)));
                }
                goto after_6226;
            }
        }
        {
            succ_4035_ &= (tmp_6226_->tag == 8);
            ParsedUnionDecl_s **decl = &tmp_6226_->payload.variant8._0;
            succ_4035_ &= true;
            succ_4035_ &= true;
            if (succ_4035_) {
                {
                    String_s name = ((getFullNamePS0997rS0540)((*decl)));
                    TypeInfo_u u = (((TypeInfo_u){
                        .tag = 6, .payload = {.variant6 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(u)))))
                        ((push_entryPS3131U7843rN)((&(table)), (u)));
                }
                goto after_6226;
            }
        }
        {
            succ_4041_ &= (tmp_6226_->tag == 10);
            TypeList_s *_elems = &tmp_6226_->payload.variant10._0;
            succ_4041_ &= true;
            if (succ_4041_) {
                {
                    String_s name = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));
                    TypeInfo_u a = (((TypeInfo_u){
                        .tag = 8, .payload = {.variant8 = {._0 = ((asSubStrPS0540rS7720)((&(name)))), ._1 = ((getSizeInBytesPU5175rusz)((t))), ._2 = ((getAlignmentInBytesPU5175rusz)((t)))}}}));
                    if (!((containsPS3131PU7843rB)((&(table)), (&(a)))))
                        ((push_entryPS3131U7843rN)((&(table)), (a)));
                }
                goto after_6226;
            }
        }
        {
            succ_4047_ &= (tmp_6226_->tag == 9);
            succ_4047_ &= true;
            if (succ_4047_) {
                {
                }
                goto after_6226;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when filling")));
                }
                goto after_6226;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6226:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *t = ((atPS4174uszrPU5175)((&(types)), (i)));
        bool succ_4055_ = true;
        bool succ_4059_ = true;
        bool succ_4068_ = true;
        bool succ_4078_ = true;
        bool succ_4097_ = true;
        bool succ_4119_ = true;
        bool succ_4144_ = true;
        bool succ_4195_ = true;
        bool succ_4198_ = true;
        bool succ_4202_ = true;

        Type_u *tmp_6399_ = (t);
        {
            succ_4055_ &= (tmp_6399_->tag == 3);
            PrimType_u *prim = &tmp_6399_->payload.variant3._0;
            succ_4055_ &= true;
            if (succ_4055_) {
                {
                }
                goto after_6399;
            }
        }
        {
            succ_4059_ &= (tmp_6399_->tag == 4);
            Type_u **underlying = &tmp_6399_->payload.variant4._0;
            succ_4059_ &= true;
            if (succ_4059_) {
                {
                    String_s tmp_32788 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_32788)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = (name)}}}));
                    usize ptr_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((ptr_index) != ((table).length))));
                    TypeInfo_u *ptr_info = (&((((table).elements))[(ptr_index)]));
                    TypeInfo_u tmp_32821 = (((TypeInfo_u){.tag = 3, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((ptr_info))) == (((tagAnyru8)((&tmp_32821)))))));
                    SubStr_s tmp_32833 = ((get_namePU7843rS7720)((ptr_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_32833)))));
                    usize underlying_index = ((index_of_typePS3131PU5175rusz)((&(table)), (*underlying)));
                    ((assertBPcrN)(((underlying_index) != ((table).length)), ("Underlying type info does not exist")));
                    ((*(ptr_info)) = (((TypeInfo_u){.tag = 3, .payload = {.variant3 = {._0 = (name), ._1 = (underlying_index)}}})));
                }
                goto after_6399;
            }
        }
        {
            succ_4068_ &= (tmp_6399_->tag == 2);
            Type_u **underlying = &tmp_6399_->payload.variant2._0;
            succ_4068_ &= true;
            if (succ_4068_) {
                {
                    String_s tmp_32865 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_32865)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = (name)}}}));
                    usize var_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((var_index) != ((table).length))));
                    TypeInfo_u *var_info = (&((((table).elements))[(var_index)]));
                    TypeInfo_u tmp_32898 = (((TypeInfo_u){.tag = 2, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((var_info))) == (((tagAnyru8)((&tmp_32898)))))));
                    SubStr_s tmp_32910 = ((get_namePU7843rS7720)((var_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_32910)))));
                    usize underlying_index = ((index_of_typePS3131PU5175rusz)((&(table)), (*underlying)));
                    ((assertBPcrN)(((underlying_index) != ((table).length)), ("Underlying type info does not exist")));
                    ((*(var_info)) = (((TypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = (name), ._1 = (underlying_index)}}})));
                }
                goto after_6399;
            }
        }
        {
            succ_4078_ &= (tmp_6399_->tag == 5);
            Type_u **elem = &tmp_6399_->payload.variant5._0;
            succ_4078_ &= true;
            usize *len = &tmp_6399_->payload.variant5._1;
            succ_4078_ &= true;
            if (succ_4078_) {
                {
                    String_s tmp_32942 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_32942)));
                    TypeInfo_u a = (((TypeInfo_u){.tag = 4, .payload = {.variant4 = {._0 = (name)}}}));
                    usize array_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(a))));
                    ((assertBrN)(((array_index) != ((table).length))));
                    TypeInfo_u *array_info = (&((((table).elements))[(array_index)]));
                    TypeInfo_u tmp_32975 = (((TypeInfo_u){.tag = 4, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((array_info))) == (((tagAnyru8)((&tmp_32975)))))));
                    SubStr_s tmp_32987 = ((get_namePU7843rS7720)((array_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_32987)))));
                    bool succ_4090_ = true;

                    TypeInfo_u *tmp_6266_ = (array_info);
                    {
                        succ_4090_ &= (tmp_6266_->tag == 4);
                        succ_4090_ &= true;
                        succ_4090_ &= true;
                        succ_4090_ &= true;
                        usize *elem_index = &tmp_6266_->payload.variant4._3;
                        succ_4090_ &= true;
                        usize *l = &tmp_6266_->payload.variant4._4;
                        succ_4090_ &= true;
                        if (succ_4090_) {
                            {
                                ((*elem_index) = ((index_of_typePS3131PU5175rusz)((&(table)), (*elem))));
                                ((assertBrN)(((*len) == (*l))));
                            }
                            goto after_6266;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6266;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6266:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }
                goto after_6399;
            }
        }
        {
            succ_4097_ &= (tmp_6399_->tag == 6);
            TypeList_s *args = &tmp_6399_->payload.variant6._0;
            succ_4097_ &= true;
            Type_u **ret = &tmp_6399_->payload.variant6._1;
            succ_4097_ &= true;
            FuncAttr_s *attr = &tmp_6399_->payload.variant6._2;
            succ_4097_ &= true;
            if (succ_4097_) {
                {
                    String_s tmp_33013 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33013)));
                    TypeInfo_u f = (((TypeInfo_u){.tag = 7, .payload = {.variant7 = {._0 = (name)}}}));
                    usize function_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(f))));
                    ((assertBrN)(((function_index) != ((table).length))));
                    TypeInfo_u *function_info = (&((((table).elements))[(function_index)]));
                    TypeInfo_u tmp_33046 = (((TypeInfo_u){.tag = 7, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((function_info))) == (((tagAnyru8)((&tmp_33046)))))));
                    SubStr_s tmp_33058 = ((get_namePU7843rS7720)((function_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33058)))));
                    TypeInfoList_s *arg_list = (NULL);
                    usize *ret_index = (NULL);
                    bool succ_4111_ = true;

                    TypeInfo_u *tmp_6282_ = (function_info);
                    {
                        succ_4111_ &= (tmp_6282_->tag == 7);
                        succ_4111_ &= true;
                        TypeInfoList_s *args = &tmp_6282_->payload.variant7._1;
                        succ_4111_ &= true;
                        usize *ret = &tmp_6282_->payload.variant7._2;
                        succ_4111_ &= true;
                        if (succ_4111_) {
                            {
                                ((arg_list) = (&(*args)));
                                ((ret_index) = (&(*ret)));
                            }
                            goto after_6282;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6282;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6282:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((arg_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (*((atPS0643uszrPPU5175)((&(*args)), (j))))));
                        ((assertBPcrN)(((index) != ((table).length)), ("Argument type info does not exist")));
                        ((pushPS2495uszrN)((arg_list), (index)));
                    }

                    ((*(ret_index)) = ((index_of_typePS3131PU5175rusz)((&(table)), (*ret))));
                    ((assertBPcrN)(((*(ret_index)) != ((table).length)), ("Return type info does not exist")));
                }
                goto after_6399;
            }
        }
        {
            succ_4119_ &= (tmp_6399_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_6399_->payload.variant7._0;
            succ_4119_ &= true;
            if (succ_4119_) {
                {
                    String_s tmp_33133 = ((getFullNamePS5521rS0540)((*decl)));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33133)));
                    TypeInfo_u s = (((TypeInfo_u){.tag = 5, .payload = {.variant5 = {._0 = (name)}}}));
                    usize struct_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(s))));
                    ((assertBrN)(((struct_index) != ((table).length))));
                    TypeInfo_u *struct_info = (&((((table).elements))[(struct_index)]));
                    TypeInfo_u tmp_33166 = (((TypeInfo_u){.tag = 5, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((struct_info))) == (((tagAnyru8)((&tmp_33166)))))));
                    SubStr_s tmp_33178 = ((get_namePU7843rS7720)((struct_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33178)))));
                    FieldTypeInfoList_s *struct_fields = (NULL);
                    bool succ_4132_ = true;

                    TypeInfo_u *tmp_6306_ = (struct_info);
                    {
                        succ_4132_ &= (tmp_6306_->tag == 5);
                        SubStr_s *name = &tmp_6306_->payload.variant5._0;
                        succ_4132_ &= true;
                        succ_4132_ &= true;
                        succ_4132_ &= true;
                        FieldTypeInfoList_s *fields = &tmp_6306_->payload.variant5._3;
                        succ_4132_ &= true;
                        if (succ_4132_) {
                            {
                                ((struct_fields) = (&(*fields)));
                            }
                            goto after_6306;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6306;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6306:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((struct_fields)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < (((*decl)->context).fieldLength)); ((j) = ((j) + ((usize)(1llu))))) {
                        Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (j)));
                        ParsedTypeNode_s *type_decl = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (j)));
                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                        ((assertBPcrN)(((index) != ((table).length)), ("Struct field type info does not exist")));
                        String_s tmp_33249 = ((toStringPS7720rS0540)((&((name).content))));

                        ((pushPS0131S3911rN)((struct_fields), ((FieldTypeInfo_s){.name = ((asSubStrPS0540rS7720)((&tmp_33249))),
                                                                                 .type = (index),
                                                                                 .offset_in_bytes = ((getFieldOffsetPS5521PS7720Brusz)((*decl), (&((name).content)), (false)))})));
                    }
                }
                goto after_6399;
            }
        }
        {
            succ_4144_ &= (tmp_6399_->tag == 8);
            ParsedUnionDecl_s **decl = &tmp_6399_->payload.variant8._0;
            succ_4144_ &= true;
            succ_4144_ &= true;
            if (succ_4144_) {
                {
                    String_s tmp_33266 = ((getFullNamePS0997rS0540)((*decl)));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33266)));
                    TypeInfo_u u = (((TypeInfo_u){.tag = 6, .payload = {.variant6 = {._0 = (name)}}}));
                    usize union_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(u))));
                    ((assertBrN)(((union_index) != ((table).length))));
                    TypeInfo_u *union_info = (&((((table).elements))[(union_index)]));
                    TypeInfo_u tmp_33299 = (((TypeInfo_u){.tag = 6, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((union_info))) == (((tagAnyru8)((&tmp_33299)))))));
                    SubStr_s tmp_33311 = ((get_namePU7843rS7720)((union_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33311)))));
                    UnionVariantTypeInfoList_s *variant_list = (NULL);
                    bool succ_4157_ = true;

                    TypeInfo_u *tmp_6331_ = (union_info);
                    {
                        succ_4157_ &= (tmp_6331_->tag == 6);
                        SubStr_s *name = &tmp_6331_->payload.variant6._0;
                        succ_4157_ &= true;
                        succ_4157_ &= true;
                        succ_4157_ &= true;
                        UnionVariantTypeInfoList_s *variants = &tmp_6331_->payload.variant6._3;
                        succ_4157_ &= true;
                        if (succ_4157_) {
                            {
                                ((variant_list) = (&(*variants)));
                            }
                            goto after_6331;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6331;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6331:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((variant_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < (((*decl)->variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedUnionVariant_s *variant = (((((*decl)->variants).elements))[(j)]);
                        UnionVariantTypeInfo_u variant_info = (((UnionVariantTypeInfo_u){.tag = 0, .payload = {.variant0 = {0}}}));
                        bool succ_4165_ = true;
                        bool succ_4168_ = true;
                        bool succ_4179_ = true;

                        ParsedUnionVariantData_u tmp_6368_ = ((variant)->data);
                        {
                            succ_4165_ &= (tmp_6368_.tag == 0);
                            if (succ_4165_) {
                                {
                                    String_s tmp_33364 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 0, .payload = {.variant0 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33364)))}}})));
                                }
                                goto after_6368;
                            }
                        }
                        {
                            succ_4168_ &= (tmp_6368_.tag == 1);
                            ParsedTypeNodeList_s *fields = &tmp_6368_.payload.variant1._0;
                            succ_4168_ &= true;
                            if (succ_4168_) {
                                {
                                    TypeInfoList_s tuple_fields = ((TypeInfoList_s){0});
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ParsedTypeNode_s *type_decl = ((((*fields).elements))[(k)]);
                                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                                        ((assertBPcrN)(((index) != ((table).length)), ("Union variant field type info does not exist")));
                                        ((pushPS2495uszrN)((&(tuple_fields)), (index)));
                                    }

                                    String_s tmp_33421 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 1, .payload = {.variant1 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33421))), ._1 = (tuple_fields)}}})));
                                }
                                goto after_6368;
                            }
                        }
                        {
                            succ_4179_ &= (tmp_6368_.tag == 2);
                            ParsedTypeNodeList_s *fields = &tmp_6368_.payload.variant2._0;
                            succ_4179_ &= true;
                            TokenList_s *names = &tmp_6368_.payload.variant2._1;
                            succ_4179_ &= true;
                            if (succ_4179_) {
                                {
                                    FieldTypeInfoList_s struct_fields = ((FieldTypeInfoList_s){0});
                                    ((assertBrN)((((*fields).length) == ((*names).length))));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        Token_s name = ((((*names).elements))[(k)]);
                                        ParsedTypeNode_s *type_decl = ((((*fields).elements))[(k)]);
                                        Type_u *type = ((getTypePU9661rPU5175)((&((type_decl)->typeState))));
                                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), (type)));
                                        ((assertBPcrN)(((index) != ((table).length)), ("Union variant field type info does not exist")));
                                        usize _size = ((usize)(0llu));
                                        usize offset = ((usize)(0llu));
                                        ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (k), (&(offset)), (&(_size)), (false)));
                                        String_s tmp_33498 = ((toStringPS7720rS0540)((&((name).content))));

                                        ((pushPS0131S3911rN)((&(struct_fields)), ((FieldTypeInfo_s){.name = ((asSubStrPS0540rS7720)((&tmp_33498))), .type = (index), .offset_in_bytes = (offset)})));
                                    }

                                    String_s tmp_33515 = ((toStringPS7720rS0540)((&(((variant)->name).content))));

                                    ((variant_info) = (((UnionVariantTypeInfo_u){.tag = 2, .payload = {.variant2 = {._0 = ((asSubStrPS0540rS7720)((&tmp_33515))), ._1 = (struct_fields)}}})));
                                }
                                goto after_6368;
                            }
                        }
                        {
                            if (true) {
                                {
                                    ((unreachablerN)());
                                }
                                goto after_6368;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_6368:
                        (void)0; // error: label at end of compound statement is a C23 extension
                        ((pushPS3117U0081rN)((variant_list), (variant_info)));
                    }
                }
                goto after_6399;
            }
        }
        {
            succ_4195_ &= (tmp_6399_->tag == 9);
            succ_4195_ &= true;
            if (succ_4195_) {
                {
                }
                goto after_6399;
            }
        }
        {
            succ_4198_ &= (tmp_6399_->tag == 1);
            if (succ_4198_) {
                {
                }
                goto after_6399;
            }
        }
        {
            succ_4202_ &= (tmp_6399_->tag == 10);
            TypeList_s *elems = &tmp_6399_->payload.variant10._0;
            succ_4202_ &= true;
            if (succ_4202_) {
                {
                    String_s tmp_33535 = ((toStringPU5175rS0540)(((atPS4174uszrPU5175)((&(types)), (i)))));

                    SubStr_s name = ((asSubStrPS0540rS7720)((&tmp_33535)));
                    TypeInfo_u a = (((TypeInfo_u){.tag = 8, .payload = {.variant8 = {._0 = (name)}}}));
                    usize tuple_index = ((index_ofPS3131PU7843rusz)((&(table)), (&(a))));
                    ((assertBrN)(((tuple_index) != ((table).length))));
                    TypeInfo_u *tuple_info = (&((((table).elements))[(tuple_index)]));
                    TypeInfo_u tmp_33568 = (((TypeInfo_u){.tag = 8, .payload = {0}}));

                    ((assertBrN)((((tagAnyru8)((tuple_info))) == (((tagAnyru8)((&tmp_33568)))))));
                    SubStr_s tmp_33580 = ((get_namePU7843rS7720)((tuple_info)));

                    ((assertBrN)(((equalsPS7720PS7720rB)((&(name)), (&tmp_33580)))));
                    TypeInfoList_s *elem_list = (NULL);
                    bool succ_4215_ = true;

                    TypeInfo_u *tmp_6387_ = (tuple_info);
                    {
                        succ_4215_ &= (tmp_6387_->tag == 8);
                        succ_4215_ &= true;
                        succ_4215_ &= true;
                        succ_4215_ &= true;
                        TypeInfoList_s *elems = &tmp_6387_->payload.variant8._3;
                        succ_4215_ &= true;
                        if (succ_4215_) {
                            {
                                ((elem_list) = (&(*elems)));
                            }
                            goto after_6387;
                        }
                    }
                    {
                        if (true) {
                            {
                                ((unreachablerN)());
                            }
                            goto after_6387;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_6387:
                    (void)0; // error: label at end of compound statement is a C23 extension
                    if (((elem_list)->length) > ((usize)(0llu)))
                        continue;
                    for (usize j = ((usize)(0llu)); ((j) < ((*elems).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        usize index = ((index_of_typePS3131PU5175rusz)((&(table)), ((((*elems).elements))[(j)])));
                        ((assertBPcrN)(((index) != ((table).length)), ("Argument type info does not exist")));
                        ((pushPS2495uszrN)((elem_list), (index)));
                    }
                }
                goto after_6399;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when patching")));
                }
                goto after_6399;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6399:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    usize length = ((table).length);
    while (true) {
        UsizeList_s count = ((UsizeList_s){0});
        ((initBlankPS4113uszrN)((&(count)), ((table).length)));
        for (usize i = ((usize)(0llu)); ((i) < ((table).length)); ((i) = ((i) + ((usize)(1llu))))) {
            bool succ_4233_ = true;
            bool succ_4238_ = true;
            bool succ_4243_ = true;
            bool succ_4249_ = true;
            bool succ_4265_ = true;
            bool succ_4275_ = true;
            bool succ_4303_ = true;
            bool succ_4310_ = true;
            bool succ_4316_ = true;

            TypeInfo_u *tmp_6474_ = (&((((table).elements))[(i)]));
            {
                succ_4233_ &= (tmp_6474_->tag == 4);
                succ_4233_ &= true;
                succ_4233_ &= true;
                succ_4233_ &= true;
                usize *elem = &tmp_6474_->payload.variant4._3;
                succ_4233_ &= true;
                succ_4233_ &= true;
                if (succ_4233_) {
                    {
                        (((((count).elements))[(*elem)]) = (((((count).elements))[(*elem)]) + ((usize)(1llu))));
                    }
                    goto after_6474;
                }
            }
            {
                succ_4238_ &= (tmp_6474_->tag == 3);
                succ_4238_ &= true;
                usize *under = &tmp_6474_->payload.variant3._1;
                succ_4238_ &= true;
                if (succ_4238_) {
                    {
                        (((((count).elements))[(*under)]) = (((((count).elements))[(*under)]) + ((usize)(1llu))));
                    }
                    goto after_6474;
                }
            }
            {
                succ_4243_ &= (tmp_6474_->tag == 2);
                succ_4243_ &= true;
                usize *under = &tmp_6474_->payload.variant2._1;
                succ_4243_ &= true;
                if (succ_4243_) {
                    {
                        (((((count).elements))[(*under)]) = (((((count).elements))[(*under)]) + ((usize)(1llu))));
                    }
                    goto after_6474;
                }
            }
            {
                succ_4249_ &= (tmp_6474_->tag == 7);
                succ_4249_ &= true;
                TypeInfoList_s *args = &tmp_6474_->payload.variant7._1;
                succ_4249_ &= true;
                usize *ret = &tmp_6474_->payload.variant7._2;
                succ_4249_ &= true;
                if (succ_4249_) {
                    {
                        bool (*is_unknown)(TypeInfoTable_s *, usize) = (_anon_26_0PS3131uszrB);
                        bool needed = (true);
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            if ((is_unknown)((&(table)), ((((*args).elements))[(j)]))) {
                                ((needed) = (false));
                            }
                        }

                        ((needed) = ((needed) && (!((is_unknown)((&(table)), (*ret))))));
                        if (needed)
                            (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = ((((*args).elements))[(j)]);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }

                        (((((count).elements))[(*ret)]) = (((((count).elements))[(*ret)]) + ((usize)(1llu))));
                    }
                    goto after_6474;
                }
            }
            {
                succ_4265_ &= (tmp_6474_->tag == 5);
                succ_4265_ &= true;
                succ_4265_ &= true;
                succ_4265_ &= true;
                FieldTypeInfoList_s *fields = &tmp_6474_->payload.variant5._3;
                succ_4265_ &= true;
                if (succ_4265_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = (((((*fields).elements))[(j)]).type);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }
                    }
                    goto after_6474;
                }
            }
            {
                succ_4275_ &= (tmp_6474_->tag == 6);
                succ_4275_ &= true;
                succ_4275_ &= true;
                succ_4275_ &= true;
                UnionVariantTypeInfoList_s *variants = &tmp_6474_->payload.variant6._3;
                succ_4275_ &= true;
                if (succ_4275_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                            bool succ_4282_ = true;
                            bool succ_4287_ = true;
                            bool succ_4295_ = true;

                            UnionVariantTypeInfo_u *tmp_6458_ = (var);
                            {
                                succ_4282_ &= (tmp_6458_->tag == 0);
                                succ_4282_ &= true;
                                if (succ_4282_) {
                                    {
                                    }
                                    goto after_6458;
                                }
                            }
                            {
                                succ_4287_ &= (tmp_6458_->tag == 1);
                                succ_4287_ &= true;
                                TypeInfoList_s *fields = &tmp_6458_->payload.variant1._1;
                                succ_4287_ &= true;
                                if (succ_4287_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            usize elem = ((((*fields).elements))[(k)]);
                                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                                        }
                                    }
                                    goto after_6458;
                                }
                            }
                            {
                                succ_4295_ &= (tmp_6458_->tag == 2);
                                succ_4295_ &= true;
                                FieldTypeInfoList_s *fields = &tmp_6458_->payload.variant2._1;
                                succ_4295_ &= true;
                                if (succ_4295_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            usize elem = (((((*fields).elements))[(k)]).type);
                                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                                        }
                                    }
                                    goto after_6458;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablerN)());
                                    }
                                    goto after_6458;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_6458:
                            (void)0; // error: label at end of compound statement is a C23 extension
                        }
                    }
                    goto after_6474;
                }
            }
            {
                succ_4303_ &= (tmp_6474_->tag == 1);
                succ_4303_ &= true;
                if (succ_4303_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                    }
                    goto after_6474;
                }
            }
            {
                succ_4310_ &= (tmp_6474_->tag == 8);
                succ_4310_ &= true;
                succ_4310_ &= true;
                succ_4310_ &= true;
                TypeInfoList_s *elements = &tmp_6474_->payload.variant8._3;
                succ_4310_ &= true;
                if (succ_4310_) {
                    {
                        (((((count).elements))[(i)]) = (((((count).elements))[(i)]) + ((usize)(1llu))));
                        for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize elem = ((((*elements).elements))[(j)]);
                            (((((count).elements))[(elem)]) = (((((count).elements))[(elem)]) + ((usize)(1llu))));
                        }
                    }
                    goto after_6474;
                }
            }
            {
                succ_4316_ &= (tmp_6474_->tag == 0);
                if (succ_4316_) {
                    {
                    }
                    goto after_6474;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when counting")));
                    }
                    goto after_6474;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_6474:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        UsizeList_s remove = ((UsizeList_s){0});
        TypeInfoTable_s new_table = ((TypeInfoTable_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((count).length)); ((i) = ((i) + ((usize)(1llu))))) {
            if (((((count).elements))[(i)]) != ((usize)(0llu))) {
                ((push_entryPS3131U7843rN)((&(new_table)), ((((table).elements))[(i)])));
            }

            else {
                ((pushPS4113uszrN)((&(remove)), (i)));
            }
        }

        usize (*count_offset)(UsizeList_s *, usize) = (_anon_26_1PS4113uszrusz);
        for (usize i = ((usize)(0llu)); ((i) < ((new_table).length)); ((i) = ((i) + ((usize)(1llu))))) {
            bool succ_4339_ = true;
            bool succ_4344_ = true;
            bool succ_4349_ = true;
            bool succ_4355_ = true;
            bool succ_4364_ = true;
            bool succ_4373_ = true;
            bool succ_4399_ = true;
            bool succ_4402_ = true;
            bool succ_4409_ = true;

            TypeInfo_u *tmp_6543_ = (&((((new_table).elements))[(i)]));
            {
                succ_4339_ &= (tmp_6543_->tag == 4);
                succ_4339_ &= true;
                succ_4339_ &= true;
                succ_4339_ &= true;
                usize *elem = &tmp_6543_->payload.variant4._3;
                succ_4339_ &= true;
                succ_4339_ &= true;
                if (succ_4339_) {
                    {
                        ((*elem) = ((*elem) - ((count_offset)((&(remove)), (*elem)))));
                    }
                    goto after_6543;
                }
            }
            {
                succ_4344_ &= (tmp_6543_->tag == 3);
                succ_4344_ &= true;
                usize *under = &tmp_6543_->payload.variant3._1;
                succ_4344_ &= true;
                if (succ_4344_) {
                    {
                        ((*under) = ((*under) - ((count_offset)((&(remove)), (*under)))));
                    }
                    goto after_6543;
                }
            }
            {
                succ_4349_ &= (tmp_6543_->tag == 2);
                succ_4349_ &= true;
                usize *under = &tmp_6543_->payload.variant2._1;
                succ_4349_ &= true;
                if (succ_4349_) {
                    {
                        ((*under) = ((*under) - ((count_offset)((&(remove)), (*under)))));
                    }
                    goto after_6543;
                }
            }
            {
                succ_4355_ &= (tmp_6543_->tag == 7);
                succ_4355_ &= true;
                TypeInfoList_s *args = &tmp_6543_->payload.variant7._1;
                succ_4355_ &= true;
                usize *ret = &tmp_6543_->payload.variant7._2;
                succ_4355_ &= true;
                if (succ_4355_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            (((((*args).elements))[(j)]) = (((((*args).elements))[(j)]) - ((count_offset)((&(remove)), ((((*args).elements))[(j)])))));
                        }

                        ((*ret) = ((*ret) - ((count_offset)((&(remove)), (*ret)))));
                    }
                    goto after_6543;
                }
            }
            {
                succ_4364_ &= (tmp_6543_->tag == 5);
                succ_4364_ &= true;
                succ_4364_ &= true;
                succ_4364_ &= true;
                FieldTypeInfoList_s *fields = &tmp_6543_->payload.variant5._3;
                succ_4364_ &= true;
                if (succ_4364_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            ((((((*fields).elements))[(j)]).type) = ((((((*fields).elements))[(j)]).type) - ((count_offset)((&(remove)), (((((*fields).elements))[(j)]).type)))));
                        }
                    }
                    goto after_6543;
                }
            }
            {
                succ_4373_ &= (tmp_6543_->tag == 6);
                succ_4373_ &= true;
                succ_4373_ &= true;
                succ_4373_ &= true;
                UnionVariantTypeInfoList_s *variants = &tmp_6543_->payload.variant6._3;
                succ_4373_ &= true;
                if (succ_4373_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                            bool succ_4380_ = true;
                            bool succ_4385_ = true;
                            bool succ_4392_ = true;

                            UnionVariantTypeInfo_u *tmp_6530_ = (var);
                            {
                                succ_4380_ &= (tmp_6530_->tag == 0);
                                succ_4380_ &= true;
                                if (succ_4380_) {
                                    {
                                    }
                                    goto after_6530;
                                }
                            }
                            {
                                succ_4385_ &= (tmp_6530_->tag == 1);
                                succ_4385_ &= true;
                                TypeInfoList_s *fields = &tmp_6530_->payload.variant1._1;
                                succ_4385_ &= true;
                                if (succ_4385_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            (((((*fields).elements))[(k)]) = (((((*fields).elements))[(k)]) - ((count_offset)((&(remove)), ((((*fields).elements))[(k)])))));
                                        }
                                    }
                                    goto after_6530;
                                }
                            }
                            {
                                succ_4392_ &= (tmp_6530_->tag == 2);
                                succ_4392_ &= true;
                                FieldTypeInfoList_s *fields = &tmp_6530_->payload.variant2._1;
                                succ_4392_ &= true;
                                if (succ_4392_) {
                                    {
                                        for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                            ((((((*fields).elements))[(k)]).type) = ((((((*fields).elements))[(k)]).type) - ((count_offset)((&(remove)), (((((*fields).elements))[(k)]).type)))));
                                        }
                                    }
                                    goto after_6530;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablerN)());
                                    }
                                    goto after_6530;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_6530:
                            (void)0; // error: label at end of compound statement is a C23 extension
                        }
                    }
                    goto after_6543;
                }
            }
            {
                succ_4399_ &= (tmp_6543_->tag == 1);
                succ_4399_ &= true;
                if (succ_4399_) {
                    {
                    }
                    goto after_6543;
                }
            }
            {
                succ_4402_ &= (tmp_6543_->tag == 0);
                if (succ_4402_) {
                    {
                    }
                    goto after_6543;
                }
            }
            {
                succ_4409_ &= (tmp_6543_->tag == 8);
                succ_4409_ &= true;
                succ_4409_ &= true;
                succ_4409_ &= true;
                TypeInfoList_s *elements = &tmp_6543_->payload.variant8._3;
                succ_4409_ &= true;
                if (succ_4409_) {
                    {
                        for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                            (((((*elements).elements))[(j)]) = (((((*elements).elements))[(j)]) - ((count_offset)((&(remove)), ((((*elements).elements))[(j)])))));
                        }
                    }
                    goto after_6543;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("generateTypeInfoTable: Exhaustive handling of Type kinds when removing")));
                    }
                    goto after_6543;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_6543:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        ((table) = (new_table));
        if (((table).length) == (length))
            break;
        ((length) = ((table).length));
    }

    return (table);
}
bool generateTypeInfoTablePS9562PS7132PS1892rB(IRGen_s *this, IRFunc_s *function, ParsedFile_s *project) {
    SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    ParsedFile_s *ti_file = ((getFileByFileNameS7720rPS1892)((FILE)));
    if ((ti_file) == (NULL)) {
        return (true);
    }

    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(NAME))));
    ((assertBPcrN)(((context) != (NULL)), ("generateTypeInfoTable: Could not find union context for TypeInfo")));
    ParsedFile_s *file = ((getParentFilePS0997rPS1892)(((context)->global)));
    for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
        if ((tli)->ignored)
            continue;
        if (((tli)->kind) == (TLI_VAR_DECL)) {
            ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)))));
            (((tli)->ignored) = (true));
        }
    }

    TypeInfoTable_s table = ((generateTypeInfoTablerS3131)());
    Type_u *t = ((intoArrayTypePU5175uszrPU5175)(((context)->type), ((table).length)));
    ((assertBPcrN)((((getSizeInBytesPU5175rusz)((t))) == ((sizeof(TypeInfo_u)) * ((table).length))), ("Size mismatch")));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
    ((buildCreateArrayPS7132S8951S6939rN)((function), (((context)->global)->span), (reg)));
    RegIndex_s global_table = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
    ((buildAllocaPS7132S8951S6939uszrN)((function), (((context)->global)->span), (global_table), ((getSizeInBytesPU5175rusz)((t)))));
    ((buildStorePS7132S8951S6939S6939rN)((function), (((context)->global)->span), (global_table), (reg)));
    bool isGlobal = (false);
    IRScopeEntry_s *global_type_info_table = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((newSubStrOfStrLitPcrS7720)(("type_info_table")))), (&(isGlobal))));
    ((assertBPcrN)(((global_type_info_table) != (NULL)), ("Could not find global type info table variable")));
    ((buildStorePS7132S8951S6939S6939rN)((function), (((context)->global)->span), ((global_type_info_table)->ptr), (global_table)));
    (((this)->type_info_table) = (table));
    (((this)->type_info_array_register) = (global_table));
    return (true);
}
none _anon_26_2PS7132S8951S6939S6939uszS6939rN(IRFunc_s *function, Span_s span, RegIndex_s ptr, RegIndex_s tmp, usize byte_offset, RegIndex_s val) {
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tmp), (usizeType), (byte_offset)));
    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (ptr), (ptr)));
    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (ptr)));
    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tmp), (val)));
}
RegIndex_s _anon_26_3PS9562PS7132S8951PU5175uszrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *ti, usize len) {
    Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (ti), ._1 = (len)}}})));
    Type_u *arrTypPtr = ((intoPointerPU5175rPU5175)((typ)));
    Type_u *pt = ((intoPointerPU5175rPU5175)((ti)));
    RegIndex_s local = ((allocateRegisterPS7132PU5175rS6939)((function), (pt)));
    usize s = ((getSizeInBytesPU5175rusz)((ti)));
    RegIndex_s arrAlloc = ((allocateRegisterPS7132PU5175rS6939)((&((this)->globalScope)), (arrTypPtr)));
    ((buildAllocaPS7132S8951S6939uszrN)((&((this)->globalScope)), (span), (arrAlloc), ((s) * (len))));
    RegIndex_s arrReg = ((allocateRegisterPS7132PU5175rS6939)((&((this)->globalScope)), (typ)));
    ((buildLoadBlankPS7132S8951S6939uszrN)((&((this)->globalScope)), (span), (arrReg), ((s) * (len))));
    ((buildStorePS7132S8951S6939S6939rN)((&((this)->globalScope)), (span), (arrAlloc), (arrReg)));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (local), (arrAlloc)));
    ((arrReg) = ((allocateRegisterPS7132PU5175rS6939)((function), (typ))));
    ((buildLoadBlankPS7132S8951S6939uszrN)((function), (span), (arrReg), ((s) * (len))));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (local), (arrReg)));
    return (local);
}
bool generateRuntimeTypeInfoPS9562rB(IRGen_s *this) {
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    SubStr_s TI = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FTI = ((BUILD_A_KEYWORDPcrS7720)(("FieldTypeInfo")));
    SubStr_s UVTI = ((BUILD_A_KEYWORDPcrS7720)(("UnionVariantTypeInfo")));
    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(TI))));
    ((assertBPcrN)(((context) != (NULL)), ("generateRuntimeInitialization: Could not find union context for TypeInfo")));
    StructLookup_s *_fieldTypeInfo = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)(((this)->lookup), (&(FILE)), (&(FTI))));
    ((assertBPcrN)(((_fieldTypeInfo) != (NULL)), ("generateRuntimeInitialization: Could not find context for FieldTypeInfo")));
    UnionLookup_s *_unionVariantTypeInfo = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(UVTI))));
    ((assertBPcrN)(((_unionVariantTypeInfo) != (NULL)), ("generateRuntimeInitialization: Could not find context for UnionVariantTypeInfo")));
    Type_u *fieldTypeInfo = ((_fieldTypeInfo)->type);
    Type_u *unionVariantTypeInfo = ((_unionVariantTypeInfo)->type);
    Span_s span = (((context)->global)->span);
    IRFunc_s *function = (&((this)->initRuntime));
    Type_u *typeInfoPtr = ((intoPointerPU5175rPU5175)(((context)->type)));
    Type_u *u8Type = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    Type_u *charPtrType =
        ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})));
    Type_u *fieldTypeInfoPtr = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (fieldTypeInfo)}}})));
    RegIndex_s global_table = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfoPtr)));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (global_table), ((this)->type_info_array_register)));
    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfoPtr)));
    RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (u8Type)));
    RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(indices)), (index)));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (charPtrType)));
    RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s ftiReg = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldTypeInfo)));
    RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldTypeInfo)))));
    RegIndex_s variantPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((unionVariantTypeInfo)))));
    RegIndex_s field_index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s field_indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(field_indices)), (field_index)));
    RegIndex_s variant_index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s variant_indices = ((RegIndexList_s){0});
    ((pushPS9911S6939rN)((&(variant_indices)), (variant_index)));
    none (*write_at_offset)(IRFunc_s *, Span_s, RegIndex_s, RegIndex_s, usize, RegIndex_s) = (_anon_26_2PS7132S8951S6939S6939uszS6939rN);
    RegIndex_s (*alloc_list)(IRGen_s *, IRFunc_s *, Span_s, Type_u *, usize) = (_anon_26_3PS9562PS7132S8951PU5175uszrS6939);
    for (usize i = ((usize)(0llu)); ((i) < (((this)->type_info_table).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (i)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (elemPtr), (global_table), (indices)));
        TypeInfo_u *info = (&(((((this)->type_info_table).elements))[(i)]));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (u8Type), ((usize)(((tagAnyru8)((info)))))));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(0llu)), (tagReg)));
        SubStr_s name = ((get_namePU7843rS7720)((info)));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (name)));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(1llu)), (reg)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((name).len)));
        ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(9llu)), (index)));
        bool succ_4488_ = true;
        bool succ_4493_ = true;
        bool succ_4498_ = true;
        bool succ_4504_ = true;
        bool succ_4514_ = true;
        bool succ_4525_ = true;
        bool succ_4558_ = true;
        bool succ_4565_ = true;
        bool succ_4571_ = true;

        TypeInfo_u *tmp_6797_ = (info);
        {
            succ_4488_ &= (tmp_6797_->tag == 4);
            succ_4488_ &= true;
            usize *size_in_bytes = &tmp_6797_->payload.variant4._1;
            succ_4488_ &= true;
            usize *align_in_bytes = &tmp_6797_->payload.variant4._2;
            succ_4488_ &= true;
            usize *elem = &tmp_6797_->payload.variant4._3;
            succ_4488_ &= true;
            usize *elem_count = &tmp_6797_->payload.variant4._4;
            succ_4488_ &= true;
            if (succ_4488_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*elem)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*elem_count)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4493_ &= (tmp_6797_->tag == 3);
            succ_4493_ &= true;
            usize *underlying = &tmp_6797_->payload.variant3._1;
            succ_4493_ &= true;
            if (succ_4493_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*underlying)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4498_ &= (tmp_6797_->tag == 2);
            succ_4498_ &= true;
            usize *underlying = &tmp_6797_->payload.variant2._1;
            succ_4498_ &= true;
            if (succ_4498_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*underlying)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4504_ &= (tmp_6797_->tag == 7);
            succ_4504_ &= true;
            TypeInfoList_s *args = &tmp_6797_->payload.variant7._1;
            succ_4504_ &= true;
            usize *ret = &tmp_6797_->payload.variant7._2;
            succ_4504_ &= true;
            if (succ_4504_) {
                {
                    RegIndex_s local_args = ((alloc_list)((this), (function), (span), (usizeType), ((*args).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*args).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_args), (field_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*args).elements))[(j)])));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                    }

                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (local_args)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*args).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (field_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*ret)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4514_ &= (tmp_6797_->tag == 5);
            succ_4514_ &= true;
            usize *size_in_bytes = &tmp_6797_->payload.variant5._1;
            succ_4514_ &= true;
            usize *align_in_bytes = &tmp_6797_->payload.variant5._2;
            succ_4514_ &= true;
            FieldTypeInfoList_s *fields = &tmp_6797_->payload.variant5._3;
            succ_4514_ &= true;
            if (succ_4514_) {
                {
                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (fieldTypeInfo), ((*fields).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                        SubStr_s fieldName = (((((*fields).elements))[(j)]).name);
                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (fieldName)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (reg)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((fieldName).len)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(8llu)), (index)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(j)]).type)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(16llu)), (index)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(j)]).offset_in_bytes)));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(24llu)), (index)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (field_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_fields)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*fields).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (field_index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4525_ &= (tmp_6797_->tag == 6);
            succ_4525_ &= true;
            usize *size_in_bytes = &tmp_6797_->payload.variant6._1;
            succ_4525_ &= true;
            usize *align_in_bytes = &tmp_6797_->payload.variant6._2;
            succ_4525_ &= true;
            UnionVariantTypeInfoList_s *variants = &tmp_6797_->payload.variant6._3;
            succ_4525_ &= true;
            if (succ_4525_) {
                {
                    RegIndex_s local_variants = ((alloc_list)((this), (function), (span), (unionVariantTypeInfo), ((*variants).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*variants).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        UnionVariantTypeInfo_u *var = (&((((*variants).elements))[(j)]));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (variantPtr), (local_variants), (variant_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (u8Type), ((usize)(((tagAnyru8)((var)))))));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(0llu)), (tagReg)));
                        SubStr_s variantName = ((get_namePU0081rS7720)((var)));
                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (variantName)));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(1llu)), (reg)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((variantName).len)));
                        ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(9llu)), (index)));
                        bool succ_4534_ = true;
                        bool succ_4539_ = true;
                        bool succ_4547_ = true;

                        UnionVariantTypeInfo_u *tmp_6760_ = (var);
                        {
                            succ_4534_ &= (tmp_6760_->tag == 0);
                            succ_4534_ &= true;
                            if (succ_4534_) {
                                {
                                }
                                goto after_6760;
                            }
                        }
                        {
                            succ_4539_ &= (tmp_6760_->tag == 1);
                            succ_4539_ &= true;
                            TypeInfoList_s *fields = &tmp_6760_->payload.variant1._1;
                            succ_4539_ &= true;
                            if (succ_4539_) {
                                {
                                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (usizeType), ((*fields).length)));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (k)));
                                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*fields).elements))[(k)])));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                                    }

                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(17llu)), (local_fields)));
                                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*fields).length)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(25llu)), (variant_index)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(33llu)), (variant_index)));
                                }
                                goto after_6760;
                            }
                        }
                        {
                            succ_4547_ &= (tmp_6760_->tag == 2);
                            succ_4547_ &= true;
                            FieldTypeInfoList_s *fields = &tmp_6760_->payload.variant2._1;
                            succ_4547_ &= true;
                            if (succ_4547_) {
                                {
                                    RegIndex_s local_fields = ((alloc_list)((this), (function), (span), (fieldTypeInfo), ((*fields).length)));
                                    for (usize k = ((usize)(0llu)); ((k) < ((*fields).length)); ((k) = ((k) + ((usize)(1llu))))) {
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (k)));
                                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_fields), (field_indices)));
                                        SubStr_s fieldName = (((((*fields).elements))[(k)]).name);
                                        ((buildLoadStringPS7132S8951S6939S7720rN)((function), (span), (reg), (fieldName)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (reg)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((fieldName).len)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(8llu)), (index)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(k)]).type)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(16llu)), (index)));
                                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (((((*fields).elements))[(k)]).offset_in_bytes)));
                                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(24llu)), (index)));
                                    }

                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(17llu)), (local_fields)));
                                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*fields).length)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(25llu)), (variant_index)));
                                    ((write_at_offset)((function), (span), (variantPtr), (tmp), ((usize)(33llu)), (variant_index)));
                                }
                                goto after_6760;
                            }
                        }
                        {
                            if (true) {
                                {
                                    ((unreachablerN)());
                                }
                                goto after_6760;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_6760:
                        (void)0; // error: label at end of compound statement is a C23 extension
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (variant_index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (variant_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_variants)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (variant_index), (usizeType), ((*variants).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (variant_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (variant_index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4558_ &= (tmp_6797_->tag == 1);
            succ_4558_ &= true;
            usize *size_in_bytes = &tmp_6797_->payload.variant1._1;
            succ_4558_ &= true;
            usize *align_in_bytes = &tmp_6797_->payload.variant1._2;
            succ_4558_ &= true;
            if (succ_4558_) {
                {
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4565_ &= (tmp_6797_->tag == 8);
            succ_4565_ &= true;
            usize *size_in_bytes = &tmp_6797_->payload.variant8._1;
            succ_4565_ &= true;
            usize *align_in_bytes = &tmp_6797_->payload.variant8._2;
            succ_4565_ &= true;
            TypeInfoList_s *elements = &tmp_6797_->payload.variant8._3;
            succ_4565_ &= true;
            if (succ_4565_) {
                {
                    RegIndex_s local_elements = ((alloc_list)((this), (function), (span), (usizeType), ((*elements).length)));
                    for (usize j = ((usize)(0llu)); ((j) < ((*elements).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), (j)));
                        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (fieldPtr), (local_elements), (field_indices)));
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), ((((*elements).elements))[(j)])));
                        ((write_at_offset)((function), (span), (fieldPtr), (tmp), ((usize)(0llu)), (index)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*size_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(17llu)), (index)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (index), (usizeType), (*align_in_bytes)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(25llu)), (index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(33llu)), (local_elements)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (field_index), (usizeType), ((*elements).length)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(41llu)), (field_index)));
                    ((write_at_offset)((function), (span), (elemPtr), (tmp), ((usize)(49llu)), (field_index)));
                }
                goto after_6797;
            }
        }
        {
            succ_4571_ &= (tmp_6797_->tag == 0);
            if (succ_4571_) {
                {
                }
                goto after_6797;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("generateRuntimeTypeInfo: Exhaustive handling of Type kinds")));
                }
                goto after_6797;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_6797:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    return (true);
}
bool generateRuntimeInitializationPS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    (((this)->initRuntime) = ((IRFunc_s){.name = (((newReadonlyStringPcrS0540)((".init_runtime"))))}));
    usize scope = ((enterScopePS7132rusz)((&((this)->initRuntime))));
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((&((this)->initRuntime))));
    ((setCurrentBlockPS7132S7192rN)((&((this)->initRuntime)), (entry)));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    ParsedFile_s *ti_file = ((getFileByFileNameS7720rPS1892)((FILE)));
    if ((ti_file) != (NULL)) {
        if (!((generateRuntimeTypeInfoPS9562rB)((this))))
            return (false);
    }

    ((buildReturnEmptyPS7132S8951rN)((&((this)->initRuntime)), (((project)->mod)->span)));
    return (true);
}
bool generateBytecodePS9562PS1892rB(IRGen_s *this, ParsedFile_s *project) {
    if (!((fillLookupPS9562PS1892rB)((this), (project))))
        return (false);
    usize scope = ((enterScopePS7132rusz)((&((this)->globalScope))));
    ((assertBPcrN)((((((this)->globalScope).scopes).length) == ((usize)(1llu))), ("Expected only one valid scope")));
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((&((this)->globalScope))));
    ((setCurrentBlockPS7132S7192rN)((&((this)->globalScope)), (entry)));
    if (!((generateTypeInfoTablePS9562PS7132PS1892rB)((this), (&((this)->globalScope)), (project))))
        return (false);
    if (!((generateRuntimeInitializationPS9562PS1892rB)((this), (project))))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (&((this)->globalScope)), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)))));
            }
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFuncDecl_s *fn = ((atPS4111uszrPS4904)((&(funcDecls)), (i)));
        ((generateFunctionPS9562PS4904rN)((this), (fn)));
    }

    if (*((flags).emitBIR)) {
        ((dumpInstructionsPS7132rN)((&((this)->globalScope))));
        ((dumpInstructionsPS7132rN)((&((this)->initRuntime))));
        IRFuncList_s fns = ((asListPS2612rS8040)((&((this)->functions))));
        for (usize i = ((usize)(0llu)); ((i) < ((fns).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ((dumpInstructionsPS7132rN)(((atPS8040uszrPS7132)((&(fns)), (i)))));
        }

        ((dropPS8040rN)((&(fns))));
    }

    return (!((this)->error));
}
none generateFunctionHeaderPS9562PS7132PU5175PS9803rN(IRGen_s *this, IRFunc_s *function, Type_u *retType, ParamContext_s *params) {
    IRBlockID_s entry = ((appendBlockPS7132rS7192)((function)));
    ((setCurrentBlockPS7132S7192rN)((function), (entry)));
    if ((hasAttributePS4904U4360rB)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->originalID))), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))))
        return;
    usize offset = ((usize)(0llu));
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        ((offset) = ((usize)(1llu)));
        ((prepareParameterPS9562PS7132uszS8951S7720PU5175BrN)((this), (function), ((usize)(0llu)), ((Span_s){0}), ((newSubStrOfStrLitPcrS7720)(("ret"))), ((intoPointerPU5175rPU5175)((retType))),
                                                              (true)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((params)->paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((params), (i)));
        ParsedTypeNode_s *typDecl = ((getTypeAtIndexPS9803uszrPS1372)((params), (i)));
        Type_u *pType = ((getTypePU9661rPU5175)((&((typDecl)->typeState))));
        ((prepareParameterPS9562PS7132uszS8951S7720PU5175BrN)((this), (function), ((i) + (offset)), ((name).span), ((name).content), (pType), (false)));
    }
}
RegIndexList_s _anon_26_4PS7132PS4904rS9911(IRFunc_s *function, ParsedFuncDecl_s *fn) {
    RegIndexList_s args = ((RegIndexList_s){0});
    RegIndex_s reg =
        ((allocateRegisterPS7132PU5175rS6939)((function),
                                              ((wrapU5175rPU5175)(((Type_u){
                                                  .tag = 4,
                                                  .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})))));
    String_s name = ((toStringPS7720rS0540)((&(((fn)->name).content))));
    ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((function)->span), (reg), ((asSubStrPS0540rS7720)((&(name))))));
    ((pushPS9911S6939rN)((&(args)), (reg)));
    return (args);
}
none generateFunctionBodyPS9562PS7132PS7247PS1372rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *body, ParsedTypeNode_s *retTypeNode) {
    Type_u *retType = ((getTypePU9661rPU5175)((&((retTypeNode)->typeState))));
    bool isNakedFn = ((hasAttributePS4904U4360rB)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->originalID))), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))));
    if ((((function)->returnBlockID).i) == ((usize)(0llu))) {
        IRBlockID_s curr = ((getCurrentBlockPS7132rS7192)((function)));
        (((function)->returnBlockID) = ((appendBlockPS7132rS7192)((function))));
        if ((isNonePU5175rB)((retType))) {
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            ((buildReturnEmptyPS7132S8951rN)((function), ((retTypeNode)->span)));
            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else if (isNakedFn) {
            ((assertBPcrN)((((getSizeInBytesPU5175rusz)((retType))) <= ((usize)(8llu))), ("Naked functions can only return types that fit into a register")));
            RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            ((buildLoadBlankPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), (reg), ((getSizeInBytesPU5175rusz)((retType)))));
            ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (reg)));
            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else {
            (((function)->returnAlloc) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType))))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), ((function)->returnAlloc), ((getSizeInBytesPU5175rusz)((retType)))));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            RegIndex_s result = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (result), ((function)->returnAlloc)));
            if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
                ((buildStorePS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), ((function)->retPtr), (result)));
                ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), ((function)->retPtr)));
            }

            else {
                if ((isStructPU5175rB)((retType))) {
                    RegIndex_s v = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), ((getSizeInBytesPU5175rusz)((retType)))));
                    Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (v)))->typ);
                    RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    usize s = ((getSizeInBytesPU5175rusz)((t)));
                    ((assertBrN)(((s) <= ((usize)(8llu)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((retTypeNode)->span), (r), (s)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (r), (result)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((retTypeNode)->span), (v), (r)));
                    ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (v)));
                }

                else {
                    ((buildReturnExprPS7132S8951S6939rN)((function), ((retTypeNode)->span), (result)));
                }
            }

            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }
    }

    if (*((flags).trace)) {
        ParsedFuncDecl_s *fn = ((getFuncNodePS7132rPS4904)((function)));
        SubStr_s tmp_36401 = ((newSubStrOfStrLitPcrS7720)(("traceEnter")));

        bool isEnter = ((equalsPS7720PS7720rB)((&(((fn)->name).content)), (&tmp_36401)));
        SubStr_s tmp_36413 = ((newSubStrOfStrLitPcrS7720)(("traceLeave")));

        bool isLeave = ((equalsPS7720PS7720rB)((&(((fn)->name).content)), (&tmp_36413)));
        RegIndexList_s (*init)(IRFunc_s *, ParsedFuncDecl_s *) = (_anon_26_4PS7132PS4904rS9911);
        if ((!(isEnter)) && (!(isLeave))) {
            usize funcID = ((usize)(0llu));
            RegIndexList_s args = ((RegIndexList_s){0});
            ((funcID) = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("traceEnterPcrN"), ("trace.bufo"))));
            ((args) = ((init)((function), (fn))));
            ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                         ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
            ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
            ((funcID) = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("traceLeavePcrN"), ("trace.bufo"))));
            IRBlockID_s curr = ((getCurrentBlockPS7132rS7192)((function)));
            ((setCurrentBlockPS7132S7192rN)((function), ((function)->returnBlockID)));
            IRBlock_s *block = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
            if ((isTerminatedPS9435rB)((block))) {
                IRInstr_s term = (*((popPS0124rPS7680)((&((block)->instructions)))));
                ((args) = ((init)((function), (fn))));
                ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                             ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
                ((pushPS0124S7680rN)((&((block)->instructions)), (term)));
            }

            else {
                ((args) = ((init)((function), (fn))));
                ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((function)->span), (funcID),
                                                                             ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
            }

            ((setCurrentBlockPS7132S7192rN)((function), (curr)));
        }

        else {
            ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
        }

    }

    else {
        ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (body)));
    }

    IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
    if (!((isTerminatedPS9435rB)((curr)))) {
        if (((isNonePU5175rB)((retType))) || (isNakedFn)) {
            ((buildBrPS7132S8951S7192rN)((function), ((body)->span), ((function)->returnBlockID)));
        }

        else {
            ((buildUnterminatedPS7132S8951rN)((function), ((body)->span)));
        }
    }

    usize after = ((leaveScopePS7132rusz)((function)));
    ((assertBPcrN)(((after) == ((usize)(1llu))), ("Scope imbalance detected")));
}
none generateFunctionPS9562PS4904rN(IRGen_s *this, ParsedFuncDecl_s *funcDecl) {
    if ((funcDecl)->ignored)
        return;
    ((assertBPcrN)(((isSuccessPU9661rB)((&((funcDecl)->typeState)))), ("Expected valid FuncDecl type in IRGen")));
    String_s name = ((getMangledNamePS4904rS0540)((funcDecl)));
    IRFunc_s *function = ((getPS2612PS0540rPS7132)((&((this)->functions)), (&(name))));
    ((assertBPcrN)(((function) != (NULL)), ("Expected to find function in lookup")));
    ((assertBPcrN)(((equalsPS0540PS0540rB)((&((function)->name)), (&(name)))), ("functions.get() retrieved wrong IRFunc")));
    ((dropPS0540rN)((&(name))));
    if ((isExternPS4904rB)((funcDecl))) {
        return;
    }

    usize scope = ((enterScopePS7132rusz)((function)));
    ((assertBPcrN)(((scope) == ((usize)(1llu))), ("Expected function to enter first scope")));
    ParsedTypeNode_s *retDecl = ((funcDecl)->retType);
    ((generateFunctionHeaderPS9562PS7132PU5175PS9803rN)((this), (function), ((getTypePU9661rPU5175)((&((retDecl)->typeState)))), (&((funcDecl)->params))));
    ((generateFunctionBodyPS9562PS7132PS7247PS1372rN)((this), (function), ((funcDecl)->body), ((funcDecl)->retType)));
}
none generateBytecodeBlockPS9562PS7132PS7247rN(IRGen_s *this, IRFunc_s *function, ParsedBlock_s *block) {
    if ((block)->ignored)
        return;
    ((assertBPcrN)(((isSuccessPU9661rB)((&((block)->typeState)))), ("Expected valid Block type in IRGen")));
    usize scope = ((enterScopePS7132rusz)((function)));
    ParsedFuncDecl_s *f = ((getFuncNodePS7132rPS4904)((function)));
    for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStmt_s *stmt = ((getStmtAtIndexPS7247uszrPS1100)((block), (i)));
        ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
        IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
        if ((isTerminatedPS9435rB)((curr))) {
            if ((i) != (((block)->stmtLength) - ((usize)(1llu)))) {
                Span_s tmp_36780 = (((getStmtAtIndexPS7247uszrPS1100)((block), ((i) + ((usize)(1llu)))))->span);

                String_s loc = ((toStringPS8951rS0540)((&tmp_36780)));
                (((fprintf))((stderr_), ("%s: %s: Unreachable code.\n"), ((loc).buffer), (WARN_STR)));
                ((dropPS0540rN)((&(loc))));
            }

            break;
        }
    }

    usize after = ((leaveScopePS7132rusz)((function)));
    ((assertBPcrN)(((scope) == (after)), ("Scope imbalance detected")));
}
none generateBytecodeStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *stmt) {
    bool succ_4667_ = true;
    bool succ_4679_ = true;
    bool succ_4683_ = true;
    bool succ_4691_ = true;
    bool succ_4695_ = true;
    bool succ_4700_ = true;
    bool succ_4711_ = true;
    bool succ_4733_ = true;
    bool succ_4749_ = true;
    bool succ_4765_ = true;
    bool succ_4792_ = true;
    bool succ_4809_ = true;
    bool succ_4820_ = true;
    bool succ_4823_ = true;
    bool succ_4829_ = true;
    bool succ_4834_ = true;

    StmtData_u *tmp_7264_ = (&((stmt)->data));
    {
        succ_4667_ &= (tmp_7264_->tag == 0);
        VarDecl_s *decl = &tmp_7264_->payload.variant0._0;
        succ_4667_ &= true;
        if (succ_4667_) {
            {
                ParsedExpr_s *expr = ((*decl).expr);
                if ((*decl).isComptime)
                    ((startComptimePS7132rN)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (result), ((*decl).pat), (false), ((*decl).isComptime)));
                if (((*decl).trampoline) != (NULL)) {
                    IRBlockID_s trampoline = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), (((*decl).trampoline)->span), (patReg), (after), (trampoline)));
                    ((setCurrentBlockPS7132S7192rN)((function), (trampoline)));
                    ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), ((*decl).trampoline)));
                    IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                    if (!((isTerminatedPS9435rB)((curr)))) {
                        String_s loc = ((toStringPS8951rS0540)((&(((*decl).trampoline)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Trampolines must always terminate.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        (((this)->error) = (true));
                    }

                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                if ((*decl).isComptime)
                    ((endComptimePS7132rN)((function)));
            }
            goto after_7264;
        }
    }
    {
        succ_4679_ &= (tmp_7264_->tag == 1);
        if (succ_4679_) {
            {
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), ((function)->returnBlockID)));
            }
            goto after_7264;
        }
    }
    {
        succ_4683_ &= (tmp_7264_->tag == 2);
        ParsedExpr_s **expr = &tmp_7264_->payload.variant2._0;
        succ_4683_ &= true;
        if (succ_4683_) {
            {
                Type_u *typ = ((getTypePU9661rPU5175)((&((*expr)->typeState))));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((stmt)->span), ((function)->returnAlloc), (result)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), ((function)->returnBlockID)));
            }
            goto after_7264;
        }
    }
    {
        succ_4691_ &= (tmp_7264_->tag == 3);
        ParsedExpr_s **expr = &tmp_7264_->payload.variant3._0;
        succ_4691_ &= true;
        if (succ_4691_) {
            {
                ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
            }
            goto after_7264;
        }
    }
    {
        succ_4695_ &= (tmp_7264_->tag == 4);
        ParsedBlock_s **block = &tmp_7264_->payload.variant4._0;
        succ_4695_ &= true;
        if (succ_4695_) {
            {
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
            }
            goto after_7264;
        }
    }
    {
        succ_4700_ &= (tmp_7264_->tag == 5);
        ParsedExpr_s **cond = &tmp_7264_->payload.variant5._0;
        succ_4700_ &= true;
        ParsedStmt_s **then = &tmp_7264_->payload.variant5._1;
        succ_4700_ &= true;
        if (succ_4700_) {
            {
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                IRBlockID_s thenBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s contBlock = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (thenBlock), (contBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (thenBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*then)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (contBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (contBlock)));
            }
            goto after_7264;
        }
    }
    {
        succ_4711_ &= (tmp_7264_->tag == 6);
        ParsedExpr_s **cond = &tmp_7264_->payload.variant6._0;
        succ_4711_ &= true;
        ParsedStmt_s **then = &tmp_7264_->payload.variant6._1;
        succ_4711_ &= true;
        ParsedStmt_s **elze = &tmp_7264_->payload.variant6._2;
        succ_4711_ &= true;
        if (succ_4711_) {
            {
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                IRBlockID_s thenBlockID = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s elzeBlockID = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (thenBlockID), (elzeBlockID)));
                ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*then)));
                ((thenBlockID) = ((getCurrentBlockPS7132rS7192)((function))));
                ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*elze)));
                ((elzeBlockID) = ((getCurrentBlockPS7132rS7192)((function))));
                IRBlock_s *thenBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (thenBlockID)));
                IRBlock_s *elzeBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (elzeBlockID)));
                bool thenTerm = ((isTerminatedPS9435rB)((thenBlock)));
                bool elseTerm = ((isTerminatedPS9435rB)((elzeBlock)));
                if ((thenTerm) && (elseTerm)) {
                }

                else if ((thenTerm) && (!(elseTerm))) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else if ((!(thenTerm)) && (elseTerm)) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (thenBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (elzeBlockID)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }
            }
            goto after_7264;
        }
    }
    {
        succ_4733_ &= (tmp_7264_->tag == 7);
        ParsedExpr_s **cond = &tmp_7264_->payload.variant7._0;
        succ_4733_ &= true;
        ParsedStmt_s **body = &tmp_7264_->payload.variant7._1;
        succ_4733_ &= true;
        if (succ_4733_) {
            {
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (condBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (condReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*body)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
            }
            goto after_7264;
        }
    }
    {
        succ_4749_ &= (tmp_7264_->tag == 13);
        ParsedPattern_s **pat = &tmp_7264_->payload.variant13._0;
        succ_4749_ &= true;
        ParsedExpr_s **expr = &tmp_7264_->payload.variant13._1;
        succ_4749_ &= true;
        ParsedBlock_s **block = &tmp_7264_->payload.variant13._2;
        succ_4749_ &= true;
        if (succ_4749_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                IRBlockID_s jump = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (jump), (after)));
                ((setCurrentBlockPS7132S7192rN)((function), (jump)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (after)));
                ((leaveScopePS7132rusz)((function)));
            }
            goto after_7264;
        }
    }
    {
        succ_4765_ &= (tmp_7264_->tag == 14);
        ParsedPattern_s **pat = &tmp_7264_->payload.variant14._0;
        succ_4765_ &= true;
        ParsedExpr_s **expr = &tmp_7264_->payload.variant14._1;
        succ_4765_ &= true;
        ParsedBlock_s **block = &tmp_7264_->payload.variant14._2;
        succ_4765_ &= true;
        ParsedBlock_s **elze = &tmp_7264_->payload.variant14._3;
        succ_4765_ &= true;
        if (succ_4765_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                IRBlockID_s jumpTrue = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s jumpFalse = ((appendBlockPS7132rS7192)((function)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (jumpTrue), (jumpFalse)));
                ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                ((jumpTrue) = ((getCurrentBlockPS7132rS7192)((function))));
                ((leaveScopePS7132rusz)((function)));
                ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*elze)));
                ((jumpFalse) = ((getCurrentBlockPS7132rS7192)((function))));
                IRBlock_s *jumpTrueBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (jumpTrue)));
                IRBlock_s *jumpFalseBlock = ((getBlockByIDPS7132S7192rPS9435)((function), (jumpFalse)));
                bool jumpTrueTerm = ((isTerminatedPS9435rB)((jumpTrueBlock)));
                bool jumpFalseTerm = ((isTerminatedPS9435rB)((jumpFalseBlock)));
                if ((jumpTrueTerm) && (jumpFalseTerm)) {
                }

                else if ((jumpTrueTerm) && (!(jumpFalseTerm))) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else if ((!(jumpTrueTerm)) && (jumpFalseTerm)) {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }

                else {
                    IRBlockID_s after = ((appendBlockPS7132rS7192)((function)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpTrue)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (jumpFalse)));
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (after)));
                    ((setCurrentBlockPS7132S7192rN)((function), (after)));
                }
            }
            goto after_7264;
        }
    }
    {
        succ_4792_ &= (tmp_7264_->tag == 15);
        ParsedPattern_s **pat = &tmp_7264_->payload.variant15._0;
        succ_4792_ &= true;
        ParsedExpr_s **expr = &tmp_7264_->payload.variant15._1;
        succ_4792_ &= true;
        ParsedBlock_s **block = &tmp_7264_->payload.variant15._2;
        succ_4792_ &= true;
        if (succ_4792_) {
            {
                usize scope = ((enterScopePS7132rusz)((function)));
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (condBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*expr), (false)));
                RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (result), (*pat), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((stmt)->span), (patReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeBlockPS9562PS7132PS7247rN)((this), (function), (*block)));
                IRBlock_s *curr = ((getCurrentBlockAsRefPS7132rPS9435)((function)));
                if (!((isTerminatedPS9435rB)((curr)))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
                ((leaveScopePS7132rusz)((function)));
            }
            goto after_7264;
        }
    }
    {
        succ_4809_ &= (tmp_7264_->tag == 8);
        ParsedStmt_s **init = &tmp_7264_->payload.variant8._0;
        succ_4809_ &= true;
        ParsedExpr_s **cond = &tmp_7264_->payload.variant8._1;
        succ_4809_ &= true;
        ParsedExpr_s **step = &tmp_7264_->payload.variant8._2;
        succ_4809_ &= true;
        ParsedStmt_s **body = &tmp_7264_->payload.variant8._3;
        succ_4809_ &= true;
        if (succ_4809_) {
            {
                IRBlockID_s initBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s condBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s stepBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s bodyBlock = ((appendBlockPS7132rS7192)((function)));
                IRBlockID_s afterBlock = ((appendBlockPS7132rS7192)((function)));
                ((pushLoopBlocksPS7132S7192S7192rN)((function), (stepBlock), (afterBlock)));
                ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (initBlock)));
                usize scope = ((enterScopePS7132rusz)((function)));
                ((setCurrentBlockPS7132S7192rN)((function), (initBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*init)));
                if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((*init)->span), (condBlock)));
                }

                ((setCurrentBlockPS7132S7192rN)((function), (condBlock)));
                RegIndex_s condReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*cond), (false)));
                ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((*cond)->span), (condReg), (bodyBlock), (afterBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (stepBlock)));
                ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*step), (false)));
                ((buildBrPS7132S8951S7192rN)((function), ((*step)->span), (condBlock)));
                ((setCurrentBlockPS7132S7192rN)((function), (bodyBlock)));
                ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (*body)));
                if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
                    ((buildBrPS7132S8951S7192rN)((function), ((*body)->span), (stepBlock)));
                }

                usize after = ((leaveScopePS7132rusz)((function)));
                ((assertBPcrN)(((scope) == (after)), ("Scope imbalance in for-loop")));
                ((setCurrentBlockPS7132S7192rN)((function), (afterBlock)));
                ((popLoopBlocksPS7132rN)((function)));
            }
            goto after_7264;
        }
    }
    {
        succ_4820_ &= (tmp_7264_->tag == 9);
        if (succ_4820_) {
            {
                if (!((buildBreakPS7132S8951rB)((function), ((stmt)->span)))) {
                    ((todo_with_msgPcrN)(("break outside of loop")));
                }
            }
            goto after_7264;
        }
    }
    {
        succ_4823_ &= (tmp_7264_->tag == 10);
        if (succ_4823_) {
            {
                if (!((buildContinuePS7132S8951rB)((function), ((stmt)->span)))) {
                    ((todo_with_msgPcrN)(("continue outside of loop")));
                }
            }
            goto after_7264;
        }
    }
    {
        succ_4829_ &= (tmp_7264_->tag == 11);
        succ_4829_ &= true;
        succ_4829_ &= true;
        succ_4829_ &= true;
        if (succ_4829_) {
            {
                ((generateBytecodeMatchStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
            }
            goto after_7264;
        }
    }
    {
        succ_4834_ &= (tmp_7264_->tag == 12);
        ParsedExpr_s **fn = &tmp_7264_->payload.variant12._0;
        succ_4834_ &= true;
        ParsedExprList_s *args = &tmp_7264_->payload.variant12._1;
        succ_4834_ &= true;
        if (succ_4834_) {
            {
                Type_u *retType = ((getReturnTypePU5175rPU5175)(((getTypePU9661rPU5175)((&((*fn)->typeState))))));
                ((assertBPcrN)((((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))), ("Expected Inline Assembly function to return ASMContext")));
                RegIndexList_s irArgs = ((RegIndexList_s){0});
                RegIndex_s retPtr = ((RegIndex_s){0});
                {
                    ((retPtr) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType))))));
                    ((startComptimePS7132rN)((function)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((stmt)->span), (retPtr), ((getSizeInBytesPU5175rusz)((retType)))));
                    ((endComptimePS7132rN)((function)));
                    ((pushPS9911S6939rN)((&(irArgs)), (retPtr)));
                }

                SubStr_s IR_VALUE = ((BUILD_A_KEYWORDPcrS7720)(("IRValue")));
                SubStr_s ASM_FILE = ((BUILD_A_KEYWORDPcrS7720)(("asm.bufo")));
                TypeLookup_s lookup = ((TypeLookup_s){0});
                TypeLookupList_s unions = ((searchAllFilesForTypeNamePS7791PS7720rS1581)(((this)->lookup), (&(IR_VALUE))));
                UnionLookup_s *context = (NULL);
                for (usize i = ((usize)(0llu)); ((i) < ((unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    TypeLookup_s *l = ((atPS1581uszrPS6177)((&(unions)), (i)));
                    if (((l)->kind) == (TYPE_LOOKUP_UNION)) {
                        UnionLookup_s *u = ((UnionLookup_s *)(((l)->actual)));
                        ParsedUnionDecl_s *decl = ((u)->global);
                        if (!(((decl)->parent).isFile))
                            continue;
                        ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
                        String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
                        String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
                        ((dropPS0540rN)((&(filePath))));
                        SubStr_s tmp_37793 = ((asSubStrPS0540rS7720)((&(fileName))));

                        if ((equalsPS7720PS7720rB)((&tmp_37793), (&(ASM_FILE)))) {
                            ((assertBPcrN)(((context) == (NULL)), ("How did we find another asm.bufo?")));
                            ((context) = (u));
                        }

                        ((dropPS0540rN)((&(fileName))));
                    }
                }

                ((assertBPcrN)(((context) != (NULL)), ("Could not find IRValue!")));
                Type_u *regValueType = ((context)->type);
                for (usize i = ((usize)(0llu)); ((i) < ((*args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&(*args)), (i))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (arg), (false)));
                    ((startComptimePS7132rN)((function)));
                    RegIndex_s regValue = ((allocateRegisterPS7132PU5175rS6939)((function), (regValueType)));
                    ((buildIntoIRValuePS7132S8951S6939S6939rN)((function), ((arg)->span), (regValue), (result)));
                    ((pushPS9911S6939rN)((&(irArgs)), ((prepareArgumentPS9562PS7132S8951S6939PU5175rS6939)((this), (function), ((arg)->span), (regValue), (regValueType)))));
                    ((endComptimePS7132rN)((function)));
                }

                ((startComptimePS7132rN)((function)));
                RegIndex_s base = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*fn), (false)));
                RegIndex_s reg = ((prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939)((this), ((stmt)->span), (function), (base), (irArgs), (retType), (retPtr), (false)));
                ((endComptimePS7132rN)((function)));
                ((buildEmitAssemblyPS7132S8951S6939PU5175rN)((function), ((stmt)->span), (reg), ((getTypePU9661rPU5175)((&((*fn)->typeState))))));
            }
            goto after_7264;
        }
    }
    {
        StmtData_u **unknown = &tmp_7264_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeStmt: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7264;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7264:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none generateBytecodeMatchStmtPS9562PS7132PS1100rN(IRGen_s *this, IRFunc_s *function, ParsedStmt_s *match) {
    ParsedExpr_s *expr = (NULL);
    ParsedPatternList_s *patterns = (NULL);
    ParsedStmtList_s *stmts = (NULL);
    bool succ_4875_ = true;

    StmtData_u *tmp_7274_ = (&((match)->data));
    {
        succ_4875_ &= (tmp_7274_->tag == 11);
        ParsedExpr_s **_expr = &tmp_7274_->payload.variant11._0;
        succ_4875_ &= true;
        ParsedPatternList_s *_patterns = &tmp_7274_->payload.variant11._1;
        succ_4875_ &= true;
        ParsedStmtList_s *_stmts = &tmp_7274_->payload.variant11._2;
        succ_4875_ &= true;
        if (succ_4875_) {
            {
                ((expr) = (*_expr));
                ((patterns) = (&(*_patterns)));
                ((stmts) = (&(*_stmts)));
            }
            goto after_7274;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7274;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7274:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBrN)((((patterns)->length) == ((stmts)->length))));
    TCState_u state = ((match)->typeState);
    ((assertBrN)(((isPatternPU9661rB)((&(state))))));
    PatState_s patState = ((getPatStatePU9661rS1259)((&(state))));
    ((assertBPcrN)(((patState).complete), ("generateBytecodeMatchStmt: Non-exhaustive pattern")));
    RegIndex_s exprReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (expr), (false)));
    IRBlockID_s end = ((appendBlockPS7132rS7192)((function)));
    for (usize i = ((usize)(0llu)); ((i) < ((patterns)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *pat = (*((atPS1982uszrPPS1826)((patterns), (i))));
        ParsedStmt_s *stmt = (*((atPS3288uszrPPS1100)((stmts), (i))));
        usize scope = ((enterScopePS7132rusz)((function)));
        RegIndex_s patReg = ((generateBytecodePatternPS9562PS7132S6939PS1826BrS6939)((this), (function), (exprReg), (pat), (false)));
        IRBlockID_s matchBlock = ((appendBlockPS7132rS7192)((function)));
        IRBlockID_s nextBlock = ((appendBlockPS7132rS7192)((function)));
        ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((match)->span), (patReg), (matchBlock), (nextBlock)));
        ((setCurrentBlockPS7132S7192rN)((function), (matchBlock)));
        ((generateBytecodeStmtPS9562PS7132PS1100rN)((this), (function), (stmt)));
        if (!((isTerminatedPS9435rB)(((getCurrentBlockAsRefPS7132rPS9435)((function)))))) {
            ((buildBrPS7132S8951S7192rN)((function), ((stmt)->span), (end)));
        }

        ((setCurrentBlockPS7132S7192rN)((function), (nextBlock)));
        usize after = ((leaveScopePS7132rusz)((function)));
        ((assertBPcrN)(((scope) == (after)), ("Scope imbalance in match")));
    }

    usize funcID = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("unreachablePcrN"), ("prelude.bufo")));
    RegIndexList_s args = ((RegIndexList_s){0});
    {
        RegIndex_s err = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))));
        String_s s = ((copyPS0540rS0540)((&((function)->name))));
        String_s _s = ((toStringPS8951rS0540)((&((match)->span))));
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": FATAL COMPILER ERROR: match-statement reached guard block!\n")));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": This should never happen, as all match-patterns eventually lead to the real block.\n")));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": Please submit a bug report.\n")));
        ((dropPS0540rN)((&(_s))));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((match)->span), (err), ((asSubStrPS0540rS7720)((&(s))))));
        ((pushPS9911S6939rN)((&(args)), (err)));
    }

    ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((match)->span), (funcID),
                                                                 ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
    ((buildUnreachablePS7132S8951rN)((function), ((match)->span)));
    ((setCurrentBlockPS7132S7192rN)((function), (end)));
}
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory) {
    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (pat), (inOrigMemory), (false)));
}
RegIndex_s generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, bool inOrigMemory, bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    RegIndex_s success = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))));
    bool succ_4905_ = true;
    bool succ_4910_ = true;
    bool succ_4917_ = true;
    bool succ_4920_ = true;
    bool succ_4925_ = true;
    bool succ_4923_ = true;
    bool succ_4930_ = true;
    bool succ_4928_ = true;
    bool succ_4936_ = true;
    bool succ_4941_ = true;
    bool succ_4946_ = true;
    bool succ_4953_ = true;
    bool succ_4956_ = true;
    bool succ_4960_ = true;

    Pattern_u *tmp_7417_ = (&((pat)->data));
    {
        succ_4905_ &= (tmp_7417_->tag == 2);
        Token_s *name = &tmp_7417_->payload.variant2._0;
        succ_4905_ &= true;
        if (succ_4905_) {
            {
                if (isComptimeVariable) {
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (expr), (true)));
                }

                else if (inOrigMemory) {
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (expr), (false)));
                }

                else {
                    RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
                    ((addVariablePS9562PS7132S8951PS7082S7720S6939BrN)((this), (function), ((pat)->span), ((lastPS9366rPS7082)((&((function)->scopes)))), ((*name).content), (allocReg), (false)));
                }

                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7417;
        }
    }
    {
        succ_4910_ &= (tmp_7417_->tag == 4);
        ParsedPattern_s **sub = &tmp_7417_->payload.variant4._0;
        succ_4910_ &= true;
        if (succ_4910_) {
            {
                ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Reference Pattern expected pointer type")));
                Type_u *under = ((getUnderlyingTypePU5175BrPU5175)((type), (false)));
                if ((isPointerPU5175rB)((under))) {
                    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (under)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (reg), (expr)));
                    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (reg), (*sub), (true), (isComptimeVariable)));
                }

                else {
                    return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (*sub), (true), (isComptimeVariable)));
                }
            }
            goto after_7417;
        }
    }
    {
        succ_4917_ &= (tmp_7417_->tag == 3);
        ParsedPattern_s **sub = &tmp_7417_->payload.variant3._0;
        succ_4917_ &= true;
        succ_4917_ &= true;
        if (succ_4917_) {
            {
                return ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (expr), (*sub), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7417;
        }
    }
    {
        succ_4920_ &= (tmp_7417_->tag == 10);
        if (succ_4920_) {
            {
                ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Null Pattern expected pointer type")));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((buildLoadNullPS7132S8951S6939rN)((function), ((pat)->span), (reg)));
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_INT_CMP_EQ), (success), (expr), (reg)));
            }
            goto after_7417;
        }
    }
    {
        succ_4925_ &= (tmp_7417_->tag == 9);
        succ_4923_ = tmp_7417_->payload.variant9._0 == true;
        succ_4925_ &= succ_4923_;
        if (succ_4925_) {
            {
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Boolean Pattern inOrigMemory expected pointer")));
                    ((assertBPcrN)(((isPointerToPU5175PU5175rB)((type), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}}))))),
                                   ("Boolean Pattern inOrigMemory expected pointer to bool")));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), ((getUnderlyingTypePU5175BrPU5175)((type), (false)))));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (_expr)));
                }

                else {
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (expr)));
                }
            }
            goto after_7417;
        }
    }
    {
        succ_4930_ &= (tmp_7417_->tag == 9);
        succ_4928_ = tmp_7417_->payload.variant9._0 == false;
        succ_4930_ &= succ_4928_;
        if (succ_4930_) {
            {
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("Boolean Pattern inOrigMemory expected pointer")));
                    ((assertBPcrN)(((isPointerToPU5175PU5175rB)((type), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}}))))),
                                   ("Boolean Pattern inOrigMemory expected pointer to bool")));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), ((getUnderlyingTypePU5175BrPU5175)((type), (false)))));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((buildLogicalNotPS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (_expr)));
                }

                else {
                    ((buildLogicalNotPS7132S8951S6939S6939rN)((function), ((pat)->span), (success), (expr)));
                }
            }
            goto after_7417;
        }
    }
    {
        succ_4936_ &= (tmp_7417_->tag == 5);
        succ_4936_ &= true;
        succ_4936_ &= true;
        if (succ_4936_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                ((generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7417;
        }
    }
    {
        succ_4941_ &= (tmp_7417_->tag == 6);
        succ_4941_ &= true;
        ParsedPattern_s **sub = &tmp_7417_->payload.variant6._1;
        succ_4941_ &= true;
        if (succ_4941_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                bool ptr = ((isPointerPU5175rB)((type)));
                if (ptr)
                    ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
                if ((isUnionPU5175rB)((type))) {
                    ((generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), ((ptr) || (inOrigMemory)), (isComptimeVariable)));
                }

                else if ((isStructPU5175rB)((type))) {
                    ((generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (*sub), (success), ((ptr) || (inOrigMemory)), (isComptimeVariable)));
                }

                else {
                    ((unreachablePcrN)(("generateBytecodePattern(PATTERN_PATH): Exhaustive handling of variations")));
                }
            }
            goto after_7417;
        }
    }
    {
        succ_4946_ &= (tmp_7417_->tag == 1);
        Token_s *ident = &tmp_7417_->payload.variant1._0;
        succ_4946_ &= true;
        if (succ_4946_) {
            {
                RegIndex_s number = ((RegIndex_s){0});
                Type_u *real = (type);
                if (inOrigMemory) {
                    ((assertBPcrN)(((isPointerPU5175rB)((real))), ("generateBytecodePattern: Number inOrigMemory")));
                    ((real) = ((getUnderlyingTypePU5175BrPU5175)((real), (false))));
                    RegIndex_s _expr = ((allocateRegisterPS7132PU5175rS6939)((function), (real)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (_expr), (expr)));
                    ((expr) = (_expr));
                }

                ((number) = ((allocateRegisterPS7132PU5175rS6939)((function), (real))));
                ((loadLiteralPS9562PS7132S6939PS6070rS6939)((this), (function), (number), (&(*ident))));
                if ((isIntegerPU5175rB)((real))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_INT_CMP_EQ), (success), (expr), (number)));
                }

                else if ((isFloatPU5175rB)((real))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((pat)->span), (INSTR_FLOAT_CMP_EQ), (success), (expr), (number)));
                }

                else {
                    ((unreachablePcrN)(("Exhaustive handling of number types in IRGen.generateBytecodePattern")));
                }
            }
            goto after_7417;
        }
    }
    {
        succ_4953_ &= (tmp_7417_->tag == 0);
        if (succ_4953_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7417;
        }
    }
    {
        succ_4956_ &= (tmp_7417_->tag == 8);
        if (succ_4956_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
            }
            goto after_7417;
        }
    }
    {
        succ_4960_ &= (tmp_7417_->tag == 7);
        succ_4960_ &= true;
        if (succ_4960_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((pat)->span), (success), ((usize)(1llu))));
                ((generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN)((this), (function), (expr), (pat), (success), (inOrigMemory), (isComptimeVariable)));
            }
            goto after_7417;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of patterns in IRGen.generateBytecodePattern")));
            }
            goto after_7417;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7417:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (success);
}
none generateBytecodePatternTuplePS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    bool succ_4966_ = true;

    Pattern_u tmp_7421_ = ((pat)->data);
    succ_4966_ &= (tmp_7421_.tag == 7);
    ParsedPatternList_s *subPatterns = &tmp_7421_.payload.variant7._0;
    succ_4966_ &= true;
    if (!succ_4966_) {
        ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple pattern")));
    };
    if (inOrigMemory) {
        bool succ_4972_ = true;
        bool succ_4969_ = true;

        Type_u *tmp_7423_ = (type);
        succ_4972_ &= (tmp_7423_->tag == 4);
        succ_4969_ &= (tmp_7423_->payload.variant4._0->tag == 10);
        TypeList_s *elems = &tmp_7423_->payload.variant4._0->payload.variant10._0;
        succ_4969_ &= true;
        succ_4972_ &= succ_4969_;
        if (!succ_4972_) {
            ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple ptr")));
        };
        for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
            Type_u *fieldType = ((intoPointerPU5175rPU5175)(((((*elems).elements))[(i)])));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (subExpr), (expr), (i)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (true), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_38736 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_38736)))))
                break;
        }

    }

    else {
        bool succ_4982_ = true;

        Type_u *tmp_7437_ = (type);
        succ_4982_ &= (tmp_7437_->tag == 10);
        TypeList_s *elems = &tmp_7437_->payload.variant10._0;
        succ_4982_ &= true;
        if (!succ_4982_) {
            ((unreachablePcrN)(("generateBytecodePatternTuple: Not a tuple type")));
        };
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        ((expr) = (allocReg));
        for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
            Type_u *fieldType = ((((*elems).elements))[(i)]);
            RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (fieldPtr), (expr), (i)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (subExpr), (fieldPtr)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (false), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_38848 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_38848)))))
                break;
        }
    }
}
none generateBytecodePatternStructPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                   bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    ParsedPatternList_s *subPatterns = (NULL);
    bool succ_4998_ = true;

    Pattern_u *tmp_7463_ = (&((pat)->data));
    {
        succ_4998_ &= (tmp_7463_->tag == 5);
        succ_4998_ &= true;
        ParsedPatternList_s *patterns = &tmp_7463_->payload.variant5._1;
        succ_4998_ &= true;
        if (succ_4998_) {
            {
                ((subPatterns) = (&(*patterns)));
            }
            goto after_7463;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7463;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7463:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (inOrigMemory) {
        ParsedStructDecl_s *decl = (NULL);
        bool succ_5008_ = true;
        bool succ_5005_ = true;

        Type_u *tmp_7469_ = (type);
        {
            succ_5008_ &= (tmp_7469_->tag == 4);
            succ_5005_ &= (tmp_7469_->payload.variant4._0->tag == 7);
            ParsedStructDecl_s **_decl = &tmp_7469_->payload.variant4._0->payload.variant7._0;
            succ_5005_ &= true;
            succ_5008_ &= succ_5005_;
            if (succ_5008_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7469;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("In Memory Struct Pattern expected pointer to struct type")));
                }
                goto after_7469;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7469:
        (void)0; // error: label at end of compound statement is a C23 extension
        for (usize i = ((usize)(0llu)); ((i) < (((decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((subPatterns), (i))));
            ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (i)));
            Type_u *fieldType = ((intoPointerPU5175rPU5175)(((getTypePU9661rPU5175)((&((fieldNode)->typeState))))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (subExpr), (expr), (i)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (true), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_38952 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_38952)))))
                break;
        }

    }

    else {
        ParsedStructDecl_s *decl = (NULL);
        bool succ_5022_ = true;

        Type_u *tmp_7488_ = (type);
        {
            succ_5022_ &= (tmp_7488_->tag == 7);
            ParsedStructDecl_s **_decl = &tmp_7488_->payload.variant7._0;
            succ_5022_ &= true;
            if (succ_5022_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7488;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Struct Pattern expected struct type")));
                }
                goto after_7488;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7488:
        (void)0; // error: label at end of compound statement is a C23 extension
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        ((expr) = (allocReg));
        for (usize i = ((usize)(0llu)); ((i) < (((decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((subPatterns), (i))));
            ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (i)));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
            RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
            RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
            ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((pat)->span), (fieldPtr), (expr), (i)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((pat)->span), (subExpr), (fieldPtr)));
            RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subPat), (false), (isComptimeVariable)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
            Pattern_u tmp_39077 = (((Pattern_u){.tag = 8, .payload = {0}}));

            if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_39077)))))
                break;
        }
    }
}
none generateBytecodePatternUnionPS9562PS7132S6939PS1826S6939BBrN(IRGen_s *this, IRFunc_s *function, RegIndex_s expr, ParsedPattern_s *pat, RegIndex_s success, bool inOrigMemory,
                                                                  bool isComptimeVariable) {
    Type_u *type = (((getRegisterPS7132S6939rPS1534)((function), (expr)))->typ);
    Token_s *name = (NULL);
    ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
    bool succ_5048_ = true;
    bool succ_5045_ = true;
    bool succ_5044_ = true;
    bool succ_5060_ = true;
    bool succ_5057_ = true;
    bool succ_5056_ = true;

    Pattern_u *tmp_7519_ = (&((pat)->data));
    {
        succ_5048_ &= (tmp_7519_->tag == 6);
        succ_5048_ &= true;
        succ_5045_ &= true;
        succ_5045_ &= true;
        succ_5044_ &= (tmp_7519_->payload.variant6._1->data.tag == 2);
        Token_s *ident = &tmp_7519_->payload.variant6._1->data.payload.variant2._0;
        succ_5044_ &= true;
        succ_5045_ &= succ_5044_;
        succ_5048_ &= succ_5045_;
        if (succ_5048_) {
            {
                ((name) = (&(*ident)));
            }
            goto after_7519;
        }
    }
    {
        succ_5060_ &= (tmp_7519_->tag == 6);
        succ_5060_ &= true;
        succ_5057_ &= true;
        succ_5057_ &= true;
        succ_5056_ &= (tmp_7519_->payload.variant6._1->data.tag == 5);
        Token_s *ident = &tmp_7519_->payload.variant6._1->data.payload.variant5._0;
        succ_5056_ &= true;
        ParsedPatternList_s *pats = &tmp_7519_->payload.variant6._1->data.payload.variant5._1;
        succ_5056_ &= true;
        succ_5057_ &= succ_5056_;
        succ_5060_ &= succ_5057_;
        if (succ_5060_) {
            {
                ((name) = (&(*ident)));
                ((subPatterns) = (*pats));
            }
            goto after_7519;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7519;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7519:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s tagMatch = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))));
    if (inOrigMemory) {
        ParsedUnionDecl_s *decl = (NULL);
        bool succ_5074_ = true;
        bool succ_5071_ = true;

        Type_u *tmp_7528_ = (type);
        {
            succ_5074_ &= (tmp_7528_->tag == 4);
            succ_5071_ &= (tmp_7528_->payload.variant4._0->tag == 8);
            ParsedUnionDecl_s **_decl = &tmp_7528_->payload.variant4._0->payload.variant8._0;
            succ_5071_ &= true;
            succ_5071_ &= true;
            succ_5074_ &= succ_5071_;
            if (succ_5074_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7528;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("In Memory Union Pattern expected pointer type")));
                }
                goto after_7528;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7528:
        (void)0; // error: label at end of compound statement is a C23 extension
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        RegIndex_s tagPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tagType)))));
        RegIndex_s tagVal = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ParsedUnionVariant_s *variant = (NULL);
        bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((decl), (name), (&(variant))));
        ((assertBrN)((found)));
        RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (tmp), (expr)));
        {
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (tagReg), (tagType), ((getVariantTagPS0997PS3506rusz)((decl), (variant)))));
            ((buildMovePS7132S8951S6939S6939rN)((function), ((name)->span), (tagPtr), (tmp)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((name)->span), (tagVal), (tagPtr)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_CMP_EQ), (tagMatch), (tagReg), (tagVal)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_LOGICAL_AND), (success), (success), (tagMatch)));
            usize offset = ((usize)(1llu));
            if ((((decl)->variants).length) >= ((usize)(256llu)))
                ((offset) = ((usize)(2llu)));
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (sizeReg), (usizeType), (offset)));
            ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
            ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
        }

        bool succ_5090_ = true;
        bool succ_5088_ = true;

        {
            tuple_1044 tmp_7573_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_5088_ = tmp_7573_._0 == true;
            succ_5090_ &= succ_5088_;
            ParsedTypeNodeList_s **fields = &tmp_7573_._1;
            succ_5090_ &= true;

            if (succ_5090_) {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subSubPat = ((((subPatterns).elements))[(i)]);
                    ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                    usize fieldSize = ((getSizeInBytesPU5175rusz)((fieldType)));
                    RegIndex_s subPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
                    ((buildMovePS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (subPtr), (tmp)));
                    RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subPtr), (subSubPat), (true), (isComptimeVariable)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
                    Pattern_u tmp_39369 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_39369)))))
                        break;
                    if ((i) != (((subPatterns).length) - ((usize)(1llu)))) {
                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((subSubPat)->span), (sizeReg), (usizeType), (fieldSize)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                    }
                }
            }
        }

    }

    else {
        ParsedUnionDecl_s *decl = (NULL);
        bool succ_5104_ = true;

        Type_u *tmp_7580_ = (type);
        {
            succ_5104_ &= (tmp_7580_->tag == 8);
            ParsedUnionDecl_s **_decl = &tmp_7580_->payload.variant8._0;
            succ_5104_ &= true;
            succ_5104_ &= true;
            if (succ_5104_) {
                {
                    ((decl) = (*_decl));
                }
                goto after_7580;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Union Pattern expected union type")));
                }
                goto after_7580;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_7580:
        (void)0; // error: label at end of compound statement is a C23 extension
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        RegIndex_s tagPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tagType)))));
        RegIndex_s tagVal = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ParsedUnionVariant_s *variant = (NULL);
        bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((decl), (name), (&(variant))));
        ((assertBrN)((found)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((pat)->span), (allocReg), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((pat)->span), (allocReg), (expr)));
        RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
        ((buildMovePS7132S8951S6939S6939rN)((function), ((pat)->span), (tmp), (allocReg)));
        {
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (tagReg), (tagType), ((getVariantTagPS0997PS3506rusz)((decl), (variant)))));
            ((buildMovePS7132S8951S6939S6939rN)((function), ((name)->span), (tagPtr), (allocReg)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), ((name)->span), (tagVal), (tagPtr)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_CMP_EQ), (tagMatch), (tagReg), (tagVal)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_LOGICAL_AND), (success), (success), (tagMatch)));
            usize offset = ((usize)(1llu));
            if ((((decl)->variants).length) >= ((usize)(256llu)))
                ((offset) = ((usize)(2llu)));
            ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((name)->span), (sizeReg), (usizeType), (offset)));
            ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
            ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((name)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
            ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((name)->span), (tmp), (tmp)));
        }

        ((expr) = (allocReg));
        bool succ_5121_ = true;
        bool succ_5119_ = true;

        {
            tuple_1044 tmp_7632_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_5119_ = tmp_7632_._0 == true;
            succ_5121_ &= succ_5119_;
            ParsedTypeNodeList_s **fields = &tmp_7632_._1;
            succ_5121_ &= true;

            if (succ_5121_) {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subSubPat = ((((subPatterns).elements))[(i)]);
                    ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                    Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                    usize fieldSize = ((getSizeInBytesPU5175rusz)((fieldType)));
                    RegIndex_s subAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
                    RegIndex_s subExpr = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((subSubPat)->span), (subAlloc), (fieldSize)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((subSubPat)->span), (sizeReg), (usizeType), (fieldSize)));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((subSubPat)->span), (tmp), (subAlloc), (sizeReg)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (subExpr), (subAlloc)));
                    RegIndex_s sub = ((generateBytecodePatternPS9562PS7132S6939PS1826BBrS6939)((this), (function), (subExpr), (subSubPat), (false), (isComptimeVariable)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_LOGICAL_AND), (success), (success), (sub)));
                    Pattern_u tmp_39709 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_39709)))))
                        break;
                    if ((i) != (((subPatterns).length) - ((usize)(1llu)))) {
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((subSubPat)->span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((subSubPat)->span), (tmp), (tmp)));
                    }
                }
            }
        }
    }
}
RegIndex_s generateBytecodeExprPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    if ((expr)->ignored)
        return ((RegIndex_s){0});
    ((assertBPcrN)(((isSuccessPU9661rB)((&((expr)->typeState)))), ("Expected valid Expr type in IRGen")));
    bool succ_5133_ = true;
    bool succ_5137_ = true;
    bool succ_5141_ = true;
    bool succ_5145_ = true;
    bool succ_5149_ = true;
    bool succ_5153_ = true;
    bool succ_5157_ = true;
    bool succ_5161_ = true;
    bool succ_5165_ = true;
    bool succ_5179_ = true;
    bool succ_5206_ = true;
    bool succ_5211_ = true;
    bool succ_5214_ = true;
    bool succ_5217_ = true;
    bool succ_5228_ = true;
    bool succ_5231_ = true;
    bool succ_5235_ = true;
    bool succ_5244_ = true;
    bool succ_5257_ = true;
    bool succ_5272_ = true;
    bool succ_5289_ = true;

    ExprData_u *tmp_7795_ = (&((expr)->data));
    {
        succ_5133_ &= (tmp_7795_->tag == 0);
        succ_5133_ &= true;
        if (succ_5133_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5137_ &= (tmp_7795_->tag == 1);
        succ_5137_ &= true;
        if (succ_5137_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5141_ &= (tmp_7795_->tag == 2);
        succ_5141_ &= true;
        if (succ_5141_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5145_ &= (tmp_7795_->tag == 3);
        succ_5145_ &= true;
        if (succ_5145_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5149_ &= (tmp_7795_->tag == 4);
        IdentExpr_s *ident = &tmp_7795_->payload.variant4._0;
        succ_5149_ &= true;
        if (succ_5149_) {
            {
                return ((generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939)((this), (function), (&(*ident)), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5153_ &= (tmp_7795_->tag == 5);
        UnaryExpr_u *unary = &tmp_7795_->payload.variant5._0;
        succ_5153_ &= true;
        if (succ_5153_) {
            {
                return ((generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939)((this), (function), ((expr)->span), (&(*unary)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5157_ &= (tmp_7795_->tag == 6);
        BinaryExpr_u *binary = &tmp_7795_->payload.variant6._0;
        succ_5157_ &= true;
        if (succ_5157_) {
            {
                return ((generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939)((this), (function), (&(*binary)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5161_ &= (tmp_7795_->tag == 7);
        CallExpr_s *call = &tmp_7795_->payload.variant7._0;
        succ_5161_ &= true;
        if (succ_5161_) {
            {
                return ((generateBytecodeExprCallPS9562PS7132PS3328BrS6939)((this), (function), (&(*call)), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5165_ &= (tmp_7795_->tag == 8);
        ParsedTypeNode_s **typeNode = &tmp_7795_->payload.variant8._0;
        succ_5165_ &= true;
        if (succ_5165_) {
            {
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                Type_u *target = ((getTypePU9661rPU5175)((&((*typeNode)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
                usize size = ((getSizeInBytesPU5175rusz)((target)));
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (reg), (t), (size)));
                if (needsPtr) {
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5179_ &= (tmp_7795_->tag == 9);
        StructExpr_s *init = &tmp_7795_->payload.variant9._0;
        succ_5179_ &= true;
        if (succ_5179_) {
            {
                Type_u *strukt = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                ParsedStructDecl_s *structDecl = (NULL);
                bool succ_5187_ = true;

                Type_u *tmp_7673_ = (strukt);
                {
                    succ_5187_ &= (tmp_7673_->tag == 7);
                    ParsedStructDecl_s **_decl = &tmp_7673_->payload.variant7._0;
                    succ_5187_ &= true;
                    if (succ_5187_) {
                        {
                            ((structDecl) = (*_decl));
                        }
                        goto after_7673;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected Struct Type in EXPR_STRUCT_INIT")));
                        }
                        goto after_7673;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_7673:
                (void)0; // error: label at end of compound statement is a C23 extension
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (strukt)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < (((*init).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*init).context)), (i)));
                    ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*init).context)), (i)));
                    usize index = ((getFieldIndexPS5521PS7720rusz)((structDecl), (&((name).content))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((field)->span), (reg), (index), (result)));
                }

                if (needsPtr) {
                    RegIndex_s structAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((strukt)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (structAlloc), ((getSizeInBytesPU5175rusz)((strukt)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (structAlloc), (reg)));
                    return (structAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5206_ &= (tmp_7795_->tag == 10);
        UnionExpr_u *init = &tmp_7795_->payload.variant10._0;
        succ_5206_ &= true;
        if (succ_5206_) {
            {
                return (
                    (generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939)((this), (function), ((expr)->span), (&(*init)), ((getTypePU9661rPU5175)((&((expr)->typeState)))), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5211_ &= (tmp_7795_->tag == 11);
        succ_5211_ &= true;
        succ_5211_ &= true;
        if (succ_5211_) {
            {
                return ((generateBytecodeExprAsPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5214_ &= (tmp_7795_->tag == 12);
        if (succ_5214_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5217_ &= (tmp_7795_->tag == 13);
        if (succ_5217_) {
            {
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                usize size = ((getSizeInBytesPU5175rusz)((t)));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
                ((buildLoadBlankPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), (size)));
                if (needsPtr) {
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5228_ &= (tmp_7795_->tag == 14);
        if (succ_5228_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5231_ &= (tmp_7795_->tag == 15);
        if (succ_5231_) {
            {
                return ((generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7795;
        }
    }
    {
        succ_5235_ &= (tmp_7795_->tag == 16);
        ParsedFuncDecl_s **decl = &tmp_7795_->payload.variant16._0;
        succ_5235_ &= true;
        if (succ_5235_) {
            {
                String_s name = ((getMangledNamePS4904rS0540)((*decl)));
                usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(name))));
                RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), ((getTypePU9661rPU5175)((&((*decl)->typeState))))));
                ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), ((expr)->span), (dst), (funcID)));
                return (dst);
            }
            goto after_7795;
        }
    }
    {
        succ_5244_ &= (tmp_7795_->tag == 17);
        ParsedTypeNode_s **typeNode = &tmp_7795_->payload.variant17._0;
        succ_5244_ &= true;
        if (succ_5244_) {
            {
                Type_u *target = ((getTypePU9661rPU5175)((&((*typeNode)->typeState))));
                Type_u *typeInfo = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((generateTypeInfoPS9562PS7132S8951PU5175rS6939)((this), (function), ((expr)->span), (target)));
                if (needsPtr) {
                    usize size = ((getSizeInBytesPU5175rusz)((typeInfo)));
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typeInfo)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5257_ &= (tmp_7795_->tag == 18);
        ParsedExpr_s **exprNode = &tmp_7795_->payload.variant18._0;
        succ_5257_ &= true;
        if (succ_5257_) {
            {
                RegIndex_s subExpr = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*exprNode), (true)));
                Type_u *target = ((getTypePU9661rPU5175)((&((*exprNode)->typeState))));
                Type_u *data = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (data)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(0llu)), (subExpr)));
                {
                    RegIndex_s ti = ((generateTypeInfoPS9562PS7132S8951PU5175rS6939)((this), (function), ((expr)->span), (target)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(1llu)), (ti)));
                }

                if (needsPtr) {
                    usize size = ((getSizeInBytesPU5175rusz)((data)));
                    RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((data)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), (size)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
                    return (tempAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5272_ &= (tmp_7795_->tag == 19);
        ParsedExprList_s *vals = &tmp_7795_->payload.variant19._0;
        succ_5272_ &= true;
        if (succ_5272_) {
            {
                Type_u *varType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                ((assertBPcrN)(((isVariadicTypePU5175rB)((varType))), ("ExprData::Variadic() is not variadic?")));
                Type_u *subType = ((getUnderlyingTypePU5175BrPU5175)((varType), (false)));
                usize count = ((*vals).length);
                Type_u *newType = ((intoArrayTypePU5175uszrPU5175)((subType), (count)));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (newType)));
                ((buildCreateArrayPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < ((*vals).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*((atPS7823uszrPPS2435)((&(*vals)), (i)))), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), (i), (result)));
                }

                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((newType)))));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (alloca), ((getSizeInBytesPU5175rusz)((newType)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (alloca), (reg)));
                Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (sizeReg), (usizeType), ((*vals).length)));
                ((reg) = ((allocateRegisterPS7132PU5175rS6939)((function), (varType))));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(0llu)), (alloca)));
                ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), ((usize)(1llu)), (sizeReg)));
                ((assertBPcrN)((!(needsPtr)), ("needsPtr for ExprData::Variadic?")));
                return (reg);
            }
            goto after_7795;
        }
    }
    {
        succ_5289_ &= (tmp_7795_->tag == 20);
        ParsedExprList_s *elems = &tmp_7795_->payload.variant20._0;
        succ_5289_ &= true;
        if (succ_5289_) {
            {
                Type_u *tuple = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (tuple)));
                ((buildCreateStructPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *e = ((((*elems).elements))[(i)]);
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (e), (false)));
                    ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((e)->span), (reg), (i), (result)));
                }

                if (needsPtr) {
                    RegIndex_s structAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((tuple)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (structAlloc), ((getSizeInBytesPU5175rusz)((tuple)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (structAlloc), (reg)));
                    return (structAlloc);
                }

                return (reg);
            }
            goto after_7795;
        }
    }
    {
        ExprData_u **unknown = &tmp_7795_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeExpr: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7795;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7795:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExpr")));
}
RegIndex_s generateTypeInfoPS9562PS7132S8951PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, Type_u *type) {
    usize index = ((index_of_typePS3131PU5175rusz)((&((this)->type_info_table)), (type)));
    if ((index) >= (((this)->type_info_table).length)) {
        String_s l = ((toStringPS8951rS0540)((&(span))));
        String_s t = ((toStringPU5175rS0540)((type)));
        (((fprintf))((stderr_), ("%s: %s: WEEWOO!!! Type Info for Type %s doesn\'t exist!!!\n"), ((l).buffer), (FATAL_STR), ((t).buffer)));
        (((C_exiti32rN))(((i32)(2))));
    }

    bool isGlobal = (false);
    IRScopeEntry_s *global_type_info_table = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((newSubStrOfStrLitPcrS7720)(("type_info_table")))), (&(isGlobal))));
    ((assertBPcrN)(((global_type_info_table) != (NULL)), ("generateTypeInfo: Could not find global type info table variable")));
    ((assertBPcrN)((isGlobal), ("generateTypeInfo: Global type info table is not global")));
    SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
    SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
    UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)(((this)->lookup), (&(FILE)), (&(NAME))));
    ((assertBPcrN)(((context) != (NULL)), ("generateTypeInfo: Could not find union context for TypeInfo")));
    Type_u *typeInfo = ((context)->type);
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s indexReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndexList_s indices = ((RegIndexList_s){0});
    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (indexReg), (usizeType), (index)));
    ((pushPS9911S6939rN)((&(indices)), (indexReg)));
    RegIndex_s info = ((allocateRegisterPS7132PU5175rS6939)((function), (typeInfo)));
    RegIndex_s info_ptr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typeInfo)))));
    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (span), (info_ptr), ((global_type_info_table)->ptr)));
    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (info_ptr), (info_ptr)));
    ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), (span), (info_ptr), (info_ptr), (indices)));
    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (info), (info_ptr)));
    return (info);
}
RegIndex_s generateBytecodeExprBinaryPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    bool succ_5323_ = true;
    bool succ_5327_ = true;
    bool succ_5331_ = true;
    bool succ_5335_ = true;
    bool succ_5339_ = true;
    bool succ_5343_ = true;
    bool succ_5347_ = true;
    bool succ_5351_ = true;
    bool succ_5355_ = true;
    bool succ_5359_ = true;
    bool succ_5363_ = true;
    bool succ_5367_ = true;
    bool succ_5371_ = true;
    bool succ_5375_ = true;
    bool succ_5379_ = true;
    bool succ_5383_ = true;
    bool succ_5387_ = true;
    bool succ_5391_ = true;
    bool succ_5395_ = true;
    bool succ_5399_ = true;

    BinaryExpr_u *tmp_7868_ = (expr);
    {
        succ_5323_ &= (tmp_7868_->tag == 0);
        succ_5323_ &= true;
        if (succ_5323_) {
            {
                return ((generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5327_ &= (tmp_7868_->tag == 1);
        succ_5327_ &= true;
        if (succ_5327_) {
            {
                return ((generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939)((this), (function), (expr), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5331_ &= (tmp_7868_->tag == 2);
        succ_5331_ &= true;
        if (succ_5331_) {
            {
                return ((generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939)((this), (function), (expr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5335_ &= (tmp_7868_->tag == 3);
        succ_5335_ &= true;
        if (succ_5335_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5339_ &= (tmp_7868_->tag == 4);
        succ_5339_ &= true;
        if (succ_5339_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5343_ &= (tmp_7868_->tag == 5);
        succ_5343_ &= true;
        if (succ_5343_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5347_ &= (tmp_7868_->tag == 6);
        succ_5347_ &= true;
        if (succ_5347_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5351_ &= (tmp_7868_->tag == 7);
        succ_5351_ &= true;
        if (succ_5351_) {
            {
                return ((generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        succ_5355_ &= (tmp_7868_->tag == 8);
        succ_5355_ &= true;
        if (succ_5355_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5359_ &= (tmp_7868_->tag == 9);
        succ_5359_ &= true;
        if (succ_5359_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5363_ &= (tmp_7868_->tag == 10);
        succ_5363_ &= true;
        if (succ_5363_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5367_ &= (tmp_7868_->tag == 11);
        succ_5367_ &= true;
        if (succ_5367_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5371_ &= (tmp_7868_->tag == 12);
        succ_5371_ &= true;
        if (succ_5371_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5375_ &= (tmp_7868_->tag == 13);
        succ_5375_ &= true;
        if (succ_5375_) {
            {
                return ((generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5379_ &= (tmp_7868_->tag == 14);
        succ_5379_ &= true;
        if (succ_5379_) {
            {
                return ((generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5383_ &= (tmp_7868_->tag == 15);
        succ_5383_ &= true;
        if (succ_5383_) {
            {
                return ((generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5387_ &= (tmp_7868_->tag == 16);
        succ_5387_ &= true;
        if (succ_5387_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5391_ &= (tmp_7868_->tag == 17);
        succ_5391_ &= true;
        if (succ_5391_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5395_ &= (tmp_7868_->tag == 18);
        succ_5395_ &= true;
        if (succ_5395_) {
            {
                return ((generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939)((this), (function), (expr), (type)));
            }
            goto after_7868;
        }
    }
    {
        succ_5399_ &= (tmp_7868_->tag == 19);
        succ_5399_ &= true;
        if (succ_5399_) {
            {
                return ((generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939)((this), (function), (expr), (type), (needsPtr)));
            }
            goto after_7868;
        }
    }
    {
        BinaryExpr_u **unknown = &tmp_7868_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s generateBytecodeExprBinary: Unhandled tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_7868;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7868:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generateBytecodeExprBinary: Exhaustive handling of binary ops")));
}
RegIndex_s generateBytecodeExprUnionInitPS9562PS7132S8951PU7869PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnionExpr_u *expr, Type_u *type, bool needsPtr) {
    ParsedUnionDecl_s *decl = (NULL);
    ParsedUnionVariant_s *variant = (NULL);
    usize _tag = ((usize)(0llu));
    bool succ_5411_ = true;

    Type_u *tmp_7879_ = (type);
    {
        succ_5411_ &= (tmp_7879_->tag == 8);
        ParsedUnionDecl_s **_decl = &tmp_7879_->payload.variant8._0;
        succ_5411_ &= true;
        usize *_variant = &tmp_7879_->payload.variant8._1;
        succ_5411_ &= true;
        if (succ_5411_) {
            {
                ((decl) = (*_decl));
                ((variant) = (*((atPS0030uszrPPS3506)((&((decl)->variants)), (*_variant)))));
                ((_tag) = (*_variant));
            }
            goto after_7879;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected Union Type in EXPR_UNION_INIT")));
            }
            goto after_7879;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7879:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((((decl)->variants).length) < ((usize)(65536llu))), ("IRGen assumes that the tag of an union fits in at most two bytes")));
    usize size = ((getSizeInBytesPU5175rusz)((type)));
    ((assertBPcrN)(((size) >= ((usize)(1llu))), ("Expected union instance to be at least one byte")));
    RegIndex_s start = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (start), (size)));
    RegIndex_s empty = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    ((buildCreateUnionPS7132S8951S6939rN)((function), (span), (empty)));
    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (start), (empty)));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    RegIndex_s sizeReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s offsetReg = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
    RegIndex_s tmp = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    RegIndex_s base = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    ((buildMovePS7132S8951S6939S6939rN)((function), (span), (tmp), (start)));
    {
        PrimType_u smol = (((PrimType_u){.tag = 0}));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((smol) = (((PrimType_u){.tag = 1})));
        Type_u *tagType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (smol)}}})));
        RegIndex_s tagReg = ((allocateRegisterPS7132PU5175rS6939)((function), (tagType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (tagReg), (tagType), (_tag)));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (start), (tagReg)));
        usize offset = ((usize)(1llu));
        if ((((decl)->variants).length) >= ((usize)(256llu)))
            ((offset) = ((usize)(2llu)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (sizeReg), (usizeType), (offset)));
        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
    }

    ((buildMovePS7132S8951S6939S6939rN)((function), (span), (base), (tmp)));
    bool succ_5428_ = true;
    bool succ_5432_ = true;
    bool succ_5442_ = true;

    UnionExpr_u *tmp_7956_ = (expr);
    {
        succ_5428_ &= (tmp_7956_->tag == 2);
        if (succ_5428_) {
            {
            }
            goto after_7956;
        }
    }
    {
        succ_5432_ &= (tmp_7956_->tag == 0);
        CallExpr_s *tuple = &tmp_7956_->payload.variant0._0;
        succ_5432_ &= true;
        if (succ_5432_) {
            {
                ParsedUnionVariantData_u tmp_40961 = (((ParsedUnionVariantData_u){.tag = 1, .payload = {0}}));

                ((assertBPcrN)((((tagAnyru8)((&((variant)->data)))) == (((tagAnyru8)((&tmp_40961))))), ("UnionExpr::Tuple did not get Tuple variant")));
                for (usize i = ((usize)(0llu)); ((i) < (((*tuple).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *field = (*((atPS7823uszrPPS2435)((&((*tuple).args)), (i))));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (true)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (sizeReg), (usizeType),
                                                                   ((getSizeInBytesPU5175rusz)(((getTypePU9661rPU5175)((&((field)->typeState))))))));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((field)->span), (result), (tmp), (sizeReg)));
                    if ((i) != ((((*tuple).args).length) - ((usize)(1llu)))) {
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (tmp), (sizeReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                    }
                }
            }
            goto after_7956;
        }
    }
    {
        succ_5442_ &= (tmp_7956_->tag == 1);
        StructExpr_s *context = &tmp_7956_->payload.variant1._0;
        succ_5442_ &= true;
        if (succ_5442_) {
            {
                ParsedUnionVariantData_u tmp_41059 = (((ParsedUnionVariantData_u){.tag = 2, .payload = {0}}));

                ((assertBPcrN)((((tagAnyru8)((&((variant)->data)))) == (((tagAnyru8)((&tmp_41059))))), ("UnionExpr::Struct did not get Struct variant")));
                for (usize i = ((usize)(0llu)); ((i) < (((*context).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*context).context)), (i)));
                    ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*context).context)), (i)));
                    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (field), (true)));
                    usize size = ((usize)(0llu));
                    usize offset = ((usize)(0llu));
                    {
                        usize index = ((getFieldIndexPS3506PS7720rusz)((variant), (&((name).content))));
                        ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (index), (&(offset)), (&(size)), (false)));
                        usize real_offset = ((usize)(0llu));
                        for (usize j = ((usize)(0llu)); ((j) < (index)); ((j) = ((j) + ((usize)(1llu))))) {
                            usize _offset = ((usize)(0llu));
                            usize _size = ((usize)(0llu));
                            ((getFieldOffsetAndSizePS3506uszPuszPuszBrN)((variant), (j), (&(_offset)), (&(_size)), (false)));
                            ((real_offset) = ((real_offset) + (_size)));
                        }

                        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (offsetReg), (usizeType), (real_offset)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (base), (base)));
                        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_ADD), (tmp), (base), (offsetReg)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (tmp), (tmp)));
                        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), (span), (base), (base)));
                    }

                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((field)->span), (sizeReg), (usizeType), (size)));
                    ((buildMemcpyPS7132S8951S6939S6939S6939rN)((function), ((field)->span), (result), (tmp), (sizeReg)));
                }
            }
            goto after_7956;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7956;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7956:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        return (start);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (dst), (start)));
        return (dst);
    }
}
RegIndex_s generateBytecodeExprAsPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    ParsedExpr_s *orig = (NULL);
    ParsedTypeNode_s *typeNode = (NULL);
    bool succ_5475_ = true;

    ExprData_u tmp_7971_ = ((expr)->data);
    {
        succ_5475_ &= (tmp_7971_.tag == 11);
        ParsedExpr_s **_orig = &tmp_7971_.payload.variant11._0;
        succ_5475_ &= true;
        ParsedTypeNode_s **_type = &tmp_7971_.payload.variant11._1;
        succ_5475_ &= true;
        if (succ_5475_) {
            {
                ((orig) = (*_orig));
                ((typeNode) = (*_type));
            }
            goto after_7971;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_7971;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_7971:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *current = ((getTypePU9661rPU5175)((&((orig)->typeState))));
    Type_u *target = ((getTypePU9661rPU5175)((&((typeNode)->typeState))));
    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (orig), ((isDataPU5175rB)((current)))));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (target)));
    if ((isDataPU5175rB)((current))) {
        RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)(((intoPointerPU5175rPU5175)((target)))))));
        ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (fieldPtr), (result), ((usize)(0llu))));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (fieldPtr), (fieldPtr)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (fieldPtr)));
    }

    else if ((isDataPU5175rB)((target))) {
        ((unreachablePcrN)(("generateBytecodeExprAs: <something> as Data should\'ve been handled by the Type Checker")));
    }

    else if (((isIntegerPU5175rB)((current))) && ((isPointerPU5175rB)((target)))) {
        ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isPointerPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isPointerPU5175rB)((current))) && ((isPointerPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isFunctionPU5175rB)((current))) && ((isFunctionPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isAnyPU5175rB)((current))) && ((isFunctionPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if (((isFunctionPU5175rB)((current))) && ((isAnyPU5175rB)((target)))) {
        ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
    }

    else if ((((isCharPU5175rB)((current))) || ((isIntegerPU5175rB)((current)))) && (((isCharPU5175rB)((target))) || ((isIntegerPU5175rB)((target))))) {
        if (((getSizeInBitsPU5175rusz)((current))) < ((getSizeInBitsPU5175rusz)((target)))) {
            if ((isSignedIntegerPU5175rB)((current))) {
                ((buildIntSignExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
            }

            else {
                ((buildIntZeroExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
            }

        }

        else if (((getSizeInBitsPU5175rusz)((current))) > ((getSizeInBitsPU5175rusz)((target)))) {
            ((buildIntTruncatePS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

        else {
            ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

    }

    else if (((isIntegerPU5175rB)((current))) && ((isFloatPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((target))) == ((usize)(4llu)))
            ((buildIntToF32PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else if (((getSizeInBytesPU5175rusz)((target))) == ((usize)(8llu)))
            ((buildIntToF64PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else
            ((unreachablePcrN)(("int to float")));
    }

    else if (((isFloatPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((current))) == ((usize)(4llu)))
            ((buildF32ToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else if (((getSizeInBytesPU5175rusz)((current))) == ((usize)(8llu)))
            ((buildF64ToIntPS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        else
            ((unreachablePcrN)(("float to int")));
    }

    else if (((isBooleanPU5175rB)((current))) && ((isIntegerPU5175rB)((target)))) {
        if ((isSignedIntegerPU5175rB)((current))) {
            ((buildIntSignExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

        else {
            ((buildIntZeroExtendPS7132S8951S6939S6939uszrN)((function), ((expr)->span), (dst), (result), ((getSizeInBitsPU5175rusz)((target)))));
        }

    }

    else if (((isIntegerPU5175rB)((current))) && ((isBooleanPU5175rB)((target)))) {
        RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (current)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (zero), (current), ((usize)(0llu))));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_CMP_NEQ), (dst), (result), (zero)));
    }

    else if (((isFloatPU5175rB)((current))) && ((isFloatPU5175rB)((target)))) {
        if (((getSizeInBytesPU5175rusz)((current))) < ((getSizeInBytesPU5175rusz)((target)))) {
            ((assertBrN)((((getSizeInBytesPU5175rusz)((current))) == ((usize)(4llu)))));
            ((assertBrN)((((getSizeInBytesPU5175rusz)((target))) == ((usize)(8llu)))));
            ((buildF32ToF64PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

        else if (((getSizeInBytesPU5175rusz)((current))) > ((getSizeInBytesPU5175rusz)((target)))) {
            ((assertBrN)((((getSizeInBytesPU5175rusz)((current))) == ((usize)(8llu)))));
            ((assertBrN)((((getSizeInBytesPU5175rusz)((target))) == ((usize)(4llu)))));
            ((buildF64ToF32PS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

        else {
            ((buildMovePS7132S8951S6939S6939rN)((function), ((expr)->span), (dst), (result)));
        }

    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of variations in generateBytecodeExprAs")));
    }

    if (needsPtr) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((target)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((target)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (dst)));
        ((dst) = (tempAlloc));
    }

    return (dst);
}
RegIndex_s generateBytecodeExprPathAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *instance = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    if ((isModulePU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    else if ((isUnionPU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    else {
        ((unreachablePcrN)(("generateBytecodeExprModuleAccess: Unexpected type of LHS")));
    }
}
RegIndex_s generateBytecodeExprMemberAccessPS9562PS7132PU0121BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *instance = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    if ((isModulePU5175rB)((instance))) {
        return ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (needsPtr)));
    }

    if (((isArrayPU5175rB)((instance))) || ((isArrayPointerPU5175rB)((instance)))) {
        if ((isArrayPointerPU5175rB)((instance))) {
            bool succ_5504_ = true;

            while (true) {
                Type_u *tmp_8086_ = ((getUnderlyingTypePU5175BrPU5175)((instance), (false)));
                succ_5504_ &= (tmp_8086_->tag == 4);
                Type_u **under = &tmp_8086_->payload.variant4._0;
                succ_5504_ &= true;

                if (!succ_5504_)
                    break;
                {
                    ((instance) = (*under));
                }
            }
        }

        bool succ_5509_ = true;

        Type_u *tmp_8092_ = (instance);
        succ_5509_ &= (tmp_8092_->tag == 5);
        succ_5509_ &= true;
        usize *arraySize = &tmp_8092_->payload.variant5._1;
        succ_5509_ &= true;
        if (!succ_5509_) {
            String_s s = ((toStringPU5175rS0540)((instance)));
            (((fprintf))((stderr_), ("%s %.*s\n"), (FATAL_STR), ((s).length), ((s).buffer)));
            ((unreachablePcrN)(("Expected array in MemberAccess")));
        };
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((rhs)->span), (size), (usizeType), (*arraySize)));
        if (needsPtr) {
            RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((usizeType)))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), ((rhs)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((usizeType)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), ((rhs)->span), (tempAlloc), (size)));
            return (tempAlloc);
        }

        else {
            return (size);
        }
    }

    ((assertBPcrN)(((((((isVariadicTypePU5175rB)((instance))) || ((isStructPU5175rB)((instance)))) || ((isStructPointerPU5175rB)((instance)))) || ((isTuplePU5175rB)((instance)))) ||
                    ((isTuplePointerPU5175rB)((instance)))),
                   ("Expected (ptr to) struct or tuple in MemberAccess")));
    bool _needsPtr = ((!((isStructPointerPU5175rB)((instance)))) && (!((isTuplePointerPU5175rB)((instance)))));
    RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (_needsPtr)));
    usize index = ((usize)(1llu));
    Type_u *fieldType = (NULL);
    if ((isVariadicTypePU5175rB)((instance))) {
        Token_s name = ((Token_s){0});
        bool succ_5529_ = true;

        ExprData_u tmp_8116_ = ((rhs)->data);
        {
            succ_5529_ &= (tmp_8116_.tag == 4);
            IdentExpr_s *ident = &tmp_8116_.payload.variant4._0;
            succ_5529_ &= true;
            if (succ_5529_) {
                {
                    ((name) = ((*ident).name));
                }
                goto after_8116;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected Identifier as RHS of member access")));
                }
                goto after_8116;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_8116:
        (void)0; // error: label at end of compound statement is a C23 extension
        SubStr_s tmp_41907 = (((newSubStrOfStrLitPcrS7720)(("length"))));

        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((name).content)), (&tmp_41907))), ("not length")));
        ((fieldType) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}}))));
        ((index) = ((usize)(1llu)));
    }

    else {
        Type_u *_t = (((getRegisterPS7132S6939rPS1534)((function), (result)))->typ);
        if (((isStructPU5175rB)((_t))) || ((isStructPointerPU5175rB)((_t)))) {
            if (!((isStructPointerPU5175rB)((_t)))) {
                Type_u *t1 = ((intoPointerPU5175rPU5175)((_t)));
                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), (t1)));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (alloca), ((getSizeInBytesPU5175rusz)((_t)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (alloca), (result)));
                ((result) = (alloca));
                ((_t) = (t1));
            }

            ParsedStructDecl_s *decl = (NULL);
            bool succ_5544_ = true;
            bool succ_5541_ = true;

            Type_u *tmp_8135_ = (_t);
            {
                succ_5544_ &= (tmp_8135_->tag == 4);
                succ_5541_ &= (tmp_8135_->payload.variant4._0->tag == 7);
                ParsedStructDecl_s **_decl = &tmp_8135_->payload.variant4._0->payload.variant7._0;
                succ_5541_ &= true;
                succ_5544_ &= succ_5541_;
                if (succ_5544_) {
                    {
                        ((decl) = (*_decl));
                    }
                    goto after_8135;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("Expected ptr to struct in Field Access")));
                    }
                    goto after_8135;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_8135:
            (void)0; // error: label at end of compound statement is a C23 extension
            Token_s name = ((Token_s){0});
            bool succ_5551_ = true;

            ExprData_u tmp_8141_ = ((rhs)->data);
            {
                succ_5551_ &= (tmp_8141_.tag == 4);
                IdentExpr_s *ident = &tmp_8141_.payload.variant4._0;
                succ_5551_ &= true;
                if (succ_5551_) {
                    {
                        ((name) = ((*ident).name));
                    }
                    goto after_8141;
                }
            }
            {
                if (true) {
                    {
                        ((unreachablePcrN)(("Expected Identifier as RHS of member access")));
                    }
                    goto after_8141;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_8141:
            (void)0; // error: label at end of compound statement is a C23 extension
            ((index) = ((getFieldIndexPS5521PS7720rusz)((decl), (&((name).content)))));
            ParsedTypeNode_s *_f = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((decl)->context)), (index)));
            ((fieldType) = ((getTypePU9661rPU5175)((&((_f)->typeState)))));
        }

        else if (((isTuplePU5175rB)((_t))) || ((isTuplePointerPU5175rB)((_t)))) {
            if (!((isTuplePointerPU5175rB)((_t)))) {
                Type_u *t1 = ((intoPointerPU5175rPU5175)((_t)));
                RegIndex_s alloca = ((allocateRegisterPS7132PU5175rS6939)((function), (t1)));
                ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (alloca), ((getSizeInBytesPU5175rusz)((_t)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (alloca), (result)));
                ((result) = (alloca));
                ((_t) = (t1));
            }

            bool succ_5561_ = true;

            ExprData_u tmp_8155_ = ((rhs)->data);
            succ_5561_ &= (tmp_8155_.tag == 0);
            Token_s *tkn = &tmp_8155_.payload.variant0._0;
            succ_5561_ &= true;
            if (!succ_5561_) {
                ((unreachablePcrN)(("Expected Number as RHS of member access")));
            };
            ((index) = ((usize)(((toU64PS7720ru64)((&((*tkn).content)))))));
            bool succ_5567_ = true;
            bool succ_5564_ = true;

            Type_u *tmp_8158_ = (_t);
            succ_5567_ &= (tmp_8158_->tag == 4);
            succ_5564_ &= (tmp_8158_->payload.variant4._0->tag == 10);
            TypeList_s *tElems = &tmp_8158_->payload.variant4._0->payload.variant10._0;
            succ_5564_ &= true;
            succ_5567_ &= succ_5564_;
            if (!succ_5567_) {
                ((unreachablePcrN)(("Not tuple")));
            };
            ((fieldType) = ((((*tElems).elements))[(index)]));
        }
    }

    RegIndex_s fieldPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((fieldType)))));
    ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((lhs)->span), (fieldPtr), (result), (index)));
    if (needsPtr) {
        return (fieldPtr);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (fieldType)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (fieldPtr)));
        return (dst);
    }
}
RegIndex_s prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939(IRGen_s *this, Span_s span, IRFunc_s *function, RegIndex_s base, RegIndexList_s args, Type_u *retType, RegIndex_s retPtr,
                                                                           bool needsPtr) {
    RegIndex_s retVal = ((RegIndex_s){0});
    if (((getSizeInBytesPU5175rusz)((retType))) > ((usize)(8llu))) {
        RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
        ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (retPtr), (base), (args)));
        if (needsPtr) {
            ((retVal) = (retPtr));
        }

        else {
            ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (reg), (retPtr)));
            ((retVal) = (reg));
        }

    }

    else {
        if ((isStructPU5175rB)((retType))) {
            RegIndex_s reg = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), ((getSizeInBytesPU5175rusz)((retType)))));
            ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (base), (args)));
            RegIndex_s v = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (v)))->typ);
            RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
            usize s = ((getSizeInBytesPU5175rusz)((t)));
            ((assertBrN)(((s) <= ((usize)(8llu)))));
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (r), (s)));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (r), (reg)));
            if (needsPtr) {
                ((retVal) = (r));
            }

            else {
                ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (v), (r)));
                ((retVal) = (v));
            }

        }

        else {
            RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
            ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (base), (args)));
            if (needsPtr) {
                RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((retType)))));
                ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (tempAlloc), ((getSizeInBytesPU5175rusz)((retType)))));
                ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tempAlloc), (reg)));
                ((retVal) = (tempAlloc));
            }

            else {
                ((retVal) = (reg));
            }
        }
    }

    Type_u *ft = (((getRegisterPS7132S6939rPS1534)((function), (base)))->typ);
    if ((isPointerPU5175rB)((ft)))
        ((ft) = ((getUnderlyingTypePU5175BrPU5175)((ft), (true))));
    ((assertBPcrN)(((isFunctionPU5175rB)((ft))), ("IRGen: Base is not a function")));
    if ((isNoreturnPU5175rB)((ft))) {
        ((buildUnreachablePS7132S8951rN)((function), (span)));
    }

    return (retVal);
}
RegIndex_s generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, usize funcID, Type_u *retType, RegIndexList_s args) {
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (retType)));
    {
        Type_u *ft = ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = ((TypeList_s){0}), ._1 = (retType), ._2 = ((FuncAttr_s){.isVariadic = (true)})}}})));
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (ft)));
        ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), (span), (dst), (funcID)));
        ((buildCallPS7132S8951S6939S6939S9911rN)((function), (span), (reg), (dst), (args)));
    }

    return (reg);
}
RegIndex_s generateBytecodeExprIndexedAccessPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    ((assertBPcrN)(((((isVariadicTypePU5175rB)((lhsType))) || ((isArrayPU5175rB)((lhsType)))) || ((isPointerPU5175rB)((lhsType)))), ("Expected Array, Ptr or VarArg as LHS in IndexedAccess")));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (!((isPointerPU5175rB)((lhsType))))));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isPointerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ))), ("Expected Ptr as LHS in IndexedAccess")));
    ((assertBPcrN)(((isIntegerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (rhsReg)))->typ))), ("Expected Int as RHS in IndexedAccess")));
    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
    if (((isArrayPU5175rB)((lhsType))) && (!(*((flags).opt)))) {
        Type_u *arrType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
        usize elemCount = (((getSizeInBytesPU5175rusz)((arrType))) / ((getSizeInBytesPU5175rusz)((type))));
        RegIndex_s cond = ((allocateRegisterPS7132PU5175rS6939)((function), (boolType)));
        RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        IRBlockID_s panic = ((appendBlockPS7132rS7192)((function)));
        IRBlockID_s normal = ((appendBlockPS7132rS7192)((function)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((lhs)->span), (size), (usizeType), (elemCount)));
        ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GTE), (cond), (rhsReg), (size)));
        ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((lhs)->span), (cond), (panic), (normal)));
        ((setCurrentBlockPS7132S7192rN)((function), (panic)));
        RegIndex_s err =
            ((allocateRegisterPS7132PU5175rS6939)((function),
                                                  ((wrapU5175rPU5175)(((Type_u){
                                                      .tag = 4,
                                                      .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})))}}})))));
        String_s s = ((copyPS0540rS0540)((&((function)->name))));
        String_s _s = ((toStringPS8951rS0540)((&((lhs)->span))));
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((pushStrPS0540PcrN)((&(s)), (": RUNTIME ERROR: Index out of bounds: Array of size ")));
        ((pushNumberPS0540uszrN)((&(s)), (elemCount)));
        ((pushStrPS0540PcrN)((&(s)), (" has no index %d\n")));
        ((dropPS0540rN)((&(_s))));
        ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((lhs)->span), (err), ((asSubStrPS0540rS7720)((&(s))))));
        usize funcID = ((getFunctionByMangledNamePS9562PcPcrusz)((this), ("index_oobPci64rN"), ("prelude.bufo")));
        RegIndexList_s args = ((RegIndexList_s){0});
        ((pushPS9911S6939rN)((&(args)), (err)));
        ((pushPS9911S6939rN)((&(args)), (rhsReg)));
        ((generateImplicitCallPS9562PS7132S8951uszPU5175S9911rS6939)((this), (function), ((lhs)->span), (funcID),
                                                                     ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}}))), (args)));
        ((buildUnreachablePS7132S8951rN)((function), ((lhs)->span)));
        ((setCurrentBlockPS7132S7192rN)((function), (normal)));
    }

    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((type)))));
    RegIndexList_s indices = ((RegIndexList_s){0});
    if ((isArrayPU5175rB)((lhsType))) {
        RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((lhs)->span), (index), (usizeType), ((usize)(0llu))));
        ((pushPS9911S6939rN)((&(indices)), (index)));
    }

    if ((isVariadicTypePU5175rB)((lhsType))) {
        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)(((getUnderlyingTypePU5175BrPU5175)((lhsType), (false)))))));
        ((buildGetFieldPtrPS7132S8951S6939S6939uszrN)((function), ((lhs)->span), (ptr), (lhsReg), ((usize)(0llu))));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (ptr), (ptr)));
        ((pushPS9911S6939rN)((&(indices)), (rhsReg)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((lhs)->span), (elemPtr), (ptr), (indices)));
    }

    else {
        ((pushPS9911S6939rN)((&(indices)), (rhsReg)));
        ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((lhs)->span), (elemPtr), (lhsReg), (indices)));
    }

    if (needsPtr) {
        return (elemPtr);
    }

    else {
        RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (elemPtr)));
        return (dst);
    }
}
none addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, usize index, bool isComptime) {
    ((addEntryPS7082S7720S6939BrN)((scope), (name), (reg), (isComptime)));
    if (*((flags).debug)) {
        ((buildDebugInfoParamPS7132S8951S6939uszS7720rN)((function), (span), (reg), (index), (name)));
    }
}
none addVariablePS9562PS7132S8951PS7082S7720S6939BrN(IRGen_s *this, IRFunc_s *function, Span_s span, IRScope_s *scope, SubStr_s name, RegIndex_s reg, bool isComptime) {
    ((addEntryPS7082S7720S6939BrN)((scope), (name), (reg), (isComptime)));
    if (*((flags).debug)) {
        ((buildDebugInfoAllocaPS7132S8951S6939S7720rN)((function), (span), (reg), (name)));
    }
}
RegIndex_s generateBytecodeExprIdentifierPS9562PS7132PS7464BrS6939(IRGen_s *this, IRFunc_s *function, IdentExpr_s *expr, bool needsPtr) {
    bool isGlobal = (false);
    Type_u *type = ((expr)->type);
    ((assertBPcrN)(((type) != (NULL)), ("IRGen: IdentExpr has unset type!")));
    IRScopeEntry_s *entry = ((getIdentifierByNamePS9562PS7132S7720PBrPS9676)((this), (function), (((expr)->name).content), (&(isGlobal))));
    if ((entry) != (NULL)) {
        if ((((function)->comptimeLevel) > ((usize)(0llu))) && (!((entry)->isComptime))) {
            ((unreachablePcrN)(("Crossing the boundary: comptime IR needs runtime value - The Checker should\'ve caught this")));
        }

        if (needsPtr) {
            if (isGlobal) {
                Type_u *ptrType = ((intoPointerPU5175rPU5175)((type)));
                RegIndex_s global = ((allocateRegisterPS7132PU5175rS6939)((function), (ptrType)));
                if ((entry)->isComptime) {
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (((expr)->name).span), (global), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), (val)));
                }

                else {
                    ((buildFetchGlobalPointerPS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), ((entry)->ptr)));
                }

                return (global);
            }

            else {
                if ((entry)->isComptime) {
                    Type_u *ptrType = ((intoPointerPU5175rPU5175)((type)));
                    RegIndex_s global = ((allocateRegisterPS7132PU5175rS6939)((function), (ptrType)));
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (((expr)->name).span), (global), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (global), (val)));
                    return (global);
                }

                else {
                    return ((entry)->ptr);
                }
            }

        }

        else {
            RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
            if (isGlobal) {
                if ((entry)->isComptime) {
                    ((buildFetchGlobalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

                else {
                    ((buildFetchGlobalRuntimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

            }

            else {
                if ((entry)->isComptime) {
                    ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }

                else {
                    ((buildLoadPS7132S8951S6939S6939rN)((function), (((expr)->name).span), (val), ((entry)->ptr)));
                }
            }

            return (val);
        }

    }

    else {
        if ((isModulePU5175rB)((type))) {
            return ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
        }

        else if ((isFunctionPU5175rB)((type))) {
            String_s name = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((expr)->origID)))));
            if (*((flags).opt)) {
                String_s tmp_42952 = (((newReadonlyStringPcrS0540)(("assertBPcrN"))));
                String_s tmp_42966 = (((newReadonlyStringPcrS0540)(("assertBrN"))));

                if ((equalsPS0540PS0540rB)((&(name)), (&tmp_42952))) {
                    ((name) = ((newStringFromStrLitPcrS0540)(("_empty_assertBPcrN"))));
                }

                else if ((equalsPS0540PS0540rB)((&(name)), (&tmp_42966))) {
                    ((name) = ((newStringFromStrLitPcrS0540)(("_empty_assertBrN"))));
                }
            }

            usize funcID = ((getFunctionByNamePS9562PS0540rusz)((this), (&(name))));
            RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
            ((buildLoadFunctionPtrPS7132S8951S6939uszrN)((function), (((expr)->name).span), (dst), (funcID)));
            return (dst);
        }

        else {
            ((unreachablePcrN)(("Exhaustive handling of types in generateBytecodeExprIdentifier")));
        }
    }
}
RegIndex_s generateBytecodeExprArithmeticPS9562PS7132PU0121PU5175BrS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type, bool needsPtr) {
    ((assertBrN)(((isArithmeticPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&((rhs)->typeState))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5682_ = true;
    bool succ_5687_ = true;
    bool succ_5706_ = true;
    bool succ_5711_ = true;
    bool succ_5716_ = true;

    BinaryExpr_u *tmp_8467_ = (expr);
    {
        succ_5682_ &= (tmp_8467_->tag == 3);
        succ_5682_ &= true;
        succ_5682_ &= true;
        if (succ_5682_) {
            {
                if ((((isIntegerPU5175rB)((lhsType))) || ((isCharPU5175rB)((lhsType)))) && (((isIntegerPU5175rB)((rhsType))) || ((isCharPU5175rB)((rhsType))))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("PTR + INT expected to be PTR")));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (lhsReg), (lhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (dst)));
                }

                else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("INT + PTR expected to be PTR")));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (rhsReg), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_ADD), (dst), (lhsReg), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (dst)));
                }

                else if (((isFloatPU5175rB)((lhsType))) && ((isFloatPU5175rB)((rhsType)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_ADD), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_PLUS")));
                }
            }
            goto after_8467;
        }
    }
    {
        succ_5687_ &= (tmp_8467_->tag == 4);
        succ_5687_ &= true;
        succ_5687_ &= true;
        if (succ_5687_) {
            {
                Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                if ((((isIntegerPU5175rB)((lhsType))) || ((isCharPU5175rB)((lhsType)))) && (((isIntegerPU5175rB)((rhsType))) || ((isCharPU5175rB)((rhsType))))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (dst), (lhsReg), (rhsReg)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("PTR - INT expected to be PTR")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (lhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (tmp2), (tmp1), (rhsReg)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (tmp2)));
                }

                else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isPointerPU5175rB)((type))), ("INT - PTR expected to be PTR")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (tmp2), (lhsReg), (tmp1)));
                    ((buildIntToPtrPS7132S8951S6939S6939rN)((function), ((lhs)->span), (dst), (tmp2)));
                }

                else if (((isPointerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                    ((assertBPcrN)(((isIntegerPU5175rB)((type))), ("PTR - PTR expected to be INT")));
                    RegIndex_s tmp1 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s tmp2 = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp1), (lhsReg)));
                    ((buildPtrToIntPS7132S8951S6939S6939rN)((function), ((lhs)->span), (tmp2), (rhsReg)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_SUB), (dst), (tmp1), (tmp2)));
                }

                else if (((isFloatPU5175rB)((lhsType))) && ((isFloatPU5175rB)((rhsType)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_SUB), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_SUB")));
                }
            }
            goto after_8467;
        }
    }
    {
        succ_5706_ &= (tmp_8467_->tag == 5);
        succ_5706_ &= true;
        succ_5706_ &= true;
        if (succ_5706_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_MUL), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_MUL), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_MULT")));
                }
            }
            goto after_8467;
        }
    }
    {
        succ_5711_ &= (tmp_8467_->tag == 6);
        succ_5711_ &= true;
        succ_5711_ &= true;
        if (succ_5711_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_DIV), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_DIV), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_DIV")));
                }
            }
            goto after_8467;
        }
    }
    {
        succ_5716_ &= (tmp_8467_->tag == 7);
        succ_5716_ &= true;
        succ_5716_ &= true;
        if (succ_5716_) {
            {
                if ((isIntegerPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_MOD), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_MOD), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_MOD")));
                }
            }
            goto after_8467;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprArithmetic")));
            }
            goto after_8467;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8467:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        Type_u *subType = ((intoPointerPU5175rPU5175)((type)));
        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((lhs)->span), (ptr), ((getSizeInBytesPU5175rusz)((type)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (ptr), (dst)));
        return (ptr);
    }

    else {
        return (dst);
    }
}
RegIndex_s generateBytecodeExprComparisonPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isComparisonPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isBooleanPU5175rB)((type))), ("Comparison expected to evaluate to Bool")));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    Type_u *t = (((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ);
    bool succ_5738_ = true;
    bool succ_5743_ = true;
    bool succ_5748_ = true;
    bool succ_5753_ = true;
    bool succ_5758_ = true;
    bool succ_5763_ = true;

    BinaryExpr_u *tmp_8542_ = (expr);
    {
        succ_5738_ &= (tmp_8542_->tag == 8);
        succ_5738_ &= true;
        succ_5738_ &= true;
        if (succ_5738_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_EQ), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_EQ), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_EQ")));
                }
            }
            goto after_8542;
        }
    }
    {
        succ_5743_ &= (tmp_8542_->tag == 9);
        succ_5743_ &= true;
        succ_5743_ &= true;
        if (succ_5743_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_NEQ), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_NEQ), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_NEQ")));
                }
            }
            goto after_8542;
        }
    }
    {
        succ_5748_ &= (tmp_8542_->tag == 10);
        succ_5748_ &= true;
        succ_5748_ &= true;
        if (succ_5748_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GT), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_GT), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_GT")));
                }
            }
            goto after_8542;
        }
    }
    {
        succ_5753_ &= (tmp_8542_->tag == 11);
        succ_5753_ &= true;
        succ_5753_ &= true;
        if (succ_5753_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_GTE), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_GTE), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_GTE")));
                }
            }
            goto after_8542;
        }
    }
    {
        succ_5758_ &= (tmp_8542_->tag == 12);
        succ_5758_ &= true;
        succ_5758_ &= true;
        if (succ_5758_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_LT), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_LT), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_LT")));
                }
            }
            goto after_8542;
        }
    }
    {
        succ_5763_ &= (tmp_8542_->tag == 13);
        succ_5763_ &= true;
        succ_5763_ &= true;
        if (succ_5763_) {
            {
                if (((((isIntegerPU5175rB)((t))) || ((isCharPU5175rB)((t)))) || ((isPointerPU5175rB)((t)))) || ((isBooleanPU5175rB)((t)))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_INT_CMP_LTE), (dst), (lhsReg), (rhsReg)));
                }

                else if ((isFloatPU5175rB)((t))) {
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_FLOAT_CMP_LTE), (dst), (lhsReg), (rhsReg)));
                }

                else {
                    ((unreachablePcrN)(("IRGen: Exhaustive handling of types for BIN_CMP_LTE")));
                }
            }
            goto after_8542;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprComparison")));
            }
            goto after_8542;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8542:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s generateBytecodeExprLogicalPS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isLogicalPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5779_ = true;
    bool succ_5784_ = true;

    BinaryExpr_u *tmp_8557_ = (expr);
    {
        succ_5779_ &= (tmp_8557_->tag == 14);
        succ_5779_ &= true;
        succ_5779_ &= true;
        if (succ_5779_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_LOGICAL_AND), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8557;
        }
    }
    {
        succ_5784_ &= (tmp_8557_->tag == 15);
        succ_5784_ &= true;
        succ_5784_ &= true;
        if (succ_5784_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_LOGICAL_OR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8557;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprLogical")));
            }
            goto after_8557;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8557:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s generateBytecodeExprBitwisePS9562PS7132PU0121PU5175rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr, Type_u *type) {
    ((assertBrN)(((isBitwisePU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (false)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    RegIndex_s dst = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
    bool succ_5800_ = true;
    bool succ_5805_ = true;
    bool succ_5810_ = true;

    BinaryExpr_u *tmp_8574_ = (expr);
    {
        succ_5800_ &= (tmp_8574_->tag == 16);
        succ_5800_ &= true;
        succ_5800_ &= true;
        if (succ_5800_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_AND), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8574;
        }
    }
    {
        succ_5805_ &= (tmp_8574_->tag == 17);
        succ_5805_ &= true;
        succ_5805_ &= true;
        if (succ_5805_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_OR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8574;
        }
    }
    {
        succ_5810_ &= (tmp_8574_->tag == 18);
        succ_5810_ &= true;
        succ_5810_ &= true;
        if (succ_5810_) {
            {
                ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((lhs)->span), (INSTR_BITWISE_XOR), (dst), (lhsReg), (rhsReg)));
            }
            goto after_8574;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprBitwise")));
            }
            goto after_8574;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8574:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (dst);
}
RegIndex_s loadLiteralPS9562PS7132S6939PS6070rS6939(IRGen_s *this, IRFunc_s *function, RegIndex_s reg, Token_s *tkn) {
    Type_u *typ = (((getRegisterPS7132S6939rPS1534)((function), (reg)))->typ);
    if (((isIntegerPU5175rB)((typ))) || ((isCharPU5175rB)((typ)))) {
        u64 _value = ((toU64PS7720ru64)((&((tkn)->content))));
        usize value = ((usize)((_value)));
        usize size = ((bitCountuszrusz)((value)));
        usize typsize = ((getSizeInBitsPU5175rusz)((typ)));
        if ((isSignedIntegerPU5175rB)((typ)))
            ((size) = ((size) + ((usize)(1llu))));
        if ((size) > (typsize)) {
            String_s loc = ((toStringPS8951rS0540)((&((tkn)->span))));
            String_s ts = ((toStringPU5175rS0540)((typ)));
            (((fprintf))((stderr_), ("%s: %s: Integer literal (value=%llu) is too big for target type %s.\n"), ((loc).buffer), (ERR_STR), (_value), ((ts).buffer)));
            ((dropPS0540rN)((&(ts))));
            ((dropPS0540rN)((&(loc))));
            (((this)->error) = (true));
        }

        ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((tkn)->span), (reg), (typ), (value)));
    }

    else if ((isFloatPU5175rB)((typ))) {
        f64 value = ((toF64PS7720rf64)((&((tkn)->content))));
        ((assertBPcrN)(((value) >= ((f64)(0))), ("Expected FloatLit value to be positive")));
        f64 typmax = ((getMaxFloatValuePU5175rf64)((typ)));
        if ((value) >= (typmax)) {
            String_s loc = ((toStringPS8951rS0540)((&((tkn)->span))));
            String_s ts = ((toStringPU5175rS0540)((typ)));
            (((fprintf))((stderr_), ("%s: %s: Float literal (value=%f) is too big for target type %s.\n"), ((loc).buffer), (ERR_STR), (value), ((ts).buffer)));
            ((dropPS0540rN)((&(ts))));
            ((dropPS0540rN)((&(loc))));
            (((this)->error) = (true));
        }

        if (((getSizeInBytesPU5175rusz)((typ))) == ((usize)(4llu)))
            ((buildLoadF32PS7132S8951S6939f32rN)((function), ((tkn)->span), (reg), ((f32)((value)))));
        else if (((getSizeInBytesPU5175rusz)((typ))) == ((usize)(8llu)))
            ((buildLoadF64PS7132S8951S6939f64rN)((function), ((tkn)->span), (reg), (value)));
        else
            ((unreachablePcrN)(("load float")));
    }

    else {
        ((unreachablePcrN)(("loadLiteral: Expected Integer, Char or Float")));
    }

    return (reg);
}
RegIndex_s generateBytecodeExprLiteralPS9562PS7132PS2435BrS6939(IRGen_s *this, IRFunc_s *function, ParsedExpr_s *expr, bool needsPtr) {
    ((assertBrN)(((isLiteralPS2435rB)((expr)))));
    Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
    RegIndex_s reg = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
    bool succ_5836_ = true;
    bool succ_5840_ = true;
    bool succ_5843_ = true;
    bool succ_5846_ = true;
    bool succ_5849_ = true;
    bool succ_5853_ = true;
    bool succ_5857_ = true;

    ExprData_u *tmp_8704_ = (&((expr)->data));
    {
        succ_5836_ &= (tmp_8704_->tag == 0);
        Token_s *value = &tmp_8704_->payload.variant0._0;
        succ_5836_ &= true;
        if (succ_5836_) {
            {
                ((loadLiteralPS9562PS7132S6939PS6070rS6939)((this), (function), (reg), (&(*value))));
            }
            goto after_8704;
        }
    }
    {
        succ_5840_ &= (tmp_8704_->tag == 1);
        Token_s *value = &tmp_8704_->payload.variant1._0;
        succ_5840_ &= true;
        if (succ_5840_) {
            {
                ((buildLoadStringPS7132S8951S6939S7720rN)((function), ((expr)->span), (reg), ((*value).content)));
            }
            goto after_8704;
        }
    }
    {
        succ_5843_ &= (tmp_8704_->tag == 14);
        if (succ_5843_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), ((usize)(1llu))));
            }
            goto after_8704;
        }
    }
    {
        succ_5846_ &= (tmp_8704_->tag == 15);
        if (succ_5846_) {
            {
                ((buildLoadBoolPS7132S8951S6939uszrN)((function), ((expr)->span), (reg), ((usize)(0llu))));
            }
            goto after_8704;
        }
    }
    {
        succ_5849_ &= (tmp_8704_->tag == 12);
        if (succ_5849_) {
            {
                ((buildLoadNullPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
            }
            goto after_8704;
        }
    }
    {
        succ_5853_ &= (tmp_8704_->tag == 2);
        Token_s *value = &tmp_8704_->payload.variant2._0;
        succ_5853_ &= true;
        if (succ_5853_) {
            {
                ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (reg), (t), ((usize)((((((*value).content).start))[((usize)(0llu))])))));
            }
            goto after_8704;
        }
    }
    {
        succ_5857_ &= (tmp_8704_->tag == 3);
        ArrayContext_s *context = &tmp_8704_->payload.variant3._0;
        succ_5857_ &= true;
        if (succ_5857_) {
            {
                ((assertBPcrN)(((isArrayPU5175rB)((t))), ("ArrayLit expected to be array")));
                if (((getSizeInBytesPU5175rusz)((t))) > ((usize)(4096llu)))
                    ((warningPcrN)(("Array Literal is big and slows down the IR")));
                if (((*context).size) == ((usize)(0llu))) {
                    if ((((getSizeInBytesPU5175rusz)((t))) == ((usize)(0llu))) && (*((flags).warnSimple))) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Array is zero-sized and can never be indexed into.\n"), ((loc).buffer), (WARN_STR)));
                        ((dropPS0540rN)((&(loc))));
                    }

                    ((buildCreateArrayPS7132S8951S6939rN)((function), ((expr)->span), (reg)));
                    for (usize i = ((usize)(0llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedExpr_s *elem = ((atPS7882uszrPS2435)((&(exprs)), ((getElementAtIndexPS8905uszrusz)((&(*context)), (i)))));
                        RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (elem), (false)));
                        ((buildInsertValuePS7132S8951S6939uszS6939rN)((function), ((expr)->span), (reg), (i), (result)));
                    }

                    if (needsPtr) {
                        Type_u *subType = ((intoPointerPU5175rPU5175)((t)));
                        RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (ptr), ((getSizeInBytesPU5175rusz)((t)))));
                        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (ptr), (reg)));
                        return (ptr);
                    }

                    else {
                        return (reg);
                    }

                }

                else {
                    ParsedExpr_s *elem = ((atPS7882uszrPS2435)((&(exprs)), ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu))))));
                    RegIndex_s value = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (elem), (false)));
                    Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
                    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                    Type_u *elemType = ((getTypePU9661rPU5175)((&((elem)->typeState))));
                    RegIndex_s arrayPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s one = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s index = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s indexPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((usizeType)))));
                    RegIndex_s size = ((allocateRegisterPS7132PU5175rS6939)((function), (usizeType)));
                    RegIndex_s cond = ((allocateRegisterPS7132PU5175rS6939)((function), (boolType)));
                    RegIndex_s elemPtr = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((elemType)))));
                    IRBlockID_s start = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s body = ((appendBlockPS7132rS7192)((function)));
                    IRBlockID_s end = ((appendBlockPS7132rS7192)((function)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (arrayPtr), ((getSizeInBytesPU5175rusz)((t)))));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (indexPtr), ((getSizeInBytesPU5175rusz)((usizeType)))));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (zero), (usizeType), ((usize)(0llu))));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (one), (usizeType), ((usize)(1llu))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (indexPtr), (zero)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), ((expr)->span), (size), (usizeType), ((*context).size)));
                    ((buildBrPS7132S8951S7192rN)((function), ((expr)->span), (start)));
                    ((setCurrentBlockPS7132S7192rN)((function), (start)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (index), (indexPtr)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_CMP_LT), (cond), (index), (size)));
                    ((buildCondBrPS7132S8951S6939S7192S7192rN)((function), ((expr)->span), (cond), (body), (end)));
                    ((setCurrentBlockPS7132S7192rN)((function), (body)));
                    RegIndexList_s indices = ((RegIndexList_s){0});
                    ((pushPS9911S6939rN)((&(indices)), (zero)));
                    ((pushPS9911S6939rN)((&(indices)), (index)));
                    ((buildGetElementPtrPS7132S8951S6939S6939S9911rN)((function), ((expr)->span), (elemPtr), (arrayPtr), (indices)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (elemPtr), (value)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (index), (indexPtr)));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), ((expr)->span), (INSTR_INT_ADD), (index), (index), (one)));
                    ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (indexPtr), (index)));
                    ((buildBrPS7132S8951S7192rN)((function), ((expr)->span), (start)));
                    ((setCurrentBlockPS7132S7192rN)((function), (end)));
                    if (needsPtr) {
                        return (arrayPtr);
                    }

                    else {
                        ((buildLoadPS7132S8951S6939S6939rN)((function), ((expr)->span), (reg), (arrayPtr)));
                        return (reg);
                    }
                }
            }
            goto after_8704;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprLiteral")));
            }
            goto after_8704;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8704:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (needsPtr) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((t)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (tempAlloc), ((getSizeInBytesPU5175rusz)((t)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), ((expr)->span), (tempAlloc), (reg)));
        return (tempAlloc);
    }

    return (reg);
}
RegIndex_s generateBytecodeExprAssignmentPS9562PS7132PU0121rS6939(IRGen_s *this, IRFunc_s *function, BinaryExpr_u *expr) {
    ((assertBrN)(((isAssignmentPU0121rB)((expr)))));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    RegIndex_s lhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (lhs), (true)));
    RegIndex_s rhsReg = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (rhs), (false)));
    ((assertBPcrN)(((isPointerPU5175rB)((((getRegisterPS7132S6939rPS1534)((function), (lhsReg)))->typ))), ("Assignment expected Ptr as LHS")));
    ((buildStorePS7132S8951S6939S6939rN)((function), ((lhs)->span), (lhsReg), (rhsReg)));
    return (rhsReg);
}
RegIndex_s generateBytecodeExprUnaryPS9562PS7132S8951PU5427PU5175BrS6939(IRGen_s *this, IRFunc_s *function, Span_s span, UnaryExpr_u *expr, Type_u *type, bool needsPtr) {
    bool succ_5917_ = true;
    bool succ_5929_ = true;
    bool succ_5939_ = true;
    bool succ_5951_ = true;
    bool succ_5959_ = true;

    UnaryExpr_u *tmp_8784_ = (expr);
    {
        succ_5917_ &= (tmp_8784_->tag == 0);
        ParsedExpr_s **subExpr = &tmp_8784_->payload.variant0._0;
        succ_5917_ &= true;
        if (succ_5917_) {
            {
                ((startComptimePS7132rN)((function)));
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((endComptimePS7132rN)((function)));
                ((buildFetchLocalComptimeValuePS7132S8951S6939S6939rN)((function), (span), (r), (result)));
                if (needsPtr) {
                    Type_u *subType = ((intoPointerPU5175rPU5175)((type)));
                    RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (ptr), ((getSizeInBytesPU5175rusz)((type)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (ptr), (r)));
                    return (ptr);
                }

                else {
                    return (r);
                }
            }
            goto after_8784;
        }
    }
    {
        succ_5929_ &= (tmp_8784_->tag == 2);
        ParsedExpr_s **subExpr = &tmp_8784_->payload.variant2._0;
        succ_5929_ &= true;
        if (succ_5929_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                IRReg_s *ptr = ((getRegisterPS7132S6939rPS1534)((function), (result)));
                ((assertBPcrN)(((isPointerPU5175rB)(((ptr)->typ))), ("Expected Ptr SubExpr in Unary Deref")));
                if (needsPtr) {
                    return (result);
                }

                else {
                    RegIndex_s val = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (val), (result)));
                    return (val);
                }
            }
            goto after_8784;
        }
    }
    {
        succ_5939_ &= (tmp_8784_->tag == 1);
        ParsedExpr_s **subExpr = &tmp_8784_->payload.variant1._0;
        succ_5939_ &= true;
        if (succ_5939_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (true)));
                IRReg_s *ptrReg = ((getRegisterPS7132S6939rPS1534)((function), (result)));
                if ((needsPtr) || (!((isPointerPU5175rB)(((ptrReg)->typ))))) {
                    Type_u *subType = ((intoPointerPU5175rPU5175)(((ptrReg)->typ)));
                    RegIndex_s ptr = ((allocateRegisterPS7132PU5175rS6939)((function), (subType)));
                    ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (ptr), ((getSizeInBytesPU5175rusz)(((ptrReg)->typ)))));
                    ((buildStorePS7132S8951S6939S6939rN)((function), (span), (ptr), (result)));
                    return (ptr);
                }

                else {
                    return (result);
                }
            }
            goto after_8784;
        }
    }
    {
        succ_5951_ &= (tmp_8784_->tag == 4);
        ParsedExpr_s **subExpr = &tmp_8784_->payload.variant4._0;
        succ_5951_ &= true;
        if (succ_5951_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                RegIndex_s r = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                ((buildLogicalNotPS7132S8951S6939S6939rN)((function), (span), (r), (result)));
                return (r);
            }
            goto after_8784;
        }
    }
    {
        succ_5959_ &= (tmp_8784_->tag == 3);
        ParsedExpr_s **subExpr = &tmp_8784_->payload.variant3._0;
        succ_5959_ &= true;
        if (succ_5959_) {
            {
                RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (*subExpr), (false)));
                if ((isIntegerPU5175rB)((type))) {
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    ((buildLoadIntegerPS7132S8951S6939PU5175uszrN)((function), (span), (zero), (type), ((usize)(0llu))));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_INT_SUB), (result), (zero), (result)));
                }

                else if ((isFloatPU5175rB)((type))) {
                    RegIndex_s zero = ((allocateRegisterPS7132PU5175rS6939)((function), (type)));
                    if (((getSizeInBytesPU5175rusz)((type))) == ((usize)(4llu)))
                        ((buildLoadF32PS7132S8951S6939f32rN)((function), (span), (zero), ((f32)(0))));
                    else if (((getSizeInBytesPU5175rusz)((type))) == ((usize)(8llu)))
                        ((buildLoadF64PS7132S8951S6939f64rN)((function), (span), (zero), ((f64)(0))));
                    else
                        ((unreachablePcrN)(("negation float")));
                    ((buildBinaryOpPS7132S8951uszS6939S6939S6939rN)((function), (span), (INSTR_FLOAT_SUB), (result), (zero), (result)));
                }

                else {
                    ((unreachablePcrN)(("Exhaustive handling of negation variants in generateBytecodeExprUnary")));
                }

                return (result);
            }
            goto after_8784;
        }
    }
    {
        if (true) {
            {
            }
            goto after_8784;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_8784:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in generateBytecodeExprUnary")));
}
none prepareParameterPS9562PS7132uszS8951S7720PU5175BrN(IRGen_s *this, IRFunc_s *function, usize index, Span_s span, SubStr_s name, Type_u *typ, bool retValue) {
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        Type_u *t =
            ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}})));
        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((t)))));
        RegIndex_s instance = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (instance), (value)));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (instance)));
        ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
    }

    else if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        Type_u *t = (NULL);
        if ((size) <= ((usize)(1llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))));
        }

        else if ((size) <= ((usize)(2llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))));
        }

        else if ((size) <= ((usize)(4llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))));
        }

        else if ((size) <= ((usize)(8llu))) {
            ((t) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))));
        }

        else {
            ((t) =
                 ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}})))}}}))));
        }

        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (t)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((t)))));
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        if ((isPointerPU5175rB)((t))) {
            RegIndex_s instance = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
            ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (instance), (value)));
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (instance)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }

        else {
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (value)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }

    }

    else {
        Type_u *allocType = ((intoPointerPU5175rPU5175)((typ)));
        RegIndex_s allocReg = ((allocateRegisterPS7132PU5175rS6939)((function), (allocType)));
        RegIndex_s value = ((allocateRegisterPS7132PU5175rS6939)((function), (typ)));
        ((buildGetParamPS7132S8951S6939uszuszrN)((function), (span), (value), (index), ((getSizeInBytesPU5175rusz)((typ)))));
        if (retValue) {
            ((assertBrN)(((index) == ((usize)(0llu)))));
            (((*(function)).retPtr) = (value));
        }

        else {
            ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (allocReg), ((getSizeInBytesPU5175rusz)((typ)))));
            ((buildStorePS7132S8951S6939S6939rN)((function), (span), (allocReg), (value)));
            ((addParameterPS9562PS7132S8951PS7082S7720S6939uszBrN)((this), (function), (span), ((lastPS9366rPS7082)((&((function)->scopes)))), (name), (allocReg), (index), (false)));
        }
    }
}
RegIndex_s getRegisterForSizePS9562PS7132uszrS6939(IRGen_s *this, IRFunc_s *function, usize size) {
    RegIndex_s v = ((RegIndex_s){0});
    if ((size) <= ((usize)(1llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 0}))}}}))))));
    }

    else if ((size) <= ((usize)(2llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 1}))}}}))))));
    }

    else if ((size) <= ((usize)(4llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 2}))}}}))))));
    }

    else if ((size) <= ((usize)(8llu))) {
        ((v) = ((allocateRegisterPS7132PU5175rS6939)((function), ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 3}))}}}))))));
    }

    else {
        ((unreachablePcrN)(("getRegisterForSize called with size > 8")));
    }

    return (v);
}
RegIndex_s prepareArgumentPS9562PS7132S8951S6939PU5175rS6939(IRGen_s *this, IRFunc_s *function, Span_s span, RegIndex_s value, Type_u *typ) {
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        RegIndex_s tempAlloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (tempAlloc), ((getSizeInBytesPU5175rusz)((typ)))));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (tempAlloc), (value)));
        return (tempAlloc);
    }

    else if ((isStructPU5175rB)((typ))) {
        usize size = ((getSizeInBytesPU5175rusz)((typ)));
        RegIndex_s alloc = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ)))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), (span), (alloc), (size)));
        ((buildStorePS7132S8951S6939S6939rN)((function), (span), (alloc), (value)));
        if ((size) > ((usize)(8llu)))
            return (alloc);
        RegIndex_s v = ((getRegisterForSizePS9562PS7132uszrS6939)((this), (function), (size)));
        ((buildLoadPS7132S8951S6939S6939rN)((function), (span), (v), (alloc)));
        return (v);
    }

    else {
        return (value);
    }
}
RegIndex_s generateBytecodeExprCallPS9562PS7132PS3328BrS6939(IRGen_s *this, IRFunc_s *function, CallExpr_s *expr, bool needsPtr) {
    RegIndex_s base = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), ((expr)->base), (false)));
    Type_u *typ = ((expr)->retType);
    ((assertBPcrN)(((typ) != (NULL)), ("IRGen: CallExpr has invalid return type")));
    RegIndexList_s args = ((RegIndexList_s){0});
    RegIndex_s retPtr = ((RegIndex_s){0});
    if (((getSizeInBytesPU5175rusz)((typ))) > ((usize)(8llu))) {
        ((retPtr) = ((allocateRegisterPS7132PU5175rS6939)((function), ((intoPointerPU5175rPU5175)((typ))))));
        ((buildAllocaPS7132S8951S6939uszrN)((function), ((expr)->span), (retPtr), ((getSizeInBytesPU5175rusz)((typ)))));
        ((pushPS9911S6939rN)((&(args)), (retPtr)));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&((expr)->args)), (i))));
        Type_u *argType = ((getTypePU9661rPU5175)((&((arg)->typeState))));
        RegIndex_s result = ((generateBytecodeExprPS9562PS7132PS2435BrS6939)((this), (function), (arg), (false)));
        ((pushPS9911S6939rN)((&(args)), ((prepareArgumentPS9562PS7132S8951S6939PU5175rS6939)((this), (function), ((arg)->span), (result), (argType)))));
    }

    return ((prepareReturnValuePS9562S8951PS7132S6939S9911PU5175S6939BrS6939)((this), ((expr)->span), (function), (base), (args), (typ), (retPtr), (needsPtr)));
}
IRGen_s newIRGeneratorPS7791rS9562(Lookup_s *lookup) {
    return ((IRGen_s){.globalScope = ((IRFunc_s){.name = ((newStringFromStrLitPcrS0540)(("__global__"))), .originalID = (((funcDecls).length) + ((usize)(1llu))), .comptimeLevel = ((usize)(0llu))}),
                      .lookup = (lookup)});
}
none addImportRootPS2466S7720rN(Parser_s *this, SubStr_s filePath) {
    String_s root = ((getPathParentPS7720rS0540)((&(filePath))));
    if (((this)->importRootLength) >= ((this)->importRootCapacity)) {
        usize newCap = (((this)->importRootCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->importRoots) = (((realloc))(((this)->importRoots), ((newCap) * (sizeof(String_s))))));
        ((assertBPcrN)((((this)->importRoots) != (NULL)), ("Could not resize import roots")));
        (((this)->importRootCapacity) = (newCap));
    }

    (((((this)->importRoots))[((this)->importRootLength)]) = (root));
    (((this)->importRootLength) = (((this)->importRootLength) + ((usize)(1llu))));
}
String_s getImportRootAtIndexPS2466uszrS0540(Parser_s *this, usize index) { return ((copyPS0540rS0540)((&((((this)->importRoots))[(index)])))); }
none inheritImportRootsPS2466PS2466rN(Parser_s *this, Parser_s *parent) {
    for (usize i = ((usize)(0llu)); ((i) < ((parent)->importRootLength)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s root = ((getImportRootAtIndexPS2466uszrS0540)((parent), (i)));
        ((addImportRootPS2466S7720rN)((this), ((asSubStrPS0540rS7720)((&(root))))));
        ((dropPS0540rN)((&(root))));
    }
}
Token_s expectSoftIdentifierPS2466rS6070(Parser_s *this) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if ((((tkn).kind) != (TOKEN_KEYWORD)) && (((tkn).kind) != (TOKEN_IDENT))) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Identifier, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    if ((((((((((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_NULL)))) || ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TRUE))))) ||
              ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FALSE))))) ||
             ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_BLANK))))) ||
            ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_SIZEOF))))) ||
           ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_ASM))))) ||
          ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC))))) ||
         ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))))) ||
        ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TYPEINFO))))) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Identifier, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    return (tkn);
}
Token_s expectPS2466uszrS6070(Parser_s *this, usize tknKind) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) != (tknKind)) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        char *exp = ((tokenKindToStringuszrPc)((tknKind)));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected %s, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), (exp), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    return (tkn);
}
bool eatPS2466uszrB(Parser_s *this, usize tknKind) {
    if ((atPS2466uszrB)((this), (tknKind))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return (true);
    }

    return (false);
}
bool atPS2466uszrB(Parser_s *this, usize tknKind) {
    if ((((peekPS3493rS6070)((&((this)->lexer)))).kind) == (tknKind)) {
        return (true);
    }

    return (false);
}
bool parsedEOFPS2466rB(Parser_s *this) { return ((((peekPS3493rS6070)((&((this)->lexer)))).kind) == (TOKEN_EOF)); }
bool _anon_25_1PS2466PS1892S7720rB(Parser_s *this, ParsedFile_s *root, SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < ((((root)->mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *_imp = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((root)->mod)->tlis)), (i))))));
        if (((_imp)->kind) == (TLI_IMPORT)) {
            ParsedFile_s *imp = ((atPS9483uszrPS1892)((&(files)), ((_imp)->nodeID)));
            String_s impPath = ((toStringPS7720rS0540)((&((imp)->origin))));
            String_s impFile = ((getFileNamePS0540rS0540)((&(impPath))));
            ((dropPS0540rN)((&(impPath))));
            SubStr_s tmp_45830 = ((asSubStrPS0540rS7720)((&(impFile))));

            if ((equalsPS7720PS7720rB)((&tmp_45830), (&(name)))) {
                ((dropPS0540rN)((&(impFile))));
                return (true);
            }

            ((dropPS0540rN)((&(impFile))));
        }
    }

    return (false);
}
none _anon_25_0PS2466PS1892BPcrN(Parser_s *this, ParsedFile_s *root, bool cond, char *name) {
    if (!(cond))
        return;
    bool (*checkIfImported)(Parser_s *, ParsedFile_s *, SubStr_s) = (_anon_25_1PS2466PS1892S7720rB);
    if (!((checkIfImported)((this), (root), ((newSubStrOfStrLitPcrS7720)((name)))))) {
        Span_s loc = (((root)->mod)->span);
        ParsedTopLevelItem_s *imp = ((parseImportByNamePS2466S8951S0540BrPS1038)((this), (loc), ((newStringFromStrLitPcrS0540)((name))), (false)));
        ((assertBPcrN)(((imp) != (NULL)), ("Could not import file!")));
        ((pushPS4113uszrN)((&(((root)->mod)->tlis)), ((getIDPS1038rusz)((imp)))));
    }
}
ParsedFile_s parseProjectPS2466S7720rS1892(Parser_s *this, SubStr_s root) {
    ((assertBPcrN)(((((this)->lexer).fileID) == ((usize)(0llu))), ("Expected Parser.parseProject to be the root")));
    ParsedFile_s *rootFile = ((newParsedFileS7720S7720rPS1892)((root), (((this)->lexer).content)));
    ((assertBPcrN)((((getIDPS1892rusz)((rootFile))) == ((usize)(0llu))), ("Expected Parser.parseProject result to be the root")));
    ((parseFilePS2466S7720PS1892rN)((this), (root), (rootFile)));
    none (*importIf)(Parser_s *, ParsedFile_s *, bool, char *) = (_anon_25_0PS2466PS1892BPcrN);
    ((importIf)((this), (rootFile), (*((flags).trace)), ("trace.bufo")));
    ((importIf)((this), (rootFile), (needsPrelude), ("prelude.bufo")));
    ((importIf)((this), (rootFile), (needsAssembly), ("asm.bufo")));
    ((importIf)((this), (rootFile), (needsTypeInfo), ("type_info.bufo")));
    ((importIf)((this), (rootFile), (true), ("runtime.bufo")));
    if (syntaxError) {
        (((C_exiti32rN))(((i32)(1))));
    }

    return (*(rootFile));
}
none parseFilePS2466S7720PS1892rN(Parser_s *this, SubStr_s root, ParsedFile_s *file) {
    (((file)->mod) = ((newParsedModuleS5656S8951S6070S4113rPS1882)(((TLIParent_s){0}), ((Span_s){0}), ((Token_s){0}), ((UsizeList_s){0}))));
    ((addImportRootPS2466S7720rN)((this), (root)));
    while (!((parsedEOFPS2466rB)((this)))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (false)));
        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S4756BrPS1038)((this), (attributes), (skip)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S4756BrPS1038)((this), (attributes), (skip)));
            ((pushPS4113uszrN)((&(((file)->mod)->tlis)), ((getIDPS1038rusz)((item)))));
        }
    }
}
bool parseAttributesPS2466PS4756BrB(Parser_s *this, ParsedAttributeList_s *attrs, bool inModule) {
    bool skip = (false);
    while ((eatPS2466uszrB)((this), (TOKEN_AT))) {
        Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
        if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_EXTERN)))) {
            if ((!(inModule)) && (*((flags).warnExtra))) {
                String_s loc = ((toStringPS8951rS0540)((&((name).span))));
                (((fprintf))((stderr_), ("%s: %s: `@extern()` used outside of a module.\n"), ((loc).buffer), (WARN_STR)));
                ((dropPS0540rN)((&(loc))));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            Token_s v = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            ((pushPS4756U4360rN)((attrs), ((ParsedAttribute_u){.tag = 1, .payload = {.variant1 = {._0 = (v)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_OS)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            Token_s os = ((expectPS2466uszrS6070)((this), (TOKEN_IDENT)));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            if ((!((equalsPS7720PS7720rB)((&((os).content)), (&(OS_WINDOWS))))) && (!((equalsPS7720PS7720rB)((&((os).content)), (&(OS_LINUX)))))) {
                (((fprintf))((stderr_), ("%s\n"), (((toStringPS7720rS0540)((&((os).content)))).buffer)));
                ((todo_with_msgPcrN)(("Unknown os")));
            }

            SubStr_s tmp_46106 = ((asSubStrPS0540rS7720)(((flags).target)));

            ((skip) = (!((equalsPS7720PS7720rB)((&((os).content)), (&tmp_46106)))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NORETURN)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 3, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NAKED)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((name).content)), (&(_ATTR_NO_MANGLE)))) {
            ((pushPS4756U4360rN)((attrs), (((ParsedAttribute_u){.tag = 5, .payload = {0}}))));
        }

        else {
            String_s loc = ((toStringPS8951rS0540)((&((name).span))));
            String_s n = ((toStringPS7720rS0540)((&((name).content))));
            (((fprintf))((stderr_), ("%s: %s: Use of unknown attribute `%s`.\n"), ((loc).buffer), (ERR_STR), ((n).buffer)));
            ((dropPS0540rN)((&(n))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }
    }

    return (skip);
}
ParsedTopLevelItem_s *parseTopLevelItemPS2466S4756BrPS1038(Parser_s *this, ParsedAttributeList_s attributes, bool skip) {
    return ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), ((TLIParent_s){.isFile = (true), .id = ((u32)((((this)->lexer).fileID)))}), (attributes), (skip)));
}
ParsedTopLevelItem_s *parseTopLevelItemPS2466S5656S4756BrPS1038(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes, bool skip) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_IMPORT)))) {
        return ((parseImportPS2466BrPS1038)((this), (skip)));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_CONFIG)))) {
        return ((asTLIPS0890rPS1038)(((parseConfigPS2466S5656S4756rPS0890)((this), (parent), (attributes)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_MODULE)))) {
        return ((asTLIPS1882rPS1038)(((parseModulePS2466S5656S4756rPS1882)((this), (parent), (attributes)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET)))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return ((asTLIPS1100rPS1038)(((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (true)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME)))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        return ((asTLIPS1100rPS1038)(((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (true)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_STRUCT)))) {
        return ((asTLIPS5521rPS1038)(((parseStructDeclPS2466S5656rPS5521)((this), (parent)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_UNION)))) {
        return ((asTLIPS0997rPS1038)(((parseUnionDeclPS2466S5656rPS0997)((this), (parent)))));
    }

    else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC)))) {
        bool isExtern = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((attributes).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedAttribute_u tmp_46352 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

            if (((tagAnyru8)((&((((attributes).elements))[(i)])))) == (((tagAnyru8)((&tmp_46352))))) {
                ((isExtern) = (true));
                break;
            }
        }

        ParsedFuncDecl_s *decl = ((parseFuncDeclPS2466S5656BrPS4904)((this), (parent), (isExtern)));
        (((decl)->attrs) = (attributes));
        return ((asTLIPS4904rPS1038)((decl)));
    }

    else {
        String_s loc = ((toStringPS8951rS0540)((&((tkn).span))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Top Level Keyword, found `%s` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        (((fprintf))((stderr_), ("%s: %s: A non-exhaustive list of TLK: `import`, `let`, `comptime`, `struct`, `union`, `func`.\n"), ((loc).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedModule_s *parseModulePS2466S5656S4756rPS1882(Parser_s *this, TLIParent_s _parent, ParsedAttributeList_s modAttr) {
    Token_s modTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((modTkn).content)), (&(KEYWORD_MODULE))))));
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    UsizeList_s tlis = ((UsizeList_s){0});
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedModule_s *mod = ((newParsedModuleS5656S8951S6070S4113rPS1882)((_parent), ((Span_s){0}), (name), ((UsizeList_s){0})));
    TLIParent_s parent = ((TLIParent_s){.isFile = (false), .id = ((u32)(((getIDPS1882rusz)((mod)))))});
    bool anyExtern = (false);
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (true)));
        for (usize i = ((usize)(0llu)); ((!(anyExtern)) && ((i) < ((attributes).length))); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedAttribute_u tmp_46493 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

            if (((tagAnyru8)((&((((attributes).elements))[(i)])))) == (((tagAnyru8)((&tmp_46493))))) {
                ((anyExtern) = (true));
                break;
            }
        }

        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), (parent), (attributes), (skip)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedTopLevelItem_s *item = ((parseTopLevelItemPS2466S5656S4756BrPS1038)((this), (parent), (attributes), (skip)));
            ((pushPS4113uszrN)((&(tlis)), ((getIDPS1038rusz)((item)))));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((modTkn).span)), (&((end).span))));
    (((mod)->span) = (span));
    (((mod)->tlis) = (tlis));
    if (anyExtern) {
        UsizeList_s modConfigs = ((UsizeList_s){0});
        bool anyLibrary = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *t = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(tlis)), (i))))));
            if (((t)->kind) == (TLI_CONFIG)) {
                ((pushPS4113uszrN)((&(modConfigs)), (*((atPS4113uszrPusz)((&(tlis)), (i))))));
                ParsedConfig_s *cfg = ((atPS9153uszrPS0890)((&(configs)), ((t)->nodeID)));
                TokenList_s paths = ((TokenList_s){0});
                SubStr_s tmp_46608 = ((newSubStrOfStrLitPcrS7720)((".")));

                ((pushPS9938S6070rN)((&(paths)), ((newTokenuszPS7720uszuszrS6070)(((usize)((((mod)->parent).id))), (&tmp_46608), ((usize)(0llu)), (TOKEN_DOT)))));
                for (usize j = ((usize)(0llu)); ((j) < (((cfg)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
                    Config_u *_cfg = ((atPS1575uszrPU7467)((&((cfg)->configs)), (j)));
                    bool succ_6121_ = true;

                    Config_u *tmp_9148_ = (_cfg);
                    {
                        succ_6121_ &= (tmp_9148_->tag == 3);
                        Token_s *p = &tmp_9148_->payload.variant3._0;
                        succ_6121_ &= true;
                        if (succ_6121_) {
                            {
                                String_s _p = ((toStringPS7720rS0540)((&((*p).content))));
                                if ((dirExistsPcrB)(((_p).buffer))) {
                                    ((pushPS9938S6070rN)((&(paths)), (*p)));
                                }

                                ((dropPS0540rN)((&(_p))));
                            }
                            goto after_9148;
                        }
                    }
                    {
                        if (true) {
                            {
                            }
                            goto after_9148;
                        }
                    }
                    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                after_9148:
                    (void)0; // error: label at end of compound statement is a C23 extension
                }

                for (usize k = ((usize)(0llu)); ((k) < ((paths).length)); ((k) = ((k) + ((usize)(1llu))))) {
                    SubStr_s tmp_46673 = (((atPS9938uszrPS6070)((&(paths)), (k)))->content);

                    String_s _path = ((toStringPS7720rS0540)((&tmp_46673)));
                    String_s path = ((toAbsolutePathPS0540rS0540)((&(_path))));
                    ((pushCharPS0540crN)((&(path)), ('/')));
                    for (usize j = ((usize)(0llu)); ((j) < (((cfg)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        Config_u *_cfg = ((atPS1575uszrPU7467)((&((cfg)->configs)), (j)));
                        bool succ_6134_ = true;
                        bool succ_6138_ = true;

                        Config_u *tmp_9190_ = (_cfg);
                        {
                            succ_6134_ &= (tmp_9190_->tag == 1);
                            Token_s *name = &tmp_9190_->payload.variant1._0;
                            succ_6134_ &= true;
                            if (succ_6134_) {
                                {
                                    ((anyLibrary) = (true));
                                }
                                goto after_9190;
                            }
                        }
                        {
                            succ_6138_ &= (tmp_9190_->tag == 2);
                            Token_s *name = &tmp_9190_->payload.variant2._0;
                            succ_6138_ &= true;
                            if (succ_6138_) {
                                {
                                    ((anyLibrary) = (true));
                                    String_s libPath = ((copyPS0540rS0540)((&(path))));
                                    ((pushSubStrPS0540PS7720rN)((&(libPath)), (&((*name).content))));
                                    if (*((flags).verbose))
                                        (((printf))(("[INFO] Trying to load %s: "), ((libPath).buffer)));
                                    Any file = (((fopen))(((libPath).buffer), ("r")));
                                    if ((file) == (NULL)) {
                                        if (*((flags).verbose)) {
                                            (((printf))(("%s\n"), ((strerror)((*((errnorPi32)()))))));
                                        }

                                        ((dropPS0540rN)((&(libPath))));
                                        continue;
                                    }

                                    (((fclose))((file)));
                                    Handle_s handle = ((dlopenPci32rS9457)(((libPath).buffer), (RTLD_LAZY)));
                                    if ((isNullS9457rB)((handle))) {
                                        if (*((flags).verbose)) {
                                            (((printf))(("%s\n"), ((dlerror)())));
                                        }

                                        ((dropPS0540rN)((&(libPath))));
                                        continue;
                                    }

                                    if (*((flags).verbose))
                                        (((printf))(("Success. Handle = %p\n"), ((handle).ptr)));
                                    ((pushPS4113uszrN)((&((mod)->dlls)), ((getIDPS3633rusz)(((newDLLS0540S9457rPS3633)((libPath), (handle)))))));
                                }
                                goto after_9190;
                            }
                        }
                        {
                            if (true) {
                                {
                                }
                                goto after_9190;
                            }
                        }
                        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                    after_9190:
                        (void)0; // error: label at end of compound statement is a C23 extension
                    }

                    ((dropPS0540rN)((&(_path))));
                    ((dropPS0540rN)((&(path))));
                }
            }
        }

        if (((modConfigs).length) == ((usize)(0llu))) {
            String_s loc = ((toStringPS8951rS0540)((&((mod)->span))));
            (((fprintf))((stderr_), ("%s: %s: Module contains @extern() functions, but no config was specified.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: The config contains important information such as linker flags and library paths.\n"), ((loc).buffer), (NOTE_STR)));
            (((fprintf))((stderr_), ("%s: %s: The config can be declared using the top level keyword `config` within the module.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else if (!(anyLibrary)) {
            String_s loc = ((toStringPS8951rS0540)((&((mod)->span))));
            (((fprintf))((stderr_), ("%s: %s: Module contains @extern() functions, but no library was provided in the config.\n"), ((loc).buffer), (ERR_STR)));
            for (usize i = ((usize)(0llu)); ((i) < ((modConfigs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                ParsedTopLevelItem_s *t = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(modConfigs)), (i))))));
                ((assertBrN)((((t)->kind) == (TLI_CONFIG))));
                ((dropPS0540rN)((&(loc))));
                ((loc) = ((toStringPS8951rS0540)((&((t)->span)))));
                (((fprintf))((stderr_), ("%s: %s: Module configuration specified here.\n"), ((loc).buffer), (NOTE_STR)));
            }

            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }
    }

    return (mod);
}
ParsedConfig_s *parseConfigPS2466S5656S4756rPS0890(Parser_s *this, TLIParent_s parent, ParsedAttributeList_s attributes) {
    Token_s cfgTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((cfgTkn).content)), (&(KEYWORD_CONFIG))))));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ConfigList_s flags = ((ConfigList_s){0});
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        Token_s _cfg = ((expectPS2466uszrS6070)((this), (TOKEN_IDENT)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        Token_s value = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
        Config_u cfg = ((newConfigS6070S6070rU7467)((_cfg), (value)));
        Config_u tmp_47019 = (((Config_u){.tag = 0, .payload = {0}}));

        if (((tagAnyru8)((&(cfg)))) == (((tagAnyru8)((&tmp_47019))))) {
            String_s loc = ((toStringPS8951rS0540)((&((_cfg).span))));
            String_s name = ((toStringPS7720rS0540)((&((_cfg).content))));
            (((fprintf))((stderr_), ("%s: %s: Unknown config option `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            (((fprintf))((stderr_), ("%s: %s: A non-exhaustive list of config options: `static`, `dynamic`, `libpath`, `linker`.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else if ((((value).content).len) == ((usize)(0llu))) {
            String_s loc = ((toStringPS8951rS0540)((&((value).span))));
            String_s name = ((toStringPS7720rS0540)((&((_cfg).content))));
            (((fprintf))((stderr_), ("%s: %s: Value for config option `%s` can\'t be empty.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            ((syntaxError) = (true));
        }

        else {
            ((pushPS1575U7467rN)((&(flags)), (cfg)));
        }

        if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
            break;
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    return ((newParsedConfigS8951S1575rPS0890)(((newSpanBetweenPS8951PS8951rS8951)((&((cfgTkn).span)), (&((end).span)))), (flags)));
}
ParsedTopLevelItem_s *parseImportPS2466BrPS1038(Parser_s *this, bool skip) {
    Token_s impTkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    ((assertBrN)(((equalsPS7720PS7720rB)((&((impTkn).content)), (&(KEYWORD_IMPORT))))));
    Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
    String_s file = ((toStringPS7720rS0540)((&((tkn).content))));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    return ((parseImportByNamePS2466S8951S0540BrPS1038)((this), ((newSpanBetweenPS8951PS8951rS8951)((&((impTkn).span)), (&((end).span)))), (file), (skip)));
}
ParsedTopLevelItem_s *parseImportByNamePS2466S8951S0540BrPS1038(Parser_s *this, Span_s loc, String_s file, bool skip) {
    String_s src = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->importRootLength)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s path = ((getImportRootAtIndexPS2466uszrS0540)((this), (i)));
        ((pushStringPS0540PS0540rN)((&(path)), (&(file))));
        ((path) = ((toAbsolutePathPS0540rS0540)((&(path)))));
        if ((canReadFileToStringPcPS0540rB)(((path).buffer), (&(src)))) {
            if (skip) {
                ((dropPS0540rN)((&(src))));
                ((dropPS0540rN)((&(path))));
                return (NULL);
            }

            usize fileID = ((usize)(0llu));
            ParsedFile_s *importedFile = (NULL);
            if ((getFileByFilePathS7720PuszrB)(((asSubStrPS0540rS7720)((&(path)))), (&(fileID)))) {
                ((importedFile) = ((atPS9483uszrPS1892)((&(files)), (fileID))));
            }

            else {
                ((importedFile) = ((newParsedFileS7720S7720rPS1892)(((asSubStrPS0540rS7720)((&(path)))), ((asSubStrPS0540rS7720)((&(src)))))));
                ((fileID) = ((getIDPS1892rusz)((importedFile))));
                Parser_s parser = ((newParserFromSourceuszS7720rS2466)((fileID), ((asSubStrPS0540rS7720)((&(src))))));
                ((inheritImportRootsPS2466PS2466rN)((&(parser)), (this)));
                ((parseFilePS2466S7720PS1892rN)((&(parser)), ((asSubStrPS0540rS7720)((&(path)))), (importedFile)));
            }

            ParsedTopLevelItem_s *item = ((newParsedTopLevelItemS8951uszuszrPS1038)((loc), (TLI_IMPORT), (fileID)));
            return (item);
        }

        ((dropPS0540rN)((&(path))));
    }

    String_s _loc = ((toStringPS8951rS0540)((&(loc))));
    (((fprintf))((stderr_), ("%s: %s: Could not import file %s.\n"), ((_loc).buffer), (ERR_STR), ((file).buffer)));
    (((C_exiti32rN))(((i32)(1))));
}
ParsedUnionDecl_s *parseUnionDeclPS2466S5656rPS0997(Parser_s *this, TLIParent_s parent) {
    Token_s kw = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedUnionDecl_s *decl = ((newParsedUnionDeclS5656S8951S6070rPS0997)((parent), ((defaultSpanrS8951)()), (nameTkn)));
    TLIParent_s unionParent = ((TLIParent_s){.id = ((u32)(((getIDPS0997rusz)((decl)))))});
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        ParsedUnionVariant_s *variant = ((parseUnionVariantPS2466S5656rPS3506)((this), (unionParent)));
        ((pushPS0030PS3506rN)((&((decl)->variants)), (variant)));
        if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    (((decl)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span)))));
    return (decl);
}
ParsedUnionVariant_s *parseUnionVariantPS2466S5656rPS3506(Parser_s *this, TLIParent_s parent) {
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    if ((eatPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
        ParsedUnionVariant_s *variant = ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 2, .payload = {.variant2 = {0}}}))));
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
            Token_s fieldName = ((expectSoftIdentifierPS2466rS6070)((this)));
            ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((addNamedFieldPS3506S6070PS1372rN)((variant), (fieldName), (typ)));
            if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
            }
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
        (((variant)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((name).span)), (&((end).span)))));
        return (variant);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedUnionVariant_s *variant = ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 1, .payload = {.variant1 = {0}}}))));
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((addFieldPS3506PS1372rN)((variant), (typ)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
            }
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        (((variant)->span) = ((newSpanBetweenPS8951PS8951rS8951)((&((name).span)), (&((end).span)))));
        return (variant);
    }

    else {
        return ((newParsedUnionVariantS5656S8951S6070U3836rPS3506)((parent), ((name).span), (name), (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}}))));
    }
}
ParsedStructDecl_s *parseStructDeclPS2466S5656rPS5521(Parser_s *this, TLIParent_s parent) {
    Token_s kw = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedStructDecl_s *decl = ((newParsedStructDeclS5656S8951S6070rPS5521)((parent), ((defaultSpanrS8951)()), (nameTkn)));
    StructContext_s structContext = ((StructContext_s){0});
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        Token_s tkn = ((expectSoftIdentifierPS2466rS6070)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        ((addFieldPS7871S6070PS1372rN)((&(structContext)), (tkn), (typ)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    (((decl)->span) = (span));
    (((decl)->context) = (structContext));
    SubStr_s tmp_47607 = (((newSubStrOfStrLitPcrS7720)(("Data"))));

    if ((equalsPS7720PS7720rB)((&(((decl)->name).content)), (&tmp_47607))) {
        ParsedFile_s *parent = ((getParentFilePS5521rPS1892)((decl)));
        SubStr_s tmp_47621 = (((newSubStrOfStrLitPcrS7720)(("type_info.bufo"))));

        if ((endsWithPS7720PS7720rB)((&((parent)->origin)), (&tmp_47621))) {
            (((decl)->isDataDefinition) = (true));
        }
    }

    return (decl);
}
ParsedFuncDecl_s *parseFuncDeclPS2466S5656BrPS4904(Parser_s *this, TLIParent_s parent, bool isExtern) {
    Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
    if (!(isExtern))
        ((assertBrN)(((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FUNC))))));
    Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
    ParamContext_s params = ((parseParametersPS2466rS9803)((this)));
    ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
    if (isExtern) {
        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
        return ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)((parent), (span), (name), (params), (retType), (NULL)));
    }

    else {
        ParsedBlock_s *body = ((parseBlockPS2466rPS7247)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((body)->span))));
        return ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)((parent), (span), (name), (params), (retType), (body)));
    }
}
ParsedTypeNode_s *parseReturnTypePS2466rPS1372(Parser_s *this) {
    if ((eatPS2466uszrB)((this), (TOKEN_ARROW_THIN))) {
        return ((parseTypeNodePS2466rPS1372)((this)));
    }

    else {
        return ((newBuiltinTypeDeclS8951uszrPS1372)((((peekPS3493rS6070)((&((this)->lexer)))).span), (PARSED_TYPE_NONE)));
    }
}
ParamContext_s parseParametersPS2466rS9803(Parser_s *this) {
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    ParamContext_s context = ((ParamContext_s){0});
    bool isVariadic = (false);
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
        if ((eatPS2466uszrB)((this), (TOKEN_DOTDOTDOT))) {
            ((isVariadic) = (true));
            break;
        }

        Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466BrPS1372)((this), (true)));
        ((addParameterPS9803S6070PS1372rN)((&(context)), (name), (typ)));
        if (isVariadic) {
            (((fprintf))((stderr_), ("%s: %s: Cannot specify parameters after variadics.\n"), (((toStringPS8951rS0540)((&((name).span)))).buffer), (ERR_STR)));
            ((syntaxError) = (true));
        }

        else {
            ((isVariadic) = (((typ)->kind) == (PARSED_TYPE_VARIADIC)));
        }

        if (!((eatPS2466uszrB)((this), (TOKEN_COMMA)))) {
            break;
        }
    }

    (((context).isVarArg) = (isVariadic));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    return (context);
}
ParsedBlock_s *parseBlockPS2466rPS7247(Parser_s *this) {
    ParsedBlock_s *block = ((newParsedBlockrPS7247)());
    Token_s start = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
        ParsedAttributeList_s attributes = ((ParsedAttributeList_s){0});
        bool skip = ((parseAttributesPS2466PS4756BrB)((this), (&(attributes)), (false)));
        if (skip) {
            ((toggleIgnoringNodesrN)());
            ParsedStmt_s *stmt = ((parseStmtPS2466rPS1100)((this)));
            ((toggleIgnoringNodesrN)());
        }

        else {
            ParsedStmt_s *stmt = ((parseStmtPS2466rPS1100)((this)));
            ((addStmtPS7247PS1100rN)((block), (stmt)));
        }
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    (((*(block)).span) = ((newSpanBetweenPS8951PS8951rS8951)((&((start).span)), (&((end).span)))));
    return (block);
}
ParsedStmt_s *parseStmtPS2466rPS1100(Parser_s *this) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) == (TOKEN_KEYWORD)) {
        if (((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET)))) || ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseVarDeclStmtPS2466S6070BrPS1100)((this), (tkn), (false)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_IF)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseIfStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_RETURN)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseReturnStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_WHILE)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseWhileStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FOR)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseForStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_BREAK)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 9, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_CONTINUE)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 10, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_MATCH)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            return ((parseMatchStmtPS2466S6070rPS1100)((this), (tkn)));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_ASM)))) {
            ((nextPS3493rS6070)((&((this)->lexer))));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            ParsedExprList_s args = ((ParsedExprList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ParsedExpr_s *arg = ((parseExprPS2466rPS2435)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                    ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                }

                ((pushPS7823PS2435rN)((&(args)), (arg)));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((needsAssembly) = (true));
            if (((args).length) == ((usize)(0llu))) {
                (((fprintf))((stderr_), ("%s: %s: `asm` expects at least one argument.\n"), (((toStringPS8951rS0540)((&((tkn).span)))).buffer), (ERR_STR)));
                ((syntaxError) = (true));
                return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 12, .payload = {.variant12 = {._0 = (NULL), ._1 = (args)}}})));
            }

            else {
                ParsedExpr_s *fn = ((popPS7823uszrPS2435)((&(args)), ((usize)(0llu))));
                return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 12, .payload = {.variant12 = {._0 = (fn), ._1 = (args)}}})));
            }
        }

    }

    else if (((tkn).kind) == (TOKEN_CURLY_OPEN)) {
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        return ((newParsedStmtS8951U4263rPS1100)(((block)->span), ((StmtData_u){.tag = 4, .payload = {.variant4 = {._0 = (block)}}})));
    }

    ParsedExpr_s *value = ((parseExprPS2466rPS2435)((this)));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((value)->span)), (&((end).span))));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 3, .payload = {.variant3 = {._0 = (value)}}})));
}
ParsedStmt_s *parseMatchStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
    ParsedPatternList_s patterns = ((ParsedPatternList_s){0});
    ParsedStmtList_s stmts = ((ParsedStmtList_s){0});
    while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
        ParsedPattern_s *pt = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_ARROW_THICK)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        ParsedStmt_s *stmt = ((into_stmtPS7247rPS1100)((block)));
        if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
            ((eatPS2466uszrB)((this), (TOKEN_COMMA)));
        }

        ((pushPS1982PS1826rN)((&(patterns)), (pt)));
        ((pushPS3288PS1100rN)((&(stmts)), (stmt)));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    if (((patterns).length) == ((usize)(0llu))) {
        ((todo_with_msgPcrN)(("parser: 0 arms in match")));
    }

    ((needsPrelude) = (true));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 11, .payload = {.variant11 = {._0 = (expr), ._1 = (patterns), ._2 = (stmts)}}})));
}
ParsedPattern_s *parsePatternPS2466rPS1826(Parser_s *this) {
    Token_s tkn = ((nextPS3493rS6070)((&((this)->lexer))));
    ParsedPattern_s *retPat = (NULL);
    if ((((tkn).kind) == (TOKEN_IDENT)) || (((tkn).kind) == (TOKEN_KEYWORD))) {
        if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_TRUE)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 9, .payload = {.variant9 = {._0 = (true)}}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_FALSE)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 9, .payload = {.variant9 = {._0 = (false)}}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_NULL)))) {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 10, .payload = {0}})))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
            ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
            bool succ_6301_ = true;
            bool succ_6305_ = true;

            Pattern_u *tmp_9536_ = (&((subpat)->data));
            {
                succ_6301_ &= (tmp_9536_->tag == 5);
                succ_6301_ &= true;
                succ_6301_ &= true;
                if (succ_6301_) {
                    {
                    }
                    goto after_9536;
                }
            }
            {
                succ_6305_ &= (tmp_9536_->tag == 2);
                succ_6305_ &= true;
                if (succ_6305_) {
                    {
                    }
                    goto after_9536;
                }
            }
            {
                if (true) {
                    {
                        ((todo_with_msgPcrN)(("parser: Path Pattern has non-struct non-ident as RHS")));
                    }
                    goto after_9536;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_9536:
            (void)0; // error: label at end of compound statement is a C23 extension
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 6, .payload = {.variant6 = {._0 = (tkn), ._1 = (subpat)}}}))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
            ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE)))) {
                    Pattern_u tmp_48430 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_48430))))) {
                        Span_s tmp_48443 = (((nextPS3493rS6070)((&((this)->lexer)))).span);

                        String_s loc = ((toStringPS8951rS0540)((&tmp_48443)));
                        (((fprintf))((stderr_), ("%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        ((syntaxError) = (true));
                    }

                    else {
                        ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                    }
                }

                ((pushPS1982PS1826rN)((&(subPatterns)), (subpat)));
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 5, .payload = {.variant5 = {._0 = (tkn), ._1 = (subPatterns)}}}))));
        }

        else if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
            ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
            while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                ParsedPattern_s *subpat = ((parsePatternPS2466rPS1826)((this)));
                if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
                    Pattern_u tmp_48524 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_48524))))) {
                        Span_s tmp_48537 = (((nextPS3493rS6070)((&((this)->lexer)))).span);

                        String_s loc = ((toStringPS8951rS0540)((&tmp_48537)));
                        (((fprintf))((stderr_), ("%s: %s: The `..` pattern can only appear at the end of a struct pattern.\n"), ((loc).buffer), (ERR_STR)));
                        ((dropPS0540rN)((&(loc))));
                        ((syntaxError) = (true));
                    }

                    else {
                        ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
                    }
                }

                ((pushPS1982PS1826rN)((&(subPatterns)), (subpat)));
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 5, .payload = {.variant5 = {._0 = (tkn), ._1 = (subPatterns)}}}))));
        }

        else {
            ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 2, .payload = {.variant2 = {._0 = (tkn)}}}))));
        }

    }

    else if (((tkn).kind) == (TOKEN_DOTDOT)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 8, .payload = {0}})))));
    }

    else if (((tkn).kind) == (TOKEN_WILDCARD)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), (((Pattern_u){.tag = 0, .payload = {0}})))));
    }

    else if (((tkn).kind) == (TOKEN_AMPERSAND_SINGLE)) {
        ParsedPattern_s *underlying = ((parsePatternPS2466rPS1826)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((underlying)->span))));
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 4, .payload = {.variant4 = {._0 = (underlying)}}}))));
    }

    else if (((tkn).kind) == (TOKEN_INT_LITERAL)) {
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 1, .payload = {.variant1 = {._0 = (tkn)}}}))));
    }

    else if (((tkn).kind) == (TOKEN_PAREN_OPEN)) {
        ParsedPatternList_s elems = ((ParsedPatternList_s){0});
        while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
            ((pushPS1982PS1826rN)((&(elems)), (pat)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        if (((elems).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Empty tuple patterns are not supported.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if (((elems).length) == ((usize)(1llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: A tuple pattern with one element will never match anything.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((end).span))));
        ((retPat) = ((newParsedPatternS8951U9267rPS1826)((span), ((Pattern_u){.tag = 7, .payload = {.variant7 = {._0 = (elems)}}}))));
    }

    if ((retPat) == (NULL)) {
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        String_s name = ((toStringPS7720rS0540)((&((tkn).content))));
        (((fprintf))((stderr_), ("%s: %s: Expected Pattern, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
        ((dropPS0540rN)((&(name))));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }

    if ((eatPS2466uszrB)((this), (TOKEN_COLON_SINGLE))) {
        ParsedTypeNode_s *type = ((parseTypeNodePS2466rPS1372)((this)));
        return ((newParsedPatternS8951U9267rPS1826)(((tkn).span), ((Pattern_u){.tag = 3, .payload = {.variant3 = {._0 = (retPat), ._1 = (type)}}})));
    }

    else {
        return (retPat);
    }
}
ParsedStmt_s *parseForStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if (!((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN)))) {
        ((todo_with_msgPcrN)(("for in loop")));
    }

    else {
        ParsedBlock_s *block = ((newParsedBlockrPS7247)());
        ParsedStmt_s *init = ((parseStmtPS2466rPS1100)((this)));
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        ParsedExpr_s *step = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *body = ((parseStmtPS2466rPS1100)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((body)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 8, .payload = {.variant8 = {._0 = (init), ._1 = (cond), ._2 = (step), ._3 = (body)}}}))));
    }
}
ParsedStmt_s *parseWhileStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *body = ((parseStmtPS2466rPS1100)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((body)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 7, .payload = {.variant7 = {._0 = (cond), ._1 = (body)}}})));
    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
        ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (false)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((block)->span))));
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 15, .payload = {.variant15 = {._0 = (pat), ._1 = (expr), ._2 = (block)}}})));
    }

    else {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedStmt_s *parseReturnStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    ParsedExpr_s *value = (NULL);
    if (!((atPS2466uszrB)((this), (TOKEN_SEMI_COLON))))
        ((value) = ((parseExprPS2466rPS2435)((this))));
    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    if ((value) != (NULL)) {
        return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 2, .payload = {.variant2 = {._0 = (value)}}})));
    }

    else {
        return ((newParsedStmtS8951U4263rPS1100)((span), (((StmtData_u){.tag = 1, .payload = {0}}))));
    }
}
ParsedStmt_s *parseIfStmtPS2466S6070rPS1100(Parser_s *this, Token_s kw) {
    ((assertBrN)((((kw).kind) == (TOKEN_KEYWORD))));
    if ((eatPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        ParsedExpr_s *cond = ((parseExprPS2466rPS2435)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        ParsedStmt_s *ifBody = ((parseStmtPS2466rPS1100)((this)));
        ParsedStmt_s *elseBody = (NULL);
        Span_s end = ((ifBody)->span);
        Token_s maybeElse = ((peekPS3493rS6070)((&((this)->lexer))));
        if (((maybeElse).kind) == (TOKEN_KEYWORD)) {
            if ((equalsPS7720PS7720rB)((&((maybeElse).content)), (&(KEYWORD_ELSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
                ((elseBody) = ((parseStmtPS2466rPS1100)((this))));
                ((end) = ((elseBody)->span));
            }
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&(end))));
        if ((elseBody) != (NULL)) {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 6, .payload = {.variant6 = {._0 = (cond), ._1 = (ifBody), ._2 = (elseBody)}}})));
        }

        else {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 5, .payload = {.variant5 = {._0 = (cond), ._1 = (ifBody)}}})));
        }

    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s tkn = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_LET))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
            (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
        ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (false)));
        ParsedBlock_s *block = ((parseBlockPS2466rPS7247)((this)));
        Span_s end = ((block)->span);
        Token_s maybeElse = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedBlock_s *elseBody = (NULL);
        if (((maybeElse).kind) == (TOKEN_KEYWORD)) {
            if ((equalsPS7720PS7720rB)((&((maybeElse).content)), (&(KEYWORD_ELSE)))) {
                ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
                ((elseBody) = ((parseBlockPS2466rPS7247)((this))));
                ((end) = ((elseBody)->span));
            }
        }

        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&(end))));
        if ((elseBody) != (NULL)) {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 14, .payload = {.variant14 = {._0 = (pat), ._1 = (expr), ._2 = (block), ._3 = (elseBody)}}})));
        }

        else {
            return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 13, .payload = {.variant13 = {._0 = (pat), ._1 = (expr), ._2 = (block)}}})));
        }

    }

    else {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        String_s loc = ((getLocationPS6070rS0540)((&(tkn))));
        (((fprintf))((stderr_), ("%s: %s: Expected `(` or `let`, found `%.*s` instead.\n"), ((loc).buffer), (ERR_STR), (((tkn).content).len), (((tkn).content).start)));
        ((dropPS0540rN)((&(loc))));
        (((C_exiti32rN))(((i32)(1))));
    }
}
ParsedStmt_s *parseVarDeclStmtPS2466S6070BrPS1100(Parser_s *this, Token_s kw, bool isGlobal) {
    bool isComptime = ((equalsPS7720PS7720rB)((&((kw).content)), (&(KEYWORD_COMPTIME))));
    ParsedPattern_s *pat = ((parsePatternPS2466rPS1826)((this)));
    ((expectPS2466uszrS6070)((this), (TOKEN_EQUAL_SINGLE)));
    ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
    VarDecl_s decl = ((VarDecl_s){.pat = (pat), .expr = (expr), .trampoline = (NULL), .isComptime = (isComptime), .isGlobal = (isGlobal), .origin = (((this)->lexer).fileID)});
    if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s elze = ((expectPS2466uszrS6070)((this), (TOKEN_KEYWORD)));
        if (!((equalsPS7720PS7720rB)((&((elze).content)), (&(KEYWORD_ELSE))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(elze))));
            (((fprintf))((stderr_), ("%s: %s: Expected `else`, got `%.*s`.\n"), ((loc).buffer), (ERR_STR), (((elze).content).len), (((elze).content).start)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        (((decl).trampoline) = ((parseBlockPS2466rPS7247)((this))));
    }

    Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((end).span))));
    return ((newParsedStmtS8951U4263rPS1100)((span), ((StmtData_u){.tag = 0, .payload = {.variant0 = {._0 = (decl)}}})));
}
ParsedTypeNode_s *parseTypeNodePS2466rPS1372(Parser_s *this) { return ((parseTypeNodePS2466BrPS1372)((this), (false))); }
ParsedTypeNodeList_s _anon_25_2PS2466BrS6760(Parser_s *this, bool allowedVariadic) {
    ParsedTypeNodeList_s tuple = ((ParsedTypeNodeList_s){0});
    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
    while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
        ParsedTypeNode_s *pt = ((parseTypeNodePS2466BrPS1372)((this), (allowedVariadic)));
        if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        ((pushPS6760PS1372rN)((&(tuple)), (pt)));
    }

    ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
    return (tuple);
}
ParsedTypeNode_s *parseTypeNodePS2466BrPS1372(Parser_s *this, bool allowedVariadic) {
    Token_s curr = ((peekPS3493rS6070)((&((this)->lexer))));
    ParsedTypeNodeList_s (*parse_tuple)(Parser_s *, bool) = (_anon_25_2PS2466BrS6760);
    if ((atPS2466uszrB)((this), (TOKEN_DOTDOTDOT))) {
        if (!(allowedVariadic)) {
            String_s loc = ((getLocationPS6070rS0540)((&(curr))));
            (((fprintf))((stderr_), ("%s: %s: Cannot use variadics in this context.\n"), ((loc).buffer), (ERR_STR)));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        ((nextPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *varNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_VARIADIC)));
        (((varNode)->underlyingID) = (typ));
        return (varNode);
    }

    else if ((atPS2466uszrB)((this), (TOKEN_KEYWORD))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        if (!((equalsPS7720PS7720rB)((&((kw).content)), (&(KEYWORD_FUNC))))) {
            ((expectSoftIdentifierPS2466rS6070)((this)));
        }

        ((nextPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNodeList_s params = ((parse_tuple)((this), (true)));
        ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((kw).span)), (&((retType)->span))));
        ParsedTypeNode_s *funcNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_FUNC)));
        (((funcNode)->underlyingID) = (retType));
        (((funcNode)->fnParams) = (params));
        return (funcNode);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_AMPERSAND_DOUBLE))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *ptr1 = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr1)).underlyingID) = (typ));
        ParsedTypeNode_s *ptr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr)).underlyingID) = (ptr1));
        return (ptr);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_AMPERSAND_SINGLE))) {
        Token_s kw = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((typ)->span))));
        ParsedTypeNode_s *ptr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_REF)));
        (((*(ptr)).underlyingID) = (typ));
        return (ptr);
    }

    else if ((eatPS2466uszrB)((this), (TOKEN_SQUARE_OPEN))) {
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        ((expectPS2466uszrS6070)((this), (TOKEN_SEMI_COLON)));
        Token_s size = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
        String_s _size = ((toStringPS7720rS0540)((&((size).content))));
        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((curr).span)), (&((end).span))));
        ParsedTypeNode_s *arr = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_ARRAY)));
        (((*(arr)).underlyingID) = (typ));
        (((*(arr)).arraySize) = ((usize)(((toU64PS0540ru64)((&(_size)))))));
        ((dropPS0540rN)((&(_size))));
        return (arr);
    }

    else if ((atPS2466uszrB)((this), (TOKEN_PAREN_OPEN))) {
        Token_s t = ((peekPS3493rS6070)((&((this)->lexer))));
        ParsedTypeNodeList_s tuple = ((parse_tuple)((this), (false)));
        if (((tuple).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(t))));
            (((fprintf))((stderr_), ("%s: %s: Expected tuple type to have at least one element.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        ParsedTypeNode_s *last = (*((atPS6760uszrPPS1372)((&(tuple)), (((tuple).length) - ((usize)(1llu))))));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((t).span)), (&((last)->span))));
        ParsedTypeNode_s *tupleNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_TUPLE)));
        (((tupleNode)->fnParams) = (tuple));
        return (tupleNode);
    }

    else {
        Token_s nameTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
        if ((atPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
            ParsedTypeNode_s *node = ((newParsedTypeNodeS8951uszrPS1372)(((nameTkn).span), (PARSED_TYPE_MODULE)));
            ParsedTypeNode_s *orig = (node);
            (((node)->nameTkn) = (nameTkn));
            while ((eatPS2466uszrB)((this), (TOKEN_COLON_DOUBLE))) {
                Token_s typeTkn = ((expectSoftIdentifierPS2466rS6070)((this)));
                Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((node)->span)), (&((typeTkn).span))));
                ParsedTypeNode_s *newNode = ((newParsedTypeNodeS8951uszrPS1372)((span), (PARSED_TYPE_MODULE)));
                (((newNode)->nameTkn) = (typeTkn));
                (((node)->underlyingID) = (newNode));
                ((node) = (newNode));
            }

            return (orig);
        }

        else {
            usize maybeBuiltin = ((getBuiltinTypeKindS6070rusz)((nameTkn)));
            if ((maybeBuiltin) == ((usize)(0llu))) {
                ParsedTypeNode_s *typ = ((newParsedTypeNodeS8951uszrPS1372)(((nameTkn).span), (PARSED_TYPE_IDENT)));
                (((*(typ)).nameTkn) = (nameTkn));
                return (typ);
            }

            else {
                return ((newBuiltinTypeDeclS8951uszrPS1372)(((nameTkn).span), (maybeBuiltin)));
            }
        }
    }
}
ParsedExpr_s *parseExprPS2466rPS2435(Parser_s *this) { return ((parseExprPS2466BrPS2435)((this), (true))); }
ParsedExpr_s *parseExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    return ((__parseExprPS2466uszU6350BrPS2435)((this), ((usize)(0llu)), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
}
ParsedExpr_s *__parseExprPS2466uszU6350rPS2435(Parser_s *this, usize precedence, Assoc_u associativity) { return ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (associativity), (true))); }
ParsedExpr_s *__parseExprPS2466uszU6350BrPS2435(Parser_s *this, usize precedence, Assoc_u associativity, bool struct_init_allowed) {
    ParsedExpr_s *expr = ((parsePrimaryExprPS2466BrPS2435)((this), (struct_init_allowed)));
    while ((matchesBinaryExprPS2466rB)((this))) {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        usize newPrec = ((getBinaryPrecedencePS2466PS6070rusz)((this), (&(tkn))));
        if ((newPrec) < (precedence))
            break;
        Assoc_u tmp_49969 = (((Assoc_u){.tag = 0}));

        if (((newPrec) == (precedence)) && (((tagAnyru8)((&(associativity)))) == (((tagAnyru8)((&tmp_49969))))))
            break;
        Assoc_u newAssoc = ((getBinaryAssociativityPS2466PS6070rU6350)((this), (&(tkn))));
        ((expr) = ((parseSecondaryExprPS2466PS2435uszU6350BrPS2435)((this), (expr), (newPrec), (newAssoc), (struct_init_allowed))));
    }

    return (expr);
}
ParsedExpr_s *parsePrimaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    if ((matchesUnaryExprPS2466rB)((this)))
        return ((parseUnaryExprPS2466BrPS2435)((this), (struct_init_allowed)));
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    if ((tknKind) == (TOKEN_INT_LITERAL)) {
        Token_s number = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((number).span), ((ExprData_u){.tag = 0, .payload = {.variant0 = {._0 = (number)}}})));
    }

    else if ((tknKind) == (TOKEN_STRING_LITERAL)) {
        Token_s str = ((expectPS2466uszrS6070)((this), (TOKEN_STRING_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((str).span), ((ExprData_u){.tag = 1, .payload = {.variant1 = {._0 = (str)}}})));
    }

    else if ((tknKind) == (TOKEN_CHAR_LITERAL)) {
        Token_s ch = ((expectPS2466uszrS6070)((this), (TOKEN_CHAR_LITERAL)));
        return ((newParsedExprS8951U8798rPS2435)(((ch).span), ((ExprData_u){.tag = 2, .payload = {.variant2 = {._0 = (ch)}}})));
    }

    else if ((tknKind) == (TOKEN_PAREN_OPEN)) {
        Token_s t = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
        ParsedExprList_s elems = ((ParsedExprList_s){0});
        while (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE)))) {
            ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
            ((pushPS7823PS2435rN)((&(elems)), (expr)));
            if (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))
                ((expectPS2466uszrS6070)((this), (TOKEN_COMMA)));
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        if (((elems).length) == ((usize)(0llu))) {
            String_s loc = ((getLocationPS6070rS0540)((&(t))));
            (((fprintf))((stderr_), ("%s: %s: Empty tuples are not supported.\n"), (ERR_STR), ((loc).buffer)));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if (((elems).length) == ((usize)(1llu))) {
            ParsedExpr_s *expr = ((((elems).elements))[((usize)(0llu))]);
            (((free))(((elems).elements)));
            return (expr);
        }

        else {
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((t).span)), (&((end).span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 20, .payload = {.variant20 = {._0 = (elems)}}})));
        }

    }

    else if ((tknKind) == (TOKEN_SQUARE_OPEN)) {
        Token_s start = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_OPEN)));
        ArrayContext_s arrayContext = ((ArrayContext_s){0});
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_SQUARE_CLOSE))))) {
            ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
            ((addElementPS8905PS2435rN)((&(arrayContext)), (expr)));
            if ((eatPS2466uszrB)((this), (TOKEN_SEMI_COLON))) {
                if (((arrayContext).elemLength) != ((usize)(1llu)))
                    ((todo_with_msgPcrN)(("array lit with given size too many elements")));
                Token_s size = ((expectPS2466uszrS6070)((this), (TOKEN_INT_LITERAL)));
                String_s _size = ((toStringPS7720rS0540)((&((size).content))));
                (((arrayContext).size) = ((usize)(((toU64PS0540ru64)((&(_size)))))));
                ((dropPS0540rN)((&(_size))));
                break;
            }

            if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                break;
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((start).span)), (&((end).span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 3, .payload = {.variant3 = {._0 = (arrayContext)}}})));
    }

    else if (((tknKind) == (TOKEN_KEYWORD)) || ((tknKind) == (TOKEN_IDENT))) {
        Token_s ident = ((expectPS2466uszrS6070)((this), (tknKind)));
        if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_NULL)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 12, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_TRUE)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 14, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_FALSE)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 15, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_BLANK)))) {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), (((ExprData_u){.tag = 13, .payload = {0}}))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_ASM)))) {
            String_s loc = ((getLocationPS6070rS0540)((&(ident))));
            String_s name = ((toStringPS7720rS0540)((&((ident).content))));
            (((fprintf))((stderr_), ("%s: %s: Expected Expression, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
            (((fprintf))((stderr_), ("%s: %s: Inline Assembly can only be used as a statement.\n"), ((loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
            (((C_exiti32rN))(((i32)(1))));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_SIZEOF)))) {
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((typ)->span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 8, .payload = {.variant8 = {._0 = (typ)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_TYPEINFO)))) {
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_OPEN)));
            ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
            ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((typ)->span))));
            ((needsTypeInfo) = (true));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 17, .payload = {.variant17 = {._0 = (typ)}}})));
        }

        else if ((equalsPS7720PS7720rB)((&((ident).content)), (&(KEYWORD_FUNC)))) {
            String_s _name = ((newStringFromStrLitPcrS0540)((".anon_")));
            ((pushNumberPS0540uszrN)((&(_name)), (((this)->lexer).fileID)));
            ((pushCharPS0540crN)((&(_name)), ('_')));
            ((pushNumberPS0540uszrN)((&(_name)), ((this)->anonFnCount)));
            (((this)->anonFnCount) = (((this)->anonFnCount) + ((usize)(1llu))));
            usize fileID = (((this)->lexer).fileID);
            SubStr_s tmp_50487 = ((asSubStrPS0540rS7720)((&(_name))));

            Token_s name = ((newTokenuszPS7720uszuszrS6070)((fileID), (&tmp_50487), ((usize)(0llu)), (TOKEN_IDENT)));
            ParamContext_s params = ((parseParametersPS2466rS9803)((this)));
            ParsedTypeNode_s *retType = ((parseReturnTypePS2466rPS1372)((this)));
            ParsedBlock_s *body = ((parseBlockPS2466rPS7247)((this)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((body)->span))));
            ParsedFuncDecl_s *decl =
                ((newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904)(((TLIParent_s){.isFile = (true), .id = ((u32)((fileID)))}), (span), (name), (params), (retType), (body)));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 16, .payload = {.variant16 = {._0 = (decl)}}})));
        }

        else if ((atPS2466uszrB)((this), (TOKEN_CURLY_OPEN))) {
            if (!(struct_init_allowed)) {
                return ((newParsedExprS8951U8798rPS2435)(((ident).span), ((ExprData_u){.tag = 4, .payload = {.variant4 = {._0 = ((IdentExpr_s){.name = (ident)})}}})));
            }

            ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_OPEN)));
            StructInitContext_s context = ((StructInitContext_s){0});
            while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_CURLY_CLOSE))))) {
                Token_s name = ((expectSoftIdentifierPS2466rS6070)((this)));
                ((expectPS2466uszrS6070)((this), (TOKEN_COLON_SINGLE)));
                ParsedExpr_s *expr = ((parseExprPS2466rPS2435)((this)));
                ((addFieldPS6291S6070PS2435rN)((&(context)), (name), (expr)));
                if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                    break;
            }

            Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_CURLY_CLOSE)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((ident).span)), (&((end).span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 9, .payload = {.variant9 = {._0 = ((StructExpr_s){.name = (ident), .context = (context)})}}})));
        }

        else {
            return ((newParsedExprS8951U8798rPS2435)(((ident).span), ((ExprData_u){.tag = 4, .payload = {.variant4 = {._0 = ((IdentExpr_s){.name = (ident)})}}})));
        }
    }

    Token_s t = ((peekPS3493rS6070)((&((this)->lexer))));
    String_s loc = ((getLocationPS6070rS0540)((&(t))));
    String_s name = ((toStringPS7720rS0540)((&((t).content))));
    (((fprintf))((stderr_), ("%s: %s: Expected Expression, found `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((C_exiti32rN))(((i32)(1))));
}
ParsedExpr_s *parseSecondaryExprPS2466PS2435uszU6350BrPS2435(Parser_s *this, ParsedExpr_s *lhs, usize precedence, Assoc_u associativity, bool struct_init_allowed) {
    ((assertBrN)(((matchesBinaryExprPS2466rB)((this)))));
    Token_s opTkn = ((nextPS3493rS6070)((&((this)->lexer))));
    if ((equalsPS7720PS7720rB)((&((opTkn).content)), (&(KEYWORD_AS)))) {
        ParsedTypeNode_s *typ = ((parseTypeNodePS2466rPS1372)((this)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((typ)->span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 11, .payload = {.variant11 = {._0 = (lhs), ._1 = (typ)}}})));
    }

    ParsedExpr_s *rhs = (NULL);
    if (((opTkn).kind) == (TOKEN_SQUARE_OPEN)) {
        ((needsPrelude) = (true));
        ((rhs) = ((__parseExprPS2466uszU6350rPS2435)((this), ((usize)(0llu)), (associativity))));
        ((expectPS2466uszrS6070)((this), (TOKEN_SQUARE_CLOSE)));
    }

    else if (((opTkn).kind) == (TOKEN_PAREN_OPEN)) {
        ParsedExprList_s args = ((ParsedExprList_s){0});
        while ((!((parsedEOFPS2466rB)((this)))) && (!((atPS2466uszrB)((this), (TOKEN_PAREN_CLOSE))))) {
            ((pushPS7823PS2435rN)((&(args)), ((parseExprPS2466rPS2435)((this)))));
            if (!((eatPS2466uszrB)((this), (TOKEN_COMMA))))
                break;
        }

        Token_s end = ((expectPS2466uszrS6070)((this), (TOKEN_PAREN_CLOSE)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((end).span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 7, .payload = {.variant7 = {._0 = ((CallExpr_s){.span = (span), .base = (lhs), .args = (args)})}}})));
    }

    else {
        ((rhs) = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (associativity), (struct_init_allowed))));
    }

    if (((opTkn).kind) == (TOKEN_DOT)) {
        bool succ_6560_ = true;
        bool succ_6564_ = true;

        ExprData_u *tmp_10064_ = (&((rhs)->data));
        {
            succ_6560_ &= (tmp_10064_->tag == 4);
            succ_6560_ &= true;
            if (succ_6560_) {
                {
                }
                goto after_10064;
            }
        }
        {
            succ_6564_ &= (tmp_10064_->tag == 0);
            succ_6564_ &= true;
            if (succ_6564_) {
                {
                }
                goto after_10064;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s: %s: The right side of `.` must be an identifier or number.\n"), (((toStringPS8951rS0540)((&((lhs)->span)))).buffer), (ERR_STR)));
                    ((syntaxError) = (true));
                }
                goto after_10064;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10064:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else if (((opTkn).kind) == (TOKEN_COLON_DOUBLE)) {
        bool succ_6572_ = true;
        bool succ_6570_ = true;
        bool succ_6576_ = true;

        ExprData_u *tmp_10071_ = (&((lhs)->data));
        {
            succ_6572_ &= (tmp_10071_->tag == 6);
            succ_6570_ &= (tmp_10071_->payload.variant6._0.tag == 0);
            succ_6570_ &= true;
            succ_6570_ &= true;
            succ_6572_ &= succ_6570_;
            if (succ_6572_) {
                {
                }
                goto after_10071;
            }
        }
        {
            succ_6576_ &= (tmp_10071_->tag == 4);
            succ_6576_ &= true;
            if (succ_6576_) {
                {
                }
                goto after_10071;
            }
        }
        {
            if (true) {
                {
                    (((fprintf))((stderr_), ("%s: %s: The left side of `::` must be an identifier or other module specifier.\n"), (((toStringPS8951rS0540)((&((lhs)->span)))).buffer), (ERR_STR)));
                    ((syntaxError) = (true));
                }
                goto after_10071;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10071:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((lhs)->span)), (&((rhs)->span))));
    return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 6, .payload = {.variant6 = {._0 = ((fromTknuszPS2435PS2435rU0121)(((opTkn).kind), (lhs), (rhs)))}}})));
}
ParsedExpr_s *parseUnaryExprPS2466BrPS2435(Parser_s *this, bool struct_init_allowed) {
    Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
    if (((tkn).kind) == (TOKEN_KEYWORD)) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        if ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME)))) {
            ParsedExpr_s *expr = ((parseExprPS2466BrPS2435)((this), (struct_init_allowed)));
            Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
            return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (expr)}}})}}})));
        }

        else {
            ((unreachablePcrN)(("parseUnaryExpr: Unexpected keyword")));
        }

    }

    else if (((tkn).kind) == (TOKEN_AMPERSAND_DOUBLE)) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        usize precedence = ((getUnaryPrecedencePS2466uszrusz)((this), (TOKEN_AMPERSAND_SINGLE)));
        ParsedExpr_s *expr = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
        ParsedExpr_s *inner = ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (expr)}}})}}})));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (inner)}}})}}})));
    }

    else if ((((((tkn).kind) == (TOKEN_ASTERISK_SINGLE)) || (((tkn).kind) == (TOKEN_AMPERSAND_SINGLE))) || (((tkn).kind) == (TOKEN_MINUS_SINGLE))) || (((tkn).kind) == (TOKEN_BANG))) {
        ((nextPS3493rS6070)((&((this)->lexer))));
        usize precedence = ((getUnaryPrecedencePS2466uszrusz)((this), ((tkn).kind)));
        ParsedExpr_s *expr = ((__parseExprPS2466uszU6350BrPS2435)((this), (precedence), (((Assoc_u){.tag = 0})), (struct_init_allowed)));
        Span_s span = ((newSpanBetweenPS8951PS8951rS8951)((&((tkn).span)), (&((expr)->span))));
        return ((newParsedExprS8951U8798rPS2435)((span), ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((fromTknuszPS2435rU5427)(((tkn).kind), (expr)))}}})));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of unary operations in parseUnaryExpr")));
    }
}
bool matchesBinaryExprPS2466rB(Parser_s *this) {
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    SubStr_s tmp_51059 = (((peekPS3493rS6070)((&((this)->lexer)))).content);

    if ((tknKind) == (TOKEN_KEYWORD))
        return ((equalsPS7720PS7720rB)((&tmp_51059), (&(KEYWORD_AS))));
    return ((((((((((((((((((((((tknKind) == (TOKEN_EQUAL_DOUBLE)) || ((tknKind) == (TOKEN_EQUAL_SINGLE))) || ((tknKind) == (TOKEN_NOT_EQUAL))) || ((tknKind) == (TOKEN_MINUS_SINGLE))) ||
                            ((tknKind) == (TOKEN_PLUS_SINGLE))) ||
                           ((tknKind) == (TOKEN_ASTERISK_SINGLE))) ||
                          ((tknKind) == (TOKEN_SLASH_SINGLE))) ||
                         ((tknKind) == (TOKEN_LESS_THAN_EQUAL))) ||
                        ((tknKind) == (TOKEN_LESS_THAN))) ||
                       ((tknKind) == (TOKEN_GREATER_THAN_EQUAL))) ||
                      ((tknKind) == (TOKEN_GREATER_THAN))) ||
                     ((tknKind) == (TOKEN_AMPERSAND_SINGLE))) ||
                    ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))) ||
                   ((tknKind) == (TOKEN_PIPE_DOUBLE))) ||
                  ((tknKind) == (TOKEN_PIPE_SINGLE))) ||
                 ((tknKind) == (TOKEN_CARET))) ||
                ((tknKind) == (TOKEN_COLON_DOUBLE))) ||
               ((tknKind) == (TOKEN_DOT))) ||
              ((tknKind) == (TOKEN_PAREN_OPEN))) ||
             ((tknKind) == (TOKEN_SQUARE_OPEN))) ||
            ((tknKind) == (TOKEN_PERCENT)));
}
bool matchesUnaryExprPS2466rB(Parser_s *this) {
    usize tknKind = (((peekPS3493rS6070)((&((this)->lexer)))).kind);
    if ((tknKind) == (TOKEN_KEYWORD)) {
        Token_s tkn = ((peekPS3493rS6070)((&((this)->lexer))));
        return ((equalsPS7720PS7720rB)((&((tkn).content)), (&(KEYWORD_COMPTIME))));
    }

    return ((((((tknKind) == (TOKEN_MINUS_SINGLE)) || ((tknKind) == (TOKEN_AMPERSAND_SINGLE))) || ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))) || ((tknKind) == (TOKEN_ASTERISK_SINGLE))) ||
            ((tknKind) == (TOKEN_BANG)));
}
usize getBinaryPrecedencePS2466PS6070rusz(Parser_s *this, Token_s *tkn) {
    usize tknKind = ((tkn)->kind);
    if ((tknKind) == (TOKEN_COLON_DOUBLE))
        return ((usize)(18llu));
    else if ((tknKind) == (TOKEN_DOT))
        return ((usize)(17llu));
    else if ((tknKind) == (TOKEN_PAREN_OPEN))
        return ((usize)(16llu));
    else if ((tknKind) == (TOKEN_SQUARE_OPEN))
        return ((usize)(16llu));
    else if ((tknKind) == (TOKEN_KEYWORD)) {
        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((tkn)->content)), (&(KEYWORD_AS)))), ("unsupported keyword in getBinaryPrecedence")));
        return ((usize)(13llu));
    }

    else if ((tknKind) == (TOKEN_SLASH_SINGLE))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_ASTERISK_SINGLE))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_PERCENT))
        return ((usize)(12llu));
    else if ((tknKind) == (TOKEN_PLUS_SINGLE))
        return ((usize)(11llu));
    else if ((tknKind) == (TOKEN_MINUS_SINGLE))
        return ((usize)(11llu));
    else if ((tknKind) == (TOKEN_LESS_THAN))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_LESS_THAN_EQUAL))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_GREATER_THAN))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_GREATER_THAN_EQUAL))
        return ((usize)(9llu));
    else if ((tknKind) == (TOKEN_EQUAL_DOUBLE))
        return ((usize)(8llu));
    else if ((tknKind) == (TOKEN_NOT_EQUAL))
        return ((usize)(8llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_SINGLE))
        return ((usize)(7llu));
    else if ((tknKind) == (TOKEN_CARET))
        return ((usize)(6llu));
    else if ((tknKind) == (TOKEN_PIPE_SINGLE))
        return ((usize)(5llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_DOUBLE))
        return ((usize)(4llu));
    else if ((tknKind) == (TOKEN_PIPE_DOUBLE))
        return ((usize)(3llu));
    else if ((tknKind) == (TOKEN_EQUAL_SINGLE))
        return ((usize)(2llu));
    ((unreachablePcrN)(("Exhaustive handling of binary operators in Parser.getBinaryPrecedence")));
}
Assoc_u getBinaryAssociativityPS2466PS6070rU6350(Parser_s *this, Token_s *tkn) {
    usize tknKind = ((tkn)->kind);
    if ((tknKind) == (TOKEN_EQUAL_SINGLE))
        return (((Assoc_u){.tag = 1}));
    return (((Assoc_u){.tag = 0}));
}
usize getUnaryPrecedencePS2466uszrusz(Parser_s *this, usize tknKind) {
    if ((tknKind) == (TOKEN_MINUS_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_ASTERISK_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_AMPERSAND_SINGLE))
        return ((usize)(14llu));
    else if ((tknKind) == (TOKEN_BANG))
        return ((usize)(14llu));
    ((unreachablePcrN)(("Exhaustive handling of unary operators in Parser.getUnaryPrecedence")));
}
Parser_s newParserFromSourceuszS7720rS2466(usize fileID, SubStr_s src) {
    return ((Parser_s){
        .lexer = ((newLexeruszS7720rS3493)((fileID), (src))), .anonFnCount = ((usize)(0llu)), .importRoots = (NULL), .importRootLength = ((usize)(0llu)), .importRootCapacity = ((usize)(0llu))});
}
ModuleLookup_s *insertFilePS7791PS1892rPS0997(Lookup_s *this, ParsedFile_s *file) {
    SubStr_s tmp_51340 = ((newSubStrOfStrLitPcrS7720)(("<file module>")));

    ModuleLookup_s lookup = ((ModuleLookup_s){
        .name = ((newTokenuszPS7720uszuszrS6070)(((usize)(0llu)), (&tmp_51340), ((usize)(0llu)), (TOKEN_IDENT))), .globalID = ((getIDPS1882rusz)(((file)->mod))), .globalLookup = (this)});
    ((pushPS5541S1913rN)((&((lookup).variables)), ((ScopeLookup_s){0})));
    ((pushPS5121S0997rN)((&((this)->files)), (lookup)));
    return ((lastPS5121rPS0997)((&((this)->files))));
}
FunctionLookup_s *getFunctionByGlobalIDPS7791uszrPS0677(Lookup_s *this, usize funcID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((getFunctionByGlobalIDPS0997uszrPS0677)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (funcID)));
        if ((f) != (NULL))
            return (f);
    }

    ((unreachablePcrN)(("Lookup failed to find function based on global ID!")));
}
ModuleLookup_s *getModuleByGlobalIDPS7791uszrPS0997(Lookup_s *this, usize modID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((getModuleByGlobalIDPS0997uszrPS0997)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (modID)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find module based on global ID!")));
}
StructLookup_s *getStructByGlobalIDPS7791uszrPS4228(Lookup_s *this, usize structID) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *m = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (structID)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find struct based on global ID!")));
}
UnionLookup_s *getUnionByGlobalDeclPS7791PS0997rPS1592(Lookup_s *this, ParsedUnionDecl_s *decl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *m = ((getUnionByGlobalDeclPS0997PS0997rPS1592)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (decl)));
        if ((m) != (NULL))
            return (m);
    }

    ((unreachablePcrN)(("Lookup failed to find union based on global declaration!")));
}
TypeLookup_s getTypeLookupForTypePS7791PU5175rS6177(Lookup_s *this, Type_u *typ) {
    bool succ_6624_ = true;

    Type_u *tmp_10219_ = (typ);
    {
        succ_6624_ &= (tmp_10219_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_10219_->payload.variant7._0;
        succ_6624_ &= true;
        if (succ_6624_) {
            {
                if (((*decl)->parent).isFile) {
                    usize fileID = ((usize)((((*decl)->parent).id)));
                    StructLookup_s *s = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->files)), (fileID))), ((getIDPS5521rusz)((*decl)))));
                    return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s)));
                }

                else {
                    StructLookup_s *s = ((getStructByGlobalIDPS7791uszrPS4228)((this), ((getIDPS5521rusz)((*decl)))));
                    return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s)));
                }
            }
            goto after_10219;
        }
    }
    {
        if (true) {
            {
            }
            goto after_10219;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10219:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Lookup.getTypeLookupForType got non-struct type")));
}
StructLookup_s *findStructByNameInFilePS7791PS7720PS7720rPS4228(Lookup_s *this, SubStr_s *file, SubStr_s *name) {
    TypeLookupList_s structs = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((this), (name)));
    StructLookup_s *context = (NULL);
    for (usize i = ((usize)(0llu)); ((i) < ((structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s *l = ((atPS1581uszrPS6177)((&(structs)), (i)));
        if (((l)->kind) == (TYPE_LOOKUP_STRUCT)) {
            StructLookup_s *s = ((StructLookup_s *)(((l)->actual)));
            ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), ((s)->globalID)));
            if (!(((decl)->parent).isFile))
                continue;
            ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
            String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
            String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
            ((dropPS0540rN)((&(filePath))));
            SubStr_s tmp_51604 = ((asSubStrPS0540rS7720)((&(fileName))));

            if ((equalsPS7720PS7720rB)((&tmp_51604), (file))) {
                ((assertBPcrN)(((context) == (NULL)), ("How did we find another file?")));
                ((context) = (s));
            }

            ((dropPS0540rN)((&(fileName))));
        }
    }

    ((dropPS1581rN)((&(structs))));
    return (context);
}
UnionLookup_s *findUnionByNameInFilePS7791PS7720PS7720rPS1592(Lookup_s *this, SubStr_s *file, SubStr_s *name) {
    TypeLookupList_s unions = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((this), (name)));
    UnionLookup_s *context = (NULL);
    for (usize i = ((usize)(0llu)); ((i) < ((unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s *l = ((atPS1581uszrPS6177)((&(unions)), (i)));
        if (((l)->kind) == (TYPE_LOOKUP_UNION)) {
            UnionLookup_s *s = ((UnionLookup_s *)(((l)->actual)));
            ParsedUnionDecl_s *decl = ((s)->global);
            if (!(((decl)->parent).isFile))
                continue;
            ParsedFile_s *parent = ((atPS9483uszrPS1892)((&(files)), ((usize)((((decl)->parent).id)))));
            String_s filePath = ((toStringPS7720rS0540)((&((parent)->origin))));
            String_s fileName = ((getFileNamePS0540rS0540)((&(filePath))));
            ((dropPS0540rN)((&(filePath))));
            SubStr_s tmp_51693 = ((asSubStrPS0540rS7720)((&(fileName))));

            if ((equalsPS7720PS7720rB)((&tmp_51693), (file))) {
                ((assertBPcrN)(((context) == (NULL)), ("How did we find another file?")));
                ((context) = (s));
            }

            ((dropPS0540rN)((&(fileName))));
        }
    }

    ((dropPS1581rN)((&(unions))));
    return (context);
}
TypeLookupList_s searchAllFilesForTypeNamePS7791PS7720rS1581(Lookup_s *this, SubStr_s *name) {
    TypeLookupList_s list = ((TypeLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TypeLookup_s t = ((TypeLookup_s){0});
        if ((resolveTypeByNamePS0997PS7720PS6177BrB)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (name), (&(t)), (false))) {
            ((pushPS1581S6177rN)((&(list)), (t)));
        }
    }

    return (list);
}
FunctionLookupList_s searchAllFilesForFunctionNamePS7791PS6070rS8385(Lookup_s *this, Token_s *name) {
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookupList_s t = ((resolveFunctionByNamePS0997PS6070rS8385)(((atPS5121uszrPS0997)((&((this)->files)), (i))), (name)));
        ((extendPS8385PS8385rN)((&(list)), (&(t))));
    }

    return (list);
}
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070rS3313(Lookup_s *this, Token_s *name) { return ((searchAllFilesForIdentifierPS7791PS6070BrS3313)((this), (name), (false))); }
VariableLookupList_s searchAllFilesForIdentifierPS7791PS6070BrS3313(Lookup_s *this, Token_s *name, bool globalOnly) {
    VariableLookupList_s list = ((VariableLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((atPS5121uszrPS0997)((&((this)->files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < (((m)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ScopeLookup_s *s = ((atPS5541uszrPS1913)((&((m)->variables)), (j)));
            VariableLookup_s v = ((VariableLookup_s){0});
            if ((getVariableByNamePS1913S7720PS6661rB)((s), ((name)->content), (&(v)))) {
                ((pushPS3313S6661rN)((&(list)), (v)));
            }

            if (globalOnly)
                break;
        }
    }

    return (list);
}
bool equalsPS5071PS5071rB(FileLookup_s *this, FileLookup_s *other) { return ((equalsPS7720PS7720rB)((&((this)->origin)), (&((other)->origin)))); }
bool insertTLIPS0997PS1038rB(ModuleLookup_s *this, ParsedTopLevelItem_s *tli) {
    ((assertBPcrN)((((this)->globalLookup) != (NULL)), ("insertTLI called on ModuleLookup without Global Lookup")));
    if (((tli)->kind) == (TLI_FUNC_DECL)) {
        ParsedFuncDecl_s *fun = ((atPS4111uszrPS4904)((&(funcDecls)), ((tli)->nodeID)));
        FunctionLookup_s lookup = ((FunctionLookup_s){.globalID = ((tli)->nodeID),
                                                      .parent = ((tli)->parent),
                                                      .name = ((fun)->name),
                                                      .params = ((VariableLookupList_s){0}),
                                                      .fnType = (((TCState_u){.tag = 0, .payload = {0}})),
                                                      .isVarArg = (((fun)->params).isVarArg)});
        ((pushPS8385S0677rN)((&((this)->functions)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_IMPORT)) {
        usize fileID = ((tli)->nodeID);
        ((assertBrN)(((fileID) < ((files).length))));
        ImportLookup_s lookup = ((ImportLookup_s){.span = ((tli)->span), .fileID = (fileID)});
        if ((containsPS3606PS6218rB)((&((this)->imports)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_51942 = (((getPS3606PS6218rPS6218)((&((this)->imports)), (&(lookup))))->span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_51942)));
            (((fprintf))((stderr_), ("%s: %s: Can not import the same file twice.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: File already imported here.\n"), ((_loc).buffer), (NOTE_STR)));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS3606S6218rN)((&((this)->imports)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_MOD_DECL)) {
        usize modID = ((tli)->nodeID);
        ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), (modID)));
        ModuleLookup_s lookup =
            ((ModuleLookup_s){.globalLookup = ((this)->globalLookup), .parent = ((atPS7393uszrPS1882)((&(modules)), ((this)->globalID))), .name = ((mod)->name), .globalID = (modID)});
        if ((containsPS5121PS0997rB)((&((this)->modules)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52035 = ((((getPS5121PS0997rPS0997)((&((this)->modules)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52035)));
            String_s name = ((toStringPS6070rS0540)((&((mod)->name))));
            (((fprintf))((stderr_), ("%s: %s: Module redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Module `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS5541S1913rN)((&((lookup).variables)), ((ScopeLookup_s){0})));
        for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu)))))
            ((insertTLIPS0997PS1038rB)((&(lookup)), ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))))));
        ((pushPS5121S0997rN)((&((this)->modules)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_STRUCT_DECL)) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), ((tli)->nodeID)));
        StructLookup_s lookup = ((StructLookup_s){.globalID = ((tli)->nodeID),
                                                  .parent = ((tli)->parent),
                                                  .name = ((strukt)->name),
                                                  .fields = ((VariableLookupList_s){0}),
                                                  .type = ((wrapU5175rPU5175)(((Type_u){.tag = 7, .payload = {.variant7 = {._0 = (strukt)}}})))});
        if ((containsPS7392PS4228rB)((&((this)->structs)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52179 = ((((getPS7392PS4228rPS4228)((&((this)->structs)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52179)));
            String_s name = ((toStringPS6070rS0540)((&((strukt)->name))));
            (((fprintf))((stderr_), ("%s: %s: Struct redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Struct `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS7392S4228rN)((&((this)->structs)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_UNION_DECL)) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), ((tli)->nodeID)));
        UnionLookup_s lookup = ((UnionLookup_s){.global = (onion),
                                                .parent = ((tli)->parent),
                                                .name = ((onion)->name),
                                                .variants = ((UnionVariantLookupList_s){0}),
                                                .type = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (onion), ._1 = ((usize)(0llu))}}})))});
        if ((containsPS4836PS1592rB)((&((this)->unions)), (&(lookup)))) {
            String_s loc = ((toStringPS8951rS0540)((&((tli)->span))));
            Span_s tmp_52286 = ((((getPS4836PS1592rPS1592)((&((this)->unions)), (&(lookup))))->name).span);

            String_s _loc = ((toStringPS8951rS0540)((&tmp_52286)));
            String_s name = ((toStringPS6070rS0540)((&((onion)->name))));
            (((fprintf))((stderr_), ("%s: %s: Union redeclaration.\n"), ((loc).buffer), (ERR_STR)));
            (((fprintf))((stderr_), ("%s: %s: Union `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((name).buffer)));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(_loc))));
            ((dropPS0540rN)((&(loc))));
            return (false);
        }

        ((pushPS4836S1592rN)((&((this)->unions)), (lookup)));
    }

    else if (((tli)->kind) == (TLI_VAR_DECL)) {
        ParsedStmt_s *varDecl = ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)));
        ((assertBPcrN)(((((this)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope")));
        ScopeLookup_s *globalScope = ((lastPS5541rPS1913)((&((this)->variables))));
        ParsedPattern_s *pat = (NULL);
        bool isComptime = (false);
        bool succ_6722_ = true;

        StmtData_u *tmp_10380_ = (&((varDecl)->data));
        {
            succ_6722_ &= (tmp_10380_->tag == 0);
            VarDecl_s *decl = &tmp_10380_->payload.variant0._0;
            succ_6722_ &= true;
            if (succ_6722_) {
                {
                    ((pat) = ((*decl).pat));
                    ((isComptime) = ((*decl).isComptime));
                }
                goto after_10380;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_10380;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10380:
        (void)0; // error: label at end of compound statement is a C23 extension
        return ((insertVariablesPS0997PS1826PS1913BrB)((this), (pat), (globalScope), (isComptime)));
    }

    else if (((tli)->kind) == (TLI_CONFIG)) {
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of TLI kinds in insertTLI")));
    }

    return (true);
}
bool _anon_24_0PS1913PS6661PS1826PS6070rB(ScopeLookup_s *globalScope, VariableLookup_s *lookup, ParsedPattern_s *pat, Token_s *name) {
    Token_s duplVar = ((Token_s){0});
    if ((isKnownVariablePS1913S7720PS6070rB)((globalScope), (((lookup)->name).content), (&(duplVar)))) {
        String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s _name = ((toStringPS6070rS0540)((name)));
        String_s _loc = ((toStringPS8951rS0540)((&((duplVar).span))));
        (((fprintf))((stderr_), ("%s: %s: Variable redeclaration.\n"), ((loc).buffer), (ERR_STR)));
        (((fprintf))((stderr_), ("%s: %s: Variable `%s` already declared here.\n"), ((_loc).buffer), (NOTE_STR), ((_name).buffer)));
        ((dropPS0540rN)((&(_name))));
        ((dropPS0540rN)((&(_loc))));
        ((dropPS0540rN)((&(loc))));
        return (true);
    }

    return (false);
}
bool insertVariablesPS0997PS1826PS1913BrB(ModuleLookup_s *this, ParsedPattern_s *pat, ScopeLookup_s *globalScope, bool isComptime) {
    bool (*check_known)(ScopeLookup_s *, VariableLookup_s *, ParsedPattern_s *, Token_s *) = (_anon_24_0PS1913PS6661PS1826PS6070rB);
    bool succ_6732_ = true;
    bool succ_6735_ = true;
    bool succ_6737_ = true;
    bool succ_6740_ = true;
    bool succ_6742_ = true;
    bool succ_6746_ = true;
    bool succ_6749_ = true;
    bool succ_6754_ = true;
    bool succ_6758_ = true;
    bool succ_6764_ = true;

    Pattern_u tmp_10438_ = ((pat)->data);
    {
        succ_6732_ &= (tmp_10438_.tag == 0);
        if (succ_6732_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10438;
        }
    }
    {
        succ_6735_ &= (tmp_10438_.tag == 1);
        succ_6735_ &= true;
        if (succ_6735_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10438;
        }
    }
    {
        succ_6737_ &= (tmp_10438_.tag == 8);
        if (succ_6737_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10438;
        }
    }
    {
        succ_6740_ &= (tmp_10438_.tag == 9);
        succ_6740_ &= true;
        if (succ_6740_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10438;
        }
    }
    {
        succ_6742_ &= (tmp_10438_.tag == 10);
        if (succ_6742_) {
            {
                ((todo_with_msgPcrN)(("insertVariables: Invalid pattern")));
            }
            goto after_10438;
        }
    }
    {
        succ_6746_ &= (tmp_10438_.tag == 3);
        ParsedPattern_s **subpat = &tmp_10438_.payload.variant3._0;
        succ_6746_ &= true;
        succ_6746_ &= true;
        if (succ_6746_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10438;
        }
    }
    {
        succ_6749_ &= (tmp_10438_.tag == 2);
        Token_s *name = &tmp_10438_.payload.variant2._0;
        succ_6749_ &= true;
        if (succ_6749_) {
            {
                VariableLookup_s lookup =
                    ((VariableLookup_s){.globalID = ((getIDPS1826rusz)((pat))), .name = (*name), .typeState = (((TCState_u){.tag = 0, .payload = {0}})), .isComptime = (isComptime)});
                if ((check_known)((globalScope), (&(lookup)), (pat), (&(*name))))
                    return (false);
                ((addVariablePS1913S6661rN)((globalScope), (lookup)));
                return (true);
            }
            goto after_10438;
        }
    }
    {
        succ_6754_ &= (tmp_10438_.tag == 4);
        ParsedPattern_s **subpat = &tmp_10438_.payload.variant4._0;
        succ_6754_ &= true;
        if (succ_6754_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10438;
        }
    }
    {
        succ_6758_ &= (tmp_10438_.tag == 5);
        Token_s *name = &tmp_10438_.payload.variant5._0;
        succ_6758_ &= true;
        ParsedPatternList_s *subpats = &tmp_10438_.payload.variant5._1;
        succ_6758_ &= true;
        if (succ_6758_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*subpats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if (!((insertVariablesPS0997PS1826PS1913BrB)((this), ((((*subpats).elements))[(i)]), (globalScope), (isComptime))))
                        return (false);
                }

                return (true);
            }
            goto after_10438;
        }
    }
    {
        succ_6764_ &= (tmp_10438_.tag == 6);
        succ_6764_ &= true;
        ParsedPattern_s **subpat = &tmp_10438_.payload.variant6._1;
        succ_6764_ &= true;
        if (succ_6764_) {
            {
                return ((insertVariablesPS0997PS1826PS1913BrB)((this), (*subpat), (globalScope), (isComptime)));
            }
            goto after_10438;
        }
    }
    {
        if (true) {
            {
            }
            goto after_10438;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10438:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("insertVariables: Exhaustive handling of patterns")));
}
bool containsDuplicateFunctionPS0997PS0677PPS0677rB(ModuleLookup_s *this, FunctionLookup_s *function, FunctionLookup_s **dupl) {
    ((assertBPcrN)(((this) != (NULL)), ("containsDuplicateFunction called with null-Lookup")));
    String_s name = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((function)->globalID)))));
    bool duplicate = (false);
    for (usize i = ((usize)(0llu)); ((!(duplicate)) && ((i) < (((this)->functions).length))); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((f) == (function))
            continue;
        String_s n = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((f)->globalID)))));
        if ((equalsPS0540PS0540rB)((&(name)), (&(n)))) {
            ((*(dupl)) = (f));
            ((duplicate) = (true));
        }

        ((dropPS0540rN)((&(n))));
    }

    return (duplicate);
}
bool equalsPS6218PS6218rB(ImportLookup_s *this, ImportLookup_s *other) { return (((this)->fileID) == ((other)->fileID)); }
bool equalsPS0997PS0997rB(ModuleLookup_s *this, ModuleLookup_s *other) {
    if (!((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))))
        return (false);
    return ((equalsPS1882PS1882rB)(((this)->parent), ((other)->parent)));
}
FunctionLookup_s *getFunctionByGlobalIDPS0997uszrPS0677(ModuleLookup_s *this, usize funcID) { return ((getFunctionByGlobalIDPS0997uszBrPS0677)((this), (funcID), (true))); }
FunctionLookup_s *getFunctionByGlobalIDPS0997uszBrPS0677(ModuleLookup_s *this, usize funcID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getFunctionByGlobalID called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if (((f)->globalID) == (funcID)) {
            return (f);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *mod = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
        FunctionLookup_s *fn = ((getFunctionByGlobalIDPS0997uszBrPS0677)((mod), (funcID), (false)));
        if ((fn) != (NULL))
            return (fn);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookup_s *fn = ((getFunctionByGlobalIDPS0997uszBrPS0677)((imp), (funcID), (false)));
            if ((fn) != (NULL))
                return (fn);
        }
    }

    return (NULL);
}
ModuleLookup_s *getModuleByGlobalIDPS0997uszrPS0997(ModuleLookup_s *this, usize modID) { return ((getModuleByGlobalIDPS0997uszBrPS0997)((this), (modID), (true))); }
ModuleLookup_s *getModuleByGlobalIDPS0997uszBrPS0997(ModuleLookup_s *this, usize modID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getModuleByGlobalID called with null-Lookup")));
    if (((this)->globalID) == (modID))
        return (this);
    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *m = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
        ModuleLookup_s *lookup = ((getModuleByGlobalIDPS0997uszrPS0997)((m), (modID)));
        if ((lookup) != (NULL))
            return (lookup);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            ModuleLookup_s *mod = ((getModuleByGlobalIDPS0997uszBrPS0997)((imp), (modID), (false)));
            if ((mod) != (NULL))
                return (mod);
        }
    }

    return (NULL);
}
StructLookup_s *getStructByGlobalIDPS0997uszrPS4228(ModuleLookup_s *this, usize structID) { return ((getStructByGlobalIDPS0997uszBrPS4228)((this), (structID), (true))); }
StructLookup_s *getStructByGlobalIDPS0997uszBrPS4228(ModuleLookup_s *this, usize structID, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("getStructByGlobalID called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if (((s)->globalID) == (structID)) {
            return (s);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((getStructByGlobalIDPS0997uszrPS4228)(((atPS5121uszrPS0997)((&((this)->modules)), (i))), (structID)));
        if ((s) != (NULL))
            return (s);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            StructLookup_s *str = ((getStructByGlobalIDPS0997uszBrPS4228)((imp), (structID), (false)));
            if ((str) != (NULL))
                return (str);
        }
    }

    return (NULL);
}
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997rPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl) { return ((getUnionByGlobalDeclPS0997PS0997BrPS1592)((this), (decl), (true))); }
UnionLookup_s *getUnionByGlobalDeclPS0997PS0997BrPS1592(ModuleLookup_s *this, ParsedUnionDecl_s *decl, bool checkImport) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if (((e)->global) == (decl)) {
            return (e);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *m = ((getUnionByGlobalDeclPS0997PS0997rPS1592)(((atPS5121uszrPS0997)((&((this)->modules)), (i))), (decl)));
        if ((m) != (NULL))
            return (m);
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            UnionLookup_s *e = ((getUnionByGlobalDeclPS0997PS0997BrPS1592)((imp), (decl), (false)));
            if ((e) != (NULL))
                return (e);
        }
    }

    return (NULL);
}
u32 resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32(ModuleLookup_s *this, Token_s *name, VariableLookup_s **var, TypeLookup_s *typ, FunctionLookupList_s *fun) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveIdentifierByName called with null-Lookup")));
    ((assertBPcrN)(((((this)->variables).length) > ((usize)(0llu))), ("Unexpected length of global variable lookup")));
    ScopeLookup_s *global = ((lastPS5541rPS1913)((&((this)->variables))));
    for (usize i = ((usize)(0llu)); ((i) < (((global)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((global)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
            ((*(var)) = (v));
            return (IDENT_VAR);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if ((equalsPS7720PS7720rB)((&(((s)->name).content)), (&((name)->content)))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s))));
            return (IDENT_TYPE);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *u = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((u)->name).content)), (&((name)->content)))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (u))));
            return (IDENT_TYPE);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((pushPS8385S0677rN)((fun), (*(f))));
        }
    }

    if (((fun)->length) > ((usize)(0llu)))
        return (IDENT_FUNC);
    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32)((parentMod), (name), (var), (typ), (fun)));
    }

    return (IDENT_NONE);
}
bool resolveModuleByNamePS0997PS6070PPS0997rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod) {
    return ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((this), (name), (mod), ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (true), .checkParent = (true)})));
}
bool resolveModuleByNamePS0997PS6070PPS0997S5972rB(ModuleLookup_s *this, Token_s *name, ModuleLookup_s **mod, MLConfig_s c) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveModuleByName called with null-Lookup")));
    if (((c).checkSelf) && ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&((name)->content))))) {
        ((*(mod)) = (this));
        return (true);
    }

    if ((c).checkModule) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->modules).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *submodule = ((atPS5121uszrPS0997)((&((this)->modules)), (i)));
            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((submodule), (name), (mod), ((MLConfig_s){.checkSelf = (true)})))
                return (true);
        }
    }

    if ((c).checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((imp), (name), (mod), ((MLConfig_s){.checkSelf = (true), .checkModule = ((c).checkModule)})))
                return (true);
        }
    }

    if (((c).checkParent) && (((this)->parent) != (NULL))) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((parentMod), (name), (mod),
                                                                ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = ((c).checkModule), .checkParent = (true)})));
    }

    return (false);
}
bool resolveVariableByNamePS0997PS6070PS5541PS6661rB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var) {
    return ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((this), (name), (scopes), (var), (true)));
}
bool resolveVariableByNamePS0997PS6070PS5541PS6661BrB(ModuleLookup_s *this, Token_s *name, ScopeLookupList_s *scopes, VariableLookup_s *var, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveVariableByName called with null-Lookup")));
    for (usize _i = ((usize)(0llu)); ((_i) < ((scopes)->length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = ((((scopes)->length) - (_i)) - ((usize)(1llu)));
        ScopeLookup_s *s = ((atPS5541uszrPS1913)((scopes), (i)));
        for (usize j = ((usize)(0llu)); ((j) < (((s)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
            VariableLookup_s *v = ((atPS3313uszrPS6661)((&((s)->variables)), (j)));
            if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
                ((*(var)) = (*(v)));
                return (true);
            }
        }
    }

    ScopeLookup_s *globalScope = ((atPS5541uszrPS1913)((&((this)->variables)), ((usize)(0llu))));
    for (usize j = ((usize)(0llu)); ((j) < (((globalScope)->variables).length)); ((j) = ((j) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((globalScope)->variables)), (j)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&((name)->content)))) {
            ((*(var)) = (*(v)));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((imp), (name), (scopes), (var), (false)))
                return (true);
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveVariableByNamePS0997PS6070PS5541PS6661BrB)((parentMod), (name), (scopes), (var), (true)));
    }

    return (false);
}
StructLookupList_s resolveAllStructsWithFieldPS0997PS6070PU5175rS7392(ModuleLookup_s *this, Token_s *name, Type_u *typ) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveAllStructsWithField called with null-Lookup")));
    StructLookupList_s list = ((StructLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        VariableLookup_s v = ((VariableLookup_s){0});
        if ((resolveFieldByNamePS4228PS6070PS6661rB)((s), (name), (&(v)))) {
            ((assertBrN)(((isTypePU9661rB)((&((v).typeState))))));
            Type_u *t = ((getTypePU9661rPU5175)((&((v).typeState))));
            if ((equalsPU5175PU5175rB)((t), (typ))) {
                ((pushPS7392S4228rN)((&(list)), (*(s))));
            }
        }
    }

    return (list);
}
bool resolveTypeByNamePS0997PS7720PS6177rB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ) { return ((resolveTypeByNamePS0997PS7720PS6177BrB)((this), (name), (typ), (true))); }
bool resolveTypeByNamePS0997PS7720PS6177BrB(ModuleLookup_s *this, SubStr_s *name, TypeLookup_s *typ, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveTypeByName called with null-Lookup")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->structs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((&((this)->structs)), (i)));
        if ((equalsPS7720PS7720rB)((&(((s)->name).content)), (name))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (s))));
            return (true);
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((e)->name).content)), (name))) {
            ((*(typ)) = ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (e))));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveTypeByNamePS0997PS7720PS6177BrB)((imp), (name), (typ), (false)))
                return (true);
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        return ((resolveTypeByNamePS0997PS7720PS6177BrB)((parentMod), (name), (typ), (true)));
    }

    return (false);
}
FunctionLookupList_s resolveFunctionByNamePS0997PS6070rS8385(ModuleLookup_s *this, Token_s *name) { return ((resolveFunctionByNamePS0997PS6070BrS8385)((this), (name), (true))); }
FunctionLookupList_s resolveFunctionByNamePS0997PS6070BrS8385(ModuleLookup_s *this, Token_s *name, bool checkImport) {
    ((assertBPcrN)(((this) != (NULL)), ("resolveFunctionByName called with null-Lookup")));
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((pushPS8385S0677rN)((&(list)), (*(f))));
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookupList_s _list = ((resolveFunctionByNamePS0997PS6070BrS8385)((imp), (name), (false)));
            ((extendPS8385PS8385rN)((&(list)), (&(_list))));
        }
    }

    if (((this)->parent) != (NULL)) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        FunctionLookupList_s _list = ((resolveFunctionByNamePS0997PS6070BrS8385)((parentMod), (name), (true)));
        ((extendPS8385PS8385rN)((&(list)), (&(_list))));
    }

    return (list);
}
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ) {
    return ((
        resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((this), (name), (typ),
                                                                       ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (false), .checkParent = (true), .allowData = (true)})));
}
FunctionLookupList_s resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385(ModuleLookup_s *this, Token_s *name, Type_u *typ, MLConfig_s config) {
    TypeList_s params1 = ((TypeList_s){0});
    Type_u *ret1 = (NULL);
    bool succ_6908_ = true;

    Type_u *tmp_10743_ = (typ);
    {
        succ_6908_ &= (tmp_10743_->tag == 6);
        TypeList_s *params = &tmp_10743_->payload.variant6._0;
        succ_6908_ &= true;
        Type_u **ret = &tmp_10743_->payload.variant6._1;
        succ_6908_ &= true;
        succ_6908_ &= true;
        if (succ_6908_) {
            {
                ((params1) = (*params));
                ((ret1) = (*ret));
            }
            goto after_10743;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_10743;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_10743:
    (void)0; // error: label at end of compound statement is a C23 extension
    FunctionLookupList_s list = ((FunctionLookupList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->functions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&((this)->functions)), (i)));
        if (!((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content))))) {
            continue;
        }

        Type_u *_rt = ((getTypePU9661rPU5175)((&((f)->fnType))));
        bool succ_6922_ = true;

        Type_u *tmp_10772_ = (_rt);
        {
            succ_6922_ &= (tmp_10772_->tag == 6);
            TypeList_s *params2 = &tmp_10772_->payload.variant6._0;
            succ_6922_ &= true;
            Type_u **ret2 = &tmp_10772_->payload.variant6._1;
            succ_6922_ &= true;
            succ_6922_ &= true;
            if (succ_6922_) {
                {
                    if (((params1).length) != ((*params2).length))
                        continue;
                    if (!((isUnknownPU5175rB)((ret1))))
                        if (!((_equalsPU5175PU5175BrB)((ret1), (*ret2), ((config).allowData))))
                            continue;
                    bool succ = (true);
                    for (usize j = ((usize)(0llu)); ((j) < ((params1).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        Type_u *t1 = (*((atPS0643uszrPPU5175)((&(params1)), (j))));
                        Type_u *t2 = (*((atPS0643uszrPPU5175)((&(*params2)), (j))));
                        if (!((isUnknownPU5175rB)((t1))))
                            if (!((_equalsPU5175PU5175BrB)((t1), (t2), ((config).allowData)))) {
                                ((succ) = (false));
                                break;
                            }
                    }

                    if (succ)
                        ((pushPS8385S0677rN)((&(list)), (*(f))));
                }
                goto after_10772;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_10772;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_10772:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    if ((config).checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            FunctionLookupList_s _list =
                ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((imp), (name), (typ), ((MLConfig_s){.checkSelf = (true), .allowData = ((config).allowData)})));
            ((extendPS8385PS8385rN)((&(list)), (&(_list))));
        }
    }

    if (((config).checkParent) && (((this)->parent) != (NULL))) {
        ModuleLookup_s *parentMod = ((getModuleByGlobalIDPS7791uszrPS0997)(((this)->globalLookup), ((getIDPS1882rusz)(((this)->parent)))));
        FunctionLookupList_s fns = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)((parentMod), (name), (typ),
                                                                                                    ((MLConfig_s){.checkSelf = (true),
                                                                                                                  .checkImport = (true),
                                                                                                                  .checkModule = (false),
                                                                                                                  .checkParent = (true),
                                                                                                                  .allowData = ((config).allowData)})));
        ((extendPS8385PS8385rN)((&(list)), (&(fns))));
    }

    return (list);
}
bool resolveUnionByNamePS0997PS6070PPS1592rB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion) { return ((resolveUnionByNamePS0997PS6070PPS1592BrB)((this), (name), (onion), (true))); }
bool resolveUnionByNamePS0997PS6070PPS1592BrB(ModuleLookup_s *this, Token_s *name, UnionLookup_s **onion, bool checkImport) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->unions).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *e = ((atPS4836uszrPS1592)((&((this)->unions)), (i)));
        if ((equalsPS7720PS7720rB)((&(((e)->name).content)), (&((name)->content)))) {
            ((*(onion)) = (e));
            return (true);
        }
    }

    if (checkImport) {
        for (usize i = ((usize)(0llu)); ((i) < (((this)->imports).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ModuleLookup_s *imp = ((atPS5121uszrPS0997)((&(((this)->globalLookup)->files)), (((atPS3606uszrPS6218)((&((this)->imports)), (i)))->fileID)));
            if ((resolveUnionByNamePS0997PS6070PPS1592BrB)((imp), (name), (onion), (false)))
                return (true);
        }
    }

    return (false);
}
none addParameterPS0677uszS6070U9661rN(FunctionLookup_s *this, usize globalID, Token_s name, TCState_u typeState) {
    ((pushPS3313S6661rN)((&((this)->params)), ((VariableLookup_s){.globalID = (globalID), .name = (name), .typeState = (typeState), .isComptime = (false)})));
}
bool checkForDuplicateParamPS0677PS6070PS6661rB(FunctionLookup_s *this, Token_s *name, VariableLookup_s *dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->params).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *param = ((atPS3313uszrPS6661)((&((this)->params)), (i)));
        if ((equalsPS7720PS7720rB)((&(((param)->name).content)), (&((name)->content)))) {
            ((*(dupl)) = (*(param)));
            return (true);
        }
    }

    return (false);
}
bool equalsPS0677PS0677rB(FunctionLookup_s *this, FunctionLookup_s *other) {
    ((warningPcrN)(("When are two functions equal")));
    return ((equalsPS6070PS6070rB)((&((this)->name)), (&((other)->name))));
}
String_s getNamePS6177rS0540(TypeLookup_s *this) {
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        SubStr_s tmp_54281 = ((((asStructPS6177rPS4228)((this)))->name).content);

        return ((toStringPS7720rS0540)((&tmp_54281)));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        SubStr_s tmp_54296 = ((((asUnionPS6177rPS1592)((this)))->name).content);

        return ((toStringPS7720rS0540)((&tmp_54296)));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling in TypeLookup.getName")));
    }
}
String_s getLocationPS6177rS0540(TypeLookup_s *this) {
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        Span_s tmp_54314 = ((((asStructPS6177rPS4228)((this)))->name).span);

        return ((toStringPS8951rS0540)((&tmp_54314)));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        Span_s tmp_54329 = ((((asUnionPS6177rPS1592)((this)))->name).span);

        return ((toStringPS8951rS0540)((&tmp_54329)));
    }

    else {
        ((unreachablePcrN)(("Exhaustive handling in TypeLookup.getLocation")));
    }
}
bool equalsPS6177PS6177rB(TypeLookup_s *this, TypeLookup_s *other) {
    if (((this)->kind) != ((other)->kind))
        return (false);
    if (((this)->kind) == (TYPE_LOOKUP_STRUCT)) {
        return ((equalsPS4228PS4228rB)(((asStructPS6177rPS4228)((this))), ((asStructPS6177rPS4228)((other)))));
    }

    else if (((this)->kind) == (TYPE_LOOKUP_UNION)) {
        return ((equalsPS1592PS1592rB)(((asUnionPS6177rPS1592)((this))), ((asUnionPS6177rPS1592)((other)))));
    }

    ((unreachablePcrN)(("Exhaustive handling in TypeLookup.equals")));
}
bool isStructPS6177rB(TypeLookup_s *this) { return (((this)->kind) == (TYPE_LOOKUP_STRUCT)); }
bool isUnionPS6177rB(TypeLookup_s *this) { return (((this)->kind) == (TYPE_LOOKUP_UNION)); }
StructLookup_s *asStructPS6177rPS4228(TypeLookup_s *this) {
    ((assertBPcrN)(((isStructPS6177rB)((this))), ("Attempted to convert non-struct TypeLookup into StructLookup")));
    return ((StructLookup_s *)(((this)->actual)));
}
UnionLookup_s *asUnionPS6177rPS1592(TypeLookup_s *this) {
    ((assertBPcrN)(((isUnionPS6177rB)((this))), ("Attempted to convert non-union TypeLookup into UnionLookup")));
    return ((UnionLookup_s *)(((this)->actual)));
}
TypeLookup_s newTypeLookupuszAnyrS6177(usize kind, Any actual) { return ((TypeLookup_s){.kind = (kind), .actual = (actual)}); }
TypeLookup_s asTypeLookupPS4228rS6177(StructLookup_s *this) { return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_STRUCT), (this))); }
bool equalsPS4228PS4228rB(StructLookup_s *this, StructLookup_s *other) {
    if (!((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent)))))
        return (false);
    return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content))));
}
bool resolveFieldByNamePS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((*(out)) = (*(f)));
            return (true);
        }
    }

    return (false);
}
bool hasFieldPS4228PS7720rB(StructLookup_s *this, SubStr_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (name))) {
            return (true);
        }
    }

    return (false);
}
usize getIndexByNamePS4228PS6070rusz(StructLookup_s *this, Token_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            return (i);
        }
    }

    ((assertBPcrN)(((hasFieldPS4228PS7720rB)((this), (&((name)->content)))), ("StructLookup.getIndexByName() called when StructLookup.hasField() == false")));
    ((unreachablePcrN)(("StructLookup.getIndexByName does not have a field with the given name")));
}
bool checkForDuplicateFieldPS4228PS6070PS6661rB(StructLookup_s *this, Token_s *name, VariableLookup_s *dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *f = ((atPS3313uszrPS6661)((&((this)->fields)), (i)));
        if ((equalsPS7720PS7720rB)((&(((f)->name).content)), (&((name)->content)))) {
            ((*(dupl)) = (*(f)));
            return (true);
        }
    }

    return (false);
}
none addFieldPS4228uszS6070U9661rN(StructLookup_s *this, usize globalID, Token_s name, TCState_u typeState) {
    ((pushPS3313S6661rN)((&((this)->fields)), ((VariableLookup_s){.globalID = (globalID), .name = (name), .typeState = (typeState), .isComptime = (false)})));
}
TypeLookup_s asTypeLookupPS1592rS6177(UnionLookup_s *this) { return ((newTypeLookupuszAnyrS6177)((TYPE_LOOKUP_UNION), (this))); }
bool equalsPS1592PS1592rB(UnionLookup_s *this, UnionLookup_s *other) {
    if (!((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent)))))
        return (false);
    return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content))));
}
bool resolveVariantByNamePS1592PS6070PPS2365rB(UnionLookup_s *this, Token_s *name, UnionVariantLookup_s **variant) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionVariantLookup_s *v = ((atPS4601uszrPS2365)((&((this)->variants)), (i)));
        if ((equalsPS7720PS7720rB)((&((((v)->global)->name).content)), (&((name)->content)))) {
            ((*(variant)) = (v));
            return (true);
        }
    }

    return (false);
}
bool checkForDuplicateVariantPS1592PS3506PPS2365rB(UnionLookup_s *this, ParsedUnionVariant_s *curr, UnionVariantLookup_s **dupl) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionVariantLookup_s *v = ((atPS4601uszrPS2365)((&((this)->variants)), (i)));
        if ((equalsPS7720PS7720rB)((&((((v)->global)->name).content)), (&(((curr)->name).content)))) {
            ((*(dupl)) = (v));
            return (true);
        }
    }

    return (false);
}
none addVariantPS1592PS3506U9661rN(UnionLookup_s *this, ParsedUnionVariant_s *variant, TCState_u typeState) {
    usize tag = (((this)->variants).length);
    ((pushPS4601S2365rN)((&((this)->variants)), ((UnionVariantLookup_s){.global = (variant), .tag = (tag), .typeState = (typeState)})));
}
bool equalsPS2365PS2365rB(UnionVariantLookup_s *this, UnionVariantLookup_s *other) { ((unreachablePcrN)(("UnionVariantLookup.equals"))); }
bool checkForDuplicateNamePS2365PS6070PPS6070rB(UnionVariantLookup_s *this, Token_s *name, Token_s **dupl) { return ((checkForDuplicateNamePS3506PS6070PPS6070rB)(((this)->global), (name), (dupl))); }
StructLookup_s intoStructLookupPS2365rS4228(UnionVariantLookup_s *this) {
    bool succ_6981_ = true;

    ParsedUnionVariantData_u *tmp_10921_ = (&(((this)->global)->data));
    succ_6981_ &= (tmp_10921_->tag == 2);
    ParsedTypeNodeList_s *fields = &tmp_10921_->payload.variant2._0;
    succ_6981_ &= true;
    TokenList_s *names = &tmp_10921_->payload.variant2._1;
    succ_6981_ &= true;
    if (!succ_6981_) {
        ((unreachablePcrN)(("intoStructLookup() called on non-struct variant")));
    };
    StructLookup_s lookup = ((StructLookup_s){.globalID = ((getIDPS3506rusz)(((this)->global))), .parent = (((this)->global)->parent), .name = (((this)->global)->name)});
    for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *field = ((((*fields).elements))[(i)]);
        Token_s *name = (&((((*names).elements))[(i)]));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid variant field type at this point")));
        ((pushPS3313S6661rN)((&((lookup).fields)), ((VariableLookup_s){.globalID = ((getIDPS1372rusz)((field))), .name = (*(name)), .typeState = ((field)->typeState), .isComptime = (false)})));
    }

    return (lookup);
}
bool isParameterPS6661rB(VariableLookup_s *this) { return (((this)->globalID) >= (NODE_ID_OFFSET)); }
bool equalsPS6661PS6661rB(VariableLookup_s *this, VariableLookup_s *other) { return ((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))); }
bool equalsPS1913PS1913rB(ScopeLookup_s *this, ScopeLookup_s *other) { ((todo_with_msgPcrN)(("when are two scopes equal"))); }
none addVariablePS1913S6661rN(ScopeLookup_s *this, VariableLookup_s variable) { ((pushPS3313S6661rN)((&((this)->variables)), (variable))); }
bool isKnownVariablePS1913S7720PS6070rB(ScopeLookup_s *this, SubStr_s name, Token_s *existing) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(existing)) = ((v)->name));
            return (true);
        }
    }

    return (false);
}
bool getVarIndexByNamePS1913S7720PuszrB(ScopeLookup_s *this, SubStr_s name, usize *index) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(index)) = (i));
            return (true);
        }
    }

    return (false);
}
bool getVariableByNamePS1913S7720PS6661rB(ScopeLookup_s *this, SubStr_s name, VariableLookup_s *var) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variables).length)); ((i) = ((i) + ((usize)(1llu))))) {
        VariableLookup_s *v = ((atPS3313uszrPS6661)((&((this)->variables)), (i)));
        if ((equalsPS7720PS7720rB)((&(((v)->name).content)), (&(name)))) {
            ((*(var)) = (*(v)));
            return (true);
        }
    }

    return (false);
}
VariableLookup_s *getVariableAtIndexPS1913uszrPS6661(ScopeLookup_s *this, usize index) { return ((atPS3313uszrPS6661)((&((this)->variables)), (index))); }
none clearPS1913rN(ScopeLookup_s *this) { ((clearPS3313rN)((&((this)->variables)))); }
bool equalsPU9661PU9661rB(TCState_u *this, TCState_u *other) { ((todo_with_msgPcrN)(("TCState.equals"))); }
bool isInvalidPU9661rB(TCState_u *this) {
    TCState_u tmp_55019 = (((TCState_u){.tag = 0, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55019)))));
}
bool wantsInferPU9661rB(TCState_u *this) {
    TCState_u tmp_55030 = (((TCState_u){.tag = 4, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55030)))));
}
bool isCriticalErrorPU9661rB(TCState_u *this) {
    if (!((isErrorPU9661rB)((this))))
        return (false);
    usize err = ((getErrorPU9661rusz)((this)));
    return (((((((err) == (ERROR_NO_SUCH_IDENTIFIER)) || ((err) == (ERROR_NO_SUCH_FUNCTION))) || ((err) == (ERROR_NO_SUCH_METHOD))) || ((err) == (ERROR_DUPLICATE_FUNCTION))) ||
             ((err) == (ERROR_DUPLICATE_METHOD))) ||
            ((err) == (ERROR_DUPLICATE_FIELD)));
}
bool isErrorPU9661rB(TCState_u *this) {
    TCState_u tmp_55072 = (((TCState_u){.tag = 2, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55072)))));
}
bool isSuccessPU9661rB(TCState_u *this) {
    TCState_u tmp_55083 = (((TCState_u){.tag = 1, .payload = {0}}));

    return (((((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55083))))) || ((isTypePU9661rB)((this)))) || ((isPatternPU9661rB)((this))));
}
bool isTypePU9661rB(TCState_u *this) {
    TCState_u tmp_55102 = (((TCState_u){.tag = 3, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55102)))));
}
bool isPatternPU9661rB(TCState_u *this) {
    TCState_u tmp_55113 = (((TCState_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_55113)))));
}
Type_u *getTypePU9661rPU5175(TCState_u *this) {
    bool succ_7096_ = true;

    TCState_u *tmp_11023_ = (this);
    succ_7096_ &= (tmp_11023_->tag == 3);
    Type_u **type = &tmp_11023_->payload.variant3._0;
    succ_7096_ &= true;
    if (!succ_7096_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-type TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*type);
}
usize getErrorPU9661rusz(TCState_u *this) {
    bool succ_7100_ = true;

    TCState_u *tmp_11027_ = (this);
    succ_7100_ &= (tmp_11027_->tag == 2);
    usize *error = &tmp_11027_->payload.variant2._0;
    succ_7100_ &= true;
    if (!succ_7100_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-error TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*error);
}
PatState_s getPatStatePU9661rS1259(TCState_u *this) {
    bool succ_7104_ = true;

    TCState_u *tmp_11031_ = (this);
    succ_7104_ &= (tmp_11031_->tag == 5);
    PatState_s *pat = &tmp_11031_->payload.variant5._0;
    succ_7104_ &= true;
    if (!succ_7104_) {
        (((fprintf))((stderr_), ("ERROR: getType(&TCState) called on non-pattern TCState with kind=%llu\n"), ((tagAnyru8)((this)))));
        ((unreachablerN)());
    };
    return (*pat);
}
none enterAnonFuncPS3900rN(TypeChecker_s *this) { (((this)->anonFuncDepth) = (((this)->anonFuncDepth) + ((usize)(1llu)))); }
none leaveAnonFuncPS3900rN(TypeChecker_s *this) { (((this)->anonFuncDepth) = (((this)->anonFuncDepth) - ((usize)(1llu)))); }
none enterComptimePS3900rN(TypeChecker_s *this) { (((this)->comptimeDepth) = (((this)->comptimeDepth) + ((usize)(1llu)))); }
none leaveComptimePS3900rN(TypeChecker_s *this) { (((this)->comptimeDepth) = (((this)->comptimeDepth) - ((usize)(1llu)))); }
char *pluszPcPcrPc(usize count, char *s1, char *s2) {
    if ((count) == ((usize)(1llu)))
        return (s1);
    return (s2);
}
TCState_u reportUnknownIdentifierPS3900PS6070rU9661(TypeChecker_s *this, Token_s *name) {
    String_s loc = ((getLocationPS6070rS0540)((name)));
    String_s _name = ((toStringPS7720rS0540)((&((name)->content))));
    (((fprintf))((stderr_), ("%s: %s: Use of undeclared identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    VariableLookupList_s alternatives = ((searchAllFilesForIdentifierPS7791PS6070BrS3313)((&((this)->lookup)), (name), (((this)->anonFuncDepth) > ((usize)(0llu)))));
    if (*((flags).verbose)) {
        for (usize i = ((usize)(0llu)); ((i) < ((alternatives).length)); ((i) = ((i) + ((usize)(1llu))))) {
            VariableLookup_s *t = ((atPS3313uszrPS6661)((&(alternatives)), (i)));
            ((dropPS0540rN)((&(loc))));
            ((loc) = ((getLocationPS6070rS0540)((&((t)->name)))));
            (((fprintf))((stderr_), ("%s: %s: A variable with that name is located here. Import the file to use it.\n"), ((loc).buffer), (NOTE_STR)));
        }

    }

    else if (((alternatives).length) > ((usize)(0llu))) {
        ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((alternatives).length), ("global variable with that name"), ("global variables with that name")));
    }

    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_IDENTIFIER)}}});
}
none reportVerboseNotePS3900S0540uszPcPcrN(TypeChecker_s *this, String_s loc, usize count, char *s1, char *s2) {
    char *is = ((pluszPcPcrPc)((count), ("is"), ("are")));
    char *ol = ((pluszPcPcrPc)((count), (s1), (s2)));
    char *it = ((pluszPcPcrPc)((count), ("it"), ("them")));
    (((fprintf))((stderr_), ("%s: %s: There %s %llu %s. Re-run with the --verbose flag to see %s.\n"), ((loc).buffer), (NOTE_STR), (is), (count), (ol), (it)));
}
TCState_u reportTypeMismatchPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *expected, Type_u *got) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ1 = ((toStringPU5175rS0540)((expected)));
    String_s typ2 = ((toStringPU5175rS0540)((got)));
    (((fprintf))((stderr_), ("%s: %s: Type mismatch! Expected type %s, found type %s.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Type_u *lhsType, Span_s rhsSpan, Type_u *rhsType) {
    Span_s tmp_55389 = ((newSpanBetweenPS8951PS8951rS8951)((&(lhsSpan)), (&(rhsSpan))));

    String_s loc = ((toStringPS8951rS0540)((&tmp_55389)));
    String_s loc1 = ((toStringPS8951rS0540)((&(lhsSpan))));
    String_s loc2 = ((toStringPS8951rS0540)((&(rhsSpan))));
    String_s typ1 = ((toStringPU5175rS0540)((lhsType)));
    String_s typ2 = ((toStringPU5175rS0540)((rhsType)));
    (((fprintf))((stderr_), ("%s: %s: Type mismatch in binary expression! Operation `%s %s %s` is not defined.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), (op), ((typ2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: LHS has type %s.\n"), ((loc1).buffer), (NOTE_STR), ((typ1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: RHS has type %s.\n"), ((loc2).buffer), (NOTE_STR), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661(TypeChecker_s *this, char *op, Span_s lhsSpan, Span_s rhsSpan) {
    Span_s tmp_55485 = ((newSpanBetweenPS8951PS8951rS8951)((&(lhsSpan)), (&(rhsSpan))));

    String_s loc = ((toStringPS8951rS0540)((&tmp_55485)));
    (((fprintf))((stderr_), ("%s: %s: Operation `%s` is not allowed in the context of pointer arithmetics.\n"), ((loc).buffer), (ERR_STR), (op)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INVALID_POINTER_ARITHMETIC)}}});
}
TCState_u reportDuplicateFieldPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s fieldToken, Span_s declSpan) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((fieldToken).span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(declSpan))));
    String_s name = ((toStringPS7720rS0540)((&((fieldToken).content))));
    (((fprintf))((stderr_), ("%s: %s: Field redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Field `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_FIELD)}}});
}
TCState_u reportDuplicateParameterPS3900S6070S8951rU9661(TypeChecker_s *this, Token_s paramToken, Span_s declSpan) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((paramToken).span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(declSpan))));
    String_s name = ((toStringPS7720rS0540)((&((paramToken).content))));
    (((fprintf))((stderr_), ("%s: %s: Parameter redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Parameter `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_PARAMETER)}}});
}
TCState_u reportUnknownFieldPS3900S6070PS4228BrU9661(TypeChecker_s *this, Token_s name, StructLookup_s *decl, bool isUnion) {
    String_s errLoc = ((toStringPS8951rS0540)((&((name).span))));
    String_s declLoc = ((toStringPS8951rS0540)((&(((decl)->name).span))));
    String_s strukt = ((toStringPS7720rS0540)((&(((decl)->name).content))));
    String_s field = ((toStringPS7720rS0540)((&((name).content))));
    char *s1 = ("struct");
    char *s2 = ("Struct");
    if (isUnion) {
        ((s1) = ("union variant"));
        ((s2) = ("Union variant"));
    }

    (((fprintf))((stderr_), ("%s: %s: Attempted to access unknown field `%s` of instance of %s %s.\n"), ((errLoc).buffer), (ERR_STR), ((field).buffer), (s1), ((strukt).buffer)));
    (((fprintf))((stderr_), ("%s: %s: %s %s is declared here.\n"), ((declLoc).buffer), (NOTE_STR), (s2), ((strukt).buffer)));
    ((dropPS0540rN)((&(field))));
    ((dropPS0540rN)((&(strukt))));
    ((dropPS0540rN)((&(declLoc))));
    ((dropPS0540rN)((&(errLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_FIELD)}}});
}
TCState_u reportUnknownTypePS3900PS0997S6070S1581rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name, TypeLookupList_s alternatives) {
    String_s loc = ((getLocationPS6070rS0540)((&(name))));
    String_s _n = ((toStringPS7720rS0540)((&((name).content))));
    if ((mod) != (NULL)) {
        ParsedModule_s *modNode = ((atPS7393uszrPS1882)((&(modules)), ((mod)->globalID)));
        String_s _n1 = ((toStringPS7720rS0540)((&(((modNode)->name).content))));
        String_s loc1 = ((toStringPS8951rS0540)((&((modNode)->span))));
        (((fprintf))((stderr_), ("%s: %s: Module `%s` does not contain any types named `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n1).buffer), ((_n).buffer)));
        (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((loc1).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(loc1))));
        ((dropPS0540rN)((&(_n1))));
    }

    else {
        (((fprintf))((stderr_), ("%s: %s: Use of undeclared type identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n).buffer)));
        if (*((flags).verbose)) {
            for (usize i = ((usize)(0llu)); ((i) < ((alternatives).length)); ((i) = ((i) + ((usize)(1llu))))) {
                TypeLookup_s *t = ((atPS1581uszrPS6177)((&(alternatives)), (i)));
                if ((isStructPS6177rB)((t))) {
                    StructLookup_s *s = ((asStructPS6177rPS4228)((t)));
                    ((dropPS0540rN)((&(loc))));
                    ((loc) = ((getLocationPS6070rS0540)((&((s)->name)))));
                    (((fprintf))((stderr_), ("%s: %s: A struct with that name is located here. Import the file to use it.\n"), ((loc).buffer), (NOTE_STR)));
                }
            }

        }

        else if (((alternatives).length) > ((usize)(0llu))) {
            ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((alternatives).length), ("struct with that name"), ("structs with that name")));
        }
    }

    ((dropPS0540rN)((&(_n))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_TYPE)}}});
}
TCState_u reportDuplicateFunctionPS3900PS0677PS0677rU9661(TypeChecker_s *this, FunctionLookup_s *f1, FunctionLookup_s *f2) {
    String_s errLoc = ((toStringPS8951rS0540)((&(((f1)->name).span))));
    String_s duplLoc = ((toStringPS8951rS0540)((&(((f2)->name).span))));
    String_s name = ((toStringPS7720rS0540)((&(((f1)->name).content))));
    String_s typ = ((toStringPU5175rS0540)(((getTypePU9661rPU5175)((&((f1)->fnType))))));
    (((fprintf))((stderr_), ("%s: %s: Function redeclaration.\n"), ((errLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: A function named `%s` with the signature %s is already declared here.\n"), ((duplLoc).buffer), (ERR_STR), ((name).buffer), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(duplLoc))));
    ((dropPS0540rN)((&(errLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_FUNCTION)}}});
}
TCState_u reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661(TypeChecker_s *this, Token_s ident, Type_u *fnType, FunctionLookupList_s *functions) {
    String_s loc = ((toStringPS8951rS0540)((&((ident).span))));
    String_s name = ((toStringPS7720rS0540)((&((ident).content))));
    String_s typ = ((toStringPU5175rS0540)((fnType)));
    (((fprintf))((stderr_), ("%s: %s: No function overload fits the provided context for call to function `%s`.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Context requires an overload of the form %s.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((assertBPcrN)((((functions)->length) != ((usize)(0llu))), ("reportNoFunctionCallCandidate: Expected at least one declaration")));
    if (*((flags).verbose)) {
        for (usize i = ((usize)(0llu)); ((i) < ((functions)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            FunctionLookup_s *f = ((atPS8385uszrPS0677)((functions), (i)));
            ((dropPS0540rN)((&(typ))));
            ((dropPS0540rN)((&(loc))));
            ((loc) = ((toStringPS8951rS0540)((&(((f)->name).span)))));
            ((typ) = ((toStringPU5175rS0540)(((getTypePU9661rPU5175)((&((f)->fnType)))))));
            (((fprintf))((stderr_), ("%s: %s: Overload %s declared here.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
        }

    }

    else {
        ((reportVerboseNotePS3900S0540uszPcPcrN)((this), (loc), ((functions)->length), ("possible overload"), ("possible overloads")));
    }

    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_CALL_CANDIDATE)}}});
}
TCState_u reportVariableRedeclarationPS3900S6070S6070rU9661(TypeChecker_s *this, Token_s newDecl, Token_s oldDecl) {
    String_s newLoc = ((toStringPS8951rS0540)((&((newDecl).span))));
    String_s oldLoc = ((toStringPS8951rS0540)((&((oldDecl).span))));
    String_s name = ((toStringPS7720rS0540)((&((newDecl).content))));
    (((fprintf))((stderr_), ("%s: %s: Variable redeclaration.\n"), ((newLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variable `%s` already declared here.\n"), ((oldLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(oldLoc))));
    ((dropPS0540rN)((&(newLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_VARIABLE_REDECLARATION)}}});
}
TCState_u reportRecursiveTypePS3900PS6177PS1581rU9661(TypeChecker_s *this, TypeLookup_s *checked, TypeLookupList_s *cycle) {
    String_s loc = ((getLocationPS6177rS0540)((checked)));
    String_s name = ((getNamePS6177rS0540)((checked)));
    (((fprintf))((stderr_), ("%s: %s: Recursive type %s.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
    ((assertBPcrN)((((cycle)->length) >= ((usize)(1llu))), ("Cycle is empty")));
    for (usize i = ((usize)(1llu)); ((i) < ((cycle)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((loc) = ((getLocationPS6177rS0540)(((atPS1581uszrPS6177)((cycle), (i))))));
        ((name) = ((getNamePS6177rS0540)(((atPS1581uszrPS6177)((cycle), (i))))));
        (((fprintf))((stderr_), ("%s: %s: Chain of recursion also includes type %s.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer)));
    }

    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_RECURSIVE_TYPE)}}});
}
TCState_u reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *from, Type_u *to) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ1 = ((toStringPU5175rS0540)((from)));
    String_s typ2 = ((toStringPU5175rS0540)((to)));
    (((fprintf))((stderr_), ("%s: %s: Non primitive cast from type %s to %s.\n"), ((loc).buffer), (ERR_STR), ((typ1).buffer), ((typ2).buffer)));
    ((dropPS0540rN)((&(typ1))));
    ((dropPS0540rN)((&(typ2))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NON_PRIMITIVE_CAST)}}});
}
TCState_u reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *typ) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s name = ((toStringPU5175rS0540)((typ)));
    (((fprintf))((stderr_), ("%s: %s: Indexed Access is only supported for arrays, pointers and variadic types.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Expression has type %s.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_ACCESS_ON_NON_ARRAY)}}});
}
TCState_u reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661(TypeChecker_s *this, Token_s ident, VariableLookup_s *var) {
    String_s loc = ((toStringPS8951rS0540)((&((ident).span))));
    String_s otherLoc = ((toStringPS8951rS0540)((&(((var)->name).span))));
    String_s name = ((toStringPS7720rS0540)((&((ident).content))));
    (((fprintf))((stderr_), ("%s: %s: Variables declared with `let` can\'t be used in a comptime context.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variable `%s` is declared here.\n"), ((otherLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(otherLoc))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_RUNTIME_VALUE_IN_COMPTIME_CONTEXT)}}});
}
TCState_u reportAnyDereferencePS3900PS2435rU9661(TypeChecker_s *this, ParsedExpr_s *expr) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Can\'t dereference expression of type Any.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ANY_DEREF)}}});
}
TCState_u reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator is not defined for values of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator expected an identifier for a value of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *instance) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((instance)));
    (((fprintf))((stderr_), ("%s: %s: The Dot-Operator expected a number for a value of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *tuple, usize index) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    String_s t = ((toStringPU5175rS0540)((tuple)));
    (((fprintf))((stderr_), ("%s: %s: Index %llu is not valid for value of type %s.\n"), ((loc).buffer), (ERR_STR), (index), ((t).buffer)));
    ((dropPS0540rN)((&(t))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NON_STRUCT)}}});
}
TCState_u reportCouldNotInferTypePS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer type of expression.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INFER_FAILED)}}});
}
TCState_u reportMemberAccessNoOptionsPS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which type to use for expression.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_NO_OPTIONS)}}});
}
TCState_u reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661(TypeChecker_s *this, Span_s span, StructLookupList_s *structs) {
    ((assertBrN)((((structs)->length) > ((usize)(0llu)))));
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which type to use for expression.\n"), ((loc).buffer), (ERR_STR)));
    for (usize i = ((usize)(0llu)); ((i) < ((structs)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *s = ((atPS7392uszrPS4228)((structs), (i)));
        String_s l = ((toStringPS8951rS0540)((&(((s)->name).span))));
        String_s n = ((toStringPS7720rS0540)((&(((s)->name).content))));
        (((fprintf))((stderr_), ("%s: %s: Context allows struct %s to be used.\n"), ((l).buffer), (NOTE_STR), ((n).buffer)));
        ((dropPS0540rN)((&(n))));
        ((dropPS0540rN)((&(l))));
    }

    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MEMBER_ACCESS_TOO_MANY_OPTIONS)}}});
}
TCState_u reportFunctionCallTooManyOptionsPS3900PS3328rU9661(TypeChecker_s *this, CallExpr_s *expr) {
    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
    (((fprintf))((stderr_), ("%s: %s: Could not infer which function to call.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_FUNCTION_CALL_TOO_MANY_OPTIONS)}}});
}
TCState_u reportCallToNonFunctionPS3900S8951PU5175rU9661(TypeChecker_s *this, Span_s span, Type_u *base) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ = ((toStringPU5175rS0540)((base)));
    (((fprintf))((stderr_), ("%s: %s: Can\'t call expression of type %s.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Currently, all variables (including global variables) shadow functions.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: This is a known limitation and will be fixed soon.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_CALL_TO_NON_FUNCTION)}}});
}
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args) {
    return ((reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661)((this), (span), (base), (args), (false)));
}
TCState_u reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661(TypeChecker_s *this, Span_s span, Type_u *base, usize args, bool atLeast) {
    usize c = ((usize)(0llu));
    bool succ_7239_ = true;

    Type_u *tmp_11328_ = (base);
    {
        succ_7239_ &= (tmp_11328_->tag == 6);
        TypeList_s *params = &tmp_11328_->payload.variant6._0;
        succ_7239_ &= true;
        succ_7239_ &= true;
        succ_7239_ &= true;
        if (succ_7239_) {
            {
                ((c) = ((*params).length));
            }
            goto after_11328;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_11328;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11328:
    (void)0; // error: label at end of compound statement is a C23 extension
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s typ = ((toStringPU5175rS0540)((base)));
    char *s = ("arguments");
    if ((c) == ((usize)(1llu)))
        ((s) = ("argument"));
    char *w = ("were");
    if ((args) == ((usize)(1llu)))
        ((w) = ("was"));
    char *min = ("");
    if (atLeast)
        ((min) = ("at least "));
    (((fprintf))((stderr_), ("%s: %s: Call expects %s%llu %s, but %llu %s provided.\n"), ((loc).buffer), (ERR_STR), (min), (c), (s), (args), (w)));
    (((fprintf))((stderr_), ("%s: %s: Call expression has type %s.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_CALL_TO_NON_FUNCTION)}}});
}
TCState_u reportUnknownSubmodulePS3900PS0997S6070rU9661(TypeChecker_s *this, ModuleLookup_s *mod, Token_s name) {
    String_s loc = ((toStringPS8951rS0540)((&((name).span))));
    ParsedModule_s *_mod = ((atPS7393uszrPS1882)((&(modules)), ((mod)->globalID)));
    String_s orig = ((toStringPS8951rS0540)((&((_mod)->span))));
    String_s _origName = ((toStringPS7720rS0540)((&(((_mod)->name).content))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: Module `%s` does not contain any submodules named `%s`.\n"), ((loc).buffer), (ERR_STR), ((_origName).buffer), ((_name).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Module declared here.\n"), ((orig).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(_origName))));
    ((dropPS0540rN)((&(orig))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_SUBMODULE)}}});
}
TCState_u reportUnknownModulePS3900S6070rU9661(TypeChecker_s *this, Token_s name) {
    String_s loc = ((toStringPS8951rS0540)((&((name).span))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: Use of undeclared module `%s`.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_MODULE)}}});
}
TCState_u reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661(TypeChecker_s *this, Span_s span, Token_s name, TypeLookup_s typ) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    String_s _name = ((toStringPS7720rS0540)((&((name).content))));
    (((fprintf))((stderr_), ("%s: %s: `%s` is not a module, so the `::` operator cannot be applied.\n"), ((loc).buffer), (ERR_STR), ((_name).buffer)));
    if (((typ).kind) != (TYPE_LOOKUP_INVALID)) {
        String_s _loc = ((getLocationPS6177rS0540)((&(typ))));
        (((fprintf))((stderr_), ("%s: %s: Struct declared here.\n"), ((_loc).buffer), (NOTE_STR)));
        ((dropPS0540rN)((&(_loc))));
    }

    ((dropPS0540rN)((&(_name))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MODULE_ACCESS_NON_MODULE)}}});
}
TCState_u reportDuplicateVariantPS3900PS3506PS2365rU9661(TypeChecker_s *this, ParsedUnionVariant_s *orig, UnionVariantLookup_s *dupl) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((orig)->span))));
    String_s origLoc = ((toStringPS8951rS0540)((&(((dupl)->global)->span))));
    String_s name = ((toStringPS7720rS0540)((&(((orig)->name).content))));
    (((fprintf))((stderr_), ("%s: %s: Union Variant redeclaration.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Variant `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_UNION_VARIANT)}}});
}
TCState_u reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661(TypeChecker_s *this, ParsedUnionVariant_s *variant, Token_s *first, Token_s *dupl) {
    String_s duplLoc = ((toStringPS8951rS0540)((&((first)->span))));
    String_s origLoc = ((toStringPS8951rS0540)((&((dupl)->span))));
    String_s name = ((toStringPS7720rS0540)((&((first)->content))));
    (((fprintf))((stderr_), ("%s: %s: Union Variant already contains a field with that name.\n"), ((duplLoc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Field `%s` already declared here.\n"), ((origLoc).buffer), (NOTE_STR), ((name).buffer)));
    ((dropPS0540rN)((&(name))));
    ((dropPS0540rN)((&(origLoc))));
    ((dropPS0540rN)((&(duplLoc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DUPLICATE_UNION_NAME)}}});
}
TCState_u reportImpossiblePatternPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
TCState_u reportNotEnoughPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    TCState_u err = ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    (((fprintf))((stderr_), ("%s: %s: Not enough patterns were provided to match the type.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: If you only care about certain fields, you can use `_` or `..` to ignore the rest.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return (err);
}
char *_anon_23_0U3836rPc(ParsedUnionVariantData_u data) {
    bool succ_7281_ = true;
    bool succ_7285_ = true;
    bool succ_7288_ = true;

    ParsedUnionVariantData_u tmp_11425_ = (data);
    {
        succ_7281_ &= (tmp_11425_.tag == 0);
        if (succ_7281_) {
            {
                return ("an Empty");
            }
            goto after_11425;
        }
    }
    {
        succ_7285_ &= (tmp_11425_.tag == 2);
        succ_7285_ &= true;
        succ_7285_ &= true;
        if (succ_7285_) {
            {
                return ("a Struct");
            }
            goto after_11425;
        }
    }
    {
        succ_7288_ &= (tmp_11425_.tag == 1);
        succ_7288_ &= true;
        if (succ_7288_) {
            {
                return ("a Tuple");
            }
            goto after_11425;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11425;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11425:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661(TypeChecker_s *this, ParsedUnionDecl_s *decl, ParsedUnionVariant_s *variant, Span_s span, ParsedUnionVariantData_u gotVar) {
    String_s loc1 = ((toStringPS8951rS0540)((&(span))));
    String_s loc2 = ((toStringPS8951rS0540)((&(((decl)->name).span))));
    String_s loc3 = ((toStringPS8951rS0540)((&((variant)->span))));
    String_s name1 = ((toStringPS7720rS0540)((&(((variant)->name).content))));
    String_s name2 = ((toStringPS7720rS0540)((&(((decl)->name).content))));
    char *(*f)(ParsedUnionVariantData_u) = (_anon_23_0U3836rPc);
    char *exp = ((f)(((variant)->data)));
    char *got = ((f)((gotVar)));
    (((fprintf))((stderr_), ("%s: %s: Invalid initialization of variant `%s` of type %s.\n"), ((loc1).buffer), (ERR_STR), ((name1).buffer), ((name2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: `%s` is %s variant, but an initializer for %s variant was provided.\n"), ((loc3).buffer), (NOTE_STR), ((name1).buffer), (exp), (got)));
    (((fprintf))((stderr_), ("%s: %s: Type declared here.\n"), ((loc2).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(loc3))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(name2))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INVALID_VARIANT_INIT)}}});
}
TCState_u reportInvalidVariantPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Type %s has no such variant.\n"), ((loc).buffer), (NOTE_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
char *_anon_23_1U3836rPc(ParsedUnionVariantData_u data) {
    bool succ_7300_ = true;
    bool succ_7304_ = true;
    bool succ_7307_ = true;

    ParsedUnionVariantData_u tmp_11460_ = (data);
    {
        succ_7300_ &= (tmp_11460_.tag == 0);
        if (succ_7300_) {
            {
                return ("an Empty");
            }
            goto after_11460;
        }
    }
    {
        succ_7304_ &= (tmp_11460_.tag == 2);
        succ_7304_ &= true;
        succ_7304_ &= true;
        if (succ_7304_) {
            {
                return ("a Struct");
            }
            goto after_11460;
        }
    }
    {
        succ_7307_ &= (tmp_11460_.tag == 1);
        succ_7307_ &= true;
        if (succ_7307_) {
            {
                return ("a Tuple");
            }
            goto after_11460;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11460;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11460:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type, ParsedUnionVariantData_u expVar, ParsedUnionVariantData_u gotVar) {
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    String_s patS = ((toStringPS1826rS0540)((pat)));
    String_s typ = ((toStringPU5175rS0540)((type)));
    char *(*f)(ParsedUnionVariantData_u) = (_anon_23_1U3836rPc);
    char *exp = ((f)((expVar)));
    char *got = ((f)((gotVar)));
    (((fprintf))((stderr_), ("%s: %s: A value of type %s will never match the pattern `%s`.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer), ((patS).buffer)));
    (((fprintf))((stderr_), ("%s: %s: %s pattern can\'t be used to match against %s variant.\n"), ((loc).buffer), (NOTE_STR), (got), (exp)));
    ((dropPS0540rN)((&(patS))));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_IMPOSSIBLE_PATTERN)}}});
}
TCState_u reportNoSuchVariantPS3900PS1592S6070rU9661(TypeChecker_s *this, UnionLookup_s *lookup, Token_s tkn) {
    String_s loc1 = ((toStringPS8951rS0540)((&((tkn).span))));
    String_s name1 = ((toStringPS7720rS0540)((&((tkn).content))));
    String_s loc2 = ((toStringPS8951rS0540)((&(((lookup)->name).span))));
    String_s name2 = ((toStringPS7720rS0540)((&(((lookup)->name).content))));
    (((fprintf))((stderr_), ("%s: %s: Type %s has no variant named `%s`.\n"), ((loc1).buffer), (ERR_STR), ((name2).buffer), ((name1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Type declared here.\n"), ((loc2).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc1))));
    ((dropPS0540rN)((&(loc2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(name2))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_VARIANT)}}});
}
TCState_u reportTooManyPatternsPS3900PS1826PU5175rU9661(TypeChecker_s *this, ParsedPattern_s *pat, Type_u *type) {
    TCState_u err = ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
    String_s loc = ((toStringPS8951rS0540)((&((pat)->span))));
    (((fprintf))((stderr_), ("%s: %s: Too many patterns were provided to match the type.\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return (err);
}
TCState_u reportStatementInNakedFunctionPS3900PS1100rU9661(TypeChecker_s *this, ParsedStmt_s *stmt) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    (((fprintf))((stderr_), ("%s: %s: Only `asm` statements are allowed in functions marked `@naked`.\n"), ((loc).buffer), (ERR_STR)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NAKED_STATEMENT)}}});
}
TCState_u reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    String_s name1 = ((toStringPU5175rS0540)((got)));
    String_s name2 = ((toStringPU5175rS0540)((wanted)));
    (((fprintf))((stderr_), ("%s: %s: The function passed as the first argument to `asm` must return an %s.\n"), ((loc).buffer), (ERR_STR), ((name2).buffer)));
    (((fprintf))((stderr_), ("%s: %s: The function currently returns a value of type `%s`.\n"), ((loc).buffer), (NOTE_STR), ((name1).buffer)));
    ((dropPS0540rN)((&(name2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, Type_u *got, Type_u *wanted) {
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    String_s name1 = ((toStringPU5175rS0540)((got)));
    String_s name2 = ((toStringPU5175rS0540)((wanted)));
    (((fprintf))((stderr_), ("%s: %s: Expected first argument of `asm` to be a function, but found expression of type `%s`.\n"), ((loc).buffer), (ERR_STR), ((name1).buffer)));
    (((fprintf))((stderr_), ("%s: %s: Inline assembly uses compile-time evaluation and requires the function to return an %s.\n"), ((loc).buffer), (NOTE_STR), ((name2).buffer)));
    ((dropPS0540rN)((&(name2))));
    ((dropPS0540rN)((&(name1))));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661(TypeChecker_s *this, ParsedStmt_s *stmt, usize argCount, usize paramCount) {
    char *args = ((pluszPcPcrPc)((argCount), ("argument"), ("arguments")));
    char *params = ((pluszPcPcrPc)((paramCount), ("parameter"), ("parameters")));
    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
    (((fprintf))((stderr_), ("%s: %s: The function passed to `asm` expected %llu %s, but got %llu %s.\n"), ((loc).buffer), (ERR_STR), (paramCount), (params), (argCount), (args)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
}
TCState_u reportMissingTrampolinePS3900S8951rU9661(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Pattern in variable declaration is not exhaustive.\n"), ((loc).buffer), (ERR_STR)));
    (((fprintf))((stderr_), ("%s: %s: Provide a trampoline to handle the case where the pattern does not match.\n"), ((loc).buffer), (NOTE_STR)));
    (((fprintf))((stderr_), ("%s: %s: A trampoline is an `else`-block after the declaration, for example `let a = 10 else { /* trampoline */ };`\n"), ((loc).buffer), (NOTE_STR)));
    ((dropPS0540rN)((&(loc))));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_MISSING_TRAMPOLINE)}}});
}
none reportUnnecessaryTrampolinePS3900S8951rN(TypeChecker_s *this, Span_s span) {
    String_s loc = ((toStringPS8951rS0540)((&(span))));
    (((fprintf))((stderr_), ("%s: %s: Pattern in variable declaration is exhaustive, the trampoline is unreachable.\n"), ((loc).buffer), (WARN_STR)));
    ((dropPS0540rN)((&(loc))));
}
none emergencyPrintPS3900S8951rN(TypeChecker_s *this, Span_s where) {
    Token_s t = ((Token_s){.span = (where), .content = ((newSubStrOfStrLitPcrS7720)((""))), .kind = (TOKEN_EOF)});
    (((printf))(("%s\n"), (((getLocationPS6070rS0540)((&(t)))).buffer)));
}
bool typeCheckProjectPS3900PS1892rB(TypeChecker_s *this, ParsedFile_s *project) {
    if (!((fillLookupPS3900rB)((this))))
        return (false);
    if (!((typeCheckFilesPS3900rB)((this))))
        return (false);
    if ((findRecursiveTypesPS3900rB)((this)))
        return (false);
    return (!((this)->typeError));
}
bool dfsPS3900PU5175PS1581PS1581rB(TypeChecker_s *this, Type_u *type, TypeLookupList_s *visited, TypeLookupList_s *finished) {
    bool succ_7334_ = true;
    bool succ_7338_ = true;
    bool succ_7343_ = true;

    Type_u *tmp_11542_ = (type);
    {
        succ_7334_ &= (tmp_11542_->tag == 5);
        Type_u **under = &tmp_11542_->payload.variant5._0;
        succ_7334_ &= true;
        succ_7334_ &= true;
        if (succ_7334_) {
            {
                return ((dfsPS3900PU5175PS1581PS1581rB)((this), (*under), (visited), (finished)));
            }
            goto after_11542;
        }
    }
    {
        succ_7338_ &= (tmp_11542_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_11542_->payload.variant7._0;
        succ_7338_ &= true;
        if (succ_7338_) {
            {
                return ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS4228rS6177)(((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), ((getIDPS5521rusz)((*decl))))))), (visited),
                                                       (finished)));
            }
            goto after_11542;
        }
    }
    {
        succ_7343_ &= (tmp_11542_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_11542_->payload.variant8._0;
        succ_7343_ &= true;
        succ_7343_ &= true;
        if (succ_7343_) {
            {
                return ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS1592rS6177)(((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (*decl))))), (visited), (finished)));
            }
            goto after_11542;
        }
    }
    {
        if (true) {
            {
            }
            goto after_11542;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_11542:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool dfsPS3900S6177PS1581PS1581rB(TypeChecker_s *this, TypeLookup_s typeLookup, TypeLookupList_s *visited, TypeLookupList_s *finished) {
    if ((containsPS1581PS6177rB)((finished), (&(typeLookup))))
        return (false);
    if ((containsPS1581PS6177rB)((visited), (&(typeLookup))))
        return (true);
    ((pushPS1581S6177rN)((visited), (typeLookup)));
    bool done = (false);
    if ((isStructPS6177rB)((&(typeLookup)))) {
        StructLookup_s *strukt = ((asStructPS6177rPS4228)((&(typeLookup))));
        for (usize i = ((usize)(0llu)); ((i) < (((strukt)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
            VariableLookup_s *field = ((atPS3313uszrPS6661)((&((strukt)->fields)), (i)));
            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type in DFS")));
            Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
            if ((dfsPS3900PU5175PS1581PS1581rB)((this), (fieldType), (visited), (finished))) {
                ((done) = (true));
            }
        }

    }

    else if ((isUnionPS6177rB)((&(typeLookup)))) {
        UnionLookup_s *onion = ((asUnionPS6177rPS1592)((&(typeLookup))));
        for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
            UnionVariantLookup_s *_variant = ((atPS4601uszrPS2365)((&((onion)->variants)), (i)));
            ParsedUnionVariant_s *variant = ((_variant)->global);
            bool succ_7364_ = true;
            bool succ_7362_ = true;

            tuple_1044 tmp_11566_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_7362_ = tmp_11566_._0 == true;
            succ_7364_ &= succ_7362_;
            ParsedTypeNodeList_s **fields = &tmp_11566_._1;
            succ_7364_ &= true;
            if (!succ_7364_) {
                continue;
            };
            for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
                ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type in DFS")));
                Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                if ((dfsPS3900PU5175PS1581PS1581rB)((this), (fieldType), (visited), (finished))) {
                    ((done) = (true));
                }
            }
        }

    }

    else {
        ((unreachablePcrN)(("Exhaustive handling of TypeLookup kinds in dfs")));
    }

    ((pushPS1581S6177rN)((finished), (typeLookup)));
    return (done);
}
bool findRecursiveTypesPS3900rB(TypeChecker_s *this) {
    bool recursive = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *decl = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((decl)->ignored)
            continue;
        StructLookup_s *strukt = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), (i)));
        TypeLookupList_s visited = ((TypeLookupList_s){0});
        TypeLookupList_s finished = ((TypeLookupList_s){0});
        if ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS4228rS6177)((strukt))), (&(visited)), (&(finished)))) {
            TypeLookup_s tmp_58207 = ((asTypeLookupPS4228rS6177)((strukt)));

            ((reportRecursiveTypePS3900PS6177PS1581rU9661)((this), (&tmp_58207), (&(visited))));
            ((recursive) = (true));
        }
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *decl = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((decl)->ignored)
            continue;
        UnionLookup_s *onion = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (decl)));
        TypeLookupList_s visited = ((TypeLookupList_s){0});
        TypeLookupList_s finished = ((TypeLookupList_s){0});
        if ((dfsPS3900S6177PS1581PS1581rB)((this), ((asTypeLookupPS1592rS6177)((onion))), (&(visited)), (&(finished)))) {
            TypeLookup_s tmp_58257 = ((asTypeLookupPS1592rS6177)((onion)));

            ((reportRecursiveTypePS3900PS6177PS1581rU9661)((this), (&tmp_58257), (&(visited))));
            ((recursive) = (true));
        }
    }

    return (recursive);
}
bool fillLookupPS3900rB(TypeChecker_s *this) {
    bool success = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((insertFilePS7791PS1892rPS0997)((&((this)->lookup)), (file))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if ((tli)->ignored)
                continue;
            if (!((insertTLIPS0997PS1038rB)(((this)->currentModule), (tli))))
                ((success) = (false));
        }
    }

    return (success);
}
bool typeCheckFilesPS3900rB(TypeChecker_s *this) {
    bool success = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_STRUCT_DECL)) {
                TCState_u state = ((typeCheckStructDeclPS3900uszrU9661)((this), ((tli)->nodeID)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_UNION_DECL)) {
                TCState_u state = ((typeCheckUnionDeclPS3900PS0997rU9661)((this), ((asUnionPS1038rPS0997)((tli)))));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_FUNC_DECL)) {
                TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (true)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_MOD_DECL)) {
                TCState_u state = ((typeCheckModulePS3900uszPS5541rU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables))));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                TCState_u state = ((typeCheckVarDeclPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (true)));
                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    if (!(success))
        return (false);
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        ((assertBrN)((((getIDPS1892rusz)((file))) == (i))));
        (((this)->currentModule) = ((atPS5121uszrPS0997)((&(((this)->lookup).files)), (i))));
        ((assertBPcrN)((((((this)->currentModule)->variables).length) == ((usize)(1llu))), ("expected to find only the global scope for TLI VarDecl")));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            usize tliID = (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))));
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (tliID)));
            if (((tli)->kind) == (TLI_FUNC_DECL)) {
                TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (&(((this)->currentModule)->variables)), (false)));
                FunctionLookup_s *_dupl = (NULL);
                FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS0997uszrPS0677)(((this)->currentModule), ((tli)->nodeID)));
                if ((containsDuplicateFunctionPS0997PS0677PPS0677rB)(((this)->currentModule), (funcLookup), (&(_dupl)))) {
                    ((assertBPcrN)(((_dupl) != (NULL)), ("Duplicate FunctionLookup is null")));
                    ((reportDuplicateFunctionPS3900PS0677PS0677rU9661)((this), (funcLookup), (_dupl)));
                    ((success) = (false));
                }

                if (!((isSuccessPU9661rB)((&(state)))))
                    ((success) = (false));
            }
        }
    }

    return (success);
}
TCState_u typeCheckModulePS3900uszPS5541rU9661(TypeChecker_s *this, usize modID, ScopeLookupList_s *scopes) {
    ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), (modID)));
    ModuleLookup_s *prev = ((this)->currentModule);
    (((this)->currentModule) = ((getModuleByGlobalIDPS7791uszrPS0997)((&((this)->lookup)), (modID))));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_STRUCT_DECL)) {
            TCState_u state = ((typeCheckStructDeclPS3900uszrU9661)((this), ((tli)->nodeID)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_UNION_DECL)) {
            TCState_u state = ((typeCheckUnionDeclPS3900PS0997rU9661)((this), ((asUnionPS1038rPS0997)((tli)))));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_FUNC_DECL)) {
            TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (true)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_MOD_DECL)) {
            TCState_u state = ((typeCheckModulePS3900uszPS5541rU9661)((this), ((tli)->nodeID), (scopes)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_VAR_DECL)) {
            TCState_u state = ((typeCheckVarDeclPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (true)));
            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    if (!((isSuccessPU9661rB)((&(result))))) {
        (((this)->currentModule) = (prev));
        return (result);
    }

    for (usize i = ((usize)(0llu)); ((i) < (((mod)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((mod)->tlis)), (i))))));
        if (((tli)->kind) == (TLI_FUNC_DECL)) {
            TCState_u state = ((typeCheckFunctionPS3900uszPS5541BrU9661)((this), ((tli)->nodeID), (scopes), (false)));
            FunctionLookup_s *_dupl = (NULL);
            FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS0997uszrPS0677)(((this)->currentModule), ((tli)->nodeID)));
            if ((containsDuplicateFunctionPS0997PS0677PPS0677rB)(((this)->currentModule), (funcLookup), (&(_dupl)))) {
                ((assertBPcrN)(((_dupl) != (NULL)), ("Duplicate FunctionLookup is null")));
                ((result) = ((reportDuplicateFunctionPS3900PS0677PS0677rU9661)((this), (funcLookup), (_dupl))));
            }

            if (!((isSuccessPU9661rB)((&(state)))))
                ((result) = (state));
        }
    }

    (((this)->currentModule) = (prev));
    return (result);
}
TCState_u typeCheckUnionDeclPS3900PS0997rU9661(TypeChecker_s *this, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    UnionLookup_s *unionLookup = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (onion)));
    ((assertBPcrN)(((isUnionPU5175rB)(((unionLookup)->type))), ("typeCheckUnionDecl: Union Lookup doesn\'t contain Union Type")));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((unionLookup)->type)}}});
    for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
        TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (onion), ._1 = ((usize)(0llu))}}})))}}});
        UnionVariantLookup_s *dupl = (NULL);
        if ((checkForDuplicateVariantPS1592PS3506PPS2365rB)((unionLookup), (variant), (&(dupl)))) {
            ((result) = ((reportDuplicateVariantPS3900PS3506PS2365rU9661)((this), (variant), (dupl))));
        }

        bool succ_7518_ = true;
        bool succ_7522_ = true;
        bool succ_7530_ = true;

        ParsedUnionVariantData_u *tmp_11874_ = (&((variant)->data));
        {
            succ_7518_ &= (tmp_11874_->tag == 0);
            if (succ_7518_) {
                {
                }
                goto after_11874;
            }
        }
        {
            succ_7522_ &= (tmp_11874_->tag == 1);
            ParsedTypeNodeList_s *fields = &tmp_11874_->payload.variant1._0;
            succ_7522_ &= true;
            if (succ_7522_) {
                {
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        TCState_u fieldState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((((*fields).elements))[(j)])));
                        if (!((isSuccessPU9661rB)((&(fieldState))))) {
                            ((result) = (fieldState));
                        }
                    }
                }
                goto after_11874;
            }
        }
        {
            succ_7530_ &= (tmp_11874_->tag == 2);
            ParsedTypeNodeList_s *fields = &tmp_11874_->payload.variant2._0;
            succ_7530_ &= true;
            TokenList_s *names = &tmp_11874_->payload.variant2._1;
            succ_7530_ &= true;
            if (succ_7530_) {
                {
                    ((assertBPcrN)((((*fields).length) == ((*names).length)), ("typeCheckUnionDecl: fields.length != names.length")));
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields).length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedTypeNode_s *field = ((((*fields).elements))[(j)]);
                        Token_s *name = (&((((*names).elements))[(j)]));
                        Token_s *duplName = (NULL);
                        if ((checkForDuplicateNamePS3506PS6070PPS6070rB)((variant), (name), (&(duplName)))) {
                            ((result) = ((reportDuplicateNameInUnionPS3900PS3506PS6070PS6070rU9661)((this), (variant), (name), (duplName))));
                            break;
                        }

                        TCState_u fieldState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (field)));
                        if (!((isSuccessPU9661rB)((&(fieldState))))) {
                            ((result) = (fieldState));
                        }
                    }
                }
                goto after_11874;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_11874;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_11874:
        (void)0; // error: label at end of compound statement is a C23 extension
        ((addVariantPS1592PS3506U9661rN)((unionLookup), (variant), (state)));
    }

    if ((isSuccessPU9661rB)((&(result)))) {
        (((onion)->typeState) = (result));
    }

    return (result);
}
TCState_u typeCheckStructDeclPS3900uszrU9661(TypeChecker_s *this, usize structID) {
    ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (structID)));
    if ((strukt)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    StructLookup_s *structLookup = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), (structID)));
    ((assertBPcrN)(((isStructPU5175rB)(((structLookup)->type))), ("typeCheckStructDecl: Struct Lookup doesn\'t contain Struct Type")));
    StructContext_s *context = (&((strukt)->context));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    TCState_u failure = (((TCState_u){.tag = 0, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < ((context)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getFieldNameAtIndexPS7871uszrS6070)((context), (i)));
        ParsedTypeNode_s *typ = ((getFieldTypeAtIndexPS7871uszrPS1372)((context), (i)));
        VariableLookup_s dupl = ((VariableLookup_s){0});
        if ((checkForDuplicateFieldPS4228PS6070PS6661rB)((structLookup), (&(name)), (&(dupl)))) {
            ((failure) = ((reportDuplicateFieldPS3900S6070S8951rU9661)((this), (name), (((dupl).name).span))));
            continue;
        }

        TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (typ)));
        if ((isErrorPU9661rB)((&(state)))) {
            ((failure) = (state));
            continue;
        }

        ((addFieldPS4228uszS6070U9661rN)((structLookup), ((NODE_ID_OFFSET) + (i)), (name), (state)));
    }

    if (!((isInvalidPU9661rB)((&(failure)))))
        return (failure);
    (((strukt)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((structLookup)->type)}}}));
    return (result);
}
TCState_u typeCheckFunctionPS3900uszPS5541BrU9661(TypeChecker_s *this, usize funcID, ScopeLookupList_s *scopes, bool signatureOnly) {
    return ((typeCheckFunctionPS3900PS4904PS5541BrU9661)((this), ((atPS4111uszrPS4904)((&(funcDecls)), (funcID))), (scopes), (signatureOnly)));
}
TCState_u typeCheckFunctionPS3900PS4904PS5541BrU9661(TypeChecker_s *this, ParsedFuncDecl_s *function, ScopeLookupList_s *scopes, bool signatureOnly) {
    if ((function)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    FunctionLookup_s *funcLookup = ((getFunctionByGlobalIDPS7791uszrPS0677)((&((this)->lookup)), ((getIDPS4904rusz)((function)))));
    (((this)->currentFunction) = (funcLookup));
    TCState_u failure = (((TCState_u){.tag = 0, .payload = {0}}));
    ((clearPS3313rN)((&((funcLookup)->params))));
    TypeList_s params = ((TypeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *typ = ((getTypeAtIndexPS9803uszrPS1372)((&((function)->params)), (i)));
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
        VariableLookup_s dupl = ((VariableLookup_s){0});
        if ((checkForDuplicateParamPS0677PS6070PS6661rB)((funcLookup), (&(name)), (&(dupl)))) {
            ((failure) = ((reportDuplicateParameterPS3900S6070S8951rU9661)((this), (name), (((dupl).name).span))));
            continue;
        }

        TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (typ)));
        if ((isErrorPU9661rB)((&(state)))) {
            ((failure) = (state));
            continue;
        }

        ((pushPS0643PU5175rN)((&(params)), ((getTypePU9661rPU5175)((&(state))))));
        ((addParameterPS0677uszS6070U9661rN)((funcLookup), ((NODE_ID_OFFSET) + (i)), (name), (state)));
    }

    if (!((isInvalidPU9661rB)((&(failure)))))
        return (failure);
    TCState_u retState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((function)->retType)));
    if ((isErrorPU9661rB)((&(retState))))
        return (retState);
    Type_u *fnType =
        ((wrapU5175rPU5175)(((Type_u){.tag = 6,
                                      .payload = {.variant6 = {._0 = (params),
                                                               ._1 = ((getTypePU9661rPU5175)((&(retState)))),
                                                               ._2 = ((FuncAttr_s){.isVariadic = (((function)->params).isVarArg),
                                                                                   .isNoreturn = ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 3, .payload = {0}}))))})}}})));
    TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (fnType)}}});
    (((funcLookup)->fnType) = (state));
    (((function)->typeState) = (state));
    if ((isExternPS4904rB)((function))) {
        if (!(((function)->parent).isFile)) {
            ParsedModule_s *mod = ((getParentModulePS4904rPS1882)((function)));
            String_s _name = ((getMangledNamePS4904rS0540)((function)));
            if ((((mod)->dlls).length) == ((usize)(0llu))) {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
                    (((fprintf))((stderr_), ("%s: %s: No dynamic library was found for external function %s. You will not be able to call it at compile time.\n"), ((loc).buffer), (WARN_STR),
                                 ((_name).buffer)));
                    ((dropPS0540rN)((&(loc))));
                }

                (((function)->dllHandle) = ((dllNotFoundrPS3633)()));
            }

            bool addrFound = (false);
            for (usize i = ((usize)(0llu)); ((i) < (((mod)->dlls).length)); ((i) = ((i) + ((usize)(1llu))))) {
                DLL_s *dll = ((atPS8168uszrPS3633)((&(dlls)), (*((atPS4113uszrPusz)((&((mod)->dlls)), (i))))));
                Handle_s handle = ((dlsymS9457PcrS9457)(((dll)->handle), ((_name).buffer)));
                if (!((isNullS9457rB)((handle)))) {
                    (((function)->dllHandle) = ((newDLLS0540S9457rPS3633)(((dll)->path), (handle))));
                    ((addrFound) = (true));
                    break;
                }
            }

            if ((!(addrFound)) && (((function)->dllHandle) != ((dllNotFoundrPS3633)()))) {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((function)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Could not find external function %s in any DLL. You will not be able to call it at compile time.\n"), ((loc).buffer), (WARN_STR),
                                 ((_name).buffer)));
                    ((dropPS0540rN)((&(loc))));
                }

                (((function)->dllHandle) = ((dllNoSuchFunctionrPS3633)()));
            }

            ((dropPS0540rN)((&(_name))));
        }

        else {
        }

        return ((function)->typeState);
    }

    if (signatureOnly) {
        return (((TCState_u){.tag = 1, .payload = {0}}));
    }

    ScopeLookup_s scope = ((ScopeLookup_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((funcLookup)->params).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((addVariablePS1913S6661rN)((&(scope)), (*((atPS3313uszrPS6661)((&((funcLookup)->params)), (i))))));
    }

    ((pushPS5541S1913rN)((scopes), (scope)));
    TCState_u blockState =
        ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), ((function)->body), (scopes), ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 4, .payload = {0}}))))));
    ((popPS5541rPS1913)((scopes)));
    if ((isErrorPU9661rB)((&(blockState)))) {
        return (blockState);
    }

    return ((function)->typeState);
}
TCState_u typeCheckBlockPS3900PS7247PS5541BrU9661(TypeChecker_s *this, ParsedBlock_s *block, ScopeLookupList_s *scopes, bool nakedFunc) {
    if ((block)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((block)->typeState)))) {
        return ((block)->typeState);
    }

    ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){.variables = ((VariableLookupList_s){0})})));
    usize curr = ((scopes)->length);
    TCState_u blockState = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStmt_s *stmt = ((getStmtAtIndexPS7247uszrPS1100)((block), (i)));
        if (nakedFunc) {
            bool succ_7600_ = true;
            bool succ_7604_ = true;

            StmtData_u *tmp_12013_ = (&((stmt)->data));
            {
                succ_7600_ &= (tmp_12013_->tag == 12);
                succ_7600_ &= true;
                succ_7600_ &= true;
                if (succ_7600_) {
                    {
                    }
                    goto after_12013;
                }
            }
            {
                succ_7604_ &= (tmp_12013_->tag == 4);
                ParsedBlock_s **_block = &tmp_12013_->payload.variant4._0;
                succ_7604_ &= true;
                if (succ_7604_) {
                    {
                        ((blockState) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*_block), (scopes), (nakedFunc))));
                        continue;
                    }
                    goto after_12013;
                }
            }
            {
                if (true) {
                    {
                        ((blockState) = ((reportStatementInNakedFunctionPS3900PS1100rU9661)((this), (stmt))));
                        continue;
                    }
                    goto after_12013;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_12013:
            (void)0; // error: label at end of compound statement is a C23 extension
        }

        TCState_u stmtState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
        if ((isErrorPU9661rB)((&(stmtState)))) {
            ((blockState) = (stmtState));
        }
    }

    usize after = ((scopes)->length);
    ((popPS5541rPS1913)((scopes)));
    ((assertBPcrN)(((after) == (curr)), ("Stack imbalance")));
    if ((isErrorPU9661rB)((&(blockState))))
        return (blockState);
    (((*(block)).typeState) = (((TCState_u){.tag = 1, .payload = {0}})));
    return ((block)->typeState);
}
TCState_u typeCheckStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *stmt, ScopeLookupList_s *scopes) {
    if ((stmt)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((stmt)->typeState))))
        return ((stmt)->typeState);
    TCState_u state = (((TCState_u){.tag = 1, .payload = {0}}));
    bool succ_7614_ = true;
    bool succ_7617_ = true;
    bool succ_7625_ = true;
    bool succ_7637_ = true;
    bool succ_7649_ = true;
    bool succ_7654_ = true;
    bool succ_7668_ = true;
    bool succ_7683_ = true;
    bool succ_7697_ = true;
    bool succ_7705_ = true;
    bool succ_7713_ = true;
    bool succ_7721_ = true;
    bool succ_7736_ = true;
    bool succ_7739_ = true;
    bool succ_7745_ = true;
    bool succ_7750_ = true;

    StmtData_u *tmp_12241_ = (&((stmt)->data));
    {
        succ_7614_ &= (tmp_12241_->tag == 0);
        succ_7614_ &= true;
        if (succ_7614_) {
            {
                return ((typeCheckVarDeclPS3900PS1100PS5541BrU9661)((this), (stmt), (scopes), (false)));
            }
            goto after_12241;
        }
    }
    {
        succ_7617_ &= (tmp_12241_->tag == 1);
        if (succ_7617_) {
            {
                ((assertBrN)((((this)->currentFunction) != (NULL))));
                TCState_u *retState = (&(((this)->currentFunction)->fnType));
                Type_u *_rt = ((getTypePU9661rPU5175)((retState)));
                Type_u *retType = ((getReturnTypePU5175rPU5175)((_rt)));
                if (!((isNonePU5175rB)((retType)))) {
                    (((printf))(("%s\n"), (((toStringPS8951rS0540)((&((stmt)->span)))).buffer)));
                    (((printf))(("%s\n"), (((toStringPU5175rS0540)((retType))).buffer)));
                    ((todo_with_msgPcrN)(("function returns something, but we wrote return;")));
                }
            }
            goto after_12241;
        }
    }
    {
        succ_7625_ &= (tmp_12241_->tag == 2);
        ParsedExpr_s **expr = &tmp_12241_->payload.variant2._0;
        succ_7625_ &= true;
        if (succ_7625_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                ((assertBrN)((((this)->currentFunction) != (NULL))));
                TCState_u *retState = (&(((this)->currentFunction)->fnType));
                ((assertBPcrN)(((isSuccessPU9661rB)((retState))), ("ready to use function has invalid return type")));
                ((assertBPcrN)(((isTypePU9661rB)((retState))), ("ready to use function has non-type as return type")));
                Type_u *_rt = ((getTypePU9661rPU5175)((retState)));
                Type_u *retType = ((getReturnTypePU5175rPU5175)((_rt)));
                if ((isNonePU5175rB)((retType)))
                    ((todo_with_msgPcrN)(("unexpected ret expr where empty function")));
                if ((wantsInferPU9661rB)((&(exprState)))) {
                    ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*expr), (retType), (scopes))));
                    if ((isErrorPU9661rB)((&(exprState))))
                        return (exprState);
                    ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("Failed to infer type of return expression")));
                }

                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (!((equalsPU5175PU5175rB)((exprType), (retType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((stmt)->span), (retType), (exprType)));
                }

                ((state) = (*(retState)));
            }
            goto after_12241;
        }
    }
    {
        succ_7637_ &= (tmp_12241_->tag == 3);
        ParsedExpr_s **expr = &tmp_12241_->payload.variant3._0;
        succ_7637_ &= true;
        if (succ_7637_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState)))) {
                    Type_u *noneType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 11}))}}})));
                    ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*expr), (noneType), (scopes))));
                }

                if (!((isTypePU9661rB)((&(exprState))))) {
                    (((printf))(("%s\n"), (((toStringPS8951rS0540)((&((stmt)->span)))).buffer)));
                    (((printf))(("%llu\n"), ((tagAnyru8)((&(exprState))))));
                    ((todo_with_msgPcrN)(("what is it then")));
                }

                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (((!((isNonePU5175rB)((exprType)))) && (!((isAssignmentPS2435rB)((*expr))))) && (*((flags).warnUnused))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Unused expression value.\n"), ((loc).buffer), (WARN_STR)));
                    ((dropPS0540rN)((&(loc))));
                }

                ((state) = (exprState));
            }
            goto after_12241;
        }
    }
    {
        succ_7649_ &= (tmp_12241_->tag == 4);
        ParsedBlock_s **block = &tmp_12241_->payload.variant4._0;
        succ_7649_ &= true;
        if (succ_7649_) {
            {
                ((state) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false))));
            }
            goto after_12241;
        }
    }
    {
        succ_7654_ &= (tmp_12241_->tag == 5);
        ParsedExpr_s **cond = &tmp_12241_->payload.variant5._0;
        succ_7654_ &= true;
        ParsedStmt_s **then = &tmp_12241_->payload.variant5._1;
        succ_7654_ &= true;
        if (succ_7654_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u thenState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*then), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(thenState))))
                    return (thenState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto if-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12241;
        }
    }
    {
        succ_7668_ &= (tmp_12241_->tag == 6);
        ParsedExpr_s **cond = &tmp_12241_->payload.variant6._0;
        succ_7668_ &= true;
        ParsedStmt_s **then = &tmp_12241_->payload.variant6._1;
        succ_7668_ &= true;
        ParsedStmt_s **elze = &tmp_12241_->payload.variant6._2;
        succ_7668_ &= true;
        if (succ_7668_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u thenState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*then), (scopes)));
                TCState_u elseState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*elze), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(thenState))))
                    return (thenState);
                if ((isErrorPU9661rB)((&(elseState))))
                    return (elseState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto if-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12241;
        }
    }
    {
        succ_7683_ &= (tmp_12241_->tag == 7);
        ParsedExpr_s **cond = &tmp_12241_->payload.variant7._0;
        succ_7683_ &= true;
        ParsedStmt_s **body = &tmp_12241_->payload.variant7._1;
        succ_7683_ &= true;
        if (succ_7683_) {
            {
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u bodyState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*body), (scopes)));
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(bodyState))))
                    return (bodyState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto while-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12241;
        }
    }
    {
        succ_7697_ &= (tmp_12241_->tag == 13);
        ParsedPattern_s **pat = &tmp_12241_->payload.variant13._0;
        succ_7697_ &= true;
        ParsedExpr_s **expr = &tmp_12241_->payload.variant13._1;
        succ_7697_ &= true;
        ParsedBlock_s **block = &tmp_12241_->payload.variant13._2;
        succ_7697_ &= true;
        if (succ_7697_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
            }
            goto after_12241;
        }
    }
    {
        succ_7705_ &= (tmp_12241_->tag == 14);
        ParsedPattern_s **pat = &tmp_12241_->payload.variant14._0;
        succ_7705_ &= true;
        ParsedExpr_s **expr = &tmp_12241_->payload.variant14._1;
        succ_7705_ &= true;
        ParsedBlock_s **block = &tmp_12241_->payload.variant14._2;
        succ_7705_ &= true;
        ParsedBlock_s **elze = &tmp_12241_->payload.variant14._3;
        succ_7705_ &= true;
        if (succ_7705_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
                TCState_u elseState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*elze), (scopes), (false)));
                if ((isErrorPU9661rB)((&(elseState))))
                    return (elseState);
            }
            goto after_12241;
        }
    }
    {
        succ_7713_ &= (tmp_12241_->tag == 15);
        ParsedPattern_s **pat = &tmp_12241_->payload.variant15._0;
        succ_7713_ &= true;
        ParsedExpr_s **expr = &tmp_12241_->payload.variant15._1;
        succ_7713_ &= true;
        ParsedBlock_s **block = &tmp_12241_->payload.variant15._2;
        succ_7713_ &= true;
        if (succ_7713_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                ((state) = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((stmt)->span), (*pat), (*expr), (scopes), (false))));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                TCState_u blockState = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*block), (scopes), (false)));
                if ((isErrorPU9661rB)((&(blockState))))
                    return (blockState);
                ((popPS5541rPS1913)((scopes)));
            }
            goto after_12241;
        }
    }
    {
        succ_7721_ &= (tmp_12241_->tag == 8);
        ParsedStmt_s **init = &tmp_12241_->payload.variant8._0;
        succ_7721_ &= true;
        ParsedExpr_s **cond = &tmp_12241_->payload.variant8._1;
        succ_7721_ &= true;
        ParsedExpr_s **step = &tmp_12241_->payload.variant8._2;
        succ_7721_ &= true;
        ParsedStmt_s **body = &tmp_12241_->payload.variant8._3;
        succ_7721_ &= true;
        if (succ_7721_) {
            {
                ((pushPS5541S1913rN)((scopes), ((ScopeLookup_s){0})));
                TCState_u initState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*init), (scopes)));
                TCState_u condState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*cond), (scopes)));
                TCState_u stepState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*step), (scopes)));
                TCState_u bodyState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (*body), (scopes)));
                ((popPS5541rPS1913)((scopes)));
                if ((isErrorPU9661rB)((&(initState))))
                    return (initState);
                if ((isErrorPU9661rB)((&(condState))))
                    return (condState);
                if ((isErrorPU9661rB)((&(stepState))))
                    return (stepState);
                if ((isErrorPU9661rB)((&(bodyState))))
                    return (bodyState);
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                if ((wantsInferPU9661rB)((&(condState)))) {
                    ((condState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*cond), (boolType), (scopes))));
                    ((assertBPcrN)(((isTypePU9661rB)((&(condState)))), ("Could not infer type onto for-condition")));
                }

                Type_u *condType = ((getTypePU9661rPU5175)((&(condState))));
                if (!((isBooleanPU5175rB)((condType)))) {
                    return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*cond)->span), (boolType), (condType)));
                }
            }
            goto after_12241;
        }
    }
    {
        succ_7736_ &= (tmp_12241_->tag == 9);
        if (succ_7736_) {
            {
            }
            goto after_12241;
        }
    }
    {
        succ_7739_ &= (tmp_12241_->tag == 10);
        if (succ_7739_) {
            {
            }
            goto after_12241;
        }
    }
    {
        succ_7745_ &= (tmp_12241_->tag == 11);
        succ_7745_ &= true;
        succ_7745_ &= true;
        succ_7745_ &= true;
        if (succ_7745_) {
            {
                return ((typeCheckMatchStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
            }
            goto after_12241;
        }
    }
    {
        succ_7750_ &= (tmp_12241_->tag == 12);
        ParsedExpr_s **fn = &tmp_12241_->payload.variant12._0;
        succ_7750_ &= true;
        ParsedExprList_s *args = &tmp_12241_->payload.variant12._1;
        succ_7750_ &= true;
        if (succ_7750_) {
            {
                if (*((flags).disableInlineAssembly)) {
                    String_s loc = ((toStringPS8951rS0540)((&((stmt)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Cannot use inline assembly.\n"), ((loc).buffer), (ERR_STR)));
                    (((fprintf))((stderr_), ("%s: %s: Flag `--no-inline-assembly` was provided.\n"), ((loc).buffer), (NOTE_STR)));
                }

                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*fn), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                SubStr_s ASM_CONTEXT = ((BUILD_A_KEYWORDPcrS7720)(("ASMContext")));
                SubStr_s ASM_FILE = ((BUILD_A_KEYWORDPcrS7720)(("asm.bufo")));
                StructLookup_s *context = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)((&((this)->lookup)), (&(ASM_FILE)), (&(ASM_CONTEXT))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckStmt: Could not find struct context for ASMContext")));
                bool succ_7762_ = true;

                Type_u *tmp_12236_ = (exprType);
                {
                    succ_7762_ &= (tmp_12236_->tag == 6);
                    TypeList_s *params = &tmp_12236_->payload.variant6._0;
                    succ_7762_ &= true;
                    Type_u **ret = &tmp_12236_->payload.variant6._1;
                    succ_7762_ &= true;
                    succ_7762_ &= true;
                    if (succ_7762_) {
                        {
                            if (!((equalsPU5175PU5175rB)((*ret), ((context)->type)))) {
                                return ((reportAssemblyWrongReturnTypePS3900PS1100PU5175PU5175rU9661)((this), (stmt), (*ret), ((context)->type)));
                            }

                            if (((*args).length) != ((*params).length)) {
                                return ((reportAssemblyArgCountMismatchPS3900PS1100uszuszrU9661)((this), (stmt), ((*args).length), ((*params).length)));
                            }

                            for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((&(*args)), (i))));
                                Type_u *par = (*((atPS0643uszrPPU5175)((&(*params)), (i))));
                                TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (arg), (scopes)));
                                if ((isErrorPU9661rB)((&(argState))))
                                    return (argState);
                                if ((wantsInferPU9661rB)((&(argState)))) {
                                    ((todo_with_msgPcrN)(("infer type onto asm arg")));
                                }

                                ((assertBPcrN)(((isTypePU9661rB)((&(argState)))), ("Expected asm-arg to be valid by now")));
                            }
                        }
                        goto after_12236;
                    }
                }
                {
                    Type_u **type = &tmp_12236_;
                    if (true) {
                        {
                            return ((reportAssemblyNotAFunctionPS3900PS1100PU5175PU5175rU9661)((this), (stmt), (*type), ((context)->type)));
                        }
                        goto after_12236;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12236:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12241;
        }
    }
    {
        StmtData_u **unknown = &tmp_12241_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckStmt: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_12241;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12241:
    (void)0; // error: label at end of compound statement is a C23 extension
    if ((isErrorPU9661rB)((&(state))))
        return (state);
    (((stmt)->typeState) = (state));
    return (state);
}
TCState_u typeCheckMatchStmtPS3900PS1100PS5541rU9661(TypeChecker_s *this, ParsedStmt_s *match, ScopeLookupList_s *scopes) {
    ParsedExpr_s *expr = (NULL);
    ParsedPatternList_s *patterns = (NULL);
    ParsedStmtList_s *stmts = (NULL);
    bool succ_7781_ = true;

    StmtData_u *tmp_12255_ = (&((match)->data));
    {
        succ_7781_ &= (tmp_12255_->tag == 11);
        ParsedExpr_s **_expr = &tmp_12255_->payload.variant11._0;
        succ_7781_ &= true;
        ParsedPatternList_s *_patterns = &tmp_12255_->payload.variant11._1;
        succ_7781_ &= true;
        ParsedStmtList_s *_stmts = &tmp_12255_->payload.variant11._2;
        succ_7781_ &= true;
        if (succ_7781_) {
            {
                ((expr) = (*_expr));
                ((patterns) = (&(*_patterns)));
                ((stmts) = (&(*_stmts)));
            }
            goto after_12255;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_12255;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12255:
    (void)0; // error: label at end of compound statement is a C23 extension
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (expr), (scopes)));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    if ((wantsInferPU9661rB)((&(exprState))))
        ((todo_with_msgPcrN)(("match expr wants infer")));
    Type_u *type = ((getTypePU9661rPU5175)((&(exprState))));
    ((assertBrN)((((patterns)->length) == ((stmts)->length))));
    TCState_u result = (((TCState_u){.tag = 1, .payload = {0}}));
    bool complete = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((patterns)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ScopeLookup_s scope = ((ScopeLookup_s){0});
        ParsedPattern_s *pat = (*((atPS1982uszrPPS1826)((patterns), (i))));
        TCState_u patState = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (type), (pat), (scopes), (&(scope))));
        if ((isErrorPU9661rB)((&(patState)))) {
            ((result) = (patState));
            continue;
        }

        ((assertBrN)(((isPatternPU9661rB)((&(patState))))));
        PatState_s _patState = ((getPatStatePU9661rS1259)((&(patState))));
        ((pushPS5541S1913rN)((scopes), (scope)));
        ParsedStmt_s *stmt = (*((atPS3288uszrPPS1100)((stmts), (i))));
        TCState_u stmtState = ((typeCheckStmtPS3900PS1100PS5541rU9661)((this), (stmt), (scopes)));
        ((popPS5541rPS1913)((scopes)));
        ((complete) = ((_patState).complete));
        if ((complete) && ((i) != (((patterns)->length) - ((usize)(1llu))))) {
            ParsedPattern_s *next = (*((atPS1982uszrPPS1826)((patterns), ((i) + ((usize)(1llu))))));
            String_s loc = ((toStringPS8951rS0540)((&((next)->span))));
            (((fprintf))((stderr_), ("%s: %s: Unreachable pattern.\n"), ((loc).buffer), (WARN_STR)));
            ((dropPS0540rN)((&(loc))));
            (((patterns)->length) = ((i) + ((usize)(1llu))));
            (((stmts)->length) = ((i) + ((usize)(1llu))));
        }
    }

    if ((isErrorPU9661rB)((&(result))))
        return (result);
    if (!(complete)) {
        String_s loc = ((toStringPS8951rS0540)((&((match)->span))));
        (((fprintf))((stderr_), ("%s: %s: Patterns of a match statement must be exhaustive.\n"), ((loc).buffer), (ERR_STR)));
        char *wildcard = ((tokenKindToStringuszrPc)((TOKEN_WILDCARD)));
        (((fprintf))((stderr_), ("%s: %s: You can use the wildcard pattern %s to catch all other cases.\n"), ((loc).buffer), (NOTE_STR), (wildcard)));
        ((dropPS0540rN)((&(loc))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NON_EXHAUSTIVE_MATCH)}}});
    }

    (((match)->typeState) = ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}}));
    return (result);
}
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope) {
    return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (type), (pat), (scopes), (scope), (false)));
}
TCState_u _anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, Token_s ident, ScopeLookupList_s *scopes, ScopeLookup_s *scope,
                                                               bool globalScope) {
    Token_s loc = ((Token_s){0});
    if (globalScope) {
        usize index = ((usize)(0llu));
        ((assertBPcrN)(((getVarIndexByNamePS1913S7720PuszrB)((scope), ((ident).content), (&(index)))), ("Could not find variable in global scope")));
        VariableLookup_s *var = ((getVariableAtIndexPS1913uszrPS6661)((scope), (index)));
        (((var)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if ((isKnownVariablePS1913S7720PS6070rB)((scope), ((ident).content), (&(loc)))) {
        return ((reportVariableRedeclarationPS3900S6070S6070rU9661)((this), (ident), (loc)));
    }

    else {
        if (*((flags).warnSimple)) {
            for (usize i = ((usize)(0llu)); ((i) < (((scopes)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
                ScopeLookup_s *s = ((atPS5541uszrPS1913)((scopes), (i)));
                Token_s _loc = ((Token_s){0});
                if ((isKnownVariablePS1913S7720PS6070rB)((s), ((ident).content), (&(_loc)))) {
                    String_s loc1 = ((toStringPS8951rS0540)((&((ident).span))));
                    String_s loc2 = ((toStringPS8951rS0540)((&((_loc).span))));
                    String_s name1 = ((toStringPS7720rS0540)((&((ident).content))));
                    (((fprintf))((stderr_), ("%s: %s: Shadowing variable `%s` from an outer scope.\n"), ((loc1).buffer), (WARN_STR), ((name1).buffer)));
                    (((fprintf))((stderr_), ("%s: %s: Variable with the same name already declared here.\n"), ((loc2).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(name1))));
                    ((dropPS0540rN)((&(loc2))));
                    ((dropPS0540rN)((&(loc1))));
                }
            }
        }

        ((addVariablePS1913S6661rN)((scope), ((VariableLookup_s){.globalID = ((getIDPS1826rusz)((pat))),
                                                                 .name = (ident),
                                                                 .typeState = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}),
                                                                 .isComptime = (((this)->comptimeDepth) > ((usize)(0llu)))})));
    }

    return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
}
TCState_u checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661(TypeChecker_s *this, Type_u *type, ParsedPattern_s *pat, ScopeLookupList_s *scopes, ScopeLookup_s *scope, bool globalScope) {
    TCState_u (*check_ident)(TypeChecker_s *, Type_u *, ParsedPattern_s *, Token_s, ScopeLookupList_s *, ScopeLookup_s *, bool) = (_anon_23_2PS3900PU5175PS1826S6070PS5541PS1913BrU9661);
    bool succ_7819_ = true;
    bool succ_7827_ = true;
    bool succ_7831_ = true;
    bool succ_7840_ = true;
    bool succ_7843_ = true;
    bool succ_7848_ = true;
    bool succ_7901_ = true;
    bool succ_7920_ = true;
    bool succ_7923_ = true;
    bool succ_7926_ = true;
    bool succ_7930_ = true;

    Pattern_u *tmp_12522_ = (&((pat)->data));
    {
        succ_7819_ &= (tmp_12522_->tag == 3);
        ParsedPattern_s **subpat = &tmp_12522_->payload.variant3._0;
        succ_7819_ &= true;
        ParsedTypeNode_s **typeNode = &tmp_12522_->payload.variant3._1;
        succ_7819_ &= true;
        if (succ_7819_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*typeNode)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                Type_u *typ = ((getTypePU9661rPU5175)((&(typeState))));
                TCState_u err = (((TCState_u){.tag = 0, .payload = {0}}));
                if (!((equalsPU5175PU5175rB)((typ), (type)))) {
                    ((err) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((pat)->span), (typ), (type))));
                }

                TCState_u res = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (typ), (*subpat), (scopes), (scope), (globalScope)));
                if ((isErrorPU9661rB)((&(err))))
                    return (err);
                return (res);
            }
            goto after_12522;
        }
    }
    {
        succ_7827_ &= (tmp_12522_->tag == 2);
        Token_s *ident = &tmp_12522_->payload.variant2._0;
        succ_7827_ &= true;
        if (succ_7827_) {
            {
                return ((check_ident)((this), (type), (pat), (*ident), (scopes), (scope), (globalScope)));
            }
            goto after_12522;
        }
    }
    {
        succ_7831_ &= (tmp_12522_->tag == 4);
        ParsedPattern_s **sub = &tmp_12522_->payload.variant4._0;
        succ_7831_ &= true;
        if (succ_7831_) {
            {
                bool succ_7835_ = true;

                Type_u *tmp_12353_ = (type);
                {
                    succ_7835_ &= (tmp_12353_->tag == 4);
                    Type_u **under = &tmp_12353_->payload.variant4._0;
                    succ_7835_ &= true;
                    if (succ_7835_) {
                        {
                            return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (*under), (*sub), (scopes), (scope)));
                        }
                        goto after_12353;
                    }
                }
                {
                    if (true) {
                        {
                            return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                        }
                        goto after_12353;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12353:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12522;
        }
    }
    {
        succ_7840_ &= (tmp_12522_->tag == 9);
        succ_7840_ &= true;
        if (succ_7840_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12522;
        }
    }
    {
        succ_7843_ &= (tmp_12522_->tag == 10);
        if (succ_7843_) {
            {
                if (!((isPointerPU5175rB)((type)))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12522;
        }
    }
    {
        succ_7848_ &= (tmp_12522_->tag == 6);
        Token_s *name = &tmp_12522_->payload.variant6._0;
        succ_7848_ &= true;
        ParsedPattern_s **subPat = &tmp_12522_->payload.variant6._1;
        succ_7848_ &= true;
        if (succ_7848_) {
            {
                Token_s ident = ((Token_s){0});
                bool succ_7854_ = true;
                bool succ_7859_ = true;

                Pattern_u *tmp_12372_ = (&((*subPat)->data));
                {
                    succ_7854_ &= (tmp_12372_->tag == 2);
                    Token_s *_ident = &tmp_12372_->payload.variant2._0;
                    succ_7854_ &= true;
                    if (succ_7854_) {
                        {
                            ((ident) = (*_ident));
                        }
                        goto after_12372;
                    }
                }
                {
                    succ_7859_ &= (tmp_12372_->tag == 5);
                    Token_s *_ident = &tmp_12372_->payload.variant5._0;
                    succ_7859_ &= true;
                    succ_7859_ &= true;
                    if (succ_7859_) {
                        {
                            ((ident) = (*_ident));
                        }
                        goto after_12372;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Path Pattern expected Ident or Struct as RHS")));
                        }
                        goto after_12372;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12372:
                (void)0; // error: label at end of compound statement is a C23 extension
                bool succ_7865_ = true;

                Type_u *tmp_12436_ = (type);
                {
                    succ_7865_ &= (tmp_12436_->tag == 8);
                    ParsedUnionDecl_s **decl = &tmp_12436_->payload.variant8._0;
                    succ_7865_ &= true;
                    succ_7865_ &= true;
                    if (succ_7865_) {
                        {
                            if (!((equalsPS7720PS7720rB)((&((*name).content)), (&(((*decl)->name).content))))) {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            ParsedUnionVariant_s *variant = (NULL);
                            if (!((resolveVariantByNamePS0997PS6070PPS3506rB)((*decl), (&(ident)), (&(variant))))) {
                                return ((reportInvalidVariantPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            bool succ_7871_ = true;
                            bool succ_7878_ = true;

                            Pattern_u *tmp_12426_ = (&((*subPat)->data));
                            {
                                succ_7871_ &= (tmp_12426_->tag == 2);
                                Token_s *ident = &tmp_12426_->payload.variant2._0;
                                succ_7871_ &= true;
                                if (succ_7871_) {
                                    {
                                        bool succ_7874_ = true;

                                        ParsedUnionVariantData_u tmp_12381_ = ((variant)->data);
                                        succ_7874_ &= (tmp_12381_.tag == 0);
                                        if (!succ_7874_) {
                                            return ((reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661)((this), (pat), (type), ((variant)->data),
                                                                                                             (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}}))));
                                        };
                                    }
                                    goto after_12426;
                                }
                            }
                            {
                                succ_7878_ &= (tmp_12426_->tag == 5);
                                Token_s *ident = &tmp_12426_->payload.variant5._0;
                                succ_7878_ &= true;
                                ParsedPatternList_s *subPatterns = &tmp_12426_->payload.variant5._1;
                                succ_7878_ &= true;
                                if (succ_7878_) {
                                    {
                                        bool succ_7881_ = true;

                                        {
                                            ParsedUnionVariantData_u tmp_12384_ = ((variant)->data);
                                            succ_7881_ &= (tmp_12384_.tag == 0);

                                            if (succ_7881_) {
                                                return ((reportInvalidVariantPS3900PS1826PU5175U3836U3836rU9661)((this), (pat), (type), (((ParsedUnionVariantData_u){.tag = 0, .payload = {0}})),
                                                                                                                 ((variant)->data)));
                                            }
                                        }

                                        bool succ_7884_ = true;
                                        bool succ_7882_ = true;

                                        tuple_1044 tmp_12386_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
                                        succ_7882_ = tmp_12386_._0 == true;
                                        succ_7884_ &= succ_7882_;
                                        ParsedTypeNodeList_s **fields = &tmp_12386_._1;
                                        succ_7884_ &= true;
                                        if (!succ_7884_) {
                                            ((unreachablePcrN)(("Pattern::Struct got no variant fields")));
                                        };
                                        if (((*subPatterns).length) > ((*fields)->length)) {
                                            if (((*subPatterns).length) == (((*fields)->length) + ((usize)(1llu)))) {
                                                ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                                Pattern_u tmp_61626 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                                if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61626))))) {
                                                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                                }

                                            }

                                            else {
                                                return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                            }
                                        }

                                        if (((*subPatterns).length) < ((*fields)->length)) {
                                            if (((*subPatterns).length) > ((usize)(0llu))) {
                                                ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                                Pattern_u tmp_61672 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                                if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61672))))) {
                                                    return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                                }

                                            }

                                            else {
                                                return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                            }
                                        }

                                        bool complete = (true);
                                        for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                                            ParsedPattern_s *subSubPat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
                                            ParsedTypeNode_s *field = ((((*fields)->elements))[(i)]);
                                            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("checkAndBindPattern: Invalid field type")));
                                            Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                                            TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (fieldType), (subSubPat), (scopes), (scope)));
                                            if ((isErrorPU9661rB)((&(subComplete))))
                                                return (subComplete);
                                            if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                                                ((complete) = (false));
                                            }

                                            Pattern_u tmp_61756 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                            if (((tagAnyru8)((&((subSubPat)->data)))) == (((tagAnyru8)((&tmp_61756)))))
                                                break;
                                        }
                                    }
                                    goto after_12426;
                                }
                            }
                            {
                                if (true) {
                                    {
                                        ((unreachablePcrN)(("Expected Ident Pattern or Struct Pattern as RHS of Path Pattern")));
                                    }
                                    goto after_12426;
                                }
                            }
                            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
                        after_12426:
                            (void)0; // error: label at end of compound statement is a C23 extension
                            return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
                        }
                        goto after_12436;
                    }
                }
                {
                    Type_u **type = &tmp_12436_;
                    if (true) {
                        {
                            ModuleLookup_s *moduleLookup = (NULL);
                            if ((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (&(*name)), (&(moduleLookup)))) {
                                return ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (*type), (*subPat), (scopes), (scope)));
                            }

                            else {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (*type)));
                            }
                        }
                        goto after_12436;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12436:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12522;
        }
    }
    {
        succ_7901_ &= (tmp_12522_->tag == 5);
        Token_s *name = &tmp_12522_->payload.variant5._0;
        succ_7901_ &= true;
        ParsedPatternList_s *subPatterns = &tmp_12522_->payload.variant5._1;
        succ_7901_ &= true;
        if (succ_7901_) {
            {
                bool succ_7905_ = true;

                Type_u *tmp_12482_ = (type);
                {
                    succ_7905_ &= (tmp_12482_->tag == 7);
                    ParsedStructDecl_s **decl = &tmp_12482_->payload.variant7._0;
                    succ_7905_ &= true;
                    if (succ_7905_) {
                        {
                            StructLookup_s *lookup = ((getStructByGlobalIDPS7791uszrPS4228)((&((this)->lookup)), ((getIDPS5521rusz)((*decl)))));
                            if (!((equalsPS7720PS7720rB)((&((*name).content)), (&(((lookup)->name).content))))) {
                                return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                            }

                            if (((*subPatterns).length) > (((lookup)->fields).length)) {
                                if (((*subPatterns).length) == ((((lookup)->fields).length) + ((usize)(1llu)))) {
                                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                    Pattern_u tmp_61859 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61859))))) {
                                        return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                    }

                                }

                                else {
                                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                }
                            }

                            if (((*subPatterns).length) < (((lookup)->fields).length)) {
                                if (((*subPatterns).length) > ((usize)(0llu))) {
                                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (((*subPatterns).length) - ((usize)(1llu))))));
                                    Pattern_u tmp_61907 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_61907))))) {
                                        return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                    }

                                }

                                else {
                                    return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                                }
                            }

                            bool complete = (true);
                            for (usize i = ((usize)(0llu)); ((i) < (((lookup)->fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                ParsedPattern_s *subpat = (*((atPS1982uszrPPS1826)((&(*subPatterns)), (i))));
                                VariableLookup_s *field = ((atPS3313uszrPS6661)((&((lookup)->fields)), (i)));
                                ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("checkAndBindPattern: Invalid field type")));
                                Type_u *fieldType = ((getTypePU9661rPU5175)((&((field)->typeState))));
                                TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (fieldType), (subpat), (scopes), (scope)));
                                if ((isErrorPU9661rB)((&(subComplete))))
                                    return (subComplete);
                                if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                                    ((complete) = (false));
                                }

                                Pattern_u tmp_61995 = (((Pattern_u){.tag = 8, .payload = {0}}));

                                if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_61995)))))
                                    break;
                            }

                            return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (complete)})}}});
                        }
                        goto after_12482;
                    }
                }
                {
                    if (true) {
                        {
                            return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                        }
                        goto after_12482;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12482:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12522;
        }
    }
    {
        succ_7920_ &= (tmp_12522_->tag == 1);
        succ_7920_ &= true;
        if (succ_7920_) {
            {
                if ((!((isIntegerPU5175rB)((type)))) && (!((isFloatPU5175rB)((type))))) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (false)})}}});
            }
            goto after_12522;
        }
    }
    {
        succ_7923_ &= (tmp_12522_->tag == 0);
        if (succ_7923_) {
            {
                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
            }
            goto after_12522;
        }
    }
    {
        succ_7926_ &= (tmp_12522_->tag == 8);
        if (succ_7926_) {
            {
                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (true)})}}});
            }
            goto after_12522;
        }
    }
    {
        succ_7930_ &= (tmp_12522_->tag == 7);
        ParsedPatternList_s *patElems = &tmp_12522_->payload.variant7._0;
        succ_7930_ &= true;
        if (succ_7930_) {
            {
                bool succ_7934_ = true;

                Type_u *tmp_12494_ = (type);
                succ_7934_ &= (tmp_12494_->tag == 10);
                TypeList_s *typElems = &tmp_12494_->payload.variant10._0;
                succ_7934_ &= true;
                if (!succ_7934_) {
                    return ((reportImpossiblePatternPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                };
                if (((*patElems).length) < ((*typElems).length)) {
                    ((assertBPcrN)((((*patElems).length) > ((usize)(0llu))), ("Pattern::Tuple is empty?")));
                    ParsedPattern_s *last = (*((atPS1982uszrPPS1826)((&(*patElems)), (((*patElems).length) - ((usize)(1llu))))));
                    Pattern_u tmp_62083 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((last)->data)))) != (((tagAnyru8)((&tmp_62083))))) {
                        return ((reportNotEnoughPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                    }

                }

                else if (((*patElems).length) > ((*typElems).length)) {
                    return ((reportTooManyPatternsPS3900PS1826PU5175rU9661)((this), (pat), (type)));
                }

                bool complete = (true);
                for (usize i = ((usize)(0llu)); ((i) < ((*typElems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedPattern_s *subpat = ((((*patElems).elements))[(i)]);
                    Type_u *elemType = ((((*typElems).elements))[(i)]);
                    TCState_u subComplete = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913rU9661)((this), (elemType), (subpat), (scopes), (scope)));
                    if ((isErrorPU9661rB)((&(subComplete))))
                        return (subComplete);
                    if (!(((getPatStatePU9661rS1259)((&(subComplete)))).complete)) {
                        ((complete) = (false));
                    }

                    Pattern_u tmp_62158 = (((Pattern_u){.tag = 8, .payload = {0}}));

                    if (((tagAnyru8)((&((subpat)->data)))) == (((tagAnyru8)((&tmp_62158)))))
                        break;
                }

                return ((TCState_u){.tag = 5, .payload = {.variant5 = {._0 = ((PatState_s){.complete = (complete)})}}});
            }
            goto after_12522;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12522;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12522:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of patterns in checkAndBindPattern")));
}
TCState_u typeCheckVarDeclPS3900uszPS5541BrU9661(TypeChecker_s *this, usize varDeclID, ScopeLookupList_s *scopes, bool globalScope) {
    return ((typeCheckVarDeclPS3900PS1100PS5541BrU9661)((this), ((atPS8227uszrPS1100)((&(stmts)), (varDeclID))), (scopes), (globalScope)));
}
TCState_u handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661(TypeChecker_s *this, Span_s span, ParsedPattern_s *pat, ParsedExpr_s *expr, ScopeLookupList_s *scopes, bool globalScope) {
    TCState_u declState = (((TCState_u){.tag = 1, .payload = {0}}));
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (expr), (scopes)));
    if ((isErrorPU9661rB)((&(exprState)))) {
        ((declState) = (exprState));
        ((exprState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)((((Type_u){.tag = 0, .payload = {0}}))))}}}));
    }

    if ((wantsInferPU9661rB)((&(exprState)))) {
        ((exprState) = ((inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661)((this), (expr), (pat), (scopes))));
        if ((isErrorPU9661rB)((&(exprState)))) {
            ((declState) = (exprState));
            ((exprState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)((((Type_u){.tag = 0, .payload = {0}}))))}}}));
        }

        if ((wantsInferPU9661rB)((&(exprState)))) {
            return ((reportCouldNotInferTypePS3900S8951rU9661)((this), (span)));
        }

        ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("typeCheckVarDecl: infer failed")));
    }

    Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
    ScopeLookup_s *last = ((lastPS5541rPS1913)((scopes)));
    TCState_u state = ((checkAndBindPatternPS3900PU5175PS1826PS5541PS1913BrU9661)((this), (exprType), (pat), (scopes), (last), (globalScope)));
    if ((isErrorPU9661rB)((&(declState))))
        return (declState);
    return (state);
}
TCState_u typeCheckVarDeclPS3900PS1100PS5541BrU9661(TypeChecker_s *this, ParsedStmt_s *varDecl, ScopeLookupList_s *scopes, bool globalScope) {
    if ((varDecl)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    bool succ_7957_ = true;
    bool succ_7955_ = true;

    StmtData_u *tmp_12576_ = (&((varDecl)->data));
    {
        succ_7957_ &= (tmp_12576_->tag == 0);
        ParsedPattern_s **pat = &tmp_12576_->payload.variant0._0.pat;
        succ_7955_ &= true;
        ParsedExpr_s **expr = &tmp_12576_->payload.variant0._0.expr;
        succ_7955_ &= true;
        ParsedBlock_s **trampoline = &tmp_12576_->payload.variant0._0.trampoline;
        succ_7955_ &= true;
        bool *isComptime = &tmp_12576_->payload.variant0._0.isComptime;
        succ_7955_ &= true;
        succ_7955_ &= true;
        succ_7957_ &= succ_7955_;
        if (succ_7957_) {
            {
                if (*isComptime)
                    ((enterComptimePS3900rN)((this)));
                ScopeLookup_s *last = ((lastPS5541rPS1913)((scopes)));
                usize hack1 = (((last)->variables).length);
                TCState_u state = ((handleLetPatExprPS3900S8951PS1826PS2435PS5541BrU9661)((this), ((varDecl)->span), (*pat), (*expr), (scopes), (globalScope)));
                usize hack2 = (((last)->variables).length);
                if (*isComptime)
                    ((leaveComptimePS3900rN)((this)));
                if ((isErrorPU9661rB)((&(state))))
                    return (state);
                PatState_s _patState = ((getPatStatePU9661rS1259)((&(state))));
                if ((*trampoline) != (NULL)) {
                    ((((last)->variables).length) = (hack1));
                    ((state) = ((typeCheckBlockPS3900PS7247PS5541BrU9661)((this), (*trampoline), (scopes), (false))));
                    ((((last)->variables).length) = (hack2));
                    if ((_patState).complete) {
                        ((reportUnnecessaryTrampolinePS3900S8951rN)((this), ((*trampoline)->span)));
                    }

                }

                else if (!((_patState).complete)) {
                    return ((reportMissingTrampolinePS3900S8951rU9661)((this), ((varDecl)->span)));
                }

                (((varDecl)->typeState) = (state));
                return (state);
            }
            goto after_12576;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12576;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12576:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("typeCheckVarDecl: Expected VarDecl")));
}
TCState_u typeCheckExprPS3900uszPS5541rU9661(TypeChecker_s *this, usize exprID, ScopeLookupList_s *scopes) {
    return ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (scopes)));
}
TCState_u typeCheckExprPS3900PS2435PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ScopeLookupList_s *scopes) {
    if ((expr)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((expr)->typeState))))
        return ((expr)->typeState);
    TCState_u state = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_7969_ = true;
    bool succ_7973_ = true;
    bool succ_7979_ = true;
    bool succ_7984_ = true;
    bool succ_8009_ = true;
    bool succ_8013_ = true;
    bool succ_8017_ = true;
    bool succ_8021_ = true;
    bool succ_8025_ = true;
    bool succ_8031_ = true;
    bool succ_8036_ = true;
    bool succ_8039_ = true;
    bool succ_8042_ = true;
    bool succ_8045_ = true;
    bool succ_8048_ = true;
    bool succ_8052_ = true;
    bool succ_8060_ = true;
    bool succ_8069_ = true;
    bool succ_8078_ = true;

    ExprData_u *tmp_12711_ = (&((expr)->data));
    {
        succ_7969_ &= (tmp_12711_->tag == 0);
        succ_7969_ &= true;
        if (succ_7969_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12711;
        }
    }
    {
        succ_7973_ &= (tmp_12711_->tag == 1);
        succ_7973_ &= true;
        if (succ_7973_) {
            {
                Type_u *ct = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})));
                Type_u *st = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (ct)}}})));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (st)}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_7979_ &= (tmp_12711_->tag == 2);
        succ_7979_ &= true;
        if (succ_7979_) {
            {
                Type_u *ct = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 12}))}}})));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (ct)}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_7984_ &= (tmp_12711_->tag == 3);
        ArrayContext_s *context = &tmp_12711_->payload.variant3._0;
        succ_7984_ &= true;
        if (succ_7984_) {
            {
                if (((*context).elemLength) == ((usize)(0llu)))
                    return (((TCState_u){.tag = 4, .payload = {0}}));
                usize elemIndex = ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu))));
                TCState_u elemState = ((typeCheckExprPS3900uszPS5541rU9661)((this), (elemIndex), (scopes)));
                if ((isErrorPU9661rB)((&(elemState))))
                    return (elemState);
                if ((wantsInferPU9661rB)((&(elemState))))
                    return (elemState);
                Type_u *elemType = ((getTypePU9661rPU5175)((&(elemState))));
                if (((*context).size) == ((usize)(0llu))) {
                    TCState_u lastErrState = (((TCState_u){.tag = 0, .payload = {0}}));
                    for (usize i = ((usize)(1llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        usize nextIndex = ((getElementAtIndexPS8905uszrusz)((&(*context)), (i)));
                        TCState_u nextState = ((typeCheckExprPS3900uszPS5541rU9661)((this), (nextIndex), (scopes)));
                        if ((isErrorPU9661rB)((&(nextState)))) {
                            ((lastErrState) = (nextState));
                            continue;
                        }

                        Type_u *nextType = ((getTypePU9661rPU5175)((&(nextState))));
                        if (!((equalsPU5175PU5175rB)((nextType), (elemType)))) {
                            Span_s tmp_62536 = (((atPS7882uszrPS2435)((&(exprs)), (elemIndex)))->span);

                            String_s loc = ((toStringPS8951rS0540)((&tmp_62536)));
                            String_s t = ((toStringPU5175rS0540)((elemType)));
                            ((lastErrState) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), (((atPS7882uszrPS2435)((&(exprs)), (nextIndex)))->span), (elemType), (nextType))));
                            (((fprintf))((stderr_), ("%s: %s: Array elements inferred to be type %s here.\n"), ((loc).buffer), (NOTE_STR), ((t).buffer)));
                            ((dropPS0540rN)((&(t))));
                            ((dropPS0540rN)((&(loc))));
                        }
                    }

                    if (!((isInvalidPU9661rB)((&(lastErrState)))))
                        return (lastErrState);
                    Type_u *t = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (elemType), ._1 = ((*context).elemLength)}}})));
                    ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                }

                else {
                    Type_u *t = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (elemType), ._1 = ((*context).size)}}})));
                    ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                }
            }
            goto after_12711;
        }
    }
    {
        succ_8009_ &= (tmp_12711_->tag == 4);
        IdentExpr_s *ident = &tmp_12711_->payload.variant4._0;
        succ_8009_ &= true;
        if (succ_8009_) {
            {
                ((state) = ((typeCheckIdentifierPS3900PS7464PS5541rU9661)((this), (&(*ident)), (scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8013_ &= (tmp_12711_->tag == 5);
        UnaryExpr_u *unary = &tmp_12711_->payload.variant5._0;
        succ_8013_ &= true;
        if (succ_8013_) {
            {
                ((state) = ((typeCheckExprUnaryPS3900PU5427PS5541rU9661)((this), (&(*unary)), (scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8017_ &= (tmp_12711_->tag == 6);
        BinaryExpr_u *binary = &tmp_12711_->payload.variant6._0;
        succ_8017_ &= true;
        if (succ_8017_) {
            {
                ((state) = ((typeCheckExprBinaryPS3900PU0121PS5541rU9661)((this), (&(*binary)), (scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8021_ &= (tmp_12711_->tag == 7);
        CallExpr_s *call = &tmp_12711_->payload.variant7._0;
        succ_8021_ &= true;
        if (succ_8021_) {
            {
                ((state) = ((typeCheckExprCallPS3900PS3328PS5541rU9661)((this), (&(*call)), (scopes))));
                if ((*call).isUnion) {
                    (((expr)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = ((UnionExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (*call)}}})}}}));
                }
            }
            goto after_12711;
        }
    }
    {
        succ_8025_ &= (tmp_12711_->tag == 8);
        ParsedTypeNode_s **type = &tmp_12711_->payload.variant8._0;
        succ_8025_ &= true;
        if (succ_8025_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*type)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_8031_ &= (tmp_12711_->tag == 9);
        StructExpr_s *init = &tmp_12711_->payload.variant9._0;
        succ_8031_ &= true;
        if (succ_8031_) {
            {
                ((state) = ((typeCheckExprStructInitPS3900PS4761PS5541rU9661)((this), (&(*init)), (scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8036_ &= (tmp_12711_->tag == 11);
        ParsedExpr_s **curr = &tmp_12711_->payload.variant11._0;
        succ_8036_ &= true;
        ParsedTypeNode_s **type = &tmp_12711_->payload.variant11._1;
        succ_8036_ &= true;
        if (succ_8036_) {
            {
                ((state) = ((typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661)((this), (expr), (*curr), (*type), (scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8039_ &= (tmp_12711_->tag == 12);
        if (succ_8039_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12711;
        }
    }
    {
        succ_8042_ &= (tmp_12711_->tag == 13);
        if (succ_8042_) {
            {
                ((state) = (((TCState_u){.tag = 4, .payload = {0}})));
            }
            goto after_12711;
        }
    }
    {
        succ_8045_ &= (tmp_12711_->tag == 14);
        if (succ_8045_) {
            {
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_8048_ &= (tmp_12711_->tag == 15);
        if (succ_8048_) {
            {
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_8052_ &= (tmp_12711_->tag == 16);
        ParsedFuncDecl_s **decl = &tmp_12711_->payload.variant16._0;
        succ_8052_ &= true;
        if (succ_8052_) {
            {
                bool added = ((insertTLIPS0997PS1038rB)(((this)->currentModule), ((asTLIPS4904rPS1038)((*decl)))));
                ((assertBPcrN)((added), ("Func Expr was already contained in lookup!")));
                ((assertBPcrN)((((scopes)->length) > ((usize)(0llu))), ("Expected to at least find global scope in func expr")));
                ScopeLookupList_s _scopes = ((ScopeLookupList_s){0});
                ((pushPS5541S1913rN)((&(_scopes)), (*((atPS5541uszrPS1913)((scopes), ((usize)(0llu)))))));
                ((enterAnonFuncPS3900rN)((this)));
                FunctionLookup_s *fn = ((this)->currentFunction);
                ((state) = ((typeCheckFunctionPS3900PS4904PS5541BrU9661)((this), (*decl), (&(_scopes)), (false))));
                (((this)->currentFunction) = (fn));
                ((leaveAnonFuncPS3900rN)((this)));
                ((dropPS5541rN)((&(_scopes))));
            }
            goto after_12711;
        }
    }
    {
        succ_8060_ &= (tmp_12711_->tag == 17);
        ParsedTypeNode_s **type = &tmp_12711_->payload.variant17._0;
        succ_8060_ &= true;
        if (succ_8060_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*type)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("TypeInfo")));
                SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
                UnionLookup_s *context = ((findUnionByNameInFilePS7791PS7720PS7720rPS1592)((&((this)->lookup)), (&(FILE)), (&(NAME))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckExpr: Could not find union context for TypeInfo")));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((context)->type)}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_8069_ &= (tmp_12711_->tag == 18);
        ParsedExpr_s **subExpr = &tmp_12711_->payload.variant18._0;
        succ_8069_ &= true;
        if (succ_8069_) {
            {
                TCState_u typeState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*subExpr), (scopes)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                if ((wantsInferPU9661rB)((&(typeState))))
                    ((todo_with_msgPcrN)(("as_data infer")));
                SubStr_s NAME = ((BUILD_A_KEYWORDPcrS7720)(("Data")));
                SubStr_s FILE = ((BUILD_A_KEYWORDPcrS7720)(("type_info.bufo")));
                StructLookup_s *context = ((findStructByNameInFilePS7791PS7720PS7720rPS4228)((&((this)->lookup)), (&(FILE)), (&(NAME))));
                ((assertBPcrN)(((context) != (NULL)), ("typeCheckExpr: Could not find struct context for Data")));
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((context)->type)}}}));
            }
            goto after_12711;
        }
    }
    {
        succ_8078_ &= (tmp_12711_->tag == 20);
        ParsedExprList_s *elems = &tmp_12711_->payload.variant20._0;
        succ_8078_ &= true;
        if (succ_8078_) {
            {
                TypeList_s tElems = ((TypeList_s){0});
                TCState_u infer = (((TCState_u){.tag = 0, .payload = {0}}));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    TCState_u e = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((((*elems).elements))[(i)]), (scopes)));
                    if ((isErrorPU9661rB)((&(e))))
                        return (e);
                    if ((wantsInferPU9661rB)((&(e)))) {
                        ((infer) = (e));
                        continue;
                    }

                    ((pushPS0643PU5175rN)((&(tElems)), ((getTypePU9661rPU5175)((&(e))))));
                }

                if ((wantsInferPU9661rB)((&(infer))))
                    return (infer);
                ((state) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 10, .payload = {.variant10 = {._0 = (tElems)}}})))}}}));
            }
            goto after_12711;
        }
    }
    {
        ExprData_u **unknown = &tmp_12711_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckExpr: Unhandled Expression with tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_12711;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12711:
    (void)0; // error: label at end of compound statement is a C23 extension
    if ((isErrorPU9661rB)((&(state))))
        return (state);
    (((expr)->typeState) = (state));
    return (state);
}
TCState_u typeCheckExprAsPS3900PS2435PS2435PS1372PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedExpr_s *curr, ParsedTypeNode_s *type, ScopeLookupList_s *scopes) {
    TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (curr), (scopes)));
    TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (type)));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    if ((isErrorPU9661rB)((&(typeState))))
        return (typeState);
    ((assertBPcrN)(((isTypePU9661rB)((&(typeState)))), ("typeCheckExprAs Type is not a Type")));
    Type_u *typeType = ((getTypePU9661rPU5175)((&(typeState))));
    if ((wantsInferPU9661rB)((&(exprState))))
        ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (curr), (typeType), (scopes))));
    if ((isErrorPU9661rB)((&(exprState))))
        return (exprState);
    ((assertBPcrN)(((isTypePU9661rB)((&(exprState)))), ("Expected <expr> in `<expr> as <type>` to have a valid type after infer")));
    Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
    if (((isDataPU5175rB)((exprType))) && ((isDataPU5175rB)((typeType)))) {
        ((todo_with_msgPcrN)(("Data as Data???")));
    }

    else if ((isDataPU5175rB)((exprType))) {
    }

    else if ((isDataPU5175rB)((typeType))) {
        (((expr)->data) = ((ExprData_u){.tag = 18, .payload = {.variant18 = {._0 = (curr)}}}));
    }

    else if (((isPointerPU5175rB)((exprType))) && ((isPointerPU5175rB)((typeType)))) {
    }

    else if (((isFunctionPU5175rB)((exprType))) && ((isFunctionPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from type %s to type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isFunctionPU5175rB)((exprType))) && ((isAnyPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from type %s to Any.\n"), ((loc).buffer), (WARN_STR), ((from).buffer)));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isAnyPU5175rB)((exprType))) && ((isFunctionPU5175rB)((typeType)))) {
        if (*((flags).warnExtra)) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting from Any to type %s.\n"), ((loc).buffer), (WARN_STR), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isPointerPU5175rB)((exprType))) && ((isIntegerPU5175rB)((typeType)))) {
        if (((getSizeInBytesPU5175rusz)((typeType))) != ((getSizeInBytesPU5175rusz)((exprType)))) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting pointer of type %s to integer of type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (((isIntegerPU5175rB)((exprType))) && ((isPointerPU5175rB)((typeType)))) {
        if (((getSizeInBytesPU5175rusz)((typeType))) != ((getSizeInBytesPU5175rusz)((exprType)))) {
            String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
            String_s from = ((toStringPU5175rS0540)((exprType)));
            String_s to = ((toStringPU5175rS0540)((typeType)));
            (((fprintf))((stderr_), ("%s: %s: Casting integer of type %s to pointer of type %s.\n"), ((loc).buffer), (WARN_STR), ((from).buffer), ((to).buffer)));
            ((dropPS0540rN)((&(to))));
            ((dropPS0540rN)((&(from))));
            ((dropPS0540rN)((&(loc))));
        }

    }

    else if (!((isPrimitivePU5175rB)((typeType)))) {
        return ((reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661)((this), ((curr)->span), (exprType), (typeType)));
    }

    else if (!((isPrimitivePU5175rB)((exprType)))) {
        return ((reportNonPrimitiveCastPS3900S8951PU5175PU5175rU9661)((this), ((curr)->span), (exprType), (typeType)));
    }

    if ((((getSizeInBytesPU5175rusz)((typeType))) < ((getSizeInBytesPU5175rusz)((exprType)))) && (*((flags).warnExtra))) {
        String_s loc = ((toStringPS8951rS0540)((&((curr)->span))));
        String_s tName = ((toStringPU5175rS0540)((typeType)));
        String_s oName = ((toStringPU5175rS0540)((exprType)));
        (((fprintf))((stderr_), ("%s: %s: Lossy type cast: Target type (%s) is smaller than original type (%s).\n"), ((loc).buffer), (WARN_STR), ((tName).buffer), ((oName).buffer)));
        ((dropPS0540rN)((&(oName))));
        ((dropPS0540rN)((&(tName))));
        ((dropPS0540rN)((&(loc))));
    }

    return (typeState);
}
TCState_u typeCheckExprUnaryPS3900PU5427PS5541rU9661(TypeChecker_s *this, UnaryExpr_u *unary, ScopeLookupList_s *scopes) {
    bool succ_8117_ = true;
    bool succ_8122_ = true;
    bool succ_8142_ = true;
    bool succ_8148_ = true;
    bool succ_8158_ = true;

    UnaryExpr_u *tmp_12874_ = (unary);
    {
        succ_8117_ &= (tmp_12874_->tag == 0);
        ParsedExpr_s **expr = &tmp_12874_->payload.variant0._0;
        succ_8117_ &= true;
        if (succ_8117_) {
            {
                ((enterComptimePS3900rN)((this)));
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                ((leaveComptimePS3900rN)((this)));
                return (exprState);
            }
            goto after_12874;
        }
    }
    {
        succ_8122_ &= (tmp_12874_->tag == 2);
        ParsedExpr_s **expr = &tmp_12874_->payload.variant2._0;
        succ_8122_ &= true;
        if (succ_8122_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                bool succ_8129_ = true;
                bool succ_8127_ = true;
                bool succ_8133_ = true;

                Type_u *tmp_12829_ = (exprType);
                {
                    succ_8129_ &= (tmp_12829_->tag == 3);
                    succ_8127_ &= (tmp_12829_->payload.variant3._0.tag == 9);
                    succ_8129_ &= succ_8127_;
                    if (succ_8129_) {
                        {
                            return ((reportAnyDereferencePS3900PS2435rU9661)((this), (*expr)));
                        }
                        goto after_12829;
                    }
                }
                {
                    succ_8133_ &= (tmp_12829_->tag == 4);
                    Type_u **under = &tmp_12829_->payload.variant4._0;
                    succ_8133_ &= true;
                    if (succ_8133_) {
                        {
                            return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (*under)}}});
                        }
                        goto after_12829;
                    }
                }
                {
                    if (true) {
                        {
                            String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                            String_s t = ((toStringPU5175rS0540)((exprType)));
                            (((fprintf))((stderr_), ("%s: %s: Attempted to dereference expression of type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                            ((dropPS0540rN)((&(t))));
                            ((dropPS0540rN)((&(loc))));
                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_DEREF_NON_POINTER)}}});
                        }
                        goto after_12829;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_12829:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_12874;
        }
    }
    {
        succ_8142_ &= (tmp_12874_->tag == 1);
        ParsedExpr_s **expr = &tmp_12874_->payload.variant1._0;
        succ_8142_ &= true;
        if (succ_8142_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (exprType)}}})))}}});
            }
            goto after_12874;
        }
    }
    {
        succ_8148_ &= (tmp_12874_->tag == 3);
        ParsedExpr_s **expr = &tmp_12874_->payload.variant3._0;
        succ_8148_ &= true;
        if (succ_8148_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if ((!((isSignedIntegerPU5175rB)((exprType)))) && (!((isFloatPU5175rB)((exprType))))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    String_s t = ((toStringPU5175rS0540)((exprType)));
                    (((fprintf))((stderr_), ("%s: %s: Negation is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                    ((dropPS0540rN)((&(t))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                return (exprState);
            }
            goto after_12874;
        }
    }
    {
        succ_8158_ &= (tmp_12874_->tag == 4);
        ParsedExpr_s **expr = &tmp_12874_->payload.variant4._0;
        succ_8158_ &= true;
        if (succ_8158_) {
            {
                TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*expr), (scopes)));
                if ((isErrorPU9661rB)((&(exprState))))
                    return (exprState);
                if ((wantsInferPU9661rB)((&(exprState))))
                    return (exprState);
                Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
                if (!((isBooleanPU5175rB)((exprType)))) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    String_s t = ((toStringPU5175rS0540)((exprType)));
                    (((fprintf))((stderr_), ("%s: %s: Logical Not is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                    ((dropPS0540rN)((&(t))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                return (exprState);
            }
            goto after_12874;
        }
    }
    {
        if (true) {
            {
            }
            goto after_12874;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_12874:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of ops in typeCheckUnary")));
}
TCState_u _anon_23_3PS3900PS7823PS0643PS5541BrU9661(TypeChecker_s *this, ParsedExprList_s *args, TypeList_s *params, ScopeLookupList_s *scopes, bool variadic) {
    for (usize i = ((usize)(0llu)); ((i) < ((params)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedExpr_s **arg = ((atPS7823uszrPPS2435)((args), (i)));
        Type_u *paramType = (*((atPS0643uszrPPU5175)((params), (i))));
        TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*(arg)), (scopes)));
        if ((isErrorPU9661rB)((&(argState))))
            return (argState);
        if ((wantsInferPU9661rB)((&(argState)))) {
            ((argState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (*(arg)), (paramType), (scopes))));
            if ((isErrorPU9661rB)((&(argState))))
                return (argState);
        }

        Type_u *argType = ((getTypePU9661rPU5175)((&(argState))));
        if (((isVariadicTypePU5175rB)((argType))) && (variadic)) {
            ((assertBPcrN)((((params)->length) == ((usize)(1llu))), ("check_params: Assumption wrong")));
        }

        else if ((!((isDataPU5175rB)((argType)))) && ((isDataPU5175rB)((paramType)))) {
            ((*(arg)) = ((newParsedExprS8951U8798rPS2435)(((*(arg))->span), ((ExprData_u){.tag = 18, .payload = {.variant18 = {._0 = (*(arg))}}}))));
            TCState_u newState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*(arg)), (scopes)));
            if ((isErrorPU9661rB)((&(newState))))
                return (newState);
            ((assertBPcrN)(((isTypePU9661rB)((&(newState)))), ("idk if this is always the case")));
        }

        else if (!((equalsPU5175PU5175rB)((argType), (paramType)))) {
            ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((*(arg))->span), (paramType), (argType)));
        }
    }

    return (((TCState_u){.tag = 1, .payload = {0}}));
}
TCState_u typeCheckExprCallPS3900PS3328PS5541rU9661(TypeChecker_s *this, CallExpr_s *call, ScopeLookupList_s *scopes) {
    ParsedExprList_s *args = (&((call)->args));
    for (usize i = ((usize)(0llu)); ((i) < ((args)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        TCState_u arg = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (*((atPS7823uszrPPS2435)((args), (i)))), (scopes)));
        if ((isErrorPU9661rB)((&(arg))))
            return (arg);
    }

    TCState_u callBase = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), ((call)->base), (scopes)));
    if ((isErrorPU9661rB)((&(callBase))))
        return (callBase);
    if ((wantsInferPU9661rB)((&(callBase)))) {
        TypeList_s params = ((TypeList_s){0});
        for (usize i = ((usize)(0llu)); ((i) < ((args)->length)); ((i) = ((i) + ((usize)(1llu))))) {
            Type_u *typ = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}}))));
            TCState_u *state = (&((*((atPS7823uszrPPS2435)((args), (i))))->typeState));
            if ((isTypePU9661rB)((state)))
                ((typ) = ((getTypePU9661rPU5175)((state))));
            ((pushPS0643PU5175rN)((&(params)), (typ)));
        }

        Type_u *fnType =
            ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}})))), ._2 = ((FuncAttr_s){0})}}})));
        TCState_u baseState = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((call)->base), (fnType), (scopes), (false)));
        if ((isErrorPU9661rB)((&(baseState))))
            return (baseState);
        if ((wantsInferPU9661rB)((&(baseState))))
            return (baseState);
        ((callBase) = (baseState));
    }

    Type_u *baseType = ((getTypePU9661rPU5175)((&(callBase))));
    bool succ_8185_ = true;
    bool succ_8203_ = true;

    Type_u *tmp_13032_ = (baseType);
    {
        succ_8185_ &= (tmp_13032_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_13032_->payload.variant8._0;
        succ_8185_ &= true;
        usize *vID = &tmp_13032_->payload.variant8._1;
        succ_8185_ &= true;
        if (succ_8185_) {
            {
                ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (*vID))));
                bool succ_8190_ = true;

                ParsedUnionVariantData_u *tmp_12907_ = (&((variant)->data));
                succ_8190_ &= (tmp_12907_->tag == 1);
                ParsedTypeNodeList_s *fields = &tmp_12907_->payload.variant1._0;
                succ_8190_ &= true;
                if (!succ_8190_) {
                    return ((reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661)((this), (*decl), (variant), ((call)->span), (((ParsedUnionVariantData_u){.tag = 1, .payload = {0}}))));
                };
                if (((args)->length) != ((*fields).length))
                    ((todo_with_msgPcrN)(("report error: Tuple variant count mismatch")));
                Type_u *unionType = ((copyPU5175rPU5175)((baseType)));
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *arg = (*((atPS7823uszrPPS2435)((args), (i))));
                    TCState_u argState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (arg), (scopes)));
                    if ((isErrorPU9661rB)((&(argState))))
                        return (argState);
                    Type_u *paramType = ((getTypeAtIndexPS3506uszrPU5175)((variant), (i)));
                    if ((wantsInferPU9661rB)((&(argState)))) {
                        ((argState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (arg), (paramType), (scopes))));
                        if ((isErrorPU9661rB)((&(argState))))
                            return (argState);
                    }

                    Type_u *argType = ((getTypePU9661rPU5175)((&(argState))));
                    if (!((equalsPU5175PU5175rB)((argType), (paramType)))) {
                        ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((arg)->span), (paramType), (argType)));
                    }
                }

                (((call)->isUnion) = (true));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}});
            }
            goto after_13032;
        }
    }
    {
        succ_8203_ &= (tmp_13032_->tag == 6);
        TypeList_s *params = &tmp_13032_->payload.variant6._0;
        succ_8203_ &= true;
        Type_u **ret = &tmp_13032_->payload.variant6._1;
        succ_8203_ &= true;
        FuncAttr_s *attr = &tmp_13032_->payload.variant6._2;
        succ_8203_ &= true;
        if (succ_8203_) {
            {
                TCState_u (*check_params)(TypeChecker_s *, ParsedExprList_s *, TypeList_s *, ScopeLookupList_s *, bool) = (_anon_23_3PS3900PS7823PS0643PS5541BrU9661);
                if ((*attr).isVariadic) {
                    ((assertBPcrN)((((*params).length) > ((usize)(0llu))), ("Variadic function with 0 parameters")));
                    Type_u *last = ((((*params).elements))[(((*params).length) - ((usize)(1llu)))]);
                    TCState_u state = (((TCState_u){.tag = 0, .payload = {0}}));
                    if ((isVariadicTypePU5175rB)((last))) {
                        (((*params).length) = (((*params).length) - ((usize)(1llu))));
                        if (((args)->length) < ((*params).length)) {
                            ((state) = ((reportArgumentCountMismatchPS3900S8951PU5175uszBrU9661)((this), ((call)->span), (baseType), ((args)->length), (true))));
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        Type_u *varType = ((getUnderlyingTypePU5175BrPU5175)((last), (false)));
                        ((state) = ((check_params)((this), (args), (&(*params)), (scopes), (false))));
                        if (!((isSuccessPU9661rB)((&(state))))) {
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        usize varLen = (((args)->length) - ((*params).length));
                        ParsedExprList_s varArgs = ((ParsedExprList_s){0});
                        TypeList_s varParams = ((TypeList_s){0});
                        for (usize i = ((usize)(0llu)); ((i) < (varLen)); ((i) = ((i) + ((usize)(1llu))))) {
                            ((pushPS7823PS2435rN)((&(varArgs)), (*((atPS7823uszrPPS2435)((args), (((*params).length) + (i)))))));
                            ((pushPS0643PU5175rN)((&(varParams)), (varType)));
                        }

                        ((state) = ((check_params)((this), (&(varArgs)), (&(varParams)), (scopes), (true))));
                        if (!((isSuccessPU9661rB)((&(state))))) {
                            (((*params).length) = (((*params).length) + ((usize)(1llu))));
                            return (state);
                        }

                        (((args)->length) = ((*params).length));
                        if (((varArgs).length) == ((usize)(1llu))) {
                            ParsedExpr_s *entry = ((((varArgs).elements))[((usize)(0llu))]);
                            ((assertBPcrN)(((isTypePU9661rB)((&((entry)->typeState)))), ("Single VarArg is not valid")));
                            Type_u *t = ((getTypePU9661rPU5175)((&((entry)->typeState))));
                            if ((isVariadicTypePU5175rB)((t))) {
                                if ((equalsPU5175PU5175rB)(((getUnderlyingTypePU5175BrPU5175)((t), (false))), (varType))) {
                                    ((pushPS7823PS2435rN)((args), (entry)));
                                }

                                else {
                                    ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                                    (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                                    ((pushPS7823PS2435rN)((args), (varArg)));
                                }

                            }

                            else {
                                ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                                (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                                ((pushPS7823PS2435rN)((args), (varArg)));
                            }

                        }

                        else {
                            ParsedExpr_s *varArg = ((newParsedExprS8951U8798rPS2435)(((call)->span), ((ExprData_u){.tag = 19, .payload = {.variant19 = {._0 = (varArgs)}}})));
                            (((varArg)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (last)}}}));
                            ((pushPS7823PS2435rN)((args), (varArg)));
                        }

                        (((*params).length) = (((*params).length) + ((usize)(1llu))));
                    }

                    else {
                        ((state) = ((check_params)((this), (args), (&(*params)), (scopes), (false))));
                        if (!((isSuccessPU9661rB)((&(state)))))
                            return (state);
                    }

                }

                else {
                    if (((args)->length) != ((*params).length)) {
                        return ((reportArgumentCountMismatchPS3900S8951PU5175uszrU9661)((this), ((call)->span), (baseType), ((args)->length)));
                    }

                    TCState_u state = ((check_params)((this), (args), (&(*params)), (scopes), (false)));
                    if (!((isSuccessPU9661rB)((&(state)))))
                        return (state);
                }

                (((call)->retType) = (*ret));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (*ret)}}});
            }
            goto after_13032;
        }
    }
    {
        if (true) {
            {
                return ((reportCallToNonFunctionPS3900S8951PU5175rU9661)((this), ((call)->span), (baseType)));
            }
            goto after_13032;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13032:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u typeCheckExprStructInitPS3900PS4761PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, ScopeLookupList_s *scopes) {
    TypeLookup_s lookup = ((TypeLookup_s){0});
    if (!((resolveTypeByNamePS0997PS7720PS6177rB)(((this)->currentModule), (&(((expr)->name).content)), (&(lookup))))) {
        TypeLookupList_s alternatives = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((&((this)->lookup)), (&(((expr)->name).content))));
        return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (NULL), ((expr)->name), (alternatives)));
    }

    if ((isStructPS6177rB)((&(lookup)))) {
        return ((typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661)((this), (expr), (lookup), (scopes)));
    }

    else {
        ((unreachablePcrN)(("typeCheckExprStructInit got non-struct")));
    }
}
TCState_u typeCheckIdentifierPS3900PS7464PS5541rU9661(TypeChecker_s *this, IdentExpr_s *ident, ScopeLookupList_s *scopes) {
    VariableLookup_s var = ((VariableLookup_s){0});
    Token_s *name = (&((ident)->name));
    if ((resolveVariableByNamePS0997PS6070PS5541PS6661rB)(((this)->currentModule), (name), (scopes), (&(var)))) {
        if ((((this)->comptimeDepth) > ((usize)(0llu))) && (!((var).isComptime))) {
            return ((reportRuntimeValueInComptimeContextPS3900S6070PS6661rU9661)((this), (*(name)), (&(var))));
        }

        TCState_u state = ((var).typeState);
        ((assertBPcrN)((!((isInvalidPU9661rB)((&(state))))), ("Variable not ready")));
        if ((isErrorPU9661rB)((&(state))))
            return (state);
        Token_s _loc = ((Token_s){0});
        if ((isKnownVariablePS1913S7720PS6070rB)(((atPS5541uszrPS1913)((scopes), ((usize)(0llu)))), ((name)->content), (&(_loc)))) {
            (((ident)->isGlobal) = (true));
        }

        if ((isTypePU9661rB)((&(state)))) {
            (((ident)->type) = ((getTypePU9661rPU5175)((&(state)))));
        }

        (((ident)->origID) = ((var).globalID));
        return (state);
    }

    FunctionLookupList_s functions = ((resolveFunctionByNamePS0997PS6070rS8385)(((this)->currentModule), (name)));
    if (((functions).length) > ((usize)(1llu))) {
        ((dropPS8385rN)((&(functions))));
        return (((TCState_u){.tag = 4, .payload = {0}}));
    }

    if (((functions).length) == ((usize)(1llu))) {
        FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
        (((ident)->type) = ((getTypePU9661rPU5175)((&((f)->fnType)))));
        (((ident)->origID) = ((f)->globalID));
        return ((f)->fnType);
    }

    UnionLookup_s *unionLookup = (NULL);
    if ((resolveUnionByNamePS0997PS6070PPS1592rB)(((this)->currentModule), (name), (&(unionLookup)))) {
        ((assertBPcrN)(((unionLookup) != (NULL)), ("resolveUnionByName returned true but lookup is null")));
        ParsedUnionDecl_s *decl = ((unionLookup)->global);
        ((assertBPcrN)(((isSuccessPU9661rB)((&((decl)->typeState)))), ("Expected valid union type at this point")));
        Type_u *t = ((getTypePU9661rPU5175)((&((decl)->typeState))));
        ((assertBPcrN)(((isUnionPU5175rB)((t))), ("Expected union declaration to have union type")));
        (((ident)->type) = (t));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((copyPU5175rPU5175)((t)))}}});
    }

    ModuleLookup_s *moduleLookup = (NULL);
    if ((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (name), (&(moduleLookup)))) {
        Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((moduleLookup)->globalID)))}}})));
        (((ident)->type) = (typ));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}});
    }

    return ((reportUnknownIdentifierPS3900PS6070rU9661)((this), (name)));
}
TCState_u typeCheckExprBinaryPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    bool succ_8252_ = true;
    bool succ_8256_ = true;
    bool succ_8260_ = true;
    bool succ_8264_ = true;
    bool succ_8268_ = true;
    bool succ_8272_ = true;
    bool succ_8276_ = true;
    bool succ_8280_ = true;
    bool succ_8284_ = true;
    bool succ_8288_ = true;
    bool succ_8292_ = true;
    bool succ_8296_ = true;
    bool succ_8300_ = true;
    bool succ_8304_ = true;
    bool succ_8308_ = true;
    bool succ_8312_ = true;
    bool succ_8316_ = true;
    bool succ_8320_ = true;
    bool succ_8324_ = true;
    bool succ_8328_ = true;

    BinaryExpr_u *tmp_13135_ = (expr);
    {
        succ_8252_ &= (tmp_13135_->tag == 0);
        succ_8252_ &= true;
        if (succ_8252_) {
            {
                return ((typeCheckExprPathAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8256_ &= (tmp_13135_->tag == 1);
        succ_8256_ &= true;
        if (succ_8256_) {
            {
                return ((typeCheckExprMemberAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8260_ &= (tmp_13135_->tag == 2);
        succ_8260_ &= true;
        if (succ_8260_) {
            {
                return ((typeCheckExprAssignPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8264_ &= (tmp_13135_->tag == 3);
        succ_8264_ &= true;
        if (succ_8264_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8268_ &= (tmp_13135_->tag == 4);
        succ_8268_ &= true;
        if (succ_8268_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8272_ &= (tmp_13135_->tag == 5);
        succ_8272_ &= true;
        if (succ_8272_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8276_ &= (tmp_13135_->tag == 6);
        succ_8276_ &= true;
        if (succ_8276_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8280_ &= (tmp_13135_->tag == 7);
        succ_8280_ &= true;
        if (succ_8280_) {
            {
                return ((typeCheckExprArithmeticPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8284_ &= (tmp_13135_->tag == 8);
        succ_8284_ &= true;
        if (succ_8284_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8288_ &= (tmp_13135_->tag == 9);
        succ_8288_ &= true;
        if (succ_8288_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8292_ &= (tmp_13135_->tag == 10);
        succ_8292_ &= true;
        if (succ_8292_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8296_ &= (tmp_13135_->tag == 11);
        succ_8296_ &= true;
        if (succ_8296_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8300_ &= (tmp_13135_->tag == 12);
        succ_8300_ &= true;
        if (succ_8300_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8304_ &= (tmp_13135_->tag == 13);
        succ_8304_ &= true;
        if (succ_8304_) {
            {
                return ((typeCheckExprComparisonPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8308_ &= (tmp_13135_->tag == 14);
        succ_8308_ &= true;
        if (succ_8308_) {
            {
                return ((typeCheckExprLogicalPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8312_ &= (tmp_13135_->tag == 15);
        succ_8312_ &= true;
        if (succ_8312_) {
            {
                return ((typeCheckExprLogicalPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8316_ &= (tmp_13135_->tag == 16);
        succ_8316_ &= true;
        if (succ_8316_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8320_ &= (tmp_13135_->tag == 17);
        succ_8320_ &= true;
        if (succ_8320_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8324_ &= (tmp_13135_->tag == 18);
        succ_8324_ &= true;
        if (succ_8324_) {
            {
                return ((typeCheckExprBitwisePS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        succ_8328_ &= (tmp_13135_->tag == 19);
        succ_8328_ &= true;
        if (succ_8328_) {
            {
                return ((typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661)((this), (expr), (scopes)));
            }
            goto after_13135;
        }
    }
    {
        BinaryExpr_u **unknown = &tmp_13135_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s typeCheckExprBinary: Unhandled tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_13135;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13135:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of binary expressions in typeCheckExprBinary")));
}
TCState_u typeCheckExprIndexedAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    if ((wantsInferPU9661rB)((&(lhsState)))) {
        String_s loc = ((toStringPS8951rS0540)((&((lhs)->span))));
        (((fprintf))((stderr_), ("%s: %s: Could not infer type of subexpression for indexed access.\n"), ((loc).buffer), (ERR_STR)));
        ((dropPS0540rN)((&(loc))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_ACCESS_ON_NON_ARRAY)}}});
    }

    ((assertBPcrN)(((isTypePU9661rB)((&(lhsState)))), ("IndexedAccess: Not error, not infer, what is it?")));
    if ((wantsInferPU9661rB)((&(rhsState)))) {
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        ((rhsState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (rhs), (usizeType), (scopes))));
    }

    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    ((assertBPcrN)(((isTypePU9661rB)((&(rhsState)))), ("IndexedAccess: Index is not valid after infer?")));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    if (((!((isArrayPU5175rB)((lhsType)))) && (!((isPointerPU5175rB)((lhsType))))) && (!((isVariadicTypePU5175rB)((lhsType))))) {
        return ((reportIndexedAccessOnNonArrayPS3900S8951PU5175rU9661)((this), ((lhs)->span), (lhsType)));
    }

    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    bool succ_8349_ = true;
    bool succ_8347_ = true;

    Type_u *tmp_13169_ = (rhsType);
    {
        succ_8349_ &= (tmp_13169_->tag == 3);
        succ_8347_ &= (tmp_13169_->payload.variant3._0.tag == 8);
        succ_8349_ &= succ_8347_;
        if (succ_8349_) {
            {
                Type_u *underlyingType = ((getUnderlyingTypePU5175BrPU5175)((lhsType), (false)));
                return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (underlyingType)}}});
            }
            goto after_13169;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13169;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13169:
    (void)0; // error: label at end of compound statement is a C23 extension
    String_s loc = ((toStringPS8951rS0540)((&((rhs)->span))));
    String_s typ = ((toStringPU5175rS0540)((rhsType)));
    (((fprintf))((stderr_), ("%s: %s: Expected index of array access to be type usize, got %s.\n"), ((loc).buffer), (ERR_STR), ((typ).buffer)));
    ((dropPS0540rN)((&(typ))));
    ((dropPS0540rN)((&(loc))));
    (((this)->typeError) = (true));
    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_INDEXED_TYPE_MISMATCH)}}});
}
TCState_u typeCheckExprLogicalPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (boolType)}}});
    if (!((isBooleanPU5175rB)((lhsType)))) {
        ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((lhs)->span), (boolType), (lhsType))));
    }

    if (!((isBooleanPU5175rB)((rhsType)))) {
        ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((rhs)->span), (boolType), (rhsType))));
    }

    return (result);
}
TCState_u typeCheckExprBitwisePS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (((!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) || (!((isIntegerPU5175rB)((lhsType))))) || (!((isIntegerPU5175rB)((rhsType))))) {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    return (lhsState);
}
TCState_u typeCheckExprAssignPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    if (!((isLValuePS2435rB)((lhs)))) {
        ((emergencyPrintPS3900S8951rN)((this), ((lhs)->span)));
        ((todo_with_msgPcrN)(("invalid l-value")));
    }

    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if (!((isTypePU9661rB)((&(lhsState)))))
        return (lhsState);
    if (!((isTypePU9661rB)((&(rhsState)))))
        return (rhsState);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) {
        return ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((rhs)->span), (lhsType), (rhsType)));
    }

    return (rhsState);
}
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes) {
    return ((typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661)((this), (expr), (lookup), (scopes), (false)));
}
TCState_u typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661(TypeChecker_s *this, StructExpr_s *expr, TypeLookup_s lookup, ScopeLookupList_s *scopes, bool isUnion) {
    StructInitContext_s *context = (&((expr)->context));
    StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
    usize hits = ((usize)(0llu));
    ((assertBPcrN)(((((structLookup)->fields).length) < ((usize)(50llu))), ("Sorry, I need to hack this for now")));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((structLookup)->type)}}});
    for (usize i = ((usize)(0llu)); ((i) < ((context)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((context), (i)));
        ParsedExpr_s *fieldExpr = ((getFieldExprAtIndexPS6291uszrPS2435)((context), (i)));
        TCState_u exprState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (fieldExpr), (scopes)));
        if ((isErrorPU9661rB)((&(exprState))))
            ((result) = (exprState));
        if (!((hasFieldPS4228PS7720rB)((structLookup), (&((name).content))))) {
            ((result) = ((reportUnknownFieldPS3900S6070PS4228BrU9661)((this), (name), (structLookup), (isUnion))));
            continue;
        }

        usize fieldIndex = ((getIndexByNamePS4228PS6070rusz)((structLookup), (&(name))));
        usize bit = ((shiftLeftuszuszrusz)(((usize)(1llu)), (fieldIndex)));
        if (((hits) & (bit)) != ((usize)(0llu))) {
            Token_s field = ((getFieldNameAtIndexPS6291uszrS6070)((context), (fieldIndex)));
            ((result) = ((reportDuplicateFieldPS3900S6070S8951rU9661)((this), (name), ((field).span))));
            continue;
        }

        else {
            ((hits) = ((hits) | (bit)));
        }

        VariableLookup_s *field = ((atPS3313uszrPS6661)((&((structLookup)->fields)), (fieldIndex)));
        TCState_u *fieldState = (&((field)->typeState));
        ((assertBPcrN)(((isSuccessPU9661rB)((fieldState))), ("Struct is ready to go, but field type is invalid?")));
        ((assertBPcrN)(((equalsPS7720PS7720rB)((&((name).content)), (&(((field)->name).content)))), ("Seems like my hack doesn\'t work")));
        Type_u *fieldType = ((getTypePU9661rPU5175)((fieldState)));
        if ((wantsInferPU9661rB)((&(exprState))))
            ((exprState) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (fieldExpr), (fieldType), (scopes))));
        if ((isErrorPU9661rB)((&(exprState)))) {
            ((result) = (exprState));
            continue;
        }

        Type_u *exprType = ((getTypePU9661rPU5175)((&(exprState))));
        if (!((equalsPU5175PU5175rB)((fieldType), (exprType)))) {
            ((result) = ((reportTypeMismatchPS3900S8951PU5175PU5175rU9661)((this), ((fieldExpr)->span), (fieldType), (exprType))));
        }
    }

    return (result);
}
TCState_u typeCheckExprPathAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u instance = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    if ((isErrorPU9661rB)((&(instance))))
        return (instance);
    Type_u *instanceType = ((getTypePU9661rPU5175)((&(instance))));
    bool succ_8440_ = true;
    bool succ_8471_ = true;

    Type_u *tmp_13369_ = (instanceType);
    {
        succ_8440_ &= (tmp_13369_->tag == 9);
        ParsedModule_s **decl = &tmp_13369_->payload.variant9._0;
        succ_8440_ &= true;
        if (succ_8440_) {
            {
                ModuleLookup_s *modLookup = ((getModuleByGlobalIDPS7791uszrPS0997)((&((this)->lookup)), ((getIDPS1882rusz)((*decl)))));
                bool succ_8445_ = true;
                bool succ_8463_ = true;

                ExprData_u *tmp_13357_ = (&((rhs)->data));
                {
                    succ_8445_ &= (tmp_13357_->tag == 4);
                    IdentExpr_s *ident = &tmp_13357_->payload.variant4._0;
                    succ_8445_ &= true;
                    if (succ_8445_) {
                        {
                            ModuleLookup_s *submodule = (NULL);
                            MLConfig_s config = ((MLConfig_s){.checkSelf = (false), .checkImport = (false), .checkModule = (true), .checkParent = (false)});
                            if ((resolveModuleByNamePS0997PS6070PPS0997S5972rB)((modLookup), (&((*ident).name)), (&(submodule)), (config))) {
                                Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((submodule)->globalID)))}}})));
                                (((rhs)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}}));
                                return ((rhs)->typeState);
                            }

                            VariableLookup_s *var = (NULL);
                            FunctionLookupList_s fun = ((FunctionLookupList_s){0});
                            TypeLookup_s typ = ((TypeLookup_s){0});
                            u32 res = ((resolveIdentifierByNamePS0997PS6070PPS6661PS6177PS8385ru32)((modLookup), (&((*ident).name)), (&(var)), (&(typ)), (&(fun))));
                            if ((res) == (IDENT_TYPE)) {
                                if ((isStructPS6177rB)((&(typ)))) {
                                    return ((reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661)((this), ((lhs)->span), ((*ident).name), (typ)));
                                }

                                else {
                                    Type_u *t = (((asUnionPS6177rPS1592)((&(typ))))->type);
                                    (((rhs)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (t)}}}));
                                    return ((rhs)->typeState);
                                }

                            }

                            else if ((res) == (IDENT_NONE)) {
                                return ((reportUnknownSubmodulePS3900PS0997S6070rU9661)((this), (modLookup), ((*ident).name)));
                            }

                            else if ((res) == (IDENT_FUNC)) {
                                ((assertBPcrN)((((fun).length) != ((usize)(0llu))), ("IDENT_FUNC but fun is empty")));
                                if (((fun).length) == ((usize)(1llu))) {
                                    FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(fun)), ((usize)(0llu))));
                                    ((assertBPcrN)(((isSuccessPU9661rB)((&((f)->fnType)))), ("Did not properly type check function of module")));
                                    TCState_u s = ((f)->fnType);
                                    (((rhs)->typeState) = (s));
                                    (((*ident).type) = ((getTypePU9661rPU5175)((&(s)))));
                                    (((*ident).origID) = ((f)->globalID));
                                    return (s);
                                }

                                else {
                                    ((dropPS8385rN)((&(fun))));
                                    return (((TCState_u){.tag = 4, .payload = {0}}));
                                }

                            }

                            else if ((res) == (IDENT_VAR)) {
                                ((assertBPcrN)(((var) != (NULL)), ("IDENT_VAR but var is null")));
                                ((todo_with_msgPcrN)(("module.var")));
                            }

                            else {
                                ((unreachablePcrN)(("Exhaustive handling of outcomes of resolveIdentifierByName")));
                            }
                        }
                        goto after_13357;
                    }
                }
                {
                    succ_8463_ &= (tmp_13357_->tag == 9);
                    StructExpr_s *init = &tmp_13357_->payload.variant9._0;
                    succ_8463_ &= true;
                    if (succ_8463_) {
                        {
                            TypeLookup_s lookup = ((TypeLookup_s){0});
                            if (!((resolveTypeByNamePS0997PS7720PS6177rB)((modLookup), (&(((*init).name).content)), (&(lookup))))) {
                                return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (modLookup), ((*init).name), ((TypeLookupList_s){0})));
                            }

                            if ((isStructPS6177rB)((&(lookup)))) {
                                (((rhs)->typeState) = ((typeCheckStructInitializationPS3900PS4761S6177PS5541rU9661)((this), (&(*init)), (lookup), (scopes))));
                            }

                            else {
                                ((unreachablePcrN)(("typeCheckExprModuleAccess got non-struct")));
                            }

                            return ((rhs)->typeState);
                        }
                        goto after_13357;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected StructInit or Ident as RHS of module")));
                        }
                        goto after_13357;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13357:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13369;
        }
    }
    {
        succ_8471_ &= (tmp_13369_->tag == 8);
        succ_8471_ &= true;
        succ_8471_ &= true;
        if (succ_8471_) {
            {
                return ((typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661)((this), (expr), (instanceType), (scopes)));
            }
            goto after_13369;
        }
    }
    {
        Type_u **typ = &tmp_13369_;
        if (true) {
            {
                Token_s name = ((Token_s){0});
                bool succ_8478_ = true;

                ExprData_u tmp_13366_ = ((lhs)->data);
                {
                    succ_8478_ &= (tmp_13366_.tag == 4);
                    IdentExpr_s *ident = &tmp_13366_.payload.variant4._0;
                    succ_8478_ &= true;
                    if (succ_8478_) {
                        {
                            ((name) = ((*ident).name));
                        }
                        goto after_13366;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Expected identifier as LHS of Path access")));
                        }
                        goto after_13366;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13366:
                (void)0; // error: label at end of compound statement is a C23 extension
                return ((reportModuleAccessOfNonModulePS3900S8951S6070S6177rU9661)((this), ((lhs)->span), (name), ((TypeLookup_s){0})));
            }
            goto after_13369;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13369:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
TCState_u typeCheckExprUnionInitPS3900PU0121PU5175PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *unionType, ScopeLookupList_s *scopes) {
    ParsedUnionDecl_s *decl = (NULL);
    bool succ_8485_ = true;

    Type_u *tmp_13376_ = (unionType);
    {
        succ_8485_ &= (tmp_13376_->tag == 8);
        ParsedUnionDecl_s **_decl = &tmp_13376_->payload.variant8._0;
        succ_8485_ &= true;
        succ_8485_ &= true;
        if (succ_8485_) {
            {
                ((decl) = (*_decl));
            }
            goto after_13376;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_13376;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13376:
    (void)0; // error: label at end of compound statement is a C23 extension
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    ((assertBPcrN)(((isSuccessPU9661rB)((&((lhs)->typeState)))), ("UnionInit: Expected valid LHS type")));
    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
    ((assertBPcrN)(((isUnionPU5175rB)((lhsType))), ("UnionInit: Expected LHS to be union")));
    ((assertBPcrN)(((equalsPU5175PU5175rB)((lhsType), (unionType))), ("UnionInit: Passed type is not the same union")));
    UnionLookup_s *lookup = ((getUnionByGlobalDeclPS7791PS0997rPS1592)((&((this)->lookup)), (decl)));
    TCState_u result = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}});
    bool succ_8498_ = true;
    bool succ_8504_ = true;

    ExprData_u *tmp_13410_ = (&((rhs)->data));
    {
        succ_8498_ &= (tmp_13410_->tag == 4);
        IdentExpr_s *ident = &tmp_13410_->payload.variant4._0;
        succ_8498_ &= true;
        if (succ_8498_) {
            {
                UnionVariantLookup_s *variant = (NULL);
                if (!((resolveVariantByNamePS1592PS6070PPS2365rB)((lookup), (&((*ident).name)), (&(variant))))) {
                    return ((reportNoSuchVariantPS3900PS1592S6070rU9661)((this), (lookup), ((*ident).name)));
                }

                ((unionType) = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (decl), ._1 = ((variant)->tag)}}}))));
                ((result) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}}));
                (((rhs)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = (((UnionExpr_u){.tag = 2, .payload = {0}}))}}}));
            }
            goto after_13410;
        }
    }
    {
        succ_8504_ &= (tmp_13410_->tag == 9);
        StructExpr_s *init = &tmp_13410_->payload.variant9._0;
        succ_8504_ &= true;
        if (succ_8504_) {
            {
                UnionVariantLookup_s *variant = (NULL);
                if (!((resolveVariantByNamePS1592PS6070PPS2365rB)((lookup), (&((*init).name)), (&(variant))))) {
                    return ((reportNoSuchVariantPS3900PS1592S6070rU9661)((this), (lookup), ((*init).name)));
                }

                bool succ_8511_ = true;

                ParsedUnionVariantData_u tmp_13399_ = (((variant)->global)->data);
                succ_8511_ &= (tmp_13399_.tag == 2);
                ParsedTypeNodeList_s *_fields = &tmp_13399_.payload.variant2._0;
                succ_8511_ &= true;
                TokenList_s *_names = &tmp_13399_.payload.variant2._1;
                succ_8511_ &= true;
                if (!succ_8511_) {
                    return ((reportInvalidVariantInitializerPS3900PS0997PS3506S8951U3836rU9661)((this), (decl), ((variant)->global), ((rhs)->span),
                                                                                                (((ParsedUnionVariantData_u){.tag = 2, .payload = {0}}))));
                };
                ((unionType) = ((wrapU5175rPU5175)(((Type_u){.tag = 8, .payload = {.variant8 = {._0 = (decl), ._1 = ((variant)->tag)}}}))));
                ((result) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (unionType)}}}));
                StructLookup_s structLookup = ((intoStructLookupPS2365rS4228)((variant)));
                TCState_u check = ((typeCheckStructInitializationPS3900PS4761S6177PS5541BrU9661)((this), (&(*init)), ((asTypeLookupPS4228rS6177)((&(structLookup)))), (scopes), (true)));
                if ((isErrorPU9661rB)((&(check))))
                    return (check);
                (((rhs)->data) = ((ExprData_u){.tag = 10, .payload = {.variant10 = {._0 = ((UnionExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (*init)}}})}}}));
            }
            goto after_13410;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Expected StructInit or Ident as RHS")));
            }
            goto after_13410;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13410:
    (void)0; // error: label at end of compound statement is a C23 extension
    (((rhs)->typeState) = (result));
    return (result);
}
TCState_u typeCheckExprMemberAccessPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u instance = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    if ((isErrorPU9661rB)((&(instance))))
        return (instance);
    if ((wantsInferPU9661rB)((&(instance))))
        return (instance);
    Type_u *instanceType = ((getTypePU9661rPU5175)((&(instance))));
    if ((((isVariadicTypePU5175rB)((instanceType))) || ((isArrayPU5175rB)((instanceType)))) || ((isArrayPointerPU5175rB)((instanceType)))) {
        Token_s fieldName = ((Token_s){0});
        bool succ_8528_ = true;
        bool succ_8526_ = true;

        ExprData_u *tmp_13427_ = (&((rhs)->data));
        {
            succ_8528_ &= (tmp_13427_->tag == 4);
            Token_s *ident = &tmp_13427_->payload.variant4._0.name;
            succ_8526_ &= true;
            succ_8526_ &= true;
            succ_8528_ &= succ_8526_;
            if (succ_8528_) {
                {
                    ((fieldName) = (*ident));
                }
                goto after_13427;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier")));
                }
                goto after_13427;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13427:
        (void)0; // error: label at end of compound statement is a C23 extension
        SubStr_s tmp_65911 = (((newSubStrOfStrLitPcrS7720)(("length"))));

        if ((equalsPS7720PS7720rB)((&((fieldName).content)), (&tmp_65911))) {
            Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
            return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (usizeType)}}});
        }

        String_s l = ((toStringPS8951rS0540)((&((rhs)->span))));
        char *s = ("array");
        if ((isVariadicTypePU5175rB)((instanceType)))
            ((s) = ("variadic"));
        (((fprintf))((stderr_), ("%s: %s: Attempted to access unknown field `%.*s` of %s type.\n"), ((l).buffer), (ERR_STR), (((fieldName).content).len), (((fieldName).content).start), (s)));
        ((dropPS0540rN)((&(l))));
        return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNKNOWN_FIELD)}}});
    }

    if ((((!((isStructPU5175rB)((instanceType)))) && (!((isStructPointerPU5175rB)((instanceType))))) && (!((isTuplePU5175rB)((instanceType))))) && (!((isTuplePointerPU5175rB)((instanceType))))) {
        return ((reportMemberAccessOnNonStructNonTuplePS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
    }

    Type_u *underlying = (instanceType);
    if (!((isStructPU5175rB)((underlying))))
        ((underlying) = ((getUnderlyingTypePU5175BrPU5175)((instanceType), (true))));
    if ((isStructPU5175rB)((underlying))) {
        TypeLookup_s lookup = ((getTypeLookupForTypePS7791PU5175rS6177)((&((this)->lookup)), (underlying)));
        ((assertBrN)(((isStructPS6177rB)((&(lookup))))));
        StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
        Token_s fieldName = ((Token_s){0});
        bool succ_8547_ = true;
        bool succ_8545_ = true;
        bool succ_8551_ = true;

        ExprData_u *tmp_13457_ = (&((rhs)->data));
        {
            succ_8547_ &= (tmp_13457_->tag == 4);
            Token_s *ident = &tmp_13457_->payload.variant4._0.name;
            succ_8545_ &= true;
            succ_8545_ &= true;
            succ_8547_ &= succ_8545_;
            if (succ_8547_) {
                {
                    ((fieldName) = (*ident));
                }
                goto after_13457;
            }
        }
        {
            succ_8551_ &= (tmp_13457_->tag == 0);
            succ_8551_ &= true;
            if (succ_8551_) {
                {
                    return ((reportNonIdentAccessOnStructPS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
                }
                goto after_13457;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier or number")));
                }
                goto after_13457;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13457:
        (void)0; // error: label at end of compound statement is a C23 extension
        VariableLookup_s field = ((VariableLookup_s){0});
        if (!((resolveFieldByNamePS4228PS6070PS6661rB)((structLookup), (&(fieldName)), (&(field))))) {
            return ((reportUnknownFieldPS3900S6070PS4228BrU9661)((this), (fieldName), (structLookup), (false)));
        }

        TCState_u fieldState = ((field).typeState);
        ((assertBPcrN)(((isSuccessPU9661rB)((&(fieldState)))), ("Expected valid field type")));
        return (fieldState);
    }

    else if ((isTuplePU5175rB)((underlying))) {
        Token_s tkn = ((Token_s){0});
        bool succ_8562_ = true;
        bool succ_8566_ = true;

        ExprData_u *tmp_13473_ = (&((rhs)->data));
        {
            succ_8562_ &= (tmp_13473_->tag == 4);
            succ_8562_ &= true;
            if (succ_8562_) {
                {
                    return ((reportNonNumberAccessOnTuplePS3900PS2435PU5175rU9661)((this), (lhs), (instanceType)));
                }
                goto after_13473;
            }
        }
        {
            succ_8566_ &= (tmp_13473_->tag == 0);
            Token_s *_tkn = &tmp_13473_->payload.variant0._0;
            succ_8566_ &= true;
            if (succ_8566_) {
                {
                    ((tkn) = (*_tkn));
                }
                goto after_13473;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("Expected RHS to be an identifier or number")));
                }
                goto after_13473;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13473:
        (void)0; // error: label at end of compound statement is a C23 extension
        usize index = ((usize)(((toU64PS7720ru64)((&((tkn).content))))));
        bool succ_8572_ = true;

        Type_u *tmp_13476_ = (underlying);
        succ_8572_ &= (tmp_13476_->tag == 10);
        TypeList_s *elems = &tmp_13476_->payload.variant10._0;
        succ_8572_ &= true;
        if (!succ_8572_) {
            ((unreachablePcrN)(("underlying is tuple")));
        };
        if ((index) >= ((*elems).length)) {
            return ((reportTupleIndexOutOfBoundsPS3900PS2435PU5175uszrU9661)((this), (lhs), (instanceType), (index)));
        }

        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((((*elems).elements))[(index)])}}});
    }

    else {
        ((unreachablePcrN)(("MemberAccess expected Struct or Tuple as LHS")));
    }
}
TCState_u checkIfInferIsNeededPS3900uszPU9661uszPU9661PS5541rU9661(TypeChecker_s *this, usize lhsID, TCState_u *lhsState, usize rhsID, TCState_u *rhsState, ScopeLookupList_s *scopes) {
    ParsedExpr_s *lhsExpr = ((atPS7882uszrPS2435)((&(exprs)), (lhsID)));
    ParsedExpr_s *rhsExpr = ((atPS7882uszrPS2435)((&(exprs)), (rhsID)));
    return ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhsExpr), (lhsState), (rhsExpr), (rhsState), (scopes)));
}
TCState_u checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *lhsExpr, TCState_u *lhsState, ParsedExpr_s *rhsExpr, TCState_u *rhsState,
                                                                         ScopeLookupList_s *scopes) {
    if (((isTypePU9661rB)((lhsState))) && ((isTypePU9661rB)((rhsState)))) {
        return (((TCState_u){.tag = 1, .payload = {0}}));
    }

    else if (((isTypePU9661rB)((lhsState))) && (!((isTypePU9661rB)((rhsState))))) {
        ((*(rhsState)) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (rhsExpr), ((getTypePU9661rPU5175)((lhsState))), (scopes))));
        return (*(rhsState));
    }

    else if ((!((isTypePU9661rB)((lhsState)))) && ((isTypePU9661rB)((rhsState)))) {
        ((*(lhsState)) = ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (lhsExpr), ((getTypePU9661rPU5175)((rhsState))), (scopes))));
        return (*(lhsState));
    }

    else {
        return (((TCState_u){.tag = 4, .payload = {0}}));
    }
}
TCState_u inferPatternOntoExprPS3900PS2435PS1826PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, ParsedPattern_s *pat, ScopeLookupList_s *scopes) {
    bool succ_8579_ = true;
    bool succ_8582_ = true;
    bool succ_8584_ = true;
    bool succ_8587_ = true;
    bool succ_8589_ = true;
    bool succ_8593_ = true;
    bool succ_8598_ = true;
    bool succ_8601_ = true;
    bool succ_8605_ = true;
    bool succ_8609_ = true;

    Pattern_u tmp_13524_ = ((pat)->data);
    {
        succ_8579_ &= (tmp_13524_.tag == 0);
        if (succ_8579_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13524;
        }
    }
    {
        succ_8582_ &= (tmp_13524_.tag == 1);
        succ_8582_ &= true;
        if (succ_8582_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13524;
        }
    }
    {
        succ_8584_ &= (tmp_13524_.tag == 8);
        if (succ_8584_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13524;
        }
    }
    {
        succ_8587_ &= (tmp_13524_.tag == 9);
        succ_8587_ &= true;
        if (succ_8587_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13524;
        }
    }
    {
        succ_8589_ &= (tmp_13524_.tag == 10);
        if (succ_8589_) {
            {
                ((todo_with_msgPcrN)(("inferPatternOntoExpr: Wildcard onto expr? Is this possible?")));
            }
            goto after_13524;
        }
    }
    {
        succ_8593_ &= (tmp_13524_.tag == 3);
        ParsedPattern_s **subpat = &tmp_13524_.payload.variant3._0;
        succ_8593_ &= true;
        ParsedTypeNode_s **typeNode = &tmp_13524_.payload.variant3._1;
        succ_8593_ &= true;
        if (succ_8593_) {
            {
                TCState_u typeState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*typeNode)));
                if ((isErrorPU9661rB)((&(typeState))))
                    return (typeState);
                Type_u *type = ((getTypePU9661rPU5175)((&(typeState))));
                return ((inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661)((this), (expr), (type), (scopes)));
            }
            goto after_13524;
        }
    }
    {
        succ_8598_ &= (tmp_13524_.tag == 2);
        Token_s *name = &tmp_13524_.payload.variant2._0;
        succ_8598_ &= true;
        if (succ_8598_) {
            {
                return (((TCState_u){.tag = 4, .payload = {0}}));
            }
            goto after_13524;
        }
    }
    {
        succ_8601_ &= (tmp_13524_.tag == 4);
        ParsedPattern_s **subpat = &tmp_13524_.payload.variant4._0;
        succ_8601_ &= true;
        if (succ_8601_) {
            {
            }
            goto after_13524;
        }
    }
    {
        succ_8605_ &= (tmp_13524_.tag == 5);
        Token_s *name = &tmp_13524_.payload.variant5._0;
        succ_8605_ &= true;
        ParsedPatternList_s *subpats = &tmp_13524_.payload.variant5._1;
        succ_8605_ &= true;
        if (succ_8605_) {
            {
            }
            goto after_13524;
        }
    }
    {
        succ_8609_ &= (tmp_13524_.tag == 6);
        succ_8609_ &= true;
        ParsedPattern_s **subpat = &tmp_13524_.payload.variant6._1;
        succ_8609_ &= true;
        if (succ_8609_) {
            {
            }
            goto after_13524;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13524;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13524:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((emergencyPrintPS3900S8951rN)((this), ((pat)->span)));
    ((emergencyPrintPS3900S8951rN)((this), ((expr)->span)));
    ((unreachablePcrN)(("inferPatternOntoExpr: Exhaustive handling of patterns")));
}
TCState_u inferTypeOntoExprPS3900uszuszPS5541rU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900uszuszPS5541BrU9661)((this), (exprID), (typeID), (scopes), (false)));
}
TCState_u inferTypeOntoExprPS3900uszPU5175PS5541rU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (type), (scopes), (false)));
}
TCState_u inferTypeOntoExprPS3900PS2435PU5175PS5541rU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (expr), (type), (scopes), (false)));
}
TCState_u tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661(TypeChecker_s *this, usize exprID, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), (type), (scopes), (checkOnly)));
}
TCState_u tryInferTypeOntoExprPS3900uszuszPS5541BrU9661(TypeChecker_s *this, usize exprID, usize typeID, ScopeLookupList_s *scopes, bool checkOnly) {
    return ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((atPS7882uszrPS2435)((&(exprs)), (exprID))), ((atPS4174uszrPU5175)((&(types)), (typeID))), (scopes), (checkOnly)));
}
TCState_u tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661(TypeChecker_s *this, ParsedExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    if ((isSuccessPU9661rB)((&((expr)->typeState)))) {
        Type_u *exprType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
        if (!((equalsPU5175PU5175rB)((exprType), (type))))
            ((todo_with_msgPcrN)(("infer failed")));
        return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
    }

    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8616_ = true;
    bool succ_8635_ = true;
    bool succ_8654_ = true;
    bool succ_8658_ = true;
    bool succ_8662_ = true;
    bool succ_8666_ = true;
    bool succ_8669_ = true;
    bool succ_8676_ = true;
    bool succ_8691_ = true;
    bool succ_8696_ = true;
    bool succ_8702_ = true;

    ExprData_u *tmp_13734_ = (&((expr)->data));
    {
        succ_8616_ &= (tmp_13734_->tag == 0);
        Token_s *value = &tmp_13734_->payload.variant0._0;
        succ_8616_ &= true;
        if (succ_8616_) {
            {
                if ((isCharPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Using integer literal to initialize value of type char.\n"), ((l).buffer), (WARN_STR)));
                        ((dropPS0540rN)((&(l))));
                    }

                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                }

                else if (((isIntegerPU5175rB)((type))) || ((isFloatPU5175rB)((type)))) {
                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                }

                else if ((isPointerPU5175rB)((type))) {
                    ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
                }

                else if ((isBooleanPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected boolean, found `%s`.\n"), ((l).buffer), (ERR_STR), ((s).buffer)));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }

                else if ((isArrayPU5175rB)((type))) {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected array, found `%s`.\n"), ((l).buffer), (ERR_STR), ((s).buffer)));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }

                else {
                    if (!(checkOnly)) {
                        String_s s = ((toStringPS7720rS0540)((&((*value).content))));
                        String_s l = ((getLocationPS6070rS0540)((&(*value))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Unexpected Literal! Expected value of type %s, found `%s`.\n"), ((l).buffer), (ERR_STR), ((t).buffer), ((s).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(l))));
                        ((dropPS0540rN)((&(s))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_UNEXPECTED_LITERAL)}}});
                }
            }
            goto after_13734;
        }
    }
    {
        succ_8635_ &= (tmp_13734_->tag == 3);
        ArrayContext_s *context = &tmp_13734_->payload.variant3._0;
        succ_8635_ &= true;
        if (succ_8635_) {
            {
                bool succ_8640_ = true;

                Type_u *tmp_13633_ = (type);
                {
                    succ_8640_ &= (tmp_13633_->tag == 5);
                    Type_u **under = &tmp_13633_->payload.variant5._0;
                    succ_8640_ &= true;
                    usize *size = &tmp_13633_->payload.variant5._1;
                    succ_8640_ &= true;
                    if (succ_8640_) {
                        {
                            if (((*context).size) == ((usize)(0llu))) {
                                if ((*size) != ((*context).elemLength)) {
                                    if (!(checkOnly)) {
                                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                        (((fprintf))((stderr_), ("%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n"), ((loc).buffer), (ERR_STR), (*size),
                                                     ((*context).elemLength)));
                                        ((dropPS0540rN)((&(loc))));
                                        (((this)->typeError) = (true));
                                    }

                                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ARRAY_SIZE_MISMATCH)}}});
                                }

                                TCState_u lastErrState = (((TCState_u){.tag = 0, .payload = {0}}));
                                for (usize i = ((usize)(0llu)); ((i) < ((*context).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                                    ((tid) = ((tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661)((this), ((getElementAtIndexPS8905uszrusz)((&(*context)), (i))), (*under), (scopes), (checkOnly))));
                                    if ((isErrorPU9661rB)((&(tid))))
                                        ((lastErrState) = (tid));
                                }

                                if (!((isInvalidPU9661rB)((&(lastErrState)))))
                                    return (lastErrState);
                            }

                            else {
                                if ((*size) != ((*context).size)) {
                                    if (!(checkOnly)) {
                                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                        (((fprintf))((stderr_), ("%s: %s: Array size mismatch! Expected to find %llu element(s), got %llu instead.\n"), ((loc).buffer), (ERR_STR), (*size),
                                                     ((*context).size)));
                                        ((dropPS0540rN)((&(loc))));
                                        (((this)->typeError) = (true));
                                    }

                                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_ARRAY_SIZE_MISMATCH)}}});
                                }

                                ((tid) =
                                     ((tryInferTypeOntoExprPS3900uszPU5175PS5541BrU9661)((this), ((getElementAtIndexPS8905uszrusz)((&(*context)), ((usize)(0llu)))), (*under), (scopes), (checkOnly))));
                                if ((isErrorPU9661rB)((&(tid))))
                                    return (tid);
                            }

                            ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                        }
                        goto after_13633;
                    }
                }
                {
                    if (true) {
                        {
                            if (!(checkOnly)) {
                                String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                                String_s t = ((toStringPU5175rS0540)((type)));
                                (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found array literal.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                                ((dropPS0540rN)((&(t))));
                                ((dropPS0540rN)((&(loc))));
                            }

                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                        }
                        goto after_13633;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13633:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13734;
        }
    }
    {
        succ_8654_ &= (tmp_13734_->tag == 4);
        IdentExpr_s *ident = &tmp_13734_->payload.variant4._0;
        succ_8654_ &= true;
        if (succ_8654_) {
            {
                ((tid) = ((tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661)((this), (&(*ident)), (type), (scopes), (checkOnly))));
            }
            goto after_13734;
        }
    }
    {
        succ_8658_ &= (tmp_13734_->tag == 5);
        UnaryExpr_u *unary = &tmp_13734_->payload.variant5._0;
        succ_8658_ &= true;
        if (succ_8658_) {
            {
                ((tid) = ((tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661)((this), ((expr)->span), (&(*unary)), (type), (scopes), (checkOnly))));
            }
            goto after_13734;
        }
    }
    {
        succ_8662_ &= (tmp_13734_->tag == 6);
        BinaryExpr_u *binary = &tmp_13734_->payload.variant6._0;
        succ_8662_ &= true;
        if (succ_8662_) {
            {
                ((tid) = ((tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661)((this), (&(*binary)), (type), (scopes), (checkOnly))));
            }
            goto after_13734;
        }
    }
    {
        succ_8666_ &= (tmp_13734_->tag == 7);
        CallExpr_s *call = &tmp_13734_->payload.variant7._0;
        succ_8666_ &= true;
        if (succ_8666_) {
            {
                ((tid) = ((tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661)((this), (&(*call)), (type), (scopes), (checkOnly))));
            }
            goto after_13734;
        }
    }
    {
        succ_8669_ &= (tmp_13734_->tag == 12);
        if (succ_8669_) {
            {
                if (!((isPointerPU5175rB)((type)))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Can\'t use `null` to initialize value of type %s.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NULL_NON_PTR)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13734;
        }
    }
    {
        succ_8676_ &= (tmp_13734_->tag == 13);
        if (succ_8676_) {
            {
                if ((isPointerPU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Invalid initialization of reference of type %s. Please use `null` instead.\n"), ((loc).buffer), (ERR_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                    (((this)->typeError) = (true));
                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_BLANK_FOR_NULL)}}});
                }

                else if ((isPrimitivePU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Using `blank` to initialize value of type %s. Please use `0` instead.\n"), ((loc).buffer), (WARN_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                }

                else if ((isUnionPU5175rB)((type))) {
                    String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                    String_s name = ((toStringPU5175rS0540)((type)));
                    (((fprintf))((stderr_), ("%s: %s: Using `blank` to initialize value of type %s.\n"), ((loc).buffer), (WARN_STR), ((name).buffer)));
                    ((dropPS0540rN)((&(name))));
                    ((dropPS0540rN)((&(loc))));
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13734;
        }
    }
    {
        succ_8691_ &= (tmp_13734_->tag == 14);
        if (succ_8691_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found `true`.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13734;
        }
    }
    {
        succ_8696_ &= (tmp_13734_->tag == 15);
        if (succ_8696_) {
            {
                if (!((isBooleanPU5175rB)((type)))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found `false`.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13734;
        }
    }
    {
        succ_8702_ &= (tmp_13734_->tag == 20);
        ParsedExprList_s *exprElems = &tmp_13734_->payload.variant20._0;
        succ_8702_ &= true;
        if (succ_8702_) {
            {
                bool succ_8706_ = true;

                Type_u *tmp_13711_ = (type);
                succ_8706_ &= (tmp_13711_->tag == 10);
                TypeList_s *typeElems = &tmp_13711_->payload.variant10._0;
                succ_8706_ &= true;
                if (!succ_8706_) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found tuple.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                };
                if (((*typeElems).length) != ((*exprElems).length)) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                        (((fprintf))((stderr_), ("%s: %s: Expected tuple with %llu elements, found %llu.\n"), ((loc).buffer), (ERR_STR), ((*typeElems).length), ((*exprElems).length)));
                        ((dropPS0540rN)((&(loc))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                for (usize i = ((usize)(0llu)); ((i) < ((*typeElems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedExpr_s *_expr = ((((*exprElems).elements))[(i)]);
                    Type_u *_type = ((((*typeElems).elements))[(i)]);
                    TCState_u state = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (_expr), (_type), (scopes), (checkOnly)));
                    if ((isErrorPU9661rB)((&(state))))
                        return (state);
                }

                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13734;
        }
    }
    {
        ExprData_u **unknown = &tmp_13734_;
        if (true) {
            {
                String_s loc = ((toStringPS8951rS0540)((&((expr)->span))));
                (((fprintf))((stderr_), ("%s %s: tryInferTypeOntoExpr: Unknown tag %hhu!\n"), (FATAL_STR), ((loc).buffer), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_13734;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13734:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (!(checkOnly)) {
        (((*(expr)).typeState) = (tid));
    }

    return (tid);
}
TCState_u tryInferTypeOntoUnaryPS3900S8951PU5427PU5175PS5541BrU9661(TypeChecker_s *this, Span_s span, UnaryExpr_u *unary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8721_ = true;
    bool succ_8727_ = true;
    bool succ_8740_ = true;
    bool succ_8750_ = true;

    UnaryExpr_u *tmp_13790_ = (unary);
    {
        succ_8721_ &= (tmp_13790_->tag == 2);
        ParsedExpr_s **subExpr = &tmp_13790_->payload.variant2._0;
        succ_8721_ &= true;
        if (succ_8721_) {
            {
                Type_u *newType = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (type)}}})));
                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (newType), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13790;
        }
    }
    {
        succ_8727_ &= (tmp_13790_->tag == 1);
        ParsedExpr_s **subExpr = &tmp_13790_->payload.variant1._0;
        succ_8727_ &= true;
        if (succ_8727_) {
            {
                bool succ_8731_ = true;

                Type_u *tmp_13761_ = (type);
                {
                    succ_8731_ &= (tmp_13761_->tag == 4);
                    Type_u **under = &tmp_13761_->payload.variant4._0;
                    succ_8731_ &= true;
                    if (succ_8731_) {
                        {
                            ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (*under), (scopes), (checkOnly))));
                            if ((isErrorPU9661rB)((&(tid))))
                                return (tid);
                            ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
                        }
                        goto after_13761;
                    }
                }
                {
                    if (true) {
                        {
                            if (!(checkOnly)) {
                                String_s loc = ((toStringPS8951rS0540)((&(span))));
                                String_s t = ((toStringPU5175rS0540)((type)));
                                (((fprintf))((stderr_), ("%s: %s: Expected expression of type %s, found reference.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                                ((dropPS0540rN)((&(t))));
                                ((dropPS0540rN)((&(loc))));
                                (((this)->typeError) = (true));
                            }

                            return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                        }
                        goto after_13761;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_13761:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_13790;
        }
    }
    {
        succ_8740_ &= (tmp_13790_->tag == 3);
        ParsedExpr_s **subExpr = &tmp_13790_->payload.variant3._0;
        succ_8740_ &= true;
        if (succ_8740_) {
            {
                if ((!((isSignedIntegerPU5175rB)((type)))) && (!((isFloatPU5175rB)((type))))) {
                    if (!(checkOnly)) {
                        String_s loc = ((toStringPS8951rS0540)((&(span))));
                        String_s t = ((toStringPU5175rS0540)((type)));
                        (((fprintf))((stderr_), ("%s: %s: Negation is not defined for type %s.\n"), ((loc).buffer), (ERR_STR), ((t).buffer)));
                        ((dropPS0540rN)((&(t))));
                        ((dropPS0540rN)((&(loc))));
                        (((this)->typeError) = (true));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }

                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (type), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((assertBPcrN)(((isTypePU9661rB)((&(tid)))), ("infer non-error expected to be a type")));
                Type_u *subType = ((getTypePU9661rPU5175)((&(tid))));
                ((assertBPcrN)(((equalsPU5175PU5175rB)((subType), (type))), ("Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr")));
                ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
            }
            goto after_13790;
        }
    }
    {
        succ_8750_ &= (tmp_13790_->tag == 4);
        ParsedExpr_s **subExpr = &tmp_13790_->payload.variant4._0;
        succ_8750_ &= true;
        if (succ_8750_) {
            {
                Type_u *boolType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})));
                ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*subExpr), (boolType), (scopes), (checkOnly))));
                if ((isErrorPU9661rB)((&(tid))))
                    return (tid);
                ((todo_with_msgPcrN)(("unary not infer")));
            }
            goto after_13790;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of ops in tryInferTypeOntoUnary")));
            }
            goto after_13790;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13790:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (tid);
}
TCState_u tryInferTypeOntoBinaryPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *binary, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((binary), (&(lhs)), (&(rhs))));
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    BinaryExpr_u tmp_67505 = (((BinaryExpr_u){.tag = 1, .payload = {0}}));
    BinaryExpr_u tmp_67525 = (((BinaryExpr_u){.tag = 0, .payload = {0}}));

    if (((isArithmeticPU0121rB)((binary))) || ((isBitwisePU0121rB)((binary)))) {
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), (type), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (rhs), (type), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if ((isComparisonPU0121rB)((binary))) {
        Type_u *usizeType = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})));
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), (usizeType), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (rhs), (usizeType), (scopes), (checkOnly))));
        if ((isErrorPU9661rB)((&(tid))))
            return (tid);
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
    }

    else if (((tagAnyru8)((binary))) == (((tagAnyru8)((&tmp_67505))))) {
        ((tid) = ((tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661)((this), (binary), (type), (scopes), (checkOnly))));
    }

    else if (((tagAnyru8)((binary))) == (((tagAnyru8)((&tmp_67525))))) {
        ((tid) = ((tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661)((this), (binary), (type), (scopes), (checkOnly))));
    }

    else {
        ((todo_with_msgPcrN)(("inferTypeOntoExpr for non-arith non-comp binary")));
    }

    return (tid);
}
TCState_u tryInferTypeOntoIdentPS3900PS7464PU5175PS5541BrU9661(TypeChecker_s *this, IdentExpr_s *ident, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    VariableLookup_s var = ((VariableLookup_s){0});
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    if ((resolveVariableByNamePS0997PS6070PS5541PS6661rB)(((this)->currentModule), (&((ident)->name)), (scopes), (&(var)))) {
        ((unreachablePcrN)(("tryInferTypeOntoIdent: New let-statements prevent variables from ever being unresolved")));
        ((assertBPcrN)(((wantsInferPU9661rB)((&((var).typeState)))), ("Ident has no type, but variable doesn\'t want infer")));
        ((tid) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}}));
        (((var).typeState) = (tid));
        ParsedStmt_s *stmt = ((atPS8227uszrPS1100)((&(stmts)), ((var).globalID)));
        bool succ_8767_ = true;

        StmtData_u tmp_13835_ = ((stmt)->data);
        {
            succ_8767_ &= (tmp_13835_.tag == 0);
            VarDecl_s *decl = &tmp_13835_.payload.variant0._0;
            succ_8767_ &= true;
            if (succ_8767_) {
                {
                    ((tid) = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((*decl).expr), (type), (scopes), (checkOnly))));
                }
                goto after_13835;
            }
        }
        {
            if (true) {
                {
                    ((unreachablePcrN)(("VariableLookup points to non-VarDecl")));
                }
                goto after_13835;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_13835:
        (void)0; // error: label at end of compound statement is a C23 extension
        if ((isErrorPU9661rB)((&(tid)))) {
            String_s loc = ((toStringPS8951rS0540)((&(((ident)->name).span))));
            String_s name = ((toStringPS7720rS0540)((&(((ident)->name).content))));
            String_s typeName = ((toStringPU5175rS0540)((type)));
            (((fprintf))((stderr_), ("%s: %s: Variable `%s` inferred to be of type %s here.\n"), ((loc).buffer), (NOTE_STR), ((name).buffer), ((typeName).buffer)));
            ((dropPS0540rN)((&(typeName))));
            ((dropPS0540rN)((&(name))));
            ((dropPS0540rN)((&(loc))));
        }

        (((stmt)->typeState) = (tid));
    }

    else if ((isFunctionPU5175rB)((type))) {
        MLConfig_s config = ((MLConfig_s){.checkSelf = (true), .checkImport = (true), .checkModule = (false), .checkParent = (true), .allowData = (false)});
        FunctionLookupList_s functions = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)(((this)->currentModule), (&((ident)->name)), (type), (config)));
        if (((functions).length) == ((usize)(0llu))) {
            (((config).allowData) = (true));
            ((functions) = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175S5972rS8385)(((this)->currentModule), (&((ident)->name)), (type), (config))));
            if (((functions).length) == ((usize)(0llu))) {
                if (checkOnly) {
                    ((tid) = ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_FUNCTION)}}}));
                }

                else {
                    FunctionLookupList_s all = ((resolveFunctionByNamePS0997PS6070rS8385)(((this)->currentModule), (&((ident)->name))));
                    ((tid) = ((reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661)((this), ((ident)->name), (type), (&(all)))));
                    ((dropPS8385rN)((&(all))));
                }

            }

            else if (((functions).length) == ((usize)(1llu))) {
                FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
                if (!(checkOnly)) {
                    (((ident)->origID) = ((f)->globalID));
                }

                ((tid) = ((f)->fnType));
            }

            else {
                ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
            }

        }

        else if (((functions).length) == ((usize)(1llu))) {
            FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
            if (!(checkOnly)) {
                (((ident)->origID) = ((f)->globalID));
            }

            ((tid) = ((f)->fnType));
        }

        else {
            ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
        }

        ((dropPS8385rN)((&(functions))));
    }

    else {
        return ((reportUnknownIdentifierPS3900PS6070rU9661)((this), (&((ident)->name))));
    }

    if ((isTypePU9661rB)((&(tid)))) {
        (((ident)->type) = ((getTypePU9661rPU5175)((&(tid)))));
    }

    return (tid);
}
TCState_u tryInferTypeOntoCallPS3900PS3328PU5175PS5541BrU9661(TypeChecker_s *this, CallExpr_s *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    TypeList_s params = ((TypeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        TCState_u *state = (&((*((atPS7823uszrPPS2435)((&((expr)->args)), (i))))->typeState));
        Type_u *typ = ((wrapU5175rPU5175)((((Type_u){.tag = 1, .payload = {0}}))));
        if ((isTypePU9661rB)((state)))
            ((typ) = ((getTypePU9661rPU5175)((state))));
        ((pushPS0643PU5175rN)((&(params)), (typ)));
    }

    Type_u *fnType = ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = (type), ._2 = ((FuncAttr_s){0})}}})));
    TCState_u baseState = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), ((expr)->base), (fnType), (scopes), (checkOnly)));
    if ((isErrorPU9661rB)((&(baseState))))
        return (baseState);
    if ((wantsInferPU9661rB)((&(baseState)))) {
        return ((reportFunctionCallTooManyOptionsPS3900PS3328rU9661)((this), (expr)));
    }

    ((assertBPcrN)(((isTypePU9661rB)((&(baseState)))), ("tryInferOntoCall: Base is not a type")));
    Type_u *baseFunc = ((getTypePU9661rPU5175)((&(baseState))));
    ((assertBPcrN)(((isFunctionPU5175rB)((baseFunc))), ("tryInferTypeOntoCall: Base is not a function")));
    TCState_u state = (((TCState_u){.tag = 1, .payload = {0}}));
    for (usize i = ((usize)(0llu)); ((i) < (((expr)->args).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *p = ((getParamPU5175uszrPU5175)((baseFunc), (i)));
        TCState_u s1 = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (*((atPS7823uszrPPS2435)((&((expr)->args)), (i)))), (p), (scopes), (checkOnly)));
        if ((isErrorPU9661rB)((&(s1)))) {
            ((state) = (s1));
        }
    }

    if (!((isSuccessPU9661rB)((&(state))))) {
        ((todo_with_msgPcrN)(("infer arg failed")));
    }

    if (checkOnly)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    (((expr)->retType) = (type));
    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
}
TCState_u tryInferTypeOntoMemberAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    bool succ_8798_ = true;

    ExprData_u *tmp_13949_ = (&((rhs)->data));
    {
        succ_8798_ &= (tmp_13949_->tag == 4);
        IdentExpr_s *ident = &tmp_13949_->payload.variant4._0;
        succ_8798_ &= true;
        if (succ_8798_) {
            {
                Token_s name = ((*ident).name);
                StructLookupList_s structs = ((resolveAllStructsWithFieldPS0997PS6070PU5175rS7392)(((this)->currentModule), (&(name)), (type)));
                if (((structs).length) == ((usize)(0llu))) {
                    return ((reportMemberAccessNoOptionsPS3900S8951rU9661)((this), ((lhs)->span)));
                }

                else if (((structs).length) == ((usize)(1llu))) {
                    StructLookup_s *struct_ = ((atPS7392uszrPS4228)((&(structs)), ((usize)(0llu))));
                    TCState_u state = ((tryInferTypeOntoExprPS3900PS2435PU5175PS5541BrU9661)((this), (lhs), ((struct_)->type), (scopes), (checkOnly)));
                    if ((isErrorPU9661rB)((&(state))))
                        return (state);
                    if (checkOnly)
                        return (((TCState_u){.tag = 1, .payload = {0}}));
                    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (type)}}});
                }

                else {
                    if (!(checkOnly)) {
                        return ((reportMemberAccessTooManyOptionsPS3900S8951PS7392rU9661)((this), ((lhs)->span), (&(structs))));
                    }

                    return ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_TYPE_MISMATCH)}}});
                }
            }
            goto after_13949;
        }
    }
    {
        if (true) {
            {
            }
            goto after_13949;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13949:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of possibilities in tryInferTypeOntoMemberAccess")));
}
TCState_u tryInferTypeOntoPathAccessPS3900PU0121PU5175PS5541BrU9661(TypeChecker_s *this, BinaryExpr_u *expr, Type_u *type, ScopeLookupList_s *scopes, bool checkOnly) {
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((lhs)->typeState);
    if (!((isSuccessPU9661rB)((&(lhsState)))))
        return (lhsState);
    if (!((isTypePU9661rB)((&(lhsState)))))
        return (lhsState);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    ModuleLookup_s *lookup = (NULL);
    bool succ_8815_ = true;

    Type_u *tmp_13965_ = (lhsType);
    {
        succ_8815_ &= (tmp_13965_->tag == 9);
        ParsedModule_s **decl = &tmp_13965_->payload.variant9._0;
        succ_8815_ &= true;
        if (succ_8815_) {
            {
                ((lookup) = ((getModuleByGlobalIDPS0997uszrPS0997)(((this)->currentModule), ((getIDPS1882rusz)((*decl))))));
            }
            goto after_13965;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("LHS of BIN_MODULE is not of type module!")));
            }
            goto after_13965;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13965:
    (void)0; // error: label at end of compound statement is a C23 extension
    TCState_u tid = (((TCState_u){.tag = 0, .payload = {0}}));
    bool succ_8821_ = true;

    ExprData_u *tmp_13995_ = (&((rhs)->data));
    {
        succ_8821_ &= (tmp_13995_->tag == 4);
        IdentExpr_s *ident = &tmp_13995_->payload.variant4._0;
        succ_8821_ &= true;
        if (succ_8821_) {
            {
                ((assertBPcrN)(((isFunctionPU5175rB)((type))), ("Can only try to infer functions onto module identifiers for now")));
                FunctionLookupList_s functions = ((resolveAllFunctionsWithSignaturePS0997PS6070PU5175rS8385)((lookup), (&((*ident).name)), (type)));
                if (((functions).length) == ((usize)(0llu))) {
                    if (checkOnly) {
                        ((tid) = ((TCState_u){.tag = 2, .payload = {.variant2 = {._0 = (ERROR_NO_SUCH_FUNCTION)}}}));
                    }

                    else {
                        FunctionLookupList_s all = ((resolveFunctionByNamePS0997PS6070rS8385)((lookup), (&((*ident).name))));
                        ((tid) = ((reportNoFunctionCallCandidatePS3900S6070PU5175PS8385rU9661)((this), ((*ident).name), (type), (&(all)))));
                        ((dropPS8385rN)((&(all))));
                    }

                }

                else if (((functions).length) == ((usize)(1llu))) {
                    FunctionLookup_s *f = ((atPS8385uszrPS0677)((&(functions)), ((usize)(0llu))));
                    if (!(checkOnly)) {
                        (((*ident).origID) = ((f)->globalID));
                    }

                    ((tid) = ((f)->fnType));
                }

                else {
                    ((tid) = (((TCState_u){.tag = 4, .payload = {0}})));
                }

                (((rhs)->typeState) = (tid));
                if ((isTypePU9661rB)((&(tid)))) {
                    (((*ident).type) = ((getTypePU9661rPU5175)((&(tid)))));
                }

                ((dropPS8385rN)((&(functions))));
            }
            goto after_13995;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of possibilities in tryInferTypeOntoModuleAccess")));
            }
            goto after_13995;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_13995:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (tid);
}
TCState_u typeCheckExprArithmeticPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ((assertBPcrN)(((isArithmeticPU0121rB)((expr))), ("Expr expected to be arithmetic")));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    bool lhsPointer = (false);
    bool rhsPointer = (false);
    if ((isTypePU9661rB)((&(lhsState))))
        if ((isPointerPU5175rB)(((getTypePU9661rPU5175)((&(lhsState))))))
            ((lhsPointer) = (true));
    if ((isTypePU9661rB)((&(rhsState))))
        if ((isPointerPU5175rB)(((getTypePU9661rPU5175)((&(rhsState))))))
            ((rhsPointer) = (true));
    if ((lhsPointer) || (rhsPointer)) {
        bool succ_8841_ = true;
        bool succ_8845_ = true;

        BinaryExpr_u *tmp_14019_ = (expr);
        {
            succ_8841_ &= (tmp_14019_->tag == 3);
            succ_8841_ &= true;
            if (succ_8841_) {
                {
                }
                goto after_14019;
            }
        }
        {
            succ_8845_ &= (tmp_14019_->tag == 4);
            succ_8845_ &= true;
            if (succ_8845_) {
                {
                }
                goto after_14019;
            }
        }
        {
            BinaryExpr_u **other = &tmp_14019_;
            if (true) {
                {
                    return ((reportInvalidPointerArithmeticsPS3900PcS8951S8951rU9661)((this), ((binOpAsStrPU0121rPc)((*other))), ((lhs)->span), ((rhs)->span)));
                }
                goto after_14019;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14019:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    TCState_u resultState = (((TCState_u){.tag = 0, .payload = {0}}));
    if ((equalsPU5175PU5175rB)((lhsType), (rhsType))) {
        BinaryExpr_u tmp_68335 = (((BinaryExpr_u){.tag = 3, .payload = {0}}));

        u8 p = ((tagAnyru8)((&tmp_68335)));
        BinaryExpr_u tmp_68341 = (((BinaryExpr_u){.tag = 4, .payload = {0}}));

        u8 s = ((tagAnyru8)((&tmp_68341)));
        if ((((isCharPU5175rB)((lhsType))) && (((tagAnyru8)((expr))) != (p))) && (((tagAnyru8)((expr))) != (s))) {
            return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
        }

        if (((isStructPU5175rB)((lhsType))) || ((isArrayPU5175rB)((lhsType)))) {
            return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
        }

        else if ((isPointerPU5175rB)((lhsType))) {
            ((resultState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 8}))}}})))}}}));
        }

        else {
            ((resultState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (lhsType)}}}));
        }

    }

    else if (((isPointerPU5175rB)((lhsType))) && ((isIntegerPU5175rB)((rhsType)))) {
        bool succ_8860_ = true;
        bool succ_8858_ = true;

        Type_u *tmp_14052_ = (rhsType);
        {
            succ_8860_ &= (tmp_14052_->tag == 3);
            succ_8858_ &= (tmp_14052_->payload.variant3._0.tag == 8);
            succ_8860_ &= succ_8858_;
            if (succ_8860_) {
                {
                    ((resultState) = (lhsState));
                }
                goto after_14052;
            }
        }
        {
            if (true) {
                {
                    TCState_u err = ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
                    String_s loc = ((toStringPS8951rS0540)((&((rhs)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Pointer offsets must be of type usize.\n"), ((loc).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(loc))));
                    return (err);
                }
                goto after_14052;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14052:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else if (((isIntegerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
        bool succ_8868_ = true;
        bool succ_8866_ = true;

        Type_u *tmp_14062_ = (lhsType);
        {
            succ_8868_ &= (tmp_14062_->tag == 3);
            succ_8866_ &= (tmp_14062_->payload.variant3._0.tag == 8);
            succ_8868_ &= succ_8866_;
            if (succ_8868_) {
                {
                    ((resultState) = (rhsState));
                }
                goto after_14062;
            }
        }
        {
            if (true) {
                {
                    TCState_u err = ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
                    String_s loc = ((toStringPS8951rS0540)((&((lhs)->span))));
                    (((fprintf))((stderr_), ("%s: %s: Pointer offsets must be of type usize.\n"), ((loc).buffer), (NOTE_STR)));
                    ((dropPS0540rN)((&(loc))));
                    return (err);
                }
                goto after_14062;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14062:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    else {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    return (resultState);
}
TCState_u typeCheckExprComparisonPS3900PU0121PS5541rU9661(TypeChecker_s *this, BinaryExpr_u *expr, ScopeLookupList_s *scopes) {
    ((assertBPcrN)(((isComparisonPU0121rB)((expr))), ("Expr expected to be comparison")));
    ParsedExpr_s *lhs = (NULL);
    ParsedExpr_s *rhs = (NULL);
    ((extractOperandsPU0121PPS2435PPS2435rN)((expr), (&(lhs)), (&(rhs))));
    TCState_u lhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (lhs), (scopes)));
    TCState_u rhsState = ((typeCheckExprPS3900PS2435PS5541rU9661)((this), (rhs), (scopes)));
    if ((isErrorPU9661rB)((&(lhsState))))
        return (lhsState);
    if ((isErrorPU9661rB)((&(rhsState))))
        return (rhsState);
    TCState_u maybeInfer = ((checkIfInferIsNeededPS3900PS2435PU9661PS2435PU9661PS5541rU9661)((this), (lhs), (&(lhsState)), (rhs), (&(rhsState)), (scopes)));
    if ((isErrorPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    if ((wantsInferPU9661rB)((&(maybeInfer))))
        return (maybeInfer);
    Type_u *lhsType = ((getTypePU9661rPU5175)((&(lhsState))));
    Type_u *rhsType = ((getTypePU9661rPU5175)((&(rhsState))));
    if (!((equalsPU5175PU5175rB)((lhsType), (rhsType)))) {
        return ((reportBinaryTypeMismatchPS3900PcS8951PU5175S8951PU5175rU9661)((this), ((binOpAsStrPU0121rPc)((expr))), ((lhs)->span), (lhsType), ((rhs)->span), (rhsType)));
    }

    if (((((isStructPU5175rB)((lhsType))) || ((isStructPU5175rB)((rhsType)))) || ((isArrayPU5175rB)((lhsType)))) || ((isArrayPU5175rB)((rhsType)))) {
        ((todo_with_msgPcrN)(("report error, can\'t compare structs or arrays using == or similar.")));
    }

    return ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (((PrimType_u){.tag = 10}))}}})))}}});
}
TCState_u typeCheckTypeNodePS3900PS1372rU9661(TypeChecker_s *this, ParsedTypeNode_s *typeNode) {
    if ((typeNode)->ignored)
        return (((TCState_u){.tag = 1, .payload = {0}}));
    if ((isSuccessPU9661rB)((&((typeNode)->typeState))))
        return ((typeNode)->typeState);
    Type_u *tid = (NULL);
    if (((typeNode)->kind) == (PARSED_TYPE_FUNC)) {
        TCState_u retState = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(retState))))
            return (retState);
        TypeList_s params = ((TypeList_s){0});
        TCState_u error = (((TCState_u){.tag = 0, .payload = {0}}));
        bool is_variadic = (false);
        for (usize i = ((usize)(0llu)); ((i) < (((typeNode)->fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
            TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*((atPS6760uszrPPS1372)((&((typeNode)->fnParams)), (i))))));
            if ((isErrorPU9661rB)((&(state)))) {
                ((error) = (state));
            }

            else {
                Type_u *typ = ((getTypePU9661rPU5175)((&(state))));
                if ((isVariadicPU5175rB)((typ)))
                    ((is_variadic) = (true));
                ((pushPS0643PU5175rN)((&(params)), (typ)));
            }
        }

        if ((isErrorPU9661rB)((&(error))))
            return (error);
        ((tid) =
             ((wrapU5175rPU5175)(((Type_u){.tag = 6, .payload = {.variant6 = {._0 = (params), ._1 = ((getTypePU9661rPU5175)((&(retState)))), ._2 = ((FuncAttr_s){.isVariadic = (is_variadic)})}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_REF)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = ((getTypePU9661rPU5175)((&(under))))}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_ARRAY)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = ((getTypePU9661rPU5175)((&(under)))), ._1 = ((typeNode)->arraySize)}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_IDENT)) {
        Token_s name = ((typeNode)->nameTkn);
        TypeLookup_s typeLookup = ((TypeLookup_s){0});
        if (!((resolveTypeByNamePS0997PS7720PS6177rB)(((this)->currentModule), (&((name).content)), (&(typeLookup))))) {
            String_s loc = ((getLocationPS6070rS0540)((&(name))));
            String_s _n = ((toStringPS7720rS0540)((&((name).content))));
            (((fprintf))((stderr_), ("%s: %s: Use of undeclared type identifier `%s`.\n"), ((loc).buffer), (ERR_STR), ((_n).buffer)));
            TypeLookupList_s alternatives = ((searchAllFilesForTypeNamePS7791PS7720rS1581)((&((this)->lookup)), (&((name).content))));
            return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (NULL), (name), (alternatives)));
        }

        if ((isStructPS6177rB)((&(typeLookup)))) {
            StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(typeLookup))));
            ((tid) = ((structLookup)->type));
            ((assertBPcrN)(((isStructPU5175rB)((tid))), ("Struct Lookup links to non-Struct typeNode")));
        }

        else if ((isUnionPS6177rB)((&(typeLookup)))) {
            UnionLookup_s *unionLookup = ((asUnionPS6177rPS1592)((&(typeLookup))));
            ((tid) = ((unionLookup)->type));
            ((assertBPcrN)(((isUnionPU5175rB)((tid))), ("Union Lookup links to non-Union typeNode")));
        }

        else {
            ((unreachablePcrN)(("Exhaustive handling of TypeLookup kinds in typeCheckTypeNode")));
        }

    }

    else if (((typeNode)->kind) == (PARSED_TYPE_MODULE)) {
        ParsedTypeNode_s *_orig = (typeNode);
        ModuleLookup_s *moduleLookup = (NULL);
        Token_s name = ((typeNode)->nameTkn);
        if (!((resolveModuleByNamePS0997PS6070PPS0997rB)(((this)->currentModule), (&(name)), (&(moduleLookup))))) {
            return ((reportUnknownModulePS3900S6070rU9661)((this), (name)));
        }

        while (true) {
            ParsedTypeNode_s *sub = ((typeNode)->underlyingID);
            if (((sub)->underlyingID) == (NULL)) {
                TypeLookup_s lookup = ((TypeLookup_s){0});
                if (!((resolveTypeByNamePS0997PS7720PS6177rB)((moduleLookup), (&(((sub)->nameTkn).content)), (&(lookup))))) {
                    return ((reportUnknownTypePS3900PS0997S6070S1581rU9661)((this), (moduleLookup), ((sub)->nameTkn), ((TypeLookupList_s){0})));
                }

                if ((isStructPS6177rB)((&(lookup)))) {
                    StructLookup_s *structLookup = ((asStructPS6177rPS4228)((&(lookup))));
                    ((tid) = ((structLookup)->type));
                    ((assertBPcrN)(((isStructPU5175rB)((tid))), ("Struct Lookup links to non-Struct typeNode")));
                    break;
                }

                else if ((isUnionPS6177rB)((&(lookup)))) {
                    UnionLookup_s *unionLookup = ((asUnionPS6177rPS1592)((&(lookup))));
                    ((tid) = ((unionLookup)->type));
                    ((assertBPcrN)(((isUnionPU5175rB)((tid))), ("Union Lookup links to non-Union typeNode")));
                    break;
                }

                else {
                    ((todo_with_msgPcrN)(("module::<typeNode> with typeNode != struct && != union")));
                }

            }

            else {
                ((name) = ((sub)->nameTkn));
                ModuleLookup_s *newModule = (NULL);
                if (!((resolveModuleByNamePS0997PS6070PPS0997rB)((moduleLookup), (&(name)), (&(newModule))))) {
                    return ((reportUnknownSubmodulePS3900PS0997S6070rU9661)((this), (moduleLookup), (name)));
                }

                Type_u *modType = ((wrapU5175rPU5175)(((Type_u){.tag = 9, .payload = {.variant9 = {._0 = ((atPS7393uszrPS1882)((&(modules)), ((newModule)->globalID)))}}})));
                (((typeNode)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (modType)}}}));
                ((typeNode) = (sub));
                ((moduleLookup) = (newModule));
            }
        }

        ((typeNode) = (_orig));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_VARIADIC)) {
        TCState_u under = ((typeCheckTypeNodePS3900PS1372rU9661)((this), ((typeNode)->underlyingID)));
        if ((isErrorPU9661rB)((&(under))))
            return (under);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 2, .payload = {.variant2 = {._0 = ((getTypePU9661rPU5175)((&(under))))}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_TUPLE)) {
        TypeList_s elems = ((TypeList_s){0});
        TCState_u error = (((TCState_u){.tag = 0, .payload = {0}}));
        for (usize i = ((usize)(0llu)); ((i) < (((typeNode)->fnParams).length)); ((i) = ((i) + ((usize)(1llu))))) {
            TCState_u state = ((typeCheckTypeNodePS3900PS1372rU9661)((this), (*((atPS6760uszrPPS1372)((&((typeNode)->fnParams)), (i))))));
            if ((isErrorPU9661rB)((&(state)))) {
                ((error) = (state));
            }

            else {
                ((pushPS0643PU5175rN)((&(elems)), ((getTypePU9661rPU5175)((&(state))))));
            }
        }

        if ((isErrorPU9661rB)((&(error))))
            return (error);
        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 10, .payload = {.variant10 = {._0 = (elems)}}}))));
    }

    else if (((typeNode)->kind) == (PARSED_TYPE_BUILTIN)) {
        usize id = ((getIDPS1372rusz)((typeNode)));
        PrimType_u prim = (((PrimType_u){.tag = 11}));
        if ((id) == (PARSED_TYPE_NONE))
            ((prim) = (((PrimType_u){.tag = 11})));
        else if ((id) == (PARSED_TYPE_ANY))
            ((prim) = (((PrimType_u){.tag = 9})));
        else if ((id) == (PARSED_TYPE_I8))
            ((prim) = (((PrimType_u){.tag = 4})));
        else if ((id) == (PARSED_TYPE_I16))
            ((prim) = (((PrimType_u){.tag = 5})));
        else if ((id) == (PARSED_TYPE_I32))
            ((prim) = (((PrimType_u){.tag = 6})));
        else if ((id) == (PARSED_TYPE_I64))
            ((prim) = (((PrimType_u){.tag = 7})));
        else if ((id) == (PARSED_TYPE_U8))
            ((prim) = (((PrimType_u){.tag = 0})));
        else if ((id) == (PARSED_TYPE_U16))
            ((prim) = (((PrimType_u){.tag = 1})));
        else if ((id) == (PARSED_TYPE_U32))
            ((prim) = (((PrimType_u){.tag = 2})));
        else if ((id) == (PARSED_TYPE_U64))
            ((prim) = (((PrimType_u){.tag = 3})));
        else if ((id) == (PARSED_TYPE_USIZE))
            ((prim) = (((PrimType_u){.tag = 8})));
        else if ((id) == (PARSED_TYPE_BOOL))
            ((prim) = (((PrimType_u){.tag = 10})));
        else if ((id) == (PARSED_TYPE_CHAR))
            ((prim) = (((PrimType_u){.tag = 12})));
        else if ((id) == (PARSED_TYPE_F32))
            ((prim) = (((PrimType_u){.tag = 13})));
        else if ((id) == (PARSED_TYPE_F64))
            ((prim) = (((PrimType_u){.tag = 14})));
        else {
            ((unreachablePcrN)(("Exhaustive handling of parsed types in typeCheckTypeNode")));
        }

        ((tid) = ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (prim)}}}))));
    }

    else {
        ((todo_with_msgPcrN)(("unknown typeNode kind")));
    }

    TCState_u state = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (tid)}}});
    (((typeNode)->typeState) = (state));
    return (state);
}
TypeChecker_s newTypeCheckerrS3900(none) {
    return ((TypeChecker_s){.comptimeDepth = ((usize)(0llu)), .currentModule = (NULL), .currentFunction = (NULL), .lookup = ((Lookup_s){0}), .typeError = (false)});
}
none addElementPS8905PS2435rN(ArrayContext_s *this, ParsedExpr_s *elem) {
    if (((this)->elemLength) >= ((this)->elemCapacity)) {
        usize newCap = (((this)->elemCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->elemList) = (((realloc))(((this)->elemList), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elemList) != (NULL)), ("Could not resize elem list")));
        (((this)->elemCapacity) = (newCap));
    }

    (((((this)->elemList))[((this)->elemLength)]) = ((getIDPS2435rusz)((elem))));
    (((this)->elemLength) = (((this)->elemLength) + ((usize)(1llu))));
}
usize getElementAtIndexPS8905uszrusz(ArrayContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->elemLength)), ("Out of bounds access in ArrayContext.getElementAtIndex")));
    return ((((this)->elemList))[(index)]);
}
none addFieldPS7871S6070PS1372rN(StructContext_s *this, Token_s name, ParsedTypeNode_s *typ) {
    if (((this)->fieldLength) >= ((this)->fieldCapacity)) {
        usize newCap = (((this)->fieldCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->fieldNames) = (((realloc))(((this)->fieldNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->fieldTypes) = (((realloc))(((this)->fieldTypes), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->fieldNames) != (NULL)), ("Could not resize field list")));
        ((assertBPcrN)((((this)->fieldTypes) != (NULL)), ("Could not resize field list")));
        (((this)->fieldCapacity) = (newCap));
    }

    (((((this)->fieldNames))[((this)->fieldLength)]) = (name));
    (((((this)->fieldTypes))[((this)->fieldLength)]) = (typ));
    (((this)->fieldLength) = (((this)->fieldLength) + ((usize)(1llu))));
}
Token_s getFieldNameAtIndexPS7871uszrS6070(StructContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructContext.getFieldNameAtIndex")));
    return ((((this)->fieldNames))[(index)]);
}
ParsedTypeNode_s *getFieldTypeAtIndexPS7871uszrPS1372(StructContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructContext.getFieldTypeAtIndex")));
    return ((((this)->fieldTypes))[(index)]);
}
usize getFieldIndexPS7871PS7720rusz(StructContext_s *this, SubStr_s *name) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s f = ((getFieldNameAtIndexPS7871uszrS6070)((this), (i)));
        if ((equalsPS7720PS7720rB)((&((f).content)), (name))) {
            return (i);
        }
    }

    ((unreachablePcrN)(("Expected to find field index at this point")));
}
usize getFieldOffsetPS7871PS7720rusz(StructContext_s *this, SubStr_s *name) {
    usize offset = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s f = ((getFieldNameAtIndexPS7871uszrS6070)((this), (i)));
        ParsedTypeNode_s *_t = ((getFieldTypeAtIndexPS7871uszrPS1372)((this), (i)));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((_t)->typeState)))), ("Expected valid field type in getFieldOffset")));
        Type_u *t = ((getTypePU9661rPU5175)((&((_t)->typeState))));
        if ((equalsPS7720PS7720rB)((&((f).content)), (name))) {
            return (offset);
        }

        ((offset) = ((offset) + ((getSizeInBytesPU5175rusz)((t)))));
    }

    ((unreachablePcrN)(("Expected to find field offset at this point")));
}
none addFieldPS6291S6070PS2435rN(StructInitContext_s *this, Token_s name, ParsedExpr_s *expr) {
    if (((this)->fieldLength) >= ((this)->fieldCapacity)) {
        usize newCap = (((this)->fieldCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->fieldNames) = (((realloc))(((this)->fieldNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->fieldExprs) = (((realloc))(((this)->fieldExprs), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->fieldNames) != (NULL)), ("Could not resize field list")));
        ((assertBPcrN)((((this)->fieldExprs) != (NULL)), ("Could not resize field list")));
        (((this)->fieldCapacity) = (newCap));
    }

    (((((this)->fieldNames))[((this)->fieldLength)]) = (name));
    (((((this)->fieldExprs))[((this)->fieldLength)]) = (expr));
    (((this)->fieldLength) = (((this)->fieldLength) + ((usize)(1llu))));
}
Token_s getFieldNameAtIndexPS6291uszrS6070(StructInitContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructInitContext.getFieldNameAtIndex")));
    return ((((this)->fieldNames))[(index)]);
}
ParsedExpr_s *getFieldExprAtIndexPS6291uszrPS2435(StructInitContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->fieldLength)), ("Out of bounds access in StructInitContext.getFieldExprAtIndex")));
    return ((((this)->fieldExprs))[(index)]);
}
none addParameterPS9803S6070PS1372rN(ParamContext_s *this, Token_s name, ParsedTypeNode_s *typ) {
    if (((this)->paramLength) >= ((this)->paramCapacity)) {
        usize newCap = (((this)->paramCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->paramNames) = (((realloc))(((this)->paramNames), ((newCap) * (sizeof(Token_s))))));
        (((this)->paramTypes) = (((realloc))(((this)->paramTypes), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->paramNames) != (NULL)), ("Could not resize param list")));
        ((assertBPcrN)((((this)->paramTypes) != (NULL)), ("Could not resize param list")));
        (((this)->paramCapacity) = (newCap));
    }

    (((((this)->paramNames))[((this)->paramLength)]) = (name));
    (((((this)->paramTypes))[((this)->paramLength)]) = (typ));
    (((this)->paramLength) = (((this)->paramLength) + ((usize)(1llu))));
}
bool hasThisPS9803rB(ParamContext_s *this) {
    if (((this)->paramLength) == ((usize)(0llu)))
        return (false);
    SubStr_s tmp_69803 = (((getNameAtIndexPS9803uszrS6070)((this), ((usize)(0llu)))).content);
    SubStr_s tmp_69808 = (((BUILD_A_KEYWORDPcrS7720)(("this"))));

    return ((equalsPS7720PS7720rB)((&tmp_69803), (&tmp_69808)));
}
Token_s getNameAtIndexPS9803uszrS6070(ParamContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->paramLength)), ("Out of bounds access in ParamContext.getNameAtIndex")));
    return ((((this)->paramNames))[(index)]);
}
ParsedTypeNode_s *getTypeAtIndexPS9803uszrPS1372(ParamContext_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->paramLength)), ("Out of bounds access in ParamContext.getTypeAtIndex")));
    return ((((this)->paramTypes))[(index)]);
}
usize nextMultipleOfuszuszrusz(usize a, usize b) {
    ((assertBPcrN)(((b) != ((usize)(0llu))), ("nextMultipleOf: b is 0!")));
    if (((a) % (b)) == ((usize)(0llu)))
        return (a);
    return ((a) + ((b) - ((a) % (b))));
}
usize index_of_typePS3131PU5175rusz(TypeInfoTable_s *table, Type_u *type) {
    String_s n = ((toStringPU5175rS0540)((type)));
    for (usize i = ((usize)(0llu)); ((i) < ((table)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        SubStr_s tmp_69882 = ((get_namePU7843rS7720)((&((((table)->elements))[(i)]))));
        SubStr_s tmp_69887 = ((asSubStrPS0540rS7720)((&(n))));

        bool b = ((equalsPS7720PS7720rB)((&tmp_69882), (&tmp_69887)));
        if (b) {
            ((dropPS0540rN)((&(n))));
            return (i);
        }
    }

    ((dropPS0540rN)((&(n))));
    return ((table)->length);
}
bool containsInvalidTypePU5175rB(Type_u *this) {
    bool succ_8980_ = true;
    bool succ_8983_ = true;
    bool succ_8987_ = true;
    bool succ_8991_ = true;
    bool succ_8995_ = true;
    bool succ_9000_ = true;
    bool succ_9006_ = true;
    bool succ_9012_ = true;
    bool succ_9017_ = true;
    bool succ_9021_ = true;
    bool succ_9025_ = true;

    Type_u *tmp_14403_ = (this);
    {
        succ_8980_ &= (tmp_14403_->tag == 0);
        if (succ_8980_) {
            {
                return (true);
            }
            goto after_14403;
        }
    }
    {
        succ_8983_ &= (tmp_14403_->tag == 1);
        if (succ_8983_) {
            {
                return (true);
            }
            goto after_14403;
        }
    }
    {
        succ_8987_ &= (tmp_14403_->tag == 2);
        Type_u **under = &tmp_14403_->payload.variant2._0;
        succ_8987_ &= true;
        if (succ_8987_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14403;
        }
    }
    {
        succ_8991_ &= (tmp_14403_->tag == 3);
        succ_8991_ &= true;
        if (succ_8991_) {
            {
                return (false);
            }
            goto after_14403;
        }
    }
    {
        succ_8995_ &= (tmp_14403_->tag == 4);
        Type_u **under = &tmp_14403_->payload.variant4._0;
        succ_8995_ &= true;
        if (succ_8995_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14403;
        }
    }
    {
        succ_9000_ &= (tmp_14403_->tag == 5);
        Type_u **under = &tmp_14403_->payload.variant5._0;
        succ_9000_ &= true;
        succ_9000_ &= true;
        if (succ_9000_) {
            {
                return ((containsInvalidTypePU5175rB)((*under)));
            }
            goto after_14403;
        }
    }
    {
        succ_9006_ &= (tmp_14403_->tag == 6);
        TypeList_s *params = &tmp_14403_->payload.variant6._0;
        succ_9006_ &= true;
        Type_u **ret = &tmp_14403_->payload.variant6._1;
        succ_9006_ &= true;
        succ_9006_ &= true;
        if (succ_9006_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((containsInvalidTypePU5175rB)(((((*params).elements))[(i)])))
                        return (true);
                }

                return ((containsInvalidTypePU5175rB)((*ret)));
            }
            goto after_14403;
        }
    }
    {
        succ_9012_ &= (tmp_14403_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14403_->payload.variant7._0;
        succ_9012_ &= true;
        if (succ_9012_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14403;
        }
    }
    {
        succ_9017_ &= (tmp_14403_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14403_->payload.variant8._0;
        succ_9017_ &= true;
        succ_9017_ &= true;
        if (succ_9017_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14403;
        }
    }
    {
        succ_9021_ &= (tmp_14403_->tag == 9);
        ParsedModule_s **decl = &tmp_14403_->payload.variant9._0;
        succ_9021_ &= true;
        if (succ_9021_) {
            {
                return ((*decl) == (NULL));
            }
            goto after_14403;
        }
    }
    {
        succ_9025_ &= (tmp_14403_->tag == 10);
        TypeList_s *elems = &tmp_14403_->payload.variant10._0;
        succ_9025_ &= true;
        if (succ_9025_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((containsInvalidTypePU5175rB)(((((*elems).elements))[(i)])))
                        return (true);
                }

                return (false);
            }
            goto after_14403;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14403;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14403:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("containsInvalidType")));
}
String_s getMangledNamePU5175rS0540(Type_u *this) {
    bool succ_9032_ = true;
    bool succ_9067_ = true;
    bool succ_9075_ = true;
    bool succ_9084_ = true;
    bool succ_9093_ = true;
    bool succ_9104_ = true;
    bool succ_9111_ = true;
    bool succ_9118_ = true;

    Type_u *tmp_14506_ = (this);
    {
        succ_9032_ &= (tmp_14506_->tag == 3);
        PrimType_u *typ = &tmp_14506_->payload.variant3._0;
        succ_9032_ &= true;
        if (succ_9032_) {
            {
                bool succ_9035_ = true;
                bool succ_9037_ = true;
                bool succ_9039_ = true;
                bool succ_9041_ = true;
                bool succ_9043_ = true;
                bool succ_9045_ = true;
                bool succ_9047_ = true;
                bool succ_9049_ = true;
                bool succ_9051_ = true;
                bool succ_9053_ = true;
                bool succ_9055_ = true;
                bool succ_9057_ = true;
                bool succ_9059_ = true;
                bool succ_9061_ = true;
                bool succ_9063_ = true;

                PrimType_u tmp_14437_ = (*typ);
                {
                    succ_9035_ &= (tmp_14437_.tag == 0);
                    if (succ_9035_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u8")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9037_ &= (tmp_14437_.tag == 1);
                    if (succ_9037_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u16")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9039_ &= (tmp_14437_.tag == 2);
                    if (succ_9039_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u32")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9041_ &= (tmp_14437_.tag == 3);
                    if (succ_9041_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u64")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9043_ &= (tmp_14437_.tag == 4);
                    if (succ_9043_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i8")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9045_ &= (tmp_14437_.tag == 5);
                    if (succ_9045_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i16")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9047_ &= (tmp_14437_.tag == 6);
                    if (succ_9047_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i32")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9049_ &= (tmp_14437_.tag == 7);
                    if (succ_9049_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i64")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9051_ &= (tmp_14437_.tag == 8);
                    if (succ_9051_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("usz")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9053_ &= (tmp_14437_.tag == 9);
                    if (succ_9053_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("Any")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9055_ &= (tmp_14437_.tag == 10);
                    if (succ_9055_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("B")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9057_ &= (tmp_14437_.tag == 11);
                    if (succ_9057_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("N")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9059_ &= (tmp_14437_.tag == 12);
                    if (succ_9059_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("c")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9061_ &= (tmp_14437_.tag == 13);
                    if (succ_9061_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f32")));
                        }
                        goto after_14437;
                    }
                }
                {
                    succ_9063_ &= (tmp_14437_.tag == 14);
                    if (succ_9063_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f64")));
                        }
                        goto after_14437;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in getMangledName")));
                        }
                        goto after_14437;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14437:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14506;
        }
    }
    {
        succ_9067_ &= (tmp_14506_->tag == 4);
        Type_u **typ = &tmp_14506_->payload.variant4._0;
        succ_9067_ &= true;
        if (succ_9067_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("P")));
                String_s _s = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9075_ &= (tmp_14506_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14506_->payload.variant7._0;
        succ_9075_ &= true;
        if (succ_9075_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("S")));
                usize hash = ((hashPS7720uszrusz)((&(((*decl)->name).content)), ((usize)(4llu))));
                if ((hash) < ((usize)(10llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(100llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(1000llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                ((pushNumberPS0540uszrN)((&(s)), (hash)));
                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9084_ &= (tmp_14506_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14506_->payload.variant8._0;
        succ_9084_ &= true;
        succ_9084_ &= true;
        if (succ_9084_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("U")));
                usize hash = ((hashPS7720uszrusz)((&(((*decl)->name).content)), ((usize)(4llu))));
                if ((hash) < ((usize)(10llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(100llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                if ((hash) < ((usize)(1000llu)))
                    ((pushNumberPS0540uszrN)((&(s)), ((usize)(((usize)(0llu))))));
                ((pushNumberPS0540uszrN)((&(s)), (hash)));
                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9093_ &= (tmp_14506_->tag == 6);
        TypeList_s *params = &tmp_14506_->payload.variant6._0;
        succ_9093_ &= true;
        Type_u **ret = &tmp_14506_->payload.variant6._1;
        succ_9093_ &= true;
        succ_9093_ &= true;
        if (succ_9093_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("F")));
                String_s r = ((getMangledNamePU5175rS0540)((*ret)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((i) != (((*params).length) - ((usize)(1llu))))
                        ((pushCharPS0540crN)((&(s)), ('.')));
                    String_s p = ((getMangledNamePU5175rS0540)((*((atPS0643uszrPPU5175)((&(*params)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(p))));
                    ((dropPS0540rN)((&(p))));
                }

                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9104_ &= (tmp_14506_->tag == 5);
        Type_u **typ = &tmp_14506_->payload.variant5._0;
        succ_9104_ &= true;
        usize *size = &tmp_14506_->payload.variant5._1;
        succ_9104_ &= true;
        if (succ_9104_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("A")));
                String_s r = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                ((pushNumberPS0540uszrN)((&(s)), (*size)));
                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9111_ &= (tmp_14506_->tag == 2);
        Type_u **typ = &tmp_14506_->payload.variant2._0;
        succ_9111_ &= true;
        if (succ_9111_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("V")));
                String_s r = ((getMangledNamePU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                ((dropPS0540rN)((&(r))));
                return (s);
            }
            goto after_14506;
        }
    }
    {
        succ_9118_ &= (tmp_14506_->tag == 10);
        TypeList_s *elems = &tmp_14506_->payload.variant10._0;
        succ_9118_ &= true;
        if (succ_9118_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("T")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    if ((i) != (((*elems).length) - ((usize)(1llu))))
                        ((pushCharPS0540crN)((&(s)), ('.')));
                    String_s e = ((getMangledNamePU5175rS0540)((*((atPS0643uszrPPU5175)((&(*elems)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(e))));
                    ((dropPS0540rN)((&(e))));
                }

                return (s);
            }
            goto after_14506;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14506;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14506:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of types in Type.getMangledName")));
}
usize getIDPU5175rusz(Type_u *this) { return ((indexOfPS4174PU5175rusz)((&(types)), (this))); }
bool equalsPU5175PU5175rB(Type_u *this, Type_u *other) { return ((_equalsPU5175PU5175BrB)((this), (other), (true))); }
bool _equalsPU5175PU5175BrB(Type_u *this, Type_u *other, bool allowData) {
    if (allowData) {
        bool succ_9128_ = true;

        Type_u *tmp_14514_ = (this);
        {
            succ_9128_ &= (tmp_14514_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_14514_->payload.variant7._0;
            succ_9128_ &= true;
            if (succ_9128_) {
                {
                    if ((*decl)->isDataDefinition)
                        return (true);
                }
                goto after_14514;
            }
        }
        {
            if (true) {
                {
                }
                goto after_14514;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14514:
        (void)0; // error: label at end of compound statement is a C23 extension
        bool succ_9133_ = true;

        Type_u *tmp_14519_ = (other);
        {
            succ_9133_ &= (tmp_14519_->tag == 7);
            ParsedStructDecl_s **decl = &tmp_14519_->payload.variant7._0;
            succ_9133_ &= true;
            if (succ_9133_) {
                {
                    if ((*decl)->isDataDefinition)
                        return (true);
                }
                goto after_14519;
            }
        }
        {
            if (true) {
                {
                }
                goto after_14519;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14519:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    bool succ_9137_ = true;

    Type_u *tmp_14525_ = (this);
    {
        succ_9137_ &= (tmp_14525_->tag == 0);
        if (succ_9137_) {
            {
                return (true);
            }
            goto after_14525;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14525;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14525:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9141_ = true;

    Type_u *tmp_14529_ = (other);
    {
        succ_9141_ &= (tmp_14529_->tag == 0);
        if (succ_9141_) {
            {
                return (true);
            }
            goto after_14529;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14529;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14529:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9146_ = true;
    bool succ_9161_ = true;
    bool succ_9159_ = true;
    bool succ_9175_ = true;

    Type_u *tmp_14551_ = (this);
    {
        succ_9146_ &= (tmp_14551_->tag == 4);
        Type_u **typ = &tmp_14551_->payload.variant4._0;
        succ_9146_ &= true;
        if (succ_9146_) {
            {
                bool succ_9151_ = true;
                bool succ_9149_ = true;
                bool succ_9155_ = true;

                Type_u *tmp_14536_ = (other);
                {
                    succ_9151_ &= (tmp_14536_->tag == 3);
                    succ_9149_ &= (tmp_14536_->payload.variant3._0.tag == 9);
                    succ_9151_ &= succ_9149_;
                    if (succ_9151_) {
                        {
                            return (true);
                        }
                        goto after_14536;
                    }
                }
                {
                    succ_9155_ &= (tmp_14536_->tag == 4);
                    Type_u **otyp = &tmp_14536_->payload.variant4._0;
                    succ_9155_ &= true;
                    if (succ_9155_) {
                        {
                            return ((equalsPU5175PU5175rB)((*typ), (*otyp)));
                        }
                        goto after_14536;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14536;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14536:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14551;
        }
    }
    {
        succ_9161_ &= (tmp_14551_->tag == 3);
        succ_9159_ &= (tmp_14551_->payload.variant3._0.tag == 9);
        succ_9161_ &= succ_9159_;
        if (succ_9161_) {
            {
                bool succ_9165_ = true;
                bool succ_9170_ = true;
                bool succ_9168_ = true;

                Type_u *tmp_14543_ = (other);
                {
                    succ_9165_ &= (tmp_14543_->tag == 4);
                    succ_9165_ &= true;
                    if (succ_9165_) {
                        {
                            return (true);
                        }
                        goto after_14543;
                    }
                }
                {
                    succ_9170_ &= (tmp_14543_->tag == 3);
                    succ_9168_ &= (tmp_14543_->payload.variant3._0.tag == 9);
                    succ_9170_ &= succ_9168_;
                    if (succ_9170_) {
                        {
                            return (true);
                        }
                        goto after_14543;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_14543;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14543:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14551;
        }
    }
    {
        succ_9175_ &= (tmp_14551_->tag == 3);
        PrimType_u *t = &tmp_14551_->payload.variant3._0;
        succ_9175_ &= true;
        if (succ_9175_) {
            {
                bool succ_9179_ = true;

                Type_u *tmp_14548_ = (other);
                {
                    succ_9179_ &= (tmp_14548_->tag == 3);
                    PrimType_u *o = &tmp_14548_->payload.variant3._0;
                    succ_9179_ &= true;
                    if (succ_9179_) {
                        {
                            return (((tagAnyru8)((&(*t)))) == ((tagAnyru8)((&(*o)))));
                        }
                        goto after_14548;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_14548;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14548:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14551;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14551;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14551:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (((tagAnyru8)((this))) != ((tagAnyru8)((other))))
        return (false);
    bool succ_9185_ = true;

    Type_u *tmp_14561_ = (this);
    {
        succ_9185_ &= (tmp_14561_->tag == 2);
        Type_u **typ1 = &tmp_14561_->payload.variant2._0;
        succ_9185_ &= true;
        if (succ_9185_) {
            {
                bool succ_9189_ = true;

                Type_u *tmp_14558_ = (other);
                {
                    succ_9189_ &= (tmp_14558_->tag == 2);
                    Type_u **typ2 = &tmp_14558_->payload.variant2._0;
                    succ_9189_ &= true;
                    if (succ_9189_) {
                        {
                            return ((equalsPU5175PU5175rB)((*typ1), (*typ2)));
                        }
                        goto after_14558;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14558;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14558:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14561;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14561;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14561:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9196_ = true;

    Type_u *tmp_14569_ = (this);
    {
        succ_9196_ &= (tmp_14569_->tag == 5);
        Type_u **typ1 = &tmp_14569_->payload.variant5._0;
        succ_9196_ &= true;
        usize *size1 = &tmp_14569_->payload.variant5._1;
        succ_9196_ &= true;
        if (succ_9196_) {
            {
                bool succ_9201_ = true;

                Type_u *tmp_14566_ = (other);
                {
                    succ_9201_ &= (tmp_14566_->tag == 5);
                    Type_u **typ2 = &tmp_14566_->payload.variant5._0;
                    succ_9201_ &= true;
                    usize *size2 = &tmp_14566_->payload.variant5._1;
                    succ_9201_ &= true;
                    if (succ_9201_) {
                        {
                            return (((*size1) == (*size2)) && ((equalsPU5175PU5175rB)((*typ1), (*typ2))));
                        }
                        goto after_14566;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14566;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14566:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14569;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14569;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14569:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9209_ = true;

    Type_u *tmp_14592_ = (this);
    {
        succ_9209_ &= (tmp_14592_->tag == 6);
        TypeList_s *params = &tmp_14592_->payload.variant6._0;
        succ_9209_ &= true;
        Type_u **ret = &tmp_14592_->payload.variant6._1;
        succ_9209_ &= true;
        FuncAttr_s *attr = &tmp_14592_->payload.variant6._2;
        succ_9209_ &= true;
        if (succ_9209_) {
            {
                bool succ_9215_ = true;

                Type_u *tmp_14589_ = (other);
                {
                    succ_9215_ &= (tmp_14589_->tag == 6);
                    TypeList_s *oparams = &tmp_14589_->payload.variant6._0;
                    succ_9215_ &= true;
                    Type_u **oret = &tmp_14589_->payload.variant6._1;
                    succ_9215_ &= true;
                    FuncAttr_s *oattr = &tmp_14589_->payload.variant6._2;
                    succ_9215_ &= true;
                    if (succ_9215_) {
                        {
                            if (((*attr).isVariadic) != ((*oattr).isVariadic))
                                return (false);
                            if (((*attr).isNoreturn) != ((*oattr).isNoreturn))
                                return (false);
                            if (((*params).length) != ((*oparams).length))
                                return (false);
                            if (!((equalsPU5175PU5175rB)((*ret), (*oret))))
                                return (false);
                            for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                Type_u *p1 = (*((atPS0643uszrPPU5175)((&(*params)), (i))));
                                Type_u *p2 = (*((atPS0643uszrPPU5175)((&(*oparams)), (i))));
                                if (!((equalsPU5175PU5175rB)((p1), (p2))))
                                    return (false);
                            }

                            return (true);
                        }
                        goto after_14589;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14589;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14589:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14592;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14592;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14592:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9225_ = true;

    Type_u *tmp_14609_ = (this);
    {
        succ_9225_ &= (tmp_14609_->tag == 10);
        TypeList_s *elems = &tmp_14609_->payload.variant10._0;
        succ_9225_ &= true;
        if (succ_9225_) {
            {
                bool succ_9229_ = true;

                Type_u *tmp_14606_ = (other);
                {
                    succ_9229_ &= (tmp_14606_->tag == 10);
                    TypeList_s *oelems = &tmp_14606_->payload.variant10._0;
                    succ_9229_ &= true;
                    if (succ_9229_) {
                        {
                            if (((*elems).length) != ((*oelems).length))
                                return (false);
                            for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                                Type_u *e1 = (*((atPS0643uszrPPU5175)((&(*elems)), (i))));
                                Type_u *e2 = (*((atPS0643uszrPPU5175)((&(*oelems)), (i))));
                                if (!((equalsPU5175PU5175rB)((e1), (e2))))
                                    return (false);
                            }

                            return (true);
                        }
                        goto after_14606;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14606;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14606:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14609;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14609;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14609:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9239_ = true;

    Type_u *tmp_14617_ = (this);
    {
        succ_9239_ &= (tmp_14617_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14617_->payload.variant7._0;
        succ_9239_ &= true;
        if (succ_9239_) {
            {
                bool succ_9243_ = true;

                Type_u *tmp_14614_ = (other);
                {
                    succ_9243_ &= (tmp_14614_->tag == 7);
                    ParsedStructDecl_s **odecl = &tmp_14614_->payload.variant7._0;
                    succ_9243_ &= true;
                    if (succ_9243_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14614;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14614;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14614:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14617;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14617;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14617:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9250_ = true;

    Type_u *tmp_14625_ = (this);
    {
        succ_9250_ &= (tmp_14625_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14625_->payload.variant8._0;
        succ_9250_ &= true;
        succ_9250_ &= true;
        if (succ_9250_) {
            {
                bool succ_9255_ = true;

                Type_u *tmp_14622_ = (other);
                {
                    succ_9255_ &= (tmp_14622_->tag == 8);
                    ParsedUnionDecl_s **odecl = &tmp_14622_->payload.variant8._0;
                    succ_9255_ &= true;
                    succ_9255_ &= true;
                    if (succ_9255_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14622;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14622;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14622:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14625;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14625;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14625:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool succ_9261_ = true;

    Type_u *tmp_14633_ = (this);
    {
        succ_9261_ &= (tmp_14633_->tag == 9);
        ParsedModule_s **decl = &tmp_14633_->payload.variant9._0;
        succ_9261_ &= true;
        if (succ_9261_) {
            {
                bool succ_9265_ = true;

                Type_u *tmp_14630_ = (other);
                {
                    succ_9265_ &= (tmp_14630_->tag == 9);
                    ParsedModule_s **odecl = &tmp_14630_->payload.variant9._0;
                    succ_9265_ &= true;
                    if (succ_9265_) {
                        {
                            return ((*decl) == (*odecl));
                        }
                        goto after_14630;
                    }
                }
                {
                    if (true) {
                        {
                            return (false);
                        }
                        goto after_14630;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14630:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14633;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14633;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14633:
    (void)0; // error: label at end of compound statement is a C23 extension
    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((this))).buffer)));
    (((fprintf))((stderr_), ("%s\n"), (((toStringPU5175rS0540)((other))).buffer)));
    ((unreachablePcrN)(("&Type.equals() should\'ve caught all combinations by this point!")));
}
bool isUnknownPU5175rB(Type_u *this) {
    Type_u tmp_70499 = (((Type_u){.tag = 1, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70499)))));
}
bool isFloatPU5175rB(Type_u *this) {
    bool succ_9272_ = true;
    bool succ_9270_ = true;
    bool succ_9277_ = true;
    bool succ_9275_ = true;

    Type_u *tmp_14643_ = (this);
    {
        succ_9272_ &= (tmp_14643_->tag == 3);
        succ_9270_ &= (tmp_14643_->payload.variant3._0.tag == 13);
        succ_9272_ &= succ_9270_;
        if (succ_9272_) {
            {
                return (true);
            }
            goto after_14643;
        }
    }
    {
        succ_9277_ &= (tmp_14643_->tag == 3);
        succ_9275_ &= (tmp_14643_->payload.variant3._0.tag == 14);
        succ_9277_ &= succ_9275_;
        if (succ_9277_) {
            {
                return (true);
            }
            goto after_14643;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14643;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14643:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isIntegerPU5175rB(Type_u *this) { return (((isSignedIntegerPU5175rB)((this))) || ((isUnsignedIntegerPU5175rB)((this)))); }
bool isSignedIntegerPU5175rB(Type_u *this) {
    bool succ_9283_ = true;
    bool succ_9281_ = true;
    bool succ_9288_ = true;
    bool succ_9286_ = true;
    bool succ_9293_ = true;
    bool succ_9291_ = true;
    bool succ_9298_ = true;
    bool succ_9296_ = true;

    Type_u *tmp_14655_ = (this);
    {
        succ_9283_ &= (tmp_14655_->tag == 3);
        succ_9281_ &= (tmp_14655_->payload.variant3._0.tag == 4);
        succ_9283_ &= succ_9281_;
        if (succ_9283_) {
            {
                return (true);
            }
            goto after_14655;
        }
    }
    {
        succ_9288_ &= (tmp_14655_->tag == 3);
        succ_9286_ &= (tmp_14655_->payload.variant3._0.tag == 5);
        succ_9288_ &= succ_9286_;
        if (succ_9288_) {
            {
                return (true);
            }
            goto after_14655;
        }
    }
    {
        succ_9293_ &= (tmp_14655_->tag == 3);
        succ_9291_ &= (tmp_14655_->payload.variant3._0.tag == 6);
        succ_9293_ &= succ_9291_;
        if (succ_9293_) {
            {
                return (true);
            }
            goto after_14655;
        }
    }
    {
        succ_9298_ &= (tmp_14655_->tag == 3);
        succ_9296_ &= (tmp_14655_->payload.variant3._0.tag == 7);
        succ_9298_ &= succ_9296_;
        if (succ_9298_) {
            {
                return (true);
            }
            goto after_14655;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14655;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14655:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isUnsignedIntegerPU5175rB(Type_u *this) {
    bool succ_9304_ = true;
    bool succ_9302_ = true;
    bool succ_9309_ = true;
    bool succ_9307_ = true;
    bool succ_9314_ = true;
    bool succ_9312_ = true;
    bool succ_9319_ = true;
    bool succ_9317_ = true;
    bool succ_9324_ = true;
    bool succ_9322_ = true;

    Type_u *tmp_14668_ = (this);
    {
        succ_9304_ &= (tmp_14668_->tag == 3);
        succ_9302_ &= (tmp_14668_->payload.variant3._0.tag == 0);
        succ_9304_ &= succ_9302_;
        if (succ_9304_) {
            {
                return (true);
            }
            goto after_14668;
        }
    }
    {
        succ_9309_ &= (tmp_14668_->tag == 3);
        succ_9307_ &= (tmp_14668_->payload.variant3._0.tag == 1);
        succ_9309_ &= succ_9307_;
        if (succ_9309_) {
            {
                return (true);
            }
            goto after_14668;
        }
    }
    {
        succ_9314_ &= (tmp_14668_->tag == 3);
        succ_9312_ &= (tmp_14668_->payload.variant3._0.tag == 2);
        succ_9314_ &= succ_9312_;
        if (succ_9314_) {
            {
                return (true);
            }
            goto after_14668;
        }
    }
    {
        succ_9319_ &= (tmp_14668_->tag == 3);
        succ_9317_ &= (tmp_14668_->payload.variant3._0.tag == 3);
        succ_9319_ &= succ_9317_;
        if (succ_9319_) {
            {
                return (true);
            }
            goto after_14668;
        }
    }
    {
        succ_9324_ &= (tmp_14668_->tag == 3);
        succ_9322_ &= (tmp_14668_->payload.variant3._0.tag == 8);
        succ_9324_ &= succ_9322_;
        if (succ_9324_) {
            {
                return (true);
            }
            goto after_14668;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14668;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14668:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isVariadicTypePU5175rB(Type_u *this) {
    bool succ_9329_ = true;

    Type_u *tmp_14673_ = (this);
    {
        succ_9329_ &= (tmp_14673_->tag == 2);
        succ_9329_ &= true;
        if (succ_9329_) {
            {
                return (true);
            }
            goto after_14673;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14673;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14673:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isCharPU5175rB(Type_u *this) {
    bool succ_9335_ = true;
    bool succ_9333_ = true;

    Type_u *tmp_14678_ = (this);
    {
        succ_9335_ &= (tmp_14678_->tag == 3);
        succ_9333_ &= (tmp_14678_->payload.variant3._0.tag == 12);
        succ_9335_ &= succ_9333_;
        if (succ_9335_) {
            {
                return (true);
            }
            goto after_14678;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14678;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14678:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBooleanPU5175rB(Type_u *this) {
    bool succ_9341_ = true;
    bool succ_9339_ = true;

    Type_u *tmp_14683_ = (this);
    {
        succ_9341_ &= (tmp_14683_->tag == 3);
        succ_9339_ &= (tmp_14683_->payload.variant3._0.tag == 10);
        succ_9341_ &= succ_9339_;
        if (succ_9341_) {
            {
                return (true);
            }
            goto after_14683;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14683;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14683:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isNonePU5175rB(Type_u *this) {
    bool succ_9347_ = true;
    bool succ_9345_ = true;

    Type_u *tmp_14688_ = (this);
    {
        succ_9347_ &= (tmp_14688_->tag == 3);
        succ_9345_ &= (tmp_14688_->payload.variant3._0.tag == 11);
        succ_9347_ &= succ_9345_;
        if (succ_9347_) {
            {
                return (true);
            }
            goto after_14688;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14688;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14688:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isAnyPU5175rB(Type_u *this) {
    bool succ_9353_ = true;
    bool succ_9351_ = true;

    Type_u *tmp_14693_ = (this);
    {
        succ_9353_ &= (tmp_14693_->tag == 3);
        succ_9351_ &= (tmp_14693_->payload.variant3._0.tag == 9);
        succ_9353_ &= succ_9351_;
        if (succ_9353_) {
            {
                return (true);
            }
            goto after_14693;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14693;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14693:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isDataPU5175rB(Type_u *this) {
    bool succ_9358_ = true;

    Type_u *tmp_14698_ = (this);
    {
        succ_9358_ &= (tmp_14698_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14698_->payload.variant7._0;
        succ_9358_ &= true;
        if (succ_9358_) {
            {
                return ((*decl)->isDataDefinition);
            }
            goto after_14698;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14698;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14698:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isPrimitivePU5175rB(Type_u *this) {
    Type_u tmp_70554 = (((Type_u){.tag = 3, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70554)))));
}
bool isFunctionPU5175rB(Type_u *this) {
    Type_u tmp_70565 = (((Type_u){.tag = 6, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70565)))));
}
bool isVariadicPU5175rB(Type_u *this) {
    bool succ_9365_ = true;

    Type_u *tmp_14705_ = (this);
    {
        succ_9365_ &= (tmp_14705_->tag == 6);
        succ_9365_ &= true;
        succ_9365_ &= true;
        FuncAttr_s *attr = &tmp_14705_->payload.variant6._2;
        succ_9365_ &= true;
        if (succ_9365_) {
            {
                return ((*attr).isVariadic);
            }
            goto after_14705;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14705;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14705:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isNoreturnPU5175rB(Type_u *this) {
    bool succ_9372_ = true;

    Type_u *tmp_14710_ = (this);
    {
        succ_9372_ &= (tmp_14710_->tag == 6);
        succ_9372_ &= true;
        succ_9372_ &= true;
        FuncAttr_s *attr = &tmp_14710_->payload.variant6._2;
        succ_9372_ &= true;
        if (succ_9372_) {
            {
                return ((*attr).isNoreturn);
            }
            goto after_14710;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14710;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14710:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isPointerPU5175rB(Type_u *this) {
    bool succ_9377_ = true;
    bool succ_9382_ = true;
    bool succ_9380_ = true;

    Type_u *tmp_14717_ = (this);
    {
        succ_9377_ &= (tmp_14717_->tag == 4);
        succ_9377_ &= true;
        if (succ_9377_) {
            {
                return (true);
            }
            goto after_14717;
        }
    }
    {
        succ_9382_ &= (tmp_14717_->tag == 3);
        succ_9380_ &= (tmp_14717_->payload.variant3._0.tag == 9);
        succ_9382_ &= succ_9380_;
        if (succ_9382_) {
            {
                return (true);
            }
            goto after_14717;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14717;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14717:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isStructPointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isStructPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isTuplePointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isTuplePU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isArrayPointerPU5175rB(Type_u *this) {
    if (!((isPointerPU5175rB)((this))))
        return (false);
    return ((isArrayPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
bool isPointerToPU5175PU5175rB(Type_u *this, Type_u *typ) {
    bool succ_9387_ = true;

    Type_u *tmp_14731_ = (this);
    {
        succ_9387_ &= (tmp_14731_->tag == 4);
        Type_u **to = &tmp_14731_->payload.variant4._0;
        succ_9387_ &= true;
        if (succ_9387_) {
            {
                return ((equalsPU5175PU5175rB)((*to), (typ)));
            }
            goto after_14731;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14731;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14731:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isModulePU5175rB(Type_u *this) {
    Type_u tmp_70629 = (((Type_u){.tag = 9, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70629)))));
}
bool isStructPU5175rB(Type_u *this) {
    Type_u tmp_70640 = (((Type_u){.tag = 7, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70640)))));
}
bool isUnionPU5175rB(Type_u *this) {
    Type_u tmp_70651 = (((Type_u){.tag = 8, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70651)))));
}
bool isArrayPU5175rB(Type_u *this) {
    Type_u tmp_70662 = (((Type_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70662)))));
}
bool isTuplePU5175rB(Type_u *this) {
    Type_u tmp_70673 = (((Type_u){.tag = 10, .payload = {0}}));

    return (((tagAnyru8)((this))) == (((tagAnyru8)((&tmp_70673)))));
}
bool isStructArrayPU5175rB(Type_u *this) {
    if (!((isArrayPU5175rB)((this))))
        return (false);
    return ((isStructPU5175rB)(((getUnderlyingTypePU5175BrPU5175)((this), (false)))));
}
Type_u *getUnderlyingTypePU5175BrPU5175(Type_u *this, bool deep) {
    Type_u *underlying = (this);
    while ((((isVariadicTypePU5175rB)((this))) || ((isPointerPU5175rB)((this)))) || ((isArrayPU5175rB)((this)))) {
        bool succ_9393_ = true;
        bool succ_9398_ = true;
        bool succ_9402_ = true;

        Type_u *tmp_14750_ = (underlying);
        {
            succ_9393_ &= (tmp_14750_->tag == 4);
            Type_u **under = &tmp_14750_->payload.variant4._0;
            succ_9393_ &= true;
            if (succ_9393_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14750;
            }
        }
        {
            succ_9398_ &= (tmp_14750_->tag == 5);
            Type_u **under = &tmp_14750_->payload.variant5._0;
            succ_9398_ &= true;
            succ_9398_ &= true;
            if (succ_9398_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14750;
            }
        }
        {
            succ_9402_ &= (tmp_14750_->tag == 2);
            Type_u **under = &tmp_14750_->payload.variant2._0;
            succ_9402_ &= true;
            if (succ_9402_) {
                {
                    ((underlying) = (*under));
                }
                goto after_14750;
            }
        }
        {
            if (true) {
                {
                    break;
                }
                goto after_14750;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_14750:
        (void)0; // error: label at end of compound statement is a C23 extension
        if (!(deep))
            break;
    }

    return (underlying);
}
String_s toStringPU5175rS0540(Type_u *this) {
    bool succ_9406_ = true;
    bool succ_9409_ = true;
    bool succ_9413_ = true;
    bool succ_9448_ = true;
    bool succ_9456_ = true;
    bool succ_9461_ = true;
    bool succ_9465_ = true;
    bool succ_9471_ = true;
    bool succ_9483_ = true;
    bool succ_9491_ = true;
    bool succ_9499_ = true;

    Type_u *tmp_14862_ = (this);
    {
        succ_9406_ &= (tmp_14862_->tag == 0);
        if (succ_9406_) {
            {
                return ((newStringFromStrLitPcrS0540)(("<propagated error>")));
            }
            goto after_14862;
        }
    }
    {
        succ_9409_ &= (tmp_14862_->tag == 1);
        if (succ_9409_) {
            {
                return ((newStringFromStrLitPcrS0540)(("<unknown>")));
            }
            goto after_14862;
        }
    }
    {
        succ_9413_ &= (tmp_14862_->tag == 3);
        PrimType_u *typ = &tmp_14862_->payload.variant3._0;
        succ_9413_ &= true;
        if (succ_9413_) {
            {
                bool succ_9416_ = true;
                bool succ_9418_ = true;
                bool succ_9420_ = true;
                bool succ_9422_ = true;
                bool succ_9424_ = true;
                bool succ_9426_ = true;
                bool succ_9428_ = true;
                bool succ_9430_ = true;
                bool succ_9432_ = true;
                bool succ_9434_ = true;
                bool succ_9436_ = true;
                bool succ_9438_ = true;
                bool succ_9440_ = true;
                bool succ_9442_ = true;
                bool succ_9444_ = true;

                PrimType_u tmp_14792_ = (*typ);
                {
                    succ_9416_ &= (tmp_14792_.tag == 0);
                    if (succ_9416_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u8")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9418_ &= (tmp_14792_.tag == 1);
                    if (succ_9418_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u16")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9420_ &= (tmp_14792_.tag == 2);
                    if (succ_9420_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u32")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9422_ &= (tmp_14792_.tag == 3);
                    if (succ_9422_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("u64")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9424_ &= (tmp_14792_.tag == 4);
                    if (succ_9424_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i8")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9426_ &= (tmp_14792_.tag == 5);
                    if (succ_9426_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i16")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9428_ &= (tmp_14792_.tag == 6);
                    if (succ_9428_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i32")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9430_ &= (tmp_14792_.tag == 7);
                    if (succ_9430_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("i64")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9432_ &= (tmp_14792_.tag == 8);
                    if (succ_9432_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("usize")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9434_ &= (tmp_14792_.tag == 9);
                    if (succ_9434_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("Any")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9436_ &= (tmp_14792_.tag == 10);
                    if (succ_9436_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("bool")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9438_ &= (tmp_14792_.tag == 11);
                    if (succ_9438_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("none")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9440_ &= (tmp_14792_.tag == 12);
                    if (succ_9440_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("char")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9442_ &= (tmp_14792_.tag == 13);
                    if (succ_9442_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f32")));
                        }
                        goto after_14792;
                    }
                }
                {
                    succ_9444_ &= (tmp_14792_.tag == 14);
                    if (succ_9444_) {
                        {
                            return ((newStringFromStrLitPcrS0540)(("f64")));
                        }
                        goto after_14792;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in toString")));
                        }
                        goto after_14792;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14792:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14862;
        }
    }
    {
        succ_9448_ &= (tmp_14862_->tag == 4);
        Type_u **sub = &tmp_14862_->payload.variant4._0;
        succ_9448_ &= true;
        if (succ_9448_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("&")));
                String_s _s = ((toStringPU5175rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_14862;
        }
    }
    {
        succ_9456_ &= (tmp_14862_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14862_->payload.variant7._0;
        succ_9456_ &= true;
        if (succ_9456_) {
            {
                return ((getFullNamePS5521rS0540)((*decl)));
            }
            goto after_14862;
        }
    }
    {
        succ_9461_ &= (tmp_14862_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14862_->payload.variant8._0;
        succ_9461_ &= true;
        succ_9461_ &= true;
        if (succ_9461_) {
            {
                return ((getFullNamePS0997rS0540)((*decl)));
            }
            goto after_14862;
        }
    }
    {
        succ_9465_ &= (tmp_14862_->tag == 9);
        ParsedModule_s **decl = &tmp_14862_->payload.variant9._0;
        succ_9465_ &= true;
        if (succ_9465_) {
            {
                return ((getFullNamePS1882rS0540)((*decl)));
            }
            goto after_14862;
        }
    }
    {
        succ_9471_ &= (tmp_14862_->tag == 6);
        TypeList_s *params = &tmp_14862_->payload.variant6._0;
        succ_9471_ &= true;
        Type_u **rt = &tmp_14862_->payload.variant6._1;
        succ_9471_ &= true;
        FuncAttr_s *attr = &tmp_14862_->payload.variant6._2;
        succ_9471_ &= true;
        if (succ_9471_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("func (")));
                for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s p = ((toStringPU5175rS0540)((*((atPS0643uszrPPU5175)((&(*params)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(p))));
                    ((dropPS0540rN)((&(p))));
                    if ((i) != (((*params).length) - ((usize)(1llu)))) {
                        ((pushCharPS0540crN)((&(s)), (',')));
                        ((pushCharPS0540crN)((&(s)), (' ')));
                    }
                }

                if ((*attr).isVariadic) {
                    if (((*params).length) > ((usize)(0llu)))
                        if (!((isVariadicTypePU5175rB)(((((*params).elements))[(((*params).length) - ((usize)(1llu)))])))) {
                            ((pushStrPS0540PcrN)((&(s)), ("...")));
                        }
                }

                ((pushCharPS0540crN)((&(s)), (')')));
                if (!((isNonePU5175rB)((*rt)))) {
                    ((pushStrPS0540PcrN)((&(s)), (" -> ")));
                    String_s r = ((toStringPU5175rS0540)((*rt)));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(r))));
                    ((dropPS0540rN)((&(r))));
                }

                return (s);
            }
            goto after_14862;
        }
    }
    {
        succ_9483_ &= (tmp_14862_->tag == 5);
        Type_u **sub = &tmp_14862_->payload.variant5._0;
        succ_9483_ &= true;
        usize *size = &tmp_14862_->payload.variant5._1;
        succ_9483_ &= true;
        if (succ_9483_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("[")));
                String_s _s = ((toStringPU5175rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                ((pushCharPS0540crN)((&(s)), (';')));
                ((pushCharPS0540crN)((&(s)), (' ')));
                ((pushNumberPS0540uszrN)((&(s)), (*size)));
                ((pushCharPS0540crN)((&(s)), (']')));
                return (s);
            }
            goto after_14862;
        }
    }
    {
        succ_9491_ &= (tmp_14862_->tag == 2);
        Type_u **typ = &tmp_14862_->payload.variant2._0;
        succ_9491_ &= true;
        if (succ_9491_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("...")));
                String_s _s = ((toStringPU5175rS0540)((*typ)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                return (s);
            }
            goto after_14862;
        }
    }
    {
        succ_9499_ &= (tmp_14862_->tag == 10);
        TypeList_s *elems = &tmp_14862_->payload.variant10._0;
        succ_9499_ &= true;
        if (succ_9499_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("(")));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s e = ((toStringPU5175rS0540)((*((atPS0643uszrPPU5175)((&(*elems)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(e))));
                    ((dropPS0540rN)((&(e))));
                    if ((i) != (((*elems).length) - ((usize)(1llu)))) {
                        ((pushCharPS0540crN)((&(s)), (',')));
                        ((pushCharPS0540crN)((&(s)), (' ')));
                    }
                }

                ((pushCharPS0540crN)((&(s)), (')')));
                return (s);
            }
            goto after_14862;
        }
    }
    {
        if (true) {
            {
            }
            goto after_14862;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14862:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of types in Type.toString")));
}
usize getAlignmentInBitsPU5175rusz(Type_u *this) { return (((getAlignmentInBytesPU5175rusz)((this))) * ((usize)(8llu))); }
usize getAlignmentInBytesPU5175rusz(Type_u *this) {
    usize res = ((usize)(0llu));
    bool succ_9512_ = true;
    bool succ_9518_ = true;
    bool succ_9522_ = true;
    bool succ_9558_ = true;
    bool succ_9562_ = true;
    bool succ_9577_ = true;
    bool succ_9581_ = true;

    Type_u *tmp_14933_ = (this);
    {
        succ_9512_ &= (tmp_14933_->tag == 4);
        succ_9512_ &= true;
        if (succ_9512_) {
            {
                ((res) = ((usize)(8llu)));
            }
            goto after_14933;
        }
    }
    {
        succ_9518_ &= (tmp_14933_->tag == 6);
        succ_9518_ &= true;
        succ_9518_ &= true;
        succ_9518_ &= true;
        if (succ_9518_) {
            {
                ((res) = ((usize)(8llu)));
            }
            goto after_14933;
        }
    }
    {
        succ_9522_ &= (tmp_14933_->tag == 3);
        PrimType_u *typ = &tmp_14933_->payload.variant3._0;
        succ_9522_ &= true;
        if (succ_9522_) {
            {
                bool succ_9525_ = true;
                bool succ_9527_ = true;
                bool succ_9529_ = true;
                bool succ_9531_ = true;
                bool succ_9533_ = true;
                bool succ_9535_ = true;
                bool succ_9537_ = true;
                bool succ_9539_ = true;
                bool succ_9541_ = true;
                bool succ_9543_ = true;
                bool succ_9545_ = true;
                bool succ_9547_ = true;
                bool succ_9549_ = true;
                bool succ_9551_ = true;
                bool succ_9553_ = true;

                PrimType_u tmp_14902_ = (*typ);
                {
                    succ_9525_ &= (tmp_14902_.tag == 11);
                    if (succ_9525_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9527_ &= (tmp_14902_.tag == 4);
                    if (succ_9527_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9529_ &= (tmp_14902_.tag == 0);
                    if (succ_9529_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9531_ &= (tmp_14902_.tag == 12);
                    if (succ_9531_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9533_ &= (tmp_14902_.tag == 10);
                    if (succ_9533_) {
                        {
                            ((res) = ((usize)(1llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9535_ &= (tmp_14902_.tag == 5);
                    if (succ_9535_) {
                        {
                            ((res) = ((usize)(2llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9537_ &= (tmp_14902_.tag == 1);
                    if (succ_9537_) {
                        {
                            ((res) = ((usize)(2llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9539_ &= (tmp_14902_.tag == 6);
                    if (succ_9539_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9541_ &= (tmp_14902_.tag == 2);
                    if (succ_9541_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9543_ &= (tmp_14902_.tag == 13);
                    if (succ_9543_) {
                        {
                            ((res) = ((usize)(4llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9545_ &= (tmp_14902_.tag == 7);
                    if (succ_9545_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9547_ &= (tmp_14902_.tag == 3);
                    if (succ_9547_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9549_ &= (tmp_14902_.tag == 14);
                    if (succ_9549_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9551_ &= (tmp_14902_.tag == 8);
                    if (succ_9551_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    succ_9553_ &= (tmp_14902_.tag == 9);
                    if (succ_9553_) {
                        {
                            ((res) = ((usize)(8llu)));
                        }
                        goto after_14902;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in Type.getAlignment")));
                        }
                        goto after_14902;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14902:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_14933;
        }
    }
    {
        succ_9558_ &= (tmp_14933_->tag == 5);
        Type_u **sub = &tmp_14933_->payload.variant5._0;
        succ_9558_ &= true;
        succ_9558_ &= true;
        if (succ_9558_) {
            {
                ((res) = ((getAlignmentInBytesPU5175rusz)((*sub))));
            }
            goto after_14933;
        }
    }
    {
        succ_9562_ &= (tmp_14933_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_14933_->payload.variant7._0;
        succ_9562_ &= true;
        if (succ_9562_) {
            {
                ((assertBPcrN)(((isSuccessPU9661rB)((&((*decl)->typeState)))), ("Can only get alignment of valid structs")));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *td = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((td)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((td)->typeState))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                }

                ((res) = (maxAlign));
            }
            goto after_14933;
        }
    }
    {
        succ_9577_ &= (tmp_14933_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_14933_->payload.variant8._0;
        succ_9577_ &= true;
        succ_9577_ &= true;
        if (succ_9577_) {
            {
                ((res) = ((getAlignmentInBytesPS0997rusz)((*decl))));
            }
            goto after_14933;
        }
    }
    {
        succ_9581_ &= (tmp_14933_->tag == 10);
        TypeList_s *elems = &tmp_14933_->payload.variant10._0;
        succ_9581_ &= true;
        if (succ_9581_) {
            {
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    Type_u *tt = ((((*elems).elements))[(i)]);
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                }

                ((res) = (maxAlign));
            }
            goto after_14933;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("Exhaustive handling of type kinds in Type.getAlignment")));
            }
            goto after_14933;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_14933:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((res) != ((usize)(0llu))), ("Alignment can\'t be 0 bytes")));
    usize n = ((usize)(1llu));
    while ((n) < (res))
        ((n) = ((n) * ((usize)(2llu))));
    return (n);
}
usize getSizeInBitsPU5175rusz(Type_u *this) {
    usize s = (((getSizeInBytesPU5175rusz)((this))) * ((usize)(8llu)));
    if ((s) == ((usize)(0llu)))
        return ((usize)(1llu));
    return (s);
}
usize getSizeInBytesPU5175rusz(Type_u *this) {
    bool succ_9597_ = true;
    bool succ_9601_ = true;
    bool succ_9607_ = true;
    bool succ_9611_ = true;
    bool succ_9646_ = true;
    bool succ_9651_ = true;
    bool succ_9655_ = true;
    bool succ_9676_ = true;
    bool succ_9680_ = true;

    Type_u *tmp_15028_ = (this);
    {
        succ_9597_ &= (tmp_15028_->tag == 4);
        succ_9597_ &= true;
        if (succ_9597_) {
            {
                return ((usize)(8llu));
            }
            goto after_15028;
        }
    }
    {
        succ_9601_ &= (tmp_15028_->tag == 2);
        succ_9601_ &= true;
        if (succ_9601_) {
            {
                return ((usize)(16llu));
            }
            goto after_15028;
        }
    }
    {
        succ_9607_ &= (tmp_15028_->tag == 6);
        succ_9607_ &= true;
        succ_9607_ &= true;
        succ_9607_ &= true;
        if (succ_9607_) {
            {
                return ((usize)(8llu));
            }
            goto after_15028;
        }
    }
    {
        succ_9611_ &= (tmp_15028_->tag == 3);
        PrimType_u *typ = &tmp_15028_->payload.variant3._0;
        succ_9611_ &= true;
        if (succ_9611_) {
            {
                bool succ_9614_ = true;
                bool succ_9616_ = true;
                bool succ_9618_ = true;
                bool succ_9620_ = true;
                bool succ_9622_ = true;
                bool succ_9624_ = true;
                bool succ_9626_ = true;
                bool succ_9628_ = true;
                bool succ_9630_ = true;
                bool succ_9632_ = true;
                bool succ_9634_ = true;
                bool succ_9636_ = true;
                bool succ_9638_ = true;
                bool succ_9640_ = true;
                bool succ_9642_ = true;

                PrimType_u tmp_14981_ = (*typ);
                {
                    succ_9614_ &= (tmp_14981_.tag == 11);
                    if (succ_9614_) {
                        {
                            return ((usize)(0llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9616_ &= (tmp_14981_.tag == 4);
                    if (succ_9616_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9618_ &= (tmp_14981_.tag == 0);
                    if (succ_9618_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9620_ &= (tmp_14981_.tag == 12);
                    if (succ_9620_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9622_ &= (tmp_14981_.tag == 10);
                    if (succ_9622_) {
                        {
                            return ((usize)(1llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9624_ &= (tmp_14981_.tag == 5);
                    if (succ_9624_) {
                        {
                            return ((usize)(2llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9626_ &= (tmp_14981_.tag == 1);
                    if (succ_9626_) {
                        {
                            return ((usize)(2llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9628_ &= (tmp_14981_.tag == 6);
                    if (succ_9628_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9630_ &= (tmp_14981_.tag == 2);
                    if (succ_9630_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9632_ &= (tmp_14981_.tag == 13);
                    if (succ_9632_) {
                        {
                            return ((usize)(4llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9634_ &= (tmp_14981_.tag == 7);
                    if (succ_9634_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9636_ &= (tmp_14981_.tag == 3);
                    if (succ_9636_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9638_ &= (tmp_14981_.tag == 14);
                    if (succ_9638_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9640_ &= (tmp_14981_.tag == 8);
                    if (succ_9640_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    succ_9642_ &= (tmp_14981_.tag == 9);
                    if (succ_9642_) {
                        {
                            return ((usize)(8llu));
                        }
                        goto after_14981;
                    }
                }
                {
                    if (true) {
                        {
                            ((unreachablePcrN)(("Exhaustive handling of primitive types in Type.getSize")));
                        }
                        goto after_14981;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_14981:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_15028;
        }
    }
    {
        succ_9646_ &= (tmp_15028_->tag == 9);
        succ_9646_ &= true;
        if (succ_9646_) {
            {
                return ((usize)(0llu));
            }
            goto after_15028;
        }
    }
    {
        succ_9651_ &= (tmp_15028_->tag == 5);
        Type_u **sub = &tmp_15028_->payload.variant5._0;
        succ_9651_ &= true;
        usize *size = &tmp_15028_->payload.variant5._1;
        succ_9651_ &= true;
        if (succ_9651_) {
            {
                return (((getSizeInBytesPU5175rusz)((*sub))) * (*size));
            }
            goto after_15028;
        }
    }
    {
        succ_9655_ &= (tmp_15028_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_15028_->payload.variant7._0;
        succ_9655_ &= true;
        if (succ_9655_) {
            {
                ((assertBPcrN)(((isSuccessPU9661rB)((&((*decl)->typeState)))), ("Can only get size of valid structs")));
                usize size = ((usize)(0llu));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *td = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((td)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((td)->typeState))));
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                    if ((i) != ((((*decl)->context).fieldLength) - ((usize)(1llu)))) {
                        ParsedTypeNode_s *next = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), ((i) + ((usize)(1llu)))));
                        Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }

                ((size) = ((nextMultipleOfuszuszrusz)((size), (maxAlign))));
                return (size);
            }
            goto after_15028;
        }
    }
    {
        succ_9676_ &= (tmp_15028_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_15028_->payload.variant8._0;
        succ_9676_ &= true;
        succ_9676_ &= true;
        if (succ_9676_) {
            {
                return ((getSizeInBytesPS0997rusz)((*decl)));
            }
            goto after_15028;
        }
    }
    {
        succ_9680_ &= (tmp_15028_->tag == 10);
        TypeList_s *elems = &tmp_15028_->payload.variant10._0;
        succ_9680_ &= true;
        if (succ_9680_) {
            {
                usize size = ((usize)(0llu));
                usize maxAlign = ((usize)(1llu));
                for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    Type_u *tt = ((((*elems).elements))[(i)]);
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (maxAlign))
                        ((maxAlign) = (_a));
                    if ((i) != (((*elems).length) - ((usize)(1llu)))) {
                        Type_u *nextType = ((((*elems).elements))[((i) + ((usize)(1llu)))]);
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }

                ((size) = ((nextMultipleOfuszuszrusz)((size), (maxAlign))));
                return (size);
            }
            goto after_15028;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15028;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15028:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of type kinds in Type.getSizeInBytes")));
}
Type_u *getParamPU5175uszrPU5175(Type_u *fnType, usize id) {
    bool succ_9699_ = true;

    Type_u *tmp_15033_ = (fnType);
    {
        succ_9699_ &= (tmp_15033_->tag == 6);
        TypeList_s *params = &tmp_15033_->payload.variant6._0;
        succ_9699_ &= true;
        succ_9699_ &= true;
        succ_9699_ &= true;
        if (succ_9699_) {
            {
                return (*((atPS0643uszrPPU5175)((&(*params)), (id))));
            }
            goto after_15033;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15033;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15033:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("getParam() called on non-function type")));
}
Type_u *getReturnTypePU5175rPU5175(Type_u *fnType) {
    bool succ_9706_ = true;

    Type_u *tmp_15038_ = (fnType);
    {
        succ_9706_ &= (tmp_15038_->tag == 6);
        succ_9706_ &= true;
        Type_u **ret = &tmp_15038_->payload.variant6._1;
        succ_9706_ &= true;
        succ_9706_ &= true;
        if (succ_9706_) {
            {
                return (*ret);
            }
            goto after_15038;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15038;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15038:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("getReturnType() called on non-function type")));
}
Type_u *getTupleElementPU5175uszrPU5175(Type_u *tuple, usize index) {
    bool succ_9711_ = true;

    Type_u *tmp_15041_ = (tuple);
    succ_9711_ &= (tmp_15041_->tag == 10);
    TypeList_s *elems = &tmp_15041_->payload.variant10._0;
    succ_9711_ &= true;
    if (!succ_9711_) {
        ((unreachablePcrN)(("getTupleElement() called on non-tuple type")));
    };
    return (*((atPS0643uszrPPU5175)((&(*elems)), (index))));
}
f64 getMaxFloatValuePU5175rf64(Type_u *this) {
    bool succ_9716_ = true;
    bool succ_9714_ = true;
    bool succ_9723_ = true;
    bool succ_9721_ = true;

    Type_u *tmp_15050_ = (this);
    {
        succ_9716_ &= (tmp_15050_->tag == 3);
        succ_9714_ &= (tmp_15050_->payload.variant3._0.tag == 13);
        succ_9716_ &= succ_9714_;
        if (succ_9716_) {
            {
                i32 VAL = ((i32)(2139095039));
                return ((f64)((*((f32 *)((&(VAL)))))));
            }
            goto after_15050;
        }
    }
    {
        succ_9723_ &= (tmp_15050_->tag == 3);
        succ_9721_ &= (tmp_15050_->payload.variant3._0.tag == 14);
        succ_9723_ &= succ_9721_;
        if (succ_9723_) {
            {
                i64 VAL = ((i64)(9218868437227405311ll));
                return (*((f64 *)((&(VAL)))));
            }
            goto after_15050;
        }
    }
    {
        if (true) {
            {
            }
            goto after_15050;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15050:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Type.getMaxFloatValue() called on non-Float")));
}
Type_u *intoPointerPU5175rPU5175(Type_u *this) { return ((wrapU5175rPU5175)(((Type_u){.tag = 4, .payload = {.variant4 = {._0 = (this)}}}))); }
Type_u *intoArrayTypePU5175uszrPU5175(Type_u *this, usize size) { return ((wrapU5175rPU5175)(((Type_u){.tag = 5, .payload = {.variant5 = {._0 = (this), ._1 = (size)}}}))); }
Type_u *copyPU5175rPU5175(Type_u *this) { return ((wrapU5175rPU5175)((*(this)))); }
Type_u *wrapU5175rPU5175(Type_u t) {
    bool succ_9730_ = true;

    Type_u tmp_15065_ = (t);
    {
        succ_9730_ &= (tmp_15065_.tag == 3);
        PrimType_u *p = &tmp_15065_.payload.variant3._0;
        succ_9730_ &= true;
        if (succ_9730_) {
            {
                usize id = ((usize)(((tagAnyru8)((&(*p))))));
                ((assertBPcrN)(((id) < (PRIM_TYPE_COUNT)), ("Type::Prim has invalid tag")));
                ((*((atPS4174uszrPU5175)((&(types)), (id)))) = (t));
                return ((atPS4174uszrPU5175)((&(types)), (id)));
            }
            goto after_15065;
        }
    }
    {
        if (true) {
            {
                ((pushPS4174U5175rN)((&(types)), (t)));
                if (*((flags).debug))
                    ((pushPS7368S5777rN)((&(debugTypes)), ((LLVMMetadata_s){0})));
                return ((lastPS4174rPU5175)((&(types))));
            }
            goto after_15065;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_15065:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablerN)());
}
ParsedExpr_s *popPS7823uszrPS2435(ParsedExprList_s *this, usize index) {
    ParsedExpr_s *elem = (*((atPS7823uszrPPS2435)((this), (index))));
    for (usize i = (index); ((i) < (((this)->length) - ((usize)(1llu)))); ((i) = ((i) + ((usize)(1llu))))) {
        ((*((atPS7823uszrPPS2435)((this), (i)))) = (*((atPS7823uszrPPS2435)((this), ((i) + ((usize)(1llu)))))));
    }

    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (elem);
}
none pushPS0643PU5175rN(TypeList_s *this, Type_u *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Type_u *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Type_u **atPS0643uszrPPU5175(TypeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TypeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TypeList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS7823PS2435rN(ParsedExprList_s *this, ParsedExpr_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedExpr_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedExprList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedExpr_s **atPS7823uszrPPS2435(ParsedExprList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedExprList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedExprList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS3288PS1100rN(ParsedStmtList_s *this, ParsedStmt_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedStmt_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedStmtList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedStmt_s **atPS3288uszrPPS1100(ParsedStmtList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedStmtList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedStmtList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS1982PS1826rN(ParsedPatternList_s *this, ParsedPattern_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedPattern_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedPatternList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedPattern_s **atPS1982uszrPPS1826(ParsedPatternList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedPatternList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedPatternList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS4601S2365rN(UnionVariantLookupList_s *this, UnionVariantLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionVariantLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionVariantLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
UnionVariantLookup_s *atPS4601uszrPS2365(UnionVariantLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UnionVariantLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UnionVariantLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4601PS2365rB(UnionVariantLookupList_s *this, UnionVariantLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS2365PS2365rB)(((atPS4601uszrPS2365)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
none pushPS4836S1592rN(UnionLookupList_s *this, UnionLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(UnionLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UnionLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
UnionLookup_s *popPS4836rPS1592(UnionLookupList_s *this) {
    UnionLookup_s *l = ((lastPS4836rPS1592)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
UnionLookup_s *atPS4836uszrPS1592(UnionLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UnionLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UnionLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4836PS1592rB(UnionLookupList_s *this, UnionLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1592PS1592rB)(((atPS4836uszrPS1592)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
UnionLookup_s *lastPS4836rPS1592(UnionLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty UnionLookupList")));
    return ((atPS4836uszrPS1592)((this), (((this)->length) - ((usize)(1llu)))));
}
none pushPS0030PS3506rN(ParsedUnionVariantList_s *this, ParsedUnionVariant_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedUnionVariant_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedUnionVariantList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedUnionVariant_s **atPS0030uszrPPS3506(ParsedUnionVariantList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedUnionVariantList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedUnionVariantList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS6760PS1372rN(ParsedTypeNodeList_s *this, ParsedTypeNode_s *element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedTypeNode_s *))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedTypeNodeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedTypeNode_s **atPS6760uszrPPS1372(ParsedTypeNodeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedTypeNodeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedTypeNodeList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS9938S6070rN(TokenList_s *this, Token_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Token_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TokenList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
Token_s *atPS9938uszrPS6070(TokenList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TokenList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TokenList.at")));
    return (&((((this)->elements))[(index)]));
}
none pushPS1575U7467rN(ConfigList_s *this, Config_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(Config_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ConfigList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
none pushPS5121S0997rN(ModuleLookupList_s *this, ModuleLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ModuleLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ModuleLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
bool containsPS5121PS0997rB(ModuleLookupList_s *this, ModuleLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0997PS0997rB)(((atPS5121uszrPS0997)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ModuleLookup_s *atPS5121uszrPS0997(ModuleLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ModuleLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ModuleLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
Config_u *atPS1575uszrPU7467(ConfigList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ConfigList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ConfigList.at")));
    return (&((((this)->elements))[(index)]));
}
ModuleLookup_s *lastPS5121rPS0997(ModuleLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ModuleLookupList")));
    return ((atPS5121uszrPS0997)((this), (((this)->length) - ((usize)(1llu)))));
}
none initBlankPS4756uszrN(ParsedAttributeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ParsedAttribute_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedAttributeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4756U4360rN(ParsedAttributeList_s *this, ParsedAttribute_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ParsedAttribute_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ParsedAttributeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ParsedAttribute_u *popPS4756rPU4360(ParsedAttributeList_s *this) {
    ParsedAttribute_u *l = ((lastPS4756rPU4360)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ParsedAttribute_u *atPS4756uszrPU4360(ParsedAttributeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ParsedAttributeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ParsedAttributeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4756PU4360rB(ParsedAttributeList_s *this, ParsedAttribute_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU4360PU4360rB)(((atPS4756uszrPU4360)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ParsedAttribute_u *lastPS4756rPU4360(ParsedAttributeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ParsedAttributeList")));
    return ((atPS4756uszrPU4360)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS4756PS4756rN(ParsedAttributeList_s *this, ParsedAttributeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4756U4360rN)((this), (*((atPS4756uszrPU4360)((other), (i))))));
    }

    ((dropPS4756rN)((other)));
}
none dropPS4756rN(ParsedAttributeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS4756rN(ParsedAttributeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8385uszrN(FunctionLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(FunctionLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FunctionLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8385S0677rN(FunctionLookupList_s *this, FunctionLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(FunctionLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in FunctionLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
FunctionLookup_s *popPS8385rPS0677(FunctionLookupList_s *this) {
    FunctionLookup_s *l = ((lastPS8385rPS0677)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
FunctionLookup_s *atPS8385uszrPS0677(FunctionLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in FunctionLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in FunctionLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8385PS0677rB(FunctionLookupList_s *this, FunctionLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0677PS0677rB)(((atPS8385uszrPS0677)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
FunctionLookup_s *lastPS8385rPS0677(FunctionLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty FunctionLookupList")));
    return ((atPS8385uszrPS0677)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8385PS8385rN(FunctionLookupList_s *this, FunctionLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8385S0677rN)((this), (*((atPS8385uszrPS0677)((other), (i))))));
    }

    ((dropPS8385rN)((other)));
}
none dropPS8385rN(FunctionLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8385rN(FunctionLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS7392uszrN(StructLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(StructLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StructLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS7392S4228rN(StructLookupList_s *this, StructLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(StructLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in StructLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
StructLookup_s *popPS7392rPS4228(StructLookupList_s *this) {
    StructLookup_s *l = ((lastPS7392rPS4228)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
StructLookup_s *atPS7392uszrPS4228(StructLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in StructLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in StructLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS7392PS4228rB(StructLookupList_s *this, StructLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS4228PS4228rB)(((atPS7392uszrPS4228)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
StructLookup_s *lastPS7392rPS4228(StructLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty StructLookupList")));
    return ((atPS7392uszrPS4228)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS7392PS7392rN(StructLookupList_s *this, StructLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS7392S4228rN)((this), (*((atPS7392uszrPS4228)((other), (i))))));
    }

    ((dropPS7392rN)((other)));
}
none dropPS7392rN(StructLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS7392rN(StructLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5541uszrN(ScopeLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ScopeLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ScopeLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5541S1913rN(ScopeLookupList_s *this, ScopeLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ScopeLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ScopeLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ScopeLookup_s *popPS5541rPS1913(ScopeLookupList_s *this) {
    ScopeLookup_s *l = ((lastPS5541rPS1913)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ScopeLookup_s *atPS5541uszrPS1913(ScopeLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ScopeLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ScopeLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5541PS1913rB(ScopeLookupList_s *this, ScopeLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1913PS1913rB)(((atPS5541uszrPS1913)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ScopeLookup_s *lastPS5541rPS1913(ScopeLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ScopeLookupList")));
    return ((atPS5541uszrPS1913)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5541PS5541rN(ScopeLookupList_s *this, ScopeLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5541S1913rN)((this), (*((atPS5541uszrPS1913)((other), (i))))));
    }

    ((dropPS5541rN)((other)));
}
none dropPS5541rN(ScopeLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5541rN(ScopeLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS1581uszrN(TypeLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(TypeLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS1581S6177rN(TypeLookupList_s *this, TypeLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(TypeLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TypeLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
TypeLookup_s *popPS1581rPS6177(TypeLookupList_s *this) {
    TypeLookup_s *l = ((lastPS1581rPS6177)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
TypeLookup_s *atPS1581uszrPS6177(TypeLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TypeLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TypeLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS1581PS6177rB(TypeLookupList_s *this, TypeLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6177PS6177rB)(((atPS1581uszrPS6177)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
TypeLookup_s *lastPS1581rPS6177(TypeLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty TypeLookupList")));
    return ((atPS1581uszrPS6177)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS1581PS1581rN(TypeLookupList_s *this, TypeLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS1581S6177rN)((this), (*((atPS1581uszrPS6177)((other), (i))))));
    }

    ((dropPS1581rN)((other)));
}
none dropPS1581rN(TypeLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS1581rN(TypeLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS3313uszrN(VariableLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(VariableLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in VariableLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS3313S6661rN(VariableLookupList_s *this, VariableLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(VariableLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in VariableLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
VariableLookup_s *popPS3313rPS6661(VariableLookupList_s *this) {
    VariableLookup_s *l = ((lastPS3313rPS6661)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
VariableLookup_s *atPS3313uszrPS6661(VariableLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in VariableLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in VariableLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS3313PS6661rB(VariableLookupList_s *this, VariableLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6661PS6661rB)(((atPS3313uszrPS6661)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
VariableLookup_s *lastPS3313rPS6661(VariableLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty VariableLookupList")));
    return ((atPS3313uszrPS6661)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS3313PS3313rN(VariableLookupList_s *this, VariableLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS3313S6661rN)((this), (*((atPS3313uszrPS6661)((other), (i))))));
    }

    ((dropPS3313rN)((other)));
}
none dropPS3313rN(VariableLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS3313rN(VariableLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS3606uszrN(ImportLookupList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(ImportLookup_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ImportLookupList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS3606S6218rN(ImportLookupList_s *this, ImportLookup_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(ImportLookup_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in ImportLookupList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
ImportLookup_s *popPS3606rPS6218(ImportLookupList_s *this) {
    ImportLookup_s *l = ((lastPS3606rPS6218)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
ImportLookup_s *atPS3606uszrPS6218(ImportLookupList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in ImportLookupList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in ImportLookupList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS3606PS6218rB(ImportLookupList_s *this, ImportLookup_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6218PS6218rB)(((atPS3606uszrPS6218)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
ImportLookup_s *lastPS3606rPS6218(ImportLookupList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty ImportLookupList")));
    return ((atPS3606uszrPS6218)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS3606PS3606rN(ImportLookupList_s *this, ImportLookupList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS3606S6218rN)((this), (*((atPS3606uszrPS6218)((other), (i))))));
    }

    ((dropPS3606rN)((other)));
}
none dropPS3606rN(ImportLookupList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS3606rN(ImportLookupList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9625uszrN(TCStateList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(TCState_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TCStateList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9625U9661rN(TCStateList_s *this, TCState_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(TCState_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in TCStateList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
TCState_u *popPS9625rPU9661(TCStateList_s *this) {
    TCState_u *l = ((lastPS9625rPU9661)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
TCState_u *atPS9625uszrPU9661(TCStateList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in TCStateList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in TCStateList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9625PU9661rB(TCStateList_s *this, TCState_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU9661PU9661rB)(((atPS9625uszrPU9661)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
TCState_u *lastPS9625rPU9661(TCStateList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty TCStateList")));
    return ((atPS9625uszrPU9661)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9625PS9625rN(TCStateList_s *this, TCStateList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9625U9661rN)((this), (*((atPS9625uszrPU9661)((other), (i))))));
    }

    ((dropPS9625rN)((other)));
}
none dropPS9625rN(TCStateList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9625rN(TCStateList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9911uszrN(RegIndexList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(RegIndex_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegIndexList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9911S6939rN(RegIndexList_s *this, RegIndex_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(RegIndex_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegIndexList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
RegIndex_s *popPS9911rPS6939(RegIndexList_s *this) {
    RegIndex_s *l = ((lastPS9911rPS6939)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
RegIndex_s *atPS9911uszrPS6939(RegIndexList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in RegIndexList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in RegIndexList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9911PS6939rB(RegIndexList_s *this, RegIndex_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS6939PS6939rB)(((atPS9911uszrPS6939)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
RegIndex_s *lastPS9911rPS6939(RegIndexList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty RegIndexList")));
    return ((atPS9911uszrPS6939)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9911PS9911rN(RegIndexList_s *this, RegIndexList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9911S6939rN)((this), (*((atPS9911uszrPS6939)((other), (i))))));
    }

    ((dropPS9911rN)((other)));
}
none dropPS9911rN(RegIndexList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9911rN(RegIndexList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS0124uszrN(IRInstrList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRInstr_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRInstrList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS0124S7680rN(IRInstrList_s *this, IRInstr_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRInstr_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRInstrList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRInstr_s *popPS0124rPS7680(IRInstrList_s *this) {
    IRInstr_s *l = ((lastPS0124rPS7680)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRInstr_s *atPS0124uszrPS7680(IRInstrList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRInstrList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRInstrList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS0124PS7680rB(IRInstrList_s *this, IRInstr_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7680PS7680rB)(((atPS0124uszrPS7680)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRInstr_s *lastPS0124rPS7680(IRInstrList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRInstrList")));
    return ((atPS0124uszrPS7680)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS0124PS0124rN(IRInstrList_s *this, IRInstrList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0124S7680rN)((this), (*((atPS0124uszrPS7680)((other), (i))))));
    }

    ((dropPS0124rN)((other)));
}
none dropPS0124rN(IRInstrList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS0124rN(IRInstrList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS9366uszrN(IRScopeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRScope_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS9366S7082rN(IRScopeList_s *this, IRScope_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRScope_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRScope_s *popPS9366rPS7082(IRScopeList_s *this) {
    IRScope_s *l = ((lastPS9366rPS7082)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRScope_s *atPS9366uszrPS7082(IRScopeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRScopeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRScopeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS9366PS7082rB(IRScopeList_s *this, IRScope_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7082PS7082rB)(((atPS9366uszrPS7082)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRScope_s *lastPS9366rPS7082(IRScopeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRScopeList")));
    return ((atPS9366uszrPS7082)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS9366PS9366rN(IRScopeList_s *this, IRScopeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS9366S7082rN)((this), (*((atPS9366uszrPS7082)((other), (i))))));
    }

    ((dropPS9366rN)((other)));
}
none dropPS9366rN(IRScopeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS9366rN(IRScopeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS2282uszrN(IRRegList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRReg_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRRegList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS2282S1534rN(IRRegList_s *this, IRReg_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRReg_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRRegList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRReg_s *popPS2282rPS1534(IRRegList_s *this) {
    IRReg_s *l = ((lastPS2282rPS1534)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRReg_s *atPS2282uszrPS1534(IRRegList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRRegList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRRegList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS2282PS1534rB(IRRegList_s *this, IRReg_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS1534PS1534rB)(((atPS2282uszrPS1534)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRReg_s *lastPS2282rPS1534(IRRegList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRRegList")));
    return ((atPS2282uszrPS1534)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS2282PS2282rN(IRRegList_s *this, IRRegList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS2282S1534rN)((this), (*((atPS2282uszrPS1534)((other), (i))))));
    }

    ((dropPS2282rN)((other)));
}
none dropPS2282rN(IRRegList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS2282rN(IRRegList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS1479uszrN(IRBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS1479S9435rN(IRBlockList_s *this, IRBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRBlock_s *popPS1479rPS9435(IRBlockList_s *this) {
    IRBlock_s *l = ((lastPS1479rPS9435)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRBlock_s *atPS1479uszrPS9435(IRBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS1479PS9435rB(IRBlockList_s *this, IRBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS9435PS9435rB)(((atPS1479uszrPS9435)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRBlock_s *lastPS1479rPS9435(IRBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRBlockList")));
    return ((atPS1479uszrPS9435)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS1479PS1479rN(IRBlockList_s *this, IRBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS1479S9435rN)((this), (*((atPS1479uszrPS9435)((other), (i))))));
    }

    ((dropPS1479rN)((other)));
}
none dropPS1479rN(IRBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS1479rN(IRBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS6662uszrN(LoopBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LoopBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LoopBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS6662S0666rN(LoopBlockList_s *this, LoopBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LoopBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LoopBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LoopBlock_s *popPS6662rPS0666(LoopBlockList_s *this) {
    LoopBlock_s *l = ((lastPS6662rPS0666)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LoopBlock_s *atPS6662uszrPS0666(LoopBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LoopBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LoopBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS6662PS0666rB(LoopBlockList_s *this, LoopBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0666PS0666rB)(((atPS6662uszrPS0666)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LoopBlock_s *lastPS6662rPS0666(LoopBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LoopBlockList")));
    return ((atPS6662uszrPS0666)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS6662PS6662rN(LoopBlockList_s *this, LoopBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS6662S0666rN)((this), (*((atPS6662uszrPS0666)((other), (i))))));
    }

    ((dropPS6662rN)((other)));
}
none dropPS6662rN(LoopBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS6662rN(LoopBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5960uszrN(IRScopeEntryList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRScopeEntry_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeEntryList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5960S9676rN(IRScopeEntryList_s *this, IRScopeEntry_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRScopeEntry_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRScopeEntryList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRScopeEntry_s *popPS5960rPS9676(IRScopeEntryList_s *this) {
    IRScopeEntry_s *l = ((lastPS5960rPS9676)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRScopeEntry_s *atPS5960uszrPS9676(IRScopeEntryList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRScopeEntryList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRScopeEntryList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5960PS9676rB(IRScopeEntryList_s *this, IRScopeEntry_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS9676PS9676rB)(((atPS5960uszrPS9676)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRScopeEntry_s *lastPS5960rPS9676(IRScopeEntryList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRScopeEntryList")));
    return ((atPS5960uszrPS9676)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5960PS5960rN(IRScopeEntryList_s *this, IRScopeEntryList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5960S9676rN)((this), (*((atPS5960uszrPS9676)((other), (i))))));
    }

    ((dropPS5960rN)((other)));
}
none dropPS5960rN(IRScopeEntryList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5960rN(IRScopeEntryList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8040uszrN(IRFuncList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(IRFunc_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRFuncList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8040S7132rN(IRFuncList_s *this, IRFunc_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(IRFunc_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in IRFuncList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
IRFunc_s *popPS8040rPS7132(IRFuncList_s *this) {
    IRFunc_s *l = ((lastPS8040rPS7132)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
IRFunc_s *atPS8040uszrPS7132(IRFuncList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in IRFuncList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in IRFuncList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8040PS7132rB(IRFuncList_s *this, IRFunc_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7132PS7132rB)(((atPS8040uszrPS7132)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
IRFunc_s *lastPS8040rPS7132(IRFuncList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty IRFuncList")));
    return ((atPS8040uszrPS7132)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8040PS8040rN(IRFuncList_s *this, IRFuncList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8040S7132rN)((this), (*((atPS8040uszrPS7132)((other), (i))))));
    }

    ((dropPS8040rN)((other)));
}
none dropPS8040rN(IRFuncList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8040rN(IRFuncList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS4318uszrN(LLVMTypeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMType_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMTypeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4318S0706rN(LLVMTypeList_s *this, LLVMType_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMType_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMTypeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMType_s *popPS4318rPS0706(LLVMTypeList_s *this) {
    LLVMType_s *l = ((lastPS4318rPS0706)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMType_s *atPS4318uszrPS0706(LLVMTypeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMTypeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMTypeList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS4318PS0706rB(LLVMTypeList_s *this, LLVMType_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS0706PS0706rB)(((atPS4318uszrPS0706)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMType_s *lastPS4318rPS0706(LLVMTypeList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMTypeList")));
    return ((atPS4318uszrPS0706)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS4318PS4318rN(LLVMTypeList_s *this, LLVMTypeList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4318S0706rN)((this), (*((atPS4318uszrPS0706)((other), (i))))));
    }

    ((dropPS4318rN)((other)));
}
none dropPS4318rN(LLVMTypeList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS4318rN(LLVMTypeList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS5884uszrN(RegValueList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(RegValue_u)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegValueList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS5884U5952rN(RegValueList_s *this, RegValue_u element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(RegValue_u))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in RegValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
RegValue_u *popPS5884rPU5952(RegValueList_s *this) {
    RegValue_u *l = ((lastPS5884rPU5952)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
RegValue_u *atPS5884uszrPU5952(RegValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in RegValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in RegValueList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS5884PU5952rB(RegValueList_s *this, RegValue_u *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPU5952PU5952rB)(((atPS5884uszrPU5952)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
RegValue_u *lastPS5884rPU5952(RegValueList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty RegValueList")));
    return ((atPS5884uszrPU5952)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS5884PS5884rN(RegValueList_s *this, RegValueList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS5884U5952rN)((this), (*((atPS5884uszrPU5952)((other), (i))))));
    }

    ((dropPS5884rN)((other)));
}
none dropPS5884rN(RegValueList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS5884rN(RegValueList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS0409uszrN(LLVMBasicBlockList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMBasicBlock_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMBasicBlockList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS0409S7469rN(LLVMBasicBlockList_s *this, LLVMBasicBlock_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMBasicBlock_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMBasicBlockList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMBasicBlock_s *popPS0409rPS7469(LLVMBasicBlockList_s *this) {
    LLVMBasicBlock_s *l = ((lastPS0409rPS7469)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMBasicBlock_s *atPS0409uszrPS7469(LLVMBasicBlockList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMBasicBlockList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMBasicBlockList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS0409PS7469rB(LLVMBasicBlockList_s *this, LLVMBasicBlock_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS7469PS7469rB)(((atPS0409uszrPS7469)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMBasicBlock_s *lastPS0409rPS7469(LLVMBasicBlockList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMBasicBlockList")));
    return ((atPS0409uszrPS7469)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS0409PS0409rN(LLVMBasicBlockList_s *this, LLVMBasicBlockList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS0409S7469rN)((this), (*((atPS0409uszrPS7469)((other), (i))))));
    }

    ((dropPS0409rN)((other)));
}
none dropPS0409rN(LLVMBasicBlockList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS0409rN(LLVMBasicBlockList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS8201uszrN(LLVMValueList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(LLVMValue_s)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMValueList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS8201S8925rN(LLVMValueList_s *this, LLVMValue_s element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(LLVMValue_s))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in LLVMValueList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
LLVMValue_s *popPS8201rPS8925(LLVMValueList_s *this) {
    LLVMValue_s *l = ((lastPS8201rPS8925)((this)));
    (((this)->length) = (((this)->length) - ((usize)(1llu))));
    return (l);
}
LLVMValue_s *atPS8201uszrPS8925(LLVMValueList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in LLVMValueList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in LLVMValueList.at")));
    return (&((((this)->elements))[(index)]));
}
bool containsPS8201PS8925rB(LLVMValueList_s *this, LLVMValue_s *element) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((equalsPS8925PS8925rB)(((atPS8201uszrPS8925)((this), (i))), (element))) {
            return (true);
        }
    }

    return (false);
}
LLVMValue_s *lastPS8201rPS8925(LLVMValueList_s *this) {
    ((assertBPcrN)((((this)->length) != ((usize)(0llu))), ("Called last() on empty LLVMValueList")));
    return ((atPS8201uszrPS8925)((this), (((this)->length) - ((usize)(1llu)))));
}
none extendPS8201PS8201rN(LLVMValueList_s *this, LLVMValueList_s *other) {
    for (usize i = ((usize)(0llu)); ((i) < ((other)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS8201S8925rN)((this), (*((atPS8201uszrPS8925)((other), (i))))));
    }

    ((dropPS8201rN)((other)));
}
none dropPS8201rN(LLVMValueList_s *this) {
    (((free))(((this)->elements)));
    (((this)->elements) = (NULL));
    (((this)->length) = ((usize)(0llu)));
    (((this)->capacity) = ((usize)(0llu)));
}
none clearPS8201rN(LLVMValueList_s *this) { (((this)->length) = ((usize)(0llu))); }
none initBlankPS4113uszrN(UsizeList_s *this, usize newCap) {
    if (((this)->elements) != (NULL))
        (((free))(((this)->elements)));
    (((this)->elements) = (((calloc))((newCap), (sizeof(usize)))));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UsizeList.initBlank")));
    (((this)->capacity) = (newCap));
    (((this)->length) = (newCap));
}
none pushPS4113uszrN(UsizeList_s *this, usize element) {
    if (((this)->length) >= ((this)->capacity)) {
        usize newCap = (((this)->capacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(32llu)));
        (((this)->elements) = (((realloc))(((this)->elements), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->elements) != (NULL)), ("Could not allocate memory in UsizeList.push")));
        (((this)->capacity) = (newCap));
    }

    (((((this)->elements))[((this)->length)]) = (element));
    (((this)->length) = (((this)->length) + ((usize)(1llu))));
}
usize *atPS4113uszrPusz(UsizeList_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->length)), ("Out of bounds access in UsizeList.at")));
    ((assertBPcrN)((((this)->elements) != (NULL)), ("Element pointer is NULL in UsizeList.at")));
    return (&((((this)->elements))[(index)]));
}
ImportLookup_s *getPS3606PS6218rPS6218(ImportLookupList_s *this, ImportLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ImportLookup_s *v = ((atPS3606uszrPS6218)((this), (i)));
        if ((equalsPS6218PS6218rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS3606PS6218rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
StructLookup_s *getPS7392PS4228rPS4228(StructLookupList_s *this, StructLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        StructLookup_s *v = ((atPS7392uszrPS4228)((this), (i)));
        if ((equalsPS4228PS4228rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS7392PS4228rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
UnionLookup_s *getPS4836PS1592rPS1592(UnionLookupList_s *this, UnionLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        UnionLookup_s *v = ((atPS4836uszrPS1592)((this), (i)));
        if ((equalsPS1592PS1592rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS4836PS1592rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
ModuleLookup_s *getPS5121PS0997rPS0997(ModuleLookupList_s *this, ModuleLookup_s *val) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ModuleLookup_s *v = ((atPS5121uszrPS0997)((this), (i)));
        if ((equalsPS0997PS0997rB)((v), (val))) {
            return (v);
        }
    }

    ((assertBPcrN)(((containsPS5121PS0997rB)((this), (val))), ("Expected to find element in get()")));
    ((unreachablePcrN)(("contains(this, val) is true")));
}
none toggleIgnoringNodesrN(none) { ((ignoringNodes) = (!(ignoringNodes))); }
String_s mangleVariableNameBuszPS6070rS0540(bool global, usize fileID, Token_s *name) {
    if ((fileID) == (NODE_ID_OFFSET)) {
        return ((toStringPS7720rS0540)((&((name)->content))));
    }

    else {
        String_s mangledName = ((String_s){0});
        ((pushNumberPS0540uszrN)((&(mangledName)), (fileID)));
        ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&((name)->content))));
        return (mangledName);
    }
}
String_s mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540(TLIParent_s parent, Token_s *name, ParamContext_s *params, ParsedTypeNode_s *retType, bool isComptime, ParsedAttributeList_s *attrs) {
    String_s mangledName = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((attrs)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedAttribute_u a = ((((attrs)->elements))[(i)]);
        bool succ_9952_ = true;

        {
            ParsedAttribute_u tmp_16135_ = (a);
            succ_9952_ &= (tmp_16135_.tag == 1);
            Token_s *name = &tmp_16135_.payload.variant1._0;
            succ_9952_ &= true;

            if (succ_9952_) {
                return ((toStringPS7720rS0540)((&((*name).content))));
            }
        }

        bool succ_9954_ = true;

        {
            ParsedAttribute_u tmp_16137_ = (a);
            succ_9954_ &= (tmp_16137_.tag == 5);

            if (succ_9954_) {
                return ((toStringPS7720rS0540)((&((name)->content))));
            }
        }
    }

    while (!((parent).isFile)) {
        ParsedModule_s *mod = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&(((mod)->name).content))));
        ((pushCharPS0540crN)((&(mangledName)), ('.')));
        ((parent) = ((mod)->parent));
    }

    ((pushSubStrPS0540PS7720rN)((&(mangledName)), (&((name)->content))));
    for (usize i = ((usize)(0llu)); ((i) < ((params)->paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *typeNode = ((getTypeAtIndexPS9803uszrPS1372)((params), (i)));
        ((assertBPcrN)(((isSuccessPU9661rB)((&((typeNode)->typeState)))), ("Expected valid parameter type for mangling")));
        Type_u *typ = ((getTypePU9661rPU5175)((&((typeNode)->typeState))));
        String_s _typ = ((getMangledNamePU5175rS0540)((typ)));
        ((pushStringPS0540PS0540rN)((&(mangledName)), (&(_typ))));
        ((dropPS0540rN)((&(_typ))));
    }

    ((pushCharPS0540crN)((&(mangledName)), ('r')));
    if ((retType) != (NULL)) {
        ((assertBPcrN)(((isSuccessPU9661rB)((&((retType)->typeState)))), ("Expected valid return type for mangling")));
        Type_u *typ = ((getTypePU9661rPU5175)((&((retType)->typeState))));
        String_s _typ = ((getMangledNamePU5175rS0540)((typ)));
        ((pushStringPS0540PS0540rN)((&(mangledName)), (&(_typ))));
        ((dropPS0540rN)((&(_typ))));
    }

    else {
        ((pushCharPS0540crN)((&(mangledName)), ('n')));
    }

    return (mangledName);
}
ParsedFile_s *getFileByFileNameS7720rPS1892(SubStr_s name) {
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        if ((endsWithPS7720PS7720rB)((&((file)->origin)), (&(name)))) {
            return (file);
        }
    }

    return (NULL);
}
bool getFileByFilePathS7720PuszrB(SubStr_s path, usize *fileID) {
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        if ((equalsPS7720PS7720rB)((&((file)->origin)), (&(path)))) {
            ((*(fileID)) = (i));
            return (true);
        }
    }

    return (false);
}
bool equalsPU4360PU4360rB(ParsedAttribute_u *this, ParsedAttribute_u *other) { ((unreachablePcrN)(("ParsedAttribute.equals is not implemented yet"))); }
Config_u newConfigS6070S6070rU7467(Token_s t, Token_s value) {
    SubStr_s tmp_77564 = (((BUILD_A_KEYWORDPcrS7720)(("static"))));
    SubStr_s tmp_77580 = (((BUILD_A_KEYWORDPcrS7720)(("dynamic"))));
    SubStr_s tmp_77596 = (((BUILD_A_KEYWORDPcrS7720)(("libpath"))));
    SubStr_s tmp_77612 = (((BUILD_A_KEYWORDPcrS7720)(("linker"))));

    if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77564))) {
        return ((Config_u){.tag = 1, .payload = {.variant1 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77580))) {
        return ((Config_u){.tag = 2, .payload = {.variant2 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77596))) {
        return ((Config_u){.tag = 3, .payload = {.variant3 = {._0 = (value)}}});
    }

    else if ((equalsPS7720PS7720rB)((&((t).content)), (&tmp_77612))) {
        return ((Config_u){.tag = 4, .payload = {.variant4 = {._0 = (value)}}});
    }

    else {
        return ((Config_u){.tag = 0, .payload = {.variant0 = {._0 = (value)}}});
    }
}
ParsedConfig_s *newParsedConfigS8951S1575rPS0890(Span_s span, ConfigList_s cfgs) {
    ((pushPS9153S0890rN)((&(configs)), ((ParsedConfig_s){.ignored = (ignoringNodes), .span = (span), .configs = (cfgs)})));
    return ((lastPS9153rPS0890)((&(configs))));
}
usize getIDPS0890rusz(ParsedConfig_s *this) { return ((indexOfPS9153PS0890rusz)((&(configs)), (this))); }
ParsedTopLevelItem_s *asTLIPS0890rPS1038(ParsedConfig_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_CONFIG), ((getIDPS0890rusz)((this))))); }
usize getIDPS1892rusz(ParsedFile_s *this) { return ((indexOfPS9483PS1892rusz)((&(files)), (this))); }
none getLineAndColumnFromSpanPS1892PS8951PuszPuszrN(ParsedFile_s *this, Span_s *span, usize *line, usize *column) {
    usize l = ((usize)(1llu));
    usize c = ((usize)(1llu));
    usize p = ((usize)(0llu));
    while ((p) < ((span)->start)) {
        char _c = (((((this)->src).start))[(p)]);
        if ((_c) == ('\n')) {
            ((c) = ((usize)(1llu)));
            ((l) = ((l) + ((usize)(1llu))));
        }

        else {
            ((c) = ((c) + ((usize)(1llu))));
        }

        ((p) = ((p) + ((usize)(1llu))));
    }

    ((*(line)) = (l));
    ((*(column)) = (c));
}
ParsedFile_s *newParsedFileS7720S7720rPS1892(SubStr_s origin, SubStr_s src) {
    ((pushPS9483S1892rN)((&(files)), ((ParsedFile_s){.ignored = (ignoringNodes), .origin = (origin), .src = (src)})));
    return ((lastPS9483rPS1892)((&(files))));
}
bool equalsPS5656PS5656rB(TLIParent_s *this, TLIParent_s *other) { return ((((this)->isFile) == ((other)->isFile)) && (((this)->id) == ((other)->id))); }
ParsedStructDecl_s *asStructPS1038rPS5521(ParsedTopLevelItem_s *this) {
    ((assertBPcrN)((((this)->kind) == (TLI_STRUCT_DECL)), ("ParsedTopLevelItem.asStruct() called on non-struct TLI")));
    return ((atPS2168uszrPS5521)((&(structDecls)), ((this)->nodeID)));
}
ParsedUnionDecl_s *asUnionPS1038rPS0997(ParsedTopLevelItem_s *this) {
    ((assertBPcrN)((((this)->kind) == (TLI_UNION_DECL)), ("ParsedTopLevelItem.asUnion() called on non-union TLI")));
    return ((atPS4268uszrPS0997)((&(unionDecls)), ((this)->nodeID)));
}
usize getIDPS1038rusz(ParsedTopLevelItem_s *this) { return ((indexOfPS9029PS1038rusz)((&(topLevelItems)), (this))); }
ParsedTopLevelItem_s *newParsedTopLevelItemS8951uszuszrPS1038(Span_s span, usize kind, usize nodeID) {
    ((pushPS9029S1038rN)((&(topLevelItems)),
                         ((ParsedTopLevelItem_s){.ignored = (ignoringNodes), .kind = (kind), .span = (span), .nodeID = (nodeID), .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS9029rPS1038)((&(topLevelItems))));
}
DLL_s *newDLLS0540S9457rPS3633(String_s path, Handle_s handle) {
    ((pushPS8168S3633rN)((&(dlls)), ((DLL_s){.path = (path), .handle = (handle)})));
    return ((lastPS8168rPS3633)((&(dlls))));
}
DLL_s *dllNotFoundrPS3633(none) { return ((DLL_s *)((DLL_NOT_FOUND))); }
DLL_s *dllNoSuchFunctionrPS3633(none) { return ((DLL_s *)((DLL_NO_SUCH_FUNCTION))); }
bool isNullPS3633rB(DLL_s *dll) {
    if ((dll) == (NULL))
        return (true);
    if ((dll) == ((dllNotFoundrPS3633)()))
        return (true);
    if ((dll) == ((dllNoSuchFunctionrPS3633)()))
        return (true);
    return ((isNullS9457rB)(((dll)->handle)));
}
usize getIDPS3633rusz(DLL_s *this) { return ((indexOfPS8168PS3633rusz)((&(dlls)), (this))); }
bool equalsPS1882PS1882rB(ParsedModule_s *this, ParsedModule_s *other) {
    if ((equalsPS8951PS8951rB)((&((this)->span)), (&((other)->span))))
        return (true);
    if (!((equalsPS7720PS7720rB)((&(((this)->name).content)), (&(((other)->name).content)))))
        return (false);
    return ((equalsPS5656PS5656rB)((&((this)->parent)), (&((other)->parent))));
}
UsizeList_s getConfigsPS1882rS4113(ParsedModule_s *this) {
    UsizeList_s list = ((UsizeList_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (((this)->tlis).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&((this)->tlis)), (i))))))->kind) == (TLI_CONFIG)) {
            ((pushPS4113uszrN)((&(list)), (*((atPS4113uszrPusz)((&((this)->tlis)), (i))))));
        }
    }

    return (list);
}
usize getIDPS1882rusz(ParsedModule_s *this) { return ((indexOfPS7393PS1882rusz)((&(modules)), (this))); }
ParsedTopLevelItem_s *asTLIPS1882rPS1038(ParsedModule_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_MOD_DECL), ((getIDPS1882rusz)((this))))); }
ParsedFile_s *getParentFilePS1882rPS1892(ParsedModule_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
String_s getFullNamePS1882rS0540(ParsedModule_s *this) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushCharPS0540crN)((&(_s)), (':')));
            ((pushCharPS0540crN)((&(_s)), (':')));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushCharPS0540crN)((&(s)), (':')));
        ((pushCharPS0540crN)((&(s)), (':')));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
ParsedModule_s *newParsedModuleS5656S8951S6070S4113rPS1882(TLIParent_s parent, Span_s span, Token_s name, UsizeList_s tlis) {
    ((pushPS7393S1882rN)((&(modules)), ((ParsedModule_s){.ignored = (ignoringNodes), .parent = (parent), .name = (name), .span = (span), .tlis = (tlis)})));
    return ((lastPS7393rPS1882)((&(modules))));
}
usize getIDPS5521rusz(ParsedStructDecl_s *this) { return ((indexOfPS2168PS5521rusz)((&(structDecls)), (this))); }
ParsedTopLevelItem_s *asTLIPS5521rPS1038(ParsedStructDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_STRUCT_DECL), ((getIDPS5521rusz)((this))))); }
usize getFieldIndexPS5521PS7720rusz(ParsedStructDecl_s *this, SubStr_s *name) { return ((getFieldIndexPS7871PS7720rusz)((&((this)->context)), (name))); }
usize getFieldOffsetPS5521PS7720Brusz(ParsedStructDecl_s *this, SubStr_s *name, bool inBits) {
    usize offset = ((usize)(0llu));
    usize _idc = ((usize)(0llu));
    ((getFieldOffsetAndSizePS5521uszPuszPuszBrN)((this), ((getFieldIndexPS5521PS7720rusz)((this), (name))), (&(offset)), (&(_idc)), (inBits)));
    return (offset);
}
none getFieldOffsetAndSizePS5521uszPuszPuszBrN(ParsedStructDecl_s *this, usize index, usize *offset, usize *size, bool inBits) {
    usize o = ((usize)(0llu));
    usize (*sizeFn)(Type_u *) = (getSizeInBytesPU5175rusz);
    usize (*alignFn)(Type_u *) = (getAlignmentInBytesPU5175rusz);
    if (inBits) {
        ((sizeFn) = (getSizeInBitsPU5175rusz));
        ((alignFn) = (getAlignmentInBitsPU5175rusz));
    }

    for (usize i = ((usize)(0llu)); ((i) < (((this)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedTypeNode_s *f1 = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((this)->context)), (i)));
        Type_u *f = ((getTypePU9661rPU5175)((&((f1)->typeState))));
        usize s = ((sizeFn)((f)));
        if ((i) == (index)) {
            ((*(offset)) = (o));
            ((*(size)) = (s));
            return;
        }

        if ((i) != ((((this)->context).fieldLength) - ((usize)(1llu)))) {
            ParsedTypeNode_s *f2 = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((this)->context)), ((i) + ((usize)(1llu)))));
            Type_u *nf = ((getTypePU9661rPU5175)((&((f2)->typeState))));
            ((o) = ((nextMultipleOfuszuszrusz)(((o) + (s)), ((alignFn)((nf))))));
        }
    }

    ((unreachablePcrN)(("Expected to find field offset and size")));
}
ParsedFile_s *getParentFilePS5521rPS1892(ParsedStructDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
ParsedModule_s *getParentModulePS5521rPS1882(ParsedStructDecl_s *this) {
    ((assertBPcrN)((!(((this)->parent).isFile)), ("getParentModule called on struct in a file scope")));
    return ((atPS7393uszrPS1882)((&(modules)), ((usize)((((this)->parent).id)))));
}
String_s getFullNamePS5521PcrS0540(ParsedStructDecl_s *this, char *split) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushStrPS0540PcrN)((&(_s)), (split)));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushStrPS0540PcrN)((&(s)), (split)));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
String_s getFullNamePS5521rS0540(ParsedStructDecl_s *this) { return ((getFullNamePS5521PcrS0540)((this), ("::"))); }
ParsedStructDecl_s *newParsedStructDeclS5656S8951S6070rPS5521(TLIParent_s parent, Span_s span, Token_s name) {
    ((pushPS2168S5521rN)((&(structDecls)), ((ParsedStructDecl_s){.ignored = (ignoringNodes),
                                                                 .parent = (parent),
                                                                 .name = (name),
                                                                 .span = (span),
                                                                 .context = ((StructContext_s){0}),
                                                                 .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS2168rPS5521)((&(structDecls))));
}
usize getAlignmentInBytesPS0997rusz(ParsedUnionDecl_s *this) {
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Can only get alignment of valid unions")));
    usize maxAlign = ((usize)(1llu));
    if ((((this)->variants).length) >= ((usize)(256llu)))
        ((maxAlign) = ((usize)(2llu)));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        bool succ_10085_ = true;
        bool succ_10083_ = true;

        tuple_1044 tmp_16372_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
        succ_10083_ = tmp_16372_._0 == true;
        succ_10085_ &= succ_10083_;
        ParsedTypeNodeList_s **fields = &tmp_16372_._1;
        succ_10085_ &= true;
        if (!succ_10085_) {
            continue;
        };
        for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
            ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type")));
            Type_u *tt = ((getTypePU9661rPU5175)((&((field)->typeState))));
            usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
            if ((_a) > (maxAlign))
                ((maxAlign) = (_a));
        }
    }

    return (maxAlign);
}
usize getSizeInBytesPS0997rusz(ParsedUnionDecl_s *this) {
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Can only get size of valid unions")));
    ((assertBPcrN)(((((this)->variants).length) < ((usize)(65536llu))), ("getSize expects the Union tag to fit into at most two bytes")));
    usize maxSize = ((usize)(0llu));
    usize maxAlign = ((usize)(1llu));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        usize size = ((usize)(1llu));
        usize align = ((usize)(1llu));
        if ((((this)->variants).length) >= ((usize)(256llu))) {
            ((size) = ((usize)(2llu)));
            ((align) = ((usize)(2llu)));
        }

        bool succ_10106_ = true;
        bool succ_10104_ = true;

        {
            tuple_1044 tmp_16417_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_10104_ = tmp_16417_._0 == true;
            succ_10106_ &= succ_10104_;
            ParsedTypeNodeList_s **fields = &tmp_16417_._1;
            succ_10106_ &= true;

            if (succ_10106_) {
                if (((*fields)->length) > ((usize)(0llu))) {
                    ParsedTypeNode_s *next = ((((*fields)->elements))[((usize)(0llu))]);
                    Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                    ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                }

                for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *field = ((((*fields)->elements))[(j)]);
                    ((assertBPcrN)(((isSuccessPU9661rB)((&((field)->typeState)))), ("Expected valid field type")));
                    Type_u *tt = ((getTypePU9661rPU5175)((&((field)->typeState))));
                    ((size) = ((size) + ((getSizeInBytesPU5175rusz)((tt)))));
                    usize _a = ((getAlignmentInBytesPU5175rusz)((tt)));
                    if ((_a) > (align))
                        ((align) = (_a));
                    if ((j) != (((*fields)->length) - ((usize)(1llu)))) {
                        ParsedTypeNode_s *next = ((((*fields)->elements))[((j) + ((usize)(1llu)))]);
                        Type_u *nextType = ((getTypePU9661rPU5175)((&((next)->typeState))));
                        ((size) = ((nextMultipleOfuszuszrusz)((size), ((getAlignmentInBytesPU5175rusz)((nextType))))));
                    }
                }
            }
        }

        if ((size) > (maxSize))
            ((maxSize) = (size));
        if ((align) > (maxAlign))
            ((maxAlign) = (align));
    }

    ((maxSize) = ((nextMultipleOfuszuszrusz)((maxSize), (maxAlign))));
    return (maxSize);
}
usize getIDPS0997rusz(ParsedUnionDecl_s *this) { return ((indexOfPS4268PS0997rusz)((&(unionDecls)), (this))); }
ParsedTopLevelItem_s *asTLIPS0997rPS1038(ParsedUnionDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_UNION_DECL), ((getIDPS0997rusz)((this))))); }
bool resolveVariantByNamePS0997PS6070PPS3506rB(ParsedUnionDecl_s *this, Token_s *name, ParsedUnionVariant_s **out) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((this)->variants)), (i))));
        if ((equalsPS7720PS7720rB)((&(((variant)->name).content)), (&((name)->content)))) {
            ((*(out)) = (variant));
            return (true);
        }
    }

    return (false);
}
usize getVariantTagPS0997PS3506rusz(ParsedUnionDecl_s *this, ParsedUnionVariant_s *variant) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((*((atPS0030uszrPPS3506)((&((this)->variants)), (i)))) == (variant)) {
            return (i);
        }
    }

    ((unreachablePcrN)(("getVariantTag() expected to find variant")));
}
ParsedFile_s *getParentFilePS0997rPS1892(ParsedUnionDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
String_s getFullNamePS0997PcrS0540(ParsedUnionDecl_s *this, char *split) {
    String_s s = ((String_s){0});
    TLIParent_s parent = ((this)->parent);
    while (!((parent).isFile)) {
        ParsedModule_s *m = ((atPS7393uszrPS1882)((&(modules)), ((usize)(((parent).id)))));
        String_s _s = ((String_s){0});
        ((pushSubStrPS0540PS7720rN)((&(_s)), (&(((m)->name).content))));
        if (((s).length) != ((usize)(0llu))) {
            ((pushStrPS0540PcrN)((&(_s)), (split)));
        }

        ((pushStringPS0540PS0540rN)((&(_s)), (&(s))));
        ((dropPS0540rN)((&(s))));
        ((s) = (_s));
        ((parent) = ((m)->parent));
    }

    if (((s).length) != ((usize)(0llu))) {
        ((pushStrPS0540PcrN)((&(s)), (split)));
    }

    ((pushSubStrPS0540PS7720rN)((&(s)), (&(((this)->name).content))));
    return (s);
}
String_s getFullNamePS0997rS0540(ParsedUnionDecl_s *this) { return ((getFullNamePS0997PcrS0540)((this), ("::"))); }
ParsedUnionDecl_s *newParsedUnionDeclS5656S8951S6070rPS0997(TLIParent_s parent, Span_s span, Token_s name) {
    ((pushPS4268S0997rN)((&(unionDecls)), ((ParsedUnionDecl_s){.ignored = (ignoringNodes), .parent = (parent), .name = (name), .span = (span)})));
    return ((lastPS4268rPS0997)((&(unionDecls))));
}
usize getIDPS3506rusz(ParsedUnionVariant_s *this) { return ((indexOfPS4249PS3506rusz)((&(unionVariants)), (this))); }
tuple_1044 get_fieldsPS3506rT_BPS6760(ParsedUnionVariant_s *this) {
    bool succ_10135_ = true;
    bool succ_10140_ = true;

    ParsedUnionVariantData_u *tmp_16473_ = (&((this)->data));
    {
        succ_10135_ &= (tmp_16473_->tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16473_->payload.variant1._0;
        succ_10135_ &= true;
        if (succ_10135_) {
            {
                return ((tuple_1044){(true), (&(*fields))});
            }
            goto after_16473;
        }
    }
    {
        succ_10140_ &= (tmp_16473_->tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16473_->payload.variant2._0;
        succ_10140_ &= true;
        TokenList_s *names = &tmp_16473_->payload.variant2._1;
        succ_10140_ &= true;
        if (succ_10140_) {
            {
                return ((tuple_1044){(true), (&(*fields))});
            }
            goto after_16473;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16473;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16473:
    (void)0; // error: label at end of compound statement is a C23 extension
    return ((tuple_1044){(false), (NULL)});
}
Type_u *toTypePS3506rPU5175(ParsedUnionVariant_s *this) {
    ParsedStructDecl_s *decl = ((newParsedStructDeclS5656S8951S6070rPS5521)(((this)->parent), ((this)->span), ((this)->name)));
    bool succ_10146_ = true;
    bool succ_10149_ = true;
    bool succ_10158_ = true;

    ParsedUnionVariantData_u tmp_16493_ = ((this)->data);
    {
        succ_10146_ &= (tmp_16493_.tag == 0);
        if (succ_10146_) {
            {
            }
            goto after_16493;
        }
    }
    {
        succ_10149_ &= (tmp_16493_.tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16493_.payload.variant1._0;
        succ_10149_ &= true;
        if (succ_10149_) {
            {
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s s = ((String_s){0});
                    ((pushNumberPS0540uszrN)((&(s)), (i)));
                    SubStr_s tmp_78784 = ((asSubStrPS0540rS7720)((&(s))));

                    Token_s name = ((newTokenuszPS7720uszuszrS6070)(((usize)((((this)->parent).id))), (&tmp_78784), ((usize)(0llu)), (TOKEN_IDENT)));
                    ((addFieldPS7871S6070PS1372rN)((&((decl)->context)), (name), ((((*fields).elements))[(i)])));
                }
            }
            goto after_16493;
        }
    }
    {
        succ_10158_ &= (tmp_16493_.tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16493_.payload.variant2._0;
        succ_10158_ &= true;
        TokenList_s *names = &tmp_16493_.payload.variant2._1;
        succ_10158_ &= true;
        if (succ_10158_) {
            {
                ((assertBPcrN)((((*fields).length) == ((*names).length)), ("ParsedUnionVariant.toType: struct count mismatch")));
                for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ((addFieldPS7871S6070PS1372rN)((&((decl)->context)), ((((*names).elements))[(i)]), ((((*fields).elements))[(i)])));
                }
            }
            goto after_16493;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_16493;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16493:
    (void)0; // error: label at end of compound statement is a C23 extension
    Type_u *typ = ((wrapU5175rPU5175)(((Type_u){.tag = 7, .payload = {.variant7 = {._0 = (decl)}}})));
    (((decl)->typeState) = ((TCState_u){.tag = 3, .payload = {.variant3 = {._0 = (typ)}}}));
    return (typ);
}
usize getFieldIndexPS3506PS7720rusz(ParsedUnionVariant_s *this, SubStr_s *name) {
    bool succ_10166_ = true;

    {
        ParsedUnionVariantData_u *tmp_16502_ = (&((this)->data));
        succ_10166_ &= (tmp_16502_->tag == 2);
        succ_10166_ &= true;
        TokenList_s *names = &tmp_16502_->payload.variant2._1;
        succ_10166_ &= true;

        if (succ_10166_) {
            for (usize i = ((usize)(0llu)); ((i) < ((*names).length)); ((i) = ((i) + ((usize)(1llu))))) {
                if ((equalsPS7720PS7720rB)((&(((((*names).elements))[(i)]).content)), (name)))
                    return (i);
            }
        }
    }

    ((unreachablePcrN)(("ParsedUnionVariant.getFieldIndex: Expected to find field with name")));
}
none getFieldOffsetAndSizePS3506uszPuszPuszBrN(ParsedUnionVariant_s *this, usize index, usize *offset, usize *size, bool inBits) {
    ParsedTypeNodeList_s fields = ((ParsedTypeNodeList_s){0});
    bool succ_10173_ = true;
    bool succ_10177_ = true;
    bool succ_10180_ = true;

    ParsedUnionVariantData_u tmp_16513_ = ((this)->data);
    {
        succ_10173_ &= (tmp_16513_.tag == 0);
        if (succ_10173_) {
            {
                ((unreachablePcrN)(("ParsedUnionVariant.getFieldOffsetAndSize called on empty union variant")));
            }
            goto after_16513;
        }
    }
    {
        succ_10177_ &= (tmp_16513_.tag == 2);
        ParsedTypeNodeList_s *_fields = &tmp_16513_.payload.variant2._0;
        succ_10177_ &= true;
        succ_10177_ &= true;
        if (succ_10177_) {
            {
                ((fields) = (*_fields));
            }
            goto after_16513;
        }
    }
    {
        succ_10180_ &= (tmp_16513_.tag == 1);
        ParsedTypeNodeList_s *_fields = &tmp_16513_.payload.variant1._0;
        succ_10180_ &= true;
        if (succ_10180_) {
            {
                ((fields) = (*_fields));
            }
            goto after_16513;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_16513;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16513:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((index) < ((fields).length)), ("getFieldOffsetAndSize: Out-of-bounds")));
    ((assertBPcrN)((((fields).length) > ((usize)(0llu))), ("getFieldOffsetAndSize: Empty variant")));
    usize (*sizeFn)(Type_u *) = (getSizeInBytesPU5175rusz);
    usize (*alignFn)(Type_u *) = (getAlignmentInBytesPU5175rusz);
    if (inBits) {
        ((sizeFn) = (getSizeInBitsPU5175rusz));
        ((alignFn) = (getAlignmentInBitsPU5175rusz));
    }

    usize o = ((usize)(0llu));
    if ((*(offset)) != ((usize)(0llu))) {
        Type_u *nf = ((getTypePU9661rPU5175)((&(((((fields).elements))[((usize)(0llu))])->typeState))));
        ((o) = ((nextMultipleOfuszuszrusz)((*(offset)), ((alignFn)((nf))))));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *f = ((getTypePU9661rPU5175)((&(((((fields).elements))[(i)])->typeState))));
        usize s = ((sizeFn)((f)));
        if ((i) == (index)) {
            ((*(offset)) = (o));
            ((*(size)) = (s));
            return;
        }

        ((o) = ((o) + (s)));
        if ((i) != (((fields).length) - ((usize)(1llu)))) {
            Type_u *nf = ((getTypePU9661rPU5175)((&(((((fields).elements))[((i) + ((usize)(1llu)))])->typeState))));
            ((o) = ((nextMultipleOfuszuszrusz)((o), ((alignFn)((nf))))));
        }
    }

    ((unreachablePcrN)(("Expected to find field offset and size")));
}
none addFieldPS3506PS1372rN(ParsedUnionVariant_s *this, ParsedTypeNode_s *field) {
    bool succ_10199_ = true;

    ParsedUnionVariantData_u *tmp_16544_ = (&((this)->data));
    succ_10199_ &= (tmp_16544_->tag == 1);
    ParsedTypeNodeList_s *fields = &tmp_16544_->payload.variant1._0;
    succ_10199_ &= true;
    if (!succ_10199_) {
        ((unreachablePcrN)(("ParsedUnionVariant.addField called on non-tuple")));
    };
    ((pushPS6760PS1372rN)((&(*fields)), (field)));
}
Type_u *getTypeAtIndexPS3506uszrPU5175(ParsedUnionVariant_s *this, usize index) {
    ParsedTypeNode_s *node = (NULL);
    bool succ_10205_ = true;
    bool succ_10210_ = true;

    ParsedUnionVariantData_u *tmp_16555_ = (&((this)->data));
    {
        succ_10205_ &= (tmp_16555_->tag == 1);
        ParsedTypeNodeList_s *fields = &tmp_16555_->payload.variant1._0;
        succ_10205_ &= true;
        if (succ_10205_) {
            {
                ((assertBPcrN)(((index) < ((*fields).length)), ("Out of bounds access in ParsedUnionVariant.getTypeAtIndex")));
                ((node) = ((((*fields).elements))[(index)]));
            }
            goto after_16555;
        }
    }
    {
        succ_10210_ &= (tmp_16555_->tag == 2);
        ParsedTypeNodeList_s *fields = &tmp_16555_->payload.variant2._0;
        succ_10210_ &= true;
        succ_10210_ &= true;
        if (succ_10210_) {
            {
                ((assertBPcrN)(((index) < ((*fields).length)), ("Out of bounds access in ParsedUnionVariant.getTypeAtIndex")));
                ((node) = ((((*fields).elements))[(index)]));
            }
            goto after_16555;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("ParsedUnionVariant.getTypeAtIndex")));
            }
            goto after_16555;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16555:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((assertBPcrN)(((isSuccessPU9661rB)((&((node)->typeState)))), ("Expected valid TypeNode state in ParsedUnionVariant.getTypeAtIndex")));
    return ((getTypePU9661rPU5175)((&((node)->typeState))));
}
none addNamedFieldPS3506S6070PS1372rN(ParsedUnionVariant_s *this, Token_s name, ParsedTypeNode_s *typ) {
    bool succ_10216_ = true;

    ParsedUnionVariantData_u *tmp_16559_ = (&((this)->data));
    succ_10216_ &= (tmp_16559_->tag == 2);
    ParsedTypeNodeList_s *fields = &tmp_16559_->payload.variant2._0;
    succ_10216_ &= true;
    TokenList_s *names = &tmp_16559_->payload.variant2._1;
    succ_10216_ &= true;
    if (!succ_10216_) {
        ((unreachablePcrN)(("ParsedUnionVariant.addNamedField called on non-struct")));
    };
    ((assertBPcrN)((((*fields).length) == ((*names).length)), ("ParsedUnionVariant.addNamedField: Unbalanced field and name lists")));
    ((pushPS6760PS1372rN)((&(*fields)), (typ)));
    ((pushPS9938S6070rN)((&(*names)), (name)));
}
bool checkForDuplicateNamePS3506PS6070PPS6070rB(ParsedUnionVariant_s *this, Token_s *name, Token_s **dupl) {
    bool succ_10221_ = true;

    ParsedUnionVariantData_u *tmp_16564_ = (&((this)->data));
    succ_10221_ &= (tmp_16564_->tag == 2);
    succ_10221_ &= true;
    TokenList_s *names = &tmp_16564_->payload.variant2._1;
    succ_10221_ &= true;
    if (!succ_10221_) {
        ((unreachablePcrN)(("ParsedUnionVariant.checkForDuplicateName called on non-struct")));
    };
    bool found = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((*names).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s *n = (&((((*names).elements))[(i)]));
        if ((equalsPS7720PS7720rB)((&((n)->content)), (&((name)->content)))) {
            if (found) {
                ((*(dupl)) = (n));
                return (true);
            }

            ((found) = (true));
        }
    }

    return (false);
}
ParsedUnionVariant_s *newParsedUnionVariantS5656S8951S6070U3836rPS3506(TLIParent_s parent, Span_s span, Token_s name, ParsedUnionVariantData_u data) {
    ((pushPS4249S3506rN)((&(unionVariants)), ((ParsedUnionVariant_s){.ignored = (ignoringNodes), .parent = (parent), .span = (span), .name = (name), .data = (data)})));
    return ((lastPS4249rPS3506)((&(unionVariants))));
}
bool hasAttributePS4904U4360rB(ParsedFuncDecl_s *this, ParsedAttribute_u attr) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == ((tagAnyru8)((&(attr)))))
            return (true);
    }

    return (false);
}
usize getIDPS4904rusz(ParsedFuncDecl_s *this) { return ((indexOfPS4111PS4904rusz)((&(funcDecls)), (this))); }
bool isExternPS4904rB(ParsedFuncDecl_s *this) {
    for (usize i = ((usize)(0llu)); ((i) < (((this)->attrs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedAttribute_u tmp_79233 = (((ParsedAttribute_u){.tag = 1, .payload = {0}}));

        if (((tagAnyru8)((&(((((this)->attrs).elements))[(i)])))) == (((tagAnyru8)((&tmp_79233)))))
            return (true);
    }

    return (false);
}
ParsedFile_s *getParentFilePS4904rPS1892(ParsedFuncDecl_s *this) { return ((atPS9483uszrPS1892)((&(files)), (((this)->span).file))); }
ParsedModule_s *getParentModulePS4904rPS1882(ParsedFuncDecl_s *this) {
    ((assertBPcrN)((!(((this)->parent).isFile)), ("getParentModule called on function in a file scope")));
    return ((atPS7393uszrPS1882)((&(modules)), ((usize)((((this)->parent).id)))));
}
String_s getMangledNamePS4904rS0540(ParsedFuncDecl_s *this) {
    if ((this)->ignored)
        return ((toStringPS7720rS0540)((&(((this)->name).content))));
    ((assertBPcrN)(((isSuccessPU9661rB)((&((this)->typeState)))), ("Mangling can only be done after type checks")));
    return ((mangleFunctionNameS5656PS6070PS9803PS1372BPS4756rS0540)(((this)->parent), (&((this)->name)), (&((this)->params)), ((this)->retType), ((this)->isComptime), (&((this)->attrs))));
}
ParsedTopLevelItem_s *asTLIPS4904rPS1038(ParsedFuncDecl_s *this) { return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_FUNC_DECL), ((getIDPS4904rusz)((this))))); }
ParsedFuncDecl_s *newParsedFuncDeclS5656S8951S6070S9803PS1372PS7247rPS4904(TLIParent_s parent, Span_s span, Token_s name, ParamContext_s params, ParsedTypeNode_s *retType, ParsedBlock_s *body) {
    ((pushPS4111S4904rN)((&(funcDecls)), ((ParsedFuncDecl_s){.ignored = (ignoringNodes),
                                                             .parent = (parent),
                                                             .name = (name),
                                                             .span = (span),
                                                             .params = (params),
                                                             .retType = (retType),
                                                             .body = (body),
                                                             .isComptime = (false),
                                                             .typeState = (((TCState_u){.tag = 0, .payload = {0}}))})));
    return ((lastPS4111rPS4904)((&(funcDecls))));
}
usize getIDPS7247rusz(ParsedBlock_s *this) { return ((indexOfPS8646PS7247rusz)((&(blocks)), (this))); }
none addStmtPS7247PS1100rN(ParsedBlock_s *this, ParsedStmt_s *stmt) {
    if (((this)->stmtLength) >= ((this)->stmtCapacity)) {
        usize newCap = (((this)->stmtCapacity) * ((usize)(2llu)));
        if ((newCap) == ((usize)(0llu)))
            ((newCap) = ((usize)(1llu)));
        (((this)->stmtList) = (((realloc))(((this)->stmtList), ((newCap) * (sizeof(usize))))));
        ((assertBPcrN)((((this)->stmtList) != (NULL)), ("Could not resize stmt list")));
        (((this)->stmtCapacity) = (newCap));
    }

    (((((this)->stmtList))[((this)->stmtLength)]) = (stmt));
    (((this)->stmtLength) = (((this)->stmtLength) + ((usize)(1llu))));
}
ParsedStmt_s *getStmtAtIndexPS7247uszrPS1100(ParsedBlock_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->stmtLength)), ("Out of bounds access in ParsedBlock.getStmtAtIndex")));
    return ((((this)->stmtList))[(index)]);
}
ParsedStmt_s *into_stmtPS7247rPS1100(ParsedBlock_s *this) { return ((newParsedStmtS8951U4263rPS1100)(((this)->span), ((StmtData_u){.tag = 4, .payload = {.variant4 = {._0 = (this)}}}))); }
ParsedBlock_s *newParsedBlockrPS7247(none) {
    ((pushPS8646S7247rN)((&(blocks)), ((ParsedBlock_s){.ignored = (ignoringNodes)})));
    return ((lastPS8646rPS7247)((&(blocks))));
}
usize getIDPS1100rusz(ParsedStmt_s *this) { return ((indexOfPS8227PS1100rusz)((&(stmts)), (this))); }
ParsedTopLevelItem_s *asTLIPS1100rPS1038(ParsedStmt_s *this) {
    bool succ_10235_ = true;

    StmtData_u *tmp_16623_ = (&((this)->data));
    {
        succ_10235_ &= (tmp_16623_->tag == 0);
        succ_10235_ &= true;
        if (succ_10235_) {
            {
                return ((newParsedTopLevelItemS8951uszuszrPS1038)(((this)->span), (TLI_VAR_DECL), ((getIDPS1100rusz)((this)))));
            }
            goto after_16623;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16623;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16623:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of STMT to TLI conversions")));
}
ParsedBlock_s *into_blockPS1100rPS7247(ParsedStmt_s *this) {
    ParsedBlock_s *block = ((newParsedBlockrPS7247)());
    ((addStmtPS7247PS1100rN)((block), (this)));
    return (block);
}
ParsedStmt_s *newParsedStmtS8951U4263rPS1100(Span_s span, StmtData_u data) {
    ((pushPS8227S1100rN)((&(stmts)), ((ParsedStmt_s){.ignored = (ignoringNodes), .span = (span), .data = (data)})));
    return ((lastPS8227rPS1100)((&(stmts))));
}
SubStr_s BUILD_A_TYPEPcrS7720(char *s) { return ((SubStr_s){.start = (s), .len = ((comptimeStrlenPcrusz)((s)))}); }
usize getBuiltinTypeKindS6070rusz(Token_s name) {
    if ((equalsPS7720PS7720rB)((&((name).content)), (&(ANY))))
        return (PARSED_TYPE_ANY);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I8))))
        return (PARSED_TYPE_I8);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I16))))
        return (PARSED_TYPE_I16);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I32))))
        return (PARSED_TYPE_I32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(I64))))
        return (PARSED_TYPE_I64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U8))))
        return (PARSED_TYPE_U8);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U16))))
        return (PARSED_TYPE_U16);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U32))))
        return (PARSED_TYPE_U32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(U64))))
        return (PARSED_TYPE_U64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(USIZE))))
        return (PARSED_TYPE_USIZE);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(F32))))
        return (PARSED_TYPE_F32);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(F64))))
        return (PARSED_TYPE_F64);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(BOOL))))
        return (PARSED_TYPE_BOOL);
    else if ((equalsPS7720PS7720rB)((&((name).content)), (&(CHAR))))
        return (PARSED_TYPE_CHAR);
    return (PARSED_TYPE_INVALID);
}
usize getIDPS1372rusz(ParsedTypeNode_s *this) { return ((indexOfPS4419PS1372rusz)((&(typeNodes)), (this))); }
ParsedTypeNode_s *newParsedTypeNodeS8951uszrPS1372(Span_s span, usize kind) {
    ((pushPS4419S1372rN)((&(typeNodes)), ((ParsedTypeNode_s){.ignored = (ignoringNodes), .span = (span), .kind = (kind)})));
    return ((lastPS4419rPS1372)((&(typeNodes))));
}
ParsedTypeNode_s *newBuiltinTypeDeclS8951uszrPS1372(Span_s span, usize kind) {
    ParsedTypeNode_s *t = ((atPS4419uszrPS1372)((&(typeNodes)), (kind)));
    (((*(t)).span) = (span));
    (((*(t)).kind) = (PARSED_TYPE_BUILTIN));
    return (t);
}
UnaryExpr_u fromTknuszPS2435rU5427(usize kind, ParsedExpr_s *expr) {
    if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ((UnaryExpr_u){.tag = 2, .payload = {.variant2 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ((UnaryExpr_u){.tag = 3, .payload = {.variant3 = {._0 = (expr)}}});
    else if ((kind) == (TOKEN_BANG))
        return ((UnaryExpr_u){.tag = 4, .payload = {.variant4 = {._0 = (expr)}}});
    ((unreachablePcrN)(("fromTkn: Exhaustive handling of unary ops")));
}
none extractOperandPU5427PPS2435rN(UnaryExpr_u *expr, ParsedExpr_s **lhs) {
    bool succ_10324_ = true;
    bool succ_10328_ = true;
    bool succ_10332_ = true;
    bool succ_10336_ = true;
    bool succ_10340_ = true;

    UnaryExpr_u *tmp_16728_ = (expr);
    {
        succ_10324_ &= (tmp_16728_->tag == 0);
        ParsedExpr_s **_lhs = &tmp_16728_->payload.variant0._0;
        succ_10324_ &= true;
        if (succ_10324_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16728;
        }
    }
    {
        succ_10328_ &= (tmp_16728_->tag == 1);
        ParsedExpr_s **_lhs = &tmp_16728_->payload.variant1._0;
        succ_10328_ &= true;
        if (succ_10328_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16728;
        }
    }
    {
        succ_10332_ &= (tmp_16728_->tag == 2);
        ParsedExpr_s **_lhs = &tmp_16728_->payload.variant2._0;
        succ_10332_ &= true;
        if (succ_10332_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16728;
        }
    }
    {
        succ_10336_ &= (tmp_16728_->tag == 3);
        ParsedExpr_s **_lhs = &tmp_16728_->payload.variant3._0;
        succ_10336_ &= true;
        if (succ_10336_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16728;
        }
    }
    {
        succ_10340_ &= (tmp_16728_->tag == 4);
        ParsedExpr_s **_lhs = &tmp_16728_->payload.variant4._0;
        succ_10340_ &= true;
        if (succ_10340_) {
            {
                ((*(lhs)) = (*_lhs));
            }
            goto after_16728;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("extractOperand: Exhaustive handling of unary expressions")));
            }
            goto after_16728;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16728:
    (void)0; // error: label at end of compound statement is a C23 extension
}
char *binOpAsStrPU0121rPc(BinaryExpr_u *expr) {
    bool succ_10345_ = true;
    bool succ_10349_ = true;
    bool succ_10353_ = true;
    bool succ_10357_ = true;
    bool succ_10361_ = true;
    bool succ_10365_ = true;
    bool succ_10369_ = true;
    bool succ_10373_ = true;
    bool succ_10377_ = true;
    bool succ_10381_ = true;
    bool succ_10385_ = true;
    bool succ_10389_ = true;
    bool succ_10393_ = true;
    bool succ_10397_ = true;
    bool succ_10401_ = true;
    bool succ_10405_ = true;
    bool succ_10409_ = true;
    bool succ_10413_ = true;
    bool succ_10417_ = true;
    bool succ_10421_ = true;

    BinaryExpr_u *tmp_16770_ = (expr);
    {
        succ_10345_ &= (tmp_16770_->tag == 0);
        succ_10345_ &= true;
        if (succ_10345_) {
            {
                return ("::");
            }
            goto after_16770;
        }
    }
    {
        succ_10349_ &= (tmp_16770_->tag == 1);
        succ_10349_ &= true;
        if (succ_10349_) {
            {
                return (".");
            }
            goto after_16770;
        }
    }
    {
        succ_10353_ &= (tmp_16770_->tag == 2);
        succ_10353_ &= true;
        if (succ_10353_) {
            {
                return ("=");
            }
            goto after_16770;
        }
    }
    {
        succ_10357_ &= (tmp_16770_->tag == 3);
        succ_10357_ &= true;
        if (succ_10357_) {
            {
                return ("+");
            }
            goto after_16770;
        }
    }
    {
        succ_10361_ &= (tmp_16770_->tag == 4);
        succ_10361_ &= true;
        if (succ_10361_) {
            {
                return ("-");
            }
            goto after_16770;
        }
    }
    {
        succ_10365_ &= (tmp_16770_->tag == 5);
        succ_10365_ &= true;
        if (succ_10365_) {
            {
                return ("*");
            }
            goto after_16770;
        }
    }
    {
        succ_10369_ &= (tmp_16770_->tag == 6);
        succ_10369_ &= true;
        if (succ_10369_) {
            {
                return ("/");
            }
            goto after_16770;
        }
    }
    {
        succ_10373_ &= (tmp_16770_->tag == 7);
        succ_10373_ &= true;
        if (succ_10373_) {
            {
                return ("%");
            }
            goto after_16770;
        }
    }
    {
        succ_10377_ &= (tmp_16770_->tag == 8);
        succ_10377_ &= true;
        if (succ_10377_) {
            {
                return ("==");
            }
            goto after_16770;
        }
    }
    {
        succ_10381_ &= (tmp_16770_->tag == 9);
        succ_10381_ &= true;
        if (succ_10381_) {
            {
                return ("!=");
            }
            goto after_16770;
        }
    }
    {
        succ_10385_ &= (tmp_16770_->tag == 10);
        succ_10385_ &= true;
        if (succ_10385_) {
            {
                return (">");
            }
            goto after_16770;
        }
    }
    {
        succ_10389_ &= (tmp_16770_->tag == 11);
        succ_10389_ &= true;
        if (succ_10389_) {
            {
                return (">=");
            }
            goto after_16770;
        }
    }
    {
        succ_10393_ &= (tmp_16770_->tag == 12);
        succ_10393_ &= true;
        if (succ_10393_) {
            {
                return ("<");
            }
            goto after_16770;
        }
    }
    {
        succ_10397_ &= (tmp_16770_->tag == 13);
        succ_10397_ &= true;
        if (succ_10397_) {
            {
                return ("<=");
            }
            goto after_16770;
        }
    }
    {
        succ_10401_ &= (tmp_16770_->tag == 14);
        succ_10401_ &= true;
        if (succ_10401_) {
            {
                return ("&&");
            }
            goto after_16770;
        }
    }
    {
        succ_10405_ &= (tmp_16770_->tag == 15);
        succ_10405_ &= true;
        if (succ_10405_) {
            {
                return ("||");
            }
            goto after_16770;
        }
    }
    {
        succ_10409_ &= (tmp_16770_->tag == 16);
        succ_10409_ &= true;
        if (succ_10409_) {
            {
                return ("&");
            }
            goto after_16770;
        }
    }
    {
        succ_10413_ &= (tmp_16770_->tag == 17);
        succ_10413_ &= true;
        if (succ_10413_) {
            {
                return ("|");
            }
            goto after_16770;
        }
    }
    {
        succ_10417_ &= (tmp_16770_->tag == 18);
        succ_10417_ &= true;
        if (succ_10417_) {
            {
                return ("^");
            }
            goto after_16770;
        }
    }
    {
        succ_10421_ &= (tmp_16770_->tag == 19);
        succ_10421_ &= true;
        if (succ_10421_) {
            {
                ((unreachablePcrN)(("binOpAsStr is not defined for indexed access")));
            }
            goto after_16770;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16770;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16770:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("binOpAsStr: Exhaustive handling of binary expressions")));
}
none extractOperandsPU0121PPS2435PPS2435rN(BinaryExpr_u *expr, ParsedExpr_s **lhs, ParsedExpr_s **rhs) {
    bool succ_10427_ = true;
    bool succ_10432_ = true;
    bool succ_10437_ = true;
    bool succ_10442_ = true;
    bool succ_10447_ = true;
    bool succ_10452_ = true;
    bool succ_10457_ = true;
    bool succ_10462_ = true;
    bool succ_10467_ = true;
    bool succ_10472_ = true;
    bool succ_10477_ = true;
    bool succ_10482_ = true;
    bool succ_10487_ = true;
    bool succ_10492_ = true;
    bool succ_10497_ = true;
    bool succ_10502_ = true;
    bool succ_10507_ = true;
    bool succ_10512_ = true;
    bool succ_10517_ = true;
    bool succ_10522_ = true;

    BinaryExpr_u *tmp_16834_ = (expr);
    {
        succ_10427_ &= (tmp_16834_->tag == 0);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant0._0;
        succ_10427_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant0._1;
        succ_10427_ &= true;
        if (succ_10427_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10432_ &= (tmp_16834_->tag == 1);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant1._0;
        succ_10432_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant1._1;
        succ_10432_ &= true;
        if (succ_10432_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10437_ &= (tmp_16834_->tag == 2);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant2._0;
        succ_10437_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant2._1;
        succ_10437_ &= true;
        if (succ_10437_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10442_ &= (tmp_16834_->tag == 3);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant3._0;
        succ_10442_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant3._1;
        succ_10442_ &= true;
        if (succ_10442_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10447_ &= (tmp_16834_->tag == 4);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant4._0;
        succ_10447_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant4._1;
        succ_10447_ &= true;
        if (succ_10447_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10452_ &= (tmp_16834_->tag == 5);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant5._0;
        succ_10452_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant5._1;
        succ_10452_ &= true;
        if (succ_10452_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10457_ &= (tmp_16834_->tag == 6);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant6._0;
        succ_10457_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant6._1;
        succ_10457_ &= true;
        if (succ_10457_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10462_ &= (tmp_16834_->tag == 7);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant7._0;
        succ_10462_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant7._1;
        succ_10462_ &= true;
        if (succ_10462_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10467_ &= (tmp_16834_->tag == 8);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant8._0;
        succ_10467_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant8._1;
        succ_10467_ &= true;
        if (succ_10467_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10472_ &= (tmp_16834_->tag == 9);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant9._0;
        succ_10472_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant9._1;
        succ_10472_ &= true;
        if (succ_10472_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10477_ &= (tmp_16834_->tag == 10);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant10._0;
        succ_10477_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant10._1;
        succ_10477_ &= true;
        if (succ_10477_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10482_ &= (tmp_16834_->tag == 11);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant11._0;
        succ_10482_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant11._1;
        succ_10482_ &= true;
        if (succ_10482_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10487_ &= (tmp_16834_->tag == 12);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant12._0;
        succ_10487_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant12._1;
        succ_10487_ &= true;
        if (succ_10487_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10492_ &= (tmp_16834_->tag == 13);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant13._0;
        succ_10492_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant13._1;
        succ_10492_ &= true;
        if (succ_10492_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10497_ &= (tmp_16834_->tag == 14);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant14._0;
        succ_10497_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant14._1;
        succ_10497_ &= true;
        if (succ_10497_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10502_ &= (tmp_16834_->tag == 15);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant15._0;
        succ_10502_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant15._1;
        succ_10502_ &= true;
        if (succ_10502_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10507_ &= (tmp_16834_->tag == 16);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant16._0;
        succ_10507_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant16._1;
        succ_10507_ &= true;
        if (succ_10507_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10512_ &= (tmp_16834_->tag == 17);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant17._0;
        succ_10512_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant17._1;
        succ_10512_ &= true;
        if (succ_10512_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10517_ &= (tmp_16834_->tag == 18);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant18._0;
        succ_10517_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant18._1;
        succ_10517_ &= true;
        if (succ_10517_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        succ_10522_ &= (tmp_16834_->tag == 19);
        ParsedExpr_s **_lhs = &tmp_16834_->payload.variant19._0;
        succ_10522_ &= true;
        ParsedExpr_s **_rhs = &tmp_16834_->payload.variant19._1;
        succ_10522_ &= true;
        if (succ_10522_) {
            {
                ((*(lhs)) = (*_lhs));
                ((*(rhs)) = (*_rhs));
            }
            goto after_16834;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("extractOperands: Exhaustive handling of binary expressions")));
            }
            goto after_16834;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16834:
    (void)0; // error: label at end of compound statement is a C23 extension
}
BinaryExpr_u fromTknuszPS2435PS2435rU0121(usize kind, ParsedExpr_s *lhs, ParsedExpr_s *rhs) {
    if ((kind) == (TOKEN_PLUS_SINGLE))
        return ((BinaryExpr_u){.tag = 3, .payload = {.variant3 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_MINUS_SINGLE))
        return ((BinaryExpr_u){.tag = 4, .payload = {.variant4 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_ASTERISK_SINGLE))
        return ((BinaryExpr_u){.tag = 5, .payload = {.variant5 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_SLASH_SINGLE))
        return ((BinaryExpr_u){.tag = 6, .payload = {.variant6 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_DOT))
        return ((BinaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_GREATER_THAN_EQUAL))
        return ((BinaryExpr_u){.tag = 11, .payload = {.variant11 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_GREATER_THAN))
        return ((BinaryExpr_u){.tag = 10, .payload = {.variant10 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_LESS_THAN_EQUAL))
        return ((BinaryExpr_u){.tag = 13, .payload = {.variant13 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_LESS_THAN))
        return ((BinaryExpr_u){.tag = 12, .payload = {.variant12 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_NOT_EQUAL))
        return ((BinaryExpr_u){.tag = 9, .payload = {.variant9 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_EQUAL_DOUBLE))
        return ((BinaryExpr_u){.tag = 8, .payload = {.variant8 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_EQUAL_SINGLE))
        return ((BinaryExpr_u){.tag = 2, .payload = {.variant2 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_SQUARE_OPEN))
        return ((BinaryExpr_u){.tag = 19, .payload = {.variant19 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PERCENT))
        return ((BinaryExpr_u){.tag = 7, .payload = {.variant7 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_AMPERSAND_DOUBLE))
        return ((BinaryExpr_u){.tag = 14, .payload = {.variant14 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PIPE_DOUBLE))
        return ((BinaryExpr_u){.tag = 15, .payload = {.variant15 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_AMPERSAND_SINGLE))
        return ((BinaryExpr_u){.tag = 16, .payload = {.variant16 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_PIPE_SINGLE))
        return ((BinaryExpr_u){.tag = 17, .payload = {.variant17 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_CARET))
        return ((BinaryExpr_u){.tag = 18, .payload = {.variant18 = {._0 = (lhs), ._1 = (rhs)}}});
    else if ((kind) == (TOKEN_COLON_DOUBLE))
        return ((BinaryExpr_u){.tag = 0, .payload = {.variant0 = {._0 = (lhs), ._1 = (rhs)}}});
    ((unreachablePcrN)(("fromTkn: Exhaustive handling of binary kinds")));
}
bool isArithmeticPU0121rB(BinaryExpr_u *this) {
    bool succ_10527_ = true;
    bool succ_10531_ = true;
    bool succ_10535_ = true;
    bool succ_10539_ = true;
    bool succ_10543_ = true;

    BinaryExpr_u *tmp_16887_ = (this);
    {
        succ_10527_ &= (tmp_16887_->tag == 3);
        succ_10527_ &= true;
        if (succ_10527_) {
            {
                return (true);
            }
            goto after_16887;
        }
    }
    {
        succ_10531_ &= (tmp_16887_->tag == 4);
        succ_10531_ &= true;
        if (succ_10531_) {
            {
                return (true);
            }
            goto after_16887;
        }
    }
    {
        succ_10535_ &= (tmp_16887_->tag == 5);
        succ_10535_ &= true;
        if (succ_10535_) {
            {
                return (true);
            }
            goto after_16887;
        }
    }
    {
        succ_10539_ &= (tmp_16887_->tag == 6);
        succ_10539_ &= true;
        if (succ_10539_) {
            {
                return (true);
            }
            goto after_16887;
        }
    }
    {
        succ_10543_ &= (tmp_16887_->tag == 7);
        succ_10543_ &= true;
        if (succ_10543_) {
            {
                return (true);
            }
            goto after_16887;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16887;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16887:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isComparisonPU0121rB(BinaryExpr_u *this) {
    bool succ_10548_ = true;
    bool succ_10552_ = true;
    bool succ_10556_ = true;
    bool succ_10560_ = true;
    bool succ_10564_ = true;
    bool succ_10568_ = true;

    BinaryExpr_u *tmp_16902_ = (this);
    {
        succ_10548_ &= (tmp_16902_->tag == 11);
        succ_10548_ &= true;
        if (succ_10548_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        succ_10552_ &= (tmp_16902_->tag == 10);
        succ_10552_ &= true;
        if (succ_10552_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        succ_10556_ &= (tmp_16902_->tag == 13);
        succ_10556_ &= true;
        if (succ_10556_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        succ_10560_ &= (tmp_16902_->tag == 12);
        succ_10560_ &= true;
        if (succ_10560_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        succ_10564_ &= (tmp_16902_->tag == 8);
        succ_10564_ &= true;
        if (succ_10564_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        succ_10568_ &= (tmp_16902_->tag == 9);
        succ_10568_ &= true;
        if (succ_10568_) {
            {
                return (true);
            }
            goto after_16902;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16902;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16902:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isLogicalPU0121rB(BinaryExpr_u *this) {
    bool succ_10573_ = true;
    bool succ_10577_ = true;

    BinaryExpr_u *tmp_16909_ = (this);
    {
        succ_10573_ &= (tmp_16909_->tag == 14);
        succ_10573_ &= true;
        if (succ_10573_) {
            {
                return (true);
            }
            goto after_16909;
        }
    }
    {
        succ_10577_ &= (tmp_16909_->tag == 15);
        succ_10577_ &= true;
        if (succ_10577_) {
            {
                return (true);
            }
            goto after_16909;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16909;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16909:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBitwisePU0121rB(BinaryExpr_u *this) {
    bool succ_10582_ = true;
    bool succ_10586_ = true;
    bool succ_10590_ = true;

    BinaryExpr_u *tmp_16918_ = (this);
    {
        succ_10582_ &= (tmp_16918_->tag == 16);
        succ_10582_ &= true;
        if (succ_10582_) {
            {
                return (true);
            }
            goto after_16918;
        }
    }
    {
        succ_10586_ &= (tmp_16918_->tag == 17);
        succ_10586_ &= true;
        if (succ_10586_) {
            {
                return (true);
            }
            goto after_16918;
        }
    }
    {
        succ_10590_ &= (tmp_16918_->tag == 18);
        succ_10590_ &= true;
        if (succ_10590_) {
            {
                return (true);
            }
            goto after_16918;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16918;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16918:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isAssignmentPU0121rB(BinaryExpr_u *this) {
    bool succ_10595_ = true;

    BinaryExpr_u *tmp_16923_ = (this);
    {
        succ_10595_ &= (tmp_16923_->tag == 2);
        succ_10595_ &= true;
        if (succ_10595_) {
            {
                return (true);
            }
            goto after_16923;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16923;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16923:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
usize getIDPS2435rusz(ParsedExpr_s *this) { return ((indexOfPS7882PS2435rusz)((&(exprs)), (this))); }
ParsedExpr_s *wrapS2435rPS2435(ParsedExpr_s this) {
    ((pushPS7882S2435rN)((&(exprs)), (this)));
    return ((lastPS7882rPS2435)((&(exprs))));
}
ParsedExpr_s *newParsedExprS8951U8798rPS2435(Span_s span, ExprData_u data) { return ((wrapS2435rPS2435)(((ParsedExpr_s){.span = (span), .data = (data)}))); }
usize intoPointerPS2435rusz(ParsedExpr_s *this) {
    ParsedExpr_s unary =
        ((ParsedExpr_s){.span = ((this)->span), .data = ((ExprData_u){.tag = 5, .payload = {.variant5 = {._0 = ((UnaryExpr_u){.tag = 1, .payload = {.variant1 = {._0 = (this)}}})}}})});
    return ((getIDPS2435rusz)(((wrapS2435rPS2435)((unary)))));
}
bool isLValuePS2435rB(ParsedExpr_s *this) {
    bool succ_10603_ = true;
    bool succ_10601_ = true;
    bool succ_10608_ = true;
    bool succ_10606_ = true;
    bool succ_10619_ = true;
    bool succ_10617_ = true;
    bool succ_10614_ = true;
    bool succ_10626_ = true;

    ExprData_u tmp_16943_ = ((this)->data);
    {
        succ_10603_ &= (tmp_16943_.tag == 5);
        succ_10601_ &= (tmp_16943_.payload.variant5._0.tag == 2);
        succ_10601_ &= true;
        succ_10603_ &= succ_10601_;
        if (succ_10603_) {
            {
                return (true);
            }
            goto after_16943;
        }
    }
    {
        succ_10608_ &= (tmp_16943_.tag == 6);
        succ_10606_ &= (tmp_16943_.payload.variant6._0.tag == 19);
        succ_10606_ &= true;
        succ_10608_ &= succ_10606_;
        if (succ_10608_) {
            {
                return (true);
            }
            goto after_16943;
        }
    }
    {
        succ_10619_ &= (tmp_16943_.tag == 6);
        succ_10617_ &= (tmp_16943_.payload.variant6._0.tag == 1);
        succ_10617_ &= true;
        succ_10614_ &= true;
        succ_10614_ &= true;
        ExprData_u *rhs = &tmp_16943_.payload.variant6._0.payload.variant1._1->data;
        succ_10614_ &= true;
        succ_10614_ &= true;
        succ_10617_ &= succ_10614_;
        succ_10619_ &= succ_10617_;
        if (succ_10619_) {
            {
                bool succ_10622_ = true;

                ExprData_u tmp_16938_ = (*rhs);
                {
                    succ_10622_ &= (tmp_16938_.tag == 4);
                    succ_10622_ &= true;
                    if (succ_10622_) {
                        {
                            return (true);
                        }
                        goto after_16938;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_16938;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_16938:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_16943;
        }
    }
    {
        succ_10626_ &= (tmp_16943_.tag == 4);
        succ_10626_ &= true;
        if (succ_10626_) {
            {
                return (true);
            }
            goto after_16943;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16943;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16943:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isBlankPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80230 = (((ExprData_u){.tag = 13, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80230))));
}
bool isIdentifierPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80243 = (((ExprData_u){.tag = 4, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80243))));
}
bool isLiteralPS2435rB(ParsedExpr_s *this) {
    bool succ_10630_ = true;
    bool succ_10634_ = true;
    bool succ_10638_ = true;
    bool succ_10642_ = true;
    bool succ_10645_ = true;
    bool succ_10648_ = true;
    bool succ_10651_ = true;

    ExprData_u *tmp_16962_ = (&((this)->data));
    {
        succ_10630_ &= (tmp_16962_->tag == 0);
        succ_10630_ &= true;
        if (succ_10630_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10634_ &= (tmp_16962_->tag == 1);
        succ_10634_ &= true;
        if (succ_10634_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10638_ &= (tmp_16962_->tag == 2);
        succ_10638_ &= true;
        if (succ_10638_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10642_ &= (tmp_16962_->tag == 3);
        succ_10642_ &= true;
        if (succ_10642_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10645_ &= (tmp_16962_->tag == 12);
        if (succ_10645_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10648_ &= (tmp_16962_->tag == 14);
        if (succ_10648_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        succ_10651_ &= (tmp_16962_->tag == 15);
        if (succ_10651_) {
            {
                return (true);
            }
            goto after_16962;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16962;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16962:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
bool isUnaryPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80268 = (((ExprData_u){.tag = 5, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80268))));
}
bool isCallPS2435rB(ParsedExpr_s *this) {
    ExprData_u tmp_80281 = (((ExprData_u){.tag = 7, .payload = {0}}));

    return (((tagAnyru8)((&((this)->data)))) == ((tagAnyru8)((&tmp_80281))));
}
bool isAssignmentPS2435rB(ParsedExpr_s *this) {
    bool succ_10658_ = true;
    bool succ_10656_ = true;

    ExprData_u *tmp_16969_ = (&((this)->data));
    {
        succ_10658_ &= (tmp_16969_->tag == 6);
        succ_10656_ &= (tmp_16969_->payload.variant6._0.tag == 2);
        succ_10656_ &= true;
        succ_10658_ &= succ_10656_;
        if (succ_10658_) {
            {
                return (true);
            }
            goto after_16969;
        }
    }
    {
        if (true) {
            {
            }
            goto after_16969;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_16969:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
usize getIDPS1826rusz(ParsedPattern_s *this) { return ((indexOfPS8361PS1826rusz)((&(patterns)), (this))); }
ParsedPattern_s *newParsedPatternS8951U9267rPS1826(Span_s span, Pattern_u pat) {
    ((pushPS8361S1826rN)((&(patterns)), ((ParsedPattern_s){.ignored = (ignoringNodes), .span = (span), .data = (pat)})));
    return ((lastPS8361rPS1826)((&(patterns))));
}
String_s toStringPS1826rS0540(ParsedPattern_s *this) {
    bool succ_10662_ = true;
    bool succ_10665_ = true;
    bool succ_10669_ = true;
    bool succ_10667_ = true;
    bool succ_10673_ = true;
    bool succ_10671_ = true;
    bool succ_10676_ = true;
    bool succ_10680_ = true;
    bool succ_10684_ = true;
    bool succ_10688_ = true;
    bool succ_10695_ = true;
    bool succ_10704_ = true;
    bool succ_10710_ = true;

    Pattern_u *tmp_17035_ = (&((this)->data));
    {
        succ_10662_ &= (tmp_17035_->tag == 8);
        if (succ_10662_) {
            {
                return ((newStringFromStrLitPcrS0540)(("..")));
            }
            goto after_17035;
        }
    }
    {
        succ_10665_ &= (tmp_17035_->tag == 0);
        if (succ_10665_) {
            {
                return ((newStringFromStrLitPcrS0540)(("_")));
            }
            goto after_17035;
        }
    }
    {
        succ_10669_ &= (tmp_17035_->tag == 9);
        succ_10667_ = tmp_17035_->payload.variant9._0 == true;
        succ_10669_ &= succ_10667_;
        if (succ_10669_) {
            {
                return ((newStringFromStrLitPcrS0540)(("true")));
            }
            goto after_17035;
        }
    }
    {
        succ_10673_ &= (tmp_17035_->tag == 9);
        succ_10671_ = tmp_17035_->payload.variant9._0 == false;
        succ_10673_ &= succ_10671_;
        if (succ_10673_) {
            {
                return ((newStringFromStrLitPcrS0540)(("false")));
            }
            goto after_17035;
        }
    }
    {
        succ_10676_ &= (tmp_17035_->tag == 10);
        if (succ_10676_) {
            {
                return ((newStringFromStrLitPcrS0540)(("null")));
            }
            goto after_17035;
        }
    }
    {
        succ_10680_ &= (tmp_17035_->tag == 2);
        Token_s *ident = &tmp_17035_->payload.variant2._0;
        succ_10680_ &= true;
        if (succ_10680_) {
            {
                return ((toStringPS7720rS0540)((&((*ident).content))));
            }
            goto after_17035;
        }
    }
    {
        succ_10684_ &= (tmp_17035_->tag == 1);
        Token_s *number = &tmp_17035_->payload.variant1._0;
        succ_10684_ &= true;
        if (succ_10684_) {
            {
                return ((toStringPS7720rS0540)((&((*number).content))));
            }
            goto after_17035;
        }
    }
    {
        succ_10688_ &= (tmp_17035_->tag == 4);
        ParsedPattern_s **pat = &tmp_17035_->payload.variant4._0;
        succ_10688_ &= true;
        if (succ_10688_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("&")));
                String_s _s = ((toStringPS1826rS0540)((*pat)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_17035;
        }
    }
    {
        succ_10695_ &= (tmp_17035_->tag == 5);
        Token_s *name = &tmp_17035_->payload.variant5._0;
        succ_10695_ &= true;
        ParsedPatternList_s *pats = &tmp_17035_->payload.variant5._1;
        succ_10695_ &= true;
        if (succ_10695_) {
            {
                String_s s = ((toStringPS7720rS0540)((&((*name).content))));
                if (((*pats).length) == ((usize)(0llu))) {
                    ((pushStrPS0540PcrN)((&(s)), (" { }")));
                }

                else {
                    ((pushStrPS0540PcrN)((&(s)), (" { ")));
                    for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s _s = ((toStringPS1826rS0540)((*((atPS1982uszrPPS1826)((&(*pats)), (i))))));
                        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                        if ((i) != (((*pats).length) - ((usize)(1llu)))) {
                            ((pushStrPS0540PcrN)((&(s)), (", ")));
                        }

                        ((dropPS0540rN)((&(_s))));
                    }

                    ((pushStrPS0540PcrN)((&(s)), (" }")));
                }

                return (s);
            }
            goto after_17035;
        }
    }
    {
        succ_10704_ &= (tmp_17035_->tag == 6);
        Token_s *name = &tmp_17035_->payload.variant6._0;
        succ_10704_ &= true;
        ParsedPattern_s **sub = &tmp_17035_->payload.variant6._1;
        succ_10704_ &= true;
        if (succ_10704_) {
            {
                String_s s = ((toStringPS7720rS0540)((&((*name).content))));
                ((pushStrPS0540PcrN)((&(s)), ("::")));
                String_s _s = ((toStringPS1826rS0540)((*sub)));
                ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                ((dropPS0540rN)((&(_s))));
                return (s);
            }
            goto after_17035;
        }
    }
    {
        succ_10710_ &= (tmp_17035_->tag == 7);
        ParsedPatternList_s *pats = &tmp_17035_->payload.variant7._0;
        succ_10710_ &= true;
        if (succ_10710_) {
            {
                String_s s = ((newStringFromStrLitPcrS0540)(("(")));
                for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s _s = ((toStringPS1826rS0540)((*((atPS1982uszrPPS1826)((&(*pats)), (i))))));
                    ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
                    if ((i) != (((*pats).length) - ((usize)(1llu)))) {
                        ((pushStrPS0540PcrN)((&(s)), (", ")));
                    }

                    ((dropPS0540rN)((&(_s))));
                }

                ((pushStrPS0540PcrN)((&(s)), (")")));
                return (s);
            }
            goto after_17035;
        }
    }
    {
        Pattern_u **unknown = &tmp_17035_;
        if (true) {
            {
                (((fprintf))((stderr_), ("%s ParsedPattern.toString: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                (((C_exiti32rN))(((i32)(2))));
            }
            goto after_17035;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17035:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("Exhaustive handling of pattern kinds in ParsedPattern.toString()")));
}
bool equalsPS8951PS8951rB(Span_s *this, Span_s *other) { return (((((this)->file) == ((other)->file)) && (((this)->start) == ((other)->start))) && (((this)->end) == ((other)->end))); }
none printPS8951rN(Span_s *this) {
    String_s s = ((toStringPS8951rS0540)((this)));
    ((printPS0540rN)((&(s))));
    ((dropPS0540rN)((&(s))));
}
String_s toStringPS8951rS0540(Span_s *this) {
    ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), ((this)->file)));
    String_s s = ((toStringPS7720rS0540)((&((file)->origin))));
    usize line = ((usize)(0llu));
    usize col = ((usize)(0llu));
    ((getLineAndColumnFromSpanPS1892PS8951PuszPuszrN)((file), (this), (&(line)), (&(col))));
    ((pushCharPS0540crN)((&(s)), (':')));
    ((pushNumberPS0540uszrN)((&(s)), (line)));
    ((pushCharPS0540crN)((&(s)), (':')));
    ((pushNumberPS0540uszrN)((&(s)), (col)));
    return (s);
}
bool comesBeforePS8951PS8951rB(Span_s *this, Span_s *other) { return (((this)->start) < ((other)->start)); }
Span_s newSpanuszuszuszrS8951(usize file, usize start, usize end) {
    ((assertBPcrN)(((end) >= (start)), ("Invalid size for newSpan()")));
    return ((Span_s){.file = (file), .start = (start), .end = (end)});
}
Span_s newSpanBetweenPS8951PS8951rS8951(Span_s *start, Span_s *end) {
    ((assertBPcrN)((((end)->end) >= ((start)->end)), ("newSpanBetween: End Span can\'t end before Start Span.")));
    ((assertBPcrN)((((start)->start) <= ((end)->start)), ("newSpanBetween: Start Span can\'t start after End Span.")));
    ((assertBPcrN)((((start)->file) == ((end)->file)), ("newSpanBetween: Spans can\'t be in different files.")));
    return ((Span_s){.file = ((start)->file), .start = ((start)->start), .end = ((end)->end)});
}
Span_s defaultSpanrS8951(none) { return ((Span_s){.file = ((usize)(0llu)), .start = ((usize)(0llu)), .end = ((usize)(0llu))}); }
bool isMandatoryPS7407rB(Flag_s *flag) { return ((((flag)->mode) & (FLAG_MODE_MANDATORY)) != ((usize)(0llu))); }
String_s toStringPS7407rS0540(Flag_s *this) {
    String_s s = ((String_s){0});
    if (((this)->long_) != (NULL)) {
        ((pushStrPS0540PcrN)((&(s)), ("--")));
        ((pushStrPS0540PcrN)((&(s)), ((this)->long_)));
        bool succ_10742_ = true;

        {
            FlagData_u tmp_17070_ = ((this)->data);
            succ_10742_ &= (tmp_17070_.tag == 1);
            succ_10742_ &= true;

            if (succ_10742_) {
                ((pushStrPS0540PcrN)((&(s)), (" [arg]")));
            }
        }

    }

    else if (((this)->short_) != (NULL)) {
        ((pushCharPS0540crN)((&(s)), ('-')));
        ((pushStrPS0540PcrN)((&(s)), ((this)->short_)));
        bool succ_10745_ = true;

        {
            FlagData_u tmp_17075_ = ((this)->data);
            succ_10745_ &= (tmp_17075_.tag == 1);
            succ_10745_ &= true;

            if (succ_10745_) {
                ((pushStrPS0540PcrN)((&(s)), (" [arg]")));
            }
        }

    }

    else {
        bool succ_10748_ = true;

        FlagData_u tmp_17078_ = ((this)->data);
        succ_10748_ &= (tmp_17078_.tag == 1);
        succ_10748_ &= true;
        if (!succ_10748_) {
            ((unreachablePcrN)(("toString expected String for standalone")));
        };
        ((pushStrPS0540PcrN)((&(s)), ("<standalone>")));
    }

    return (s);
}
bool *addHelpFlagPS7660rPB(FlagParser_s *this) {
    ((assertBPcrN)((((this)->helpFlag) == (NULL)), ("addHelpFlag() called twice")));
    return (((this)->helpFlag) = ((addBoolFlagPS7660PcPcPcrPB)((this), ("h"), ("help"), ("Print help and exit"))));
}
Flag_s *addDefaultFlagPS7660PcPcPcuszU0121rPS7407(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode, FlagData_u data) {
    ((assertBPcrN)((((this)->flagCount) < ((usize)(32llu))), ("Could not add flag: Too many flags")));
    Flag_s *f = (&((((this)->flags).arr)[((this)->flagCount)]));
    bool succ_10751_ = true;

    FlagData_u tmp_17089_ = ((f)->data);
    succ_10751_ &= (tmp_17089_.tag == 0);
    if (!succ_10751_) {
        ((unreachablePcrN)(("addDefaultFlag: Flag not invalid")));
    };
    (((this)->flagCount) = (((this)->flagCount) + ((usize)(1llu))));
    (((f)->mode) = (mode));
    (((f)->short_) = (short_));
    (((f)->long_) = (long_));
    (((f)->descr) = (descr));
    (((f)->data) = (data));
    return (f);
}
String_s *addStringFlagPS7660PcuszrPS0540(FlagParser_s *this, char *descr, usize mode) { return ((addStringFlagPS7660PcPcPcuszrPS0540)((this), (NULL), (NULL), (descr), (mode))); }
String_s *addStringFlagPS7660PcPcPcrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr) {
    return ((addStringFlagPS7660PcPcPcuszrPS0540)((this), (short_), (long_), (descr), (FLAG_MODE_DEFAULT)));
}
String_s *addStringFlagPS7660PcPcPcuszrPS0540(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode) {
    Flag_s *f = ((addDefaultFlagPS7660PcPcPcuszU0121rPS7407)((this), (short_), (long_), (descr), (mode), ((FlagData_u){.tag = 1, .payload = {.variant1 = {._0 = ((String_s){0})}}})));
    bool succ_10755_ = true;

    FlagData_u *tmp_17101_ = (&((f)->data));
    succ_10755_ &= (tmp_17101_->tag == 1);
    String_s *s = &tmp_17101_->payload.variant1._0;
    succ_10755_ &= true;
    if (!succ_10755_) {
        ((unreachablerN)());
    };
    return (&(*s));
}
bool *addBoolFlagPS7660PcPcrPB(FlagParser_s *this, char *flag, char *descr) {
    if ((((strncmp))(("--"), (flag), ((usize)(2llu)))) == ((i32)(0))) {
        ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(2llu)))));
        return ((addBoolFlagPS7660PcPcPcrPB)((this), (NULL), (flag), (descr)));
    }

    else if ((*(flag)) == ('-')) {
        ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(1llu)))));
        return ((addBoolFlagPS7660PcPcPcrPB)((this), (flag), (NULL), (descr)));
    }

    (((printf))(("%s\n"), (flag)));
    ((assertBPcrN)((false), ("addBoolFlag(&FlagParser, &char, &char) must be called with a flag that has the form -s or --long")));
    ((unreachablerN)());
}
bool *addBoolFlagPS7660PcPcPcrPB(FlagParser_s *this, char *short_, char *long_, char *descr) { return ((addBoolFlagPS7660PcPcPcuszrPB)((this), (short_), (long_), (descr), (FLAG_MODE_DEFAULT))); }
bool *addBoolFlagPS7660PcPcPcuszrPB(FlagParser_s *this, char *short_, char *long_, char *descr, usize mode) {
    Flag_s *f = ((addDefaultFlagPS7660PcPcPcuszU0121rPS7407)((this), (short_), (long_), (descr), (mode), ((FlagData_u){.tag = 2, .payload = {.variant2 = {._0 = (false)}}})));
    bool succ_10760_ = true;

    FlagData_u *tmp_17117_ = (&((f)->data));
    succ_10760_ &= (tmp_17117_->tag == 2);
    bool *b = &tmp_17117_->payload.variant2._0;
    succ_10760_ &= true;
    if (!succ_10760_) {
        ((unreachablerN)());
    };
    return (&(*b));
}
char *shiftArgumentPS7660Pi32PPPcrPc(FlagParser_s *this, i32 *argc, char ***argv) {
    ((assertBrN)(((*(argc)) > ((i32)(0)))));
    char *result = (*(*(argv)));
    ((*(argv)) = (&(((*(argv)))[((usize)(1llu))])));
    ((*(argc)) = ((*(argc)) - ((i32)(1))));
    return (result);
}
none showErrorsAnyPS7660rN(Any stream, FlagParser_s *this) {
    ((assertBPcrN)(((((this)->errors).length) > ((usize)(0llu))), ("showErrors() called but no error collected")));
    for (usize i = ((usize)(0llu)); ((i) < (((this)->errors).length)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s *f = (&(((((this)->errors).elements))[(i)]));
        (((fprintf))((stream), ("%.*s"), ((f)->length), ((f)->buffer)));
    }
}
none showUsageAnyPS7660rN(Any stream, FlagParser_s *this) {
    (((fprintf))((stream), ("Usage: %s"), (((this)->programName).buffer)));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        Flag_s *f = (&((((this)->flags).arr)[(i)]));
        if ((isMandatoryPS7407rB)((f))) {
            (((fprintf))((stream), (" %s"), (((toStringPS7407rS0540)((f))).buffer)));
        }
    }

    (((fprintf))((stream), ("\n")));
}
none showHelpAnyPS7660rN(Any stream, FlagParser_s *this) {
    (((fprintf))((stream), ("Help:\n")));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        ((showHelpAnyPS7407rN)((stream), (&((((this)->flags).arr)[(i)]))));
    }
}
none showHelpAnyPS7407rN(Any stream, Flag_s *this) {
    String_s s = ((String_s){0});
    if ((((this)->short_) != (NULL)) && (((this)->long_) != (NULL))) {
        ((pushCharPS0540crN)((&(s)), ('-')));
        ((pushStrPS0540PcrN)((&(s)), ((this)->short_)));
        ((pushStrPS0540PcrN)((&(s)), (" | ")));
        String_s _s = ((toStringPS7407rS0540)((this)));
        ((pushStringPS0540PS0540rN)((&(s)), (&(_s))));
        ((dropPS0540rN)((&(_s))));
    }

    else {
        ((s) = ((toStringPS7407rS0540)((this))));
    }

    (((fprintf))((stream), ("%20s: %s"), ((s).buffer), ((this)->descr)));
    if ((isMandatoryPS7407rB)((this))) {
        (((fprintf))((stream), (" [mandatory]")));
    }

    (((fprintf))((stream), ("\n")));
    ((dropPS0540rN)((&(s))));
}
bool helpOrPS7660BrB(FlagParser_s *this, bool or) {
    if (((this)->helpFlag) != (NULL)) {
        return ((*((this)->helpFlag)) || (or));
    }

    return (or);
}
String_s *emitFlagErrorPS7660PcPcrPS0540(FlagParser_s *this, char *msg, char *name) {
    usize len = (((((strlen))((msg))) + (((strlen))((name)))) + ((usize)(1llu)));
    Any buf = (((calloc))((len), (sizeof(char))));
    ((assertBrN)(((buf) != (NULL))));
    (((snprintf))((buf), (len), (msg), (name)));
    String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), (buf)));
    (((free))((buf)));
    return (err);
}
String_s *emitFlagErrorPS7660PcrPS0540(FlagParser_s *this, char *msg) {
    String_s err = ((newStringFromStrLitPcrS0540)((ERR_STR)));
    ((pushStrPS0540PcrN)((&(err)), (": ")));
    ((pushStrPS0540PcrN)((&(err)), (msg)));
    ((pushCharPS0540crN)((&(err)), ('\n')));
    ((pushPS6808S0540rN)((&((this)->errors)), (err)));
    return ((lastPS6808rPS0540)((&((this)->errors))));
}
String_s emitFlagDescriptionPS7660PS7407rS0540(FlagParser_s *this, Flag_s *f) {
    String_s err = ((newStringFromStrLitPcrS0540)((NOTE_STR)));
    ((pushStrPS0540PcrN)((&(err)), (": Description of flag: ")));
    ((pushStrPS0540PcrN)((&(err)), ((f)->descr)));
    ((pushStrPS0540PcrN)((&(err)), ("\n")));
    return (err);
}
bool runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv) {
    bool res = (((_runOnPS7660i32PPcrB)((this), (argc), (argv))) && ((((this)->errors).length) == ((usize)(0llu))));
    return ((helpOrPS7660BrB)((this), (res)));
}
bool _runOnPS7660i32PPcrB(FlagParser_s *this, i32 argc, char **argv) {
    if ((((this)->programName).buffer) == (NULL)) {
        char *name = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
        (((this)->programName) = ((newStringFromStrLitPcrS0540)((name))));
    }

    while ((argc) > ((i32)(0))) {
        char *flag = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
        bool long_ = (false);
        bool short_ = (false);
        bool standalone = (false);
        if ((((strncmp))(("--"), (flag), ((usize)(2llu)))) == ((i32)(0))) {
            ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(2llu)))));
            ((long_) = (true));
        }

        else if ((*(flag)) == ('-')) {
            ((flag) = ((char *)((unsigned char *)(flag) + ((usize)(1llu)))));
            ((short_) = (true));
        }

        else {
            ((standalone) = (true));
        }

        bool found = (false);
        for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
            Flag_s *f = (&((((this)->flags).arr)[(i)]));
            if (long_) {
                if (((f)->long_) == (NULL))
                    continue;
                if ((((strcmp))((flag), ((f)->long_))) == ((i32)(0))) {
                    if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                        ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Value for flag --%s was already provided."), ((f)->long_)));
                        return (false);
                    }

                    bool succ_10792_ = true;

                    {
                        FlagData_u *tmp_17214_ = (&((f)->data));
                        succ_10792_ &= (tmp_17214_->tag == 2);
                        bool *b = &tmp_17214_->payload.variant2._0;
                        succ_10792_ &= true;

                        if (succ_10792_) {
                            ((*b) = (true));
                            (((f)->found) = (true));
                        }
                    }

                    bool succ_10796_ = true;

                    {
                        FlagData_u *tmp_17222_ = (&((f)->data));
                        succ_10796_ &= (tmp_17222_->tag == 1);
                        String_s *s = &tmp_17222_->payload.variant1._0;
                        succ_10796_ &= true;

                        if (succ_10796_) {
                            if ((argc) == ((i32)(0))) {
                                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Expected one more positional argument for flag --%s."), ((f)->long_)));
                                return (false);
                            }

                            char *val = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
                            ((*s) = ((newStringFromStrLitPcrS0540)((val))));
                            (((f)->found) = (true));
                        }
                    }

                    ((assertBPcrN)(((f)->found), ("Exhaustive handling of long flags")));
                    ((found) = (true));
                    break;
                }

            }

            else if (short_) {
                if (((f)->short_) == (NULL))
                    continue;
                if ((((strcmp))((flag), ((f)->short_))) == ((i32)(0))) {
                    if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                        ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Value for flag -%s was already provided."), ((f)->short_)));
                        return (false);
                    }

                    bool succ_10801_ = true;

                    {
                        FlagData_u *tmp_17237_ = (&((f)->data));
                        succ_10801_ &= (tmp_17237_->tag == 2);
                        bool *b = &tmp_17237_->payload.variant2._0;
                        succ_10801_ &= true;

                        if (succ_10801_) {
                            ((*b) = (true));
                            (((f)->found) = (true));
                        }
                    }

                    bool succ_10805_ = true;

                    {
                        FlagData_u *tmp_17245_ = (&((f)->data));
                        succ_10805_ &= (tmp_17245_->tag == 1);
                        String_s *s = &tmp_17245_->payload.variant1._0;
                        succ_10805_ &= true;

                        if (succ_10805_) {
                            if ((argc) == ((i32)(0))) {
                                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Expected one more positional argument for flag -%s."), ((f)->short_)));
                                return (false);
                            }

                            char *val = ((shiftArgumentPS7660Pi32PPPcrPc)((this), (&(argc)), (&(argv))));
                            ((*s) = ((newStringFromStrLitPcrS0540)((val))));
                            (((f)->found) = (true));
                        }
                    }

                    ((assertBPcrN)(((f)->found), ("Exhaustive handling of short flag kinds")));
                    ((found) = (true));
                    break;
                }

            }

            else if (standalone) {
                if (((f)->short_) != (NULL))
                    continue;
                if (((f)->long_) != (NULL))
                    continue;
                if (((f)->found) && ((((f)->mode) & (FLAG_MODE_SINGLE)) != ((usize)(0llu)))) {
                    String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), ("Value for standalone flag was already provided.")));
                    String_s note = ((emitFlagDescriptionPS7660PS7407rS0540)((this), (f)));
                    ((pushStringPS0540PS0540rN)((err), (&(note))));
                    ((dropPS0540rN)((&(note))));
                    return (false);
                }

                bool succ_10812_ = true;

                {
                    FlagData_u *tmp_17265_ = (&((f)->data));
                    succ_10812_ &= (tmp_17265_->tag == 2);
                    bool *b = &tmp_17265_->payload.variant2._0;
                    succ_10812_ &= true;

                    if (succ_10812_) {
                        ((*b) = (true));
                        (((f)->found) = (true));
                    }
                }

                bool succ_10816_ = true;

                {
                    FlagData_u *tmp_17268_ = (&((f)->data));
                    succ_10816_ &= (tmp_17268_->tag == 1);
                    String_s *s = &tmp_17268_->payload.variant1._0;
                    succ_10816_ &= true;

                    if (succ_10816_) {
                        ((*s) = ((newStringFromStrLitPcrS0540)((flag))));
                        (((f)->found) = (true));
                    }
                }

                ((assertBPcrN)(((f)->found), ("Exhaustive handling of standalone flag kinds")));
                ((found) = (true));
                break;
            }
        }

        if (!(found)) {
            if (long_)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag --%s."), (flag)));
            if (short_)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag -%s."), (flag)));
            if (standalone)
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("Unknown flag %s."), (flag)));
            continue;
        }
    }

    bool allGotten = (true);
    for (usize i = ((usize)(0llu)); ((i) < ((this)->flagCount)); ((i) = ((i) + ((usize)(1llu))))) {
        Flag_s *f = (&((((this)->flags).arr)[(i)]));
        if ((!((f)->found)) && ((((f)->mode) & (FLAG_MODE_MANDATORY)) != ((usize)(0llu)))) {
            char *name = ((f)->long_);
            if ((name) == (NULL))
                ((name) = ((f)->short_));
            if ((name) == (NULL)) {
                String_s *err = ((emitFlagErrorPS7660PcrPS0540)((this), ("Mandatory standalone flag not provided.")));
                String_s note = ((emitFlagDescriptionPS7660PS7407rS0540)((this), (f)));
                ((pushStringPS0540PS0540rN)((err), (&(note))));
                ((dropPS0540rN)((&(note))));
            }

            else {
                ((emitFlagErrorPS7660PcPcrPS0540)((this), ("No value for flag `%s` was provided."), (name)));
            }

            ((allGotten) = (false));
        }
    }

    return (allGotten);
}
bool analyzeControlFlowPS9562rB(IRGen_s *irgen) { return (true); }
none __format_helperPS0540S4175rN(String_s *out, Data_s arg) {
    bool succ_10830_ = true;
    bool succ_10839_ = true;
    bool succ_10843_ = true;

    TypeInfo_u tmp_17365_ = ((arg).info);
    {
        succ_10830_ &= (tmp_17365_.tag == 5);
        SubStr_s *name = &tmp_17365_.payload.variant5._0;
        succ_10830_ &= true;
        succ_10830_ &= true;
        succ_10830_ &= true;
        FieldTypeInfoList_s *fields = &tmp_17365_.payload.variant5._3;
        succ_10830_ &= true;
        if (succ_10830_) {
            {
                if ((((strncmp))(((*name).start), ("SubStr"), ((*name).len))) == ((i32)(0))) {
                    ((pushSubStrPS0540PS7720rN)((out), ((arg).ptr)));
                }

                else if ((((strncmp))(((*name).start), ("String"), ((*name).len))) == ((i32)(0))) {
                    ((pushStringPS0540PS0540rN)((out), ((arg).ptr)));
                }

                else {
                    ((pushSubStrPS0540PS7720rN)((out), (&(*name))));
                    for (usize i = ((usize)(0llu)); ((i) < ((*fields).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        FieldTypeInfo_s *f = (&((((*fields).elements))[(i)]));
                        if ((i) > ((usize)(0llu)))
                            ((pushCharPS0540crN)((out), (',')));
                        ((pushSubStrPS0540PS7720rN)((out), (&((f)->name))));
                        Any field_ptr = ((Any)((((usize)(((arg).ptr))) + ((f)->offset_in_bytes))));
                        ((__format_helperPS0540S4175rN)((out), ((Data_s){.ptr = (field_ptr), .info = (((type_info_table))[((f)->type)])})));
                    }

                    ((pushStrPS0540PcrN)((out), (" }")));
                }
            }
            goto after_17365;
        }
    }
    {
        succ_10839_ &= (tmp_17365_.tag == 1);
        SubStr_s *name = &tmp_17365_.payload.variant1._0;
        succ_10839_ &= true;
        usize *size = &tmp_17365_.payload.variant1._1;
        succ_10839_ &= true;
        usize *align = &tmp_17365_.payload.variant1._2;
        succ_10839_ &= true;
        if (succ_10839_) {
            {
                if ((((strncmp))(((*name).start), ("i8"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i8rN)((out), (*(i8 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i16"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i16rN)((out), (*(i16 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i32"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i32rN)((out), (*(i32 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("i64"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540i64rN)((out), (*(i64 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u8"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u8rN)((out), (*(u8 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u16"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u16rN)((out), (*(u16 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u32"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u32rN)((out), (*(u32 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("u64"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540u64rN)((out), (*(u64 *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("usize"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("bool"), ((*name).len))) == ((i32)(0)))
                    if (*(bool *)((arg).ptr))
                        ((pushStrPS0540PcrN)((out), ("true")));
                    else
                        ((pushStrPS0540PcrN)((out), ("false")));
                else if ((((strncmp))(((*name).start), ("char"), ((*name).len))) == ((i32)(0)))
                    ((pushCharPS0540crN)((out), (*(char *)((arg).ptr))));
                else if ((((strncmp))(((*name).start), ("Any"), ((*name).len))) == ((i32)(0)))
                    ((pushNumberAsHexPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                else
                    ((unreachablePcrN)(("__format_helper primitive")));
            }
            goto after_17365;
        }
    }
    {
        succ_10843_ &= (tmp_17365_.tag == 3);
        succ_10843_ &= true;
        usize *underlying = &tmp_17365_.payload.variant3._1;
        succ_10843_ &= true;
        if (succ_10843_) {
            {
                TypeInfo_u tmp_82017 = (type_info_table[12]);

                if ((equalsPU7843PU7843rB)((&(((type_info_table))[(*underlying)])), (&tmp_82017))) {
                    ((pushStrPS0540PcrN)((out), (*(char **)((arg).ptr))));
                }

                else {
                    ((pushNumberAsHexPS0540uszrN)((out), (*(usize *)((arg).ptr))));
                }
            }
            goto after_17365;
        }
    }
    {
        if (true) {
            {
                ((unreachablePcrN)(("__format_helper")));
            }
            goto after_17365;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17365:
    (void)0; // error: label at end of compound statement is a C23 extension
}
none formatPS0540PcVS4175rN(String_s *out, char *fmt, variadic_4507 args) {
    usize l = (((strlen))((fmt)));
    usize arg_count = ((usize)(0llu));
    bool escaped = (false);
    for (usize i = ((usize)(0llu)); ((i) < (l)); ((i) = ((i) + ((usize)(1llu))))) {
        char c = (((fmt))[(i)]);
        if ((c) == ('\\')) {
            ((escaped) = (true));
        }

        else if ((c) == ('%')) {
            if (escaped) {
                ((pushCharPS0540crN)((out), (c)));
            }

            else {
                ((assertBPcrN)(((arg_count) < ((args).length)), ("RUNTIME ERROR: Format string received too many arguments")));
                Data_s arg = (((args).ptr)[(arg_count)]);
                ((__format_helperPS0540S4175rN)((out), (arg)));
                ((arg_count) = ((arg_count) + ((usize)(1llu))));
            }

            ((escaped) = (false));
        }

        else {
            ((pushCharPS0540crN)((out), (c)));
            ((escaped) = (false));
        }
    }

    ((assertBPcrN)(((arg_count) == ((args).length)), ("RUNTIME ERROR: Unused arguments in format string")));
}
String_s format1PcVS4175rS0540(char *fmt, variadic_4507 args) {
    String_s s = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(s)), (fmt), (args)));
    return (s);
}
none fprintPcVS4175rN(char *fmt, variadic_4507 args) {
    String_s o = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(o)), (fmt), (args)));
    ((printPS0540rN)((&(o))));
    ((dropPS0540rN)((&(o))));
}
GAF_List_s new_GAF_ListU7843rS3646(TypeInfo_u ti) {
    return ((GAF_List_s){.elements = (NULL), .length = ((usize)(0llu)), .capacity = ((usize)(0llu)), .type = (ti), .type_size = ((get_sizePU7843rusz)((&(ti))))});
}
none enumeratePS3646FN_uszS4175rN(GAF_List_s *this, none (*fn)(usize, Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)((i), ((get_refPS3646uszrS4175)((this), (i)))));
    }
}
none enumeratePS3646FN_usz_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(usize, Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)((i), ((get_refPS3646uszrS4175)((this), (i))), (arg)));
    }
}
none foreachPS3646FNS4175rN(GAF_List_s *this, none (*fn)(Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)(((get_refPS3646uszrS4175)((this), (i)))));
    }
}
none foreachPS3646FN_S4175AnyAnyrN(GAF_List_s *this, none (*fn)(Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((fn)(((get_refPS3646uszrS4175)((this), (i))), (arg)));
    }
}
none pushPS3646S4175rN(GAF_List_s *list, Data_s elem) {
    if (!((equalsPU7843PU7843rB)((&((list)->type)), (&((elem).info))))) {
        SubStr_s want = ((get_namePU7843rS7720)((&((list)->type))));
        SubStr_s got = ((get_namePU7843rS7720)((&((elem).info))));
        (((fprintf))((stderr_), ("got:  %.*s\n"), ((got).len), ((got).start)));
        (((fprintf))((stderr_), ("want: %.*s\n"), ((want).len), ((want).start)));
        (((fprintf))((stderr_), ("GAF_List.push: Attempted to push invalid element\n")));
        (((C_exiti32rN))(((i32)(1))));
    }

    if (((list)->length) >= ((list)->capacity)) {
        usize new_cap = (((list)->capacity) * ((usize)(2llu)));
        if ((new_cap) == ((usize)(0llu)))
            ((new_cap) = ((usize)(32llu)));
        (((list)->elements) = (((realloc))(((list)->elements), ((new_cap) * ((list)->type_size)))));
        ((assertBPcrN)((((list)->elements) != (NULL)), ("GAF_List.push: Could not allocate memory")));
        (((list)->capacity) = (new_cap));
    }

    (((memcpy))(((usize *)((unsigned char *)((usize *)(((list)->elements))) + (((list)->length) * ((list)->type_size)))), ((elem).ptr), ((list)->type_size)));
    (((list)->length) = (((list)->length) + ((usize)(1llu))));
}
none popPS3646rN(GAF_List_s *list) { ((popPS3646AnyrN)((list), (NULL))); }
none popPS3646AnyrN(GAF_List_s *list, Any dst) {
    ((assertBPcrN)((((list)->length) > ((usize)(0llu))), ("GAF_List.pop: Attempted to pop from empty list")));
    (((list)->length) = (((list)->length) - ((usize)(1llu))));
    if ((dst) != (NULL)) {
        usize *elem = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + (((list)->length) * ((list)->type_size))));
        (((memcpy))((dst), (elem), ((list)->type_size)));
    }
}
Data_s get_refPS3646uszrS4175(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.get_ref: Out of bounds access")));
    return ((Data_s){.ptr = ((get_ref_rawPS3646uszrAny)((list), (index))), .info = ((list)->type)});
}
Any get_ref_rawPS3646uszrAny(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.get_ref_raw: Out of bounds access")));
    return ((Any)(((usize)(((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((index) * ((list)->type_size))))))));
}
none swap_removePS3646uszrN(GAF_List_s *list, usize index) {
    ((assertBPcrN)(((index) < ((list)->length)), ("GAF_List.swap_remove: Out of bounds removal")));
    usize *dst = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((index) * ((list)->type_size))));
    usize *src = ((usize *)((unsigned char *)((usize *)(((list)->elements))) + ((((list)->length) - ((usize)(1llu))) * ((list)->type_size))));
    (((memcpy))((dst), (src), ((list)->type_size)));
    (((list)->length) = (((list)->length) - ((usize)(1llu))));
}
usize _anon_46_0S4175rusz(Data_s key) { return ((hashPS7720rusz)(((SubStr_s *)(((key).ptr))))); }
bool _anon_46_1S4175S4175rB(Data_s k1, Data_s k2) { return ((equalsPS7720PS7720rB)(((SubStr_s *)(((k1).ptr))), ((SubStr_s *)(((k2).ptr))))); }
GAF_HashMap_s new_hashmap_with_substr_keyU7843rS4580(TypeInfo_u info) {
    return ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((type_info_table[16]), (info), (_anon_46_0S4175rusz), (_anon_46_1S4175S4175rB)));
}
usize _anon_46_2S4175rusz(Data_s key) { return ((hashPS0540rusz)(((String_s *)(((key).ptr))))); }
bool _anon_46_3S4175S4175rB(Data_s k1, Data_s k2) { return ((equalsPS0540PS0540rB)(((String_s *)(((k1).ptr))), ((String_s *)(((k2).ptr))))); }
GAF_HashMap_s new_hashmap_with_string_keyU7843rS4580(TypeInfo_u info) {
    return ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((type_info_table[18]), (info), (_anon_46_2S4175rusz), (_anon_46_3S4175S4175rB)));
}
GAF_HashMap_s new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580(TypeInfo_u key, TypeInfo_u value, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s)) {
    return ((GAF_HashMap_s){.elements = (NULL),
                            .keys = (NULL),
                            .set_elements = (NULL),
                            .length = ((usize)(0llu)),
                            .capacity = ((usize)(0llu)),
                            .key_type = (key),
                            .key_type_size = ((get_sizePU7843rusz)((&(key)))),
                            .value_type = (value),
                            .value_type_size = ((get_sizePU7843rusz)((&(value)))),
                            .key_hash_fn = (key_hash),
                            .key_equals_fn = (key_equals)});
}
none _anon_46_4S4175S4175PS3646rN(Data_s k, Data_s elem, GAF_List_s *arg) { ((pushPS3646S4175rN)((arg), (elem))); }
GAF_List_s asListPS4580rS3646(GAF_HashMap_s *this) {
    GAF_List_s l = ((new_GAF_ListU7843rS3646)(((this)->value_type)));
    ((foreachPS4580FN_S4175_S4175AnyAnyrN)((this), (_anon_46_4S4175S4175PS3646rN), (&(l))));
    return (l);
}
none enumeratePS4580FN_usz_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s)) {
    usize index = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10879_ = true;

            tuple_4545 tmp_17462_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17462_._0;
            succ_10879_ &= true;
            Data_s *value = &tmp_17462_._1;
            succ_10879_ &= true;
            (void)succ_10879_;
            ((fn)((index), (*key), (*value)));
            ((index) = ((index) + ((usize)(1llu))));
        }
    }
}
none enumeratePS4580FN_usz_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(usize, Data_s, Data_s, Any), Any arg) {
    usize index = ((usize)(0llu));
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10886_ = true;

            tuple_4545 tmp_17471_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17471_._0;
            succ_10886_ &= true;
            Data_s *value = &tmp_17471_._1;
            succ_10886_ &= true;
            (void)succ_10886_;
            ((fn)((index), (*key), (*value), (arg)));
            ((index) = ((index) + ((usize)(1llu))));
        }
    }
}
none foreachPS4580FN_S4175S4175rN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s)) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10891_ = true;

            tuple_4545 tmp_17479_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17479_._0;
            succ_10891_ &= true;
            Data_s *value = &tmp_17479_._1;
            succ_10891_ &= true;
            (void)succ_10891_;
            ((fn)((*key), (*value)));
        }
    }
}
none foreachPS4580FN_S4175_S4175AnyAnyrN(GAF_HashMap_s *this, none (*fn)(Data_s, Data_s, Any), Any arg) {
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        if ((((this)->set_elements))[(i)]) {
            bool succ_10896_ = true;

            tuple_4545 tmp_17486_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
            Data_s *key = &tmp_17486_._0;
            succ_10896_ &= true;
            Data_s *value = &tmp_17486_._1;
            succ_10896_ &= true;
            (void)succ_10896_;
            ((fn)((*key), (*value), (arg)));
        }
    }
}
bool needsResizePS4580rB(GAF_HashMap_s *this) {
    if (((this)->capacity) == ((usize)(0llu)))
        return (true);
    f64 loadFactor = (((f64)(((this)->length))) / ((f64)(((this)->capacity))));
    ((assertBrN)(((loadFactor) <= ((f64)(1)))));
    return ((((f64)(10)) * (loadFactor)) > ((f64)(6)));
}
none resizeIfNecessaryPS4580rN(GAF_HashMap_s *this) {
    if (!((needsResizePS4580rB)((this))))
        return;
    usize newCap = (((this)->capacity) * ((usize)(2llu)));
    if ((newCap) == ((usize)(0llu)))
        ((newCap) = ((usize)(256llu)));
    Any newElements = (((calloc))((newCap), ((this)->value_type_size)));
    ((assertBPcrN)(((newElements) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    Any newKeys = (((calloc))((newCap), ((this)->key_type_size)));
    ((assertBPcrN)(((newKeys) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    Any newSetElements = (((calloc))((newCap), (sizeof(bool))));
    ((assertBPcrN)(((newSetElements) != (NULL)), ("Could not allocate memory in GAF_HashMap.resizeIfNecessary")));
    GAF_HashMap_s newThis = ((GAF_HashMap_s){.elements = (newElements),
                                             .keys = (newKeys),
                                             .set_elements = (newSetElements),
                                             .length = ((usize)(0llu)),
                                             .capacity = (newCap),
                                             .key_type = ((this)->key_type),
                                             .key_type_size = ((this)->key_type_size),
                                             .value_type = ((this)->value_type),
                                             .value_type_size = ((this)->value_type_size),
                                             .key_hash_fn = ((this)->key_hash_fn),
                                             .key_equals_fn = ((this)->key_equals_fn)});
    for (usize i = ((usize)(0llu)); ((i) < ((this)->capacity)); ((i) = ((i) + ((usize)(1llu))))) {
        bool succ_10910_ = true;

        tuple_4545 tmp_17510_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (i)));
        Data_s *key = &tmp_17510_._0;
        succ_10910_ &= true;
        Data_s *value = &tmp_17510_._1;
        succ_10910_ &= true;
        (void)succ_10910_;
        if ((((this)->set_elements))[(i)])
            ((addPS4580S4175S4175rN)((&(newThis)), (*key), (*value)));
    }

    (((free))(((this)->elements)));
    (((free))(((this)->keys)));
    (((free))(((this)->set_elements)));
    ((*(this)) = (newThis));
}
none addPS4580S4175S4175rN(GAF_HashMap_s *this, Data_s key, Data_s value) {
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->key_type)), (&((key).info)))), ("GAF_HashMap.add: Key type mismatch")));
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->value_type)), (&((value).info)))), ("GAF_HashMap.add: Value type mismatch")));
    ((resizeIfNecessaryPS4580rN)((this)));
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize _hash = ((((this)->key_hash_fn)((key))) % ((this)->capacity));
    usize stop = ((_hash) - ((usize)(1llu)));
    if ((_hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((_hash) != (stop)) {
        bool succ_10917_ = true;

        tuple_4545 tmp_17527_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (_hash)));
        Data_s *_key = &tmp_17527_._0;
        succ_10917_ &= true;
        Data_s *_value = &tmp_17527_._1;
        succ_10917_ &= true;
        (void)succ_10917_;
        bool must_write = (false);
        if (!((((this)->set_elements))[(_hash)])) {
            ((must_write) = (true));
            (((this)->length) = (((this)->length) + ((usize)(1llu))));
        }

        else if (((this)->key_equals_fn)((*_key), (key))) {
            ((must_write) = (true));
        }

        if (must_write) {
            (((memcpy))(((*_key).ptr), ((key).ptr), ((this)->key_type_size)));
            (((memcpy))(((*_value).ptr), ((value).ptr), ((this)->value_type_size)));
            (((((this)->set_elements))[(_hash)]) = (true));
            return;
        }

        ((_hash) = (((_hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Could not insert element into HashMap")));
}
bool containsPS4580S4175rB(GAF_HashMap_s *this, Data_s key) { return ((((getPS4580S4175rS4175)((this), (key))).ptr) != (NULL)); }
Data_s getPS4580S4175rS4175(GAF_HashMap_s *this, Data_s key) {
    ((assertBPcrN)(((equalsPU7843PU7843rB)((&((this)->key_type)), (&((key).info)))), ("GAF_HashMap.get: Key type mismatch")));
    if (((this)->length) == ((usize)(0llu)))
        return ((Data_s){.info = ((this)->value_type), .ptr = (NULL)});
    ((assertBrN)((((this)->capacity) > ((usize)(0llu)))));
    usize _hash = ((((this)->key_hash_fn)((key))) % ((this)->capacity));
    usize stop = ((_hash) - ((usize)(1llu)));
    if ((_hash) == ((usize)(0llu)))
        ((stop) = (((this)->capacity) - ((usize)(1llu))));
    while ((_hash) != (stop)) {
        bool succ_10925_ = true;

        tuple_4545 tmp_17555_ = ((getAtIndexPS4580uszrT_S4175S4175)((this), (_hash)));
        Data_s *_key = &tmp_17555_._0;
        succ_10925_ &= true;
        Data_s *_value = &tmp_17555_._1;
        succ_10925_ &= true;
        (void)succ_10925_;
        if (!((((this)->set_elements))[(_hash)]))
            return ((Data_s){.info = ((this)->value_type), .ptr = (NULL)});
        if (((this)->key_equals_fn)((*_key), (key)))
            return (*_value);
        ((_hash) = (((_hash) + ((usize)(1llu))) % ((this)->capacity)));
    }

    ((unreachablePcrN)(("Load Factor guarantees that there\'s always at least one unset Entry in the HashMap.")));
}
tuple_4545 getAtIndexPS4580uszrT_S4175S4175(GAF_HashMap_s *this, usize index) {
    ((assertBPcrN)(((index) < ((this)->capacity)), ("Out of bounds access in GAF_HashMap.getAtIndex")));
    Data_s key = ((Data_s){.ptr = ((char *)((unsigned char *)((char *)(((this)->keys))) + ((index) * ((this)->key_type_size)))), .info = ((this)->key_type)});
    Data_s value = ((Data_s){.ptr = ((char *)((unsigned char *)((char *)(((this)->elements))) + ((index) * ((this)->value_type_size)))), .info = ((this)->value_type)});
    return ((tuple_4545){(key), (value)});
}
GAF_HashSet_s new_substr_hashsetrS1250(none) { return ((GAF_HashSet_s){._map = ((new_hashmap_with_substr_keyU7843rS4580)((type_info_table[10])))}); }
GAF_HashSet_s new_string_hashsetrS1250(none) { return ((GAF_HashSet_s){._map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[10])))}); }
GAF_HashSet_s new_GAF_HashSetU7843FuszS4175FB_S4175S4175rS1250(TypeInfo_u key, usize (*key_hash)(Data_s), bool (*key_equals)(Data_s, Data_s)) {
    return ((GAF_HashSet_s){._map = ((new_GAF_HashMapU7843U7843FuszS4175FB_S4175S4175rS4580)((key), (type_info_table[10]), (key_hash), (key_equals)))});
}
none addPS1250S4175rN(GAF_HashSet_s *this, Data_s key) {
    bool tmp_91624 = (true);

    ((addPS4580S4175S4175rN)((&((this)->_map)), (key), ((Data_s){.ptr = &tmp_91624, .info = type_info_table[10]})));
}
bool containsPS1250S4175rB(GAF_HashSet_s *this, Data_s key) { return ((containsPS4580S4175rB)((&((this)->_map)), (key))); }
CStack_s newCStackrS1662(none) { return ((CStack_s){.variables = ((new_hashmap_with_substr_keyU7843rS4580)((type_info_table[213])))}); }
CGen_s newCGenrS9442(none) {
    return ((CGen_s){.stack = ((new_GAF_ListU7843rS3646)((type_info_table[214]))),
                     .variadic_map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .array_map_declared = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .array_map_defined = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .tuple_map_declared = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .tuple_map_defined = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[18]))),
                     .type_info_table = ((generateTypeInfoTablerS3131)())});
}
tuple_4329 getVariableInfoPS9442S7720rT_S0610B(CGen_s *this, SubStr_s name) {
    for (usize _i = ((usize)(0llu)); ((_i) < (((this)->stack).length)); ((_i) = ((_i) + ((usize)(1llu))))) {
        usize i = (((((this)->stack).length) - (_i)) - ((usize)(1llu)));
        CStack_s *entry = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), (i)))));
        SubStr_s tmp_90917 = (name);

        Data_s _entry = ((getPS4580S4175rS4175)((&((entry)->variables)), ((Data_s){.ptr = &tmp_90917, .info = type_info_table[16]})));
        if (((_entry).ptr) != (NULL)) {
            return ((tuple_4329){(*(Var_Context_s *)((_entry).ptr)), (true)});
        }
    }

    return ((tuple_4329){((Var_Context_s){0}), (false)});
}
String_s unescapeS7720rS0540(SubStr_s s) {
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((s).len)); ((i) = ((i) + ((usize)(1llu))))) {
        if (((((s).start))[(i)]) == ('\0')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\0")));
        }

        else if (((((s).start))[(i)]) == ('\n')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\n")));
        }

        else if (((((s).start))[(i)]) == ('\t')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\t")));
        }

        else if (((((s).start))[(i)]) == ('\r')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\r")));
        }

        else if (((((s).start))[(i)]) == ('\\')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\\")));
        }

        else if (((((s).start))[(i)]) == ('\'')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\'")));
        }

        else if (((((s).start))[(i)]) == ('\"')) {
            ((pushStrPS0540PcrN)((&(out)), ("\\\"")));
        }

        else if ((((u8)(((((s).start))[(i)]))) >= ((u8)(127))) || (((((s).start))[(i)]) < (' '))) {
            ((pushStrPS0540PcrN)((&(out)), ("\\x")));
            String_s tmp = ((String_s){0});
            ((pushNumberAsHexPS0540uszrN)((&(tmp)), ((usize)(((((s).start))[(i)])))));
            (((tmp).buffer) = ((char *)((unsigned char *)((tmp).buffer) + ((usize)(2llu)))));
            (((tmp).length) = (((tmp).length) - ((usize)(2llu))));
            ((pushStringPS0540PS0540rN)((&(out)), (&(tmp))));
            (((tmp).buffer) = ((char *)((unsigned char *)((tmp).buffer) - ((usize)(2llu)))));
            (((tmp).length) = (((tmp).length) + ((usize)(2llu))));
            ((dropPS0540rN)((&(tmp))));
        }

        else {
            ((pushCharPS0540crN)((&(out)), ((((s).start))[(i)])));
        }
    }

    return (out);
}
String_s generateTypeNamePS9442PU5175S0540rS0540(CGen_s *this, Type_u *type, String_s nameForType) {
    return ((generateTypeNamePS9442PU5175S7720rS0540)((this), (type), ((asSubStrPS0540rS7720)((&(nameForType))))));
}
String_s generateTypeNamePS9442PU5175S7720rS0540(CGen_s *this, Type_u *type, SubStr_s nameForType) {
    return ((generateTypeNamePS9442PU5175S7720uszrS0540)((this), (type), (nameForType), ((usize)(0llu))));
}
String_s generateTypeNamePS9442PU5175S7720uszrS0540(CGen_s *this, Type_u *type, SubStr_s nameForType, usize size) {
    String_s out = ((String_s){0});
    bool succ_10947_ = true;

    Type_u *tmp_17660_ = (type);
    {
        succ_10947_ &= (tmp_17660_->tag == 6);
        TypeList_s *params = &tmp_17660_->payload.variant6._0;
        succ_10947_ &= true;
        Type_u **ret = &tmp_17660_->payload.variant6._1;
        succ_10947_ &= true;
        succ_10947_ &= true;
        if (succ_10947_) {
            {
                if ((size) == ((usize)(0llu))) {
                    String_s tmp_90918 = ((generateTypeNamePS9442PU5175rS0540)((this), (*ret)));
                    SubStr_s tmp_90919 = (nameForType);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% (*%)("),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_90918, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90919, .info = type_info_table[16]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_90921 = ((generateTypeNamePS9442PU5175rS0540)((this), (*ret)));
                    SubStr_s tmp_90922 = (nameForType);
                    usize tmp_90923 = (size);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% (*%[%])("),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_90921, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90922, .info = type_info_table[16]}),
                                                                               ((Data_s){.ptr = &tmp_90923, .info = type_info_table[8]})},
                                                               .length = 3})));
                }

                if (((*params).length) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("none"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }

                else {
                    for (usize i = ((usize)(0llu)); ((i) < ((*params).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_90926 = ((generateTypeNamePS9442PU5175rS0540)((this), ((((*params).elements))[(i)])));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90926, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*params).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (")"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_17660;
        }
    }
    {
        if (true) {
            {
                if (((nameForType).len) != ((usize)(0llu))) {
                    if ((size) != ((usize)(0llu))) {
                        String_s tmp_90930 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        SubStr_s tmp_90931 = (nameForType);
                        usize tmp_90932 = (size);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% %[%]"),
                                                  ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_90930, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_90931, .info = type_info_table[16]}),
                                                                                      ((Data_s){.ptr = &tmp_90932, .info = type_info_table[8]})},
                                                                   .length = 3})));
                    }

                    else {
                        String_s tmp_90934 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        SubStr_s tmp_90935 = (nameForType);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% %"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_90934, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90935, .info = type_info_table[16]})},
                                                      .length = 2})));
                    }

                }

                else {
                    if ((size) != ((usize)(0llu))) {
                        String_s tmp_90937 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
                        usize tmp_90938 = (size);

                        ((formatPS0540PcVS4175rN)((&(out)), ("%[%]"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_90937, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90938, .info = type_info_table[8]})},
                                                      .length = 2})));
                    }

                    else {
                        String_s tmp_90940 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90940, .info = type_info_table[18]})}, .length = 1})));
                    }
                }
            }
            goto after_17660;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17660:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateTypeNamePS9442PU5175rS0540(CGen_s *this, Type_u *type) {
    bool succ_10954_ = true;
    bool succ_10958_ = true;
    bool succ_10962_ = true;
    bool succ_10968_ = true;
    bool succ_10973_ = true;
    bool succ_10979_ = true;
    bool succ_10983_ = true;
    bool succ_10989_ = true;

    Type_u *tmp_17707_ = (type);
    {
        succ_10954_ &= (tmp_17707_->tag == 3);
        succ_10954_ &= true;
        if (succ_10954_) {
            {
                return ((toStringPU5175rS0540)((type)));
            }
            goto after_17707;
        }
    }
    {
        succ_10958_ &= (tmp_17707_->tag == 4);
        Type_u **under = &tmp_17707_->payload.variant4._0;
        succ_10958_ &= true;
        if (succ_10958_) {
            {
                String_s tmp_90942 = ((generateTypeNamePS9442PU5175rS0540)((this), (*under)));

                return ((format1PcVS4175rS0540)(("%*"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90942, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_17707;
        }
    }
    {
        succ_10962_ &= (tmp_17707_->tag == 7);
        ParsedStructDecl_s **decl = &tmp_17707_->payload.variant7._0;
        succ_10962_ &= true;
        if (succ_10962_) {
            {
                String_s name = ((getFullNamePS5521PcrS0540)((*decl), ("_")));
                ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
                return (name);
            }
            goto after_17707;
        }
    }
    {
        succ_10968_ &= (tmp_17707_->tag == 8);
        ParsedUnionDecl_s **decl = &tmp_17707_->payload.variant8._0;
        succ_10968_ &= true;
        succ_10968_ &= true;
        if (succ_10968_) {
            {
                String_s name = ((getFullNamePS0997PcrS0540)((*decl), ("_")));
                ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
                return (name);
            }
            goto after_17707;
        }
    }
    {
        succ_10973_ &= (tmp_17707_->tag == 10);
        TypeList_s *elems = &tmp_17707_->payload.variant10._0;
        succ_10973_ &= true;
        if (succ_10973_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_90944 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_90944, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_90945 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90945, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17707;
        }
    }
    {
        succ_10979_ &= (tmp_17707_->tag == 6);
        succ_10979_ &= true;
        if (succ_10979_) {
            {
                return ((generateTypeNamePS9442PU5175S7720rS0540)((this), (type), (((newSubStrOfStrLitPcrS7720)((""))))));
            }
            goto after_17707;
        }
    }
    {
        succ_10983_ &= (tmp_17707_->tag == 5);
        succ_10983_ &= true;
        if (succ_10983_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_90947 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_90947, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_90948 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("array_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90948, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17707;
        }
    }
    {
        succ_10989_ &= (tmp_17707_->tag == 2);
        Type_u **under = &tmp_17707_->payload.variant2._0;
        succ_10989_ &= true;
        if (succ_10989_) {
            {
                String_s _t = ((toStringPU5175rS0540)((type)));
                String_s tmp_90950 = (_t);

                Data_s _v = ((getPS4580S4175rS4175)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_90950, .info = type_info_table[18]})));
                ((dropPS0540rN)((&(_t))));
                if (((_v).ptr) == (NULL)) {
                    usize tmp_90951 = ((getIDPU5175rusz)((type)));

                    return ((format1PcVS4175rS0540)(("variadic_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90951, .info = type_info_table[8]})}, .length = 1})));
                }

                else {
                    return (*(String_s *)((_v).ptr));
                }
            }
            goto after_17707;
        }
    }
    {
        if (true) {
            {
                String_s tmp_83650 = ((toStringPU5175rS0540)((type)));

                ((printPS0540rN)((&tmp_83650)));
                (((printf))(("\n")));
                return ((newStringFromStrLitPcrS0540)(("/*TODO: generateTypeName */")));
            }
            goto after_17707;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17707:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generateTypeName")));
}
String_s generateTypeNamePS9442PS1372rS0540(CGen_s *this, ParsedTypeNode_s *type) { return ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((type)->typeState)))))); }
none makeNameCCompatiblePS0540rN(String_s *name) { ((makeNameCCompatiblePS0540PcrN)((name), (""))); }
none makeNameCCompatiblePS0540PcrN(String_s *name, char *prefix) {
    array_33013 forbidden = ((array_33013){("stdin"),    ("stdout"), ("stderr"), ("enum"),   ("union"),    ("struct"), ("if"),   ("else"),  ("switch"), ("case"), ("for"),  ("while"), ("break"),
                                           ("continue"), ("do"),     ("return"), ("signed"), ("unsigned"), ("void"),   ("bool"), ("float"), ("double"), ("int"),  ("char"), ("short"), ("long")});
    ((pushStrPS0540PcrN)((name), (prefix)));
    for (usize i = ((usize)(0llu)); ((i) < (26)); ((i) = ((i) + ((usize)(1llu))))) {
        String_s s = ((newStringFromStrLitPcrS0540)((((forbidden).arr)[(i)])));
        if ((equalsPS0540PS0540rB)((name), (&(s)))) {
            String_s tmp_90953 = (s);

            ((*(name)) = ((format1PcVS4175rS0540)(("%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90953, .info = type_info_table[18]})}, .length = 1}))));
        }

        ((dropPS0540rN)((&(s))));
    }

    ((replacePS0540ccrN)((name), ('.'), ('_')));
}
none generateBuiltinTypedefsPS0540rN(String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Builtin Types:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stddef.h> // NULL\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stdbool.h> // bool\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("#include <stdint.h>\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint8_t u8;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint16_t u16;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint32_t u32;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef uint64_t u64;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int8_t i8;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int16_t i16;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int32_t i32;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef int64_t i64;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef void* Any;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef void none;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef float f32;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef double f64;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("typedef u64 usize;\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// C doesn\'t have f32 \\% f32 etc.\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("float fmodf(float x, float y);\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("double fmod(double x, double y);\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none forwardDeclareTypesPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Struct Declarations:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareStructPS0540PS5521rN)((out), ((atPS2168uszrPS5521)((&(structDecls)), (i)))));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Union Declarations:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareUnionPS0540PS0997rN)((out), ((atPS4268uszrPS0997)((&(unionDecls)), (i)))));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Tuple Types:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((forwardDeclareTuplePS9442PS0540PU5175rN)((this), (out), (type)));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("// Array Types:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((forwardDeclareArrayPS9442PS0540PU5175rN)((this), (out), (type)));
    }

    ((formatPS0540PcVS4175rN)((out), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none emitTypeDeclarationPS9442PS0540PS4580PU5175rN(CGen_s *this, String_s *out, GAF_HashMap_s *map, Type_u *type) {
    String_s tmp_90984 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

    Data_s _entry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_90984, .info = type_info_table[18]})));
    bool succ_11012_ = true;
    bool succ_11019_ = true;
    bool succ_11029_ = true;
    bool succ_11041_ = true;

    Type_u *tmp_17848_ = (type);
    {
        succ_11012_ &= (tmp_17848_->tag == 5);
        Type_u **elem = &tmp_17848_->payload.variant5._0;
        succ_11012_ &= true;
        succ_11012_ &= true;
        if (succ_11012_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find array")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                String_s tmp_90985 = ((generateTypeNamePS9442PU5175rS0540)((this), (*elem)));

                Data_s elemEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_90985, .info = type_info_table[18]})));
                if (((elemEntry).ptr) != (NULL)) {
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((elemEntry).ptr)));
                    if (!((entry)->generated)) {
                        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (*elem)));
                    }
                }
            }
            goto after_17848;
        }
    }
    {
        succ_11019_ &= (tmp_17848_->tag == 10);
        TypeList_s *elems = &tmp_17848_->payload.variant10._0;
        succ_11019_ &= true;
        if (succ_11019_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find tuple")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize j = ((usize)(0llu)); ((j) < ((*elems).length)); ((j) = ((j) + ((usize)(1llu))))) {
                    Type_u *field = ((((*elems).elements))[(j)]);
                    String_s tmp_90986 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                    Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_90986, .info = type_info_table[18]})));
                    if (((fieldEntry).ptr) == (NULL))
                        continue;
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                    if ((entry)->generated)
                        continue;
                    ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                }
            }
            goto after_17848;
        }
    }
    {
        succ_11029_ &= (tmp_17848_->tag == 7);
        ParsedStructDecl_s **strukt = &tmp_17848_->payload.variant7._0;
        succ_11029_ &= true;
        if (succ_11029_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find struct")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize j = ((usize)(0llu)); ((j) < (((*strukt)->context).fieldLength)); ((j) = ((j) + ((usize)(1llu))))) {
                    ParsedTypeNode_s *_field = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*strukt)->context)), (j)));
                    Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                    String_s tmp_90987 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                    Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_90987, .info = type_info_table[18]})));
                    if (((fieldEntry).ptr) == (NULL))
                        continue;
                    TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                    if ((entry)->generated)
                        continue;
                    ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                }
            }
            goto after_17848;
        }
    }
    {
        succ_11041_ &= (tmp_17848_->tag == 8);
        ParsedUnionDecl_s **onion = &tmp_17848_->payload.variant8._0;
        succ_11041_ &= true;
        succ_11041_ &= true;
        if (succ_11041_) {
            {
                ((assertBPcrN)((((_entry).ptr) != (NULL)), ("emitTypeDeclaration: Could not find union")));
                TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
                if ((entry)->generated)
                    return;
                for (usize i = ((usize)(0llu)); ((i) < (((*onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((*onion)->variants)), (i))));
                    bool succ_11049_ = true;
                    bool succ_11047_ = true;

                    tuple_1044 tmp_17830_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
                    succ_11047_ = tmp_17830_._0 == true;
                    succ_11049_ &= succ_11047_;
                    ParsedTypeNodeList_s **fields = &tmp_17830_._1;
                    succ_11049_ &= true;
                    if (!succ_11049_) {
                        continue;
                    };
                    for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                        ParsedTypeNode_s *_field = (*((atPS6760uszrPPS1372)((*fields), (j))));
                        Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                        String_s tmp_90988 = ((generateTypeNamePS9442PU5175rS0540)((this), (field)));

                        Data_s fieldEntry = ((getPS4580S4175rS4175)((map), ((Data_s){.ptr = &tmp_90988, .info = type_info_table[18]})));
                        if (((fieldEntry).ptr) == (NULL))
                            continue;
                        TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((fieldEntry).ptr)));
                        if ((entry)->generated)
                            continue;
                        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (map), (field)));
                    }
                }
            }
            goto after_17848;
        }
    }
    {
        if (true) {
            {
                ((assertBPcrN)((((_entry).ptr) == (NULL)), ("emitTypeDeclaration: Missed a Type")));
            }
            goto after_17848;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_17848:
    (void)0; // error: label at end of compound statement is a C23 extension
    if (((_entry).ptr) != (NULL)) {
        TypeDeclEntry_s *entry = ((TypeDeclEntry_s *)(((_entry).ptr)));
        ((assertBPcrN)((!((entry)->generated)), ("emitTypeDeclaration: Type already generated")));
        ((pushStringPS0540PS0540rN)((out), (&((entry)->c_code))));
        (((entry)->generated) = (true));
    }
}
none emitVariadicTypePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11060_ = true;

    Type_u *tmp_17856_ = (type);
    succ_11060_ &= (tmp_17856_->tag == 2);
    Type_u **under = &tmp_17856_->payload.variant2._0;
    succ_11060_ &= true;
    if (!succ_11060_) {
        ((unreachablePcrN)(("emitVariadicType")));
    };
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_90989 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_90989, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_90990 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("variadic_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90990, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_90992 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90992, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_90994 = (ind);
    String_s tmp_90995 = ((generateTypeNamePS9442PU5175rS0540)((this), (*under)));

    ((formatPS0540PcVS4175rN)((out), ("%%* ptr;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_90994, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_90995, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_90997 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%usize length;\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90997, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_90999 = (name);

    ((formatPS0540PcVS4175rN)((out), ("} %;\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_90999, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91001 = (_t);
    String_s tmp_91002 = (name);

    ((addPS4580S4175S4175rN)((&((this)->variadic_map)), ((Data_s){.ptr = &tmp_91001, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91002, .info = type_info_table[18]})));
}
none generateTypeDeclarationsPS9442PS0540rN(CGen_s *this, String_s *out) {
    GAF_HashMap_s map = ((new_hashmap_with_string_keyU7843rS4580)((type_info_table[216])));
    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((strukt)->ignored)
            continue;
        String_s s = ((String_s){0});
        ((generateStructDefinitionPS9442PS0540PS5521rN)((this), (&(s)), (strukt)));
        String_s tmp_91003 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((strukt)->typeState))))));
        TypeDeclEntry_s tmp_91004 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91003, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91004, .info = type_info_table[216]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((onion)->ignored)
            continue;
        String_s s = ((String_s){0});
        ((generateUnionDefinitionPS9442PS0540PS0997rN)((this), (&(s)), (onion)));
        String_s tmp_91005 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((onion)->typeState))))));
        TypeDeclEntry_s tmp_91006 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91005, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91006, .info = type_info_table[216]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        String_s s = ((String_s){0});
        ((generateTupleDefinitionPS9442PS0540PU5175rN)((this), (&(s)), (type)));
        if (((s).length) == ((usize)(0llu)))
            continue;
        String_s tmp_91007 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
        TypeDeclEntry_s tmp_91008 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91007, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91008, .info = type_info_table[216]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        String_s s = ((String_s){0});
        ((generateArrayDefinitionPS9442PS0540PU5175rN)((this), (&(s)), (type)));
        if (((s).length) == ((usize)(0llu)))
            continue;
        String_s tmp_91009 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));
        TypeDeclEntry_s tmp_91010 = ((TypeDeclEntry_s){.c_code = (s)});

        ((addPS4580S4175S4175rN)((&(map)), ((Data_s){.ptr = &tmp_91009, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91010, .info = type_info_table[216]})));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((structDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedStructDecl_s *strukt = ((atPS2168uszrPS5521)((&(structDecls)), (i)));
        if ((strukt)->ignored)
            continue;
        Type_u *sType = ((getTypePU9661rPU5175)((&((strukt)->typeState))));
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (sType)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((unionDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionDecl_s *onion = ((atPS4268uszrPS0997)((&(unionDecls)), (i)));
        if ((onion)->ignored)
            continue;
        Type_u *uType = ((getTypePU9661rPU5175)((&((onion)->typeState))));
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (uType)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isTuplePU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (type)));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((types).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *type = ((atPS4174uszrPU5175)((&(types)), (i)));
        if (!((isArrayPU5175rB)((type))))
            continue;
        if ((containsInvalidTypePU5175rB)((type)))
            continue;
        ((emitTypeDeclarationPS9442PS0540PS4580PU5175rN)((this), (out), (&(map)), (type)));
    }
}
none forwardDeclareFunctionsPS9442PS0540rN(CGen_s *this, String_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((forwardDeclareFunctionPS9442PS0540PS4904rN)((this), (out), ((atPS4111uszrPS4904)((&(funcDecls)), (i)))));
    }
}
none generateFunctionDefinitionsPS9442PS0540rN(CGen_s *this, String_s *out) {
    for (usize i = ((usize)(0llu)); ((i) < ((funcDecls).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ((generateFunctionDefinitionPS9442PS0540PS4904rN)((this), (out), ((atPS4111uszrPS4904)((&(funcDecls)), (i)))));
    }
}
none _anon_44_0PS9442PS0540S6070PU5175PS2435uszrN(CGen_s *this, String_s *out, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent) {
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s tmp_91012 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (_name)));

    ((formatPS0540PcVS4175rN)((out), ("%;\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91012, .info = type_info_table[18]})}, .length = 1})));
    CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
    SubStr_s tmp_91014 = ((tkn).content);
    Var_Context_s tmp_91015 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

    ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91014, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91015, .info = type_info_table[213]})));
}
none generateGlobalVariablesPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("// Global Variables:\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                ParsedStmt_s *_decl = ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID)));
                bool succ_11116_ = true;

                StmtData_u *tmp_17966_ = (&((_decl)->data));
                succ_11116_ &= (tmp_17966_->tag == 0);
                VarDecl_s *decl = &tmp_17966_->payload.variant0._0;
                succ_11116_ &= true;
                if (!succ_11116_) {
                    ((unreachablerN)());
                };
                none (*fast_path)(CGen_s *, String_s *, Token_s, Type_u *, ParsedExpr_s *, usize) = (_anon_44_0PS9442PS0540S6070PU5175PS2435uszrN);
                bool succ_11124_ = true;

                {
                    Pattern_u *tmp_17976_ = (&(((*decl).pat)->data));
                    succ_11124_ &= (tmp_17976_->tag == 3);
                    ParsedPattern_s **subpat = &tmp_17976_->payload.variant3._0;
                    succ_11124_ &= true;
                    ParsedTypeNode_s **typ = &tmp_17976_->payload.variant3._1;
                    succ_11124_ &= true;

                    if (succ_11124_) {
                        bool succ_11128_ = true;

                        {
                            Pattern_u *tmp_17975_ = (&((*subpat)->data));
                            succ_11128_ &= (tmp_17975_->tag == 2);
                            Token_s *tkn = &tmp_17975_->payload.variant2._0;
                            succ_11128_ &= true;

                            if (succ_11128_) {
                                ((fast_path)((this), (out), (*tkn), ((getTypePU9661rPU5175)((&((*typ)->typeState)))), ((*decl).expr), ((usize)(0llu))));
                                continue;
                            }
                        }
                    }
                }

                bool succ_11132_ = true;

                {
                    Pattern_u *tmp_17979_ = (&(((*decl).pat)->data));
                    succ_11132_ &= (tmp_17979_->tag == 2);
                    Token_s *tkn = &tmp_17979_->payload.variant2._0;
                    succ_11132_ &= true;

                    if (succ_11132_) {
                        ((fast_path)((this), (out), (*tkn), ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState)))), ((*decl).expr), ((usize)(0llu))));
                        continue;
                    }
                }

                ((unreachablePcrN)(("generateGlobalVariables: Can\'t use slow_path here")));
            }
        }
    }
}
String_s _anon_44_1PS9442S6070PS2435uszrS0540(CGen_s *this, Token_s tkn, ParsedExpr_s *expr, usize indent) {
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s tmpAlloc = ((String_s){0});
    String_s tmp_91016 = ((generateIndentuszrS0540)((indent)));
    String_s tmp_91017 = (_name);
    String_s tmp_91018 = ((generateExprPS9442PS0540PS2435rS0540)((this), (&(tmpAlloc)), (expr)));

    return ((format1PcVS4175rS0540)(("%% = %;\n"),
                                    ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91016, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91017, .info = type_info_table[18]}),
                                                                        ((Data_s){.ptr = &tmp_91018, .info = type_info_table[18]})},
                                                     .length = 3})));
    ((assertBPcrN)((((tmpAlloc).length) == ((usize)(0llu))), ("generateGlobalInit: Expression needs entry")));
}
String_s generateGlobalInitPS9442PS1100uszrS0540(CGen_s *this, ParsedStmt_s *_decl, usize indent) {
    bool succ_11136_ = true;

    StmtData_u *tmp_17988_ = (&((_decl)->data));
    succ_11136_ &= (tmp_17988_->tag == 0);
    VarDecl_s *decl = &tmp_17988_->payload.variant0._0;
    succ_11136_ &= true;
    if (!succ_11136_) {
        ((unreachablerN)());
    };
    String_s (*fast_path)(CGen_s *, Token_s, ParsedExpr_s *, usize) = (_anon_44_1PS9442S6070PS2435uszrS0540);
    bool succ_11145_ = true;

    {
        Pattern_u *tmp_17997_ = (&(((*decl).pat)->data));
        succ_11145_ &= (tmp_17997_->tag == 3);
        ParsedPattern_s **subpat = &tmp_17997_->payload.variant3._0;
        succ_11145_ &= true;
        succ_11145_ &= true;

        if (succ_11145_) {
            bool succ_11149_ = true;

            {
                Pattern_u *tmp_17996_ = (&((*subpat)->data));
                succ_11149_ &= (tmp_17996_->tag == 2);
                Token_s *tkn = &tmp_17996_->payload.variant2._0;
                succ_11149_ &= true;

                if (succ_11149_) {
                    return ((fast_path)((this), (*tkn), ((*decl).expr), (indent)));
                }
            }
        }
    }

    bool succ_11153_ = true;

    {
        Pattern_u *tmp_17999_ = (&(((*decl).pat)->data));
        succ_11153_ &= (tmp_17999_->tag == 2);
        Token_s *tkn = &tmp_17999_->payload.variant2._0;
        succ_11153_ &= true;

        if (succ_11153_) {
            return ((fast_path)((this), (*tkn), ((*decl).expr), (indent)));
        }
    }

    ((unreachablePcrN)(("generateGlobalInit: Can\'t use slow_path here")));
}
none generateGlobalInitializationPS9442PS0540rN(CGen_s *this, String_s *out) {
    ((formatPS0540PcVS4175rN)((out), ("none __global_init_please_dont_call_yourself(none) {\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((files).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedFile_s *file = ((atPS9483uszrPS1892)((&(files)), (i)));
        for (usize j = ((usize)(0llu)); ((j) < ((((file)->mod)->tlis).length)); ((j) = ((j) + ((usize)(1llu))))) {
            ParsedTopLevelItem_s *tli = ((atPS9029uszrPS1038)((&(topLevelItems)), (*((atPS4113uszrPusz)((&(((file)->mod)->tlis)), (j))))));
            if ((tli)->ignored)
                continue;
            if (((tli)->kind) == (TLI_VAR_DECL)) {
                String_s tmp_91021 = ((generateGlobalInitPS9442PS1100uszrS0540)((this), ((atPS8227uszrPS1100)((&(stmts)), ((tli)->nodeID))), (INDENTATION_LEVEL)));

                ((formatPS0540PcVS4175rN)((out), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91021, .info = type_info_table[18]})}, .length = 1})));
            }
        }
    }

    ((formatPS0540PcVS4175rN)((out), ("}\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none transpileToCrN(none) {
    ((generateCCoderN)());
    ((generateBuildScriptrN)());
}
none generateCCoderN(none) {
    String_s c_code = ((String_s){0});
    CGen_s cgen = ((newCGenrS9442)());
    CStack_s tmp_91024 = ((newCStackrS1662)());

    ((pushPS3646S4175rN)((&((cgen).stack)), ((Data_s){.ptr = &tmp_91024, .info = type_info_table[214]})));
    ((generateBuiltinTypedefsPS0540rN)((&(c_code))));
    ((forwardDeclareTypesPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((generateTypeDeclarationsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((forwardDeclareFunctionsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((generateGlobalVariablesPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((generateGlobalInitializationPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((generateFunctionDefinitionsPS9442PS0540rN)((&(cgen)), (&(c_code))));
    ((formatPS0540PcVS4175rN)((&(c_code)), ("\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((generateEntrypointPS0540rN)((&(c_code))));
    ((writeStringToFilePcS0540rN)((((flags).out)->buffer), (c_code)));
    String_s tmp_91029 = (*((flags).out));

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91029, .info = type_info_table[18]})}, .length = 1})));
}
none generateBuildScriptrN(none) {
    ((generateClangScriptrN)());
    String_s tmp_85070 = ((toStringPS7720rS0540)((&(OS_WINDOWS))));
    String_s tmp_85082 = ((toStringPS7720rS0540)((&(OS_LINUX))));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85070))) {
        ((generateClexeScriptrN)());
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85082))) {
        ((generateGCCScriptrN)());
    }

    else {
        ((unreachablePcrN)(("generateBuildScript")));
    }
}
none generateClexeScriptrN(none) {
    String_s file = ((String_s){0});
    String_s tmp_91031 = (*((flags).out));

    String_s name = ((format1PcVS4175rS0540)(("%.cl.bat"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91031, .info = type_info_table[18]})}, .length = 1})));
    String_s command = ((String_s){0});
    String_s tmp_91033 = (*((flags).out));
    String_s tmp_91034 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("@cl.exe /nologo /Fe:%.exe %"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91033, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91034, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" /W4 /wd4047 /wd4024 /wd4100 /wd4189 /wd4702 /wd4101 /wd4456 /wd4459 /wd4457"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11180_ = true;

            Config_u *tmp_18056_ = (_flag);
            succ_11180_ &= (tmp_18056_->tag == 1);
            Token_s *name = &tmp_18056_->payload.variant1._0;
            succ_11180_ &= true;
            if (!succ_11180_) {
                continue;
            };
            SubStr_s tmp_91037 = ((*name).content);

            ((formatPS0540PcVS4175rN)((&(command)), (" %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91037, .info = type_info_table[16]})}, .length = 1})));
        }
    }

    bool emitted_link = (false);
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11191_ = true;
            bool succ_11195_ = true;

            Config_u *tmp_18083_ = (_flag);
            {
                succ_11191_ &= (tmp_18083_->tag == 3);
                Token_s *name = &tmp_18083_->payload.variant3._0;
                succ_11191_ &= true;
                if (succ_11191_) {
                    {
                        if (!(emitted_link)) {
                            ((formatPS0540PcVS4175rN)((&(command)), (" /link"), ((variadic_4507){.ptr = NULL, .length = 0})));
                            ((emitted_link) = (true));
                        }

                        SubStr_s tmp_91040 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" /LIBPATH:%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91040, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18083;
                }
            }
            {
                succ_11195_ &= (tmp_18083_->tag == 4);
                Token_s *name = &tmp_18083_->payload.variant4._0;
                succ_11195_ &= true;
                if (succ_11195_) {
                    {
                        if (!(emitted_link)) {
                            ((formatPS0540PcVS4175rN)((&(command)), (" /link"), ((variadic_4507){.ptr = NULL, .length = 0})));
                            ((emitted_link) = (true));
                        }

                        SubStr_s tmp_91043 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91043, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18083;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18083;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18083:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91045 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91045, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91047 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91047, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91049 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91049, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91051 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91051, .info = type_info_table[18]})}, .length = 1})));
}
none generateGCCScriptrN(none) {
    String_s file = ((String_s){0});
    ((formatPS0540PcVS4175rN)((&(file)), ("#!/usr/bin/env bash\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    String_s tmp_91054 = (*((flags).out));

    String_s name = ((format1PcVS4175rS0540)(("%.gcc.sh"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91054, .info = type_info_table[18]})}, .length = 1})));
    String_s command = ((String_s){0});
    String_s tmp_91056 = (*((flags).out));
    String_s tmp_91057 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("gcc -x c % -o %.exe"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91056, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91057, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wall -Wextra -pedantic -std=c99"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-builtin-declaration-mismatch -Wno-incompatible-pointer-types -Wno-missing-braces"), ((variadic_4507){.ptr = NULL, .length = 0})));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11212_ = true;
            bool succ_11216_ = true;
            bool succ_11220_ = true;

            Config_u *tmp_18115_ = (_flag);
            {
                succ_11212_ &= (tmp_18115_->tag == 1);
                Token_s *name = &tmp_18115_->payload.variant1._0;
                succ_11212_ &= true;
                if (succ_11212_) {
                    {
                        SubStr_s tmp_91062 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -l %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91062, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18115;
                }
            }
            {
                succ_11216_ &= (tmp_18115_->tag == 3);
                Token_s *name = &tmp_18115_->payload.variant3._0;
                succ_11216_ &= true;
                if (succ_11216_) {
                    {
                        SubStr_s tmp_91064 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -L %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91064, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18115;
                }
            }
            {
                succ_11220_ &= (tmp_18115_->tag == 4);
                Token_s *name = &tmp_18115_->payload.variant4._0;
                succ_11220_ &= true;
                if (succ_11220_) {
                    {
                        SubStr_s tmp_91066 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -Xlinker %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91066, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18115;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18115;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18115:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91068 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91068, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91070 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91070, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91072 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91072, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91074 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91074, .info = type_info_table[18]})}, .length = 1})));
}
none generateClangScriptrN(none) {
    String_s file = ((String_s){0});
    String_s name = ((String_s){0});
    String_s command = ((String_s){0});
    String_s tmp_91076 = (*((flags).out));
    String_s tmp_91077 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(command)), ("clang % -o %.exe"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91076, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91077, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wall -Wextra -pedantic -std=c99 -ferror-limit=5"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-incompatible-library-redeclaration -Wno-builtin-requires-header"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((&(command)), (" -Wno-unused-variable -Wno-unused-parameter -Wno-incompatible-function-pointer-types"), ((variadic_4507){.ptr = NULL, .length = 0})));
    String_s tmp_85454 = ((toStringPS7720rS0540)((&(OS_WINDOWS))));
    String_s tmp_85478 = ((toStringPS7720rS0540)((&(OS_LINUX))));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85454))) {
        String_s tmp_91082 = (*((flags).out));

        ((name) = ((format1PcVS4175rS0540)(("%.clang.bat"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91082, .info = type_info_table[18]})}, .length = 1}))));
        ((formatPS0540PcVS4175rN)((&(file)), ("@"), ((variadic_4507){.ptr = NULL, .length = 0})));
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_85478))) {
        String_s tmp_91085 = (*((flags).out));

        ((name) = ((format1PcVS4175rS0540)(("%.clang.sh"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91085, .info = type_info_table[18]})}, .length = 1}))));
        ((formatPS0540PcVS4175rN)((&(file)), ("#!/usr/bin/env bash\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    }

    else {
        ((unreachablePcrN)(("generateClangScript")));
    }

    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_11237_ = true;
            bool succ_11241_ = true;
            bool succ_11245_ = true;

            Config_u *tmp_18156_ = (_flag);
            {
                succ_11237_ &= (tmp_18156_->tag == 1);
                Token_s *name = &tmp_18156_->payload.variant1._0;
                succ_11237_ &= true;
                if (succ_11237_) {
                    {
                        SubStr_s tmp_91088 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -l %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91088, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18156;
                }
            }
            {
                succ_11241_ &= (tmp_18156_->tag == 3);
                Token_s *name = &tmp_18156_->payload.variant3._0;
                succ_11241_ &= true;
                if (succ_11241_) {
                    {
                        SubStr_s tmp_91090 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -L %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91090, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18156;
                }
            }
            {
                succ_11245_ &= (tmp_18156_->tag == 4);
                Token_s *name = &tmp_18156_->payload.variant4._0;
                succ_11245_ &= true;
                if (succ_11245_) {
                    {
                        SubStr_s tmp_91092 = ((*name).content);

                        ((formatPS0540PcVS4175rN)((&(command)), (" -Xlinker %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91092, .info = type_info_table[16]})}, .length = 1})));
                    }
                    goto after_18156;
                }
            }
            {
                if (true) {
                    {
                        continue;
                    }
                    goto after_18156;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_18156:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    String_s tmp_91094 = (command);

    ((formatPS0540PcVS4175rN)((&(file)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91094, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91096 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" && echo [INFO] Successfully generated %.exe"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91096, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91098 = (*((flags).out));

    ((formatPS0540PcVS4175rN)((&(file)), (" || echo [ERROR] Could not generate %.exe\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91098, .info = type_info_table[18]})}, .length = 1})));
    ((writeStringToFilePcS0540rN)(((name).buffer), (file)));
    String_s tmp_91100 = (name);

    ((fprintPcVS4175rN)(("[INFO] Successfully generated %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91100, .info = type_info_table[18]})}, .length = 1})));
}
none generateEntrypointPS0540rN(String_s *out) {
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    ((formatPS0540PcVS4175rN)((out), ("// The entry point for the C runtime\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((formatPS0540PcVS4175rN)((out), ("int main(int argc, char **argv) {\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    String_s tmp_91104 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%__global_init_please_dont_call_yourself();\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91104, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91106 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%return __real_main(argc, argv, &maini32PPcri32);\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91106, .info = type_info_table[18]})}, .length = 1})));
    ((formatPS0540PcVS4175rN)((out), ("}\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none forwardDeclareTuplePS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91109 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_91109, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize tmp_91110 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91110, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91112 = (name);
    String_s tmp_91113 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91112, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91113, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_91115 = (_t);
    String_s tmp_91116 = (name);

    ((addPS4580S4175S4175rN)((&((this)->tuple_map_declared)), ((Data_s){.ptr = &tmp_91115, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91116, .info = type_info_table[18]})));
}
none generateTupleDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11254_ = true;

    Type_u *tmp_18182_ = (type);
    succ_11254_ &= (tmp_18182_->tag == 10);
    TypeList_s *elems = &tmp_18182_->payload.variant10._0;
    succ_11254_ &= true;
    if (!succ_11254_) {
        ((unreachablePcrN)(("generateTupleDefinition")));
    };
    ((assertBrN)((((*elems).length) != ((usize)(0llu)))));
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91117 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->tuple_map_defined)), ((Data_s){.ptr = &tmp_91117, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_91118 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("tuple_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91118, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91120 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91120, .info = type_info_table[18]})}, .length = 1})));
    for (usize i = ((usize)(0llu)); ((i) < ((*elems).length)); ((i) = ((i) + ((usize)(1llu))))) {
        Type_u *field = ((((*elems).elements))[(i)]);
        usize tmp_91122 = (i);

        String_s _name = ((format1PcVS4175rS0540)(("_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91122, .info = type_info_table[8]})}, .length = 1})));
        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
        String_s tmp_91124 = (ind);
        String_s tmp_91125 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

        ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                                  ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91124, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91125, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    String_s tmp_91128 = (_t);
    String_s tmp_91129 = (name);

    ((addPS4580S4175S4175rN)((&((this)->tuple_map_defined)), ((Data_s){.ptr = &tmp_91128, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91129, .info = type_info_table[18]})));
}
none forwardDeclareArrayPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91130 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_91130, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize tmp_91131 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("array_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91131, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91133 = (name);
    String_s tmp_91134 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91133, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91134, .info = type_info_table[18]})},
                                               .length = 2})));
    String_s tmp_91136 = (_t);
    String_s tmp_91137 = (name);

    ((addPS4580S4175S4175rN)((&((this)->array_map_declared)), ((Data_s){.ptr = &tmp_91136, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91137, .info = type_info_table[18]})));
}
none generateArrayDefinitionPS9442PS0540PU5175rN(CGen_s *this, String_s *out, Type_u *type) {
    bool succ_11271_ = true;

    Type_u *tmp_18212_ = (type);
    succ_11271_ &= (tmp_18212_->tag == 5);
    Type_u **elem = &tmp_18212_->payload.variant5._0;
    succ_11271_ &= true;
    usize *size = &tmp_18212_->payload.variant5._1;
    succ_11271_ &= true;
    if (!succ_11271_) {
        ((unreachablePcrN)(("generateArrayDefinition")));
    };
    String_s _t = ((toStringPU5175rS0540)((type)));
    String_s tmp_91138 = (_t);

    Data_s _v = ((getPS4580S4175rS4175)((&((this)->array_map_defined)), ((Data_s){.ptr = &tmp_91138, .info = type_info_table[18]})));
    if (((_v).ptr) != (NULL)) {
        ((dropPS0540rN)((&(_t))));
        return;
    }

    usize _size = (*size);
    if ((_size) == ((usize)(0llu)))
        ((_size) = ((usize)(1llu)));
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    usize tmp_91139 = ((getIDPU5175rusz)((type)));

    String_s name = ((format1PcVS4175rS0540)(("array_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91139, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91141 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91141, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91143 = (ind);
    String_s tmp_91144 = ((generateTypeNamePS9442PU5175S7720uszrS0540)((this), (*elem), (((newSubStrOfStrLitPcrS7720)(("arr")))), (_size)));

    ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91143, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91144, .info = type_info_table[18]})},
                                               .length = 2})));
    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    String_s tmp_91147 = (_t);
    String_s tmp_91148 = (name);

    ((addPS4580S4175S4175rN)((&((this)->array_map_defined)), ((Data_s){.ptr = &tmp_91147, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91148, .info = type_info_table[18]})));
}
none forwardDeclareStructPS0540PS5521rN(String_s *out, ParsedStructDecl_s *strukt) {
    if ((strukt)->ignored)
        return;
    String_s name = ((getFullNamePS5521PcrS0540)((strukt), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
    String_s tmp_91149 = (name);
    String_s tmp_91150 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91149, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91150, .info = type_info_table[18]})},
                                               .length = 2})));
}
none generateStructDefinitionPS9442PS0540PS5521rN(CGen_s *this, String_s *out, ParsedStructDecl_s *strukt) {
    if ((strukt)->ignored)
        return;
    if ((((strukt)->context).fieldLength) == ((usize)(0llu)))
        return;
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    String_s name = ((getFullNamePS5521PcrS0540)((strukt), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_s")));
    String_s tmp_91152 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91152, .info = type_info_table[18]})}, .length = 1})));
    for (usize i = ((usize)(0llu)); ((i) < (((strukt)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s nameTkn = ((getFieldNameAtIndexPS7871uszrS6070)((&((strukt)->context)), (i)));
        ParsedTypeNode_s *_field = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((strukt)->context)), (i)));
        Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
        String_s _name = ((toStringPS7720rS0540)((&((nameTkn).content))));
        ((makeNameCCompatiblePS0540rN)((&(_name))));
        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
        String_s tmp_91154 = (ind);
        String_s tmp_91155 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

        ((formatPS0540PcVS4175rN)((out), ("%%;\n"),
                                  ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91154, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91155, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none forwardDeclareUnionPS0540PS0997rN(String_s *out, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return;
    String_s name = ((getFullNamePS0997PcrS0540)((onion), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
    String_s tmp_91158 = (name);
    String_s tmp_91159 = (name);

    ((formatPS0540PcVS4175rN)((out), ("typedef struct % %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91158, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91159, .info = type_info_table[18]})},
                                               .length = 2})));
}
none generateUnionDefinitionPS9442PS0540PS0997rN(CGen_s *this, String_s *out, ParsedUnionDecl_s *onion) {
    if ((onion)->ignored)
        return;
    ((assertBPcrN)(((((onion)->variants).length) < ((usize)(256llu))), ("generateUnionDefinition: Tag needs u16")));
    ((assertBPcrN)(((((onion)->variants).length) != ((usize)(0llu))), ("generateUnionDefinition: Empty Union?")));
    String_s ind = ((generateIndentuszrS0540)((INDENTATION_LEVEL)));
    String_s name = ((getFullNamePS0997PcrS0540)((onion), ("_")));
    ((makeNameCCompatiblePS0540PcrN)((&(name)), ("_u")));
    String_s tmp_91161 = (name);

    ((formatPS0540PcVS4175rN)((out), ("struct % {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91161, .info = type_info_table[18]})}, .length = 1})));
    String_s tmp_91163 = (ind);

    ((formatPS0540PcVS4175rN)((out), ("%u8 tag;\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91163, .info = type_info_table[18]})}, .length = 1})));
    bool has_non_empty = (false);
    for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
        bool succ_11300_ = true;

        {
            ParsedUnionVariantData_u *tmp_18272_ = (&((variant)->data));
            succ_11300_ &= (tmp_18272_->tag == 0);

            if (succ_11300_) {
                continue;
            } else {
                ((has_non_empty) = (true));
                break;
            }
        }
    }

    if (has_non_empty) {
        String_s tmp_91165 = (ind);

        ((formatPS0540PcVS4175rN)((out), ("%union {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91165, .info = type_info_table[18]})}, .length = 1})));
        for (usize i = ((usize)(0llu)); ((i) < (((onion)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
            ParsedUnionVariant_s *variant = (*((atPS0030uszrPPS3506)((&((onion)->variants)), (i))));
            bool succ_11307_ = true;
            bool succ_11305_ = true;

            tuple_1044 tmp_18279_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
            succ_11305_ = tmp_18279_._0 == true;
            succ_11307_ &= succ_11305_;
            ParsedTypeNodeList_s **fields = &tmp_18279_._1;
            succ_11307_ &= true;
            if (!succ_11307_) {
                continue;
            };
            String_s tmp_91167 = (ind);
            String_s tmp_91168 = (ind);

            String_s payload =
                ((format1PcVS4175rS0540)(("%%struct {\n"),
                                         ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91167, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91168, .info = type_info_table[18]})},
                                                          .length = 2})));
            for (usize j = ((usize)(0llu)); ((j) < ((*fields)->length)); ((j) = ((j) + ((usize)(1llu))))) {
                ParsedTypeNode_s *_field = (*((atPS6760uszrPPS1372)((*fields), (j))));
                Type_u *field = ((getTypePU9661rPU5175)((&((_field)->typeState))));
                usize tmp_91170 = (j);

                String_s _name = ((format1PcVS4175rS0540)(("_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91170, .info = type_info_table[8]})}, .length = 1})));
                SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
                String_s tmp_91172 = (ind);
                String_s tmp_91173 = (ind);
                String_s tmp_91174 = (ind);
                String_s tmp_91175 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (field), (name)));

                ((formatPS0540PcVS4175rN)((&(payload)), ("%%%%;\n"),
                                          ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91172, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91173, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91174, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91175, .info = type_info_table[18]})},
                                                           .length = 4})));
                ((dropPS0540rN)((&(_name))));
            }

            String_s tmp_91177 = (ind);
            String_s tmp_91178 = (ind);
            usize tmp_91179 = (i);

            ((formatPS0540PcVS4175rN)((&(payload)), ("%%} variant%;\n"),
                                      ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91177, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91178, .info = type_info_table[18]}),
                                                                          ((Data_s){.ptr = &tmp_91179, .info = type_info_table[8]})},
                                                       .length = 3})));
            ((pushStringPS0540PS0540rN)((out), (&(payload))));
        }

        String_s tmp_91181 = (ind);

        ((formatPS0540PcVS4175rN)((out), ("%} payload;\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91181, .info = type_info_table[18]})}, .length = 1})));
    }

    ((formatPS0540PcVS4175rN)((out), ("};\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none forwardDeclareFunctionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function) {
    if ((function)->ignored)
        return;
    String_s name = ((getMangledNamePS4904rS0540)((function)));
    ((makeNameCCompatiblePS0540rN)((&(name))));
    ((emitFunctionSignaturePS9442PS0540S0540PS4904BrN)((this), (out), (name), (function), (true)));
    ((formatPS0540PcVS4175rN)((out), (";\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
}
none generateFunctionDefinitionPS9442PS0540PS4904rN(CGen_s *this, String_s *out, ParsedFuncDecl_s *function) {
    if ((function)->ignored)
        return;
    if ((isExternPS4904rB)((function)))
        return;
    String_s name = ((getMangledNamePS4904rS0540)((function)));
    ((makeNameCCompatiblePS0540rN)((&(name))));
    ((emitFunctionSignaturePS9442PS0540S0540PS4904rN)((this), (out), (name), (function)));
    CStack_s stack = ((newCStackrS1662)());
    for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
        Token_s name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
        SubStr_s tmp_91185 = ((name).content);
        Var_Context_s tmp_91186 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

        ((addPS4580S4175S4175rN)((&((stack).variables)), ((Data_s){.ptr = &tmp_91185, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91186, .info = type_info_table[213]})));
    }

    CStack_s tmp_91187 = (stack);

    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91187, .info = type_info_table[214]})));
    String_s tmp_91188 = ((generateBlockPS9442PS7247uszrS0540)((this), ((function)->body), (INDENTATION_LEVEL)));

    ((formatPS0540PcVS4175rN)((out), (" %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91188, .info = type_info_table[18]})}, .length = 1})));
    ((popPS3646rN)((&((this)->stack))));
}
none emitFunctionSignaturePS9442PS0540S0540PS4904rN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function) {
    ((emitFunctionSignaturePS9442PS0540S0540PS4904BrN)((this), (out), (name), (function), (false)));
}
none emitFunctionSignaturePS9442PS0540S0540PS4904BrN(CGen_s *this, String_s *out, String_s name, ParsedFuncDecl_s *function, bool generateVariadics) {
    String_s fnSig = ((String_s){0});
    if ((hasAttributePS4904U4360rB)((function), (((ParsedAttribute_u){.tag = 3, .payload = {0}})))) {
        ((formatPS0540PcVS4175rN)((out), ("#if defined(__clang__) || defined(__GNUC__)\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("__attribute__((noreturn))\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#elif defined(_WIN32)\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("__declspec(noreturn)\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#else\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#error \"Can\'t mark function as noreturn on your compiler. PRs welcome.\"\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
        ((formatPS0540PcVS4175rN)((out), ("#endif\n"), ((variadic_4507){.ptr = NULL, .length = 0})));
    }

    String_s tmp_91197 = ((generateTypeNamePS9442PS1372rS0540)((this), ((function)->retType)));
    String_s tmp_91198 = (name);

    ((formatPS0540PcVS4175rN)((&(fnSig)), ("% %("),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91197, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91198, .info = type_info_table[18]})},
                                               .length = 2})));
    if ((((function)->params).paramLength) == ((usize)(0llu))) {
        ((formatPS0540PcVS4175rN)((&(fnSig)), ("none"), ((variadic_4507){.ptr = NULL, .length = 0})));
    }

    else {
        for (usize i = ((usize)(0llu)); ((i) < (((function)->params).paramLength)); ((i) = ((i) + ((usize)(1llu))))) {
            Token_s _name = ((getNameAtIndexPS9803uszrS6070)((&((function)->params)), (i)));
            String_s name = ((toStringPS7720rS0540)((&((_name).content))));
            ((makeNameCCompatiblePS0540rN)((&(name))));
            ParsedTypeNode_s *typDecl = ((getTypeAtIndexPS9803uszrPS1372)((&((function)->params)), (i)));
            Type_u *pType = ((getTypePU9661rPU5175)((&((typDecl)->typeState))));
            bool succ_11333_ = true;

            {
                Type_u *tmp_18343_ = (pType);
                succ_11333_ &= (tmp_18343_->tag == 2);
                Type_u **under = &tmp_18343_->payload.variant2._0;
                succ_11333_ &= true;

                if (succ_11333_) {
                    if (generateVariadics) {
                        ((emitVariadicTypePS9442PS0540PU5175rN)((this), (out), (pType)));
                    }
                }
            }

            String_s tmp_91201 = ((generateTypeNamePS9442PU5175S7720rS0540)((this), (pType), ((asSubStrPS0540rS7720)((&(name))))));

            ((formatPS0540PcVS4175rN)((&(fnSig)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91201, .info = type_info_table[18]})}, .length = 1})));
            if ((i) != ((((function)->params).paramLength) - ((usize)(1llu)))) {
                ((formatPS0540PcVS4175rN)((&(fnSig)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
        }
    }

    if (((isExternPS4904rB)((function))) && (((function)->params).isVarArg)) {
        ((formatPS0540PcVS4175rN)((&(fnSig)), (", ..."), ((variadic_4507){.ptr = NULL, .length = 0})));
    }

    ((formatPS0540PcVS4175rN)((&(fnSig)), (")"), ((variadic_4507){.ptr = NULL, .length = 0})));
    ((pushStringPS0540PS0540rN)((out), (&(fnSig))));
}
String_s generateBlockPS9442PS7247uszrS0540(CGen_s *this, ParsedBlock_s *block, usize indent) {
    ((assertBPcrN)(((indent) != ((usize)(0llu))), ("generateBlock without indent")));
    String_s out = ((String_s){0});
    String_s tmp_91206 = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));

    ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91206, .info = type_info_table[18]})}, .length = 1})));
    {
        CStack_s tmp_91208 = ((newCStackrS1662)());

        ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91208, .info = type_info_table[214]})));
        for (usize i = ((usize)(0llu)); ((i) < ((block)->stmtLength)); ((i) = ((i) + ((usize)(1llu))))) {
            String_s entry = ((String_s){0});
            String_s stmt = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (&(entry)), ((((block)->stmtList))[(i)]), (indent)));
            if (((entry).length) != ((usize)(0llu))) {
                String_s tmp_91209 = (entry);

                ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91209, .info = type_info_table[18]})}, .length = 1})));
                ((dropPS0540rN)((&(entry))));
            }

            String_s tmp_91211 = (stmt);

            ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91211, .info = type_info_table[18]})}, .length = 1})));
        }

        ((popPS3646rN)((&((this)->stack))));
    }

    String_s tmp_91213 = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));

    ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91213, .info = type_info_table[18]})}, .length = 1})));
    return (out);
}
String_s generateIndentuszrS0540(usize indent) {
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < (indent)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushCharPS0540crN)((&(out)), (' ')));
    }

    return (out);
}
String_s generateStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent) {
    String_s out = ((String_s){0});
    bool succ_11350_ = true;

    {
        StmtData_u *tmp_18383_ = (&((stmt)->data));
        succ_11350_ &= (tmp_18383_->tag == 4);
        succ_11350_ &= true;

        if (succ_11350_) {
        } else {
            ((out) = ((generateIndentuszrS0540)((indent))));
        }
    }

    bool succ_11354_ = true;
    bool succ_11357_ = true;
    bool succ_11361_ = true;
    bool succ_11365_ = true;
    bool succ_11369_ = true;
    bool succ_11374_ = true;
    bool succ_11380_ = true;
    bool succ_11385_ = true;
    bool succ_11392_ = true;
    bool succ_11395_ = true;
    bool succ_11398_ = true;
    bool succ_11402_ = true;
    bool succ_11407_ = true;
    bool succ_11414_ = true;
    bool succ_11430_ = true;
    bool succ_11446_ = true;

    StmtData_u *tmp_18469_ = (&((stmt)->data));
    {
        succ_11354_ &= (tmp_18469_->tag == 0);
        VarDecl_s *decl = &tmp_18469_->payload.variant0._0;
        succ_11354_ &= true;
        if (succ_11354_) {
            {
                String_s tmp_91215 = ((generateVarDeclPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (stmt), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%;"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91215, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11357_ &= (tmp_18469_->tag == 1);
        if (succ_11357_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("return;"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18469;
        }
    }
    {
        succ_11361_ &= (tmp_18469_->tag == 2);
        ParsedExpr_s **expr = &tmp_18469_->payload.variant2._0;
        succ_11361_ &= true;
        if (succ_11361_) {
            {
                String_s tmp_91218 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("return %;"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91218, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11365_ &= (tmp_18469_->tag == 3);
        ParsedExpr_s **expr = &tmp_18469_->payload.variant3._0;
        succ_11365_ &= true;
        if (succ_11365_) {
            {
                String_s tmp_91220 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%;"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91220, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11369_ &= (tmp_18469_->tag == 4);
        ParsedBlock_s **block = &tmp_18469_->payload.variant4._0;
        succ_11369_ &= true;
        if (succ_11369_) {
            {
                String_s tmp_91222 = ((generateBlockPS9442PS7247uszrS0540)((this), (*block), ((indent) + (INDENTATION_LEVEL))));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91222, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11374_ &= (tmp_18469_->tag == 5);
        ParsedExpr_s **cond = &tmp_18469_->payload.variant5._0;
        succ_11374_ &= true;
        ParsedStmt_s **body = &tmp_18469_->payload.variant5._1;
        succ_11374_ &= true;
        if (succ_11374_) {
            {
                String_s tmp_91224 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91225 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("if %\n%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91224, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91225, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18469;
        }
    }
    {
        succ_11380_ &= (tmp_18469_->tag == 6);
        ParsedExpr_s **cond = &tmp_18469_->payload.variant6._0;
        succ_11380_ &= true;
        ParsedStmt_s **body = &tmp_18469_->payload.variant6._1;
        succ_11380_ &= true;
        ParsedStmt_s **elze = &tmp_18469_->payload.variant6._2;
        succ_11380_ &= true;
        if (succ_11380_) {
            {
                String_s tmp_91227 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91228 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));
                String_s tmp_91229 = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91230 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*elze), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("if %\n%\n%else\n%"),
                                          ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91227, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91228, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91229, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91230, .info = type_info_table[18]})},
                                                           .length = 4})));
            }
            goto after_18469;
        }
    }
    {
        succ_11385_ &= (tmp_18469_->tag == 7);
        ParsedExpr_s **cond = &tmp_18469_->payload.variant7._0;
        succ_11385_ &= true;
        ParsedStmt_s **body = &tmp_18469_->payload.variant7._1;
        succ_11385_ &= true;
        if (succ_11385_) {
            {
                String_s tmp_91232 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91233 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("while %\n%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91232, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91233, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18469;
        }
    }
    {
        succ_11392_ &= (tmp_18469_->tag == 8);
        ParsedStmt_s **init = &tmp_18469_->payload.variant8._0;
        succ_11392_ &= true;
        ParsedExpr_s **cond = &tmp_18469_->payload.variant8._1;
        succ_11392_ &= true;
        ParsedExpr_s **step = &tmp_18469_->payload.variant8._2;
        succ_11392_ &= true;
        ParsedStmt_s **body = &tmp_18469_->payload.variant8._3;
        succ_11392_ &= true;
        if (succ_11392_) {
            {
                String_s tmp_91235 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*init), ((usize)(0llu))));
                String_s tmp_91236 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*cond)));
                String_s tmp_91237 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*step)));
                String_s tmp_91238 = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (*body), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("for (% %; %)\n%"),
                                          ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91235, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91236, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91237, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91238, .info = type_info_table[18]})},
                                                           .length = 4})));
            }
            goto after_18469;
        }
    }
    {
        succ_11395_ &= (tmp_18469_->tag == 9);
        if (succ_11395_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("break;"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18469;
        }
    }
    {
        succ_11398_ &= (tmp_18469_->tag == 10);
        if (succ_11398_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("continue;"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18469;
        }
    }
    {
        succ_11402_ &= (tmp_18469_->tag == 11);
        succ_11402_ &= true;
        if (succ_11402_) {
            {
                String_s tmp_91242 = ((generateMatchStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (stmt), (indent)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91242, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11407_ &= (tmp_18469_->tag == 12);
        ParsedExpr_s **expr = &tmp_18469_->payload.variant12._0;
        succ_11407_ &= true;
        ParsedExprList_s *args = &tmp_18469_->payload.variant12._1;
        succ_11407_ &= true;
        if (succ_11407_) {
            {
                String_s s = ((toStringPS8951rS0540)((&((stmt)->span))));
                (((fprintf))((stderr_), ("%s %.*s: Cannot transpile Inline Assembly to C yet.\n"), (ERR_STR), ((s).length), ((s).buffer)));
                (((C_exiti32rN))(((i32)(1))));
            }
            goto after_18469;
        }
    }
    {
        succ_11414_ &= (tmp_18469_->tag == 13);
        ParsedPattern_s **_pat = &tmp_18469_->payload.variant13._0;
        succ_11414_ &= true;
        ParsedExpr_s **_expr = &tmp_18469_->payload.variant13._1;
        succ_11414_ &= true;
        ParsedBlock_s **_block = &tmp_18469_->payload.variant13._2;
        succ_11414_ &= true;
        if (succ_11414_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91244 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91244, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91246 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91246, .info = type_info_table[214]})));
                    usize tmp_91247 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91247, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91249 = (tmp_type);
                    String_s tmp_91250 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91249, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91250, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11423_ = true;

                    tuple_4458 tmp_18420_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18420_._0;
                    succ_11423_ &= true;
                    String_s *success = &tmp_18420_._1;
                    succ_11423_ &= true;
                    (void)succ_11423_;
                    String_s tmp_91252 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91252, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91254 = (ind);
                    String_s tmp_91255 = (*success);
                    String_s tmp_91256 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) %"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91254, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91255, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91256, .info = type_info_table[18]})},
                                                               .length = 3})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91258 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91258, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11430_ &= (tmp_18469_->tag == 14);
        ParsedPattern_s **_pat = &tmp_18469_->payload.variant14._0;
        succ_11430_ &= true;
        ParsedExpr_s **_expr = &tmp_18469_->payload.variant14._1;
        succ_11430_ &= true;
        ParsedBlock_s **_block = &tmp_18469_->payload.variant14._2;
        succ_11430_ &= true;
        ParsedBlock_s **_elze = &tmp_18469_->payload.variant14._3;
        succ_11430_ &= true;
        if (succ_11430_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91260 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91260, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91262 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91262, .info = type_info_table[214]})));
                    usize tmp_91263 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91263, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91265 = (tmp_type);
                    String_s tmp_91266 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91265, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91266, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11439_ = true;

                    tuple_4458 tmp_18436_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18436_._0;
                    succ_11439_ &= true;
                    String_s *success = &tmp_18436_._1;
                    succ_11439_ &= true;
                    (void)succ_11439_;
                    String_s tmp_91268 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91268, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91270 = (ind);
                    String_s tmp_91271 = (*success);
                    String_s tmp_91272 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) % else"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91270, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91271, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91272, .info = type_info_table[18]})},
                                                               .length = 3})));
                    ((popPS3646rN)((&((this)->stack))));
                    CStack_s tmp_91274 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91274, .info = type_info_table[214]})));
                    String_s elze = ((generateBlockPS9442PS7247uszrS0540)((this), (*_elze), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91275 = (ind);
                    String_s tmp_91276 = (elze);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%%"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91275, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91276, .info = type_info_table[18]})},
                                                               .length = 2})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91278 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91278, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        succ_11446_ &= (tmp_18469_->tag == 15);
        ParsedPattern_s **_pat = &tmp_18469_->payload.variant15._0;
        succ_11446_ &= true;
        ParsedExpr_s **_expr = &tmp_18469_->payload.variant15._1;
        succ_11446_ &= true;
        ParsedBlock_s **_block = &tmp_18469_->payload.variant15._2;
        succ_11446_ &= true;
        if (succ_11446_) {
            {
                String_s expr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));
                Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
                String_s ind = ((generateIndentuszrS0540)((indent)));
                String_s tmp_91280 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%while (true) {\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91280, .info = type_info_table[18]})}, .length = 1})));
                {
                    CStack_s tmp_91282 = ((newCStackrS1662)());

                    ((pushPS3646S4175rN)((&((this)->stack)), ((Data_s){.ptr = &tmp_91282, .info = type_info_table[214]})));
                    usize tmp_91283 = ((getIDPS1100rusz)((stmt)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91283, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
                    String_s tmp_91285 = (tmp_type);
                    String_s tmp_91286 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91285, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91286, .info = type_info_table[18]})},
                                                               .length = 2})));
                    bool succ_11455_ = true;

                    tuple_4458 tmp_18456_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*_pat), (tmp_name), (typ), (indent)));
                    String_s *pat = &tmp_18456_._0;
                    succ_11455_ &= true;
                    String_s *success = &tmp_18456_._1;
                    succ_11455_ &= true;
                    (void)succ_11455_;
                    String_s tmp_91288 = (*pat);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91288, .info = type_info_table[18]})}, .length = 1})));
                    String_s block = ((generateBlockPS9442PS7247uszrS0540)((this), (*_block), ((indent) + (INDENTATION_LEVEL))));
                    String_s tmp_91290 = (ind);
                    String_s tmp_91291 = (*success);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%if (!%) break;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91290, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91291, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91293 = (ind);
                    String_s tmp_91294 = (block);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%%\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91293, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91294, .info = type_info_table[18]})},
                                                               .length = 2})));
                    ((popPS3646rN)((&((this)->stack))));
                }

                String_s tmp_91296 = (ind);

                ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91296, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    {
        StmtData_u **t = &tmp_18469_;
        if (true) {
            {
                String_s s = ((toStringPS8951rS0540)((&((stmt)->span))));
                (((fprintf))((stderr_), ("%s %.*s: stmt %hhu\n"), (FATAL_STR), ((s).length), ((s).buffer), ((tagAnyru8)((*t)))));
                u8 tmp_91298 = ((tagAnyru8)((*t)));

                return ((format1PcVS4175rS0540)(("\n#error TODO: generateStmt %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91298, .info = type_info_table[0]})}, .length = 1})));
            }
            goto after_18469;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18469:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s _anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540(CGen_s *this, String_s *tmpAlloc, Token_s tkn, Type_u *type, ParsedExpr_s *expr, usize indent) {
    String_s out = ((String_s){0});
    String_s _name = ((toStringPS7720rS0540)((&((tkn).content))));
    ((makeNameCCompatiblePS0540rN)((&(_name))));
    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr)));
    String_s tmp_91300 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (_name)));
    String_s tmp_91301 = (e);

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91300, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91301, .info = type_info_table[18]})},
                                               .length = 2})));
    CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
    SubStr_s tmp_91303 = ((tkn).content);
    Var_Context_s tmp_91304 = ((Var_Context_s){.bound_in_reference_pattern = (false)});

    ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91303, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91304, .info = type_info_table[213]})));
    return (out);
}
String_s generateVarDeclPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *_decl, usize indent) {
    bool succ_11461_ = true;

    StmtData_u *tmp_18472_ = (&((_decl)->data));
    succ_11461_ &= (tmp_18472_->tag == 0);
    VarDecl_s *decl = &tmp_18472_->payload.variant0._0;
    succ_11461_ &= true;
    if (!succ_11461_) {
        ((unreachablePcrN)(("generateVarDecl")));
    };
    if (((*decl).isComptime) && (*((flags).warnSimple))) {
        String_s loc = ((toStringPS8951rS0540)((&((_decl)->span))));
        (((fprintf))((stderr_), ("%s: %.*s: Comptime has no effect when transpiling to C.\n"), (WARN_STR), ((loc).length), ((loc).buffer)));
    }

    String_s (*fast_path)(CGen_s *, String_s *, Token_s, Type_u *, ParsedExpr_s *, usize) = (_anon_44_2PS9442PS0540S6070PU5175PS2435uszrS0540);
    bool succ_11473_ = true;

    {
        Pattern_u *tmp_18488_ = (&(((*decl).pat)->data));
        succ_11473_ &= (tmp_18488_->tag == 3);
        ParsedPattern_s **subpat = &tmp_18488_->payload.variant3._0;
        succ_11473_ &= true;
        ParsedTypeNode_s **typ = &tmp_18488_->payload.variant3._1;
        succ_11473_ &= true;

        if (succ_11473_) {
            bool succ_11477_ = true;

            {
                Pattern_u *tmp_18487_ = (&((*subpat)->data));
                succ_11477_ &= (tmp_18487_->tag == 2);
                Token_s *tkn = &tmp_18487_->payload.variant2._0;
                succ_11477_ &= true;

                if (succ_11477_) {
                    return ((fast_path)((this), (tmpAlloc), (*tkn), ((getTypePU9661rPU5175)((&((*typ)->typeState)))), ((*decl).expr), (indent)));
                }
            }
        }
    }

    bool succ_11481_ = true;

    {
        Pattern_u *tmp_18490_ = (&(((*decl).pat)->data));
        succ_11481_ &= (tmp_18490_->tag == 2);
        Token_s *tkn = &tmp_18490_->payload.variant2._0;
        succ_11481_ &= true;

        if (succ_11481_) {
            return ((fast_path)((this), (tmpAlloc), (*tkn), ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState)))), ((*decl).expr), (indent)));
        }
    }

    String_s out = ((String_s){0});
    String_s ind = ((generateIndentuszrS0540)((indent)));
    usize id = ((getIDPS1100rusz)((_decl)));
    Type_u *typ = ((getTypePU9661rPU5175)((&(((*decl).expr)->typeState))));
    usize tmp_91305 = (id);

    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91305, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
    String_s tmp_91307 = (tmp_type);
    String_s tmp_91308 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((*decl).expr)));

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91307, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91308, .info = type_info_table[18]})},
                                               .length = 2})));
    bool succ_11492_ = true;

    tuple_4458 tmp_18498_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), ((*decl).pat), (tmp_name), (typ), (indent)));
    String_s *pat = &tmp_18498_._0;
    succ_11492_ &= true;
    String_s *success = &tmp_18498_._1;
    succ_11492_ &= true;
    (void)succ_11492_;
    String_s tmp_91310 = (ind);
    String_s tmp_91311 = (*pat);

    ((formatPS0540PcVS4175rN)((&(out)), ("%%"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91310, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91311, .info = type_info_table[18]})},
                                               .length = 2})));
    if (((*decl).trampoline) != (NULL)) {
        String_s tmp_91313 = (*success);
        String_s tmp_91314 = ((generateBlockPS9442PS7247uszrS0540)((this), ((*decl).trampoline), ((indent) + (INDENTATION_LEVEL))));

        ((formatPS0540PcVS4175rN)((&(out)), ("if (!%) %"),
                                  ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91313, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91314, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    else if (*((flags).debug)) {
        String_s tmp_91316 = (ind);
        String_s tmp_91317 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%if (!%) unreachablePcrN(\"RUNTIME ERROR: pattern of let statement is not exhaustive. this is a bug!\");\n"),
                                  ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91316, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91317, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    else {
        String_s tmp_91319 = (ind);
        String_s tmp_91320 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%(void)%"),
                                  ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91319, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91320, .info = type_info_table[18]})},
                                                   .length = 2})));
    }

    return (out);
}
String_s generateMatchStmtPS9442PS0540PS1100uszrS0540(CGen_s *this, String_s *tmpAlloc, ParsedStmt_s *stmt, usize indent) {
    bool succ_11497_ = true;

    StmtData_u *tmp_18510_ = (&((stmt)->data));
    succ_11497_ &= (tmp_18510_->tag == 11);
    ParsedExpr_s **_expr = &tmp_18510_->payload.variant11._0;
    succ_11497_ &= true;
    ParsedPatternList_s *_pats = &tmp_18510_->payload.variant11._1;
    succ_11497_ &= true;
    ParsedStmtList_s *_arms = &tmp_18510_->payload.variant11._2;
    succ_11497_ &= true;
    if (!succ_11497_) {
        ((unreachablePcrN)(("generateMatchStmt")));
    };
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s armInd = ((generateIndentuszrS0540)(((indent) + (INDENTATION_LEVEL))));
    String_s out = ((String_s){0});
    Type_u *typ = ((getTypePU9661rPU5175)((&((*_expr)->typeState))));
    usize id = ((getIDPS1100rusz)((stmt)));
    usize tmp_91322 = (id);

    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91322, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_type = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (typ), (tmp_name)));
    String_s tmp_91324 = (tmp_type);
    String_s tmp_91325 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*_expr)));

    ((formatPS0540PcVS4175rN)((&(out)), ("% = %;\n"),
                              ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91324, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91325, .info = type_info_table[18]})},
                                               .length = 2})));
    for (usize i = ((usize)(0llu)); ((i) < ((*_pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *_pat = ((((*_pats).elements))[(i)]);
        ParsedStmt_s *_arm = ((((*_arms).elements))[(i)]);
        bool succ_11513_ = true;

        tuple_4458 tmp_18522_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (_pat), (tmp_name), (typ), ((indent) + (INDENTATION_LEVEL))));
        String_s *pat = &tmp_18522_._0;
        succ_11513_ &= true;
        String_s *succ = &tmp_18522_._1;
        succ_11513_ &= true;
        (void)succ_11513_;
        String_s arm = ((generateStmtPS9442PS0540PS1100uszrS0540)((this), (tmpAlloc), (_arm), ((indent) + (INDENTATION_LEVEL))));
        String_s tmp_91327 = (ind);

        ((formatPS0540PcVS4175rN)((&(out)), ("%{\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91327, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91329 = (*pat);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91329, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91331 = (armInd);
        String_s tmp_91332 = (*succ);
        String_s tmp_91333 = (arm);
        String_s tmp_91334 = (armInd);
        usize tmp_91335 = (id);

        ((formatPS0540PcVS4175rN)((&(out)), ("%if (%) {%%goto after_%;\n}\n"),
                                  ((variadic_4507){.ptr = (Data_s[5]){((Data_s){.ptr = &tmp_91331, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91332, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91333, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91334, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91335, .info = type_info_table[8]})},
                                                   .length = 5})));
        String_s tmp_91337 = (ind);

        ((formatPS0540PcVS4175rN)((&(out)), ("%}\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91337, .info = type_info_table[18]})}, .length = 1})));
    }

    String_s tmp_91339 = (ind);

    ((formatPS0540PcVS4175rN)((&(out)), ("%unreachablePcrN(\"RUNTIME ERROR: match statement is not exhaustive. this is a bug!\");\n"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91339, .info = type_info_table[18]})}, .length = 1})));
    usize tmp_91341 = (id);

    ((formatPS0540PcVS4175rN)((&(out)), ("after_%:\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91341, .info = type_info_table[8]})}, .length = 1})));
    String_s tmp_91343 = (ind);

    ((formatPS0540PcVS4175rN)((&(out)), ("%(void)0; // error: label at end of compound statement is a C23 extension"),
                              ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91343, .info = type_info_table[18]})}, .length = 1})));
    return (out);
}
tuple_4458 generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s expr, Type_u *type, usize indent) {
    ((assertBPcrN)(((indent) != ((usize)(0llu))), ("generatePattern: wrong indentation")));
    String_s initInd = ((generateIndentuszrS0540)(((indent) - (INDENTATION_LEVEL))));
    String_s ind = ((generateIndentuszrS0540)((indent)));
    bool succ_11518_ = true;
    bool succ_11522_ = true;
    bool succ_11531_ = true;
    bool succ_11535_ = true;
    bool succ_11541_ = true;
    bool succ_11547_ = true;
    bool succ_11554_ = true;
    bool succ_11558_ = true;
    bool succ_11562_ = true;

    Pattern_u *tmp_18592_ = (&((pat)->data));
    {
        succ_11518_ &= (tmp_18592_->tag == 0);
        if (succ_11518_) {
            {
                return ((tuple_4458){((String_s){0}), ((format1PcVS4175rS0540)(("true"), ((variadic_4507){.ptr = NULL, .length = 0})))});
            }
            goto after_18592;
        }
    }
    {
        succ_11522_ &= (tmp_18592_->tag == 2);
        Token_s *tkn = &tmp_18592_->payload.variant2._0;
        succ_11522_ &= true;
        if (succ_11522_) {
            {
                String_s name = ((toStringPS7720rS0540)((&((*tkn).content))));
                ((makeNameCCompatiblePS0540rN)((&(name))));
                CStack_s *stack = ((CStack_s *)(((get_ref_rawPS3646uszrAny)((&((this)->stack)), ((((this)->stack).length) - ((usize)(1llu)))))));
                SubStr_s tmp_91346 = ((*tkn).content);
                Var_Context_s tmp_91347 = ((Var_Context_s){.bound_in_reference_pattern = (true)});

                ((addPS4580S4175S4175rN)((&((stack)->variables)), ((Data_s){.ptr = &tmp_91346, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91347, .info = type_info_table[213]})));
                String_s out = ((String_s){0});
                if (true) {
                    ((type) = ((intoPointerPU5175rPU5175)((type))));
                    String_s tmp_91348 = (ind);
                    String_s tmp_91349 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (name)));
                    String_s tmp_91350 = (expr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%% = &%;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91348, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91349, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91350, .info = type_info_table[18]})},
                                                               .length = 3})));
                }

                else {
                    String_s tmp_91352 = (ind);
                    String_s tmp_91353 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (type), (name)));
                    String_s tmp_91354 = (expr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[3]){((Data_s){.ptr = &tmp_91352, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91353, .info = type_info_table[18]}),
                                                                               ((Data_s){.ptr = &tmp_91354, .info = type_info_table[18]})},
                                                               .length = 3})));
                }

                return ((tuple_4458){(out), ((format1PcVS4175rS0540)(("true"), ((variadic_4507){.ptr = NULL, .length = 0})))});
            }
            goto after_18592;
        }
    }
    {
        succ_11531_ &= (tmp_18592_->tag == 3);
        ParsedPattern_s **sub = &tmp_18592_->payload.variant3._0;
        succ_11531_ &= true;
        ParsedTypeNode_s **ty = &tmp_18592_->payload.variant3._1;
        succ_11531_ &= true;
        if (succ_11531_) {
            {
                return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (expr), (type), (indent)));
            }
            goto after_18592;
        }
    }
    {
        succ_11535_ &= (tmp_18592_->tag == 4);
        ParsedPattern_s **sub = &tmp_18592_->payload.variant4._0;
        succ_11535_ &= true;
        if (succ_11535_) {
            {
                Type_u *under = ((getUnderlyingTypePU5175BrPU5175)((type), (false)));
                if ((isPointerPU5175rB)((under))) {
                    String_s tmp_91357 = (expr);

                    return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub),
                                                                                           ((format1PcVS4175rS0540)(("*%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){
                                                                                                                                                 .ptr = &tmp_91357, .info = type_info_table[18]})},
                                                                                                                                             .length = 1}))),
                                                                                           (under), (indent)));
                }

                else {
                    return ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (expr), (type), (indent)));
                }
            }
            goto after_18592;
        }
    }
    {
        succ_11541_ &= (tmp_18592_->tag == 5);
        Token_s *tkn = &tmp_18592_->payload.variant5._0;
        succ_11541_ &= true;
        ParsedPatternList_s *sub = &tmp_18592_->payload.variant5._1;
        succ_11541_ &= true;
        if (succ_11541_) {
            {
                usize tmp_91359 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91359, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91361 = (initInd);
                String_s tmp_91362 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91361, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91362, .info = type_info_table[18]})},
                                                           .length = 2})));
                return ((generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (pat), (success), (expr), (type), (indent)));
            }
            goto after_18592;
        }
    }
    {
        succ_11547_ &= (tmp_18592_->tag == 6);
        succ_11547_ &= true;
        ParsedPattern_s **sub = &tmp_18592_->payload.variant6._1;
        succ_11547_ &= true;
        if (succ_11547_) {
            {
                usize tmp_91364 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91364, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91366 = (initInd);
                String_s tmp_91367 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91366, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91367, .info = type_info_table[18]})},
                                                           .length = 2})));
                bool ptr = ((isPointerPU5175rB)((type)));
                Type_u *under = (type);
                if (ptr)
                    ((under) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
                if ((isUnionPU5175rB)((under))) {
                    return ((generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (success), (expr), (type), (indent)));
                }

                else if ((isStructPU5175rB)((under))) {
                    return ((generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (*sub), (success), (expr), (under), (indent)));
                }

                else {
                    ((unreachablePcrN)(("generatePattern")));
                }
            }
            goto after_18592;
        }
    }
    {
        succ_11554_ &= (tmp_18592_->tag == 7);
        ParsedPatternList_s *pats = &tmp_18592_->payload.variant7._0;
        succ_11554_ &= true;
        if (succ_11554_) {
            {
                usize tmp_91369 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91369, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91371 = (initInd);
                String_s tmp_91372 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91371, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91372, .info = type_info_table[18]})},
                                                           .length = 2})));
                return ((generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (pat), (success), (expr), (type), (indent)));
            }
            goto after_18592;
        }
    }
    {
        succ_11558_ &= (tmp_18592_->tag == 8);
        if (succ_11558_) {
            {
                return ((tuple_4458){((String_s){0}), ((format1PcVS4175rS0540)(("true"), ((variadic_4507){.ptr = NULL, .length = 0})))});
            }
            goto after_18592;
        }
    }
    {
        succ_11562_ &= (tmp_18592_->tag == 9);
        bool *b = &tmp_18592_->payload.variant9._0;
        succ_11562_ &= true;
        if (succ_11562_) {
            {
                usize tmp_91375 = ((getIDPS1826rusz)((pat)));

                String_s success = ((format1PcVS4175rS0540)(("succ_%_"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91375, .info = type_info_table[8]})}, .length = 1})));
                String_s tmp_91377 = (initInd);
                String_s tmp_91378 = (success);

                ((formatPS0540PcVS4175rN)((tmpAlloc), ("%bool % = true;\n"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91377, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91378, .info = type_info_table[18]})},
                                                           .length = 2})));
                String_s tmp_91380 = (ind);
                String_s tmp_91381 = (success);
                String_s tmp_91382 = (expr);
                bool tmp_91383 = (*b);

                return ((tuple_4458){((format1PcVS4175rS0540)(("%% = % == %;\n"), ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91380, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91381, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91382, .info = type_info_table[18]}),
                                                                                                                      ((Data_s){.ptr = &tmp_91383, .info = type_info_table[10]})},
                                                                                                   .length = 4}))),
                                     (success)});
            }
            goto after_18592;
        }
    }
    {
        Pattern_u **p = &tmp_18592_;
        if (true) {
            {
                u8 tmp_91385 = ((tagAnyru8)((*p)));

                return ((tuple_4458){
                    ((format1PcVS4175rS0540)(("\n#error generatePattern %\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91385, .info = type_info_table[0]})}, .length = 1}))),
                    ((format1PcVS4175rS0540)(("false"), ((variadic_4507){.ptr = NULL, .length = 0})))});
            }
            goto after_18592;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18592:
    (void)0; // error: label at end of compound statement is a C23 extension
    ((unreachablePcrN)(("generatePattern")));
}
tuple_4458 generatePatternTuplePS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent) {
    bool succ_11568_ = true;

    Pattern_u *tmp_18595_ = (&((pat)->data));
    succ_11568_ &= (tmp_18595_->tag == 7);
    ParsedPatternList_s *pats = &tmp_18595_->payload.variant7._0;
    succ_11568_ &= true;
    if (!succ_11568_) {
        ((unreachablePcrN)(("generatePatternTuple")));
    };
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11573_ = true;

    Type_u *tmp_18601_ = (type);
    succ_11573_ &= (tmp_18601_->tag == 10);
    TypeList_s *types = &tmp_18601_->payload.variant10._0;
    succ_11573_ &= true;
    if (!succ_11573_) {
        String_s tmp_91388 = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s tmp_91389 = ((toStringPU5175rS0540)((type)));

        ((fprintPcVS4175rN)(("%: Nope, it\'s actually a %\n"),
                            ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91388, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91389, .info = type_info_table[18]})},
                                             .length = 2})));
        ((unreachablePcrN)(("generatePattern: Tuple")));
    };
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s out = ((String_s){0});
    for (usize i = ((usize)(0llu)); ((i) < ((*pats).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *subPat = ((((*pats).elements))[(i)]);
        Type_u *fieldType = ((((*types).elements))[(i)]);
        String_s subExpr = ((String_s){0});
        if (ptr) {
            String_s tmp_91391 = (expr);
            usize tmp_91392 = (i);

            ((subExpr) =
                 ((format1PcVS4175rS0540)(("%->_%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91391, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91392, .info = type_info_table[8]})},
                                                           .length = 2}))));
        }

        else {
            String_s tmp_91394 = (expr);
            usize tmp_91395 = (i);

            ((subExpr) =
                 ((format1PcVS4175rS0540)(("%._%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91394, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91395, .info = type_info_table[8]})},
                                                           .length = 2}))));
        }

        bool succ_11586_ = true;

        tuple_4458 tmp_18613_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (subExpr), (fieldType), (indent)));
        String_s *_sub = &tmp_18613_._0;
        succ_11586_ &= true;
        String_s *_succ = &tmp_18613_._1;
        succ_11586_ &= true;
        (void)succ_11586_;
        String_s tmp_91397 = (*_sub);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91397, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91399 = (ind);
        String_s tmp_91400 = (successVariable);
        String_s tmp_91401 = (*_succ);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                  ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91399, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91400, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91401, .info = type_info_table[18]})},
                                                   .length = 3})));
        Pattern_u tmp_87778 = (((Pattern_u){.tag = 8, .payload = {0}}));

        if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_87778)))))
            break;
    }

    return ((tuple_4458){(out), (successVariable)});
}
tuple_4458 generatePatternUnionPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                  usize indent) {
    Token_s *name = (NULL);
    ParsedPatternList_s subPatterns = ((ParsedPatternList_s){0});
    bool succ_11593_ = true;
    bool succ_11598_ = true;

    Pattern_u *tmp_18630_ = (&((pat)->data));
    {
        succ_11593_ &= (tmp_18630_->tag == 2);
        Token_s *ident = &tmp_18630_->payload.variant2._0;
        succ_11593_ &= true;
        if (succ_11593_) {
            {
                ((name) = (&(*ident)));
            }
            goto after_18630;
        }
    }
    {
        succ_11598_ &= (tmp_18630_->tag == 5);
        Token_s *ident = &tmp_18630_->payload.variant5._0;
        succ_11598_ &= true;
        ParsedPatternList_s *pats = &tmp_18630_->payload.variant5._1;
        succ_11598_ &= true;
        if (succ_11598_) {
            {
                ((name) = (&(*ident)));
                ((subPatterns) = (*pats));
            }
            goto after_18630;
        }
    }
    {
        if (true) {
            {
                ((unreachablerN)());
            }
            goto after_18630;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18630:
    (void)0; // error: label at end of compound statement is a C23 extension
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11605_ = true;

    Type_u *tmp_18635_ = (type);
    succ_11605_ &= (tmp_18635_->tag == 8);
    ParsedUnionDecl_s **decl = &tmp_18635_->payload.variant8._0;
    succ_11605_ &= true;
    succ_11605_ &= true;
    if (!succ_11605_) {
        ((unreachablePcrN)(("generatePatternUnion")));
    };
    ParsedUnionVariant_s *variant = (NULL);
    bool found = ((resolveVariantByNamePS0997PS6070PPS3506rB)((*decl), (name), (&(variant))));
    ((assertBrN)((found)));
    usize variantTag = ((getVariantTagPS0997PS3506rusz)((*decl), (variant)));
    String_s ind = ((generateIndentuszrS0540)((indent)));
    String_s out = ((String_s){0});
    if (ptr) {
        String_s tmp_91403 = (ind);
        String_s tmp_91404 = (successVariable);
        String_s tmp_91405 = (expr);
        usize tmp_91406 = (variantTag);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= (%->tag == %);\n"),
                                  ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91403, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91404, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91405, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91406, .info = type_info_table[8]})},
                                                   .length = 4})));
    }

    else {
        String_s tmp_91408 = (ind);
        String_s tmp_91409 = (successVariable);
        String_s tmp_91410 = (expr);
        usize tmp_91411 = (variantTag);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= (%.tag == %);\n"),
                                  ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91408, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91409, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91410, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91411, .info = type_info_table[8]})},
                                                   .length = 4})));
    }

    bool succ_11616_ = true;
    bool succ_11614_ = true;

    {
        tuple_1044 tmp_18664_ = ((get_fieldsPS3506rT_BPS6760)((variant)));
        succ_11614_ = tmp_18664_._0 == true;
        succ_11616_ &= succ_11614_;
        ParsedTypeNodeList_s **fields = &tmp_18664_._1;
        succ_11616_ &= true;

        if (succ_11616_) {
            for (usize i = ((usize)(0llu)); ((i) < ((*fields)->length)); ((i) = ((i) + ((usize)(1llu))))) {
                ParsedPattern_s *subPat = ((((subPatterns).elements))[(i)]);
                ParsedTypeNode_s *fieldNode = ((((*fields)->elements))[(i)]);
                Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
                String_s subExpr = ((String_s){0});
                if (ptr) {
                    String_s tmp_91413 = (expr);
                    usize tmp_91414 = (variantTag);
                    usize tmp_91415 = (i);

                    ((subExpr) = ((format1PcVS4175rS0540)(("%->payload.variant%._%"), ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91413, .info = type_info_table[18]}),
                                                                                                                          ((Data_s){.ptr = &tmp_91414, .info = type_info_table[8]}),
                                                                                                                          ((Data_s){.ptr = &tmp_91415, .info = type_info_table[8]})},
                                                                                                       .length = 3}))));
                }

                else {
                    String_s tmp_91417 = (expr);
                    usize tmp_91418 = (variantTag);
                    usize tmp_91419 = (i);

                    ((subExpr) = ((format1PcVS4175rS0540)(("%.payload.variant%._%"), ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91417, .info = type_info_table[18]}),
                                                                                                                         ((Data_s){.ptr = &tmp_91418, .info = type_info_table[8]}),
                                                                                                                         ((Data_s){.ptr = &tmp_91419, .info = type_info_table[8]})},
                                                                                                      .length = 3}))));
                }

                bool succ_11626_ = true;

                tuple_4458 tmp_18657_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (subExpr), (fieldType), (indent)));
                String_s *sub = &tmp_18657_._0;
                succ_11626_ &= true;
                String_s *success = &tmp_18657_._1;
                succ_11626_ &= true;
                (void)succ_11626_;
                String_s tmp_91421 = (*sub);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91421, .info = type_info_table[18]})}, .length = 1})));
                String_s tmp_91423 = (ind);
                String_s tmp_91424 = (successVariable);
                String_s tmp_91425 = (*success);

                ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                          ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91423, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91424, .info = type_info_table[18]}),
                                                                              ((Data_s){.ptr = &tmp_91425, .info = type_info_table[18]})},
                                                           .length = 3})));
                Pattern_u tmp_87935 = (((Pattern_u){.tag = 8, .payload = {0}}));

                if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_87935)))))
                    break;
            }
        }
    }

    return ((tuple_4458){(out), (successVariable)});
}
tuple_4458 generatePatternStructPS9442PS0540PS1826S0540S0540PU5175uszrT_S0540S0540(CGen_s *this, String_s *tmpAlloc, ParsedPattern_s *pat, String_s successVariable, String_s expr, Type_u *type,
                                                                                   usize indent) {
    bool succ_11630_ = true;

    Pattern_u *tmp_18667_ = (&((pat)->data));
    succ_11630_ &= (tmp_18667_->tag == 5);
    succ_11630_ &= true;
    ParsedPatternList_s *patterns = &tmp_18667_->payload.variant5._1;
    succ_11630_ &= true;
    if (!succ_11630_) {
        ((unreachablePcrN)(("generatePatternStruct")));
    };
    bool ptr = ((isPointerPU5175rB)((type)));
    if (ptr)
        ((type) = ((getUnderlyingTypePU5175BrPU5175)((type), (false))));
    bool succ_11635_ = true;

    Type_u *tmp_18673_ = (type);
    succ_11635_ &= (tmp_18673_->tag == 7);
    ParsedStructDecl_s **decl = &tmp_18673_->payload.variant7._0;
    succ_11635_ &= true;
    if (!succ_11635_) {
        String_s tmp_91427 = ((toStringPS8951rS0540)((&((pat)->span))));
        String_s tmp_91428 = ((toStringPU5175rS0540)((type)));

        ((fprintPcVS4175rN)(("%: Nope, it\'s actually a %\n"),
                            ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91427, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91428, .info = type_info_table[18]})},
                                             .length = 2})));
        ((unreachablePcrN)(("generatePatternStruct")));
    };
    String_s out = ((String_s){0});
    String_s ind = ((generateIndentuszrS0540)((indent)));
    for (usize i = ((usize)(0llu)); ((i) < (((*decl)->context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedPattern_s *subPat = (*((atPS1982uszrPPS1826)((&(*patterns)), (i))));
        ParsedTypeNode_s *fieldNode = ((getFieldTypeAtIndexPS7871uszrPS1372)((&((*decl)->context)), (i)));
        Token_s fieldName = ((getFieldNameAtIndexPS7871uszrS6070)((&((*decl)->context)), (i)));
        Type_u *fieldType = ((getTypePU9661rPU5175)((&((fieldNode)->typeState))));
        String_s fieldExpr = ((String_s){0});
        if (ptr) {
            String_s tmp_91430 = (expr);
            SubStr_s tmp_91431 = ((fieldName).content);

            ((fieldExpr) =
                 ((format1PcVS4175rS0540)(("%->%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91430, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91431, .info = type_info_table[16]})},
                                                           .length = 2}))));
        }

        else {
            String_s tmp_91433 = (expr);
            SubStr_s tmp_91434 = ((fieldName).content);

            ((fieldExpr) =
                 ((format1PcVS4175rS0540)(("%.%"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91433, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91434, .info = type_info_table[16]})},
                                                           .length = 2}))));
        }

        bool succ_11650_ = true;

        tuple_4458 tmp_18687_ = ((generatePatternPS9442PS0540PS1826S0540PU5175uszrT_S0540S0540)((this), (tmpAlloc), (subPat), (fieldExpr), (fieldType), (indent)));
        String_s *sub = &tmp_18687_._0;
        succ_11650_ &= true;
        String_s *success = &tmp_18687_._1;
        succ_11650_ &= true;
        (void)succ_11650_;
        String_s tmp_91436 = (*sub);

        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91436, .info = type_info_table[18]})}, .length = 1})));
        String_s tmp_91438 = (ind);
        String_s tmp_91439 = (successVariable);
        String_s tmp_91440 = (*success);

        ((formatPS0540PcVS4175rN)((&(out)), ("%% &= %;\n"),
                                  ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91438, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91439, .info = type_info_table[18]}),
                                                                      ((Data_s){.ptr = &tmp_91440, .info = type_info_table[18]})},
                                                   .length = 3})));
        Pattern_u tmp_88070 = (((Pattern_u){.tag = 8, .payload = {0}}));

        if (((tagAnyru8)((&((subPat)->data)))) == (((tagAnyru8)((&tmp_88070)))))
            break;
    }

    return ((tuple_4458){(out), (successVariable)});
}
String_s generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    String_s tmp_91442 = ((_generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr)));

    return ((format1PcVS4175rS0540)(("(%)"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91442, .info = type_info_table[18]})}, .length = 1})));
}
String_s _generateExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    String_s out = ((String_s){0});
    bool succ_11655_ = true;
    bool succ_11673_ = true;
    bool succ_11677_ = true;
    bool succ_11681_ = true;
    bool succ_11694_ = true;
    bool succ_11703_ = true;
    bool succ_11707_ = true;
    bool succ_11711_ = true;
    bool succ_11717_ = true;
    bool succ_11721_ = true;
    bool succ_11731_ = true;
    bool succ_11736_ = true;
    bool succ_11740_ = true;
    bool succ_11743_ = true;
    bool succ_11746_ = true;
    bool succ_11749_ = true;
    bool succ_11753_ = true;
    bool succ_11759_ = true;
    bool succ_11763_ = true;
    bool succ_11773_ = true;
    bool succ_11784_ = true;

    ExprData_u *tmp_18868_ = (&((expr)->data));
    {
        succ_11655_ &= (tmp_18868_->tag == 0);
        Token_s *lit = &tmp_18868_->payload.variant0._0;
        succ_11655_ &= true;
        if (succ_11655_) {
            {
                String_s _lit = ((String_s){0});
                SubStr_s tmp_91444 = ((*lit).content);

                ((formatPS0540PcVS4175rN)((&(_lit)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91444, .info = type_info_table[16]})}, .length = 1})));
                Type_u *t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                bool succ_11662_ = true;

                Type_u *tmp_18701_ = (t);
                succ_11662_ &= (tmp_18701_->tag == 3);
                PrimType_u *pt = &tmp_18701_->payload.variant3._0;
                succ_11662_ &= true;
                if (!succ_11662_) {
                    ((unreachablePcrN)(("Integer Literal doesn\'t have primitive type")));
                };
                bool succ_11665_ = true;
                bool succ_11667_ = true;
                bool succ_11669_ = true;

                PrimType_u tmp_18709_ = (*pt);
                {
                    succ_11665_ &= (tmp_18709_.tag == 8);
                    if (succ_11665_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("llu"), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                        goto after_18709;
                    }
                }
                {
                    succ_11667_ &= (tmp_18709_.tag == 3);
                    if (succ_11667_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("llu"), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                        goto after_18709;
                    }
                }
                {
                    succ_11669_ &= (tmp_18709_.tag == 7);
                    if (succ_11669_) {
                        {
                            ((formatPS0540PcVS4175rN)((&(_lit)), ("ll"), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                        goto after_18709;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_18709;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_18709:
                (void)0; // error: label at end of compound statement is a C23 extension
                String_s tmp_91449 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));
                String_s tmp_91450 = (_lit);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%)(%)"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91449, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91450, .info = type_info_table[18]})},
                                                           .length = 2})));
                ((dropPS0540rN)((&(_lit))));
            }
            goto after_18868;
        }
    }
    {
        succ_11673_ &= (tmp_18868_->tag == 1);
        Token_s *lit = &tmp_18868_->payload.variant1._0;
        succ_11673_ &= true;
        if (succ_11673_) {
            {
                String_s tmp_91452 = ((unescapeS7720rS0540)(((*lit).content)));

                ((formatPS0540PcVS4175rN)((&(out)), ("\"%\""), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91452, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11677_ &= (tmp_18868_->tag == 2);
        Token_s *lit = &tmp_18868_->payload.variant2._0;
        succ_11677_ &= true;
        if (succ_11677_) {
            {
                String_s tmp_91454 = ((unescapeS7720rS0540)(((*lit).content)));

                ((formatPS0540PcVS4175rN)((&(out)), ("\'%\'"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91454, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11681_ &= (tmp_18868_->tag == 3);
        ArrayContext_s *ctx = &tmp_18868_->payload.variant3._0;
        succ_11681_ &= true;
        if (succ_11681_) {
            {
                String_s tmp_91456 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%){"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91456, .info = type_info_table[18]})}, .length = 1})));
                if (((*ctx).size) == ((usize)(0llu))) {
                    for (usize i = ((usize)(0llu)); ((i) < ((*ctx).elemLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        usize idx = ((getElementAtIndexPS8905uszrusz)((&(*ctx)), (i)));
                        ParsedExpr_s *el = ((atPS7882uszrPS2435)((&(exprs)), (idx)));
                        String_s tmp_91458 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (el)));

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91458, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*ctx).elemLength) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }

                }

                else {
                    usize idx = ((getElementAtIndexPS8905uszrusz)((&(*ctx)), ((usize)(0llu))));
                    ParsedExpr_s *el = ((atPS7882uszrPS2435)((&(exprs)), (idx)));
                    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (el)));
                    for (usize i = ((usize)(0llu)); ((i) < ((*ctx).size)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_91461 = (e);

                        ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91461, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*ctx).size) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), ("}"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11694_ &= (tmp_18868_->tag == 4);
        IdentExpr_s *ident = &tmp_18868_->payload.variant4._0;
        succ_11694_ &= true;
        if (succ_11694_) {
            {
                String_s name = ((String_s){0});
                bool succ_11700_ = true;
                bool succ_11699_ = true;

                {
                    tuple_4329 tmp_18753_ = ((getVariableInfoPS9442S7720rT_S0610B)((this), (((*ident).name).content)));
                    Var_Context_s *ctx = &tmp_18753_._0;
                    succ_11700_ &= true;
                    succ_11699_ = tmp_18753_._1 == true;
                    succ_11700_ &= succ_11699_;

                    if (succ_11700_) {
                        ((name) = ((toStringPS7720rS0540)((&(((*ident).name).content)))));
                        if ((*ctx).bound_in_reference_pattern) {
                            String_s tmp_91465 = (name);

                            ((name) = ((format1PcVS4175rS0540)(("*%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91465, .info = type_info_table[18]})}, .length = 1}))));
                        }

                    } else {
                        if ((isFunctionPU5175rB)(((*ident).type))) {
                            ((name) = ((getMangledNamePS4904rS0540)(((atPS4111uszrPS4904)((&(funcDecls)), ((*ident).origID))))));
                        }

                        else {
                            SubStr_s tmp_91467 = (((*ident).name).content);

                            ((fprintPcVS4175rN)(("%\n"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91467, .info = type_info_table[16]})}, .length = 1})));
                            return ((newStringFromStrLitPcrS0540)(("/*TODO: dont know this ident */")));
                        }
                    }
                }

                ((makeNameCCompatiblePS0540rN)((&(name))));
                String_s tmp_91469 = (name);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91469, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11703_ &= (tmp_18868_->tag == 5);
        UnaryExpr_u *unary = &tmp_18868_->payload.variant5._0;
        succ_11703_ &= true;
        if (succ_11703_) {
            {
                ((out) = ((generateUnaryExprPS9442PS0540PU5427rS0540)((this), (tmpAlloc), (&(*unary)))));
            }
            goto after_18868;
        }
    }
    {
        succ_11707_ &= (tmp_18868_->tag == 6);
        BinaryExpr_u *bin = &tmp_18868_->payload.variant6._0;
        succ_11707_ &= true;
        if (succ_11707_) {
            {
                ((out) = ((generateBinaryExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr))));
            }
            goto after_18868;
        }
    }
    {
        succ_11711_ &= (tmp_18868_->tag == 7);
        CallExpr_s *call = &tmp_18868_->payload.variant7._0;
        succ_11711_ &= true;
        if (succ_11711_) {
            {
                String_s tmp_91471 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((*call).base)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%("), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91471, .info = type_info_table[18]})}, .length = 1})));
                for (usize i = ((usize)(0llu)); ((i) < (((*call).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s tmp_91473 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (((((*call).args).elements))[(i)])));

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91473, .info = type_info_table[18]})}, .length = 1})));
                    if ((i) != ((((*call).args).length) - ((usize)(1llu)))) {
                        ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (")"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11717_ &= (tmp_18868_->tag == 8);
        ParsedTypeNode_s **what = &tmp_18868_->payload.variant8._0;
        succ_11717_ &= true;
        if (succ_11717_) {
            {
                String_s tmp_91477 = ((generateTypeNamePS9442PS1372rS0540)((this), (*what)));

                ((formatPS0540PcVS4175rN)((&(out)), ("sizeof(%)"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91477, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11721_ &= (tmp_18868_->tag == 9);
        StructExpr_s *str = &tmp_18868_->payload.variant9._0;
        succ_11721_ &= true;
        if (succ_11721_) {
            {
                String_s tmp_91479 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91479, .info = type_info_table[18]})}, .length = 1})));
                if ((((*str).context).fieldLength) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("0"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }

                else {
                    for (usize i = ((usize)(0llu)); ((i) < (((*str).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                        Token_s nameTkn = ((getFieldNameAtIndexPS6291uszrS6070)((&((*str).context)), (i)));
                        ParsedExpr_s *fieldNode = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*str).context)), (i)));
                        String_s _name = ((toStringPS7720rS0540)((&((nameTkn).content))));
                        ((makeNameCCompatiblePS0540rN)((&(_name))));
                        SubStr_s name = ((asSubStrPS0540rS7720)((&(_name))));
                        SubStr_s tmp_91482 = (name);
                        String_s tmp_91483 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (fieldNode)));

                        ((formatPS0540PcVS4175rN)((&(out)), (".% = %"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91482, .info = type_info_table[16]}), ((Data_s){.ptr = &tmp_91483, .info = type_info_table[18]})},
                                                      .length = 2})));
                        if ((i) != ((((*str).context).fieldLength) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11731_ &= (tmp_18868_->tag == 10);
        UnionExpr_u *uni = &tmp_18868_->payload.variant10._0;
        succ_11731_ &= true;
        if (succ_11731_) {
            {
                ((out) = ((generateUnionInitPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (expr))));
            }
            goto after_18868;
        }
    }
    {
        succ_11736_ &= (tmp_18868_->tag == 11);
        ParsedExpr_s **subexpr = &tmp_18868_->payload.variant11._0;
        succ_11736_ &= true;
        ParsedTypeNode_s **type = &tmp_18868_->payload.variant11._1;
        succ_11736_ &= true;
        if (succ_11736_) {
            {
                Type_u *exprType = ((getTypePU9661rPU5175)((&((*subexpr)->typeState))));
                if ((isFunctionPU5175rB)((exprType))) {
                    String_s tmp_91487 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91488 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)(usize)(%)"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91487, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91488, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else if ((isDataPU5175rB)((exprType))) {
                    String_s tmp_91490 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91491 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("*(%*)(%.ptr)"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91490, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91491, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_91493 = ((generateTypeNamePS9442PS1372rS0540)((this), (*type)));
                    String_s tmp_91494 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)(%)"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91493, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91494, .info = type_info_table[18]})},
                                                               .length = 2})));
                }
            }
            goto after_18868;
        }
    }
    {
        succ_11740_ &= (tmp_18868_->tag == 12);
        if (succ_11740_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("NULL"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11743_ &= (tmp_18868_->tag == 13);
        if (succ_11743_) {
            {
                String_s tmp_91497 = ((generateTypeNamePS9442PU5175rS0540)((this), ((getTypePU9661rPU5175)((&((expr)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) {0}"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91497, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11746_ &= (tmp_18868_->tag == 14);
        if (succ_11746_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("true"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11749_ &= (tmp_18868_->tag == 15);
        if (succ_11749_) {
            {
                ((formatPS0540PcVS4175rN)((&(out)), ("false"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        succ_11753_ &= (tmp_18868_->tag == 16);
        ParsedFuncDecl_s **function = &tmp_18868_->payload.variant16._0;
        succ_11753_ &= true;
        if (succ_11753_) {
            {
                String_s name = ((getMangledNamePS4904rS0540)((*function)));
                ((makeNameCCompatiblePS0540rN)((&(name))));
                String_s tmp_91501 = (name);

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91501, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11759_ &= (tmp_18868_->tag == 17);
        ParsedTypeNode_s **typ = &tmp_18868_->payload.variant17._0;
        succ_11759_ &= true;
        if (succ_11759_) {
            {
                String_s tmp_91503 = ((generateTypeInfoPS9442S8951PU5175rS0540)((this), ((expr)->span), ((getTypePU9661rPU5175)((&((*typ)->typeState))))));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91503, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11763_ &= (tmp_18868_->tag == 18);
        ParsedExpr_s **subexpr = &tmp_18868_->payload.variant18._0;
        succ_11763_ &= true;
        if (succ_11763_) {
            {
                Type_u *exprType = ((getTypePU9661rPU5175)((&((*subexpr)->typeState))));
                String_s e = ((String_s){0});
                if ((isPointerPU5175rB)((exprType))) {
                    ((e) = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr))));
                }

                else {
                    String_s sub = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*subexpr)));
                    usize tmp_91505 = ((getIDPS2435rusz)((expr)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91505, .info = type_info_table[8]})}, .length = 1})));
                    String_s tmp_91507 = ((generateTypeNamePS9442PU5175S0540rS0540)((this), (exprType), (tmp_name)));
                    String_s tmp_91508 = (sub);

                    ((formatPS0540PcVS4175rN)((tmpAlloc), ("% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91507, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91508, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91510 = (tmp_name);

                    ((e) = ((format1PcVS4175rS0540)(("&%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91510, .info = type_info_table[18]})}, .length = 1}))));
                }

                String_s ti = ((generateTypeInfoPS9442S8951PU5175rS0540)((this), ((expr)->span), (exprType)));
                String_s tmp_91512 = (e);
                String_s tmp_91513 = (ti);

                ((formatPS0540PcVS4175rN)((&(out)), ("(Data_s) { .ptr = %, .info = % }"),
                                          ((variadic_4507){.ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91512, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91513, .info = type_info_table[18]})},
                                                           .length = 2})));
            }
            goto after_18868;
        }
    }
    {
        succ_11773_ &= (tmp_18868_->tag == 19);
        ParsedExprList_s *exprs = &tmp_18868_->payload.variant19._0;
        succ_11773_ &= true;
        if (succ_11773_) {
            {
                Type_u *_v = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                String_s vt = ((generateTypeNamePS9442PU5175rS0540)((this), (_v)));
                String_s et = ((generateTypeNamePS9442PU5175rS0540)((this), ((getUnderlyingTypePU5175BrPU5175)((_v), (false)))));
                String_s tmp_91515 = (vt);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { .ptr = "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91515, .info = type_info_table[18]})}, .length = 1})));
                if (((*exprs).length) == ((usize)(0llu))) {
                    ((formatPS0540PcVS4175rN)((&(out)), ("NULL"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }

                else {
                    String_s tmp = ((String_s){0});
                    String_s tmp_91518 = (et);
                    usize tmp_91519 = ((*exprs).length);

                    ((formatPS0540PcVS4175rN)((&(tmp)), ("(%[%]){ "),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91518, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91519, .info = type_info_table[8]})},
                                                               .length = 2})));
                    for (usize i = ((usize)(0llu)); ((i) < ((*exprs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        String_s tmp_91521 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((((*exprs).elements))[(i)])));

                        ((formatPS0540PcVS4175rN)((&(tmp)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91521, .info = type_info_table[18]})}, .length = 1})));
                        if ((i) != (((*exprs).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(tmp)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }

                    ((formatPS0540PcVS4175rN)((&(tmp)), (" }"), ((variadic_4507){.ptr = NULL, .length = 0})));
                    String_s tmp_91525 = (tmp);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91525, .info = type_info_table[18]})}, .length = 1})));
                }

                usize tmp_91527 = ((*exprs).length);

                ((formatPS0540PcVS4175rN)((&(out)), (" , .length = % }"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91527, .info = type_info_table[8]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    {
        succ_11784_ &= (tmp_18868_->tag == 20);
        ParsedExprList_s *exprs = &tmp_18868_->payload.variant20._0;
        succ_11784_ &= true;
        if (succ_11784_) {
            {
                Type_u *_t = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                String_s tt = ((generateTypeNamePS9442PU5175rS0540)((this), (_t)));
                String_s tmp_91529 = (tt);

                ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91529, .info = type_info_table[18]})}, .length = 1})));
                for (usize i = ((usize)(0llu)); ((i) < ((*exprs).length)); ((i) = ((i) + ((usize)(1llu))))) {
                    String_s tmp_91531 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), ((((*exprs).elements))[(i)])));

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91531, .info = type_info_table[18]})}, .length = 1})));
                    if ((i) != (((*exprs).length) - ((usize)(1llu)))) {
                        ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                    }
                }

                ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4507){.ptr = NULL, .length = 0})));
            }
            goto after_18868;
        }
    }
    {
        ExprData_u **t = &tmp_18868_;
        if (true) {
            {
                String_s s = ((toStringPS8951rS0540)((&((expr)->span))));
                (((fprintf))((stderr_), ("%s %.*s: expr %hhu\n"), (FATAL_STR), ((s).length), ((s).buffer), ((tagAnyru8)((*t)))));
                u8 tmp_91535 = ((tagAnyru8)((*t)));

                return ((format1PcVS4175rS0540)(("/*TODO: generateExpr %*/"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91535, .info = type_info_table[0]})}, .length = 1})));
            }
            goto after_18868;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18868:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateTypeInfoPS9442S8951PU5175rS0540(CGen_s *this, Span_s span, Type_u *type) {
    usize index = ((index_of_typePS3131PU5175rusz)((&((this)->type_info_table)), (type)));
    if ((index) >= (((this)->type_info_table).length)) {
        String_s l = ((toStringPS8951rS0540)((&(span))));
        String_s t = ((toStringPU5175rS0540)((type)));
        (((fprintf))((stderr_), ("%s: %s: WEEWOO!!! Type Info for Type %s doesn\'t exist!!!\n"), ((l).buffer), (FATAL_STR), ((t).buffer)));
        (((C_exiti32rN))(((i32)(2))));
    }

    usize tmp_91537 = (index);

    return ((format1PcVS4175rS0540)(("type_info_table[%]"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91537, .info = type_info_table[8]})}, .length = 1})));
}
String_s generateUnionInitPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *init) {
    Type_u *type = ((getTypePU9661rPU5175)((&((init)->typeState))));
    bool succ_11801_ = true;

    Type_u *tmp_18880_ = (type);
    succ_11801_ &= (tmp_18880_->tag == 8);
    ParsedUnionDecl_s **decl = &tmp_18880_->payload.variant8._0;
    succ_11801_ &= true;
    usize *_variant = &tmp_18880_->payload.variant8._1;
    succ_11801_ &= true;
    if (!succ_11801_) {
        ((unreachablePcrN)(("generateUnionInit")));
    };
    bool succ_11805_ = true;

    ExprData_u *tmp_18882_ = (&((init)->data));
    succ_11805_ &= (tmp_18882_->tag == 10);
    UnionExpr_u *uni = &tmp_18882_->payload.variant10._0;
    succ_11805_ &= true;
    if (!succ_11805_) {
        ((unreachablePcrN)(("generateUnionInit")));
    };
    String_s out = ((String_s){0});
    String_s tmp_91539 = ((generateTypeNamePS9442PU5175rS0540)((this), (type)));

    ((formatPS0540PcVS4175rN)((&(out)), ("(%) { "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91539, .info = type_info_table[18]})}, .length = 1})));
    usize tmp_91541 = (*_variant);

    ((formatPS0540PcVS4175rN)((&(out)), (".tag = %"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91541, .info = type_info_table[8]})}, .length = 1})));
    bool has_non_empty = (false);
    for (usize i = ((usize)(0llu)); ((i) < (((*decl)->variants).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedUnionVariant_s *_v = (*((atPS0030uszrPPS3506)((&((*decl)->variants)), (i))));
        bool succ_11814_ = true;

        {
            ParsedUnionVariantData_u *tmp_18891_ = (&((_v)->data));
            succ_11814_ &= (tmp_18891_->tag == 0);

            if (succ_11814_) {
            } else {
                ((has_non_empty) = (true));
                break;
            }
        }
    }

    if (has_non_empty) {
        ((formatPS0540PcVS4175rN)((&(out)), (", .payload = "), ((variadic_4507){.ptr = NULL, .length = 0})));
        bool succ_11818_ = true;
        bool succ_11826_ = true;
        bool succ_11835_ = true;

        UnionExpr_u *tmp_18929_ = (&(*uni));
        {
            succ_11818_ &= (tmp_18929_->tag == 0);
            CallExpr_s *texpr = &tmp_18929_->payload.variant0._0;
            succ_11818_ &= true;
            if (succ_11818_) {
                {
                    usize tmp_91544 = (*_variant);

                    ((formatPS0540PcVS4175rN)((&(out)), ("{ .variant% = { "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91544, .info = type_info_table[8]})}, .length = 1})));
                    for (usize i = ((usize)(0llu)); ((i) < (((*texpr).args).length)); ((i) = ((i) + ((usize)(1llu))))) {
                        ParsedExpr_s *v = (((((*texpr).args).elements))[(i)]);
                        String_s te = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (v)));
                        usize tmp_91546 = (i);
                        String_s tmp_91547 = (te);

                        ((formatPS0540PcVS4175rN)((&(out)), ("._% = %"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91546, .info = type_info_table[8]}), ((Data_s){.ptr = &tmp_91547, .info = type_info_table[18]})},
                                                      .length = 2})));
                        if ((i) != ((((*texpr).args).length) - ((usize)(1llu)))) {
                            ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                        }
                    }

                    ((formatPS0540PcVS4175rN)((&(out)), (" } }"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }
                goto after_18929;
            }
        }
        {
            succ_11826_ &= (tmp_18929_->tag == 1);
            StructExpr_s *sexpr = &tmp_18929_->payload.variant1._0;
            succ_11826_ &= true;
            if (succ_11826_) {
                {
                    usize tmp_91551 = (*_variant);

                    ((formatPS0540PcVS4175rN)((&(out)), ("{ .variant% = { "), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91551, .info = type_info_table[8]})}, .length = 1})));
                    if ((((*sexpr).context).fieldLength) > ((usize)(0llu))) {
                        for (usize i = ((usize)(0llu)); ((i) < (((*sexpr).context).fieldLength)); ((i) = ((i) + ((usize)(1llu))))) {
                            Token_s name = ((getFieldNameAtIndexPS6291uszrS6070)((&((*sexpr).context)), (i)));
                            ParsedExpr_s *field = ((getFieldExprAtIndexPS6291uszrPS2435)((&((*sexpr).context)), (i)));
                            String_s te = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (field)));
                            usize index = ((getFieldIndexPS3506PS7720rusz)((*((atPS0030uszrPPS3506)((&((*decl)->variants)), (*_variant)))), (&((name).content))));
                            usize tmp_91553 = (index);
                            String_s tmp_91554 = (te);

                            ((formatPS0540PcVS4175rN)((&(out)), ("._% = %"),
                                                      ((variadic_4507){
                                                          .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91553, .info = type_info_table[8]}), ((Data_s){.ptr = &tmp_91554, .info = type_info_table[18]})},
                                                          .length = 2})));
                            if ((i) != ((((*sexpr).context).fieldLength) - ((usize)(1llu)))) {
                                ((formatPS0540PcVS4175rN)((&(out)), (", "), ((variadic_4507){.ptr = NULL, .length = 0})));
                            }
                        }

                    }

                    else {
                        ((formatPS0540PcVS4175rN)((&(out)), ("0"), ((variadic_4507){.ptr = NULL, .length = 0})));
                    }

                    ((formatPS0540PcVS4175rN)((&(out)), (" } }"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }
                goto after_18929;
            }
        }
        {
            succ_11835_ &= (tmp_18929_->tag == 2);
            if (succ_11835_) {
                {
                    ((formatPS0540PcVS4175rN)((&(out)), ("{0}"), ((variadic_4507){.ptr = NULL, .length = 0})));
                }
                goto after_18929;
            }
        }
        {
            if (true) {
                {
                    ((unreachablerN)());
                }
                goto after_18929;
            }
        }
        unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
    after_18929:
        (void)0; // error: label at end of compound statement is a C23 extension
    }

    ((formatPS0540PcVS4175rN)((&(out)), (" }"), ((variadic_4507){.ptr = NULL, .length = 0})));
    return (out);
}
bool isCLValuePS2435rB(ParsedExpr_s *this) {
    bool succ_11842_ = true;
    bool succ_11840_ = true;
    bool succ_11848_ = true;
    bool succ_11846_ = true;
    bool succ_11859_ = true;
    bool succ_11857_ = true;
    bool succ_11854_ = true;
    bool succ_11866_ = true;

    ExprData_u tmp_18948_ = ((this)->data);
    {
        succ_11842_ &= (tmp_18948_.tag == 5);
        succ_11840_ &= (tmp_18948_.payload.variant5._0.tag == 2);
        succ_11840_ &= true;
        succ_11842_ &= succ_11840_;
        if (succ_11842_) {
            {
                return (true);
            }
            goto after_18948;
        }
    }
    {
        succ_11848_ &= (tmp_18948_.tag == 6);
        succ_11846_ &= (tmp_18948_.payload.variant6._0.tag == 19);
        ParsedExpr_s **lhs = &tmp_18948_.payload.variant6._0.payload.variant19._0;
        succ_11846_ &= true;
        ParsedExpr_s **rhs = &tmp_18948_.payload.variant6._0.payload.variant19._1;
        succ_11846_ &= true;
        succ_11848_ &= succ_11846_;
        if (succ_11848_) {
            {
                return (true);
            }
            goto after_18948;
        }
    }
    {
        succ_11859_ &= (tmp_18948_.tag == 6);
        succ_11857_ &= (tmp_18948_.payload.variant6._0.tag == 1);
        ParsedExpr_s **lhs = &tmp_18948_.payload.variant6._0.payload.variant1._0;
        succ_11857_ &= true;
        succ_11854_ &= true;
        succ_11854_ &= true;
        ExprData_u *rhs = &tmp_18948_.payload.variant6._0.payload.variant1._1->data;
        succ_11854_ &= true;
        succ_11854_ &= true;
        succ_11857_ &= succ_11854_;
        succ_11859_ &= succ_11857_;
        if (succ_11859_) {
            {
                if (!((isCLValuePS2435rB)((*lhs))))
                    return (false);
                bool succ_11862_ = true;

                ExprData_u tmp_18943_ = (*rhs);
                {
                    succ_11862_ &= (tmp_18943_.tag == 4);
                    succ_11862_ &= true;
                    if (succ_11862_) {
                        {
                            return (true);
                        }
                        goto after_18943;
                    }
                }
                {
                    if (true) {
                        {
                        }
                        goto after_18943;
                    }
                }
                unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
            after_18943:
                (void)0; // error: label at end of compound statement is a C23 extension
            }
            goto after_18948;
        }
    }
    {
        succ_11866_ &= (tmp_18948_.tag == 4);
        succ_11866_ &= true;
        if (succ_11866_) {
            {
                return (true);
            }
            goto after_18948;
        }
    }
    {
        if (true) {
            {
            }
            goto after_18948;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18948:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (false);
}
String_s generateUnaryExprPS9442PS0540PU5427rS0540(CGen_s *this, String_s *tmpAlloc, UnaryExpr_u *unary) {
    String_s out = ((String_s){0});
    bool succ_11872_ = true;
    bool succ_11879_ = true;
    bool succ_11883_ = true;
    bool succ_11887_ = true;
    bool succ_11891_ = true;

    UnaryExpr_u *tmp_18975_ = (unary);
    {
        succ_11872_ &= (tmp_18975_->tag == 1);
        ParsedExpr_s **expr = &tmp_18975_->payload.variant1._0;
        succ_11872_ &= true;
        if (succ_11872_) {
            {
                if ((isCLValuePS2435rB)((*expr))) {
                    String_s tmp_91561 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                    ((formatPS0540PcVS4175rN)((&(out)), ("&%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91561, .info = type_info_table[18]})}, .length = 1})));
                }

                else {
                    usize tmp_91563 = ((getIDPS2435rusz)((*expr)));

                    String_s tmp_name = ((format1PcVS4175rS0540)(("tmp_%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91563, .info = type_info_table[8]})}, .length = 1})));
                    String_s t = ((generateTypeNamePS9442PU5175S0540rS0540)((this), ((getTypePU9661rPU5175)((&((*expr)->typeState)))), (tmp_name)));
                    String_s e = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));
                    String_s tmp_91565 = (t);
                    String_s tmp_91566 = (e);

                    ((formatPS0540PcVS4175rN)((tmpAlloc), ("% = %;\n"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91565, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91566, .info = type_info_table[18]})},
                                                               .length = 2})));
                    String_s tmp_91568 = (tmp_name);

                    ((formatPS0540PcVS4175rN)((&(out)), ("&%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91568, .info = type_info_table[18]})}, .length = 1})));
                }
            }
            goto after_18975;
        }
    }
    {
        succ_11879_ &= (tmp_18975_->tag == 2);
        ParsedExpr_s **expr = &tmp_18975_->payload.variant2._0;
        succ_11879_ &= true;
        if (succ_11879_) {
            {
                String_s tmp_91570 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("*%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91570, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18975;
        }
    }
    {
        succ_11883_ &= (tmp_18975_->tag == 3);
        ParsedExpr_s **expr = &tmp_18975_->payload.variant3._0;
        succ_11883_ &= true;
        if (succ_11883_) {
            {
                String_s tmp_91572 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("-%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91572, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18975;
        }
    }
    {
        succ_11887_ &= (tmp_18975_->tag == 4);
        ParsedExpr_s **expr = &tmp_18975_->payload.variant4._0;
        succ_11887_ &= true;
        if (succ_11887_) {
            {
                String_s tmp_91574 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("!%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91574, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18975;
        }
    }
    {
        succ_11891_ &= (tmp_18975_->tag == 0);
        ParsedExpr_s **expr = &tmp_18975_->payload.variant0._0;
        succ_11891_ &= true;
        if (succ_11891_) {
            {
                if (*((flags).warnSimple)) {
                    String_s loc = ((toStringPS8951rS0540)((&((*expr)->span))));
                    (((fprintf))((stderr_), ("%s: %.*s: Comptime has no effect when transpiling to C.\n"), (WARN_STR), ((loc).length), ((loc).buffer)));
                }

                String_s tmp_91576 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*expr)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91576, .info = type_info_table[18]})}, .length = 1})));
            }
            goto after_18975;
        }
    }
    {
        UnaryExpr_u **t = &tmp_18975_;
        if (true) {
            {
                ((unreachablePcrN)(("generateUnaryExpr")));
            }
            goto after_18975;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_18975:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
String_s generateBinaryExprPS9442PS0540PS2435rS0540(CGen_s *this, String_s *tmpAlloc, ParsedExpr_s *expr) {
    bool succ_11897_ = true;

    ExprData_u *tmp_18978_ = (&((expr)->data));
    succ_11897_ &= (tmp_18978_->tag == 6);
    BinaryExpr_u *bin = &tmp_18978_->payload.variant6._0;
    succ_11897_ &= true;
    if (!succ_11897_) {
        ((unreachablePcrN)(("generateBinaryExpr")));
    };
    String_s out = ((String_s){0});
    bool succ_11904_ = true;
    bool succ_11909_ = true;
    bool succ_11925_ = true;
    bool succ_11933_ = true;

    BinaryExpr_u *tmp_19061_ = (&(*bin));
    {
        succ_11904_ &= (tmp_19061_->tag == 0);
        succ_11904_ &= true;
        ParsedExpr_s **rhs = &tmp_19061_->payload.variant0._1;
        succ_11904_ &= true;
        if (succ_11904_) {
            {
                ((out) = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs))));
            }
            goto after_19061;
        }
    }
    {
        succ_11909_ &= (tmp_19061_->tag == 1);
        ParsedExpr_s **lhs = &tmp_19061_->payload.variant1._0;
        succ_11909_ &= true;
        ParsedExpr_s **rhs = &tmp_19061_->payload.variant1._1;
        succ_11909_ &= true;
        if (succ_11909_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s tmp_91578 = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));

                ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91578, .info = type_info_table[18]})}, .length = 1})));
                if ((isArrayPU5175rB)((lhsType))) {
                    bool succ_11915_ = true;

                    Type_u *tmp_18985_ = (lhsType);
                    succ_11915_ &= (tmp_18985_->tag == 5);
                    succ_11915_ &= true;
                    usize *size = &tmp_18985_->payload.variant5._1;
                    succ_11915_ &= true;
                    if (!succ_11915_) {
                        ((unreachablerN)());
                    };
                    (((out).length) = ((usize)(0llu)));
                    ((pushNumberPS0540uszrN)((&(out)), (*size)));
                }

                else if ((isVariadicTypePU5175rB)((lhsType))) {
                    ((pushStrPS0540PcrN)((&(out)), (".length")));
                }

                else if (((isStructPU5175rB)((lhsType))) || ((isStructPointerPU5175rB)((lhsType)))) {
                    if ((isStructPointerPU5175rB)((lhsType))) {
                        ((pushStrPS0540PcrN)((&(out)), ("->")));
                    }

                    else {
                        ((pushStrPS0540PcrN)((&(out)), (".")));
                    }

                    bool succ_11919_ = true;

                    ExprData_u *tmp_18997_ = (&((*rhs)->data));
                    succ_11919_ &= (tmp_18997_->tag == 4);
                    IdentExpr_s *ident = &tmp_18997_->payload.variant4._0;
                    succ_11919_ &= true;
                    if (!succ_11919_) {
                        ((unreachablePcrN)(("Struct Dot doesn\'t have ident RHS")));
                    };
                    String_s _field = ((toStringPS7720rS0540)((&(((*ident).name).content))));
                    ((makeNameCCompatiblePS0540rN)((&(_field))));
                    String_s tmp_91580 = (_field);

                    ((formatPS0540PcVS4175rN)((&(out)), ("%"), ((variadic_4507){.ptr = (Data_s[1]){((Data_s){.ptr = &tmp_91580, .info = type_info_table[18]})}, .length = 1})));
                }

                else if (((isTuplePU5175rB)((lhsType))) || ((isTuplePointerPU5175rB)((lhsType)))) {
                    return ((newStringFromStrLitPcrS0540)(("/*TODO: dot tuple */")));
                }

                else {
                    ((unreachablePcrN)(("generateBinaryExpr: Dot")));
                }
            }
            goto after_19061;
        }
    }
    {
        succ_11925_ &= (tmp_19061_->tag == 19);
        ParsedExpr_s **lhs = &tmp_19061_->payload.variant19._0;
        succ_11925_ &= true;
        ParsedExpr_s **rhs = &tmp_19061_->payload.variant19._1;
        succ_11925_ &= true;
        if (succ_11925_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs)));
                if ((isArrayPU5175rB)((lhsType))) {
                    String_s tmp_91582 = (lhsExpr);
                    String_s tmp_91583 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%.arr)[%]"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91582, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91583, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else if ((isVariadicTypePU5175rB)((lhsType))) {
                    String_s tmp_91585 = (lhsExpr);
                    String_s tmp_91586 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%.ptr)[%]"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91585, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91586, .info = type_info_table[18]})},
                                                               .length = 2})));
                }

                else {
                    String_s tmp_91588 = (lhsExpr);
                    String_s tmp_91589 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("(%)[%]"),
                                              ((variadic_4507){.ptr =
                                                                   (Data_s[2]){((Data_s){.ptr = &tmp_91588, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91589, .info = type_info_table[18]})},
                                                               .length = 2})));
                }
            }
            goto after_19061;
        }
    }
    {
        succ_11933_ &= (tmp_19061_->tag == 7);
        ParsedExpr_s **lhs = &tmp_19061_->payload.variant7._0;
        succ_11933_ &= true;
        ParsedExpr_s **rhs = &tmp_19061_->payload.variant7._1;
        succ_11933_ &= true;
        if (succ_11933_) {
            {
                Type_u *lhsType = ((getTypePU9661rPU5175)((&((*lhs)->typeState))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (*rhs)));
                if ((isFloatPU5175rB)((lhsType))) {
                    if (((getSizeInBytesPU5175rusz)((lhsType))) == ((usize)(4llu))) {
                        String_s tmp_91591 = (lhsExpr);
                        String_s tmp_91592 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("fmodf(%, %)"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91591, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91592, .info = type_info_table[18]})},
                                                      .length = 2})));
                    }

                    else {
                        String_s tmp_91594 = (lhsExpr);
                        String_s tmp_91595 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("fmod(%, %)"),
                                                  ((variadic_4507){
                                                      .ptr = (Data_s[2]){((Data_s){.ptr = &tmp_91594, .info = type_info_table[18]}), ((Data_s){.ptr = &tmp_91595, .info = type_info_table[18]})},
                                                      .length = 2})));
                    }

                }

                else {
                    String_s tmp_91597 = (lhsExpr);
                    String_s tmp_91599 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                              ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91597, .info = type_info_table[18]}),
                                                                                  ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                  ((Data_s){.ptr = &tmp_91599, .info = type_info_table[18]})},
                                                               .length = 3})));
                }
            }
            goto after_19061;
        }
    }
    {
        if (true) {
            {
                ParsedExpr_s *lhs = (NULL);
                ParsedExpr_s *rhs = (NULL);
                ((extractOperandsPU0121PPS2435PPS2435rN)((&(*bin)), (&(lhs)), (&(rhs))));
                String_s lhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (lhs)));
                String_s rhsExpr = ((generateExprPS9442PS0540PS2435rS0540)((this), (tmpAlloc), (rhs)));
                if ((isArithmeticPU0121rB)((&(*bin)))) {
                    Type_u *lhsType = ((getTypePU9661rPU5175)((&((lhs)->typeState))));
                    Type_u *rhsType = ((getTypePU9661rPU5175)((&((rhs)->typeState))));
                    Type_u *resType = ((getTypePU9661rPU5175)((&((expr)->typeState))));
                    String_s rt = ((generateTypeNamePS9442PU5175rS0540)((this), (resType)));
                    if (((isPointerPU5175rB)((lhsType))) && ((isPointerPU5175rB)((rhsType)))) {
                        String_s tmp_91601 = (rt);
                        String_s tmp_91602 = (lhsExpr);
                        String_s tmp_91604 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)((unsigned char *)% % (unsigned char *)%)"),
                                                  ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91601, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91602, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                      ((Data_s){.ptr = &tmp_91604, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else if ((isPointerPU5175rB)((lhsType))) {
                        String_s tmp_91606 = (rt);
                        String_s tmp_91607 = (lhsExpr);
                        String_s tmp_91609 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)((unsigned char *)% % %)"),
                                                  ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91606, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91607, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                      ((Data_s){.ptr = &tmp_91609, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else if ((isPointerPU5175rB)((rhsType))) {
                        String_s tmp_91611 = (rt);
                        String_s tmp_91612 = (lhsExpr);
                        String_s tmp_91614 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("(%)(% % (unsigned char *)%)"),
                                                  ((variadic_4507){.ptr = (Data_s[4]){((Data_s){.ptr = &tmp_91611, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = &tmp_91612, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                      ((Data_s){.ptr = &tmp_91614, .info = type_info_table[18]})},
                                                                   .length = 4})));
                    }

                    else {
                        String_s tmp_91616 = (lhsExpr);
                        String_s tmp_91618 = (rhsExpr);

                        ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                                  ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91616, .info = type_info_table[18]}),
                                                                                      ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                      ((Data_s){.ptr = &tmp_91618, .info = type_info_table[18]})},
                                                                   .length = 3})));
                    }

                }

                else {
                    String_s tmp_91620 = (lhsExpr);
                    String_s tmp_91622 = (rhsExpr);

                    ((formatPS0540PcVS4175rN)((&(out)), ("% % %"),
                                              ((variadic_4507){.ptr = (Data_s[3]){((Data_s){.ptr = &tmp_91620, .info = type_info_table[18]}),
                                                                                  ((Data_s){.ptr = ((binOpAsStrPU0121rPc)((&(*bin)))), .info = type_info_table[222]}),
                                                                                  ((Data_s){.ptr = &tmp_91622, .info = type_info_table[18]})},
                                                               .length = 3})));
                }
            }
            goto after_19061;
        }
    }
    unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
after_19061:
    (void)0; // error: label at end of compound statement is a C23 extension
    return (out);
}
i32 maini32PPcri32(i32 argc, char **argv) {
    for (usize i = ((usize)(0llu)); ((i) < (PARSED_TYPE_BUILTIN)); ((i) = ((i) + ((usize)(1llu))))) {
        ((pushPS4419S1372rN)((&(typeNodes)), ((ParsedTypeNode_s){.span = ((Span_s){0}), .kind = (PARSED_TYPE_BUILTIN)})));
    }

    (((flags).file) = ((addStringFlagPS7660PcuszrPS0540)((&(flagParser)), ("The input file"), (FLAG_MODE_MANDATORY))));
    (((flags).out) = ((addStringFlagPS7660PcPcPcuszrPS0540)((&(flagParser)), ("o"), ("output"), ("The output file"), ((FLAG_MODE_SINGLE) | (FLAG_MODE_MANDATORY)))));
    (((flags).verbose) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("v"), ("verbose"), ("Enable verbose output"))));
    (((flags).warnSimple) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("w"), ("warn"), ("Enable warnings"))));
    (((flags).warnExtra) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-extra"), ("Enable extra warnings"))));
    (((flags).warnUnused) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-unused"), ("Enable warnings about unused expression values, functions, etc."))));
    bool *warnAll = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--warn-all"), ("Enable all warnings")));
    (((flags).target) = ((addStringFlagPS7660PcPcPcrPS0540)((&(flagParser)), ("t"), ("target"), ("The target to compile for. Must be either Windows or Linux."))));
    (((flags).checkOnly) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--check-only"), ("Stop after semantic analysis"))));
    (((flags).emitASM) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-asm"), ("Save the generated assembly code in <output>.asm"))));
    (((flags).emitBIR) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-bir"), ("Save the generated bufo IR in <output>.bir"))));
    (((flags).emitLLVM) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--emit-llvm"), ("Save the generated LLVM IR in <output>.ll"))));
    (((flags).transpileToC) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--transpile-c"), ("Transpile the input to a target-specific C program."))));
    (((flags).dontLink) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--dont-link"), ("Stop after generating <output>.obj"))));
    (((flags).noEntry) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-entry"), ("Don\'t include an entrypoint in the final output"))));
    (((flags).linkDynamic) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--link-dynamic"), ("Use the specified dynamic libraries to link instead of static libraries"))));
    (((flags).debug) = ((addBoolFlagPS7660PcPcPcrPB)((&(flagParser)), ("d"), ("debug"), ("Compile with debug info"))));
    (((flags).trace) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--trace"), ("Trace function calls"))));
    (((flags).opt) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--opt"), ("Enable aggressive optimizations"))));
    (((flags).disableExternalComptime) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-extern-comptime"), ("Don\'t allow any compile time calls to functions marked `@extern`."))));
    (((flags).disableInlineAssembly) = ((addBoolFlagPS7660PcPcrPB)((&(flagParser)), ("--no-inline-assembly"), ("Don\'t allow any `asm()` blocks."))));
    bool *help = ((addHelpFlagPS7660rPB)((&(flagParser))));
    if (!((runOnPS7660i32PPcrB)((&(flagParser)), (argc), (argv)))) {
        ((showErrorsAnyPS7660rN)((stderr_), (&(flagParser))));
        ((showUsageAnyPS7660rN)((stderr_), (&(flagParser))));
        ((showHelpAnyPS7660rN)((stderr_), (&(flagParser))));
        return ((i32)(1));
    }

    if (*(help)) {
        ((showUsageAnyPS7660rN)((stdout_), (&(flagParser))));
        ((showHelpAnyPS7660rN)((stdout_), (&(flagParser))));
        return ((i32)(0));
    }

    if (*(warnAll)) {
        ((*((flags).warnExtra)) = (true));
        ((*((flags).warnSimple)) = (true));
        ((*((flags).warnUnused)) = (true));
    }

    if ((*((flags).warnExtra)) && (!(*((flags).warnSimple)))) {
        (((fprintf))((stderr_), ("error: --warn-extra only works in combination with [-w|--warn]\n")));
        return ((i32)(1));
    }

    for (u8 i = ((u8)(0)); ((i) < ((u8)((PRIM_TYPE_COUNT)))); ((i) = ((i) + ((u8)(1))))) {
        ((pushPS4174U5175rN)((&(types)), (((Type_u){.tag = 1, .payload = {0}}))));
        if (*((flags).debug))
            ((pushPS7368S5777rN)((&(debugTypes)), ((LLVMMetadata_s){0})));
        ((wrapU5175rPU5175)(((Type_u){.tag = 3, .payload = {.variant3 = {._0 = (*((PrimType_u *)((&(i)))))}}})));
    }

    String_s tmp_90016 = ((newStringFromStrLitPcrS0540)(("x86_64-pc-windows-msvc")));
    String_s tmp_90033 = ((newStringFromStrLitPcrS0540)(("x86_64-pc-linux-gnu")));

    if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_90016))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("WINDOWS"))));
    }

    else if ((equalsPS0540PS0540rB)(((flags).target), (&tmp_90033))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("LINUX"))));
    }

    else if ((((flags).target)->length) == ((usize)(0llu))) {
        ((*((flags).target)) = ((newStringFromStrLitPcrS0540)(("LINUX"))));
    }

    else {
        (((fprintf))((stderr_), ("error: Unknown target %s\n"), (((flags).target)->buffer)));
        ((showHelpAnyPS7660rN)((stderr_), (&(flagParser))));
        return ((i32)(1));
    }

    String_s filepath = (*((flags).file));
    ((filepath) = ((toAbsolutePathPS0540rS0540)((&(filepath)))));
    SubStr_s fileSubStr = ((asSubStrPS0540rS7720)((&(filepath))));
    String_s string = ((readFileToStringPcrS0540)((((flags).file)->buffer)));
    SubStr_s sub = ((newSubStrOfStringPS0540uszuszrS7720)((&(string)), ((usize)(0llu)), ((string).length)));
    Parser_s parser = ((newParserFromSourceuszS7720rS2466)(((usize)(0llu)), (sub)));
    if (!((findStdAndAddToImportsPS2466rB)((&(parser)))))
        return ((i32)(1));
    ((addImportRootPS2466S7720rN)((&(parser)), ((newSubStrOfStrLitPcrS7720)(("./std/")))));
    ParsedFile_s project = ((parseProjectPS2466S7720rS1892)((&(parser)), (fileSubStr)));
    TypeChecker_s checker = ((newTypeCheckerrS3900)());
    if (!((typeCheckProjectPS3900PS1892rB)((&(checker)), (&(project)))))
        return ((i32)(1));
    if (*((flags).transpileToC)) {
        ((transpileToCrN)());
    }

    else {
        IRGen_s generator = ((newIRGeneratorPS7791rS9562)((&((checker).lookup))));
        if (!((generateBytecodePS9562PS1892rB)((&(generator)), (&(project)))))
            return ((i32)(1));
        if (!((analyzeControlFlowPS9562rB)((&(generator)))))
            return ((i32)(1));
        if (*((flags).checkOnly))
            return ((i32)(0));
        IRInterp_s interp = ((newIRInterpreterPS9562rS3154)((&(generator))));
        LLVMCodegen_s llvmCodegen = ((newLLVMCodegenS7720PS9562PS3154rS4053)((fileSubStr), (&(generator)), (&(interp))));
        if (!((generateExecutablePS4053S7720i32PPcrB)((&(llvmCodegen)), ((asSubStrPS0540rS7720)(((flags).out))), (argc), (argv))))
            return ((i32)(1));
        if (!((linkExecutablerB)()))
            return ((i32)(1));
    }

    if (*((flags).debug)) {
        (((printf))(("files.length         = %llu\n"), ((files).length)));
        (((printf))(("topLevelItems.length = %llu\n"), ((topLevelItems).length)));
        (((printf))(("structDecls.length   = %llu\n"), ((structDecls).length)));
        (((printf))(("funcDecls.length     = %llu\n"), ((funcDecls).length)));
        (((printf))(("blocks.length        = %llu\n"), ((blocks).length)));
        (((printf))(("stmts.length         = %llu\n"), ((stmts).length)));
        (((printf))(("typeNodes.length     = %llu\n"), ((typeNodes).length)));
        (((printf))(("exprs.length         = %llu\n"), ((exprs).length)));
    }

    ((dropPS0540rN)((&(string))));
    return ((i32)(0));
}
bool findStdAndAddToImportsPS2466rB(Parser_s *parser) {
    char *_my_path = ((getBufoPathrPc)());
    String_s my_path = ((newStringFromStrLitPcrS0540)((_my_path)));
    (((free))((_my_path)));
    String_s root = ((getRootPS0540rS0540)((&(my_path))));
    ((pushStrPS0540PcrN)((&(root)), ("/std/")));
    ((addImportRootPS2466S7720rN)((parser), ((asSubStrPS0540rS7720)((&(root))))));
    return (true);
}
char *getBufoPathrPc(none) {
    Any buffer = (((malloc))(((usize)(1024llu))));
    (((memset))((buffer), ((i32)(0)), ((usize)(1024llu))));
    i32 n = ((readlink)(("/proc/self/exe"), (buffer), ((i32)(1024))));
    if ((n) < ((i32)(0))) {
        (((free))((buffer)));
        return (NULL);
    }

    return (buffer);
}
bool linkExecutablerB(none) {
    if (*((flags).dontLink)) {
        return (true);
    }

    String_s tmp_90685 = ((newStringFromStrLitPcrS0540)(("LINUX")));

    if (!((equalsPS0540PS0540rB)(((flags).target), (&tmp_90685)))) {
        (((fprintf))((stderr_), ("%s: Cross-linking is not supported yet. Run with `--dont-link` to generate an object file.\n"), (ERR_STR)));
        return (false);
    }

    String_s s = ((newStringFromStrLitPcrS0540)(("ld ")));
    ((pushStrPS0540PcrN)((&(s)), ("-dynamic-linker ")));
    ((pushStrPS0540PcrN)((&(s)), ("/lib64/ld-linux-x86-64.so.2 ")));
    ((pushStrPS0540PcrN)((&(s)), ("/lib64/crt1.o ")));
    ((pushStringPS0540PS0540rN)((&(s)), ((flags).out)));
    ((pushStrPS0540PcrN)((&(s)), (".obj ")));
    ((pushStrPS0540PcrN)((&(s)), ("-lc ")));
    ((pushStrPS0540PcrN)((&(s)), ("-o ")));
    ((pushStringPS0540PS0540rN)((&(s)), ((flags).out)));
    for (usize i = ((usize)(0llu)); ((i) < ((configs).length)); ((i) = ((i) + ((usize)(1llu))))) {
        ParsedConfig_s *flag = ((atPS9153uszrPS0890)((&(configs)), (i)));
        if ((flag)->ignored)
            continue;
        for (usize j = ((usize)(0llu)); ((j) < (((flag)->configs).length)); ((j) = ((j) + ((usize)(1llu))))) {
            Config_u *_flag = ((atPS1575uszrPU7467)((&((flag)->configs)), (j)));
            bool succ_12027_ = true;
            bool succ_12031_ = true;
            bool succ_12035_ = true;
            bool succ_12040_ = true;

            Config_u *tmp_19331_ = (_flag);
            {
                succ_12027_ &= (tmp_19331_->tag == 1);
                Token_s *name = &tmp_19331_->payload.variant1._0;
                succ_12027_ &= true;
                if (succ_12027_) {
                    {
                        if (*((flags).linkDynamic))
                            continue;
                        ((pushCharPS0540crN)((&(s)), (' ')));
                        ((pushStrPS0540PcrN)((&(s)), ("-l ")));
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                    }
                    goto after_19331;
                }
            }
            {
                succ_12031_ &= (tmp_19331_->tag == 2);
                Token_s *name = &tmp_19331_->payload.variant2._0;
                succ_12031_ &= true;
                if (succ_12031_) {
                    {
                        if (!(*((flags).linkDynamic)))
                            continue;
                        ((pushCharPS0540crN)((&(s)), (' ')));
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                    }
                    goto after_19331;
                }
            }
            {
                succ_12035_ &= (tmp_19331_->tag == 3);
                Token_s *name = &tmp_19331_->payload.variant3._0;
                succ_12035_ &= true;
                if (succ_12035_) {
                    {
                        String_s _p = ((toStringPS7720rS0540)((&((*name).content))));
                        if ((dirExistsPcrB)(((_p).buffer))) {
                            ((pushCharPS0540crN)((&(s)), (' ')));
                            ((pushStrPS0540PcrN)((&(s)), ("-L")));
                            ((pushStringPS0540PS0540rN)((&(s)), (&(_p))));
                        }

                        ((dropPS0540rN)((&(_p))));
                    }
                    goto after_19331;
                }
            }
            {
                succ_12040_ &= (tmp_19331_->tag == 4);
                Token_s *name = &tmp_19331_->payload.variant4._0;
                succ_12040_ &= true;
                if (succ_12040_) {
                    {
                        ((pushCharPS0540crN)((&(s)), (' ')));
                        ((pushSubStrPS0540PS7720rN)((&(s)), (&((*name).content))));
                    }
                    goto after_19331;
                }
            }
            {
                Config_u **unknown = &tmp_19331_;
                if (true) {
                    {
                        (((fprintf))((stderr_), ("%s linkExecutable: Unknown tag %hhu!\n"), (FATAL_STR), ((tagAnyru8)((*unknown)))));
                        (((C_exiti32rN))(((i32)(2))));
                    }
                    goto after_19331;
                }
            }
            unreachablePcrN("RUNTIME ERROR: match statement is not exhaustive. this is a bug!");
        after_19331:
            (void)0; // error: label at end of compound statement is a C23 extension
        }
    }

    Cmd_s cmd = ((newCmdFromStrLitPcrS3657)(((s).buffer)));
    (((cmd).log) = (*((flags).verbose)));
    bool success = ((runSyncPS3657rB)((&(cmd))));
    ((dropPS0540rN)((&(s))));
    return (success);
}
i32 __real_main(i32 argc, char **argv, i32 (*main)(i32, char **)) {
    ((setupStdHandlesrN)());
    i32 code = ((main)((argc), (argv)));
    (((fflush))((NULL)));
    return (code);
}

// The entry point for the C runtime
int main(int argc, char **argv) {
    __global_init_please_dont_call_yourself();
    return __real_main(argc, argv, &maini32PPcri32);
}
