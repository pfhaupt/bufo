import "prelude.bufo";
import "libc.bufo";
import "string.bufo";
import "substr.bufo";
import "../util/span.bufo";
import "../util/lists.bufo";
import "../frontend/context.bufo";
import "../frontend/token.bufo";
import "../frontend/nodes.bufo";
import "./types.bufo";
import "./lookup.bufo";

comptime ERROR_INVALID: usize = 0;
comptime ERROR_LOOKUP_NOT_READY: usize = 1;
comptime ERROR_NO_SUCH_IDENTIFIER: usize = 2;
comptime ERROR_NO_SUCH_FUNCTION: usize = 3;
comptime ERROR_NO_SUCH_METHOD: usize = 4;
comptime ERROR_NO_SUCH_FIELD: usize = 5;
comptime ERROR_USE_BEFORE_DECLARATION: usize = 6;
comptime ERROR_FIELD_COUNT_MISMATCH: usize = 7;

comptime TCSTATE_INVALID: usize = 0;
comptime TCSTATE_ERROR: usize = 1;
comptime TCSTATE_PLEASE_INFER: usize = 2;
comptime TCSTATE_TYPE: usize = 3;
struct TCState {
    kind: usize;
    typ: usize;
    name: Token;

    func equals(&mut this, other: &TCState) -> bool {
        todo_with_msg("TCState.equals");
        return false;
    }

    func isInvalid(&this) -> bool {
        return this.kind == TCSTATE_INVALID;
    }
    func wantsInfer(&mut this) -> bool {
        return this.kind == TCSTATE_PLEASE_INFER;
    }
    func isCriticalError(&mut this) -> bool {
        if (!this.isError()) return false;
        let err: usize = this.getError();
        return err == ERROR_NO_SUCH_IDENTIFIER
            || err == ERROR_NO_SUCH_FUNCTION
            || err == ERROR_NO_SUCH_METHOD
            || err == ERROR_NO_SUCH_FIELD;
    }
    func isError(&mut this) -> bool {
        return this.kind == TCSTATE_ERROR;
    }

    func isSuccess(&mut this) -> bool {
        return this.kind == TCSTATE_TYPE;
    }

    func isType(&mut this) -> bool {
        return this.kind == TCSTATE_TYPE;
    }

    func getType(&mut this) -> usize {
        if (!this.isType()) unsafe {
            fprintf(stderr, "ERROR: TCState.getType() called on non-type TCState with kind=%llu\n", this.kind);
            assert(false);
        }
        return this.typ;
    }
    func getError(&mut this) -> usize {
        if (!this.isError()) unsafe {
            fprintf(stderr, "ERROR: TCState.getError() called on non-error TCState with kind=%llu\n", this.kind);
            assert(false);
        }
        return this.typ;
    }
}

func newTCStateSuccess() -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: 0,
        name: blank,
    };
}

func newTCStateType(typ: usize) -> TCState {
    return TCState {
        kind: TCSTATE_TYPE,
        typ: typ,
        name: blank,
    };
}

func newTCStateFailure(error: usize) -> TCState {
    return TCState {
        kind: TCSTATE_ERROR,
        typ: error,
        name: blank,
    };
}

func newTCStatePleaseInfer() -> TCState {
    return TCState {
        kind: TCSTATE_PLEASE_INFER,
        typ: 0,
        name: blank,
    };
}

struct TypeChecker {
    isComptimeContext: bool;
    currentModule: usize;
    currentFunction: &mut FunctionLookup;
    currentMethod: &mut MethodLookup;
    lookup: Lookup;

    func emergencyPrint(&mut this, where: Span) {
        let t: Token = Token {
            moduleID: this.currentModule,
            span: where,
            content: newSubStrOfStrLit(""),
            kind: TOKEN_EOF
        };
        t.getLocation().print();
        unsafe { printf("\n"); }
    }

    func typeCheckProject(&mut this, project: &mut ParsedModule) -> bool {
        trace("TypeChecker.typeCheckProject");
        if (!this.fillLookup()) return false;
        if (!this.typeCheckModules()) return false;
        if (this.findRecursiveTypes()) return false;
        return true;
    }

    func dfs(&mut this, mut typeLookup: TypeLookup, visited: &mut TypeLookupList, finished: &mut TypeLookupList) -> bool {
        trace("TypeChecker.dfs");
        if (finished.contains(&typeLookup))
            return false;
        if (visited.contains(&typeLookup))
            return true;
        visited.push(typeLookup);
        mut done: bool = false;
        if (typeLookup.isStruct()) {
            let strukt: &mut StructLookup = (&mut typeLookup).asStruct();
            for (mut i: usize = 0; i < strukt.fields.length; i = i + 1) {
                let field: &mut VariableLookup = strukt.fields.at(i);
                assert_with_msg(field.typeState.isSuccess(), "Expected valid field type in DFS");
                let fieldTypeID: usize = field.typeState.getType();
                let fieldType: &mut Type = getTypeByID(fieldTypeID);
                if (fieldType.isStruct()) {
                    let structID: usize = fieldType.typeIndex;
                    let decl: &mut ParsedStructDecl = getStructDeclByID(structID);
                    let mod: &mut ModuleLookup = this.lookup.modules.at(decl.parentModule);
                    let strukt: &mut StructLookup = mod.getStructByGlobalID(structID);
                    if (this.dfs(strukt.asTypeLookup(), visited, finished)) {
                        todo_with_msg("recursive struct found");
                    }
                }
            }
        } else {
            todo_with_msg("dfs on non-struct");
        }
        finished.push(typeLookup);
        return done;
    }

    func findRecursiveTypes(&mut this) -> bool {
        trace("TypeChecker.findRecursiveTypes");
        for (mut i: usize = 0; i < structCount; i = i + 1) {
            let decl: &mut ParsedStructDecl = getStructDeclByID(i);
            let mod: &mut ModuleLookup = this.lookup.modules.at(decl.parentModule);
            let strukt: &mut StructLookup = mod.getStructByGlobalID(i);
            mut visited: TypeLookupList = blank;
            mut finished: TypeLookupList = blank;
            if (this.dfs(strukt.asTypeLookup(), &mut visited, &mut finished)) {
                todo_with_msg("recursive");
            }
        }
        return false;
    }

    func fillLookup(&mut this) -> bool {
        trace("TypeChecker.fillLookup");
        for (mut i: usize = 0; i < moduleCount; i = i + 1) {
            let mod: &mut ParsedModule = getModuleByID(i);
            assert(mod.getID() == i);
            this.currentModule = i;
            let lookup: &mut ModuleLookup = this.lookup.insertModule(mod);
            for (mut j: usize = 0; j < mod.tliLength; j = j + 1) unsafe {
                let tliID: usize = mod.getTopLevelItemAtIndex(j);
                let tli: &mut ParsedTopLevelItem = getTopLevelItemByID(tliID);
                lookup.insertTLI(tli);
            }
        }
        return true;
    }

    func typeCheckModules(&mut this) -> bool {
        trace("TypeChecker.typeCheckModules");
        mut done: bool = false;
        while (!done) {
            done = true;
            for (mut i: usize = 0; i < moduleCount; i = i + 1) {
                let mod: &mut ParsedModule = getModuleByID(i);
                assert(mod.getID() == i);
                this.currentModule = i;
                let currModule: &mut ModuleLookup = this.lookup.modules.at(i);
                assert_with_msg(currModule.variables.length == 1, "still deez");
                for (mut j: usize = 0; j < mod.tliLength; j = j + 1) unsafe {
                    let tliID: usize = mod.getTopLevelItemAtIndex(j);
                    let tli: &mut ParsedTopLevelItem = getTopLevelItemByID(tliID);
                    if (tli.typeState.isSuccess()) continue;
                    mut state: TCState = this.typeCheckTLI(tli);
                    (*tli).typeState = state;
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) {
                            done = false;
                            // break;
                        } else if (state.isCriticalError()) {
                            // We can't continue here
                            return false;
                        } else {
                            printf("%llu\n", err);
                            todo_with_msg("other error");
                        }
                    }
                }
            }
        }
        return true;
    }

    func typeCheckTLI(&mut this, tli: &mut ParsedTopLevelItem) -> TCState {
        trace("TypeChecker.typeCheckTLI");
        unsafe { this.currentFunction = null; }
        unsafe { this.currentMethod = null; }
        let currentModule: &mut ModuleLookup = this.lookup.modules.at(this.currentModule);
        assert_with_msg(currentModule.variables.length == 1, "expected to find only the global scope for TLI VarDecl");
        if (tli.kind == TLI_IMPORT) {
            return newTCStateSuccess();
        } else if (tli.kind == TLI_FUNC_DECL) {
            return this.typeCheckFunction(tli.nodeID, &mut currentModule.variables);
        } else if (tli.kind == TLI_STRUCT_DECL) {
            return this.typeCheckStructDecl(tli.nodeID);
        } else if (tli.kind == TLI_VAR_DECL) {
            return this.typeCheckVarDecl(tli.nodeID, &mut currentModule.variables, true);
        } else {
            todo_with_msg("unknown TLI");
        }
        unreachable("Exhaustive handling of TLI in typeCheckTLI");
        return blank;
    }

    func typeCheckStructDecl(&mut this, structID: usize) -> TCState {
        trace("TypeChecker.typeCheckStructDecl");
        let strukt: &mut ParsedStructDecl = getStructDeclByID(structID);
        let moduleLookup: &mut ModuleLookup = this.lookup.modules.at(this.currentModule);
        let structLookup: &mut StructLookup = moduleLookup.getStructByGlobalID(structID);
        let context: &mut StructContext = &mut strukt.context;
        mut result: TCState = newTCStateSuccess();
        if (!structLookup.getReadyState(STRUCT_READY_TO_USE)) {
            if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE)) {
                mut failure: TCState = blank;
                for (mut i: usize = 0; i < context.fieldLength; i = i + 1) {
                    let name: Token = context.getFieldNameAtIndex(i);
                    let typ: usize = context.getFieldTypeAtIndex(i);
                    if (structLookup.checkForDuplicateField(&name)) {
                        this.emergencyPrint(name.span);
                        todo_with_msg("duplicate field");
                    }
                    mut state: TCState = this.typeCheckTypeNode(typ, &mut moduleLookup.variables);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    structLookup.addField(64000 + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                structLookup.setReadyState(STRUCT_FIELDS_COMPLETE);
            }
            if (!structLookup.getReadyState(STRUCT_SIGNATURE_COMPLETE)) {
                mut lookup: bool = false;
                mut error: usize = 0;
                for (mut i: usize = 0; i < context.methodLength; i = i + 1) {
                    let methodID: usize = context.getMethodAtIndex(i);
                    mut state: TCState = this.typeCheckMethod(structID, methodID, true);
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) lookup = true;
                        if (state.isCriticalError()) error = err;
                    }
                    // Don't need to do anything with the StructLookup here because typeCheckMethod
                    // already updates MethodLookup accordingly
                }
                if (error != ERROR_INVALID) return newTCStateFailure(error);
                if (lookup) return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                structLookup.setReadyState(STRUCT_SIGNATURE_COMPLETE);
            }
            if (!structLookup.getReadyState(STRUCT_METHODS_COMPLETE)) {
                mut lookup: bool = false;
                for (mut i: usize = 0; i < context.methodLength; i = i + 1) {
                    let methodID: usize = context.getMethodAtIndex(i);
                    mut state: TCState = this.typeCheckMethod(structID, methodID, false);
                    if (state.isError()) {
                        let err: usize = state.getError();
                        if (err == ERROR_LOOKUP_NOT_READY) lookup = true;
                        if (state.isCriticalError()) return state;
                    }
                }
                if (lookup) return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                structLookup.setReadyState(STRUCT_METHODS_COMPLETE);
            }
            structLookup.setReadyState(STRUCT_READY_TO_USE);
        }
        (*strukt).typeState = newTCStateSuccess();
        return result;
    }

    func typeCheckMethod(&mut this, structID: usize, methodID: usize, onlySignature: bool) -> TCState {
        trace("TypeChecker.typeCheckMethod");
        // REVIEW: We can improve performance by passing the StructLookup instead of the ID
        let method: &mut ParsedMethod = getMethodByID(methodID);
        let moduleLookup: &mut ModuleLookup = this.lookup.modules.at(this.currentModule);
        let structLookup: &mut StructLookup = moduleLookup.getStructByGlobalID(structID);
        let methodLookup: &mut MethodLookup = structLookup.getMethodByGlobalID(methodID);
        if (method.typeState.isSuccess()) {
            assert_with_msg(methodLookup.getReadyState(METHOD_READY_TO_USE), "Method should be ready to use at this point");
            return method.typeState;
        }
        this.currentMethod = methodLookup;
        if (!methodLookup.getReadyState(METHOD_READY_TO_USE)) {
            if (!methodLookup.getReadyState(METHOD_PARAMS_COMPLETE)) {
                mut failure: TCState = blank;
                for (mut i: usize = 0; i < method.params.paramLength; i = i + 1) {
                    let typ: usize = method.params.getTypeAtIndex(i);
                    let name: Token = method.params.getNameAtIndex(i);
                    if (methodLookup.checkForDuplicateParam(&name)) {
                        todo_with_msg("duplicate param");
                    }
                    mut state: TCState = this.typeCheckTypeNode(typ, &mut moduleLookup.variables);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    methodLookup.addParameter(64000 + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                methodLookup.setReadyState(METHOD_PARAMS_COMPLETE);
            }
            if (!methodLookup.getReadyState(METHOD_RETTYPE_COMPLETE)) {
                mut retState: TCState = this.typeCheckTypeNode(method.retTypeID, &mut moduleLookup.variables);
                if (retState.isError()) return retState;
                methodLookup.setReturnType(retState);
                methodLookup.setReadyState(METHOD_RETTYPE_COMPLETE);
            }
            methodLookup.setReadyState(METHOD_READY_TO_USE);
        }
        if (onlySignature) {
            assert_with_msg(methodLookup.getReadyState(METHOD_READY_TO_USE), "expected method to be ready for use after checking signature");
            return newTCStateSuccess();
        }
        if (!methodLookup.getReadyState(METHOD_BODY_COMPLETE)) {
            mut scopes: ScopeLookupList = blank;
            mut scope: ScopeLookup = blank;
            for (mut i: usize = 0; i < methodLookup.params.length; i = i + 1) {
                scope.addVariable(*(methodLookup.params.at(i)));
            }
            scopes.push(scope);
            mut blockState: TCState = this.typeCheckBlock(method.body, &mut scopes);
            scopes.pop();
            if (blockState.isError()) return blockState;
            methodLookup.setReadyState(METHOD_BODY_COMPLETE);
        }
        (*method).typeState = newTCStateSuccess();
        return method.typeState;
    }

    func typeCheckFunction(&mut this, funcID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckFunction");
        let function: &mut ParsedFuncDecl = getFuncDeclByID(funcID);
        let moduleLookup: &mut ModuleLookup = this.lookup.modules.at(this.currentModule);
        let funcLookup: &mut FunctionLookup = moduleLookup.getFunctionByGlobalID(funcID);
        if (function.typeState.isSuccess()) {
            assert_with_msg(funcLookup.getReadyState(FUNC_READY_TO_USE), "Function should be ready to use at this point");
            return function.typeState;
        }
        this.currentFunction = funcLookup;
        if (!funcLookup.getReadyState(FUNC_READY_TO_USE)) {
            if (!funcLookup.getReadyState(FUNC_PARAMS_COMPLETE)) {
                mut failure: TCState = blank;
                for (mut i: usize = 0; i < function.params.paramLength; i = i + 1) {
                    let typ: usize = function.params.getTypeAtIndex(i);
                    let name: Token = function.params.getNameAtIndex(i);
                    if (funcLookup.checkForDuplicateParam(&name)) {
                        todo_with_msg("duplicate param");
                    }
                    mut state: TCState = this.typeCheckTypeNode(typ, &mut moduleLookup.variables);
                    if (state.isError()) {
                        failure = state;
                        continue;
                    }
                    funcLookup.addParameter(64000 + i, name, state);
                }
                if (!failure.isInvalid()) return failure;
                funcLookup.setReadyState(FUNC_PARAMS_COMPLETE);
            }
            if (!funcLookup.getReadyState(FUNC_RETTYPE_COMPLETE)) {
                mut retState: TCState = this.typeCheckTypeNode(function.retTypeID, &mut moduleLookup.variables);
                if (retState.isError()) return retState;
                funcLookup.setReturnType(retState);
                funcLookup.setReadyState(FUNC_RETTYPE_COMPLETE);
            }
            funcLookup.setReadyState(FUNC_READY_TO_USE);
        }
        if (!funcLookup.getReadyState(FUNC_BODY_COMPLETE)) {
            mut scope: ScopeLookup = blank;
            for (mut i: usize = 0; i < funcLookup.params.length; i = i + 1) {
                scope.addVariable(*(funcLookup.params.at(i)));
            }
            if (!function.isExtern) {
                scopes.push(scope);
                mut blockState: TCState = this.typeCheckBlock(function.body, scopes);
                scopes.pop();
                if (blockState.isError()) {
                    return blockState;
                }
            }
            funcLookup.setReadyState(FUNC_BODY_COMPLETE);
        }
        (*function).typeState = newTCStateSuccess();
        return function.typeState;
    }

    func typeCheckBlock(&mut this, blockID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckBlock");
        let block: &mut ParsedBlock = getBlockByID(blockID);
        if (block.typeState.isSuccess()) {
            return block.typeState;
        }
        scopes.push(ScopeLookup {
            variables: blank,
        });
        let curr: usize = scopes.length;
        // REVIEW: Do we want to make blocks expressions?
        mut blockState: TCState = newTCStateSuccess();
        for (mut i: usize = 0; i < block.stmtLength; i = i + 1) {
            mut stmtState: TCState = this.typeCheckStmt(block.getStmtAtIndex(i), scopes);
            if (stmtState.isError()) {
                let err: usize = stmtState.getError();
                if (err == ERROR_LOOKUP_NOT_READY) {
                    blockState = stmtState;
                    break;
                } else if (stmtState.isCriticalError()) {
                    blockState = stmtState;
                } else {
                    todo_with_msg("block stmt err");
                }
            }
        }
        let after: usize = scopes.length;
        scopes.pop();
        assert_with_msg(after == curr, "Stack imbalance");
        if (blockState.isError()) return blockState;
        (*block).typeState = newTCStateSuccess();
        return block.typeState;
    }

    func typeCheckStmt(&mut this, stmtID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckStmt");
        let stmt: &mut ParsedStmt = getStmtByID(stmtID);
        if (stmt.kind == STMT_BLOCK) {
            mut blockState: TCState = this.typeCheckBlock(stmt.block, scopes);
            if (blockState.isError()) return blockState;
            (*stmt).typeState = blockState;
            return blockState;
        } else if (stmt.kind == STMT_VAR_DECL) {
            return this.typeCheckVarDecl(stmtID, scopes, false);
        } else if (stmt.kind == STMT_EXPR) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            mut exprState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            if (exprState.isError()) return exprState;
            if (exprState.wantsInfer()) todo_with_msg("stmt expr infer");
            let expr: &mut ParsedExpr = getExprByID(stmt.expr);
            if (!exprState.isType()) unsafe {
                printf("%llu\n", exprState.kind);
                todo_with_msg("what is it then");
            }
            let exprType: &mut Type = getTypeByID(exprState.getType());
            if (!exprType.isNone() && !expr.isAssignment()) unsafe {
                mut loc: String = this.lookup.modules.at(this.currentModule).origin.toString();
                loc.pushChar(':');
                let _s: String = expr.span.toString();
                loc.pushString(&_s);
                fprintf(stderr, "%s: %s: Unused expression value.\n", loc.chars(), WARN_STR);
                _s.drop();
                loc.drop();
            }
            (*stmt).typeState = exprState;
            return newTCStateSuccess();
        } else if (stmt.kind == STMT_IF) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            mut condState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            mut thenState: TCState = this.typeCheckStmt(stmt.ifContext.thenBody, scopes);
            mut elseState: TCState = newTCStateSuccess();
            if (stmt.ifContext.hasElse) {
                elseState = this.typeCheckStmt(stmt.ifContext.elseBody, scopes);
            }
            if (condState.isError()) return condState;
            if (thenState.isError()) return thenState;
            if (elseState.isError()) return elseState;
            let condType: &mut Type = getTypeByID(condState.getType());
            if (!condType.isBoolean()) todo_with_msg("if cond not bool");
            let state: TCState = newTCStateSuccess();
            (*stmt).typeState = state;
            return state;
        } else if (stmt.kind == STMT_RETURN_EXPR) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            mut exprState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            if (exprState.isError()) return exprState;
            unsafe {
                if (this.currentFunction != null) {
                    assert_with_msg(this.currentFunction.getReadyState(FUNC_READY_TO_USE), "Function is not ready");
                    let _retType: &mut Type = getTypeByID(this.currentFunction.returnType.getType());
                    if (_retType.isNone()) todo_with_msg("unexpected ret expr where empty function");
                    let retState: &mut TCState = &mut this.currentFunction.returnType;
                    assert_with_msg(retState.isSuccess(), "ready to use function has invalid return type");
                    assert_with_msg(retState.isType(), "ready to use function has non-type as return type");
                    if (exprState.wantsInfer()) {
                        exprState = this.inferTypeOntoExpr(stmt.expr, retState.getType());
                        if (exprState.isError()) return exprState;
                        assert_with_msg(exprState.isType(), "Failed to infer type of return expression");
                    }
                    let exprType: &mut Type = getTypeByID(exprState.getType());
                    let retType: &mut Type = getTypeByID(retState.getType());
                    if (!exprType.equals(retType)) {
                        todo_with_msg("return expr type mismatch");
                    }
                    (*stmt).typeState = *retState;
                    return newTCStateSuccess();
                } else if (this.currentMethod != null) {
                    assert_with_msg(this.currentMethod.getReadyState(METHOD_READY_TO_USE), "Method is not ready");
                    let _retType: &mut Type = getTypeByID(this.currentMethod.returnType.getType());
                    if (_retType.isNone()) todo_with_msg("unexpected ret expr where empty method");
                    let retState: &mut TCState = &mut this.currentMethod.returnType;
                    assert_with_msg(retState.isSuccess(), "ready to use method has invalid return type");
                    assert_with_msg(retState.isType(), "ready to use method has non-type as return type");
                    if (exprState.wantsInfer()) {
                        exprState = this.inferTypeOntoExpr(stmt.expr, retState.getType());
                        if (exprState.isError()) return exprState;
                        assert_with_msg(exprState.isType(), "Failed to infer type of return expression");
                    }
                    let exprType: &mut Type = getTypeByID(exprState.getType());
                    let retType: &mut Type = getTypeByID(retState.getType());
                    if (!exprType.equals(retType)) {
                        todo_with_msg("return expr type mismatch");
                    }
                    (*stmt).typeState = *retState;
                    return newTCStateSuccess();
                } else {
                    unreachable("Expected to be either in a method or function, got none of both");
                }
            }
            todo_with_msg("return expr");
        } else if (stmt.kind == STMT_RETURN_EMPTY) {
            unsafe {
                if (this.currentFunction != null) {
                    assert_with_msg(this.currentFunction.getReadyState(FUNC_READY_TO_USE), "Function is not ready");
                    let retType: &mut Type = getTypeByID(this.currentFunction.returnType.getType());
                    if (!retType.isNone()) todo_with_msg("function returns something, but we wrote return;");
                    (*stmt).typeState = newTCStateSuccess();
                    return newTCStateSuccess();
                } else if (this.currentMethod != null) {
                    assert_with_msg(this.currentMethod.getReadyState(METHOD_READY_TO_USE), "Method is not ready");
                    let retType: &mut Type = getTypeByID(this.currentMethod.returnType.getType());
                    if (!retType.isNone()) todo_with_msg("method returns something, but we wrote return;");
                    (*stmt).typeState = newTCStateSuccess();
                    return newTCStateSuccess();
                } else {
                    unreachable("Expected to be either in a method or function, got none of both");
                }
            }
        } else if (stmt.kind == STMT_WHILE) {
            if (stmt.typeState.isSuccess())
                return stmt.typeState;
            mut condState: TCState = this.typeCheckExpr(stmt.expr, scopes);
            mut bodyState: TCState = this.typeCheckStmt(stmt.block, scopes);
            mut stepState: TCState = this.typeCheckExpr(stmt.step, scopes);
            if (condState.isError()) return condState;
            if (bodyState.isError()) return bodyState;
            if (stepState.isError()) return stepState;
            if (condState.wantsInfer()) todo_with_msg("while cond infer");
            if (stepState.wantsInfer()) todo_with_msg("while step infer");
            let condTypeID: usize = condState.getType();
            let condType: &mut Type = getTypeByID(condTypeID);
            if (!condType.isBoolean()) todo_with_msg("while condition must be bool");
            (*stmt).typeState = newTCStateSuccess();
            return newTCStateSuccess();
        } else if (stmt.kind == STMT_BREAK || stmt.kind == STMT_CONTINUE) {
            (*stmt).typeState = newTCStateSuccess();
            return newTCStateSuccess();
        } else {
            this.emergencyPrint(stmt.span);
            todo_with_msg("unknown stmt");
        }
        unreachable("Exhaustive handling of stmts in typeCheckStmt");
        return blank;
    }

    func typeCheckVarDecl(&mut this, varDeclID: usize, scopes: &mut ScopeLookupList, globalScope: bool) -> TCState {
        trace("TypeChecker.typeCheckVarDecl");
        let varDecl: &mut ParsedStmt = getStmtByID(varDeclID);
        assert_with_msg(varDecl.kind == STMT_VAR_DECL, "Stmt expected to be a VarDecl");
        let context: VarDeclContext = varDecl.varDeclContext;
        let last: &mut ScopeLookup = scopes.last();
        if (varDecl.typeState.isSuccess()) {
            if (globalScope) todo_with_msg("cached var decl global scope");
            last.addVariable(VariableLookup {
                globalID: varDecl.getID(),
                name: context.name,
                typeState: varDecl.typeState,
                isComptime: context.isComptime,
            });
            return varDecl.typeState;
        }
        mut loc: Token = blank;
        // REVIEW: Warn about shadowing?
        if (!globalScope && last.isKnownVariable(context.name.content, &mut loc)) unsafe {
            printf("%llu\n", varDecl.kind);
            context.name.getLocation().print();
            loc.getLocation().print();
            todo_with_msg("variable redecl");
        }
        mut typeState: TCState = blank;
        if (context.typeID != TYPE_INVALID) {
            typeState = this.typeCheckTypeNode(context.typeID, scopes);
            if (typeState.isError()) return typeState;
            if (!typeState.isType()) todo_with_msg("let type is not a type");
        }
        this.isComptimeContext = context.isComptime;
        mut exprState: TCState = this.typeCheckExpr(context.exprID, scopes);
        this.isComptimeContext = false;
        if (exprState.isError()) {
            return exprState;
        }
        if (context.typeID == TYPE_INVALID) {
            // let var = expr;
            assert_with_msg(typeState.isInvalid(), "`let var = expr;` got valid type state??");
            if (exprState.wantsInfer()) {
                todo_with_msg("`let var = expr;` wants inferred expr");
            }
            if (!exprState.isType()) todo_with_msg("let expr is not a type");
            typeState = exprState;
        } else {
            // let var: type = expr;
            if (exprState.wantsInfer()) {
                exprState = this.inferTypeOntoExpr(context.exprID, typeState.getType());
            }
            if (!exprState.isType()) todo_with_msg("let expr is not a type");
            let typeType: &mut Type = getTypeByID(typeState.getType());
            let exprType: &mut Type = getTypeByID(exprState.getType());
            if (!typeType.equals(exprType)) unsafe {
                printf("%llu %llu\n", typeType.kind, exprType.kind);
                printf("%llu %llu\n", typeType.typeIndex, exprType.typeIndex);
                this.emergencyPrint(varDecl.span);
                this.emergencyPrint(getExprByID(context.exprID).span);
                this.emergencyPrint(context.name.span);
                todo_with_msg("var decl type mismatch");
            }
        }
        if (globalScope) {
            mut index: usize = 0;
            assert_with_msg(last.getVarIndexByName(context.name.content, &mut index), "Could not find variable in global scope");
            let var: &mut VariableLookup = last.getVariableAtIndex(index);
            assert_with_msg(var.typeState.isInvalid(), "Global variable was not invalid");
            (*var).typeState = typeState;
        } else unsafe {
            last.addVariable(VariableLookup {
                globalID: varDecl.getID(),
                name: context.name,
                typeState: typeState,
                isComptime: context.isComptime,
            });
        }
        (*varDecl).typeState = exprState;
        return exprState;
    }

    func typeCheckExpr(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExpr");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        if (expr.typeState.isSuccess()) return expr.typeState;
        mut state: TCState = blank;
        if (expr.kind == EXPR_EMPTY) {
            state = newTCStateSuccess();
        } else if (expr.kind == EXPR_INT_LIT) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_STRING_LIT) {
            let ct: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
            let st: &mut Type = newType(TYPE_KIND_POINTER, ct.getID());
            state = newTCStateType(st.getID());
        } else if (expr.kind == EXPR_CHAR_LIT) {
            let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_CHAR);
            state = newTCStateType(t.getID());
        } else if (expr.kind == EXPR_ARRAY_LIT) {
            let context: &mut ArrayContext = &mut expr.arrayContext;
            assert_with_msg(context.elemLength != 0, "Zero sized Array Literal spotted");
            let elemIndex: usize = context.getElementAtIndex(0);
            mut elemState: TCState = this.typeCheckExpr(elemIndex, scopes);
            if (elemState.isError()) return elemState;
            if (elemState.wantsInfer()) return elemState;
            let elemTypeID: usize = elemState.getType();
            if (context.size == 0) {
                let elemType: &mut Type = getTypeByID(elemTypeID);
                for (mut i: usize = 1; i < context.elemLength; i = i + 1) {
                    let nextIndex: usize = context.getElementAtIndex(i);
                    mut nextState: TCState = this.typeCheckExpr(nextIndex, scopes);
                    if (nextState.isError()) return nextState;
                    let nextType: &mut Type = getTypeByID(nextState.getType());
                    if (!nextType.equals(elemType)) {
                        todo_with_msg("array elem type mismatch");
                    }
                }
                let t: &mut Type = newType(TYPE_KIND_ARRAY, elemTypeID);
                (*t).arraySize = context.elemLength;
                state = newTCStateType(t.getID());
            } else {
                let t: &mut Type = newType(TYPE_KIND_ARRAY, elemTypeID);
                (*t).arraySize = context.size;
                state = newTCStateType(t.getID());
            }
        } else if (expr.kind == EXPR_NAME) {
            state = this.typeCheckIdentifier(exprID, scopes);
        } else if (expr.kind == EXPR_UNARY) {
            state = this.typeCheckUnary(exprID, scopes);
        } else if (expr.kind == EXPR_BINARY) {
            state = this.typeCheckExprBinary(exprID, scopes);
        } else if (expr.kind == EXPR_CALL) {
            state = this.typeCheckExprCall(exprID, scopes);
        } else if (expr.kind == EXPR_SIZEOF) {
            state = this.typeCheckExprSizeof(exprID, scopes);
        } else if (expr.kind == EXPR_STRUCT_INIT) {
            state = this.typeCheckExprStructInit(exprID, scopes);
        } else if (expr.kind == EXPR_AS) {
            state = this.typeCheckExprAs(exprID, scopes);
        } else if (expr.kind == EXPR_NULL) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_BLANK) {
            state = newTCStatePleaseInfer();
        } else if (expr.kind == EXPR_TRUE || expr.kind == EXPR_FALSE) {
            let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
            state = newTCStateType(t.getID());
        } else {
            todo_with_msg("unexpected expr kind");
        }
        (*expr).typeState = state;
        return state;
    }

    func typeCheckExprSizeof(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprSizeof");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        if (expr.typeState.isSuccess()) return expr.typeState;
        assert(expr.kind == EXPR_SIZEOF);
        mut typeState: TCState = this.typeCheckTypeNode(expr.lhs, scopes);
        if (typeState.isError()) return typeState;
        let ut: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
        return newTCStateType(ut.getID());
    }

    func typeCheckExprAs(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprAs");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        assert(expr.kind == EXPR_AS);
        mut exprState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut typeState: TCState = this.typeCheckTypeNode(expr.rhs, scopes);
        if (exprState.isError()) return exprState;
        if (typeState.isError()) return typeState;
        let exprType: &mut Type = getTypeByID(exprState.getType());
        let typeType: &mut Type = getTypeByID(typeState.getType());
        if (typeType.isPointer() && exprType.isPointer()) {
            // PTR as PTR is allowed
        } else if (exprType.isPointer() && typeType.isInteger()) {
            // PTR as INT is allowed if INT is pointer-sized
            if (typeType.getSize() != exprType.getSize()) {
                todo_with_msg("PTR as INT with sizeof(INT) < sizeof(PTR)");
            }
        } else if (exprType.isInteger() && typeType.isPointer()) {
            // INT as PTR is allowed if INT is pointer-sized
            if (typeType.getSize() != exprType.getSize()) {
                todo_with_msg("INT as PTR with sizeof(INT) < sizeof(PTR)");
            }
        } else if (!typeType.isPrimitive()) {
            this.emergencyPrint(expr.span);
            todo_with_msg("as target is not primitive");
        } else if (!exprType.isPrimitive()) {
            todo_with_msg("as source is not primitive");
        }
        return typeState;
    }

    func typeCheckUnary(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckUnary");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        assert(expr.kind == EXPR_UNARY);
        mut exprState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        if (exprState.isError()) return exprState;
        if (exprState.wantsInfer()) return exprState; // Can't be done in here
        if (expr.op == UNARY_DEREF) {
            let exprType: &mut Type = getTypeByID(exprState.getType());
            if (exprType.isPrimitive()) {
                if (exprType.typeIndex == TYPE_ANY) {
                    return newTCStatePleaseInfer();
                }
            }
            if (!exprType.isPointer()) {
                todo_with_msg("deref non-pointer");
            }
            let underlying: &mut Type = exprType.getUnderlyingType(false);
            return newTCStateType(underlying.getID());
        } else if (expr.op == UNARY_REF) {
            let exprType: &mut Type = getTypeByID(exprState.getType());
            let t: &mut Type = newType(TYPE_KIND_POINTER, exprType.getID());
            return newTCStateType(t.getID());
        } else if (expr.op == UNARY_NOT) {
            let exprType: &mut Type = getTypeByID(exprState.getType());
            if (!exprType.isBoolean()) unsafe {
                let loc: String = expr.span.toString();
                fprintf(stderr, "%: %s:\n", loc.chars(), ERR_STR);
                loc.drop();
                todo_with_msg("unary not non-boolean");
            }
            return exprState;
        } else if (expr.op == UNARY_MINUS) {
            let exprType: &mut Type = getTypeByID(exprState.getType());
            if (!exprType.isSignedInteger()) {
                todo_with_msg("unary minus for non-integer or unsigned integers is not defined");
            }
            return exprState;
        } else {
            unreachable("Exhaustive handling of ops in typeCheckUnary");
            return blank;
        }
    }

    func typeCheckExprCall(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprCall");
        // REVIEW: Would be cool if the call base could be any expression, not just an identifier
        let expr: &mut ParsedExpr = getExprByID(exprID);
        assert(expr.kind == EXPR_CALL);
        let name: Token = expr.origToken;
        mut functions: FunctionLookupList = this.lookup.resolveFunctionByName(this.currentModule, &name);
        if (functions.length == 0) unsafe {
            let loc: String = name.getLocation();
            let n: String = name.content.toString();
            fprintf(stderr, "%s: %s: Call to unknown function `%s`.\n", loc.chars(), ERR_STR, n.chars());
            mut alternatives: FunctionLookupList = this.lookup.searchAllModulesForFunctionName(&name);
            for (mut i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &mut FunctionLookup = &mut *alternatives.at(i);
                let loc: String = t.name.getLocation();
                fprintf(stderr, "%s: %s: A function with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                loc.drop();
            }
            n.drop();
            loc.drop();
            return newTCStateFailure(ERROR_NO_SUCH_FUNCTION);
        }
        let callContext: &mut ArrayContext = &mut expr.arrayContext;
        mut arguments: TCStateList = blank;
        for (mut i: usize = 0; i < callContext.elemLength; i = i + 1) {
            let argID: usize = callContext.getElementAtIndex(i);
            mut arg: TCState = this.typeCheckExpr(argID, scopes);
            if (arg.isError()) return arg;
            arguments.push(arg);
        }
        assert(arguments.length == callContext.elemLength);
        for (mut i: usize = 0; i < functions.length; i = i + 1) {
            let f: &mut FunctionLookup = &mut *(functions.at(i));
            if (!f.getReadyState(FUNC_READY_TO_USE)) {
                return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
            }
            if (!f.isVarArg && f.params.length != arguments.length) {
                continue;
            }
            for (mut j: usize = 0; j < f.params.length; j = j + 1) {
                let argState: &mut TCState = &mut *arguments.at(j);
                let param: &mut VariableLookup = f.params.at(j);
                let paramState: &mut TCState = &mut param.typeState;
                assert_with_msg(paramState.isSuccess(), "Expected valid function parameter");
                let paramType: &mut Type = getTypeByID(paramState.getType());
                if (argState.wantsInfer()) {
                    let old: TCState = *argState;
                    *argState = this.inferTypeOntoExpr(callContext.getElementAtIndex(j), paramType.getID());
                    if (argState.isError()) {
                        *argState = old;
                        todo_with_msg("error when inferring type of param onto argument");
                    }
                    assert_with_msg(argState.isType(), "Did not infer type of param onto argument properly");
                }
                let argType: &mut Type = getTypeByID(argState.getType());
                if (!argType.equals(paramType)) {
                    todo_with_msg("function arg mismatch");
                }
            }
            // By this point, `f` fits all criteria for being called
            // REVIEW: Do we want to make Overload selection smarter? Right now we only
            //         pick the first match
            (*expr).lhs = f.globalID;
            mut retType: TCState = f.returnType;
            assert_with_msg(retType.isSuccess(), "Expected valid function return type");
            return retType;
        }
        this.emergencyPrint(expr.span);
        todo_with_msg("do stuff with call");
        todo_with_msg("EXPR_CALL");
        return blank;
    }

    func typeCheckExprStructInit(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        // REVIEW: This function will later also do union declarations
        trace("TypeChecker.typeCheckExprStructInit");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        assert(expr.kind == EXPR_STRUCT_INIT);
        let name: Token = expr.origToken;
        mut lookup: TypeLookup = blank;
        if (!this.lookup.resolveTypeByName(this.currentModule, &name, &mut lookup)) unsafe {
            let loc: String = name.getLocation();
            let _n: String = name.content.toString();
            fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.chars(), ERR_STR, _n.chars());
            mut alternatives: TypeLookupList = this.lookup.searchAllModulesForTypeName(&name);
            for (mut i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &mut TypeLookup = &mut *alternatives.at(i);
                if (t.isStruct()) {
                    let s: &mut StructLookup = t.asStruct();
                    let loc: String = s.name.getLocation();
                    fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                    loc.drop();
                }
            }
            _n.drop();
            loc.drop();
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (lookup.isStruct()) {
            let context: &mut StructInitContext = &mut expr.structInitContext;
            let structLookup: &mut StructLookup = &mut *lookup.asStruct();
            if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE))
                return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
            if (structLookup.fields.length != context.fieldLength) unsafe {
                let loc: String = name.getLocation();
                fprintf(stderr, "%s: %s: Expected %llu fields in initialization, got %llu.\n", loc.chars(), ERR_STR, structLookup.fields.length, context.fieldLength);
                loc.drop();
                return newTCStateFailure(ERROR_FIELD_COUNT_MISMATCH);
            }
            mut hits: usize = 0;
            assert_with_msg(structLookup.fields.length < 50, "Sorry, I need to hack this for now");
            for (mut i: usize = 0; i < context.fieldLength; i = i + 1) {
                let name: Token = context.getFieldNameAtIndex(i);
                let exprID: usize = context.getFieldExprAtIndex(i);
                mut exprState: TCState = this.typeCheckExpr(exprID, scopes);
                if (exprState.isError()) return exprState;
                let fieldIndex: usize = structLookup.getIndexByName(&name);
                let bit: usize = shiftLeft(1, fieldIndex);
                if ((hits & bit) != 0) {
                    todo_with_msg("duplicate field");
                } else {
                    hits = hits | bit;
                }
                let field: &mut VariableLookup = structLookup.fields.at(fieldIndex);
                let fieldState: &mut TCState = &mut field.typeState;
                assert_with_msg(fieldState.isSuccess(), "Struct is ready to go, but field type is invalid?");
                assert_with_msg(name.content.equals(&field.name.content), "Seems like my hack doesn't work");
                let fieldType: &mut Type = getTypeByID(fieldState.getType());
                if (exprState.wantsInfer())
                    exprState = this.inferTypeOntoExpr(exprID, fieldType.getID());
                let exprType: &mut Type = getTypeByID(exprState.getType());
                if (!fieldType.equals(exprType)) unsafe {
                    this.emergencyPrint(expr.span);
                    todo_with_msg("field type mismatch");
                }
            }
            return newTCStateType(structLookup.typeID);
        } else {
            todo_with_msg("struct init but it's not a struct?");
            return blank;
        }
    }

    func typeCheckIdentifier(&mut this, exprID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckIdentifier");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        assert(expr.kind == EXPR_NAME);
        let name: Token = expr.origToken;
        mut var: VariableLookup = blank;
        if (!this.lookup.resolveVariableByName(this.currentModule, &name, scopes, &mut var)) unsafe {
            let loc: String = name.getLocation();
            let _name: String = name.content.toString();
            fprintf(stderr, "%s: %s: Use of undeclared identifier `%s`.\n", loc.chars(), ERR_STR, _name.chars());
            mut alternatives: VariableLookupList = this.lookup.searchAllModulesForIdentifier(&name);
            for (mut i: usize = 0; i < alternatives.length; i = i + 1) {
                let t: &mut VariableLookup = &mut *alternatives.at(i);
                let loc: String = t.name.getLocation();
                fprintf(stderr, "%s: %s: A variable with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                loc.drop();
            }
            _name.drop();
            loc.drop();
            return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
        }
        if (this.isComptimeContext && !var.isComptime) {
            todo_with_msg("shit my pants");
        }
        mut state: TCState = var.typeState;
        if (state.isInvalid()) unsafe {
            return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
        }
        if (state.isError()) return state;
        assert(expr.op == 0);
        mut _loc: Token = blank;
        if (scopes.at(0).isKnownVariable(name.content, &mut _loc)) {
            (*expr).op = 1;
        }
        (*expr).lhs = var.globalID;
        (*expr).typeState = state;
        return state;
    }

    func typeCheckExprBinary(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprBinary");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert_with_msg(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        if (expr.op == BIN_DOT) {
            return this.typeCheckExprMemberAccess(binID, scopes);
        } else if (expr.op == BIN_ASSIGN) {
            return this.typeCheckExprAssign(binID, scopes);
        } else if (expr.op == BIN_INDEXED_ACCESS) {
            return this.typeCheckExprIndexedAccess(binID, scopes);
        } else if (expr.isArithmetic()) {
            return this.typeCheckExprArithmetic(binID, scopes);
        } else if (expr.isComparison()) {
            return this.typeCheckExprComparison(binID, scopes);
        } else if (expr.isLogical()) {
            return this.typeCheckExprLogical(binID, scopes);
        } else if (expr.isBitwise()) {
            return this.typeCheckExprBitwise(binID, scopes);
        } else {
            this.emergencyPrint(expr.span);
            todo_with_msg("EXPR_BINARY");
        }
        unreachable("Exhaustive handling of ops in typeCheckExprBinary");
        return blank;
    }

    func typeCheckExprIndexedAccess(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprIndexedAccess");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_INDEXED_ACCESS);
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        if (!lhsState.isType()) todo_with_msg("indexed access, original LHS is not a type");
        let lhsTypeID: usize = lhsState.getType();
        let lhsType: &mut Type = getTypeByID(lhsTypeID);
        // REVIEW: Support for indexing pointers would be cool
        if (lhsType.isPointer()) todo_with_msg("indexed access, LHS is a pointer");
        if (!lhsType.isArray()) todo_with_msg("indexed access, LHS is not an array");
        if (rhsState.wantsInfer())
            rhsState = this.inferTypeOntoExpr(expr.rhs, TYPE_USIZE);
        if (!rhsState.isType()) todo_with_msg("indexex access, could not infer type to RHS");
        let rhsTypeID: usize = rhsState.getType();
        let rhsType: &mut Type = getTypeByID(rhsTypeID);
        // FIXME: Put those into a single check
        if (!rhsType.isPrimitive()) todo_with_msg("indexed access, RHS is not a usize");
        if (rhsTypeID != TYPE_USIZE) todo_with_msg("indexed access, RHS is not a usize");
        let underlyingID: usize = lhsType.typeIndex;
        let underlyingType: &mut Type = getTypeByID(underlyingID);
        assert(underlyingType.getID() == underlyingID);
        return newTCStateType(underlyingID);
    }

    func typeCheckExprLogical(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprLogical");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.isLogical());
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let lhsType: &mut Type = getTypeByID(lhsState.getType());
        let rhsType: &mut Type = getTypeByID(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            todo_with_msg("logical type mismatch");
        }
        if (!lhsType.isBoolean()) {
            todo_with_msg("logical expects bool");
        }
        let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        return newTCStateType(t.getID());
    }

    func typeCheckExprBitwise(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprBitwise");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.isBitwise());
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        let lhsType: &mut Type = getTypeByID(lhsState.getType());
        let rhsType: &mut Type = getTypeByID(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            todo_with_msg("bitwise type mismatch");
        }
        if (!lhsType.isInteger()) {
            this.emergencyPrint(expr.span);
            todo_with_msg("bitwise is only supported for integers");
        }
        return lhsState;
    }

    func typeCheckExprAssign(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprAssign");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert(expr.kind == EXPR_BINARY);
        assert(expr.op == BIN_ASSIGN);
        let lhsExpr: &mut ParsedExpr = getExprByID(expr.lhs);
        if (!lhsExpr.isLValue()) {
            this.emergencyPrint(lhsExpr.span);
            todo_with_msg("invalid l-value");
        }
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        if (!lhsState.isType()) todo_with_msg("assignment LHS is not a type");
        if (!rhsState.isType())
            rhsState = this.inferTypeOntoExpr(expr.rhs, lhsState.getType());
        let lhsType: &mut Type = getTypeByID(lhsState.getType());
        let rhsType: &mut Type = getTypeByID(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            todo_with_msg("assignment type mismatch");
        }
        return rhsState;
    }

    func typeCheckExprMemberAccess(&mut this, dotID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprMemberAccess");
        let expr: &mut ParsedExpr = getExprByID(dotID);
        assert_with_msg(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert(expr.op == BIN_DOT);
        mut instance: TCState = this.typeCheckExpr(expr.lhs, scopes);
        if (instance.isError()) return instance;
        let instanceTypeID: usize = instance.getType();
        let instanceType: &mut Type = getTypeByID(instanceTypeID);
        mut underlying: &mut Type = instanceType;
        if (!underlying.isStruct()) underlying = instanceType.getUnderlyingType(true);
        mut lookup: TypeLookup = this.lookup.getTypeLookupForType(underlying);
        if (underlying.isStruct()) {
            assert(lookup.isStruct());
            let structLookup: &mut StructLookup = &mut *lookup.asStruct();
            let rhs: &mut ParsedExpr = getExprByID(expr.rhs);
            if (rhs.kind == EXPR_NAME) {
                if (!structLookup.getReadyState(STRUCT_FIELDS_COMPLETE))
                    return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                let fieldName: Token = rhs.origToken;
                mut field: VariableLookup = blank;
                if (!structLookup.resolveFieldByName(&fieldName, &mut field)) unsafe {
                    let loc: String = fieldName.getLocation();
                    let structName: String = structLookup.name.toString();
                    let structLoc: String = structLookup.name.getLocation();
                    let n: String = fieldName.content.toString();
                    fprintf(stderr,
                        "%s: %s: Struct `%s` has no field named `%s`.\n%s: %s: Struct declared here.\n",
                        loc.chars(), ERR_STR, structName.chars(), n.chars(), structLoc.chars(), NOTE_STR,
                    );
                    n.drop();
                    structLoc.drop();
                    structName.drop();
                    loc.drop();
                    return newTCStateFailure(ERROR_NO_SUCH_FIELD);
                }
                mut fieldState: TCState = field.typeState;
                assert_with_msg(fieldState.isSuccess(), "Expected valid field type");
                return fieldState;
            } else if (rhs.kind == EXPR_CALL) {
                if (!structLookup.getReadyState(STRUCT_SIGNATURE_COMPLETE))
                    return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                let methodName: Token = rhs.origToken;
                mut methods: MethodLookupList = structLookup.resolveMethodByName(&methodName);
                if (methods.length == 0) unsafe {
                    let loc: String = methodName.getLocation();
                    let structName: String = structLookup.name.toString();
                    let structLoc: String = structLookup.name.getLocation();
                    let n: String = methodName.content.toString();
                    fprintf(stderr,
                        "%s: %s: Struct `%s` has no method named `%s`.\n%s: %s: Struct declared here.\n",
                        loc.chars(), ERR_STR, structName.chars(), n.chars(), structLoc.chars(), NOTE_STR,
                    );
                    n.drop();
                    structLoc.drop();
                    structName.drop();
                    loc.drop();
                    return newTCStateFailure(ERROR_NO_SUCH_METHOD);
                }
                let callContext: &mut ArrayContext = &mut rhs.arrayContext;
                mut arguments: TCStateList = blank;
                for (mut i: usize = 0; i < callContext.elemLength; i = i + 1) {
                    let argID: usize = callContext.getElementAtIndex(i);
                    mut arg: TCState = this.typeCheckExpr(argID, scopes);
                    if (arg.isError()) return arg;
                    arguments.push(arg);
                }
                assert(arguments.length == callContext.elemLength);
                let callArgCount: usize = arguments.length + 1;
                for (mut i: usize = 0; i < methods.length; i = i + 1) {
                    let m: &mut MethodLookup = &mut *methods.at(i);
                    if (!m.getReadyState(METHOD_READY_TO_USE)) return newTCStateFailure(ERROR_LOOKUP_NOT_READY);
                    let hasThis: bool = !m.isStatic;
                    mut argCount: usize = m.params.length;
                    if (callArgCount != argCount) continue;
                    mut indexOffset: usize = 0;
                    if (hasThis) {
                        assert(m.params.length != 0);
                        indexOffset = 1;
                        let thisParam: &mut VariableLookup = m.params.at(0);
                        mut thisParamState: TCState = thisParam.typeState;
                        assert_with_msg(thisParamState.isSuccess(), "Expected valid this parameter");
                        let paramType: &mut Type = getTypeByID(thisParamState.getType());
                        let instType: &mut Type = getTypeByID(instance.getType());
                        if (!instType.equals(paramType)) {
                            if (paramType.isPointer() && !instType.isPointer()) {
                                let under: &mut Type = paramType.getUnderlyingType(false);
                                assert_with_msg(instType.equals(under), "method call instance type doesn't match");
                                (*expr).lhs = getExprByID(expr.lhs).intoPointer();
                                mut patched: TCState = this.typeCheckExpr(expr.lhs, scopes);
                                assert_with_msg(patched.isSuccess(), "patched instance failed");
                                assert_with_msg(patched.isType(), "patched instance state is not a type");
                                assert_with_msg(getTypeByID(patched.getType()).equals(paramType), "patched instance type does not match");
                            } else {
                                this.emergencyPrint(rhs.span);
                                todo_with_msg("how can this happen");
                            }
                        }
                    }
                    // REVIEW: The index offset looks incorrect
                    for (mut j: usize = 0; j < argCount - indexOffset; j = j + 1) {
                        mut argState: &mut TCState = &mut *arguments.at(j);
                        let param: &mut VariableLookup = m.params.at(j + indexOffset);
                        let paramState: &mut TCState = &mut param.typeState;
                        assert_with_msg(paramState.isSuccess(), "Expected valid method parameter");
                        let paramType: &mut Type = getTypeByID(paramState.getType());
                        if (argState.wantsInfer()) {
                            let old: TCState = *argState;
                            *argState = this.inferTypeOntoExpr(callContext.getElementAtIndex(j), paramType.getID());
                            if (argState.isError()) {
                                *argState = old;
                                todo_with_msg("error when inferring type of param onto argument");
                            }
                            assert_with_msg(argState.isType(), "Did not infer type of param onto argument properly");
                        }
                        let argType: &mut Type = getTypeByID(argState.getType());
                        if (!argType.equals(paramType)) {
                            todo_with_msg("method arg mismatch");
                        }
                    }
                    // By this point, `m` fits all criteria for being called
                    // REVIEW: Do we want to make Overload selection smarter? Right now we only
                    //         pick the first match
                    (*rhs).lhs = m.globalID;
                    mut retType: TCState = m.returnType;
                    assert_with_msg(retType.isSuccess(), "Expected valid method return type");
                    return retType;
                }
                todo_with_msg("method call");
            } else {
                unreachable("Got non-field non-call RHS in the dot operation.");
            }
        } else {
            todo_with_msg("LHS of dot is sus");
        }
        todo_with_msg("member");
        return blank;
    }

    func checkIfInferIsNeeded(&mut this, lhsID: usize, lhsState: &mut TCState, rhsID: usize, rhsState: &mut TCState) -> TCState {
        trace("TypeChecker.checkIfInferIsNeeded");
        let lhsExpr: &mut ParsedExpr = getExprByID(lhsID);
        let rhsExpr: &mut ParsedExpr = getExprByID(rhsID);
        if (lhsState.isType() && rhsState.isType()) {
            return newTCStateSuccess();
        } else if (lhsState.isType() && !rhsState.isType()) {
            let lhsType: usize = lhsState.getType();
            *rhsState = this.inferTypeOntoExpr(rhsID, lhsType);
            return *rhsState;
        } else if (!lhsState.isType() && rhsState.isType()) {
            let rhsType: usize = rhsState.getType();
            *lhsState = this.inferTypeOntoExpr(lhsID, rhsType);
            return *lhsState;
        } else {
            return newTCStatePleaseInfer();
        }
        unreachable("Exhaustive handling of cases in checkIfInferIsNeeded");
        return blank;
    }

    func inferTypeOntoExpr(&mut this, exprID: usize, typeID: usize) -> TCState {
        trace("TypeChecker.inferTypeOntoExpr");
        let expr: &mut ParsedExpr = getExprByID(exprID);
        if (expr.typeState.isSuccess()) {
            let exprType: &mut Type = getTypeByID(expr.typeState.getType());
            let wantType: &mut Type = getTypeByID(typeID);
            if (!exprType.equals(wantType)) todo_with_msg("infer failed");
            return newTCStateType(typeID);
        }
        let typ: &mut Type = getTypeByID(typeID);
        if (expr.kind == EXPR_INT_LIT) {
            if (typ.isPointer()) {
                let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                let tid: TCState = newTCStateType(t.getID());
                (*expr).typeState = tid;
                return tid;
            } else if (typ.isInteger() || typ.isFloat()) {
                let tid: TCState = newTCStateType(typ.getID());
                (*expr).typeState = tid;
                return tid;
            } else unsafe {
                todo_with_msg("can't infer non-int non-float type onto int literal");
                return blank;
            }
        } else if (expr.kind == EXPR_CHAR_LIT) {
            if (typ.kind != TYPE_KIND_PRIMITIVE && typ.typeIndex != TYPE_CHAR)
                todo_with_msg("can't infer non-char type onto char literal");
            let tid: TCState = newTCStateType(typ.getID());
            (*expr).typeState = tid;
            return tid;
        } else if (expr.kind == EXPR_ARRAY_LIT) {
            if (!typ.isArray()) todo_with_msg("can't infer non-array type onto array literal");
            assert_with_msg(expr.arrayContext.elemLength > 0, "Got empty array literal");
            mut tid: TCState = this.inferTypeOntoExpr(expr.arrayContext.getElementAtIndex(0), typ.typeIndex);
            if (tid.isError()) return tid;
            (*expr).typeState = newTCStateType(typeID);
            return expr.typeState;
        } else if (expr.kind == EXPR_BLANK) {
            if (typ.isPrimitive())
                todo_with_msg("warning: typeof(blank) == primitive");
            else if (typ.isPointer())
                todo_with_msg("error: typeof(blank) == pointer, use null instead");
            let tid: TCState = newTCStateType(typ.getID());
            (*expr).typeState = tid;
            return tid;
        } else if (expr.kind == EXPR_BINARY) {
            if (expr.isArithmetic()) {
                mut tid: TCState = this.inferTypeOntoExpr(expr.lhs, typeID);
                if (tid.isError()) return tid;
                tid = this.inferTypeOntoExpr(expr.rhs, typeID);
                if (tid.isError()) return tid;
                (*expr).typeState = newTCStateType(typeID);
                return expr.typeState;
            } else {
                todo_with_msg("inferTypeOntoExpr for non-arith binary");
                return blank;
            }
        } else if (expr.kind == EXPR_UNARY) {
            if (expr.op == UNARY_DEREF) {
                let newType: &mut Type = newType(TYPE_KIND_POINTER, typeID);
                mut tid: TCState = this.inferTypeOntoExpr(expr.lhs, newType.getID());
                if (tid.isError()) return tid;
                (*expr).typeState = newTCStateType(typeID);
                return expr.typeState;
            } else if (expr.op == UNARY_REF) {
                if (!typ.isPointer()) todo_with_msg("can't infer non-pointer type onto reference");
                let underlying: &mut Type = typ.getUnderlyingType(false);
                mut tid: TCState = this.inferTypeOntoExpr(expr.lhs, underlying.getID());
                if (tid.isError()) return tid;
                (*expr).typeState = newTCStateType(typeID);
                return expr.typeState;
            } else if (expr.op == UNARY_MINUS) {
                // -expr
                // typeof(expr) == typeof(-expr)
                if (!typ.isSignedInteger() && !typ.isFloat()) todo_with_msg("infer unary not non-int non-float");
                mut tid: TCState = this.inferTypeOntoExpr(expr.lhs, typeID);
                if (tid.isError()) return tid;
                assert_with_msg(tid.isType(), "infer non-error expected to be a type");
                let subType: &mut Type = getTypeByID(tid.getType());
                assert_with_msg(subType.equals(typ), "Infer: SubExpr of UNARY_MINUS is expected to have same type as Expr");
                (*expr).typeState = newTCStateType(typeID);
                return expr.typeState;
            } else if (expr.op == UNARY_NOT) {
                todo_with_msg("unary not infer");
                return blank;
            } else {
                unreachable("Exhaustive handling of unary ops in inferTypeOntoExpr");
                return blank;
            }
        } else if (expr.kind == EXPR_NULL) {
            if (!typ.isPointer()) todo_with_msg("tried to infer non-ptr to null");
            (*expr).typeState = newTCStateType(typeID);
            return expr.typeState;
        } else unsafe {
            this.emergencyPrint(expr.span);
            todo_with_msg("unhandled case in inferTypeOntoExpr");
            return blank;
        }
    }

    func typeCheckExprArithmetic(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprArithmetic");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert_with_msg(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert_with_msg(expr.isArithmetic(), "Expr expected to be arithmetic");
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        mut maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &mut lhsState, expr.rhs, &mut rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in arith");
        }
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &mut Type = getTypeByID(lhsState.getType());
        let rhsType: &mut Type = getTypeByID(rhsState.getType());
        mut resultState: TCState = blank;
        if (lhsType.equals(rhsType)) {
            if (lhsType.isStruct() || lhsType.isArray()) {
                todo_with_msg("can't do arithmetics on structs or arrays");
            } else if (lhsType.isPointer()) {
                let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_USIZE);
                resultState = newTCStateType(t.getID());
            } else {
                assert_with_msg(lhsType.getID() == rhsType.getID(), "Arithmetic LHS and RHS are different types");
                resultState = newTCStateType(lhsType.getID());
            }
        } else if (lhsType.isPointer() && rhsType.isInteger()) {
            if (rhsType.typeIndex == TYPE_USIZE) {
                resultState = lhsState;
            } else {
                todo_with_msg("ptr + non-usize");
            }
        } else if (lhsType.isInteger() && rhsType.isPointer()) {
            todo_with_msg("int + ptr");
        } else {
            this.emergencyPrint(expr.span);
            todo_with_msg("arith type mismatch");
        }
        return resultState;
    }

    func typeCheckExprComparison(&mut this, binID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckExprComparison");
        let expr: &mut ParsedExpr = getExprByID(binID);
        assert_with_msg(expr.kind == EXPR_BINARY, "Expr expected to be Binary");
        assert_with_msg(expr.isComparison(), "Expr expected to be comparison");
        mut lhsState: TCState = this.typeCheckExpr(expr.lhs, scopes);
        mut rhsState: TCState = this.typeCheckExpr(expr.rhs, scopes);
        if (lhsState.isError()) return lhsState;
        if (rhsState.isError()) return rhsState;
        mut maybeInfer: TCState = this.checkIfInferIsNeeded(expr.lhs, &mut lhsState, expr.rhs, &mut rhsState);
        if (maybeInfer.isError()) {
            todo_with_msg("couldn't infer in comp");
        }
        if (maybeInfer.wantsInfer()) return maybeInfer;
        let lhsType: &mut Type = getTypeByID(lhsState.getType());
        let rhsType: &mut Type = getTypeByID(rhsState.getType());
        if (!lhsType.equals(rhsType)) {
            todo_with_msg("comp type mismatch");
        }
        if (lhsType.isStruct() || rhsType.isStruct()
            || lhsType.isArray() || rhsType.isArray()) {
            todo_with_msg("report error, can't compare structs or arrays using == or similar.");
        }
        let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, TYPE_BOOL);
        return newTCStateType(t.getID());
    }

    func typeCheckTypeNode(&mut this, typeID: usize, scopes: &mut ScopeLookupList) -> TCState {
        trace("TypeChecker.typeCheckTypeNode");
        let typ: &mut ParsedTypeDecl = getTypeDeclByID(typeID);
        if (typ.typeState.isSuccess()) return typ.typeState;
        mut tid: usize = 0;
        if (typ.kind == PARSED_TYPE_REF) {
            mut under: TCState = this.typeCheckTypeNode(typ.underlyingID, scopes);
            if (under.isError()) return under;
            let underlyingType: usize = under.getType();
            let t: &mut Type = newType(TYPE_KIND_POINTER, underlyingType);
            tid = t.getID();
        } else if (typ.kind == PARSED_TYPE_ARRAY) {
            if (typ.arraySize == 0) todo_with_msg("0 elements in mah array");
            mut under: TCState = this.typeCheckTypeNode(typ.underlyingID, scopes);
            if (under.isError()) return under;
            let underlyingType: usize = under.getType();
            let t: &mut Type = newType(TYPE_KIND_ARRAY, underlyingType);
            (*t).arraySize = typ.arraySize;
            tid = t.getID();
        } else if (typ.kind == PARSED_TYPE_IDENT) {
            let name: Token = typ.nameTkn;
            mut typeLookup: TypeLookup = blank;
            if (!this.lookup.resolveTypeByName(this.currentModule, &name, &mut typeLookup)) unsafe {
                let loc: String = name.getLocation();
                let _n: String = name.content.toString();
                fprintf(stderr, "%s: %s: Use of undeclared type identifier `%s`.\n", loc.chars(), ERR_STR, _n.chars());
                mut alternatives: TypeLookupList = this.lookup.searchAllModulesForTypeName(&name);
                for (mut i: usize = 0; i < alternatives.length; i = i + 1) {
                    let t: &mut TypeLookup = &mut *alternatives.at(i);
                    if (t.isStruct()) {
                        let s: &mut StructLookup = t.asStruct();
                        let loc: String = s.name.getLocation();
                        fprintf(stderr, "%s: %s: A struct with that name is located here. Import the module to use it.\n", loc.chars(), NOTE_STR);
                        loc.drop();
                    }
                }
                _n.drop();
                loc.drop();
                return newTCStateFailure(ERROR_NO_SUCH_IDENTIFIER);
            }
            if (typeLookup.isStruct()) {
                let structLookup: &mut StructLookup = &mut *typeLookup.asStruct();
                let _tid: usize = structLookup.typeID;
                assert_with_msg(_tid != 0, "Ready to use Struct Lookup has Type ID 0");
                let t: &mut Type = getTypeByID(_tid);
                assert_with_msg(t.isStruct(), "Struct Lookup links to non-Struct type");
                tid = t.getID();
            } else {
                todo_with_msg("check ident");
            }
        } else if (typ.kind == PARSED_TYPE_BUILTIN) {
            let id: usize = typ.getID();
            mut typeID: usize = 0;
            if (id == PARSED_TYPE_INVALID) typeID = TYPE_INVALID;
            else if (id == PARSED_TYPE_UNKNOWN) typeID = TYPE_UNKNOWN;
            else if (id == PARSED_TYPE_NONE) typeID = TYPE_NONE;
            else if (id == PARSED_TYPE_ANY) typeID = TYPE_ANY;
            else if (id == PARSED_TYPE_I8) typeID = TYPE_I8;
            else if (id == PARSED_TYPE_I16) typeID = TYPE_I16;
            else if (id == PARSED_TYPE_I32) typeID = TYPE_I32;
            else if (id == PARSED_TYPE_I64) typeID = TYPE_I64;
            else if (id == PARSED_TYPE_U8) typeID = TYPE_U8;
            else if (id == PARSED_TYPE_U16) typeID = TYPE_U16;
            else if (id == PARSED_TYPE_U32) typeID = TYPE_U32;
            else if (id == PARSED_TYPE_U64) typeID = TYPE_U64;
            else if (id == PARSED_TYPE_USIZE) typeID = TYPE_USIZE;
            else if (id == PARSED_TYPE_BOOL) typeID = TYPE_BOOL;
            else if (id == PARSED_TYPE_CHAR) typeID = TYPE_CHAR;
            else if (id == PARSED_TYPE_F32) typeID = TYPE_F32;
            else if (id == PARSED_TYPE_F64) typeID = TYPE_F64;
            else {
                this.emergencyPrint(typ.span);
                todo_with_msg("handle other parsed -> checked type conversion");
            }
            let t: &mut Type = newType(TYPE_KIND_PRIMITIVE, typeID);
            tid = t.getID();
        } else {
            todo_with_msg("unknown type kind");
        }
        let state: TCState = newTCStateType(tid);
        (*typ).typeState = state;
        return state;
    }
}

func newTypeChecker() -> TypeChecker {
    unsafe {
        return TypeChecker {
            isComptimeContext: false,
            currentModule: 0,
            currentFunction: null,
            currentMethod: null,
            lookup: blank,
        };
    }
}
