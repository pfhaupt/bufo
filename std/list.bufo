
import "type_info.bufo";
import "libc.bufo";
import "prelude.bufo";

struct GAF_List {
    elements: Any;
    length: usize;
    capacity: usize;
    type: TypeInfo;
    type_size: usize;
}

func new_GAF_List(ti: TypeInfo) -> GAF_List {
    return GAF_List {
        elements: null,
        length: 0,
        capacity: 0,
        type: ti,
        type_size: get_size(&ti),
    };
}

func enumerate(this: &GAF_List, fn: func (usize, Data)) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(i, get_ref(this, i));
    }
}
func enumerate(this: &GAF_List, fn: func (usize, Data, Any), arg: Any) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(i, get_ref(this, i), arg);
    }
}
func foreach(this: &GAF_List, fn: func (Data)) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(get_ref(this, i));
    }
}
func foreach(this: &GAF_List, fn: func (Data, Any), arg: Any) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(get_ref(this, i), arg);
    }
}
func map(list: &GAF_List, fn: func (Data) -> Data){
    if (list.length == 0) return;
    let elements: Any = null;
    let size: usize = list.type_size;
    
    let ret = fn(get_ref(list, 0));
    // check if fn returns a type different than the one stored in list
    // if so, allocate a new array
    // if not, i can reuse list.elements
    if (!equals(&ret.info, &list.type)){
        size = get_size(&ret.info);
        elements = C::malloc(size*list.capacity);
    }
    else {
        elements = list.elements; 
    }
    // copy the first element
    C::memcpy(
        elements as &usize,
        ret.ptr,
        size
    );
    
    // iterate over the list starting from 1
    // and apply fn to all the elements
    for (let i: usize = 1; i < list.length; i = i + 1) {
        ret = fn(get_ref(list, i));
        C::memcpy(
            elements as &usize + i*size,
            ret.ptr ,
            size
        );
    }
    
    // update list only if the type got changed
    if (elements != list.elements){
        C::free(list.elements);
        list.type_size = size;
        list.type = ret.info;
        list.elements = elements;
    }
}

func push(list: &GAF_List, elem: Data) {
    if (!equals(&list.type, &elem.info)) {
        let want = get_name(&list.type);
        let got = get_name(&elem.info);
        C::fprintf(stderr, "got:  %.*s\n", got.len, got.start);
        C::fprintf(stderr, "want: %.*s\n", want.len, want.start);
        C::fprintf(stderr, "GAF_List.push: Attempted to push invalid element\n");
        C::exit(1);
    }
    if (list.length >= list.capacity) {
        let new_cap: usize = list.capacity * 2;
        if (new_cap == 0) new_cap = 32;
        list.elements = C::realloc(list.elements, new_cap * list.type_size);
        assert(list.elements != null, "GAF_List.push: Could not allocate memory");
        list.capacity = new_cap;
    }
    C::memcpy(list.elements as &usize + list.length * list.type_size, elem.ptr, list.type_size);
    list.length = list.length + 1;
}
func filter(this: &GAF_List, fn: func (Data) -> bool) {
    let i: usize = 0;
    let c: usize = 0;
    for (i= 0; i < this.length; i = i + 1) {
        let ret = fn(get_ref(this, i));
        if(ret){
            if (i!=c){
                C::memcpy(
                    this.elements as &usize + c * this.type_size,
                    this.elements as &usize + i * this.type_size,
                    this.type_size
                );
            }
            c=c+1;
        }
    }
    this.length = c;
}
func pop(list: &GAF_List) {
    pop(list, null);
}

func pop(list: &GAF_List, dst: Any) {
    assert(list.length > 0, "GAF_List.pop: Attempted to pop from empty list");
    list.length = list.length - 1;
    if (dst != null) {
        let elem = list.elements as &usize + list.length * list.type_size;
        C::memcpy(dst, elem, list.type_size);
    }
}

func get_ref(list: &GAF_List, index: usize) -> Data {
    assert(index < list.length, "GAF_List.get_ref: Out of bounds access");
    return Data {
        ptr: get_ref_raw(list, index),
        info: list.type
    };
}

func get_ref_raw(list: &GAF_List, index: usize) -> Any {
    assert(index < list.length, "GAF_List.get_ref_raw: Out of bounds access");
    return (list.elements as &usize + index * list.type_size) as usize as Any;
}

func swap_remove(list: &GAF_List, index: usize) {
    assert(index < list.length, "GAF_List.swap_remove: Out of bounds removal");
    let dst = list.elements as &usize + index * list.type_size;
    let src = list.elements as &usize + (list.length - 1) * list.type_size;
    C::memcpy(dst, src, list.type_size);
    list.length = list.length - 1;
}

// Helper function to swap two elements in the list
func swap_elements(list: &GAF_List, i: usize, j: usize, swap_buffer:Any) {
    if (i == j) return;
    let size = list.type_size;
    let a = list.elements as &usize + i * size;
    let b = list.elements as &usize + j * size;
    C::memcpy(swap_buffer, a, size);
    C::memcpy(a, b, size);
    C::memcpy(b, swap_buffer, size);
}

/// Insertion sort, stable, in‑loco
/// fn_compare(a, b) returns a < b (ascending order sort)
func sort(this: &GAF_List, fn_compare: func (Data, Data) -> bool) {
    let size = this.type_size;
    let temp = C::malloc(size); // temporary buffer
    for (let i:usize = 1; i < this.length; i = i + 1) {
        let current_ptr = this.elements as &usize + i * size;
        C::memcpy(temp, current_ptr, size);
        let temp_data = Data { ptr: temp, info: this.type };

        let j = i;
        while (j > 0) {
            let prev_ptr = this.elements as &usize + (j - 1) * size;
            let prev_data = Data { ptr: prev_ptr, info: this.type };
            if (fn_compare(prev_data, temp_data)) {
                break;
            }
            let dest = this.elements as &usize + j * size;
            C::memcpy(dest, prev_ptr, size);
            j = j - 1;
        }
        let dest = this.elements as &usize + j * size;
        C::memcpy(dest, temp, size);
    }
    C::free(temp);
}

func qs_range(this: &GAF_List, low: usize, high: usize, fn_compare: func (Data, Data) -> bool, swap_buf:Any) {
    if (low >= high) return;
    
    // Set the pivot as the last element in the array
    let pivot_ptr = this.elements as &usize + high * this.type_size;
    let pivot_data = Data { ptr: pivot_ptr, info: this.type };

    //Partition
    let i = low; 
    for (let j = low; j < high; j = j + 1) {
        let cur_ptr = this.elements as &usize + j * this.type_size;
        let cur_data = Data { ptr: cur_ptr, info: this.type };
        if (fn_compare(cur_data, pivot_data)) {
            if (i != j) {
                swap_elements(this, i, j, swap_buf);
            }
            i = i + 1;
        }
    }

    if (i != high) {
        swap_elements(this, i, high, swap_buf);
    }

    if (i > 0) qs_range(this, low, i - 1, fn_compare, swap_buf);
    qs_range(this, i + 1, high, fn_compare, swap_buf);
}

/// Quick sort, not stable, in‑loco
/// fn_compare(a, b) returns a < b (ascending order sort)
func quick_sort(this: &GAF_List, fn_compare: func (Data, Data) -> bool) {
    if (this.length <= 1) return;
    let buf = C::malloc(this.type_size); // temporary buffer used for swaps
    qs_range(this, 0, this.length - 1, fn_compare, buf);
    C::free(buf);
}