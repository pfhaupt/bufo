
import "type_info.bufo";
import "libc.bufo";
import "prelude.bufo";

struct GAF_List {
    elements: Any;
    length: usize;
    capacity: usize;
    type: TypeInfo;
    type_size: usize;
}

func new_GAF_List(ti: TypeInfo) -> GAF_List {
    return GAF_List {
        elements: null,
        length: 0,
        capacity: 0,
        type: ti,
        type_size: get_size(&ti),
    };
}

func enumerate(this: &GAF_List, fn: func (usize, Data)) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(i, get_ref(this, i));
    }
}
func enumerate(this: &GAF_List, fn: func (usize, Data, Any), arg: Any) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(i, get_ref(this, i), arg);
    }
}
func foreach(this: &GAF_List, fn: func (Data)) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(get_ref(this, i));
    }
}
func foreach(this: &GAF_List, fn: func (Data, Any), arg: Any) {
    for (let i: usize = 0; i < this.length; i = i + 1) {
        fn(get_ref(this, i), arg);
    }
}
func map(list: &GAF_List, fn: func (Data) -> Data){
    if (list.length == 0) return;
    let elements: Any = null;
    let size: usize = list.type_size;
    
    let ret = fn(get_ref(list, 0));
    // check if fn returns a type different than the one stored in list
    // if so, allocate a new array
    // if not, i can reuse list.elements
    if (!equals(&ret.info, &list.type)){
        size = get_size(&ret.info);
        elements = C::malloc(size*list.capacity);
    }
    else {
        elements = list.elements; 
    }
    // copy the first element
    C::memcpy(
        elements as &usize,
        ret.ptr,
        size
    );
    
    // iterate over the list starting from 1
    // and apply fn to all the elements
    for (let i: usize = 1; i < list.length; i = i + 1) {
        ret = fn(get_ref(list, i));
        C::memcpy(
            elements as &usize + i*size,
            ret.ptr ,
            size
        );
    }
    
    // update list only if the type got changed
    if (elements != list.elements){
        C::free(list.elements);
        list.type_size = size;
        list.type = ret.info;
        list.elements = elements;
    }
}

func push(list: &GAF_List, elem: Data) {
    if (!equals(&list.type, &elem.info)) {
        let want = get_name(&list.type);
        let got = get_name(&elem.info);
        C::fprintf(stderr, "got:  %.*s\n", got.len, got.start);
        C::fprintf(stderr, "want: %.*s\n", want.len, want.start);
        C::fprintf(stderr, "GAF_List.push: Attempted to push invalid element\n");
        C::exit(1);
    }
    if (list.length >= list.capacity) {
        let new_cap: usize = list.capacity * 2;
        if (new_cap == 0) new_cap = 32;
        list.elements = C::realloc(list.elements, new_cap * list.type_size);
        assert(list.elements != null, "GAF_List.push: Could not allocate memory");
        list.capacity = new_cap;
    }
    C::memcpy(list.elements as &usize + list.length * list.type_size, elem.ptr, list.type_size);
    list.length = list.length + 1;
}
func filter(this: &GAF_List, fn: func (Data) -> bool) {
    let i: usize = 0;
    let c: usize = 0;
    for (i= 0; i < this.length; i = i + 1) {
        let ret = fn(get_ref(this, i));
        if(ret){
            if (i!=c){
                C::memcpy(
                    this.elements as &usize + c * this.type_size,
                    this.elements as &usize + i * this.type_size,
                    this.type_size
                );
            }
            c=c+1;
        }
    }
    this.length = c;
}
func pop(list: &GAF_List) {
    pop(list, null);
}

func pop(list: &GAF_List, dst: Any) {
    assert(list.length > 0, "GAF_List.pop: Attempted to pop from empty list");
    list.length = list.length - 1;
    if (dst != null) {
        let elem = list.elements as &usize + list.length * list.type_size;
        C::memcpy(dst, elem, list.type_size);
    }
}

func get_ref(list: &GAF_List, index: usize) -> Data {
    assert(index < list.length, "GAF_List.get_ref: Out of bounds access");
    return Data {
        ptr: get_ref_raw(list, index),
        info: list.type
    };
}

func get_ref_raw(list: &GAF_List, index: usize) -> Any {
    assert(index < list.length, "GAF_List.get_ref_raw: Out of bounds access");
    return (list.elements as &usize + index * list.type_size) as usize as Any;
}

func swap_remove(list: &GAF_List, index: usize) {
    assert(index < list.length, "GAF_List.swap_remove: Out of bounds removal");
    let dst = list.elements as &usize + index * list.type_size;
    let src = list.elements as &usize + (list.length - 1) * list.type_size;
    C::memcpy(dst, src, list.type_size);
    list.length = list.length - 1;
}

