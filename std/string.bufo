import "libc.bufo";
import "prelude.bufo";
import "substr.bufo";

let HEX_CHAR: [char; 16] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
struct String {
    buffer: &char;
    length: usize;
    capacity: usize;

    func len(&this) -> usize {
        return this.length;
    }
    func hash(&this) -> usize {
        let hash: usize = 5381;
        for (let i: usize = 0; i < this.length; i = i + 1) {
            hash = (shiftLeft(hash, 5) + hash) + (this.getChar(i) as usize);
        }
        return hash;
    }

    func toAbsolutePath(&this) -> String {
        let buf: &char = calloc(1024, 1);
        assert(buf != null);
        let abs: &char = _fullpath(buf, this.chars(), 1024);
        assert(abs != null, "Could not get absolute path");
        let s: String = newStringFromStrLit(buf);
        free(buf);
        return s;
    }

    func getChar(&this, index: usize) -> char {
        assert(index <= this.length, "Index out of bounds for String.getChar()");
        return *(this.buffer + index);
    }

    func drop(&this) {
        free(this.buffer);
    }
    func copy(&this) -> String {
        let bfr: Any = calloc(this.capacity, sizeof char);
        assert(bfr != null, "Could not copy String");
        let _bfr: Any = memcpy(bfr, this.buffer, this.capacity);
        assert(_bfr != null);
        assert(bfr == _bfr);
        return String {
            buffer: bfr,
            length: this.length,
            capacity: this.capacity,
        };
    }
    func resize(&this, newCap: usize) {
        if (newCap < 256) newCap = 256;
        let old: &char = this.buffer;
        this.buffer = calloc(newCap, sizeof char);
        assert(this.buffer != null, "Could not resize String");
        memcpy(this.buffer, old, this.length);
        free(old);
        this.capacity = newCap;
    }
    func chars(&this) -> &char {
        return this.buffer;
    }
    func print(&this) {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            printf("%c", *(this.buffer + i));
        }
    }
    func asSubStr(&this) -> SubStr {
        return this.substring(0, this.length);
    }
    func substring(&this, start: usize, end: usize) -> SubStr {
        return newSubStrOfString(this, start, end);
    }
    func pushNumber(&this, num: usize) {
        let bfr: [char; 50] = ['\0'; 50];
        let length: usize = snprintf(null, 0, "%llu", num);
        assert(length < 50, "Buffer Overflow in String.pushNumber()");
        snprintf(&bfr, length + 1, "%llu", num);
        for (let i: usize = 0; i < length; i = i + 1) {
            this.pushChar(bfr[i]);
        }
    }
    func pushNumberAsHex(&this, num: usize) {
        let bfr: [char; 50] = ['\0'; 50];
        let length: usize = snprintf(null, 0, "0x%llX", num);
        assert(length < 50, "Buffer Overflow in String.pushNumberAsHex()");
        snprintf(&bfr, length + 1, "0x%llX", num);
        for (let i: usize = 0; i < length; i = i + 1) {
            this.pushChar(bfr[i]);
        }
    }
    func pushI64(&this, i: i64) {
        if (i < 0) {
            this.pushChar('-');
            i = -i;
        }
        this.pushNumber(i as usize);
    }
    func pushChar(&this, ch: char) {
        if (this.length >= this.capacity || this.capacity < 256) {
            this.resize(2 * this.capacity);
        }
        *(this.buffer + this.length * sizeof char) = ch;
        this.length = this.length + 1;
    }
    func pushHex(&this, hex: u8) {
        let lower: u8 = hex % 16;
        let upper: u8 = (hex / 16) % 16;
        assert(lower < 16);
        assert(upper < 16);
        this.pushChar('\\');
        this.pushChar('x');
        this.pushChar(HEX_CHAR[upper as usize]);
        this.pushChar(HEX_CHAR[lower as usize]);
    }
    func pushSubStr(&this, sub: &SubStr) {
        for (let i: usize = 0; i < sub.len(); i = i + 1) {
            let ch: char = sub.getChar(i);
            this.pushChar(ch);
        }
    }
    func pushString(&this, s: &String) {
        for (let i: usize = 0; i < s.len(); i = i + 1) {
            let ch: char = s.getChar(i);
            this.pushChar(ch);
        }
    }
    func pushStr(&this, s: &char) {
        let _len: usize = strlen(s);
        for (let i: usize = 0; i < _len; i = i + 1) {
            let ch: char = *(s + i);
            this.pushChar(ch);
        }
    }
    func isNumber(&this) -> bool {
        for (let i: usize = 0; i < this.length; i = i + 1) {
            let ch: char = this.getChar(i);
            if (ch == '\0') {
                break;
            }
            if (!isNumeric(ch)) {
                return false;
            }
        }
        // Empty string is not a number
        return this.length > 0;
    }
    func toI64(&this) -> i64 {
        assert(this.isNumber(), "not a number");
        let val: i64 = 0;
        for (let i: usize = 0; i < this.length - 1; i = i + 1) {
            let ch: char = this.getChar(i);
            let digit: i64 = (ch - '0') as i64;
            val = 10 * val + digit;
        }
        return val;
    }
    func toU64(&this) -> u64 {
        assert(this.isNumber(), "not a number");
        let val: u64 = 0;
        for (let i: usize = 0; i < this.length; i = i + 1) {
            let ch: char = this.getChar(i);
            let digit: u64 = (ch - '0') as u64;
            val = 10 * val + digit;
        }
        return val;
    }
    func equals(&this, other: &String) -> bool {
        if (this.length != other.length) return false;
        return this.asSubStr().equals(&other.asSubStr());
    }
}

func newString() -> String {
    let cap: usize = 16;
    let _m: Any = calloc(cap, sizeof char);
    let buff: &char = &*_m;
    return String {
        buffer: buff,
        length: 0,
        capacity: 16
    };
}

func newStringFromStrLit(s: &char) -> String {
    let len: usize = strlen(s);
    let buff: &char = calloc(len + 1, sizeof char);
    assert(buff != null);
    memcpy(buff, s, len);
    return String {
        buffer: buff as &char,
        length: len,
        capacity: len
    };
}

func canReadFileToString(path: &char, source: &String) -> bool {
    // `b` needed because otherwise `\r` would be dropped, leading to wrong Spans
    let file: Any = fopen(path, "rb");
    if (file == null) {
        return false;
    }
    let buf: [char; 1024] = ['\0'; 1024];
    while (true) {
        let size: usize = fread(&buf, 1, 1024, file);
        if (size == 0) {
            break;
        }
        for (let i: usize = 0; i < size; i = i + 1) {
            source.pushChar(buf[i]);
        }
    }
    assert(fclose(file) == 0);
    return true;
}

func readFileToString(path: &char) -> String {
    let s: String = newString();
    // `b` needed because otherwise `\r` would be dropped, leading to wrong Spans
    let file: Any = fopen(path, "rb");
    if (file == null) {
        fprintf(stderr, "error: Could not open file `%s`.\n", path);
        exit(1);
    }
    let buf: [char; 1024] = ['\0'; 1024];
    while (true) {
        let size: usize = fread(&buf, 1, 1024, file);
        if (size == 0) {
            break;
        }
        for (let i: usize = 0; i < size; i = i + 1) {
            s.pushChar(buf[i]);
        }
    }
    assert(fclose(file) == 0);
    return s;
}

func writeStringToFile(path: &char, s: String) {
    // `b` needed because otherwise `\r` would be dropped, leading to wrong Spans
    let file: Any = fopen(path, "wb");
    if (file == null) {
        fprintf(stderr, "error: Could not open file `%s`.\n", path);
        exit(1);
    }
    let size: usize = fwrite(s.buffer, 1, s.length, file);
    assert(fclose(file) == 0);
}
